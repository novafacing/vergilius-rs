#include <stdint.h>

// 0x0 (0) bytes
struct _LDRP_LOAD_CONTEXT

{};

// 0x0 (0) bytes
struct _VERIFIER_SHARED_EXPORT_THUNK

{};

// 0x20 (32) bytes
struct _VF_TARGET_ALL_SHARED_EXPORT_THUNKS {
  struct _VERIFIER_SHARED_EXPORT_THUNK *SharedExportThunks; // offset: 0x0 (0)
  struct _VERIFIER_SHARED_EXPORT_THUNK
      *PoolSharedExportThunks; // offset: 0x8 (8)
  struct _VERIFIER_SHARED_EXPORT_THUNK
      *OrderDependentSharedExportThunks; // offset: 0x10 (16)
  struct _VERIFIER_SHARED_EXPORT_THUNK
      *XdvSharedExportThunks; // offset: 0x18 (24)
};

// 0x0 (0) bytes
struct _ACTIVATION_CONTEXT_DATA

{};

// 0x0 (0) bytes
struct __WIL__WNF_USER_SUBSCRIPTION

{};

// 0x0 (0) bytes
struct _IOMMU_DMA_DOMAIN

{};

// 0x0 (0) bytes
struct _CALLBACK_OBJECT

{};

typedef uint8_t UCHAR;

typedef uint64_t ULONGLONG;

typedef void VOID;

// 0x0 (0) bytes
struct _PCW_INSTANCE

{};

// 0x0 (0) bytes
struct _PCW_BUFFER

{};

// 0x0 (0) bytes
struct _PCW_REGISTRATION

{};

// 0x0 (0) bytes
struct _KTMNOTIFICATION_PACKET

{};

// 0x0 (0) bytes
struct _AWEINFO

{};

// 0x0 (0) bytes
struct _MI_SLAB_ALLOCATOR_ENTRY

{};

// 0x0 (0) bytes
struct _MI_ZERO_THREAD_CONTEXT

{};

// 0x0 (0) bytes
struct wil_StagingConfig

{};

typedef int32_t HRESULT;

typedef uint16_t USHORT;

// 0x0 (0) bytes
struct _TP_CALLBACK_INSTANCE

{};

// 0x0 (0) bytes
struct _ACTIVATION_CONTEXT

{};

// 0x0 (0) bytes
struct _TP_CLEANUP_GROUP

{};

// 0x0 (0) bytes
struct _TP_POOL

{};

typedef uint32_t ULONG;

// 0xc (12) bytes
struct _RTL_FEATURE_CONFIGURATION {
  ULONG FeatureId;               // offset: 0x0 (0)
  ULONG Priority : 4;            // offset: 0x4 (4)
  ULONG EnabledState : 2;        // offset: 0x4 (4)
  ULONG IsWexpConfiguration : 1; // offset: 0x4 (4)
  ULONG HasSubscriptions : 1;    // offset: 0x4 (4)
  ULONG Variant : 6;             // offset: 0x4 (4)
  ULONG VariantPayloadKind : 2;  // offset: 0x4 (4)
  ULONG VariantPayload;          // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct wil_details_StagingConfigHeaderProperties {
  ULONG ignoreServiceState : 1; // offset: 0x0 (0)
  ULONG ignoreUserState : 1;    // offset: 0x0 (0)
  ULONG ignoreTestState : 1;    // offset: 0x0 (0)
  ULONG ignoreVariants : 1;     // offset: 0x0 (0)
  ULONG unused : 28;            // offset: 0x0 (0)
};

// 0xc (12) bytes
struct wil_details_StagingConfigFeature {
  ULONG featureId;            // offset: 0x0 (0)
  ULONG changedInSession : 1; // offset: 0x4 (4)
  ULONG isVariantConfig : 1;  // offset: 0x4 (4)
  ULONG unused1 : 6;          // offset: 0x4 (4)
  ULONG serviceState : 2;     // offset: 0x4 (4)
  ULONG userState : 2;        // offset: 0x4 (4)
  ULONG testState : 2;        // offset: 0x4 (4)
  ULONG unused2 : 2;          // offset: 0x4 (4)
  ULONG unused3 : 8;          // offset: 0x4 (4)
  ULONG variant : 6;          // offset: 0x4 (4)
  ULONG payloadKind : 2;      // offset: 0x4 (4)
  ULONG payload;              // offset: 0x8 (8)
};

// 0x4 (4) bytes
union wil_details_RecordedState {
  ULONG exchange;                               // offset: 0x0 (0)
  ULONG recordedDeviceUsage : 1;                // offset: 0x0 (0)
  ULONG recordedDevicePotential : 1;            // offset: 0x0 (0)
  ULONG recordedDeviceOpportunity : 1;          // offset: 0x0 (0)
  ULONG recordedDevicePotentialOpportunity : 1; // offset: 0x0 (0)
  ULONG recordedVariantDeviceUsage : 1;         // offset: 0x0 (0)
  ULONG recordedVariant : 6;                    // offset: 0x0 (0)
  ULONG unused : 21;                            // offset: 0x0 (0)
};

// 0x4 (4) bytes
union wil_details_ReportedState {
  ULONG exchange;                                // offset: 0x0 (0)
  ULONG queuedForReporting : 1;                  // offset: 0x0 (0)
  ULONG reportedDeviceUsage : 1;                 // offset: 0x0 (0)
  ULONG reportedDevicePotential : 1;             // offset: 0x0 (0)
  ULONG reportedDeviceOpportunity : 1;           // offset: 0x0 (0)
  ULONG reportedDevicePotentialOpportunity : 1;  // offset: 0x0 (0)
  ULONG usageCount : 9;                          // offset: 0x0 (0)
  ULONG usageCountRepresentsPotential : 1;       // offset: 0x0 (0)
  ULONG opportunityCount : 7;                    // offset: 0x0 (0)
  ULONG opportunityCountRepresentsPotential : 1; // offset: 0x0 (0)
  ULONG unused : 9;                              // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct wil_details_FeatureReportingCache {
  union wil_details_ReportedState reported; // offset: 0x0 (0)
  union wil_details_RecordedState recorded; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct wil_details_StagingConfigWnfStateName {
  ULONG Data[2]; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct wil_details_StagingConfigUsageTrigger {
  ULONG featureId;                                      // offset: 0x0 (0)
  struct wil_details_StagingConfigWnfStateName trigger; // offset: 0x4 (4)
  ULONG serviceReportingKind : 16;                      // offset: 0xc (12)
  ULONG isVariantConfig : 1;                            // offset: 0xc (12)
  ULONG unused : 15;                                    // offset: 0xc (12)
};

// 0x4 (4) bytes
struct _EXT_IOMMU_DEVICE_ID_GIC {
  ULONG LineNumber; // offset: 0x0 (0)
};

typedef int8_t CHAR;

// 0x8 (8) bytes
struct _EXT_IOMMU_DEVICE_ID_ACPI {
  const CHAR *ObjectName; // offset: 0x0 (0)
};

typedef uint16_t WCHAR;

// 0x18 (24) bytes
struct _RTL_SPLAY_LINKS {
  struct _RTL_SPLAY_LINKS *Parent;     // offset: 0x0 (0)
  struct _RTL_SPLAY_LINKS *LeftChild;  // offset: 0x8 (8)
  struct _RTL_SPLAY_LINKS *RightChild; // offset: 0x10 (16)
};

// 0x0 (0) bytes
struct _HAL_PMC_COUNTERS

{};

// 0x0 (0) bytes
struct _SCSI_REQUEST_BLOCK

{};

// 0x0 (0) bytes
struct _DEVICE_NODE_IOMMU_EXTENSION

{};

// 0x0 (0) bytes
struct _ETW_EVENT_CALLBACK_CONTEXT

{};

// 0x0 (0) bytes
struct _ETW_SOFT_RESTART_CONTEXT

{};

// 0x0 (0) bytes
struct _EX_TIMER

{};

// 0x0 (0) bytes
struct _ETW_STACK_CACHE

{};

// 0x0 (0) bytes
struct _ETW_PERFECT_HASH_FUNCTION

{};

// 0x8 (8) bytes
struct _ETW_PARTITION_CONTEXT {
  struct _EPARTITION *Partition; // offset: 0x0 (0)
};

// 0x0 (0) bytes
struct _EX_WNF_SUBSCRIPTION

{};

// 0x0 (0) bytes
struct _DBGKP_ERROR_PORT

{};

// 0x0 (0) bytes
struct _CI_NGEN_PATHS

{};

// 0x0 (0) bytes
struct _EXP_LICENSE_STATE

{};

// 0x10 (16) bytes
struct _PO_IRP_QUEUE {
  struct _IRP *CurrentIrp;     // offset: 0x0 (0)
  struct _IRP *PendingIrpList; // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _PO_IRP_MANAGER {
  struct _PO_IRP_QUEUE DeviceIrpQueue; // offset: 0x0 (0)
  struct _PO_IRP_QUEUE SystemIrpQueue; // offset: 0x10 (16)
};

// 0x0 (0) bytes
struct _ASSEMBLY_STORAGE_MAP

{};

// 0x0 (0) bytes
struct _JOB_NET_RATE_CONTROL

{};

// 0x0 (0) bytes
struct _PSP_STORAGE

{};

// 0x0 (0) bytes
struct _JOB_CPU_RATE_CONTROL

{};

// 0x0 (0) bytes
struct _JOB_NOTIFICATION_INFORMATION

{};

// 0x0 (0) bytes
struct _JOB_ACCESS_STATE

{};

typedef int16_t SHORT;

typedef int64_t LONGLONG;

// 0x8 (8) bytes
struct _ARBITER_ADD_RESERVED_PARAMETERS {
  struct _DEVICE_OBJECT *ReserveDevice; // offset: 0x0 (0)
};

// 0x0 (0) bytes
struct _PO_PROCESS_ENERGY_CONTEXT

{};

// 0x0 (0) bytes
struct _EPROCESS_QUOTA_BLOCK

{};

// 0x0 (0) bytes
struct _PAGEFAULT_HISTORY

{};

// 0x44 (68) bytes
struct _IO_APIC_REGISTERS {
  volatile ULONG RegisterIndex;  // offset: 0x0 (0)
  volatile ULONG Reserved1[3];   // offset: 0x4 (4)
  volatile ULONG RegisterValue;  // offset: 0x10 (16)
  volatile ULONG Reserved2[11];  // offset: 0x14 (20)
  volatile ULONG EndOfInterrupt; // offset: 0x40 (64)
};

// 0x10 (16) bytes
struct _HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS {
  volatile ULONGLONG SmallPagesInUseWithinLarge;  // offset: 0x0 (0)
  volatile ULONGLONG OpportunisticLargePageCount; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _RTL_AVL_TREE {
  struct _RTL_BALANCED_NODE *Root; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _HIVE_WRITE_WAIT_QUEUE {
  struct _ETHREAD *ActiveThread;      // offset: 0x0 (0)
  struct _HIVE_WAIT_PACKET *WaitList; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _TIME_FIELDS {
  SHORT Year;         // offset: 0x0 (0)
  SHORT Month;        // offset: 0x2 (2)
  SHORT Day;          // offset: 0x4 (4)
  SHORT Hour;         // offset: 0x6 (6)
  SHORT Minute;       // offset: 0x8 (8)
  SHORT Second;       // offset: 0xa (10)
  SHORT Milliseconds; // offset: 0xc (12)
  SHORT Weekday;      // offset: 0xe (14)
};

// 0x10 (16) bytes
struct _SLIST_ENTRY {
  struct _SLIST_ENTRY *Next; // offset: 0x0 (0)
};

typedef int32_t LONG;

// 0x4 (4) bytes
enum _MACHINE_CHECK_NESTING_LEVEL {

  McheckNormal = 0,
  McheckNmi = 1,
  McheckNestingLevels = 2
};

// 0x4 (4) bytes
enum _CM_SHARE_DISPOSITION {

  CmResourceShareUndetermined = 0,
  CmResourceShareDeviceExclusive = 1,
  CmResourceShareDriverExclusive = 2,
  CmResourceShareShared = 3
};

// 0x4 (4) bytes
enum _ETW_HEADER_TYPE {

  EtwHeaderTypeNative = 0,
  EtwHeaderTypeWow = 1,
  EtwHeaderTypeMax = 2
};

// 0x4 (4) bytes
enum _MI_AVAILABLE_PAGE_WAIT_TYPES {

  AvailablePagesWaitLow = 0,
  AvailablePagesWaitHigh = 1,
  AvailablePagesWaitVeryHigh = 2,
  AvailablePagesWaitMaximum = 3
};

// 0x4 (4) bytes
enum _PO_MODERN_SLEEP_ACTION {

  PoModernSleepActionGlobalActivatorsVeto = 0,
  PoModernSleepActionNonBlockingPhases = 1,
  PoModernSleepActionForceIdle = 2,
  PoModernSleepActionMinimalBlockingNotificationClients = 3,
  PoModernSleepActionMax = 4
};

// 0x4 (4) bytes
enum _KCONTINUE_TYPE {

  KCONTINUE_UNWIND = 0,
  KCONTINUE_RESUME = 1,
  KCONTINUE_LONGJUMP = 2,
  KCONTINUE_SET = 3,
  KCONTINUE_LAST = 4
};

// 0x4 (4) bytes
enum _MI_MIRROR_BITMAP_TYPES {

  MirrorBitmapTypeNormal = 0,
  MirrorBitmapTypeInterlocked = 1,
  MirrorBitmapTypeMaximum = 2
};

// 0x4 (4) bytes
enum _MI_INPAGE_SUPPORT_TYPES {

  MiInPageSupportExpanded = 0,
  MiInPageSupportRegular = 1,
  MiInPageSupportMaximum = 2
};

// 0x4 (4) bytes
enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {

  JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 1,
  JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 2,
  JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 4,
  JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 7
};

// 0x4 (4) bytes
enum PDC_ACTIVITY_TYPE {

  PdcNetwork = 0,
  PdcSystem = 1,
  PdcTimer = 2,
  PdcAllNetworks = 3,
  PdcAnyNetwork = 4,
  PdcInvalidActivity = 5,
  PdcMaxActivity = 5
};

// 0x4 (4) bytes
enum ReplacesCorHdrNumericDefines {

  COMIMAGE_FLAGS_ILONLY = 1,
  COMIMAGE_FLAGS_32BITREQUIRED = 2,
  COMIMAGE_FLAGS_IL_LIBRARY = 4,
  COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
  COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,
  COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
  COMIMAGE_FLAGS_32BITPREFERRED = 131072,
  COR_VERSION_MAJOR_V2 = 2,
  COR_VERSION_MAJOR = 2,
  COR_VERSION_MINOR = 5,
  COR_DELETED_NAME_LENGTH = 8,
  COR_VTABLEGAP_NAME_LENGTH = 8,
  NATIVE_TYPE_MAX_CB = 1,
  COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
  IMAGE_COR_MIH_METHODRVA = 1,
  IMAGE_COR_MIH_EHRVA = 2,
  IMAGE_COR_MIH_BASICBLOCK = 8,
  COR_VTABLE_32BIT = 1,
  COR_VTABLE_64BIT = 2,
  COR_VTABLE_FROM_UNMANAGED = 4,
  COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8,
  COR_VTABLE_CALL_MOST_DERIVED = 16,
  IMAGE_COR_EATJ_THUNK_SIZE = 32,
  MAX_CLASS_NAME = 1024,
  MAX_PACKAGE_NAME = 1024
};

// 0x4 (4) bytes
enum _VRF_TRIAGE_CONTEXT {

  VRF_TRIAGE_CONTEXT_NONE = 0,
  VRF_TRIAGE_CONTEXT_DEFAULT = 1,
  VRF_TRIAGE_CONTEXT_DEVELOPMENT = 1,
  VRF_TRIAGE_CONTEXT_CERTIFICATION = 2,
  VRF_TRIAGE_CONTEXT_FLIGHT_TARGETED = 3,
  VRF_TRIAGE_CONTEXT_FLIGHT_DIAGNOSTICS = 4,
  VRF_TRIAGE_CONTEXT_FLIGHT_MONITORING = 5,
  NUM_VRF_TRIAGE_CONTEXTS = 6
};

// 0x4 (4) bytes
enum _PROCESS_TERMINATE_REQUEST_REASON {

  ProcessTerminateRequestReasonNone = 0,
  ProcessTerminateCommitFail = 1,
  ProcessTerminateWriteToExecuteMemory = 2,
  ProcessTerminateAttachedWriteToExecuteMemory = 3,
  ProcessTerminateRequestReasonMax = 4
};

// 0x4 (4) bytes
enum _SYSTEM_INFORMATION_CLASS {

  SystemBasicInformation = 0,
  SystemProcessorInformation = 1,
  SystemPerformanceInformation = 2,
  SystemTimeOfDayInformation = 3,
  SystemPathInformation = 4,
  SystemProcessInformation = 5,
  SystemCallCountInformation = 6,
  SystemDeviceInformation = 7,
  SystemProcessorPerformanceInformation = 8,
  SystemFlagsInformation = 9,
  SystemCallTimeInformation = 10,
  SystemModuleInformation = 11,
  SystemLocksInformation = 12,
  SystemStackTraceInformation = 13,
  SystemPagedPoolInformation = 14,
  SystemNonPagedPoolInformation = 15,
  SystemHandleInformation = 16,
  SystemObjectInformation = 17,
  SystemPageFileInformation = 18,
  SystemVdmInstemulInformation = 19,
  SystemVdmBopInformation = 20,
  SystemFileCacheInformation = 21,
  SystemPoolTagInformation = 22,
  SystemInterruptInformation = 23,
  SystemDpcBehaviorInformation = 24,
  SystemFullMemoryInformation = 25,
  SystemLoadGdiDriverInformation = 26,
  SystemUnloadGdiDriverInformation = 27,
  SystemTimeAdjustmentInformation = 28,
  SystemSummaryMemoryInformation = 29,
  SystemMirrorMemoryInformation = 30,
  SystemPerformanceTraceInformation = 31,
  SystemObsolete0 = 32,
  SystemExceptionInformation = 33,
  SystemCrashDumpStateInformation = 34,
  SystemKernelDebuggerInformation = 35,
  SystemContextSwitchInformation = 36,
  SystemRegistryQuotaInformation = 37,
  SystemExtendServiceTableInformation = 38,
  SystemPrioritySeperation = 39,
  SystemVerifierAddDriverInformation = 40,
  SystemVerifierRemoveDriverInformation = 41,
  SystemProcessorIdleInformation = 42,
  SystemLegacyDriverInformation = 43,
  SystemCurrentTimeZoneInformation = 44,
  SystemLookasideInformation = 45,
  SystemTimeSlipNotification = 46,
  SystemSessionCreate = 47,
  SystemSessionDetach = 48,
  SystemSessionInformation = 49,
  SystemRangeStartInformation = 50,
  SystemVerifierInformation = 51,
  SystemVerifierThunkExtend = 52,
  SystemSessionProcessInformation = 53,
  SystemLoadGdiDriverInSystemSpace = 54,
  SystemNumaProcessorMap = 55,
  SystemPrefetcherInformation = 56,
  SystemExtendedProcessInformation = 57,
  SystemRecommendedSharedDataAlignment = 58,
  SystemComPlusPackage = 59,
  SystemNumaAvailableMemory = 60,
  SystemProcessorPowerInformation = 61,
  SystemEmulationBasicInformation = 62,
  SystemEmulationProcessorInformation = 63,
  SystemExtendedHandleInformation = 64,
  SystemLostDelayedWriteInformation = 65,
  SystemBigPoolInformation = 66,
  SystemSessionPoolTagInformation = 67,
  SystemSessionMappedViewInformation = 68,
  SystemHotpatchInformation = 69,
  SystemObjectSecurityMode = 70,
  SystemWatchdogTimerHandler = 71,
  SystemWatchdogTimerInformation = 72,
  SystemLogicalProcessorInformation = 73,
  SystemWow64SharedInformationObsolete = 74,
  SystemRegisterFirmwareTableInformationHandler = 75,
  SystemFirmwareTableInformation = 76,
  SystemModuleInformationEx = 77,
  SystemVerifierTriageInformation = 78,
  SystemSuperfetchInformation = 79,
  SystemMemoryListInformation = 80,
  SystemFileCacheInformationEx = 81,
  SystemThreadPriorityClientIdInformation = 82,
  SystemProcessorIdleCycleTimeInformation = 83,
  SystemVerifierCancellationInformation = 84,
  SystemProcessorPowerInformationEx = 85,
  SystemRefTraceInformation = 86,
  SystemSpecialPoolInformation = 87,
  SystemProcessIdInformation = 88,
  SystemErrorPortInformation = 89,
  SystemBootEnvironmentInformation = 90,
  SystemHypervisorInformation = 91,
  SystemVerifierInformationEx = 92,
  SystemTimeZoneInformation = 93,
  SystemImageFileExecutionOptionsInformation = 94,
  SystemCoverageInformation = 95,
  SystemPrefetchPatchInformation = 96,
  SystemVerifierFaultsInformation = 97,
  SystemSystemPartitionInformation = 98,
  SystemSystemDiskInformation = 99,
  SystemProcessorPerformanceDistribution = 100,
  SystemNumaProximityNodeInformation = 101,
  SystemDynamicTimeZoneInformation = 102,
  SystemCodeIntegrityInformation = 103,
  SystemProcessorMicrocodeUpdateInformation = 104,
  SystemProcessorBrandString = 105,
  SystemVirtualAddressInformation = 106,
  SystemLogicalProcessorAndGroupInformation = 107,
  SystemProcessorCycleTimeInformation = 108,
  SystemStoreInformation = 109,
  SystemRegistryAppendString = 110,
  SystemAitSamplingValue = 111,
  SystemVhdBootInformation = 112,
  SystemCpuQuotaInformation = 113,
  SystemNativeBasicInformation = 114,
  SystemErrorPortTimeouts = 115,
  SystemLowPriorityIoInformation = 116,
  SystemBootEntropyInformation = 117,
  SystemVerifierCountersInformation = 118,
  SystemPagedPoolInformationEx = 119,
  SystemSystemPtesInformationEx = 120,
  SystemNodeDistanceInformation = 121,
  SystemAcpiAuditInformation = 122,
  SystemBasicPerformanceInformation = 123,
  SystemQueryPerformanceCounterInformation = 124,
  SystemSessionBigPoolInformation = 125,
  SystemBootGraphicsInformation = 126,
  SystemScrubPhysicalMemoryInformation = 127,
  SystemBadPageInformation = 128,
  SystemProcessorProfileControlArea = 129,
  SystemCombinePhysicalMemoryInformation = 130,
  SystemEntropyInterruptTimingInformation = 131,
  SystemConsoleInformation = 132,
  SystemPlatformBinaryInformation = 133,
  SystemPolicyInformation = 134,
  SystemHypervisorProcessorCountInformation = 135,
  SystemDeviceDataInformation = 136,
  SystemDeviceDataEnumerationInformation = 137,
  SystemMemoryTopologyInformation = 138,
  SystemMemoryChannelInformation = 139,
  SystemBootLogoInformation = 140,
  SystemProcessorPerformanceInformationEx = 141,
  SystemCriticalProcessErrorLogInformation = 142,
  SystemSecureBootPolicyInformation = 143,
  SystemPageFileInformationEx = 144,
  SystemSecureBootInformation = 145,
  SystemEntropyInterruptTimingRawInformation = 146,
  SystemPortableWorkspaceEfiLauncherInformation = 147,
  SystemFullProcessInformation = 148,
  SystemKernelDebuggerInformationEx = 149,
  SystemBootMetadataInformation = 150,
  SystemSoftRebootInformation = 151,
  SystemElamCertificateInformation = 152,
  SystemOfflineDumpConfigInformation = 153,
  SystemProcessorFeaturesInformation = 154,
  SystemRegistryReconciliationInformation = 155,
  SystemEdidInformation = 156,
  SystemManufacturingInformation = 157,
  SystemEnergyEstimationConfigInformation = 158,
  SystemHypervisorDetailInformation = 159,
  SystemProcessorCycleStatsInformation = 160,
  SystemVmGenerationCountInformation = 161,
  SystemTrustedPlatformModuleInformation = 162,
  SystemKernelDebuggerFlags = 163,
  SystemCodeIntegrityPolicyInformation = 164,
  SystemIsolatedUserModeInformation = 165,
  SystemHardwareSecurityTestInterfaceResultsInformation = 166,
  SystemSingleModuleInformation = 167,
  SystemAllowedCpuSetsInformation = 168,
  SystemVsmProtectionInformation = 169,
  SystemInterruptCpuSetsInformation = 170,
  SystemSecureBootPolicyFullInformation = 171,
  SystemCodeIntegrityPolicyFullInformation = 172,
  SystemAffinitizedInterruptProcessorInformation = 173,
  SystemRootSiloInformation = 174,
  SystemCpuSetInformation = 175,
  SystemCpuSetTagInformation = 176,
  SystemWin32WerStartCallout = 177,
  SystemSecureKernelProfileInformation = 178,
  SystemCodeIntegrityPlatformManifestInformation = 179,
  SystemInterruptSteeringInformation = 180,
  SystemSupportedProcessorArchitectures = 181,
  SystemMemoryUsageInformation = 182,
  SystemCodeIntegrityCertificateInformation = 183,
  SystemPhysicalMemoryInformation = 184,
  SystemControlFlowTransition = 185,
  SystemKernelDebuggingAllowed = 186,
  SystemActivityModerationExeState = 187,
  SystemActivityModerationUserSettings = 188,
  SystemCodeIntegrityPoliciesFullInformation = 189,
  SystemCodeIntegrityUnlockInformation = 190,
  SystemIntegrityQuotaInformation = 191,
  SystemFlushInformation = 192,
  SystemProcessorIdleMaskInformation = 193,
  SystemSecureDumpEncryptionInformation = 194,
  SystemWriteConstraintInformation = 195,
  SystemKernelVaShadowInformation = 196,
  SystemHypervisorSharedPageInformation = 197,
  SystemFirmwareBootPerformanceInformation = 198,
  SystemCodeIntegrityVerificationInformation = 199,
  SystemFirmwarePartitionInformation = 200,
  SystemSpeculationControlInformation = 201,
  SystemDmaGuardPolicyInformation = 202,
  SystemEnclaveLaunchControlInformation = 203,
  SystemWorkloadAllowedCpuSetsInformation = 204,
  SystemCodeIntegrityUnlockModeInformation = 205,
  SystemLeapSecondInformation = 206,
  SystemFlags2Information = 207,
  SystemSecurityModelInformation = 208,
  SystemCodeIntegritySyntheticCacheInformation = 209,
  SystemFeatureConfigurationInformation = 210,
  SystemFeatureConfigurationSectionInformation = 211,
  SystemFeatureUsageSubscriptionInformation = 212,
  SystemSecureSpeculationControlInformation = 213,
  SystemSpacesBootInformation = 214,
  SystemFwRamdiskInformation = 215,
  SystemWheaIpmiHardwareInformation = 216,
  SystemDifSetRuleClassInformation = 217,
  SystemDifClearRuleClassInformation = 218,
  SystemDifApplyPluginVerificationOnDriver = 219,
  SystemDifRemovePluginVerificationOnDriver = 220,
  SystemShadowStackInformation = 221,
  SystemBuildVersionInformation = 222,
  SystemPoolLimitInformation = 223,
  SystemCodeIntegrityAddDynamicStore = 224,
  SystemCodeIntegrityClearDynamicStores = 225,
  SystemPoolZeroingInformation = 227,
  MaxSystemInfoClass = 228
};

// 0x4 (4) bytes
enum _ConnectionResourceConsumerDesc {

  ConnectionResourceConsumerDescIsUndefined = 0,
  ConnectionResourceConsumerDescIsDevice = 1,
  ConnectionResourceConsumerDescIsOpregion = 2,
  ConnectionResourceConsumerDescMax = 3
};

// 0x4 (4) bytes
enum _MI_VAD_ALLOCATION_CELL_TYPE {

  MiVadBottomUp = 0,
  MiVadStackPebTeb = 1,
  MiVadReserved64 = 2,
  MiVadAllocationCellMaximum = 3
};

// 0x4 (4) bytes
enum _PPM_PERF_QOS_DISABLE_REASON {

  PpmPerfQosDisableInternal = 0,
  PpmPerfQosDisableNoProfile = 1,
  PpmPerfQosDisableNoPolicy = 2,
  PpmPerfQosDisableInsufficientPolicy = 3,
  PpmPerfQosDisableMaxOverride = 4,
  PpmPerfQosDisableLowLatency = 5,
  PpmPerfQosDisableSmtScheduler = 6,
  PpmPerfQosDisableNoHardwareSupport = 7,
  PpmPerfQosDisableGroupPolicy = 8,
  PpmPerfQosDisableMax = 9
};

// 0x4 (4) bytes
enum _PS_ATTRIBUTE_NUM {

  PsAttributeParentProcess = 0,
  PsAttributeDebugObject = 1,
  PsAttributeToken = 2,
  PsAttributeClientId = 3,
  PsAttributeTebAddress = 4,
  PsAttributeImageName = 5,
  PsAttributeImageInfo = 6,
  PsAttributeMemoryReserve = 7,
  PsAttributePriorityClass = 8,
  PsAttributeErrorMode = 9,
  PsAttributeStdHandleInfo = 10,
  PsAttributeHandleList = 11,
  PsAttributeGroupAffinity = 12,
  PsAttributePreferredNode = 13,
  PsAttributeIdealProcessor = 14,
  PsAttributeUmsThread = 15,
  PsAttributeMitigationOptions = 16,
  PsAttributeProtectionLevel = 17,
  PsAttributeSecureProcess = 18,
  PsAttributeJobList = 19,
  PsAttributeChildProcessPolicy = 20,
  PsAttributeAllApplicationPackagesPolicy = 21,
  PsAttributeWin32kFilter = 22,
  PsAttributeSafeOpenPromptOriginClaim = 23,
  PsAttributeBnoIsolation = 24,
  PsAttributeDesktopAppPolicy = 25,
  PsAttributeChpe = 26,
  PsAttributeMitigationAuditOptions = 27,
  PsAttributeMachineType = 28,
  PsAttributeComponentFilter = 29,
  PsAttributeMax = 30
};

// 0x4 (4) bytes
enum _SYSTEM_FEATURE_CONFIGURATION_SECTION_TYPE {

  SystemFeatureConfigurationSectionTypeBoot = 0,
  SystemFeatureConfigurationSectionTypeRuntime = 1,
  SystemFeatureConfigurationSectionTypeUsageTriggers = 2,
  SystemFeatureConfigurationSectionTypeCount = 3
};

// 0x4 (4) bytes
enum _HV_EXT_EPF_MODE {

  HvExtEpfModeMin = 0,
  HvExtEpfModeNt = 0,
  HvExtEpfModeMax = 1
};

// 0x4 (4) bytes
enum _MI_CROSS_PARTITION_CHARGE_TYPE {

  MiCrossPartitionSectionResAvailCharge = 0,
  MiCrossPartitionSectionCommitCharge = 1,
  MiCrossPartitionPageCombineResAvailCharge = 2,
  MiCrossPartitionPageCombineCommitCharge = 3,
  MiCrossPartitionLargePageResAvailCharge = 4,
  MiCrossPartitionLargePageCommitCharge = 5,
  MiCrossPartitionPageCloneResAvailCharge = 6,
  MiCrossPartitionMaximumCharge = 7
};

// 0x4 (4) bytes
enum _THREAD_WORKLOAD_CLASS {

  ThreadWorkloadClassDefault = 0,
  ThreadWorkloadClassGraphics = 1,
  MaxThreadWorkloadClass = 2
};

// 0x4 (4) bytes
enum LSA_FOREST_TRUST_RECORD_TYPE {

  ForestTrustTopLevelName = 0,
  ForestTrustTopLevelNameEx = 1,
  ForestTrustDomainInfo = 2,
  ForestTrustRecordTypeLast = 2
};

// 0x4 (4) bytes
enum SLEEPSTUDY_SPM_SCENARIO_CS_EXIT {

  SpmScenarioStopReasonUnspecified = 16,
  SpmScenarioStopReasonCsExit = 17,
  SpmScenarioStopReasonInternalSegmentTransition = 18,
  SpmScenarioStopReasonMax = 19
};

// 0x4 (4) bytes
enum PDCCLIENTID {

  PDC_INVALID_CLIENT = 0,
  PDC_PLM_CLIENT = 1,
  PDC_NQM_CLIENT = 2,
  PDC_WNS_CLIENT = 3,
  PDC_DAM_CLIENT = 4,
  PDC_WCM_CLIENT = 5,
  PDC_NCSI_CLIENT = 7,
  PDC_DHCP_CLIENT = 8,
  PDC_TCPIP_CLIENT = 9,
  PDC_WU_CLIENT = 11,
  PDC_GP_CLIENT = 12,
  PDC_NCA_CLIENT = 14,
  PDC_BI_CLIENT = 15,
  PDC_MSCHED_CLIENT = 16,
  PDC_SUSPENDRESUME_CLIENT = 17,
  PDC_INTERNAL_CLIENT = 18,
  PDC_DEFAULT_KM_TEST_CLIENT_EXEMPTED = 19,
  PDC_DEFAULT_UM_TEST_CLIENT_EXEMPTED = 20,
  PDC_DAM_PHASE_TEST_CLIENT = 21,
  PDC_LOW_POWER_PHASE_TEST_CLIENT = 22,
  PDC_RESILIENCY_NOTIFICATION_PHASE_TEST_CLIENT = 23,
  PDC_NQM_RESILIENCY_TEST_CLIENT = 24,
  PDC_DAM_RESILIENCY_TEST_CLIENT = 25,
  PDC_DAM_KM_TEST_CLIENT = 26,
  PDC_DAM_UM_TEST_CLIENT = 27,
  PDC_SINGLETON_TEST_CLIENT = 28,
  PDC_NETWORK_SERVICE_TEST_CLIENT = 29,
  PDC_NETWORK_SERVICE2_TEST_CLIENT = 30,
  PDC_SYSTEM_SERVICE_TEST_CLIENT = 31,
  PDC_ACTIV_NOTIF_DAM_RESIL_TEST_CLIENT = 32,
  PDC_ACTIV_NOTIF_NET_RESIL_TEST_CLIENT = 33,
  PDC_SHELL_CLIENT = 34,
  PDC_MAINTENANCE_CLIENT = 35,
  PDC_SYNC_CLIENT = 36,
  PDC_IDM_CLIENT = 37,
  PDC_CORTANA_VOICE_ACTIVATION_CLIENT = 38,
  PDC_TETHERING_CLIENT = 39,
  PDC_AUDIO_CLIENT = 40,
  PDC_LOCK_SCREEN = 41,
  PDC_LREC_CLIENT = 42,
  PDC_WP_BW_CLIENT = 43,
  PDC_WP_MEDIA_STREAMING_CLIENT = 44,
  PDC_WP_MAPS_CLIENT = 46,
  PDC_WP_SYNC_CLIENT = 47,
  PDC_SETTING_SYNC_CLIENT = 48,
  PDC_WP_EDM_CLIENT = 49,
  PDC_WP_WALLET_CLIENT = 50,
  PDC_WP_LOCATION_CLIENT = 51,
  PDC_WP_CM_CLIENT = 53,
  PDC_WP_DCP_CLIENT = 54,
  PDC_WP_WIFIAUTO_CLIENT = 55,
  PDC_BITLOCKER_CLIENT = 56,
  PDC_MDM_CERTINSTALLER_CLIENT = 57,
  PDC_WP_IM_CLIENT = 58,
  PDC_WP_MMS_CLIENT = 59,
  PDC_DEVICEENROLLER_CLIENT = 60,
  PDC_WP_WIFI_SCANNING_CLIENT = 61,
  PDC_WP_OMADM_CLIENT = 62,
  PDC_WP_TELEMETRY_CHECK_CLIENT = 63,
  PDC_WP_DIS_CLIENT = 64,
  PDC_BITS_CLIENT = 65,
  PDC_WP_VOIP_EXECUTION_CLIENT = 66,
  PDC_WP_RESERVED_CLIENT3 = 67,
  PDC_SLEEP_STUDY_CLIENT = 68,
  PDC_WP_AUTOTIMEUPDATE_CLIENT = 69,
  PDC_HYPERV_CLIENT = 70,
  PDC_KM_SIGNAL_CLIENT = 71,
  PDC_UM_SIGNAL_CLIENT = 72,
  PDC_DEVICE_HEALTH_ATTESTATION_CLIENT = 73,
  PDC_XB_SYSTEM_CLIENT = 74,
  PDC_XB_HOST_CLIENT = 75,
  PDC_PRINT_JOB_MANAGER_CLIENT = 76,
  PDC_TELEMETRY_CLIENT = 77,
  PDC_ERROR_REPORTING_CLIENT = 78,
  PDC_XBOX_NTM = 79,
  PDC_CBE_CLIENT = 80,
  PDC_FIND_MY_PHONE_CLIENT = 81,
  PDC_COMMAND_CHANNEL_CLIENT = 82,
  PDC_PPM_PROFILES_CLIENT = 83,
  PDC_WIFI_CALLING_CLIENT = 84,
  PDC_WU_REBOOT_CLIENT = 85,
  PDC_SYSMAIN_CLIENT = 86,
  PDC_XBOX_UPDATE_CLIENT = 87,
  PDC_CHAT_SERVICE_CLIENT = 88,
  PDC_FIND_MY_DEVICE_CLIENT = 89,
  PDC_NOTIFICATION_FORWARDING_AND_ACTION_CLIENT = 90,
  PDC_INSTALL_AGENT_CLIENT = 91,
  PDC_XBOX_WAKE_ON_VOICE = 92,
  PDC_PLM_AUDIO_CLIENT = 93,
  PDC_WP_BCKAUDIO_CLIENT = 94,
  PDC_WAKE_ON_LAN_CLIENT = 95,
  PDC_WP_CLOUD_MESSAGING_CLIENT = 96,
  PDC_DATA_MIGRATION_MANAGER = 97,
  PDC_EVENT_SOUND_MANAGER_CLIENT = 98,
  PDC_WWAN_DORMANCY_HINT_CLIENT = 99,
  PDC_HAM_CLIENT = 100,
  PDC_FILESHARINGSERVER_CLIENT = 101,
  PDC_DIRECTED_DRIPS_TASK_CLIENT = 102,
  PDC_DIRECTED_DRIPS_LPE_CLIENT = 103,
  PDC_DIRECTED_DRIPS_PLM_CLIENT = 104,
  PDC_HTTPSDATASOURCE_CLIENT = 105,
  PDC_TERMINALSERVER_CONNECTION_CLIENT = 106,
  PDC_TERMINALSERVER_SESSION_CLIENT = 107,
  PDC_ANYNETWORK_RESILIENCY_CLIENT = 108,
  PDC_XBOX_NUI_CLIENT = 110,
  PDC_WIFI_CALLING_IMS_CLIENT = 111,
  PDC_SLEEPSTUDY_HELPER_USER_CLIENT = 112,
  PDC_SLEEPSTUDY_HELPER_KERNEL_CLIENT = 113,
  PDC_CONTAINER_MANAGER_CLIENT = 114,
  PDC_NUMBER_OF_CLIENTS = 115
};

// 0x4 (4) bytes
enum _PERFINFO_MM_STAT {

  PerfInfoMMStatNotUsed = 0,
  PerfInfoMMStatAggregatePageCombine = 1,
  PerfInfoMMStatIterationPageCombine = 2,
  PerfInfoMMStatMax = 3
};

// 0x4 (4) bytes
enum _MI_PARTITION_THREAD {

  MiZeroPageThreadSlot = 0,
  MiRebuildLargePagesThreadSlot = 1,
  MiPartitionWorkingSetManagerSlot = 2,
  MiDereferenceSegmentThreadSlot = 3,
  MiModifiedPageWriterSlot = 4,
  MiMappedPageWriterSlot = 5,
  MiNumberOfPartitionThreads = 6
};

// 0x4 (4) bytes
enum _TRACE_INFORMATION_CLASS {

  TraceIdClass = 0,
  TraceHandleClass = 1,
  TraceEnableFlagsClass = 2,
  TraceEnableLevelClass = 3,
  GlobalLoggerHandleClass = 4,
  EventLoggerHandleClass = 5,
  AllLoggerHandlesClass = 6,
  TraceHandleByNameClass = 7,
  LoggerEventsLostClass = 8,
  TraceSessionSettingsClass = 9,
  LoggerEventsLoggedClass = 10,
  DiskIoNotifyRoutinesClass = 11,
  TraceInformationClassReserved1 = 12,
  AllPossibleNotifyRoutinesClass = 12,
  FltIoNotifyRoutinesClass = 13,
  TraceInformationClassReserved2 = 14,
  WdfNotifyRoutinesClass = 15,
  MaxTraceInformationClass = 16
};

// 0x4 (4) bytes
enum _MI_IO_PFN_TYPE {

  MiIoPfnProbes = 0,
  MiIoPfnMaps = 1,
  MiIoPfnUnmapped = 2,
  MiMaximumIoPfnType = 3
};

// 0x4 (4) bytes
enum TlgOut_t {

  TlgOutNULL = 0,
  TlgOutNOPRINT = 1,
  TlgOutSTRING = 2,
  TlgOutBOOLEAN = 3,
  TlgOutHEX = 4,
  TlgOutPID = 5,
  TlgOutTID = 6,
  TlgOutPORT = 7,
  TlgOutIPV4 = 8,
  TlgOutIPV6 = 9,
  TlgOutSOCKETADDRESS = 10,
  TlgOutXML = 11,
  TlgOutJSON = 12,
  TlgOutWIN32ERROR = 13,
  TlgOutNTSTATUS = 14,
  TlgOutHRESULT = 15,
  TlgOutFILETIME = 16,
  TlgOutSIGNED = 17,
  TlgOutUNSIGNED = 18,
  TlgOutUTF8 = 35,
  TlgOutPKCS7_WITH_TYPE_INFO = 36,
  TlgOutCODE_POINTER = 37,
  TlgOutDATETIME_UTC = 38,
  _TlgOutMax = 39,
  _TlgOutChain = 128,
  _TlgOutTypeMask = 127
};

// 0x4 (4) bytes
enum _INVPCID_TYPE {

  InvpcidIndividualAddress = 0,
  InvpcidSingleContext = 1,
  InvpcidAllContextAndGlobals = 2,
  InvpcidAllContext = 3
};

// 0x4 (4) bytes
enum _ADD_DRIVER_STAGE {

  ClassConfigFilters = 0,
  LowerDeviceFilters = 1,
  LowerClassFilters = 2,
  DeviceService = 3,
  UpperDeviceFilters = 4,
  UpperClassFilters = 5,
  MaximumAddStage = 6
};

// 0x4 (4) bytes
enum _KPROCESS_STATE {

  ProcessInMemory = 0,
  ProcessOutOfMemory = 1,
  ProcessInTransition = 2,
  ProcessOutTransition = 3,
  ProcessInSwap = 4,
  ProcessOutSwap = 5,
  ProcessRetryOutSwap = 6,
  ProcessAllSwapStates = 7
};

// 0x4 (4) bytes
enum _MI_VAD_64K_TYPES {

  MiVad64KPrivate = 0,
  MiVad64KShared = 1,
  MiVad64KTypes = 2
};

// 0x4 (4) bytes
enum _PO_CS_DEVICE_NOTIFICATION_TYPE {

  PoCsDeviceNotificationStorage = 0,
  PoCsDeviceNotificationWiFi = 1,
  PoCsDeviceNotificationMbn = 2,
  PoCsDeviceNotificationAudio = 3,
  PoCsDeviceNotificationEthernet = 4,
  PoCsDeviceNotificationMaximum = 5
};

// 0x4 (4) bytes
enum _POLICY_AUDIT_EVENT_TYPE {

  AuditCategorySystem = 0,
  AuditCategoryLogon = 1,
  AuditCategoryObjectAccess = 2,
  AuditCategoryPrivilegeUse = 3,
  AuditCategoryDetailedTracking = 4,
  AuditCategoryPolicyChange = 5,
  AuditCategoryAccountManagement = 6,
  AuditCategoryDirectoryServiceAccess = 7,
  AuditCategoryAccountLogon = 8
};

// 0x4 (4) bytes
enum _MI_ASSIGNED_REGION_TYPES {

  AssignedRegionNonPagedPool = 0,
  AssignedRegionPagedPool = 1,
  AssignedRegionSystemCache = 2,
  AssignedRegionSystemPtes = 3,
  AssignedRegionUltraZero = 4,
  AssignedRegionPfnDatabase = 5,
  AssignedRegionCfg = 6,
  AssignedRegionHyperSpace = 7,
  AssignedRegionKernelStacks = 8,
  AssignedRegionPageTables = 9,
  AssignedRegionSession = 10,
  AssignedRegionSecureNonPagedPool = 11,
  AssignedRegionSystemImages = 12,
  AssignedRegionMaximum = 13
};

// 0x4 (4) bytes
enum _MI_SUBVAD_LISTS {

  MiSubVadPebTebAny = 0,
  MiSubVadPebTebBelow4gb = 1,
  MiSubVadMaximum = 2
};

// 0x4 (4) bytes
enum _KWAIT_STATE {

  WaitInProgress = 0,
  WaitCommitted = 1,
  WaitAborted = 2,
  WaitSuspendInProgress = 3,
  WaitSuspended = 4,
  WaitResumeInProgress = 5,
  WaitResumeAborted = 6,
  WaitFirstSuspendState = 3,
  WaitLastSuspendState = 6,
  MaximumWaitState = 7
};

// 0x4 (4) bytes
enum _KI_CALLBACK {

  KiCallbackNmi = 0,
  KiCallbackBound = 1,
  KiCallbackSx = 2,
  KiCallbackCount = 3,
  KiFirstCallback = 0
};

// 0x4 (4) bytes
enum _POP_DEEP_SLEEP_DISENGAGE_REASON {

  PopDeepSleepDisengageReasonInactive = 0,
  PopDeepSleepDisengageReasonNonAoAc = 1,
  PopDeepSleepDisengageReasonPendingIrps = 2,
  PopDeepSleepDisengageReasonPowerSettings = 3,
  PopDeepSleepDisengageReasonDozeS4WorkerQueued = 4,
  PopDeepSleepDisengageReasonSystemPowerTransition = 5,
  PopDeepSleepDisengageReasonDeviceBlockingDrips = 6,
  PopDeepSleepDisengageReasonAcpi = 7,
  PopDeepSleepDisengageReasonDirectedDripsTransition = 8,
  PopDeepSleepDisengageReasonPepPreVeto = 9,
  PopDeepSleepDisengageReasonMax = 10
};

// 0x4 (4) bytes
enum _ETW_GUID_TYPE {

  EtwTraceGuidType = 0,
  EtwNotificationGuidType = 1,
  EtwGroupGuidType = 2,
  EtwGuidTypeMax = 3
};

// 0x4 (4) bytes
enum _MI_KSTACK_TYPE {

  MiRegularKstack = 0,
  MiShortLivedKstack = 1,
  MiMaximumKstack = 2
};

// 0x4 (4) bytes
enum _WOW64_SHARED_INFORMATION {

  SharedNtdll32LdrInitializeThunk = 0,
  SharedNtdll32KiUserExceptionDispatcher = 1,
  SharedNtdll32KiUserApcDispatcher = 2,
  SharedNtdll32KiUserCallbackDispatcher = 3,
  SharedNtdll32RtlUserThreadStart = 4,
  SharedNtdll32pQueryProcessDebugInformationRemote = 5,
  SharedNtdll32BaseAddress = 6,
  SharedNtdll32LdrSystemDllInitBlock = 7,
  SharedNtdll32RtlpFreezeTimeBias = 8,
  Wow64SharedPageEntriesCount = 9
};

// 0x4 (4) bytes
enum _PO_HIBER_FORCE_DISABLE_REASON {

  PoHiberForceDisableReasonPolicy = 0,
  PoHiberForceDisableReasonGuardedHost = 1,
  PoHiberForceDisableReasonMax = 2
};

// 0x4 (4) bytes
enum _SYSTEM_PROCESS_CLASSIFICATION {

  SystemProcessClassificationNormal = 0,
  SystemProcessClassificationSystem = 1,
  SystemProcessClassificationSecureSystem = 2,
  SystemProcessClassificationMemCompression = 3,
  SystemProcessClassificationRegistry = 4,
  SystemProcessClassificationMaximum = 5
};

// 0x4 (4) bytes
enum _KTHREAD_STATE {

  Initialized = 0,
  Ready = 1,
  Running = 2,
  Standby = 3,
  Terminated = 4,
  Waiting = 5,
  Transition = 6,
  DeferredReady = 7,
  GateWaitObsolete = 8,
  WaitingForProcessInSwap = 9
};

// 0x4 (4) bytes
enum _TlgBlob_t {

  _TlgBlobNone = 0,
  _TlgBlobEnd = 1,
  _TlgBlobProvider = 2,
  _TlgBlobEvent3 = 3,
  _TlgBlobProvider3 = 4,
  _TlgBlobEvent2 = 5,
  _TlgBlobEvent4 = 6,
  _TlgBlobMax = 7
};

// 0x4 (4) bytes
enum _MI_SHARED_USER_PAGE_TYPES {

  MiSharedUserPageKernel = 0,
  MiSharedUserPageHypervisor = 1,
  MiSharedUserPageMaximum = 2
};

// 0x4 (4) bytes
enum _KPROCESS_PPM_POLICY {

  ProcessPpmDefault = 0,
  ProcessPpmThrottle = 1,
  ProcessPpmSemiThrottle = 2,
  ProcessPpmNoThrottle = 3,
  ProcessPpmWindowMinimized = 4,
  ProcessPpmWindowOccluded = 5,
  ProcessPpmWindowVisible = 6,
  ProcessPpmWindowInFocus = 7,
  MaxProcessPpmPolicy = 8
};

// 0x4 (4) bytes
enum _KTHREAD_PPM_POLICY {

  ThreadPpmDefault = 0,
  ThreadPpmThrottle = 1,
  ThreadPpmSemiThrottle = 2,
  ThreadPpmNoThrottle = 3,
  MaxThreadPpmPolicy = 4
};

// 0x4 (4) bytes
enum PS_CREATE_STATE {

  PsCreateInitialState = 0,
  PsCreateFailOnFileOpen = 1,
  PsCreateFailOnSectionCreate = 2,
  PsCreateFailExeFormat = 3,
  PsCreateFailMachineMismatch = 4,
  PsCreateFailExeName = 5,
  PsCreateSuccess = 6,
  PsCreateMaximumStates = 7
};

// 0x4 (4) bytes
enum _MI_DYNAMICBASE_BITMAP {

  DynamicBaseBitMapNative = 0,
  DynamicBaseBitMap64Low = 1,
  DynamicBaseBitMap64LowWow = 2,
  DynamicBaseBitMap32WowFirst = 3,
  DynamicBaseBitMap32WowLast = 3,
  DynamicBaseBitMapInvalid = 4,
  DynamicBaseBitMapMax = 4
};

// 0x4 (4) bytes
enum _POP_SYSTEM_IDLE_EVENT_TYPE {

  PopSystemIdleEventTypeMonitorOffUserInput = 0,
  PopSystemIdleEventTypeMonitorOnUserInput = 1,
  PopSystemIdleEventTypeUserPresence = 2,
  PopSystemIdleEventTypeResumeFromSxSystemPowerState = 3,
  PopSystemIdleEventTypeMax = 4,
  PopSystemIdleEventTypeInvalid = 4
};

// 0x4 (4) bytes
enum _POP_FX_WORK_POOL_QUEUE {

  PopFxWorkPoolQueueEmergency = 0,
  PopFxWorkPoolQueuePlugin = 1,
  PopFxWorkPoolQueueMax = 2
};

// 0x4 (4) bytes
enum _ETW_STRING_TOKEN_TYPE {

  ETW_STRING_TOKEN_EXE = 0,
  ETW_STRING_TOKEN_PACKAGE_ID = 1,
  ETW_STRING_TOKEN_PKG_APP_ID = 2,
  ETW_STRING_TOKEN_CONTAINER = 3,
  ETW_STRING_TOKEN_MAX_COUNT = 4
};

// 0x4 (4) bytes
enum _WORKING_SET_TYPE {

  WorkingSetTypeUser = 0,
  WorkingSetTypeSession = 1,
  WorkingSetTypeSystemTypes = 2,
  WorkingSetTypeSystemCache = 2,
  WorkingSetTypePagedPool = 3,
  WorkingSetTypeSystemViews = 4,
  WorkingSetTypePagableMaximum = 4,
  WorkingSetTypeSystemPtes = 5,
  WorkingSetTypeKernelStacks = 6,
  WorkingSetTypeNonPagedPool = 7,
  WorkingSetTypeMaximum = 8
};

// 0x4 (4) bytes
enum _PS_PROTECTED_SIGNER {

  PsProtectedSignerNone = 0,
  PsProtectedSignerAuthenticode = 1,
  PsProtectedSignerCodeGen = 2,
  PsProtectedSignerAntimalware = 3,
  PsProtectedSignerLsa = 4,
  PsProtectedSignerWindows = 5,
  PsProtectedSignerWinTcb = 6,
  PsProtectedSignerWinSystem = 7,
  PsProtectedSignerApp = 8,
  PsProtectedSignerMax = 9
};

// 0x4 (4) bytes
enum _MI_MEMORY_HIGHLOW {

  MiMemoryHigh = 0,
  MiMemoryLow = 1,
  MiMemoryHighLow = 2
};

// 0x4 (4) bytes
enum FEATURE_ENABLED_STATE {

  FEATURE_ENABLED_STATE_DEFAULT = 0,
  FEATURE_ENABLED_STATE_DISABLED = 1,
  FEATURE_ENABLED_STATE_ENABLED = 2,
  FEATURE_ENABLED_STATE_HAS_NOTIFICATION = 128,
  FEATURE_ENABLED_STATE_HAS_VARIANT_CONFIGURATION = 64
};

// 0x4 (4) bytes
enum _PERFINFO_KERNELMEMORY_USAGE_TYPE {

  PerfInfoMemUsagePfnMetadata = 0,
  PerfInfoMemUsageMax = 1
};

// 0x4 (4) bytes
enum _RTL_FEATURE_CONFIGURATION_PRIORITY {

  FeatureConfigurationPriorityImageDefault = 0,
  FeatureConfigurationPriorityService = 4,
  FeatureConfigurationPriorityUser = 8,
  FeatureConfigurationPriorityUserPolicy = 10,
  FeatureConfigurationPriorityTest = 12,
  FeatureConfigurationPriorityImageOverride = 15,
  FeatureConfigurationPriorityMax = 15
};

// 0x4 (4) bytes
enum _HEAP_SEGMGR_LARGE_PAGE_POLICY {

  HeapSegMgrNoLargePages = 0,
  HeapSegMgrEnableLargePages = 1,
  HeapSegMgrNormalPolicy = 1,
  HeapSegMgrForceSmall = 2,
  HeapSegMgrForceLarge = 3,
  HeapSegMgrForceRandom = 4,
  HeapSegMgrLargePagePolicyMax = 5
};

// 0x4 (4) bytes
enum _PS_RESOURCE_TYPE {

  PsResourceNonPagedPool = 0,
  PsResourcePagedPool = 1,
  PsResourcePageFile = 2,
  PsResourceWorkingSet = 3,
  PsResourceMax = 4
};

// 0x4 (4) bytes
enum _PROCESS_VA_TYPE {

  ProcessVAImage = 0,
  ProcessVASection = 1,
  ProcessVAPrivate = 2,
  ProcessVAMax = 3
};

// 0x4 (4) bytes
enum _MI_CFG_BITMAP_TYPE {

  CfgBitMapNative = 0,
  CfgBitMapWow64 = 1,
  CfgBitMapMax = 2
};

// 0x4 (4) bytes
enum _PS_PROTECTED_TYPE {

  PsProtectedTypeNone = 0,
  PsProtectedTypeProtectedLight = 1,
  PsProtectedTypeProtected = 2,
  PsProtectedTypeMax = 3
};

// 0x4 (4) bytes
enum _SKSERVICE {

  SECURESERVICE_NONE = 0,
  SECURESERVICE_PHASE4_INIT = 1,
  SECURESERVICE_START_PROCESSOR = 2,
  SECURESERVICE_FINISH_START_PROCESSOR = 3,
  SECURESERVICE_REGISTER_SYSTEM_DLLS = 4,
  SECURESERVICE_REGISTER_SYSTEM_PROCESS = 5,
  SECURESERVICE_CREATE_PROCESS = 6,
  SECURESERVICE_INITIALIZE_PROCESS = 7,
  SECURESERVICE_CREATE_THREAD = 8,
  SECURESERVICE_REQUEST_THREAD_EXIT = 9,
  SECURESERVICE_TERMINATE_THREAD = 10,
  SECURESERVICE_RUNDOWN_PROCESS = 11,
  SECURESERVICE_DEBUG_PROCESS = 12,
  SECURESERVICE_GET_TEB_ADDRESS = 13,
  SECURESERVICE_GET_CONTEXT = 14,
  SECURESERVICE_SET_CONTEXT = 15,
  SECURESERVICE_SEND_ATTACH_NOTIFICATIONS = 16,
  SECURESERVICE_GET_ETW_DEBUG_ID = 17,
  SECURESERVICE_GET_ON_DEMAND_DEBUG_CHALLENGE = 18,
  SECURESERVICE_ENABLE_ON_DEMAND_DEBUG_WITH_RESPONSE = 19,
  SECURESERVICE_RETRIEVE_MAILBOX = 20,
  SECURESERVICE_IS_TRUSTLET_RUNNING = 21,
  SECURESERVICE_CREATE_SECURE_ALLOCATION = 22,
  SECURESERVICE_FILL_SECURE_ALLOCATION = 23,
  SECURESERVICE_MAKE_CODE_CATALOG = 24,
  SECURESERVICE_CREATE_SECURE_IMAGE = 25,
  SECURESERVICE_FINALIZE_SECURE_IMAGE_HASH = 26,
  SECURESERVICE_FINISH_SECURE_IMAGE_VALIDATION = 27,
  SECURESERVICE_PREPARE_IMAGE_RELOCATIONS = 28,
  SECURESERVICE_RELOCATE_IMAGE = 29,
  SECURESERVICE_CLOSE_SECURE_HANDLE = 30,
  SECURESERVICE_VALIDATE_DYNAMIC_CODE = 31,
  SECURESERVICE_TRANSFER_IMAGE_VERSION_RESOURCE = 32,
  SECURESERVICE_SET_CODE_INTEGRITY_POLICY = 33,
  SECURESERVICE_EXCHANGE_ENTROPY = 34,
  SECURESERVICE_ALLOCATE_HIBERNATE_RESOURCES = 35,
  SECURESERVICE_FREE_HIBERNATE_RESOURCES = 36,
  SECURESERVICE_CONFIGURE_DYNAMIC_MEMORY = 37,
  SECURESERVICE_DEBUG_PROTECT_MEMORY = 38,
  SECURESERVICE_DEBUG_READ_WRITE_MEMORY = 39,
  SECURESERVICE_QUERY_VIRTUAL_MEMORY = 40,
  SECURESERVICE_CAPTURE_IMAGE_IAT = 41,
  SECURESERVICE_FREE_IMAGE_IAT = 42,
  SECURESERVICE_APPLY_FIXUPS = 43,
  SECURESERVICE_MARK_IMAGE_PROTECTED = 44,
  SECURESERVICE_CREATE_ENCLAVE = 45,
  SECURESERVICE_LOAD_ENCLAVE_DATA = 46,
  SECURESERVICE_LOAD_ENCLAVE_MODULE = 47,
  SECURESERVICE_INITIALIZE_ENCLAVE = 48,
  SECURESERVICE_TERMINATE_ENCLAVE = 49,
  SECURESERVICE_DELETE_ENCLAVE = 50,
  SECURESERVICE_CONNECT_SW_INTERRUPT = 51,
  SECURESERVICE_RELAX_HYPERGUARD_QUOTA = 52,
  SECURESERVICE_LIVEDUMP_QUERY_SECONDARYDATA_SIZE = 53,
  SECURESERVICE_LIVEDUMP_START = 54,
  SECURESERVICE_LIVEDUMP_ADD_BUFFER = 55,
  SECURESERVICE_LIVEDUMP_SETUP_BUFFER = 56,
  SECURESERVICE_LIVEDUMP_FINALIZE = 57,
  SECURESERVICE_LIVEDUMP_ABORT = 58,
  SECURESERVICE_LIVEDUMP_CAPTURE_PROCESS = 59,
  SECURESERVICE_NOTIFY_POWER_STATE = 60,
  SECURESERVICE_QUERY_PROFILE_INFORMATION = 61,
  SECURESERVICE_UPDATE_FREEZE_BIAS = 62,
  SECURESERVICE_CREATE_SECURE_SECTION = 63,
  SECURESERVICE_DELETE_SECURE_SECTION = 64,
  SECURESERVICE_QUERY_SECURE_DEVICE = 65,
  SECURESERVICE_UNPROTECT_SECURE_DEVICE = 66,
  SECURESERVICE_DETERMINE_HOT_PATCH_TYPE = 67,
  SECURESERVICE_OBTAIN_PATCH_UNDO_TABLE_SIZE = 68,
  SECURESERVICE_OBTAIN_PATCH_UNDO_TABLE = 69,
  SECURESERVICE_APPLY_HOT_PATCH = 70,
  SECURESERVICE_REVERT_HOT_PATCH = 71,
  SECURESERVICE_PREPARE_DRIVER_FOR_PATCH = 72,
  SECURESERVICE_PROVISION_DUMP_KEYS = 73,
  SECURESERVICE_CAPTURE_PGO_DATA = 74,
  SECURESERVICE_START_PROFILE = 75,
  SECURESERVICE_STOP_PROFILE = 76,
  SECURESERVICE_SET_TRACEPOINT = 77,
  SECURESERVICE_NO_TRACING_FIRST = 191,
  SECURESERVICE_GET_PEB_ADDRESS = 192,
  SECURESERVICE_VALIDATE_SECURE_IMAGE_PAGES = 193,
  SECURESERVICE_PRE_INIT_FIRST = 207,
  SECURESERVICE_PHASE3_INIT = 208,
  SECURESERVICE_PERIODIC = 209,
  SECURESERVICE_WORK_QUEUE = 210,
  SECURESERVICE_RESERVE_PROTECTED_PAGES = 211,
  SECURESERVICE_APPLY_DYNAMIC_RELOCATIONS = 212,
  SECURESERVICE_ETW_ENABLE_CALLBACK = 213,
  SECURESERVICE_INITIALIZE_SECURE_POOL = 214,
  SECURESERVICE_INITIALIZE_KERNEL_CFG = 215,
  SECURESERVICE_LOAD_DRIVER = 216,
  SECURESERVICE_UNLOAD_DRIVER = 217,
  SECURESERVICE_ENABLE_CFG_TARGET = 218,
  SECURESERVICE_COMPLETE_SLAB_CONFIGURATION = 219,
  SECURESERVICE_INITIALIZE_RETPOLINE = 220,
  SECURESERVICE_PERFORM_RETPOLINE_RELOCATIONS = 221,
  SECURESERVICE_UPDATE_IMPORT_RELOCATIONS = 222,
  SECURESERVICE_DISPATCH_LEVEL_FIRST = 239,
  SECURESERVICE_FLUSH_ADDRESS_SPACE = 240,
  SECURESERVICE_FAST_FLUSH_RANGE_LIST = 241,
  SECURESERVICE_SLOW_FLUSH_RANGE_LIST = 242,
  SECURESERVICE_REMOVE_PROTECTED_PAGE = 243,
  SECURESERVICE_COPY_PROTECTED_PAGE = 244,
  SECURESERVICE_REGISTER_PROTECTED_PAGE = 245,
  SECURESERVICE_DISAMBIGUATE_PROTECTED_PAGE = 246,
  SECURESERVICE_MAKE_PROTECTED_PAGE_WRITABLE = 247,
  SECURESERVICE_MAKE_PROTECTED_PAGE_EXECUTABLE = 248,
  SECURESERVICE_QUERY_STRONG_CODE_FEATURES = 249,
  SECURESERVICE_INVOKE_EFI_RUNTIME_SERVICE = 250,
  SECURESERVICE_LIVEDUMP_COLLECT_LIVE_DUMP = 251,
  SECURESERVICE_REGISTER_LOG_PAGES = 252,
  SECURESERVICE_RECLAIM_PARTITION_PAGES = 253,
  SECURESERVICE_BIND_NT_KERNEL_IMPORTS = 254,
  SECURESERVICE_SET_PLACEHOLDER_PAGES = 255,
  SECURESERVICE_QUERY_SPECULATION_CONTROL_FEATURES = 256,
  SECURESERVICE_PROTECT_KERNEL_DATA_PAGE = 257,
  SECURESERVICE_VERIFY_PAGE = 258,
  SECURESERVICE_PREPARE_FOR_HIBERNATION = 259,
  SECURESERVICE_PREPARE_FOR_CRASHDUMP = 260,
  SECURESERVICE_REPORT_BUGCHECK_PROGRESS = 261,
  SECURESERVICE_SHUTDOWN = 262,
  SECURESERVICE_QUERY_SECURE_PCI_INFO = 263,
  SECURESERVICE_ACCESS_PCI_DEVICE = 264,
  SECURESERVICE_REINITIALIZE_DEBUGGER_TRANSPORT = 265,
  SECURESERVICE_KSR_CALL = 266,
  SECURESERVICE_SVC_CALL = 267,
  SECURESERVICE_BUGCHECK = 1792,
  SECURESERVICE_LIMITED_MODE_SERVICE_START = 2048
};

// 0x4 (4) bytes
enum _KTIMER2_COLLECTION_INDEX {

  KTimer2CollectionNoWake = 0,
  KTimer2CollectionHr = 1,
  KTimer2CollectionPseudoHr = 2,
  KTimer2CollectionFinite = 3,
  KTimer2CollectionIr = 4,
  KTimer2CollectionNotInserted = 16,
  KTimer2CollectionInvalid = 21,
  KTimer2CollectionOptional = 32,
  KTimer2CollectionMin = 0,
  KTimer2CollectionMax = 5,
  KTimer2CollectionNode1 = 2
};

// 0x4 (4) bytes
enum _MI_WORKING_SET_TYPE {

  MiWorkingSetTypeSystemCache = 0,
  MiWorkingSetTypeSystemViews = 1,
  MiWorkingSetTypePartitionMaximum = 1,
  MiWorkingSetTypePagedPool = 2,
  MiWorkingSetTypePagableMaximum = 2,
  MiWorkingSetTypeSystemPtes = 3,
  MiWorkingSetTypeKernelStacks = 4,
  MiWorkingSetTypeNonPagedPool = 5,
  MiWorkingSetTypeMaximum = 6
};

// 0x4 (4) bytes
enum _KE_WAKE_SOURCE_TYPE {

  KeWakeSourceTypeSpuriousWake = 0,
  KeWakeSourceTypeSpuriousClock = 1,
  KeWakeSourceTypeSpuriousInterrupt = 2,
  KeWakeSourceTypeQueryFailure = 3,
  KeWakeSourceTypeAccountingFailure = 4,
  KeWakeSourceTypeStaticSourceMax = 4,
  KeWakeSourceTypeInterrupt = 5,
  KeWakeSourceTypeIRTimer = 6,
  KeWakeSourceTypeMax = 7
};

// 0x4 (4) bytes
enum _VRF_RULE_CLASS_ID {

  VrfSpecialPoolRuleClass = 0,
  VrfForceIrqlRuleClass = 1,
  VrfAllocationFailuresRuleClass = 2,
  VrfTrackingPoolAllocationsRuleClass = 3,
  VrfIORuleClass = 4,
  VrfDeadlockPreventionRuleClass = 5,
  VrfEnhancedIORuleClass = 6,
  VrfDMARuleClass = 7,
  VrfSecurityRuleClass = 8,
  VrfForcePendingIORequestRuleClass = 9,
  VrfIRPTrackingRuleClass = 10,
  VrfMiscellaneousRuleClass = 11,
  VrfMoreDebuggingRuleClass = 12,
  VrfMDLInvariantStackRuleClass = 13,
  VrfMDLInvariantDriverRuleClass = 14,
  VrfPowerDelayFuzzingRuleClass = 15,
  VrfPortMiniportRuleClass = 16,
  VrfStandardDDIRuleClass = 17,
  VrfAutoFailRuleClass = 18,
  VrfAdditionalDDIRuleClass = 19,
  VrfRuleClassBase = 20,
  VrfNdisWifiRuleClass = 21,
  VrfDriverLoggingRuleClass = 22,
  VrfSyncDelayFuzzingRuleClass = 23,
  VrfVMSwitchingRuleClass = 24,
  VrfCodeIntegrityRuleClass = 25,
  VrfBelow4GBAllocationRuleClass = 26,
  VrfProcessorBranchTraceRuleClass = 27,
  VrfAdvancedMMRuleClass = 28,
  VrfExtendingXDVTimeLimit = 29,
  VrfSystemBIOSRuleClass = 30,
  VrfHardwareRuleClass = 31,
  VrfStateSepRuleClass = 32,
  VrfWDFRuleClass = 33,
  VrfMoreIrqlRuleClass = 34,
  VrfXDVPlatformMode = 35,
  VrfStandalonePlatformMode = 36,
  VrfPlatformModeTest = 37,
  VrfInfoDisclosureIRPRule = 38,
  VrfLwSpecialPool = 39,
  VrfAVXCorruption = 40,
  VrfAccessModeMismatch = 41,
  ReservedForDVRF42 = 42,
  ReservedForDVRF43 = 43,
  ReservedForDVRF44 = 44,
  ReservedForDVRF45 = 45,
  ReservedForDVRF46 = 46,
  ReservedForDVRF47 = 47,
  ReservedForDVRF48 = 48,
  ReservedForDVRF49 = 49,
  ReservedForDVRF50 = 50,
  ReservedForDVRF51 = 51,
  ReservedForDVRF52 = 52,
  ReservedForDVRF53 = 53,
  ReservedForDVRF54 = 54,
  ReservedForDVRF55 = 55,
  ReservedForDVRF56 = 56,
  ReservedForDVRF57 = 57,
  ReservedForDVRF58 = 58,
  ReservedForDVRF59 = 59,
  ReservedForDVRF60 = 60,
  ReservedForDVRF61 = 61,
  ReservedForDVRF62 = 62,
  ReservedForDVRF63 = 63,
  VrfRuleClassSizeMax = 64
};

// 0x4 (4) bytes
enum _POWER_INFORMATION_LEVEL_INTERNAL_TTMTCAPI {

  PowerInformationInternalTtmFirst = 4096,
  PowerInternalTtmOpenTerminal = 4096,
  PowerInternalTtmCreateTerminal = 4097,
  PowerInternalTtmEvacuateDevices = 4098,
  PowerInternalTtmCreateTerminalEventQueue = 4099,
  PowerInternalTtmGetTerminalEvent = 4100,
  PowerInternalTtmSetDefaultDeviceAssignment = 4101,
  PowerInternalTtmAssignDevice = 4102,
  PowerInternalTtmSetDisplayState = 4103,
  PowerInternalTtmSetDisplayTimeouts = 4104,
  PowerInternalTtmSetDisplayPowerRequest = 4105,
  PowerInternalTtmSetInputWakeCapability = 4106,
  PowerInformationInternalTtmLast = 4106
};

// 0x4 (4) bytes
enum _MI_ENCLAVE_TYPE {

  MiEnclaveNone = 0,
  MiEnclaveHardware = 1,
  MiEnclaveVsm = 2,
  MiEnclaveMax = 3
};

// 0x4 (4) bytes
enum _ETW_PERFECT_HASH_FUNCTION_TYPE {

  ETW_PHF_EVENT_ID = 0,
  ETW_PHF_STACK_WALK = 1,
  ETW_PHF_MAX_COUNT = 2
};

// 0x4 (4) bytes
enum _KTHREAD_TAG {

  KThreadTagNone = 0,
  KThreadTagMediaBuffering = 1,
  KThreadTagDeadline = 2,
  KThreadTagMax = 3
};

// 0x4 (4) bytes
enum _KHETERO_RUNNING_TYPE {

  KHeteroShortRunning = 0,
  KHeteroLongRunning = 1,
  KHeteroRunningTypeMax = 2
};

// 0x4 (4) bytes
enum wil_FeatureStage {

  wil_FeatureStage_AlwaysDisabled = 0,
  wil_FeatureStage_DisabledByDefault = 1,
  wil_FeatureStage_EnabledByDefault = 2,
  wil_FeatureStage_AlwaysEnabled = 3
};

// 0x4 (4) bytes
enum _RTL_MEMORY_TYPE {

  MemoryTypePaged = 0,
  MemoryTypeNonPaged = 1,
  MemoryTypeLargePage = 2,
  MemoryTypeHugePage = 3,
  MemoryTypeMax = 4
};

// 0x4 (4) bytes
enum _PS_WAKE_REASON {

  PsWakeReasonUser = 0,
  PsWakeReasonExecutionRequired = 1,
  PsWakeReasonKernel = 2,
  PsWakeReasonInstrumentation = 3,
  PsWakeReasonPreserveProcess = 4,
  PsWakeReasonActivityReference = 5,
  PsWakeReasonWorkOnBehalf = 6,
  PsMaxWakeReasons = 7
};

// 0x4 (4) bytes
enum _MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE {

  MemoryNotContiguous = 0,
  MemoryAlignedAndContiguous = 1,
  MemoryNotResident = 2,
  MemoryNotEligibleToMakeContiguous = 3,
  MemoryContiguityStateMax = 4
};

// 0x4 (4) bytes
enum _PS_STD_HANDLE_STATE {

  PsNeverDuplicate = 0,
  PsRequestDuplicate = 1,
  PsAlwaysDuplicate = 2,
  PsMaxStdHandleStates = 3
};

// 0x4 (4) bytes
enum _POWER_INFORMATION_LEVEL_INTERNAL {

  PowerInternalAcpiInterfaceRegister = 0,
  PowerInternalS0LowPowerIdleInfo = 1,
  PowerInternalReapplyBrightnessSettings = 2,
  PowerInternalUserAbsencePrediction = 3,
  PowerInternalUserAbsencePredictionCapability = 4,
  PowerInternalPoProcessorLatencyHint = 5,
  PowerInternalStandbyNetworkRequest = 6,
  PowerInternalDirtyTransitionInformation = 7,
  PowerInternalSetBackgroundTaskState = 8,
  PowerInternalReservedDoNotUseEnum9 = 9,
  PowerInternalReservedDoNotUseEnum10 = 10,
  PowerInternalReservedDoNotUseEnum11 = 11,
  PowerInternalReservedDoNotUseEnum12 = 12,
  PowerInternalReservedDoNotUseEnum13 = 13,
  PowerInternalReservedDoNotUseEnum14 = 14,
  PowerInternalReservedDoNotUseEnum15 = 15,
  PowerInternalReservedDoNotUseEnum16 = 16,
  PowerInternalReservedDoNotUseEnum17 = 17,
  PowerInternalBootSessionStandbyActivationInformation = 18,
  PowerInternalSessionPowerState = 19,
  PowerInternalSessionTerminalInput = 20,
  PowerInternalSetWatchdog = 21,
  PowerInternalPhysicalPowerButtonPressInfoAtBoot = 22,
  PowerInternalExternalMonitorConnected = 23,
  PowerInternalHighPrecisionBrightnessSettings = 24,
  PowerInternalWinrtScreenToggle = 25,
  PowerInternalPpmQosDisable = 26,
  PowerInternalTransitionCheckpoint = 27,
  PowerInternalInputControllerState = 28,
  PowerInternalFirmwareResetReason = 29,
  PowerInternalPpmSchedulerQosSupport = 30,
  PowerInternalBootStatGet = 31,
  PowerInternalBootStatSet = 32,
  PowerInternalCallHasNotReturnedWatchdog = 33,
  PowerInternalBootStatCheckIntegrity = 34,
  PowerInternalBootStatRestoreDefaults = 35,
  PowerInternalHostEsStateUpdate = 36,
  PowerInternalGetPowerActionState = 37,
  PowerInternalBootStatUnlock = 38,
  PowerInternalWakeOnVoiceState = 39,
  PowerInternalDeepSleepBlock = 40,
  PowerInternalIsPoFxDevice = 41,
  PowerInternalPowerTransitionExtensionAtBoot = 42,
  PowerInternalProcessorBrandedFrequency = 43,
  PowerInternalTimeBrokerExpirationReason = 44,
  PowerInternalNotifyUserShutdownStatus = 45,
  PowerInternalPowerRequestTerminalCoreWindow = 46,
  PowerInternalProcessorIdleVeto = 47,
  PowerInternalPlatformIdleVeto = 48,
  PowerInternalIsLongPowerButtonBugcheckEnabled = 49,
  PowerInternalAutoChkCausedReboot = 50,
  PowerInternalSetWakeAlarmOverride = 51,
  PowerInternalDirectedFxAddTestDevice = 53,
  PowerInternalDirectedFxRemoveTestDevice = 54,
  PowerInternalDirectedFxSetMode = 56,
  PowerInternalRegisterPowerPlane = 57,
  PowerInternalSetDirectedDripsFlags = 58,
  PowerInternalClearDirectedDripsFlags = 59,
  PowerInternalRetrieveHiberFileResumeContext = 60,
  PowerInternalReadHiberFilePage = 61,
  PowerInternalLastBootSucceeded = 62,
  PowerInternalQuerySleepStudyHelperRoutineBlock = 63,
  PowerInternalDirectedDripsQueryCapabilities = 64,
  PowerInternalClearConstraints = 65,
  PowerInternalSoftParkVelocityEnabled = 66,
  PowerInternalQueryIntelPepCapabilities = 67,
  PowerInformationInternalMaximum = 68
};

// 0x4 (4) bytes
enum _BUGCHECK_RECOVERY_LOG_EVENT {

  RecoveryEventStart = 0,
  RecoveryEventPhase1Status = 1,
  RecoveryEventPhase2Status = 2,
  RecoveryEventMax = 3
};

// 0x4 (4) bytes
enum TlgIn_t {

  TlgInNULL = 0,
  TlgInUNICODESTRING = 1,
  TlgInANSISTRING = 2,
  TlgInINT8 = 3,
  TlgInUINT8 = 4,
  TlgInINT16 = 5,
  TlgInUINT16 = 6,
  TlgInINT32 = 7,
  TlgInUINT32 = 8,
  TlgInINT64 = 9,
  TlgInUINT64 = 10,
  TlgInFLOAT = 11,
  TlgInDOUBLE = 12,
  TlgInBOOL32 = 13,
  TlgInBINARY = 14,
  TlgInGUID = 15,
  _TlgInPOINTER_unsupported = 16,
  TlgInFILETIME = 17,
  TlgInSYSTEMTIME = 18,
  TlgInSID = 19,
  TlgInHEXINT32 = 20,
  TlgInHEXINT64 = 21,
  TlgInCOUNTEDSTRING = 22,
  TlgInCOUNTEDANSISTRING = 23,
  _TlgInSTRUCT = 24,
  TlgInCOUNTEDBINARY = 25,
  _TlgInMax = 26,
  TlgInINTPTR = 9,
  TlgInUINTPTR = 10,
  TlgInPOINTER = 21,
  TlgInLONG = 7,
  TlgInULONG = 8,
  TlgInHEXLONG = 20,
  _TlgInCcount = 32,
  TlgInVcount = 64,
  _TlgInChain = 128,
  _TlgInCustom = 96,
  _TlgInTypeMask = 31,
  _TlgInCountMask = 96,
  _TlgInFlagMask = 224
};

// 0x4 (4) bytes
enum PDC_RESOURCE {

  PdcResourceSystemForeground = 0,
  PdcResourceUniversalApplications = 1,
  PdcResourceWin32 = 2,
  PdcResourceNetwork = 3,
  PdcResourceSystemBackground = 4,
  PdcResourceMin = 0,
  PdcResourceMax = 4
};

// 0x4 (4) bytes
enum _POP_SLEEP_CHECKPOINT_STATUS {

  PopSleepCheckpointStatusDisabled = 0,
  PopSleepCheckpointStatusEnabledDueToDirtyShutdown = 1,
  PopSleepCheckpointStatusEnabledManually = 4,
  PopSleepCheckpointStatusEnabledExperiment = 4,
  PopSleepCheckpointStatusEnabledMax = 7,
  PopSleepCheckpointStatusFailedNotEfiSystem = 8,
  PopSleepCheckpointStatusFailedInsufficientSpace = 9,
  PopSleepCheckpointStatusFailedTooSlow = 10,
  PopSleepCheckpointStatusFailedOtherError = 15,
  PopSleepCheckpointStatusMax = 15
};

// 0x4 (4) bytes
enum _KOBJECTS {

  EventNotificationObject = 0,
  EventSynchronizationObject = 1,
  MutantObject = 2,
  ProcessObject = 3,
  QueueObject = 4,
  SemaphoreObject = 5,
  ThreadObject = 6,
  GateObject = 7,
  TimerNotificationObject = 8,
  TimerSynchronizationObject = 9,
  Spare2Object = 10,
  Spare3Object = 11,
  Spare4Object = 12,
  Spare5Object = 13,
  Spare6Object = 14,
  Spare7Object = 15,
  Spare8Object = 16,
  ProfileCallbackObject = 17,
  ApcObject = 18,
  DpcObject = 19,
  DeviceQueueObject = 20,
  PriQueueObject = 21,
  InterruptObject = 22,
  ProfileObject = 23,
  Timer2NotificationObject = 24,
  Timer2SynchronizationObject = 25,
  ThreadedDpcObject = 26,
  MaximumKernelObject = 27
};

// 0x4 (4) bytes
enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {

  JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 1,
  JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 2,
  JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 4,
  JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 8,
  JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = 15
};

// 0x4 (4) bytes
enum _MI_MEMORY_EVENT_TYPES {

  LowPagedPoolEvent = 0,
  HighPagedPoolEvent = 1,
  LowNonPagedPoolEvent = 2,
  HighNonPagedPoolEvent = 3,
  LowAvailablePagesEvent = 4,
  HighAvailablePagesEvent = 5,
  LowCommitEvent = 6,
  HighCommitEvent = 7,
  MaximumCommitEvent = 8,
  BadMemoryDetectedEvent = 9,
  PhysicalMemoryChangeEvent = 10,
  TotalNumberOfMemoryEvents = 11
};

// 0x4 (4) bytes
enum PDC_CS_PHASE {

  PdcNoCsPhase = 0,
  PdcConnectionPhase = 1,
  PdcShellPhase = 2,
  PdcPlmPhase = 3,
  PdcMaintenancePhase = 4,
  PdcDamPhase = 5,
  PdcLowPowerPhase = 6,
  PdcResiliencyNotificationPhase = 7,
  PdcResiliencyPhase = 8,
  PdcInvalidPhase = 9,
  PdcMaxPhase = 9
};

// 0x4 (4) bytes
enum _POP_SLEEP_CHECKPOINT {

  PopSleepCheckpointInvalid = 0,
  PopSleepCheckpointPowerTransitionStart = 1,
  PopSleepCheckpointSuspendAppsBefore = 2,
  PopSleepCheckpointSuspendAppsAfter = 3,
  PopSleepCheckpointSuspendServicesBefore = 4,
  PopSleepCheckpointSuspendServicesAfter = 5,
  PopSleepCheckpointNotifySuperfetchBefore = 6,
  PopSleepCheckpointNotifySuperfetchAfter = 7,
  PopSleepCheckpointNotifyCallbacksBefore = 8,
  PopSleepCheckpointNotifyCallbacksAfter = 9,
  PopSleepCheckpointSleepTransactionCommitted = 10,
  PopSleepCheckpointQueryDriversBefore = 11,
  PopSleepCheckpointQueryDriversAfter = 12,
  PopSleepCheckpointAllocatingHiberContext = 13,
  PopSleepCheckpointSuspendDriversBefore = 14,
  PopSleepCheckpointPreSleepNotification = 16,
  PopSleepCheckpointInterruptsDisabledBegin = 17,
  PopSleepCheckpointInvokeHandlerBefore = 18,
  PopSleepCheckpointSaveHiberContextBegin = 19,
  PopSleepCheckpointInitializeDumpStackFailed = 20,
  PopSleepCheckpointHiberWriteFailed = 21,
  PopSleepCheckpointHiberFileTooSmall = 22,
  PopSleepCheckpointSaveHiberContextFailed = 23,
  PopSleepCheckpointSaveHiberContextEnd = 24,
  PopSleepCheckpointHiberKernelHandoff = 25,
  PopSleepCheckpointInvokeHandlerAfter = 26,
  PopSleepCheckpointReadHiberfileBefore = 27,
  PopSleepCheckpointInitializeDumpStackForReadFailed = 28,
  PopSleepCheckpointHiberReadFailed = 29,
  PopSleepCheckpointChecksumFailure = 30,
  PopSleepCheckpointDecompressionFailed = 31,
  PopSleepCheckpointReadHiberfileAfter = 32,
  PopSleepCheckpointInterruptsDisabledEnd = 33,
  PopSleepCheckpointWakeDriversAfter = 36,
  PopSleepCheckpointResumeAppsBefore = 37,
  PopSleepCheckpointResumeAppsAfter = 38,
  PopSleepCheckpointResumeServicesBefore = 39,
  PopSleepCheckpointResumeServicesAfter = 40,
  PopSleepCheckpointPowerTransitionEnd = 41,
  PopSleepCheckpointAllocatingHiberContextNoFileObject = 42,
  PopSleepCheckpointAllocatingHiberContextGetDumpStackFailed = 43,
  PopSleepCheckpointAllocatingHiberContextLoadResumeContextFailed = 44,
  PopSleepCheckpointAllocatingHiberContextBcdOpenFailed = 45,
  PopSleepCheckpointAllocatingHiberContextEstablishResumeObjectFailed = 46,
  PopSleepCheckpointAllocatingHiberContextSetPendingResumeFailed = 47,
  PopSleepCheckpointAllocatingHiberContextAllocateIoPagesPagesFailed = 48,
  PopSleepCheckpointAllocatingHiberContextAdapterBuffersInvalid1 = 49,
  PopSleepCheckpointAllocatingHiberContextAllocateDumpPagesFailed = 50,
  PopSleepCheckpointAllocatingHiberContextAdapterBuffersInvalid2 = 51,
  PopSleepCheckpointAllocatingHiberContextUnHibernatedMdlFailed = 52,
  PopSleepCheckpointAllocatingHiberContextSecureResourcesFailed = 53,
  PopSleepCheckpointPrepareSleepBefore = 54,
  PopSleepCheckpointPrepareSleepAfter = 55,
  PopSleepCheckpointBootstatAvailable = 56,
  PopSleepCheckpointMax = 57
};

// 0x4 (4) bytes
enum _MI_ALTERNATE_LOCK_VA_TYPE {

  AlternateLockVaTypeSystemPtes = 0,
  AlternateLockVaTypeNonPagedPool = 1,
  AlternateLockVaTypeUser = 2,
  AlternateLockVaTypeSystem = 3,
  AlternateLockVaTypeMaximum = 4
};

// 0x4 (4) bytes
enum _KWAIT_BLOCK_STATE {

  WaitBlockBypassStart = 0,
  WaitBlockBypassComplete = 1,
  WaitBlockSuspendBypassStart = 2,
  WaitBlockSuspendBypassComplete = 3,
  WaitBlockActive = 4,
  WaitBlockInactive = 5,
  WaitBlockSuspended = 6,
  WaitBlockAllStates = 7
};

// 0x4 (4) bytes
enum _DEVPROP_OPERATOR {

  DEVPROP_OPERATOR_MODIFIER_NOT = 65536,
  DEVPROP_OPERATOR_MODIFIER_IGNORE_CASE = 131072,
  DEVPROP_OPERATOR_NONE = 0,
  DEVPROP_OPERATOR_EXISTS = 1,
  DEVPROP_OPERATOR_NOT_EXISTS = 65537,
  DEVPROP_OPERATOR_EQUALS = 2,
  DEVPROP_OPERATOR_NOT_EQUALS = 65538,
  DEVPROP_OPERATOR_GREATER_THAN = 3,
  DEVPROP_OPERATOR_LESS_THAN = 4,
  DEVPROP_OPERATOR_GREATER_THAN_EQUALS = 5,
  DEVPROP_OPERATOR_LESS_THAN_EQUALS = 6,
  DEVPROP_OPERATOR_EQUALS_IGNORE_CASE = 131074,
  DEVPROP_OPERATOR_NOT_EQUALS_IGNORE_CASE = 196610,
  DEVPROP_OPERATOR_BITWISE_AND = 7,
  DEVPROP_OPERATOR_BITWISE_OR = 8,
  DEVPROP_OPERATOR_BEGINS_WITH = 9,
  DEVPROP_OPERATOR_ENDS_WITH = 10,
  DEVPROP_OPERATOR_CONTAINS = 11,
  DEVPROP_OPERATOR_BEGINS_WITH_IGNORE_CASE = 131081,
  DEVPROP_OPERATOR_ENDS_WITH_IGNORE_CASE = 131082,
  DEVPROP_OPERATOR_CONTAINS_IGNORE_CASE = 131083,
  DEVPROP_OPERATOR_LIST_CONTAINS = 4096,
  DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH = 8192,
  DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH = 12288,
  DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS = 16384,
  DEVPROP_OPERATOR_LIST_CONTAINS_IGNORE_CASE = 135168,
  DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE = 139264,
  DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH_IGNORE_CASE = 143360,
  DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS_IGNORE_CASE = 147456,
  DEVPROP_OPERATOR_AND_OPEN = 1048576,
  DEVPROP_OPERATOR_AND_CLOSE = 2097152,
  DEVPROP_OPERATOR_OR_OPEN = 3145728,
  DEVPROP_OPERATOR_OR_CLOSE = 4194304,
  DEVPROP_OPERATOR_NOT_OPEN = 5242880,
  DEVPROP_OPERATOR_NOT_CLOSE = 6291456,
  DEVPROP_OPERATOR_ARRAY_CONTAINS = 268435456,
  DEVPROP_OPERATOR_MASK_EVAL = 4095,
  DEVPROP_OPERATOR_MASK_LIST = 61440,
  DEVPROP_OPERATOR_MASK_MODIFIER = 983040,
  DEVPROP_OPERATOR_MASK_NOT_LOGICAL = -267386881,
  DEVPROP_OPERATOR_MASK_LOGICAL = 267386880,
  DEVPROP_OPERATOR_MASK_ARRAY = -268435456
};

// 0x4 (4) bytes
enum _RTLP_HP_MEMORY_TYPE {

  HeapMemoryPaged = 0,
  HeapMemoryNonPaged = 1,
  HeapMemoryLargePage = 2,
  HeapMemoryHugePage = 3,
  HeapMemoryTypeMax = 4
};

// 0x4 (4) bytes
enum _RTL_FEATURE_ENABLED_STATE_OPTIONS {

  FeatureEnabledStateOptionsNone = 0,
  FeatureEnabledStateOptionsWexpConfig = 1
};

// 0x4 (4) bytes
enum _EX_HEAP_TYPE {

  ExHeapTypeNonPagedMin = 0,
  ExHeapTypeNonPaged = 0,
  ExHeapTypeNonPagedMax = 1,
  ExHeapTypeNonPagedNx = 1,
  ExHeapTypePagedMin = 2,
  ExHeapTypePaged = 2,
  ExHeapTypePagedMax = 3,
  ExHeapTypeMmSt = 3,
  ExHeapTypeMax = 4,
  ExHeapTypeSpecialMax = 4
};

// 0x4 (4) bytes
enum FEATURE_CHANGE_TIME {

  FEATURE_CHANGE_TIME_READ = 0,
  FEATURE_CHANGE_TIME_MODULE_RELOAD = 1,
  FEATURE_CHANGE_TIME_SESSION = 2,
  FEATURE_CHANGE_TIME_REBOOT = 3,
  FEATURE_CHANGE_TIME_USER_FLAG = 128
};

// 0x4 (4) bytes
enum _POP_DIRECTED_DRIPS_PROBLEM_DEVICE_REASON {

  DirectedDripsProblemDeviceReasonSpecialDevice = 0,
  DirectedDripsProblemDeviceReasonNoDfx = 1,
  DirectedDripsProblemDeviceReasonNoPs4 = 2,
  DirectedDripsProblemDeviceReasonNoPs4Root = 3,
  DirectedDripsProblemDeviceReasonComponentContraint = 4,
  DirectedDripsProblemDeviceReasonDfxFailure = 5,
  DirectedDripsProblemDeviceReasonPagingDevice = 6,
  DirectedDripsProblemDeviceReasonDebuggingDevice = 7,
  DirectedDripsProblemDeviceReasonDfxNotAllowed = 8,
  DirectedDripsProblemDeviceReasonMax = 9
};

// 0x4 (4) bytes
enum _PROCESS_SECTION_TYPE {

  ProcessSectionData = 0,
  ProcessSectionImage = 1,
  ProcessSectionImageNx = 2,
  ProcessSectionPagefileBacked = 3,
  ProcessSectionMax = 4
};

// 0x4 (4) bytes
enum _FILE_OBJECT_EXTENSION_TYPE {

  FoExtTypeTransactionParams = 0,
  FoExtTypeInternal = 1,
  FoExtTypeIosbRange = 2,
  FoExtTypeGeneric = 3,
  FoExtTypeSfio = 4,
  FoExtTypeSymlink = 5,
  FoExtTypeOplockKey = 6,
  FoExtTypeSilo = 7,
  FoExtTypeMemoryPartitionInfo = 8,
  MaxFoExtTypes = 9
};

// 0x4 (4) bytes
enum _OBJECT_INFORMATION_CLASS {

  ObjectBasicInformation = 0,
  ObjectNameInformation = 1,
  ObjectTypeInformation = 2,
  ObjectTypesInformation = 3,
  ObjectHandleFlagInformation = 4,
  ObjectSessionInformation = 5,
  ObjectSessionObjectInformation = 6,
  MaxObjectInfoClass = 7
};

// 0x4 (4) bytes
enum _JOBOBJECTINFOCLASS {

  JobObjectBasicAccountingInformation = 1,
  JobObjectBasicLimitInformation = 2,
  JobObjectBasicProcessIdList = 3,
  JobObjectBasicUIRestrictions = 4,
  JobObjectSecurityLimitInformation = 5,
  JobObjectEndOfJobTimeInformation = 6,
  JobObjectAssociateCompletionPortInformation = 7,
  JobObjectBasicAndIoAccountingInformation = 8,
  JobObjectExtendedLimitInformation = 9,
  JobObjectJobSetInformation = 10,
  JobObjectGroupInformation = 11,
  JobObjectNotificationLimitInformation = 12,
  JobObjectLimitViolationInformation = 13,
  JobObjectGroupInformationEx = 14,
  JobObjectCpuRateControlInformation = 15,
  JobObjectCompletionFilter = 16,
  JobObjectCompletionCounter = 17,
  JobObjectFreezeInformation = 18,
  JobObjectExtendedAccountingInformation = 19,
  JobObjectWakeInformation = 20,
  JobObjectBackgroundInformation = 21,
  JobObjectSchedulingRankBiasInformation = 22,
  JobObjectTimerVirtualizationInformation = 23,
  JobObjectCycleTimeNotification = 24,
  JobObjectClearEvent = 25,
  JobObjectInterferenceInformation = 26,
  JobObjectClearPeakJobMemoryUsed = 27,
  JobObjectMemoryUsageInformation = 28,
  JobObjectSharedCommit = 29,
  JobObjectContainerId = 30,
  JobObjectIoRateControlInformation = 31,
  JobObjectSiloRootDirectory = 37,
  JobObjectServerSiloBasicInformation = 38,
  JobObjectServerSiloUserSharedData = 39,
  JobObjectServerSiloInitialize = 40,
  JobObjectServerSiloRunningState = 41,
  JobObjectIoAttribution = 42,
  JobObjectMemoryPartitionInformation = 43,
  JobObjectContainerTelemetryId = 44,
  JobObjectSiloSystemRoot = 45,
  JobObjectEnergyTrackingState = 46,
  JobObjectThreadImpersonationInformation = 47,
  JobObjectReserved1Information = 18,
  JobObjectReserved2Information = 19,
  JobObjectReserved3Information = 20,
  JobObjectReserved4Information = 21,
  JobObjectReserved5Information = 22,
  JobObjectReserved6Information = 23,
  JobObjectReserved7Information = 24,
  JobObjectReserved8Information = 25,
  JobObjectReserved9Information = 26,
  JobObjectReserved10Information = 27,
  JobObjectReserved11Information = 28,
  JobObjectReserved12Information = 29,
  JobObjectReserved13Information = 30,
  JobObjectReserved14Information = 31,
  JobObjectNetRateControlInformation = 32,
  JobObjectNotificationLimitInformation2 = 33,
  JobObjectLimitViolationInformation2 = 34,
  JobObjectCreateSilo = 35,
  JobObjectSiloBasicInformation = 36,
  JobObjectReserved15Information = 37,
  JobObjectReserved16Information = 38,
  JobObjectReserved17Information = 39,
  JobObjectReserved18Information = 40,
  JobObjectReserved19Information = 41,
  JobObjectReserved20Information = 42,
  JobObjectReserved21Information = 43,
  JobObjectReserved22Information = 44,
  JobObjectReserved23Information = 45,
  JobObjectReserved24Information = 46,
  JobObjectReserved25Information = 47,
  MaxJobObjectInfoClass = 48
};

// 0x4 (4) bytes
enum _IO_RATE_CONTROL_TYPE {

  IoRateControlTypeCapMin = 0,
  IoRateControlTypeIopsCap = 0,
  IoRateControlTypeBandwidthCap = 1,
  IoRateControlTypeTimePercentCap = 2,
  IoRateControlTypeCapMax = 2,
  IoRateControlTypeReservationMin = 3,
  IoRateControlTypeIopsReservation = 3,
  IoRateControlTypeBandwidthReservation = 4,
  IoRateControlTypeTimePercentReservation = 5,
  IoRateControlTypeReservationMax = 5,
  IoRateControlTypeCriticalReservationMin = 6,
  IoRateControlTypeIopsCriticalReservation = 6,
  IoRateControlTypeBandwidthCriticalReservation = 7,
  IoRateControlTypeTimePercentCriticalReservation = 8,
  IoRateControlTypeCriticalReservationMax = 8,
  IoRateControlTypeSoftCapMin = 9,
  IoRateControlTypeIopsSoftCap = 9,
  IoRateControlTypeBandwidthSoftCap = 10,
  IoRateControlTypeTimePercentSoftCap = 11,
  IoRateControlTypeSoftCapMax = 11,
  IoRateControlTypeLimitExcessNotifyMin = 12,
  IoRateControlTypeIopsLimitExcessNotify = 12,
  IoRateControlTypeBandwidthLimitExcessNotify = 13,
  IoRateControlTypeTimePercentLimitExcessNotify = 14,
  IoRateControlTypeLimitExcessNotifyMax = 14,
  IoRateControlTypeMax = 15
};

// 0x4 (4) bytes
enum _WNF_STATE_NAME_LIFETIME {

  WnfWellKnownStateName = 0,
  WnfPermanentStateName = 1,
  WnfPersistentStateName = 2,
  WnfTemporaryStateName = 3
};

// 0x4 (4) bytes
enum _TRANSFER_TYPE {

  ReadTransfer = 0,
  WriteTransfer = 1,
  OtherTransfer = 2
};

// 0x4 (4) bytes
enum _LOCK_OPERATION {

  IoReadAccess = 0,
  IoWriteAccess = 1,
  IoModifyAccess = 2
};

// 0x4 (4) bytes
enum _KWAIT_REASON {

  Executive = 0,
  FreePage = 1,
  PageIn = 2,
  PoolAllocation = 3,
  DelayExecution = 4,
  Suspended = 5,
  UserRequest = 6,
  WrExecutive = 7,
  WrFreePage = 8,
  WrPageIn = 9,
  WrPoolAllocation = 10,
  WrDelayExecution = 11,
  WrSuspended = 12,
  WrUserRequest = 13,
  WrSpare0 = 14,
  WrQueue = 15,
  WrLpcReceive = 16,
  WrLpcReply = 17,
  WrVirtualMemory = 18,
  WrPageOut = 19,
  WrRendezvous = 20,
  WrKeyedEvent = 21,
  WrTerminated = 22,
  WrProcessInSwap = 23,
  WrCpuRateControl = 24,
  WrCalloutStack = 25,
  WrKernel = 26,
  WrResource = 27,
  WrPushLock = 28,
  WrMutex = 29,
  WrQuantumEnd = 30,
  WrDispatchInt = 31,
  WrPreempted = 32,
  WrYieldExecution = 33,
  WrFastMutex = 34,
  WrGuardedMutex = 35,
  WrRundown = 36,
  WrAlertByThreadId = 37,
  WrDeferredPreempt = 38,
  WrPhysicalFault = 39,
  MaximumWaitReason = 40
};

// 0x4 (4) bytes
enum _RTLP_HP_ALLOCATOR {

  RtlpHpSegmentSm = 0,
  RtlpHpSegmentLg = 1,
  RtlpHpSegmentTypes = 2,
  RtlpHpHugeAllocator = 2,
  RtlpHpAllocatorMax = 3
};

// 0x4 (4) bytes
enum _HEAP_SEG_RANGE_TYPE {

  HeapSegRangeUser = 0,
  HeapSegRangeInternal = 1,
  HeapSegRangeLFH = 2,
  HeapSegRangeVS = 3,
  HeapSegRangeTypeMax = 3
};

// 0x4 (4) bytes
enum _HEAP_LFH_LOCKMODE {

  HeapLockNotHeld = 0,
  HeapLockShared = 1,
  HeapLockExclusive = 2
};

// 0x4 (4) bytes
enum RTLP_CSPARSE_BITMAP_STATE {

  CommitBitmapInvalid = 0,
  UserBitmapInvalid = 1,
  UserBitmapValid = 2
};

// 0x4 (4) bytes
enum _OPENCOUNT_REASON {

  OpenCount_SkipLogging = 0,
  OpenCount_AsyncRead = 1,
  OpenCount_FlushCache = 2,
  OpenCount_GetDirtyPage = 3,
  OpenCount_GetFlushedVDL = 4,
  OpenCount_InitCachemap1 = 5,
  OpenCount_InitCachemap2 = 6,
  OpenCount_InitCachemap3 = 7,
  OpenCount_InitCachemap4 = 8,
  OpenCount_InitCachemap5 = 9,
  OpenCount_MdlWrite = 10,
  OpenCount_MdlWriteAbort = 11,
  OpenCount_NotifyMappedWrite = 12,
  OpenCount_NotifyMappedWriteCompCallback = 13,
  OpenCount_PurgeCache = 14,
  OpenCount_PurgeCacheActiveViews = 15,
  OpenCount_ReadAhead = 16,
  OpenCount_SetFileSize = 17,
  OpenCount_SetFileSizeSection = 18,
  OpenCount_UninitCachemapReadAhead = 19,
  OpenCount_UninitCachemapReg = 20,
  OpenCount_UnmapInactiveViews = 21,
  OpenCount_UnmapInactiveViews1 = 22,
  OpenCount_UnmapInactiveViews2 = 23,
  OpenCount_UnmapInactiveViews3 = 24,
  OpenCount_WriteBehind = 25,
  OpenCount_WriteBehindComplete = 26,
  OpenCount_WriteBehindFailAcquire = 27
};

// 0x4 (4) bytes
enum _POWER_REQUEST_TYPE_INTERNAL {

  PowerRequestDisplayRequiredInternal = 0,
  PowerRequestSystemRequiredInternal = 1,
  PowerRequestAwayModeRequiredInternal = 2,
  PowerRequestExecutionRequiredInternal = 3,
  PowerRequestPerfBoostRequiredInternal = 4,
  PowerRequestActiveLockScreenInternal = 5,
  PowerRequestInternalInvalid = 6
};

// 0x4 (4) bytes
enum _POWER_REQUEST_TYPE {

  PowerRequestDisplayRequired = 0,
  PowerRequestSystemRequired = 1,
  PowerRequestAwayModeRequired = 2,
  PowerRequestExecutionRequired = 3
};

// 0x4 (4) bytes
enum _CMP_FAILURE_INJECTION_POINT {

  CmpFailurePointPoolAllocation = 0,
  CmpFailurePointViewMapping = 1,
  CmpFailurePointViewPinning = 2,
  CmpFailurePointResourceCharging = 3,
  CmpFailurePointFileWrite = 4,
  CmpFailurePointFileRead = 5,
  CmpFailurePointCacheFlush = 6,
  CmpFailurePointFlush = 7,
  CmpFailurePointFlushAndPurge = 8,
  CmpFailurePointForceLargeBin = 9,
  CmpFailurePointDontFixAlignment = 10,
  CmpFailurePointAllocateCell = 11,
  CmpFailurePointMarkDirty = 12,
  CmpFailurePointForceMultiLevelMap = 13,
  CmpFailurePointAllocateContiguousLogEntry = 14,
  CmpFailurePointAllocateKcb = 15,
  CmpFailurePointCreateKeyBody = 16,
  CmpFailurePointForceFreeKcb = 17,
  CmpFailurePointKcbLockUpgrade = 18,
  CmpFailurePointKcbLockUpgradeDelay = 19,
  CmpFailurePointKeyEnumResumeContextVerification = 20,
  CmpFailurePointKeyEnumForceRetry = 21,
  CmpFailurePointForceReorganization = 22,
  CmpFailurePointForceLazyCOWByPolicy = 23,
  CmpFailureInjectionPointCount = 24
};

// 0x4 (4) bytes
enum wil_UsageReportingMode {

  wil_UsageReportingMode_Default = 0,
  wil_UsageReportingMode_SuppressPotential = 1,
  wil_UsageReportingMode_SuppressImplicit = 2
};

// 0x4 (4) bytes
enum wil_details_ServiceReportingOptions {

  wil_details_ServiceReportingOptions_None = 0,
  wil_details_ServiceReportingOptions_VariantConfig = 1
};

// 0x4 (4) bytes
enum _RTL_FEATURE_CONFIGURATION_TYPE {

  RtlFeatureConfigurationBoot = 0,
  RtlFeatureConfigurationRuntime = 1,
  RtlFeatureConfigurationCount = 2
};

// 0x4 (4) bytes
enum wil_FeatureChangeTime {

  wil_FeatureChangeTime_OnRead = 0,
  wil_FeatureChangeTime_OnReload = 1,
  wil_FeatureChangeTime_OnSession = 2,
  wil_FeatureChangeTime_OnReboot = 3
};

// 0x4 (4) bytes
enum wil_details_StagingConfigFeatureFields {

  wil_details_StagingConfigFeatureFields_None = 0,
  wil_details_StagingConfigFeatureFields_ServiceState = 1,
  wil_details_StagingConfigFeatureFields_UserState = 2,
  wil_details_StagingConfigFeatureFields_TestState = 4,
  wil_details_StagingConfigFeatureFields_Variant = 8
};

// 0x4 (4) bytes
enum wil_FeatureEnabledStateKind {

  wil_FeatureEnabledStateKind_Service = 1,
  wil_FeatureEnabledStateKind_User = 2,
  wil_FeatureEnabledStateKind_Test = 3
};

// 0x4 (4) bytes
enum wil_FeatureEnabledStateOptions {

  wil_FeatureEnabledStateOptions_None = 0,
  wil_FeatureEnabledStateOptions_VariantConfig = 1
};

// 0x4 (4) bytes
enum wil_VariantReportingKind {

  wil_VariantReportingKind_None = 0,
  wil_VariantReportingKind_UniqueUsage = 1,
  wil_VariantReportingKind_DeviceUsage = 2
};

// 0x4 (4) bytes
enum wil_ReportingKind {

  wil_ReportingKind_None = 0,
  wil_ReportingKind_UniqueUsage = 1,
  wil_ReportingKind_UniqueOpportunity = 2,
  wil_ReportingKind_DeviceUsage = 3,
  wil_ReportingKind_DeviceOpportunity = 4,
  wil_ReportingKind_TotalDuration = 5,
  wil_ReportingKind_PausedDuration = 6
};

// 0x4 (4) bytes
enum wil_details_ServiceReportingKind {

  wil_details_ServiceReportingKind_UniqueUsage = 0,
  wil_details_ServiceReportingKind_UniqueOpportunity = 1,
  wil_details_ServiceReportingKind_DeviceUsage = 2,
  wil_details_ServiceReportingKind_DeviceOpportunity = 3,
  wil_details_ServiceReportingKind_PotentialUniqueUsage = 4,
  wil_details_ServiceReportingKind_PotentialUniqueOpportunity = 5,
  wil_details_ServiceReportingKind_PotentialDeviceUsage = 6,
  wil_details_ServiceReportingKind_PotentialDeviceOpportunity = 7,
  wil_details_ServiceReportingKind_EnabledTotalDuration = 8,
  wil_details_ServiceReportingKind_EnabledPausedDuration = 9,
  wil_details_ServiceReportingKind_DisabledTotalDuration = 10,
  wil_details_ServiceReportingKind_DisabledPausedDuration = 11,
  wil_details_ServiceReportingKind_CustomEnabledBase = 100,
  wil_details_ServiceReportingKind_CustomDisabledBase = 150,
  wil_details_ServiceReportingKind_Store = 254,
  wil_details_ServiceReportingKind_None = 255,
  wil_details_ServiceReportingKind_VariantDevicePotentialBase = 256,
  wil_details_ServiceReportingKind_VariantDeviceUsageBase = 320,
  wil_details_ServiceReportingKind_VariantUniquePotentialBase = 384,
  wil_details_ServiceReportingKind_VariantUniqueUsageBase = 448
};

// 0x4 (4) bytes
enum _EVENT_INFO_CLASS {

  EventProviderBinaryTrackInfo = 0,
  EventProviderSetReserved1 = 1,
  EventProviderSetTraits = 2,
  EventProviderUseDescriptorType = 3,
  MaxEventInfo = 4
};

// 0x4 (4) bytes
enum _PF_FILE_ACCESS_TYPE {

  PfFileAccessTypeRead = 0,
  PfFileAccessTypeWrite = 1,
  PfFileAccessTypeMax = 2
};

// 0x4 (4) bytes
enum _EX_GEN_RANDOM_DOMAIN {

  ExGenRandomDomainKernel = 0,
  ExGenRandomDomainFirst = 0,
  ExGenRandomDomainUserVisible = 1,
  ExGenRandomDomainMax = 2
};

// 0x4 (4) bytes
enum _PP_NPAGED_LOOKASIDE_NUMBER {

  LookasideSmallIrpList = 0,
  LookasideMediumIrpList = 1,
  LookasideLargeIrpList = 2,
  LookasideMdlList = 3,
  LookasideCreateInfoList = 4,
  LookasideNameBufferList = 5,
  LookasideTwilightList = 6,
  LookasideCompletionList = 7,
  LookasideScratchBufferList = 8,
  LookasideMaximumList = 9
};

// 0x4 (4) bytes
enum _PS_MITIGATION_OPTION {

  PS_MITIGATION_OPTION_NX = 0,
  PS_MITIGATION_OPTION_SEHOP = 1,
  PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES = 2,
  PS_MITIGATION_OPTION_HEAP_TERMINATE = 3,
  PS_MITIGATION_OPTION_BOTTOM_UP_ASLR = 4,
  PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR = 5,
  PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS = 6,
  PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE = 7,
  PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE = 8,
  PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE = 9,
  PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD = 10,
  PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES = 11,
  PS_MITIGATION_OPTION_FONT_DISABLE = 12,
  PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE = 13,
  PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL = 14,
  PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32 = 15,
  PS_MITIGATION_OPTION_RETURN_FLOW_GUARD = 16,
  PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY = 17,
  PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD = 18,
  PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT = 19,
  PS_MITIGATION_OPTION_ROP_STACKPIVOT = 20,
  PS_MITIGATION_OPTION_ROP_CALLER_CHECK = 21,
  PS_MITIGATION_OPTION_ROP_SIMEXEC = 22,
  PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER = 23,
  PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS = 24,
  PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION = 25,
  PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER = 26,
  PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION = 27,
  PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION = 28,
  PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE = 29,
  PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY = 30,
  PS_MITIGATION_OPTION_CET_USER_SHADOW_STACKS = 31,
  PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION = 32,
  PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES = 33,
  PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY = 36
};

// 0x4 (4) bytes
enum SE_WS_APPX_SIGNATURE_ORIGIN {

  SE_WS_APPX_SIGNATURE_ORIGIN_NOT_VALIDATED = 0,
  SE_WS_APPX_SIGNATURE_ORIGIN_UNKNOWN = 1,
  SE_WS_APPX_SIGNATURE_ORIGIN_APPSTORE = 2,
  SE_WS_APPX_SIGNATURE_ORIGIN_WINDOWS = 3,
  SE_WS_APPX_SIGNATURE_ORIGIN_ENTERPRISE = 4
};

// 0x4 (4) bytes
enum _HAL_DMA_CRASH_DUMP_REGISTER_TYPE {

  HalDmaCrashDumpRegisterSet1 = 0,
  HalDmaCrashDumpRegisterSet2 = 1,
  HalDmaCrashDumpRegisterSetMax = 2
};

// 0x4 (4) bytes
enum _USER_ACTIVITY_PRESENCE {

  PowerUserPresent = 0,
  PowerUserNotPresent = 1,
  PowerUserInactive = 2,
  PowerUserMaximum = 3,
  PowerUserInvalid = 3
};

// 0x4 (4) bytes
enum _HAL_INIT_PHASE {

  HalInitPhaseBspProcEarly = 0,
  HalInitPhaseBspProcEarlyMmReady = 1,
  HalInitPhaseBspProcEarlyTimerReady = 2,
  HalInitPhaseBspProcEarlyEnd = 3,
  HalInitPhasePnProcEarly = 4,
  HalInitPhasePnProcEarlyInterruptsReady = 5,
  HalInitPhasePnProcEarlyEnd = 6,
  HalInitPhaseBspSystemEarly = 7,
  HalInitPhaseBspSystemEarlyAcpiReady = 8,
  HalInitPhaseBspSystemEarlyHalExtensionsReady = 9,
  HalInitPhaseBspSystemEarlyInterruptsAlmostReady = 10,
  HalInitPhaseBspSystemEarlyIommusReady = 11,
  HalInitPhaseBspSystemEarlyInterruptsReady = 12,
  HalInitPhaseBspSystemEarlyDmaReady = 12,
  HalInitPhaseBspSystemEarlyProcReady = 13,
  HalInitPhaseBspSystemEarlyHwPerfCntReady = 14,
  HalInitPhaseBspSystemEarlyAllocationDone = 15,
  HalInitPhaseBspSystemEarlyEnd = 16,
  HalInitPhaseBspSystemLate = 17,
  HalInitPhaseBspSystemLateEnd = 18,
  HalInitPhasePnSystemLate = 19,
  HalInitPhasePnSystemLateEnd = 20,
  HalInitPhaseAllProcStartComplete = 21,
  HalInitPhaseAllProcStartCompleteEnd = 22,
  HalInitPhaseExPhase1Ready = 23,
  HalInitPhaseExPhase1ReadyEnd = 24,
  HalInitPhaseAcpiPdoStarted = 25,
  HalInitPhaseAcpiPdoStartedEnd = 26,
  HalInitPhaseReportResources = 27,
  HalInitPhaseReportResourcesEnd = 28,
  HalInitPhaseReportCoreSystemResources = 29,
  HalInitPhaseReportCoreSystemResourcesEnd = 30,
  HalInitPhaseLateSystemActions = 31,
  HalInitPhaseLateSystemActionsTelemetryReady = 32,
  HalInitPhaseLateSystemActionsEnd = 33
};

// 0x4 (4) bytes
enum _INTERLOCKED_RESULT {

  ResultNegative = 1,
  ResultZero = 0,
  ResultPositive = 2
};

// 0x4 (4) bytes
enum _MEMORY_CACHING_TYPE_ORIG {

  MmFrameBufferCached = 2
};

// 0x4 (4) bytes
enum _MODE {

  KernelMode = 0,
  UserMode = 1,
  MaximumMode = 2
};

// 0x4 (4) bytes
enum _HALP_DMA_MAP_BUFFER_TYPE {

  HalpDmaContiguousMapBuffer = 0,
  HalpDmaNonContiguousMapBuffer = 1,
  HalpDmaMaximumMapBufferType = 2
};

// 0x4 (4) bytes
enum _REG_NOTIFY_CLASS {

  RegNtDeleteKey = 0,
  RegNtPreDeleteKey = 0,
  RegNtSetValueKey = 1,
  RegNtPreSetValueKey = 1,
  RegNtDeleteValueKey = 2,
  RegNtPreDeleteValueKey = 2,
  RegNtSetInformationKey = 3,
  RegNtPreSetInformationKey = 3,
  RegNtRenameKey = 4,
  RegNtPreRenameKey = 4,
  RegNtEnumerateKey = 5,
  RegNtPreEnumerateKey = 5,
  RegNtEnumerateValueKey = 6,
  RegNtPreEnumerateValueKey = 6,
  RegNtQueryKey = 7,
  RegNtPreQueryKey = 7,
  RegNtQueryValueKey = 8,
  RegNtPreQueryValueKey = 8,
  RegNtQueryMultipleValueKey = 9,
  RegNtPreQueryMultipleValueKey = 9,
  RegNtPreCreateKey = 10,
  RegNtPostCreateKey = 11,
  RegNtPreOpenKey = 12,
  RegNtPostOpenKey = 13,
  RegNtKeyHandleClose = 14,
  RegNtPreKeyHandleClose = 14,
  RegNtPostDeleteKey = 15,
  RegNtPostSetValueKey = 16,
  RegNtPostDeleteValueKey = 17,
  RegNtPostSetInformationKey = 18,
  RegNtPostRenameKey = 19,
  RegNtPostEnumerateKey = 20,
  RegNtPostEnumerateValueKey = 21,
  RegNtPostQueryKey = 22,
  RegNtPostQueryValueKey = 23,
  RegNtPostQueryMultipleValueKey = 24,
  RegNtPostKeyHandleClose = 25,
  RegNtPreCreateKeyEx = 26,
  RegNtPostCreateKeyEx = 27,
  RegNtPreOpenKeyEx = 28,
  RegNtPostOpenKeyEx = 29,
  RegNtPreFlushKey = 30,
  RegNtPostFlushKey = 31,
  RegNtPreLoadKey = 32,
  RegNtPostLoadKey = 33,
  RegNtPreUnLoadKey = 34,
  RegNtPostUnLoadKey = 35,
  RegNtPreQueryKeySecurity = 36,
  RegNtPostQueryKeySecurity = 37,
  RegNtPreSetKeySecurity = 38,
  RegNtPostSetKeySecurity = 39,
  RegNtCallbackObjectContextCleanup = 40,
  RegNtPreRestoreKey = 41,
  RegNtPostRestoreKey = 42,
  RegNtPreSaveKey = 43,
  RegNtPostSaveKey = 44,
  RegNtPreReplaceKey = 45,
  RegNtPostReplaceKey = 46,
  RegNtPreQueryKeyName = 47,
  RegNtPostQueryKeyName = 48,
  MaxRegNtNotifyClass = 49
};

// 0x4 (4) bytes
enum _DEVICE_WAKE_DEPTH {

  DeviceWakeDepthNotWakeable = 0,
  DeviceWakeDepthD0 = 1,
  DeviceWakeDepthD1 = 2,
  DeviceWakeDepthD2 = 3,
  DeviceWakeDepthD3hot = 4,
  DeviceWakeDepthD3cold = 5,
  DeviceWakeDepthMaximum = 6
};

// 0x4 (4) bytes
enum _DEVICE_POWER_STATE {

  PowerDeviceUnspecified = 0,
  PowerDeviceD0 = 1,
  PowerDeviceD1 = 2,
  PowerDeviceD2 = 3,
  PowerDeviceD3 = 4,
  PowerDeviceMaximum = 5
};

// 0x4 (4) bytes
enum _EVENT_TYPE {

  NotificationEvent = 0,
  SynchronizationEvent = 1
};

// 0x4 (4) bytes
enum _EX_POOL_PRIORITY {

  LowPoolPriority = 0,
  LowPoolPrioritySpecialPoolOverrun = 8,
  LowPoolPrioritySpecialPoolUnderrun = 9,
  NormalPoolPriority = 16,
  NormalPoolPrioritySpecialPoolOverrun = 24,
  NormalPoolPrioritySpecialPoolUnderrun = 25,
  HighPoolPriority = 32,
  HighPoolPrioritySpecialPoolOverrun = 40,
  HighPoolPrioritySpecialPoolUnderrun = 41
};

// 0x4 (4) bytes
enum _DMA_SPEED {

  Compatible = 0,
  TypeA = 1,
  TypeB = 2,
  TypeC = 3,
  TypeF = 4,
  MaximumDmaSpeed = 5
};

// 0x4 (4) bytes
enum _LDR_DDAG_STATE {

  LdrModulesMerged = -5,
  LdrModulesInitError = -4,
  LdrModulesSnapError = -3,
  LdrModulesUnloaded = -2,
  LdrModulesUnloading = -1,
  LdrModulesPlaceHolder = 0,
  LdrModulesMapping = 1,
  LdrModulesMapped = 2,
  LdrModulesWaitingForDependencies = 3,
  LdrModulesSnapping = 4,
  LdrModulesSnapped = 5,
  LdrModulesCondensed = 6,
  LdrModulesReadyToInit = 7,
  LdrModulesInitializing = 8,
  LdrModulesReadyToRun = 9
};

// 0x4 (4) bytes
enum _LDR_DLL_LOAD_REASON {

  LoadReasonStaticDependency = 0,
  LoadReasonStaticForwarderDependency = 1,
  LoadReasonDynamicForwarderDependency = 2,
  LoadReasonDelayloadDependency = 3,
  LoadReasonDynamicLoad = 4,
  LoadReasonAsImageLoad = 5,
  LoadReasonAsDataLoad = 6,
  LoadReasonEnclavePrimary = 7,
  LoadReasonEnclaveDependency = 8,
  LoadReasonUnknown = -1
};

// 0x4 (4) bytes
enum _KERNEL_STACK_LIMITS {

  BugcheckStackLimits = 0,
  DPCStackLimits = 1,
  ExpandedStackLimits = 2,
  NormalStackLimits = 3,
  Win32kStackLimits = 4,
  SwapBusyStackLimits = 5,
  IsrStackLimits = 6,
  DebuggerStackLimits = 7,
  NmiStackLimits = 8,
  MachineCheckStackLimits = 9,
  ExceptionStackLimits = 10,
  MaximumStackLimits = 11
};

// 0x4 (4) bytes
enum _DUMP_EVENTS {

  DUMP_EVENT_NONE = 0,
  DUMP_EVENT_HIBER_RESUME = 1,
  DUMP_EVENT_HIBER_RESUME_END = 2
};

// 0x4 (4) bytes
enum _POP_IO_STATUS {

  IoReady = 0,
  IoPending = 1,
  IoDone = 2
};

// 0x4 (4) bytes
enum _POP_POWER_ACTION_WATCHDOG_STATE {

  PopPowerActionWatchdogStateDisabled = 0,
  PopPowerActionWatchdogStateTransitioning = 1,
  PopPowerActionWatchdogStateResuming = 2,
  PopPowerActionWatchdogStateMax = 3
};

// 0x4 (4) bytes
enum SYSTEM_POWER_CONDITION {

  PoAc = 0,
  PoDc = 1,
  PoHot = 2,
  PoConditionMaximum = 3
};

// 0x4 (4) bytes
struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ {
  LONG unused; // offset: 0x0 (0)
};

// 0x4 (4) bytes
enum _REQUESTER_TYPE {

  KernelRequester = 0,
  UserProcessRequester = 1,
  UserSharedServiceRequester = 2
};

// 0x4 (4) bytes
enum _ETW_NOTIFICATION_TYPE {

  EtwNotificationTypeNoReply = 1,
  EtwNotificationTypeLegacyEnable = 2,
  EtwNotificationTypeEnable = 3,
  EtwNotificationTypePrivateLogger = 4,
  EtwNotificationTypePerflib = 5,
  EtwNotificationTypeAudio = 6,
  EtwNotificationTypeSession = 7,
  EtwNotificationTypeReserved = 8,
  EtwNotificationTypeCredentialUI = 9,
  EtwNotificationTypeInProcSession = 10,
  EtwNotificationTypeFilteredPrivateLogger = 11,
  EtwNotificationTypeMax = 12
};

// 0x4 (4) bytes
enum _EXQUEUEINDEX {

  ExPoolUntrusted = 0,
  IoPoolUntrusted = 1,
  ExPoolMax = 8
};

// 0x4 (4) bytes
enum _PNP_DEVICE_ACTION_REQUEST {

  AssignResources = 0,
  ClearDeviceProblem = 1,
  ClearProblem = 2,
  ClearEjectProblem = 3,
  HaltDevice = 4,
  QueryPowerRelations = 5,
  Rebalance = 6,
  ReenumerateBootDevices = 7,
  ReenumerateDeviceOnly = 8,
  ReenumerateDeviceTree = 9,
  ReenumerateRootDevices = 10,
  RequeryDeviceState = 11,
  ResetDevice = 12,
  ResourceRequirementsChanged = 13,
  RestartEnumeration = 14,
  SetDeviceProblem = 15,
  StartDevice = 16,
  StartSystemDevicesPass0 = 17,
  StartSystemDevicesPass1 = 18,
  NotifyTransportRelationsChange = 19,
  NotifyEjectionRelationsChange = 20,
  ConfigureDevice = 21,
  ConfigureDeviceClass = 22,
  ConfigureDeviceExtensions = 23,
  ConfigureDeviceReset = 24,
  ClearDmaGuardProblem = 25,
  PnpDeviceActionRequestMax = 26
};

// 0x4 (4) bytes
enum POWER_POLICY_DEVICE_TYPE {

  PolicyDeviceSystemButton = 0,
  PolicyDeviceThermalZone = 1,
  PolicyDeviceBattery = 2,
  PolicyDeviceMemory = 3,
  PolicyInitiatePowerActionAPI = 4,
  PolicySetPowerStateAPI = 5,
  PolicyImmediateDozeS4 = 6,
  PolicySystemIdle = 7,
  PolicyDeviceWakeAlarm = 8,
  PolicyDeviceFan = 9,
  PolicyCsBatterySaver = 10,
  PolicyImmediateDozeS4Predicted = 11,
  PolicyImmediateDozeS4PredictedNoWake = 12,
  PolicyImmediateDozeS4AdaptiveBudget = 13,
  PolicyImmediateDozeS4AdaptiveReserveNoWake = 14,
  PolicySystemInitiatedShutdown = 15,
  PolicyDeviceMax = 16
};

// 0x4 (4) bytes
enum _ARBITER_RESULT {

  ArbiterResultUndefined = -1,
  ArbiterResultSuccess = 0,
  ArbiterResultExternalConflict = 1,
  ArbiterResultNullRequest = 2
};

// 0x4 (4) bytes
enum _ARBITER_ACTION {

  ArbiterActionTestAllocation = 0,
  ArbiterActionRetestAllocation = 1,
  ArbiterActionCommitAllocation = 2,
  ArbiterActionRollbackAllocation = 3,
  ArbiterActionQueryAllocatedResources = 4,
  ArbiterActionWriteReservedResources = 5,
  ArbiterActionQueryConflict = 6,
  ArbiterActionQueryArbitrate = 7,
  ArbiterActionAddReserved = 8,
  ArbiterActionBootAllocation = 9
};

// 0x4 (4) bytes
enum _MI_PFN_CACHE_ATTRIBUTE {

  MiNonCached = 0,
  MiCached = 1,
  MiWriteCombined = 2,
  MiNotMapped = 3
};

// 0x4 (4) bytes
enum _BOOT_ENTROPY_SOURCE_RESULT_CODE {

  BootEntropySourceStructureUninitialized = 0,
  BootEntropySourceDisabledByPolicy = 1,
  BootEntropySourceNotPresent = 2,
  BootEntropySourceError = 3,
  BootEntropySourceSuccess = 4
};

// 0x4 (4) bytes
enum _BOOT_ENTROPY_SOURCE_ID {

  BootEntropySourceNone = 0,
  BootEntropySourceSeedfile = 1,
  BootEntropySourceExternal = 2,
  BootEntropySourceTpm = 3,
  BootEntropySourceRdrand = 4,
  BootEntropySourceTime = 5,
  BootEntropySourceAcpiOem0 = 6,
  BootEntropySourceUefi = 7,
  BootEntropySourceCng = 8,
  BootEntropySourceTcbTpm = 9,
  BootEntropySourceTcbRdrand = 10,
  BootMaxEntropySources = 10
};

// 0x4 (4) bytes
enum _DOMAIN_CONFIGURATION_ARCH {

  DomainConfigurationArm64 = 0,
  DomainConfigurationInvalid = 1
};

// 0x4 (4) bytes
enum _CONFIGURATION_TYPE {

  ArcSystem = 0,
  CentralProcessor = 1,
  FloatingPointProcessor = 2,
  PrimaryIcache = 3,
  PrimaryDcache = 4,
  SecondaryIcache = 5,
  SecondaryDcache = 6,
  SecondaryCache = 7,
  EisaAdapter = 8,
  TcAdapter = 9,
  ScsiAdapter = 10,
  DtiAdapter = 11,
  MultiFunctionAdapter = 12,
  DiskController = 13,
  TapeController = 14,
  CdromController = 15,
  WormController = 16,
  SerialController = 17,
  NetworkController = 18,
  DisplayController = 19,
  ParallelController = 20,
  PointerController = 21,
  KeyboardController = 22,
  AudioController = 23,
  OtherController = 24,
  DiskPeripheral = 25,
  FloppyDiskPeripheral = 26,
  TapePeripheral = 27,
  ModemPeripheral = 28,
  MonitorPeripheral = 29,
  PrinterPeripheral = 30,
  PointerPeripheral = 31,
  KeyboardPeripheral = 32,
  TerminalPeripheral = 33,
  OtherPeripheral = 34,
  LinePeripheral = 35,
  NetworkPeripheral = 36,
  SystemMemory = 37,
  DockingInformation = 38,
  RealModeIrqRoutingTable = 39,
  RealModePCIEnumeration = 40,
  MaximumType = 41
};

// 0x4 (4) bytes
enum _CONFIGURATION_CLASS {

  SystemClass = 0,
  ProcessorClass = 1,
  CacheClass = 2,
  AdapterClass = 3,
  ControllerClass = 4,
  PeripheralClass = 5,
  MemoryClass = 6,
  MaximumClass = 7
};

// 0x4 (4) bytes
enum _FAULT_INFORMATION_ARM64_TYPE {

  UnsupportedUpstreamTransaction = 0,
  AddressSizeFault = 1,
  TlbMatchConflict = 2,
  ExternalFault = 3,
  PermissionFault = 4,
  AccessFlagFault = 5,
  TranslationFault = 6,
  MaxFaultType = 7
};

// 0x4 (4) bytes
enum HAL_APIC_DESTINATION_MODE {

  ApicDestinationModePhysical = 1,
  ApicDestinationModeLogicalFlat = 2,
  ApicDestinationModeLogicalClustered = 3,
  ApicDestinationModeUnknown = 4
};

// 0x4 (4) bytes
enum _FAULT_INFORMATION_ARCH {

  FaultInformationInvalid = 0,
  FaultInformationArm64 = 1,
  FaultInformationX64 = 2
};

// 0x4 (4) bytes
enum KD_CALLBACK_ACTION {

  KdConfigureDeviceAndContinue = 0,
  KdSkipDeviceAndContinue = 1,
  KdConfigureDeviceAndStop = 2,
  KdSkipDeviceAndStop = 3
};

// 0x4 (4) bytes
enum _PCI_BUSMASTER_RID_TYPE {

  BusmasterRidInvalid = 0,
  BusmasterRidFromDeviceRid = 1,
  BusmasterRidFromBridgeRid = 2,
  BusmasterRidFromMultipleBridges = 3
};

// 0x4 (4) bytes
enum INTERRUPT_CONNECTION_TYPE {

  InterruptTypeControllerInput = 0,
  InterruptTypeXapicMessage = 1,
  InterruptTypeHypertransport = 2,
  InterruptTypeMessageRequest = 3
};

// 0x4 (4) bytes
enum KD_NAMESPACE_ENUM {

  KdNameSpacePCI = 0,
  KdNameSpaceACPI = 1,
  KdNameSpaceAny = 2,
  KdNameSpaceNone = 3,
  KdNameSpaceMax = 4
};

// 0x4 (4) bytes
enum _HAL_PROCESSOR_STAT_TYPE {

  HalProcessorStatResidency = 0,
  HalProcessorStatCount = 1,
  HalProcessorStatMax = 2
};

// 0x4 (4) bytes
enum _HAL_CLOCK_TIMER_MODE {

  HalClockTimerModePeriodic = 0,
  HalClockTimerModeOneShot = 1,
  HalClockTimerModeMax = 2
};

// 0x4 (4) bytes
enum _BUS_DATA_TYPE {

  ConfigurationSpaceUndefined = -1,
  Cmos = 0,
  EisaConfiguration = 1,
  Pos = 2,
  CbusConfiguration = 3,
  PCIConfiguration = 4,
  VMEConfiguration = 5,
  NuBusConfiguration = 6,
  PCMCIAConfiguration = 7,
  MPIConfiguration = 8,
  MPSAConfiguration = 9,
  PNPISAConfiguration = 10,
  SgiInternalConfiguration = 11,
  MaximumBusDataType = 12
};

// 0x4 (4) bytes
enum _TYPE_OF_MEMORY {

  LoaderExceptionBlock = 0,
  LoaderSystemBlock = 1,
  LoaderFree = 2,
  LoaderBad = 3,
  LoaderLoadedProgram = 4,
  LoaderFirmwareTemporary = 5,
  LoaderFirmwarePermanent = 6,
  LoaderOsloaderHeap = 7,
  LoaderOsloaderStack = 8,
  LoaderSystemCode = 9,
  LoaderHalCode = 10,
  LoaderBootDriver = 11,
  LoaderConsoleInDriver = 12,
  LoaderConsoleOutDriver = 13,
  LoaderStartupDpcStack = 14,
  LoaderStartupKernelStack = 15,
  LoaderStartupPanicStack = 16,
  LoaderStartupPcrPage = 17,
  LoaderStartupPdrPage = 18,
  LoaderRegistryData = 19,
  LoaderMemoryData = 20,
  LoaderNlsData = 21,
  LoaderSpecialMemory = 22,
  LoaderBBTMemory = 23,
  LoaderZero = 24,
  LoaderXIPRom = 25,
  LoaderHALCachedMemory = 26,
  LoaderLargePageFiller = 27,
  LoaderErrorLogMemory = 28,
  LoaderVsmMemory = 29,
  LoaderFirmwareCode = 30,
  LoaderFirmwareData = 31,
  LoaderFirmwareReserved = 32,
  LoaderEnclaveMemory = 33,
  LoaderFirmwareKsr = 34,
  LoaderEnclaveKsr = 35,
  LoaderSkMemory = 36,
  LoaderSkFirmwareReserved = 37,
  LoaderIoSpaceMemoryZeroed = 38,
  LoaderIoSpaceMemoryFree = 39,
  LoaderIoSpaceMemoryKsr = 40,
  LoaderMaximum = 41
};

// 0x4 (4) bytes
enum _VI_DEADLOCK_RESOURCE_TYPE {

  VfDeadlockUnknown = 0,
  VfDeadlockMutex = 1,
  VfDeadlockMutexAbandoned = 2,
  VfDeadlockFastMutex = 3,
  VfDeadlockFastMutexUnsafe = 4,
  VfDeadlockSpinLock = 5,
  VfDeadlockInStackQueuedSpinLock = 6,
  VfDeadlockUnusedSpinLock = 7,
  VfDeadlockEresource = 8,
  VfDeadlockTypeMaximum = 9
};

// 0x4 (4) bytes
enum _WNF_SUBSCRIPTION_STATE {

  WNF_SUB_STATE_QUIESCENT = 0,
  WNF_SUB_STATE_READY_TO_DELIVER = 1,
  WNF_SUB_STATE_IN_DELIVERY = 2,
  WNF_SUB_STATE_RETRY = 3
};

// 0x4 (4) bytes
enum _SEP_CACHED_HANDLES_ENTRY_TYPE {

  SepCachedHandlesEntryLowbox = 0,
  SepCachedHandlesEntryBnoIsolation = 1
};

// 0x4 (4) bytes
enum _CREATE_FILE_TYPE {

  CreateFileTypeNone = 0,
  CreateFileTypeNamedPipe = 1,
  CreateFileTypeMailslot = 2
};

// 0x4 (4) bytes
enum _IOP_PRIORITY_HINT {

  IopIoPriorityNotSet = 0,
  IopIoPriorityVeryLow = 1,
  IopIoPriorityLow = 2,
  IopIoPriorityNormal = 3,
  IopIoPriorityHigh = 4,
  IopIoPriorityCritical = 5,
  MaxIopIoPriorityTypes = 6
};

// 0x4 (4) bytes
enum _SECURITY_OPERATION_CODE {

  SetSecurityDescriptor = 0,
  QuerySecurityDescriptor = 1,
  DeleteSecurityDescriptor = 2,
  AssignSecurityDescriptor = 3
};

// 0x4 (4) bytes
enum _OB_OPEN_REASON {

  ObCreateHandle = 0,
  ObOpenHandle = 1,
  ObDuplicateHandle = 2,
  ObInheritHandle = 3,
  ObMaxOpenReason = 4
};

// 0x4 (4) bytes
enum _BLOB_ID {

  BLOB_TYPE_UNKNOWN = 0,
  BLOB_TYPE_CONNECTION_INFO = 1,
  BLOB_TYPE_MESSAGE = 2,
  BLOB_TYPE_SECURITY_CONTEXT = 3,
  BLOB_TYPE_SECTION = 4,
  BLOB_TYPE_REGION = 5,
  BLOB_TYPE_VIEW = 6,
  BLOB_TYPE_RESERVE = 7,
  BLOB_TYPE_DIRECT_TRANSFER = 8,
  BLOB_TYPE_HANDLE_DATA = 9,
  BLOB_TYPE_MAX_ID = 10
};

// 0x4 (4) bytes
enum _RTLP_HP_LOCK_TYPE {

  HeapLockPaged = 0,
  HeapLockNonPaged = 1,
  HeapLockTypeMax = 2
};

// 0x4 (4) bytes
enum _HEAP_FAILURE_TYPE {

  heap_failure_internal = 0,
  heap_failure_unknown = 1,
  heap_failure_generic = 2,
  heap_failure_entry_corruption = 3,
  heap_failure_multiple_entries_corruption = 4,
  heap_failure_virtual_block_corruption = 5,
  heap_failure_buffer_overrun = 6,
  heap_failure_buffer_underrun = 7,
  heap_failure_block_not_busy = 8,
  heap_failure_invalid_argument = 9,
  heap_failure_invalid_allocation_type = 10,
  heap_failure_usage_after_free = 11,
  heap_failure_cross_heap_operation = 12,
  heap_failure_freelists_corruption = 13,
  heap_failure_listentry_corruption = 14,
  heap_failure_lfh_bitmap_mismatch = 15,
  heap_failure_segment_lfh_bitmap_corruption = 16,
  heap_failure_segment_lfh_double_free = 17,
  heap_failure_vs_subsegment_corruption = 18,
  heap_failure_null_heap = 19,
  heap_failure_allocation_limit = 20,
  heap_failure_commit_limit = 21,
  heap_failure_invalid_va_mgr_query = 22
};

// 0x4 (4) bytes
enum _RTLP_HP_ADDRESS_SPACE_TYPE {

  HeapAddressUser = 0,
  HeapAddressKernel = 1,
  HeapAddressSession = 2,
  HeapAddressSecureKernel = 3,
  HeapAddressTypeMax = 4
};

// 0x4 (4) bytes
enum _KHETERO_CPU_POLICY {

  KHeteroCpuPolicyAll = 0,
  KHeteroCpuPolicyLarge = 1,
  KHeteroCpuPolicyLargeOrIdle = 2,
  KHeteroCpuPolicySmall = 3,
  KHeteroCpuPolicySmallOrIdle = 4,
  KHeteroCpuPolicyDynamic = 5,
  KHeteroCpuPolicyStaticMax = 5,
  KHeteroCpuPolicyBiasedSmall = 6,
  KHeteroCpuPolicyBiasedLarge = 7,
  KHeteroCpuPolicyDefault = 8,
  KHeteroCpuPolicyMax = 9
};

// 0x4 (4) bytes
enum _GPIO_PIN_IORESTRICTION_TYPE {

  IoRestrictionNone = 0,
  IoRestrictionInputOnly = 1,
  IoRestrictionOutputOnly = 2,
  IoRestrictionNoneAndPreserve = 3
};

// 0x4 (4) bytes
enum _GPIO_PIN_CONFIG_TYPE {

  PullDefault = 0,
  PullUp = 1,
  PullDown = 2,
  PullNone = 3
};

// 0x4 (4) bytes
enum _PEP_ACPI_RESOURCE_TYPE {

  PepAcpiMemory = 0,
  PepAcpiIoPort = 1,
  PepAcpiInterrupt = 2,
  PepAcpiGpioIo = 3,
  PepAcpiGpioInt = 4,
  PepAcpiSpbI2c = 5,
  PepAcpiSpbSpi = 6,
  PepAcpiSpbUart = 7,
  PepAcpiExtendedMemory = 8,
  PepAcpiExtendedIo = 9
};

// 0x4 (4) bytes
enum _ARBITER_REQUEST_SOURCE {

  ArbiterRequestUndefined = -1,
  ArbiterRequestLegacyReported = 0,
  ArbiterRequestHalReported = 1,
  ArbiterRequestLegacyAssigned = 2,
  ArbiterRequestPnpDetected = 3,
  ArbiterRequestPnpEnumerated = 4
};

// 0x4 (4) bytes
enum _PCW_CALLBACK_TYPE {

  PcwCallbackAddCounter = 0,
  PcwCallbackRemoveCounter = 1,
  PcwCallbackEnumerateInstances = 2,
  PcwCallbackCollectData = 3
};

// 0x4 (4) bytes
enum _CM_LOAD_FAILURE_TYPE {

  _None = 0,
  _CmpCreateHive = 1,
  _HvpBuildMap = 3,
  _HvpBuildMapForLoaderHive = 4,
  _HvpInitMap = 5,
  _HvLoadHive = 6,
  _HvpMapHiveImage = 7,
  _HvpRecoverData = 8,
  _CmpValidateHiveSecurityDescriptors = 9,
  _HvpEnlistBinInMap = 10,
  _CmCheckRegistry = 11,
  _CmRegistryIO = 12,
  _CmCheckRegistry2 = 13,
  _CmpCheckKey = 14,
  _CmpCheckValueList = 15,
  _HvCheckHive = 16,
  _HvCheckBin = 17,
  _HvpGetLogEntryDirtyVector = 18,
  _HvpReadLogEntryHeader = 19,
  _HvpReadLogEntry = 20,
  _CmpMountPreloadedHives = 21,
  _CmpLoadHiveThread = 22,
  _CmpCheckLeaf = 23,
  _HvHiveStartFileBacked = 24,
  _HvStartHiveMemoryBacked = 25,
  _HvpEnlistFreeCells = 26,
  _HvpPerformLogFileRecovery = 27,
  _CmpInitHiveFromFile = 28,
  _CmpLoadKeyCommon = 29,
  _CmpLinkHiveToMaster = 30,
  _CmLoadKey = 31,
  _CmLoadAppKey = 32,
  _CmpResolveHiveLoadConflict = 33
};

// 0x4 (4) bytes
enum _RTL_GENERIC_COMPARE_RESULTS {

  GenericLessThan = 0,
  GenericGreaterThan = 1,
  GenericEqual = 2
};

// 0x4 (4) bytes
enum _CM_DIRTY_VECTOR_OPERATION {

  DirtyVectorModified = 0,
  DirtyDataCaptureStart = 1,
  DirtyDataCaptureEnd = 2
};

// 0x4 (4) bytes
enum KTM_STATE {

  KKtmUninitialized = 0,
  KKtmInitialized = 1,
  KKtmRecovering = 2,
  KKtmOnline = 3,
  KKtmRecoveryFailed = 4,
  KKtmOffline = 5
};

// 0x4 (4) bytes
enum _KTRANSACTION_OUTCOME {

  KTxOutcomeUninitialized = 0,
  KTxOutcomeUndetermined = 1,
  KTxOutcomeCommitted = 2,
  KTxOutcomeAborted = 3,
  KTxOutcomeUnavailable = 4
};

// 0x4 (4) bytes
enum _KTRANSACTION_STATE {

  KTransactionUninitialized = 0,
  KTransactionActive = 1,
  KTransactionPreparing = 2,
  KTransactionPrepared = 3,
  KTransactionInDoubt = 4,
  KTransactionCommitted = 5,
  KTransactionAborted = 6,
  KTransactionDelegated = 7,
  KTransactionPrePreparing = 8,
  KTransactionForgotten = 9,
  KTransactionRecovering = 10,
  KTransactionPrePrepared = 11
};

// 0x4 (4) bytes
enum _KRESOURCEMANAGER_STATE {

  KResourceManagerUninitialized = 0,
  KResourceManagerOffline = 1,
  KResourceManagerOnline = 2
};

// 0x4 (4) bytes
enum HSTORAGE_TYPE {

  Stable = 0,
  Volatile = 1,
  InvalidStorage = 2
};

// 0x4 (4) bytes
enum UoWActionType {

  UoWAddThisKey = 0,
  UoWAddChildKey = 1,
  UoWDeleteThisKey = 2,
  UoWDeleteChildKey = 3,
  UoWSetValueNew = 4,
  UoWSetValueExisting = 5,
  UoWDeleteValue = 6,
  UoWSetKeyUserFlags = 7,
  UoWSetLastWriteTime = 8,
  UoWSetSecurityDescriptor = 9,
  UoWRenameSubKey = 10,
  UoWRenameOldSubKey = 11,
  UoWRenameNewSubKey = 12,
  UoWIsolation = 13,
  UoWInvalid = 14
};

// 0x4 (4) bytes
enum _KENLISTMENT_STATE {

  KEnlistmentUninitialized = 0,
  KEnlistmentActive = 256,
  KEnlistmentPreparing = 257,
  KEnlistmentPrepared = 258,
  KEnlistmentInDoubt = 259,
  KEnlistmentCommitted = 260,
  KEnlistmentCommittedNotify = 261,
  KEnlistmentCommitRequested = 262,
  KEnlistmentAborted = 263,
  KEnlistmentDelegated = 264,
  KEnlistmentDelegatedDisconnected = 265,
  KEnlistmentPrePreparing = 266,
  KEnlistmentForgotten = 267,
  KEnlistmentRecovering = 268,
  KEnlistmentAborting = 269,
  KEnlistmentReadOnly = 270,
  KEnlistmentOutcomeUnavailable = 271,
  KEnlistmentOffline = 272,
  KEnlistmentPrePrepared = 273,
  KEnlistmentInitialized = 274
};

// 0x4 (4) bytes
enum _MI_SLAB_ALLOCATOR_PROTECTION {

  MiSlabAllocatorProtectionReadExecute = 0,
  MiSlabAllocatorProtectionReadOnly = 1,
  MiSlabAllocatorProtectionNoAccess = 2,
  MiSlabAllocatorProtectionReadWrite = 3,
  MiSlabAllocatorProtectionMax = 4
};

// 0x4 (4) bytes
enum _MI_SLAB_ALLOCATOR_TYPE {

  MiSlabAllocatorTypeSlatProtected = 0,
  MiSlabAllocatorTypeUnprotected = 1,
  MiSlabAllocatorTypeMax = 2
};

// 0x4 (4) bytes
enum _MI_WRITE_TYPES {

  WriteTypeCached = 0,
  WriteTypeNonTemporal = 1,
  WriteTypeMaximum = 2
};

// 0x4 (4) bytes
enum _MMLISTS {

  ZeroedPageList = 0,
  FreePageList = 1,
  StandbyPageList = 2,
  ModifiedPageList = 3,
  ModifiedNoWritePageList = 4,
  BadPageList = 5,
  ActiveAndValid = 6,
  TransitionPage = 7
};

// 0x4 (4) bytes
enum wil_details_FeatureTestStateKind {

  wil_details_FeatureTestStateKind_EnabledState = 0,
  wil_details_FeatureTestStateKind_Variant = 1
};

// 0x4 (4) bytes
enum wil_FeatureVariantPayloadKind {

  wil_FeatureVariantPayloadKind_None = 0,
  wil_FeatureVariantPayloadKind_Resident = 1,
  wil_FeatureVariantPayloadKind_External = 2
};

// 0x4 (4) bytes
enum wil_FeatureEnabledState {

  wil_FeatureEnabledState_Default = 0,
  wil_FeatureEnabledState_Disabled = 1,
  wil_FeatureEnabledState_Enabled = 2
};

// 0x4 (4) bytes
enum wil_FeatureStore {

  wil_FeatureStore_Machine = 0,
  wil_FeatureStore_User = 1,
  wil_FeatureStore_All = 2
};

// 0x18 (24) bytes
struct wil_details_RecordUsageResult {
  LONG queueBackground;                                // offset: 0x0 (0)
  ULONG countImmediate;                                // offset: 0x4 (4)
  enum wil_details_ServiceReportingKind kindImmediate; // offset: 0x8 (8)
  ULONG payloadId;                                     // offset: 0xc (12)
  LONG ignoredUse;                                     // offset: 0x10 (16)
  LONG isVariantConfiguration;                         // offset: 0x14 (20)
};

// 0x4 (4) bytes
enum _MM_PAGE_ACCESS_TYPE {

  MmPteAccessType = 0,
  MmCcReadAheadType = 1,
  MmPfnRepurposeType = 2,
  MmMaximumPageAccessType = 3
};

// 0x4 (4) bytes
enum _IO_PRIORITY_HINT {

  IoPriorityVeryLow = 0,
  IoPriorityLow = 1,
  IoPriorityNormal = 2,
  IoPriorityHigh = 3,
  IoPriorityCritical = 4,
  MaxIoPriorityTypes = 5
};

// 0x4 (4) bytes
enum _TP_CALLBACK_PRIORITY {

  TP_CALLBACK_PRIORITY_HIGH = 0,
  TP_CALLBACK_PRIORITY_NORMAL = 1,
  TP_CALLBACK_PRIORITY_LOW = 2,
  TP_CALLBACK_PRIORITY_INVALID = 3,
  TP_CALLBACK_PRIORITY_COUNT = 3
};

// 0x4 (4) bytes
enum _ALTERNATIVE_ARCHITECTURE_TYPE {

  StandardDesign = 0,
  NEC98x86 = 1,
  EndAlternatives = 2
};

// 0x4 (4) bytes
enum _WHEA_RECOVERY_CONTEXT_ERROR_TYPE {

  WheaRecoveryContextErrorTypeMemory = 1,
  WheaRecoveryContextErrorTypePmem = 2,
  WheaRecoveryContextErrorTypeMax = 3
};

// 0x4 (4) bytes
enum DMA_COMPLETION_STATUS {

  DmaComplete = 0,
  DmaAborted = 1,
  DmaError = 2,
  DmaCancelled = 3
};

// 0x4 (4) bytes
enum _MEMORY_CACHING_TYPE {

  MmNonCached = 0,
  MmCached = 1,
  MmWriteCombined = 2,
  MmHardwareCoherentCached = 3,
  MmNonCachedUnordered = 4,
  MmUSWCCached = 5,
  MmMaximumCacheType = 6,
  MmNotMapped = -1
};

// 0x4 (4) bytes
enum _DMA_INTERRUPT_TYPE {

  InterruptTypeCompletion = 0,
  InterruptTypeError = 1,
  InterruptTypeCancelled = 2
};

// 0x4 (4) bytes
enum _EXT_IOMMU_DEVICE_TYPE {

  EXT_IOMMU_DEVICE_TYPE_INVALID = 0,
  EXT_IOMMU_DEVICE_TYPE_PCI = 1,
  EXT_IOMMU_DEVICE_TYPE_ACPI = 2,
  EXT_IOMMU_DEVICE_TYPE_IOAPIC = 3,
  EXT_IOMMU_DEVICE_TYPE_LOGICAL = 4,
  EXT_IOMMU_DEVICE_TYPE_GIC = 5,
  EXT_IOMMU_DEVICE_TYPE_TEST = 6,
  EXT_IOMMU_DEVICE_TYPE_MAX = 7
};

// 0x4 (4) bytes
enum _HALP_EMERGENCY_LA_QUEUE_TYPE {

  HalpDmaLegacyLaQueueEntry = 0,
  HalpDmaThinLaQueueEntry = 1,
  HalpDmaLaQueueEntryMax = 2
};

// 0x4 (4) bytes
enum _HALP_DMA_ADAPTER_ALLOCATION_STATE {

  HalpDmaAdapterAllocationStateNone = 0,
  HalpDmaAdapterAllocateChannel = 1,
  HalpDmaAdapterAllocateMapRegisters = 2,
  HalpDmaAdapterAllocateChannelRemapResources = 3,
  HalpDmaAdapterAllocationStateComplete = 4,
  HalpDmaAdapterAllocationStateMax = 5
};

// 0x4 (4) bytes
enum _EXT_IOMMU_TRANSLATION_TYPE {

  ExtTranslationTypePassThrough = 0,
  ExtTranslationTypeBlocked = 1,
  ExtTranslationTypeTranslate = 2,
  ExtTranslationTypeSafePassThrough = 3,
  ExtTranslationTypeInvalid = 4
};

// 0x4 (4) bytes
enum _DMA_WIDTH {

  Width8Bits = 0,
  Width16Bits = 1,
  Width32Bits = 2,
  Width64Bits = 3,
  WidthNoWrap = 4,
  MaximumDmaWidth = 5
};

// 0x4 (4) bytes
enum _WHEA_CPU_VENDOR {

  WheaCpuVendorOther = 0,
  WheaCpuVendorIntel = 1,
  WheaCpuVendorAmd = 2
};

// 0x4 (4) bytes
enum _INTERRUPT_TARGET_TYPE {

  InterruptTargetInvalid = 0,
  InterruptTargetAllIncludingSelf = 1,
  InterruptTargetAllExcludingSelf = 2,
  InterruptTargetSelfOnly = 3,
  InterruptTargetPhysical = 4,
  InterruptTargetLogicalFlat = 5,
  InterruptTargetLogicalClustered = 6,
  InterruptTargetRemapIndex = 7,
  InterruptTargetHypervisor = 8
};

// 0x4 (4) bytes
enum _INTERRUPT_RESULT {

  InterruptBeginFatalError = 0,
  InterruptBeginLine = 1,
  InterruptBeginSpurious = 2,
  InterruptBeginVector = 3,
  InterruptBeginNone = 4
};

// 0x4 (4) bytes
enum _INTERRUPT_PROBLEM {

  InterruptProblemNone = 0,
  InterruptProblemMadtParsingFailure = 1,
  InterruptProblemNoControllersFound = 2,
  InterruptProblemFailedDiscovery = 3,
  InterruptProblemInitializeLocalUnitFailed = 4,
  InterruptProblemInitializeIoUnitFailed = 5,
  InterruptProblemSetLogicalIdFailed = 6,
  InterruptProblemSetLineStateFailed = 7,
  InterruptProblemGenerateMessageFailed = 8,
  InterruptProblemConvertIdFailed = 9,
  InterruptProblemCmciSetupFailed = 10,
  InterruptProblemQueryMaxProcessorsCalledTooEarly = 11,
  InterruptProblemProcessorReset = 12,
  InterruptProblemStartProcessorFailed = 13,
  InterruptProblemProcessorNotAlive = 14,
  InterruptProblemLowerIrqlViolation = 15,
  InterruptProblemInvalidIrql = 16,
  InterruptProblemNoSuchController = 17,
  InterruptProblemNoSuchLines = 18,
  InterruptProblemBadConnectionData = 19,
  InterruptProblemBadRoutingData = 20,
  InterruptProblemInvalidProcessor = 21,
  InterruptProblemFailedToAttainTarget = 22,
  InterruptProblemUnsupportedWiringConfiguration = 23,
  InterruptProblemSpareAlreadyStarted = 24,
  InterruptProblemClusterNotFullyReplaced = 25,
  InterruptProblemNewClusterAlreadyActive = 26,
  InterruptProblemNewClusterTooLarge = 27,
  InterruptProblemCannotHardwareQuiesce = 28,
  InterruptProblemIpiDestinationUpdateFailed = 29,
  InterruptProblemNoMemory = 30,
  InterruptProblemNoIrtEntries = 31,
  InterruptProblemConnectionDataBaitAndSwitch = 32,
  InterruptProblemInvalidLogicalFlatId = 33,
  InterruptProblemDeinitializeLocalUnitFailed = 34,
  InterruptProblemDeinitializeIoUnitFailed = 35,
  InterruptProblemMismatchedThermalLvtIsr = 36,
  InterruptProblemHvRetargetFailed = 37,
  InterruptProblemDeferredErrorSetupFailed = 38
};

// 0x4 (4) bytes
enum _KNOWN_CONTROLLER_TYPE {

  InterruptControllerInvalid = 0,
  InterruptControllerPic = 1,
  InterruptControllerApic = 2,
  InterruptControllerGic = 3,
  InterruptControllerGicV3 = 4,
  InterruptControllerGicV4 = 5,
  InterruptControllerBcm = 6,
  InterruptControllerUnknown = 4096
};

// 0x4 (4) bytes
enum _KINTERRUPT_MODE {

  LevelSensitive = 0,
  Latched = 1
};

// 0x4 (4) bytes
enum _KINTERRUPT_POLARITY {

  InterruptPolarityUnknown = 0,
  InterruptActiveHigh = 1,
  InterruptRisingEdge = 1,
  InterruptActiveLow = 2,
  InterruptFallingEdge = 2,
  InterruptActiveBoth = 3,
  InterruptActiveBothTriggerLow = 3,
  InterruptActiveBothTriggerHigh = 4
};

// 0x4 (4) bytes
enum _WHEA_ERROR_PACKET_DATA_FORMAT {

  WheaDataFormatIPFSalRecord = 0,
  WheaDataFormatXPFMCA = 1,
  WheaDataFormatMemory = 2,
  WheaDataFormatPCIExpress = 3,
  WheaDataFormatNMIPort = 4,
  WheaDataFormatPCIXBus = 5,
  WheaDataFormatPCIXDevice = 6,
  WheaDataFormatGeneric = 7,
  WheaDataFormatMax = 8
};

// 0x4 (4) bytes
enum _WHEA_ERROR_SEVERITY {

  WheaErrSevRecoverable = 0,
  WheaErrSevFatal = 1,
  WheaErrSevCorrected = 2,
  WheaErrSevInformational = 3
};

// 0x4 (4) bytes
enum _WHEA_ERROR_TYPE {

  WheaErrTypeProcessor = 0,
  WheaErrTypeMemory = 1,
  WheaErrTypePCIExpress = 2,
  WheaErrTypeNMI = 3,
  WheaErrTypePCIXBus = 4,
  WheaErrTypePCIXDevice = 5,
  WheaErrTypeGeneric = 6,
  WheaErrTypePmem = 7
};

// 0x4 (4) bytes
enum _WHEA_EVENT_LOG_ENTRY_ID {

  WheaEventLogEntryIdCmcPollingTimeout = -2147483647,
  WheaEventLogEntryIdWheaInit = -2147483646,
  WheaEventLogEntryIdCmcSwitchToPolling = -2147483645,
  WheaEventLogEntryIdDroppedCorrectedError = -2147483644,
  WheaEventLogEntryIdStartedReportHwError = -2147483643,
  WheaEventLogEntryIdPFAMemoryOfflined = -2147483642,
  WheaEventLogEntryIdPFAMemoryRemoveMonitor = -2147483641,
  WheaEventLogEntryIdPFAMemoryPolicy = -2147483640,
  WheaEventLogEntryIdPshedInjectError = -2147483639,
  WheaEventLogEntryIdOscCapabilities = -2147483638,
  WheaEventLogEntryIdPshedPluginRegister = -2147483637,
  WheaEventLogEntryIdAddRemoveErrorSource = -2147483636,
  WheaEventLogEntryIdWorkQueueItem = -2147483635,
  WheaEventLogEntryIdAttemptErrorRecovery = -2147483634,
  WheaEventLogEntryIdMcaFoundErrorInBank = -2147483633,
  WheaEventLogEntryIdMcaStuckErrorCheck = -2147483632,
  WheaEventLogEntryIdMcaErrorCleared = -2147483631,
  WheaEventLogEntryIdClearedPoison = -2147483630,
  WheaEventLogEntryIdProcessEINJ = -2147483629,
  WheaEventLogEntryIdProcessHEST = -2147483628,
  WheaEventLogEntryIdCreateGenericRecord = -2147483627,
  WheaEventLogEntryIdErrorRecord = -2147483626,
  WheaEventLogEntryIdErrorRecordLimit = -2147483625,
  WheaEventLogEntryIdErrSrcArrayInvalid = -2147483623,
  WheaEventLogEntryIdAcpiTimeOut = -2147483622,
  WheaEventLogCmciRestart = -2147483621,
  WheaEventLogCmciFinalRestart = -2147483620,
  WheaEventLogEntryEtwOverFlow = -2147483619,
  WheaEventLogAzccRootBusSearchErr = -2147483618,
  WheaEventLogAzccRootBusList = -2147483617,
  WheaEventLogEntryIdErrSrcInvalid = -2147483616,
  WheaEventLogEntryIdGenericErrMemMap = -2147483615,
  WheaEventLogEntryIdPshedCallbackCollision = -2147483614,
  WheaEventLogEntryIdSELBugCheckProgress = -2147483613,
  WheaEventLogEntryIdPshedPluginLoad = -2147483612,
  WheaEventLogEntryIdPshedPluginUnload = -2147483611,
  WheaEventLogEntryIdPshedPluginSupported = -2147483610,
  WheaEventLogEntryIdDeviceDriver = -2147483609,
  WheaEventLogEntryIdCmciImplPresent = -2147483608,
  WheaEventLogEntryIdCmciInitError = -2147483607,
  WheaEventLogEntryIdSELBugCheckRecovery = -2147483606,
  WheaEventLogEntryIdDrvErrSrcInvalid = -2147483605,
  WheaEventLogEntryIdDrvHandleBusy = -2147483604,
  WheaEventLogEntryIdWheaHeartbeat = -2147483603,
  WheaEventLogAzccRootBusPoisonSet = -2147483602,
  WheaEventLogEntryIdSELBugCheckInfo = -2147483601,
  WheaEventLogEntryIdErrDimmInfoMismatch = -2147483600,
  WheaEventLogEntryIdeDpcEnabled = -2147483599
};

// 0x4 (4) bytes
enum _WHEA_EVENT_LOG_ENTRY_TYPE {

  WheaEventLogEntryTypeInformational = 0,
  WheaEventLogEntryTypeWarning = 1,
  WheaEventLogEntryTypeError = 2
};

// 0x4 (4) bytes
enum _WHEA_ERROR_SOURCE_STATE {

  WheaErrSrcStateStopped = 1,
  WheaErrSrcStateStarted = 2,
  WheaErrSrcStateRemoved = 3,
  WheaErrSrcStateRemovePending = 4
};

// 0x4 (4) bytes
enum _WHEA_ERROR_SOURCE_TYPE {

  WheaErrSrcTypeMCE = 0,
  WheaErrSrcTypeCMC = 1,
  WheaErrSrcTypeCPE = 2,
  WheaErrSrcTypeNMI = 3,
  WheaErrSrcTypePCIe = 4,
  WheaErrSrcTypeGeneric = 5,
  WheaErrSrcTypeINIT = 6,
  WheaErrSrcTypeBOOT = 7,
  WheaErrSrcTypeSCIGeneric = 8,
  WheaErrSrcTypeIPFMCA = 9,
  WheaErrSrcTypeIPFCMC = 10,
  WheaErrSrcTypeIPFCPE = 11,
  WheaErrSrcTypeGenericV2 = 12,
  WheaErrSrcTypeSCIGenericV2 = 13,
  WheaErrSrcTypeBMC = 14,
  WheaErrSrcTypePMEM = 15,
  WheaErrSrcTypeDeviceDriver = 16,
  WheaErrSrcTypeMax = 17
};

// 0x4 (4) bytes
enum _EXCEPTION_DISPOSITION {

  ExceptionContinueExecution = 0,
  ExceptionContinueSearch = 1,
  ExceptionNestedException = 2,
  ExceptionCollidedUnwind = 3
};

// 0x4 (4) bytes
enum _DEVICE_RELATION_LEVEL {

  RELATION_LEVEL_REMOVE_EJECT = 0,
  RELATION_LEVEL_DEPENDENT = 1,
  RELATION_LEVEL_DIRECT_DESCENDANT = 2
};

// 0x4 (4) bytes
enum _PO_FX_PERF_STATE_TYPE {

  PoFxPerfStateTypeDiscrete = 0,
  PoFxPerfStateTypeRange = 1,
  PoFxPerfStateTypeMaximum = 2
};

// 0x4 (4) bytes
enum _PO_FX_PERF_STATE_UNIT {

  PoFxPerfStateUnitOther = 0,
  PoFxPerfStateUnitFrequency = 1,
  PoFxPerfStateUnitBandwidth = 2,
  PoFxPerfStateUnitMaximum = 3
};

// 0x4 (4) bytes
enum _IRQ_PRIORITY {

  IrqPriorityUndefined = 0,
  IrqPriorityLow = 1,
  IrqPriorityNormal = 2,
  IrqPriorityHigh = 3
};

// 0x4 (4) bytes
enum _FS_FILTER_SECTION_SYNC_TYPE {

  SyncTypeOther = 0,
  SyncTypeCreateSection = 1
};

// 0x4 (4) bytes
enum PROFILE_DEPARTURE_STYLE {

  PDS_UPDATE_DEFAULT = 1,
  PDS_UPDATE_ON_REMOVE = 2,
  PDS_UPDATE_ON_INTERFACE = 3,
  PDS_UPDATE_ON_EJECT = 4
};

// 0x4 (4) bytes
enum _PNP_WATCHDOG_TYPE {

  PNP_EVENT_WORKER_WATCHDOG = 1,
  PNP_DEVICE_COMPLETION_QUEUE_WATCHDOG = 2,
  PNP_DELAYED_REMOVE_WORKER_WATCHDOG = 3,
  PNP_ADD_DEVICE_WATCHDOG = 4,
  PNP_DRIVER_ENTRY_WATCHDOG = 5
};

// 0x4 (4) bytes
enum _PLUGPLAY_EVENT_CATEGORY {

  HardwareProfileChangeEvent = 0,
  TargetDeviceChangeEvent = 1,
  DeviceClassChangeEvent = 2,
  CustomDeviceEvent = 3,
  DeviceInstallEvent = 4,
  DeviceArrivalEvent = 5,
  VetoEvent = 6,
  BlockedDriverEvent = 7,
  InvalidIDEvent = 8,
  DevicePropertyChangeEvent = 9,
  DeviceInstanceRemovalEvent = 10,
  DeviceInstanceStartedEvent = 11,
  MaxPlugEventCategory = 12
};

// 0x4 (4) bytes
enum _PNP_VETO_TYPE {

  PNP_VetoTypeUnknown = 0,
  PNP_VetoLegacyDevice = 1,
  PNP_VetoPendingClose = 2,
  PNP_VetoWindowsApp = 3,
  PNP_VetoWindowsService = 4,
  PNP_VetoOutstandingOpen = 5,
  PNP_VetoDevice = 6,
  PNP_VetoDriver = 7,
  PNP_VetoIllegalDeviceRequest = 8,
  PNP_VetoInsufficientPower = 9,
  PNP_VetoNonDisableable = 10,
  PNP_VetoLegacyDriver = 11,
  PNP_VetoInsufficientRights = 12,
  PNP_VetoAlreadyRemoved = 13
};

// 0x4 (4) bytes
struct POHANDLE__ {
  LONG unused; // offset: 0x0 (0)
};

// 0x4 (4) bytes
enum _PNP_DEVNODE_QUERY_REBALANCE_VETO_REASON {

  DeviceQueryRebalanceSucceeded = 0,
  DeviceQueryStopFailed = 1,
  DeviceFailedGetNewResourceRequirement = 2,
  DeviceInUnexpectedState = 3,
  DeviceNotSupportQueryRebalance = 4
};

// 0x4 (4) bytes
enum _PNP_REBALANCE_FAILURE {

  RebalanceFailureNone = 0,
  RebalanceFailureDisabled = 1,
  RebalanceFailureNoMemory = 2,
  RebalanceFailureQueryStopUnexpectedVeto = 3,
  RebalanceFailureNoRequirements = 4,
  RebalanceFailureNoCandidates = 5,
  RebalanceFailureNoConfiguration = 6
};

// 0x4 (4) bytes
enum _PNP_REBALANCE_REASON {

  RebalanceReasonUnknown = 0,
  RebalanceReasonRequirementsChanged = 1,
  RebalanceReasonNewDevice = 2
};

// 0x4 (4) bytes
enum _KPROFILE_SOURCE {

  ProfileTime = 0,
  ProfileAlignmentFixup = 1,
  ProfileTotalIssues = 2,
  ProfilePipelineDry = 3,
  ProfileLoadInstructions = 4,
  ProfilePipelineFrozen = 5,
  ProfileBranchInstructions = 6,
  ProfileTotalNonissues = 7,
  ProfileDcacheMisses = 8,
  ProfileIcacheMisses = 9,
  ProfileCacheMisses = 10,
  ProfileBranchMispredictions = 11,
  ProfileStoreInstructions = 12,
  ProfileFpInstructions = 13,
  ProfileIntegerInstructions = 14,
  Profile2Issue = 15,
  Profile3Issue = 16,
  Profile4Issue = 17,
  ProfileSpecialInstructions = 18,
  ProfileTotalCycles = 19,
  ProfileIcacheIssues = 20,
  ProfileDcacheAccesses = 21,
  ProfileMemoryBarrierCycles = 22,
  ProfileLoadLinkedIssues = 23,
  ProfileMaximum = 24
};

// 0x4 (4) bytes
enum POWER_ACTION {

  PowerActionNone = 0,
  PowerActionReserved = 1,
  PowerActionSleep = 2,
  PowerActionHibernate = 3,
  PowerActionShutdown = 4,
  PowerActionShutdownReset = 5,
  PowerActionShutdownOff = 6,
  PowerActionWarmEject = 7,
  PowerActionDisplayOff = 8
};

// 0x4 (4) bytes
enum _DEVICE_USAGE_NOTIFICATION_TYPE {

  DeviceUsageTypeUndefined = 0,
  DeviceUsageTypePaging = 1,
  DeviceUsageTypeHibernation = 2,
  DeviceUsageTypeDumpFile = 3,
  DeviceUsageTypeBoot = 4,
  DeviceUsageTypePostDisplay = 5,
  DeviceUsageTypeGuestAssigned = 6
};

// 0x4 (4) bytes
enum DEVICE_TEXT_TYPE {

  DeviceTextDescription = 0,
  DeviceTextLocationInformation = 1
};

// 0x4 (4) bytes
enum BUS_QUERY_ID_TYPE {

  BusQueryDeviceID = 0,
  BusQueryHardwareIDs = 1,
  BusQueryCompatibleIDs = 2,
  BusQueryInstanceID = 3,
  BusQueryDeviceSerialNumber = 4,
  BusQueryContainerID = 5
};

// 0x4 (4) bytes
enum _DEVICE_RELATION_TYPE {

  BusRelations = 0,
  EjectionRelations = 1,
  PowerRelations = 2,
  RemovalRelations = 3,
  TargetDeviceRelation = 4,
  SingleBusRelations = 5,
  TransportRelations = 6
};

// 0x4 (4) bytes
enum _FSINFOCLASS {

  FileFsVolumeInformation = 1,
  FileFsLabelInformation = 2,
  FileFsSizeInformation = 3,
  FileFsDeviceInformation = 4,
  FileFsAttributeInformation = 5,
  FileFsControlInformation = 6,
  FileFsFullSizeInformation = 7,
  FileFsObjectIdInformation = 8,
  FileFsDriverPathInformation = 9,
  FileFsVolumeFlagsInformation = 10,
  FileFsSectorSizeInformation = 11,
  FileFsDataCopyInformation = 12,
  FileFsMetadataSizeInformation = 13,
  FileFsFullSizeInformationEx = 14,
  FileFsMaximumInformation = 15
};

// 0x4 (4) bytes
enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {

  DirectoryNotifyInformation = 1,
  DirectoryNotifyExtendedInformation = 2
};

// 0x4 (4) bytes
enum _FILE_INFORMATION_CLASS {

  FileDirectoryInformation = 1,
  FileFullDirectoryInformation = 2,
  FileBothDirectoryInformation = 3,
  FileBasicInformation = 4,
  FileStandardInformation = 5,
  FileInternalInformation = 6,
  FileEaInformation = 7,
  FileAccessInformation = 8,
  FileNameInformation = 9,
  FileRenameInformation = 10,
  FileLinkInformation = 11,
  FileNamesInformation = 12,
  FileDispositionInformation = 13,
  FilePositionInformation = 14,
  FileFullEaInformation = 15,
  FileModeInformation = 16,
  FileAlignmentInformation = 17,
  FileAllInformation = 18,
  FileAllocationInformation = 19,
  FileEndOfFileInformation = 20,
  FileAlternateNameInformation = 21,
  FileStreamInformation = 22,
  FilePipeInformation = 23,
  FilePipeLocalInformation = 24,
  FilePipeRemoteInformation = 25,
  FileMailslotQueryInformation = 26,
  FileMailslotSetInformation = 27,
  FileCompressionInformation = 28,
  FileObjectIdInformation = 29,
  FileCompletionInformation = 30,
  FileMoveClusterInformation = 31,
  FileQuotaInformation = 32,
  FileReparsePointInformation = 33,
  FileNetworkOpenInformation = 34,
  FileAttributeTagInformation = 35,
  FileTrackingInformation = 36,
  FileIdBothDirectoryInformation = 37,
  FileIdFullDirectoryInformation = 38,
  FileValidDataLengthInformation = 39,
  FileShortNameInformation = 40,
  FileIoCompletionNotificationInformation = 41,
  FileIoStatusBlockRangeInformation = 42,
  FileIoPriorityHintInformation = 43,
  FileSfioReserveInformation = 44,
  FileSfioVolumeInformation = 45,
  FileHardLinkInformation = 46,
  FileProcessIdsUsingFileInformation = 47,
  FileNormalizedNameInformation = 48,
  FileNetworkPhysicalNameInformation = 49,
  FileIdGlobalTxDirectoryInformation = 50,
  FileIsRemoteDeviceInformation = 51,
  FileUnusedInformation = 52,
  FileNumaNodeInformation = 53,
  FileStandardLinkInformation = 54,
  FileRemoteProtocolInformation = 55,
  FileRenameInformationBypassAccessCheck = 56,
  FileLinkInformationBypassAccessCheck = 57,
  FileVolumeNameInformation = 58,
  FileIdInformation = 59,
  FileIdExtdDirectoryInformation = 60,
  FileReplaceCompletionInformation = 61,
  FileHardLinkFullIdInformation = 62,
  FileIdExtdBothDirectoryInformation = 63,
  FileDispositionInformationEx = 64,
  FileRenameInformationEx = 65,
  FileRenameInformationExBypassAccessCheck = 66,
  FileDesiredStorageClassInformation = 67,
  FileStatInformation = 68,
  FileMemoryPartitionInformation = 69,
  FileStatLxInformation = 70,
  FileCaseSensitiveInformation = 71,
  FileLinkInformationEx = 72,
  FileLinkInformationExBypassAccessCheck = 73,
  FileStorageReserveIdInformation = 74,
  FileCaseSensitiveInformationForceAccessCheck = 75,
  FileMaximumInformation = 76
};

// 0x4 (4) bytes
enum _PNP_DEVICE_DELETE_TYPE {

  QueryRemoveDevice = 0,
  CancelRemoveDevice = 1,
  RemoveDevice = 2,
  SurpriseRemoveDevice = 3,
  EjectDevice = 4,
  RemoveFailedDevice = 5,
  RemoveUnstartedFailedDevice = 6,
  MaxDeviceDeleteType = 7
};

// 0x4 (4) bytes
enum IRPLOCK {

  IRPLOCK_CANCELABLE = 0,
  IRPLOCK_CANCEL_STARTED = 1,
  IRPLOCK_CANCEL_COMPLETE = 2,
  IRPLOCK_COMPLETED = 3
};

// 0x4 (4) bytes
enum _TOKEN_TYPE {

  TokenPrimary = 1,
  TokenImpersonation = 2
};

// 0x4 (4) bytes
enum _SECURITY_IMPERSONATION_LEVEL {

  SecurityAnonymous = 0,
  SecurityIdentification = 1,
  SecurityImpersonation = 2,
  SecurityDelegation = 3
};

// 0x4 (4) bytes
enum _ETW_BUFFER_STATE {

  EtwBufferStateFree = 0,
  EtwBufferStateGeneralLogging = 1,
  EtwBufferStateCSwitch = 2,
  EtwBufferStateFlush = 3,
  EtwBufferStatePendingCompression = 4,
  EtwBufferStateCompressed = 5,
  EtwBufferStatePlaceholder = 6,
  EtwBufferStateMaximum = 7
};

// 0x4 (4) bytes
enum _PEP_WORK_TYPE {

  PepWorkActiveComplete = 0,
  PepWorkRequestIdleState = 1,
  PepWorkDevicePower = 2,
  PepWorkRequestPowerControl = 3,
  PepWorkDeviceIdle = 4,
  PepWorkCompleteIdleState = 5,
  PepWorkCompletePerfState = 6,
  PepWorkAcpiNotify = 7,
  PepWorkAcpiEvaluateControlMethodComplete = 8,
  PepWorkMax = 9
};

// 0x4 (4) bytes
enum PROFILE_STATUS {

  DOCK_NOTDOCKDEVICE = 0,
  DOCK_QUIESCENT = 1,
  DOCK_ARRIVING = 2,
  DOCK_DEPARTING = 3,
  DOCK_EJECTIRP_COMPLETED = 4
};

// 0x4 (4) bytes
enum _SYSTEM_POWER_STATE {

  PowerSystemUnspecified = 0,
  PowerSystemWorking = 1,
  PowerSystemSleeping1 = 2,
  PowerSystemSleeping2 = 3,
  PowerSystemSleeping3 = 4,
  PowerSystemHibernate = 5,
  PowerSystemShutdown = 6,
  PowerSystemMaximum = 7
};

// 0x4 (4) bytes
enum _INTERFACE_TYPE {

  InterfaceTypeUndefined = -1,
  Internal = 0,
  Isa = 1,
  Eisa = 2,
  MicroChannel = 3,
  TurboChannel = 4,
  PCIBus = 5,
  VMEBus = 6,
  NuBus = 7,
  PCMCIABus = 8,
  CBus = 9,
  MPIBus = 10,
  MPSABus = 11,
  ProcessorInternal = 12,
  InternalPowerBus = 13,
  PNPISABus = 14,
  PNPBus = 15,
  Vmcs = 16,
  ACPIBus = 17,
  MaximumInterfaceType = 18
};

// 0x4 (4) bytes
enum _PNP_DEVNODE_STATE {

  DeviceNodeUnspecified = 768,
  DeviceNodeUninitialized = 769,
  DeviceNodeInitialized = 770,
  DeviceNodeDriversAdded = 771,
  DeviceNodeResourcesAssigned = 772,
  DeviceNodeStartPending = 773,
  DeviceNodeStartCompletion = 774,
  DeviceNodeStartPostWork = 775,
  DeviceNodeStarted = 776,
  DeviceNodeQueryStopped = 777,
  DeviceNodeStopped = 778,
  DeviceNodeRestartCompletion = 779,
  DeviceNodeEnumeratePending = 780,
  DeviceNodeEnumerateCompletion = 781,
  DeviceNodeAwaitingQueuedDeletion = 782,
  DeviceNodeAwaitingQueuedRemoval = 783,
  DeviceNodeQueryRemoved = 784,
  DeviceNodeRemovePendingCloses = 785,
  DeviceNodeRemoved = 786,
  DeviceNodeDeletePendingCloses = 787,
  DeviceNodeDeleted = 788,
  MaxDeviceNodeState = 789
};

// 0x4 (4) bytes
enum _POP_PEP_NOTIFY_DEVICE_DSTATE_REASON {

  PepNotifyDeviceDStateReasonNone = 0,
  PepNotifyDeviceDStateReasonSystemTransition = 1,
  PepNotifyDeviceDStateReasonDfx = 2,
  PepNotifyDeviceDStateReasonMax = 3
};

// 0x4 (4) bytes
enum _POWER_STATE_TYPE {

  SystemPowerState = 0,
  DevicePowerState = 1
};

// 0x4 (4) bytes
enum _WNF_DATA_SCOPE {

  WnfDataScopeSystem = 0,
  WnfDataScopeSession = 1,
  WnfDataScopeUser = 2,
  WnfDataScopeProcess = 3,
  WnfDataScopeMachine = 4,
  WnfDataScopePhysicalMachine = 5
};

// 0x4 (4) bytes
enum ETW_COMPRESSION_RESUMPTION_MODE {

  EtwCompressionModeRestart = 0,
  EtwCompressionModeNoDisable = 1,
  EtwCompressionModeNoRestart = 2
};

// 0x4 (4) bytes
enum _ETW_PERIODIC_TIMER_STATE {

  EtwpPeriodicTimerUnset = 0,
  EtwpPeriodicTimerSet = 1
};

// 0x4 (4) bytes
enum _ETW_RT_EVENT_LOSS {

  EtwRtEventNoLoss = 0,
  EtwRtEventLost = 1,
  EtwRtBufferLost = 2,
  EtwRtBackupLost = 3,
  EtwRtEventLossMax = 4
};

// 0x4 (4) bytes
struct PEPHANDLE__ {
  LONG unused; // offset: 0x0 (0)
};

// 0x4 (4) bytes
enum _PROCESSOR_PRESENCE {

  ProcessorPresenceNt = 0,
  ProcessorPresenceHv = 1,
  ProcessorPresenceHidden = 2
};

// 0x4 (4) bytes
union _POWER_STATE {
  enum _SYSTEM_POWER_STATE SystemState; // offset: 0x0 (0)
  enum _DEVICE_POWER_STATE DeviceState; // offset: 0x0 (0)
};

// 0x4 (4) bytes
enum _POP_DEVICE_IDLE_TYPE {

  DeviceIdleNormal = 0,
  DeviceIdleDisk = 1
};

// 0x4 (4) bytes
enum _IO_ALLOCATION_ACTION {

  KeepObject = 1,
  DeallocateObject = 2,
  DeallocateObjectKeepRegisters = 3
};

// 0x4 (4) bytes
enum PPM_IDLE_BUCKET_TIME_TYPE {

  PpmIdleBucketTimeInQpc = 0,
  PpmIdleBucketTimeIn100ns = 1,
  PpmIdleBucketTimeMaximum = 2
};

// 0x4 (4) bytes
enum _PROCESSOR_CACHE_TYPE {

  CacheUnified = 0,
  CacheInstruction = 1,
  CacheData = 2,
  CacheTrace = 3
};

// 0x4 (4) bytes
enum _HARDWARE_COUNTER_TYPE {

  PMCCounter = 0,
  MaxHardwareCounterType = 1
};

// 0x4 (4) bytes
enum _FUNCTION_TABLE_TYPE {

  RF_SORTED = 0,
  RF_UNSORTED = 1,
  RF_CALLBACK = 2,
  RF_KERNEL_DYNAMIC = 3
};

// 0x4 (4) bytes
enum _NT_PRODUCT_TYPE {

  NtProductWinNt = 1,
  NtProductLanManNt = 2,
  NtProductServer = 3
};

// 0x4 (4) bytes
enum _KHETERO_CPU_QOS {

  KHeteroCpuQosDefault = 0,
  KHeteroCpuQosHigh = 0,
  KHeteroCpuQosMedium = 1,
  KHeteroCpuQosLow = 2,
  KHeteroCpuQosMultimedia = 3,
  KHeteroCpuQosDeadline = 4,
  KHeteroCpuQosDynamic = 5,
  KHeteroCpuQosMax = 5
};

// 0x4 (4) bytes
enum _PROC_HYPERVISOR_STATE {

  ProcHypervisorNone = 0,
  ProcHypervisorPresent = 1,
  ProcHypervisorPower = 2,
  ProcHypervisorHvCounters = 3
};

// 0x4 (4) bytes
enum _SERVERSILO_STATE {

  SERVERSILO_INITING = 0,
  SERVERSILO_STARTED = 1,
  SERVERSILO_SHUTTING_DOWN = 2,
  SERVERSILO_TERMINATING = 3,
  SERVERSILO_TERMINATED = 4
};

// 0x4 (4) bytes
enum _MI_SYSTEM_VA_TYPE {

  MiVaUnused = 0,
  MiVaSessionSpace = 1,
  MiVaProcessSpace = 2,
  MiVaBootLoaded = 3,
  MiVaPfnDatabase = 4,
  MiVaNonPagedPool = 5,
  MiVaPagedPool = 6,
  MiVaSpecialPoolPaged = 7,
  MiVaSystemCache = 8,
  MiVaSystemPtes = 9,
  MiVaHal = 10,
  MiVaSessionGlobalSpace = 11,
  MiVaDriverImages = 12,
  MiVaSystemPtesLarge = 13,
  MiVaKernelStacks = 14,
  MiVaSecureNonPagedPool = 15,
  MiVaMaximumType = 16
};

// 0x4 (4) bytes
enum _SYSTEM_DLL_TYPE {

  PsNativeSystemDll = 0,
  PsWowX86SystemDll = 1,
  PsWowArm32SystemDll = 2,
  PsWowAmd64SystemDll = 3,
  PsWowChpeX86SystemDll = 4,
  PsVsmEnclaveRuntimeDll = 5,
  PsSystemDllTotalTypes = 6
};

// 0x4 (4) bytes
enum _IO_SESSION_STATE {

  IoSessionStateCreated = 1,
  IoSessionStateInitialized = 2,
  IoSessionStateConnected = 3,
  IoSessionStateDisconnected = 4,
  IoSessionStateDisconnectedLoggedOn = 5,
  IoSessionStateLoggedOn = 6,
  IoSessionStateLoggedOff = 7,
  IoSessionStateTerminated = 8,
  IoSessionStateMax = 9
};

// 0x4 (4) bytes
enum _POOL_TYPE {

  NonPagedPool = 0,
  NonPagedPoolExecute = 0,
  PagedPool = 1,
  NonPagedPoolMustSucceed = 2,
  DontUseThisType = 3,
  NonPagedPoolCacheAligned = 4,
  PagedPoolCacheAligned = 5,
  NonPagedPoolCacheAlignedMustS = 6,
  MaxPoolType = 7,
  NonPagedPoolBase = 0,
  NonPagedPoolBaseMustSucceed = 2,
  NonPagedPoolBaseCacheAligned = 4,
  NonPagedPoolBaseCacheAlignedMustS = 6,
  NonPagedPoolSession = 32,
  PagedPoolSession = 33,
  NonPagedPoolMustSucceedSession = 34,
  DontUseThisTypeSession = 35,
  NonPagedPoolCacheAlignedSession = 36,
  PagedPoolCacheAlignedSession = 37,
  NonPagedPoolCacheAlignedMustSSession = 38,
  NonPagedPoolNx = 512,
  NonPagedPoolNxCacheAligned = 516,
  NonPagedPoolSessionNx = 544
};

// 0x1 (1) bytes
struct _MI_WSLE {
  union {
    struct {
      UCHAR Age : 4;        // offset: 0x0 (0)
      UCHAR Protection : 3; // offset: 0x0 (0)
      UCHAR Reserved : 1;   // offset: 0x0 (0)
    } e1;                   // offset: 0x0 (0)
    struct {
      UCHAR EntireWsle; // offset: 0x0 (0)
    } e2;               // offset: 0x0 (0)

  } u1; // offset: 0x0 (0)
};

// 0x1 (1) bytes
union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
  UCHAR Trustlet : 1;    // offset: 0x0 (0)
  UCHAR Ntos : 1;        // offset: 0x0 (0)
  UCHAR WriteHandle : 1; // offset: 0x0 (0)
  UCHAR ReadHandle : 1;  // offset: 0x0 (0)
  UCHAR Reserved : 4;    // offset: 0x0 (0)
  UCHAR AccessRights;    // offset: 0x0 (0)
};

// 0x1e (30) bytes
struct _TOKEN_AUDIT_POLICY {
  UCHAR PerUserPolicy[30]; // offset: 0x0 (0)
};

// 0x1f (31) bytes
struct _SEP_AUDIT_POLICY {
  struct _TOKEN_AUDIT_POLICY AdtTokenPolicy; // offset: 0x0 (0)
  UCHAR PolicySetStatus;                     // offset: 0x1e (30)
};

// 0x1 (1) bytes
struct _ETW_LOGGER_HANDLE {
  UCHAR DereferenceAndLeave; // offset: 0x0 (0)
};

// 0x2 (2) bytes
struct _HEAP_LFH_SUBSEGMENT_STAT {
  UCHAR Index; // offset: 0x0 (0)
  UCHAR Count; // offset: 0x1 (1)
};

// 0x1 (1) bytes
struct _MMPFNENTRY3 {
  UCHAR Priority : 3;           // offset: 0x0 (0)
  UCHAR OnProtectedStandby : 1; // offset: 0x0 (0)
  UCHAR InPageError : 1;        // offset: 0x0 (0)
  UCHAR SystemChargedPage : 1;  // offset: 0x0 (0)
  UCHAR RemovalRequested : 1;   // offset: 0x0 (0)
  UCHAR ParityError : 1;        // offset: 0x0 (0)
};

// 0x1 (1) bytes
struct _MMPFNENTRY1 {
  UCHAR PageLocation : 3;    // offset: 0x0 (0)
  UCHAR WriteInProgress : 1; // offset: 0x0 (0)
  UCHAR Modified : 1;        // offset: 0x0 (0)
  UCHAR ReadInProgress : 1;  // offset: 0x0 (0)
  UCHAR CacheAttribute : 2;  // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MMPAGE_FILE_EXPANSION_FLAGS {
  UCHAR PageFileNumber : 8;        // offset: 0x0 (0)
  UCHAR Spare1 : 8;                // offset: 0x1 (1)
  UCHAR Spare2 : 8;                // offset: 0x2 (2)
  UCHAR IgnoreCurrentCommit : 1;   // offset: 0x3 (3)
  UCHAR IncreaseMinimumSize : 1;   // offset: 0x3 (3)
  UCHAR AttemptForCantExtend : 1;  // offset: 0x3 (3)
  UCHAR UnusedSegmentDeletion : 1; // offset: 0x3 (3)
  UCHAR PageFileContract : 1;      // offset: 0x3 (3)
  UCHAR NoWait : 1;                // offset: 0x3 (3)
  UCHAR Spare3 : 2;                // offset: 0x3 (3)
};

// 0x3 (3) bytes
struct _MI_RESTRICTED_MODWRITES {
  UCHAR MaximumClusterPages;  // offset: 0x0 (0)
  UCHAR ReducedClusterWrites; // offset: 0x1 (1)
  UCHAR ImposeDelay;          // offset: 0x2 (2)
};

// 0x20 (32) bytes
struct wil_details_FeatureTestState {
  enum wil_details_FeatureTestStateKind kind;     // offset: 0x0 (0)
  ULONG featureId;                                // offset: 0x4 (4)
  enum wil_FeatureEnabledState state;             // offset: 0x8 (8)
  UCHAR variant;                                  // offset: 0xc (12)
  ULONG payload;                                  // offset: 0x10 (16)
  enum wil_FeatureVariantPayloadKind payloadKind; // offset: 0x14 (20)
  struct wil_details_FeatureTestState *next;      // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct wil_FeatureState {
  enum wil_FeatureEnabledState enabledState;      // offset: 0x0 (0)
  UCHAR variant;                                  // offset: 0x4 (4)
  enum wil_FeatureVariantPayloadKind payloadKind; // offset: 0x8 (8)
  ULONG payload;                                  // offset: 0xc (12)
  LONG hasNotification;                           // offset: 0x10 (16)
  LONG isVariantConfiguration;                    // offset: 0x14 (20)
};

// 0x1 (1) bytes
union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
  UCHAR FRUId : 1;    // offset: 0x0 (0)
  UCHAR FRUText : 1;  // offset: 0x0 (0)
  UCHAR Reserved : 6; // offset: 0x0 (0)
  UCHAR AsUCHAR;      // offset: 0x0 (0)
};

// 0x1 (1) bytes
union _XPF_MC_BANK_FLAGS {
  UCHAR ClearOnInitializationRW : 1; // offset: 0x0 (0)
  UCHAR ControlDataRW : 1;           // offset: 0x0 (0)
  UCHAR Reserved : 6;                // offset: 0x0 (0)
  UCHAR AsUCHAR;                     // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _PEP_WORK_DEVICE_IDLE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  UCHAR IgnoreIdleTimeout;         // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _PEP_WORK_DEVICE_POWER {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  UCHAR PowerRequired;             // offset: 0x8 (8)
};

// 0x2 (2) bytes
struct _ETW_SYSTEM_LOGGER {
  UCHAR LoggerId;  // offset: 0x0 (0)
  UCHAR ClockType; // offset: 0x1 (1)
};

// 0x2 (2) bytes
struct _PROC_PERF_LOAD {
  UCHAR BusyPercentage;      // offset: 0x0 (0)
  UCHAR FrequencyPercentage; // offset: 0x1 (1)
};

// 0x1 (1) bytes
struct _flags {
  UCHAR Removable : 1;            // offset: 0x0 (0)
  UCHAR GroupAssigned : 1;        // offset: 0x0 (0)
  UCHAR GroupCommitted : 1;       // offset: 0x0 (0)
  UCHAR GroupAssignmentFixed : 1; // offset: 0x0 (0)
  UCHAR ProcessorOnly : 1;        // offset: 0x0 (0)
  UCHAR SmtSetsPresent : 1;       // offset: 0x0 (0)
  UCHAR Fill : 2;                 // offset: 0x0 (0)
};

// 0x6 (6) bytes
struct _PROC_IDLE_POLICY {
  UCHAR PromotePercent;     // offset: 0x0 (0)
  UCHAR DemotePercent;      // offset: 0x1 (1)
  UCHAR PromotePercentBase; // offset: 0x2 (2)
  UCHAR DemotePercentBase;  // offset: 0x3 (3)
  UCHAR AllowScaling;       // offset: 0x4 (4)
  UCHAR ForceLightIdle;     // offset: 0x5 (5)
};

// 0x6 (6) bytes
struct _SID_IDENTIFIER_AUTHORITY {
  UCHAR Value[6]; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _VF_ADDRESS_RANGE {
  UCHAR *Start; // offset: 0x0 (0)
  UCHAR *End;   // offset: 0x8 (8)
};

// 0x1 (1) bytes
union _KWAIT_STATUS_REGISTER {
  UCHAR Flags;        // offset: 0x0 (0)
  UCHAR State : 3;    // offset: 0x0 (0)
  UCHAR Affinity : 1; // offset: 0x0 (0)
  UCHAR Priority : 1; // offset: 0x0 (0)
  UCHAR Apc : 1;      // offset: 0x0 (0)
  UCHAR UserApc : 1;  // offset: 0x0 (0)
  UCHAR Alert : 1;    // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _RTL_RB_TREE {
  struct _RTL_BALANCED_NODE *Root; // offset: 0x0 (0)
  union {
    UCHAR Encoded : 1;              // offset: 0x8 (8)
    struct _RTL_BALANCED_NODE *Min; // offset: 0x8 (8)
  };
};

// 0x1 (1) bytes
union _KEXECUTE_OPTIONS {
  UCHAR ExecuteDisable : 1;                  // offset: 0x0 (0)
  UCHAR ExecuteEnable : 1;                   // offset: 0x0 (0)
  UCHAR DisableThunkEmulation : 1;           // offset: 0x0 (0)
  UCHAR Permanent : 1;                       // offset: 0x0 (0)
  UCHAR ExecuteDispatchEnable : 1;           // offset: 0x0 (0)
  UCHAR ImageDispatchEnable : 1;             // offset: 0x0 (0)
  UCHAR DisableExceptionChainValidation : 1; // offset: 0x0 (0)
  UCHAR Spare : 1;                           // offset: 0x0 (0)
  volatile UCHAR ExecuteOptions;             // offset: 0x0 (0)
  UCHAR ExecuteOptionsNV;                    // offset: 0x0 (0)
};

// 0x1 (1) bytes
struct _PS_PROTECTION {
  union {
    UCHAR Level; // offset: 0x0 (0)
    struct {
      UCHAR Type : 3;   // offset: 0x0 (0)
      UCHAR Audit : 1;  // offset: 0x0 (0)
      UCHAR Signer : 4; // offset: 0x0 (0)
    };
  };
};

// 0x10 (16) bytes
struct _MI_COMBINE_PAGE_LISTHEAD {
  struct _RTL_AVL_TREE Table; // offset: 0x0 (0)
  volatile LONG Lock;         // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _QUAD {
  union {
    LONGLONG UseThisFieldToCopy; // offset: 0x0 (0)
    double DoNotUseThisField;    // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
struct _UNEXPECTED_INTERRUPT {
  UCHAR PushImm;  // offset: 0x0 (0)
  UCHAR Vector;   // offset: 0x1 (1)
  UCHAR PushRbp;  // offset: 0x2 (2)
  UCHAR JmpOp;    // offset: 0x3 (3)
  LONG JmpOffset; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _ISR_THUNK {
  UCHAR PushImm;  // offset: 0x0 (0)
  UCHAR Vector;   // offset: 0x1 (1)
  UCHAR PushRbp;  // offset: 0x2 (2)
  UCHAR JmpOp;    // offset: 0x3 (3)
  LONG JmpOffset; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _VACB_LEVEL_REFERENCE {
  LONG Reference;        // offset: 0x0 (0)
  LONG SpecialReference; // offset: 0x4 (4)
};

// 0x4 (4) bytes
struct _DBGKD_CONTINUE {
  LONG ContinueStatus; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _ETW_PERF_COUNTERS {
  LONG TotalActiveSessions;           // offset: 0x0 (0)
  LONG TotalBufferMemoryNonPagedPool; // offset: 0x4 (4)
  LONG TotalBufferMemoryPagedPool;    // offset: 0x8 (8)
  LONG TotalGuidsEnabled;             // offset: 0xc (12)
  LONG TotalGuidsNotEnabled;          // offset: 0x10 (16)
  LONG TotalGuidsPreEnabled;          // offset: 0x14 (20)
};

// 0x10 (16) bytes
struct _ETW_COUNTERS {
  LONG GuidCount;    // offset: 0x0 (0)
  LONG PoolUsage[2]; // offset: 0x4 (4)
  LONG SessionCount; // offset: 0xc (12)
};

// 0x200 (512) bytes
struct _IOV_FORCED_PENDING_TRACE {
  struct _IRP *Irp;        // offset: 0x0 (0)
  struct _ETHREAD *Thread; // offset: 0x8 (8)
  VOID *StackTrace[62];    // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _VF_TRACKER_STAMP {
  VOID *Thread;        // offset: 0x0 (0)
  UCHAR Flags : 8;     // offset: 0x8 (8)
  UCHAR OldIrql : 8;   // offset: 0x9 (9)
  UCHAR NewIrql : 8;   // offset: 0xa (10)
  UCHAR Processor : 8; // offset: 0xb (11)
};

// 0x8 (8) bytes
struct _KWAIT_CHAIN {
  VOID *Head; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _MI_DLL_OVERFLOW_AREA {
  VOID *RangeStart;         // offset: 0x0 (0)
  VOID *NextVa;             // offset: 0x8 (8)
  VOID *RangeStartAbove2gb; // offset: 0x10 (16)
  VOID *NextVaAbove2gb;     // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _NLS_DATA_BLOCK {
  VOID *AnsiCodePageData;     // offset: 0x0 (0)
  VOID *OemCodePageData;      // offset: 0x8 (8)
  VOID *UnicodeCaseTableData; // offset: 0x10 (16)
};

// 0x18 (24) bytes
struct _HAL_LBR_ENTRY {
  VOID *FromAddress; // offset: 0x0 (0)
  VOID *ToAddress;   // offset: 0x8 (8)
  VOID *Reserved;    // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _MAP_REGISTER_ENTRY {
  VOID *MapRegister;   // offset: 0x0 (0)
  UCHAR WriteToDevice; // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _VI_FAULT_TRACE {
  struct _ETHREAD *Thread; // offset: 0x0 (0)
  VOID *StackTrace[8];     // offset: 0x8 (8)
};

// 0x40 (64) bytes
struct _VF_KE_CRITICAL_REGION_TRACE {
  struct _ETHREAD *Thread; // offset: 0x0 (0)
  VOID *StackTrace[7];     // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _OB_EXTENDED_USER_INFO {
  VOID *Context1; // offset: 0x0 (0)
  VOID *Context2; // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _FAST_OWNER_ENTRY {
  VOID *Reserved[9]; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _ALPC_HANDLE_ENTRY {
  VOID *Object; // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _HEAP_LFH_SUBSEGMENT_STATS {
  struct _HEAP_LFH_SUBSEGMENT_STAT Buckets[4]; // offset: 0x0 (0)
  VOID *AllStats;                              // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _CMSI_PROCESS_TUPLE {
  VOID *ProcessHandle;    // offset: 0x0 (0)
  VOID *ProcessReference; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _CMSI_RW_LOCK {
  VOID *Reserved; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _SECURITY_SUBJECT_CONTEXT {
  VOID *ClientToken;                                     // offset: 0x0 (0)
  enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; // offset: 0x8 (8)
  VOID *PrimaryToken;                                    // offset: 0x10 (16)
  VOID *ProcessAuditId;                                  // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct _PEP_CRASHDUMP_INFORMATION {
  struct PEPHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  VOID *DeviceContext;              // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _IO_CLIENT_EXTENSION {
  struct _IO_CLIENT_EXTENSION *NextExtension; // offset: 0x0 (0)
  VOID *ClientIdentificationAddress;          // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct RTL_HP_ENV_HANDLE {
  VOID *h[2]; // offset: 0x0 (0)
};

// 0x80 (128) bytes
struct _OBJECT_REF_TRACE {
  VOID *StackTrace[16]; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _KREQUEST_PACKET {
  VOID *CurrentPacket[3]; // offset: 0x0 (0)
  VOID (*WorkerRoutine)
  (VOID *arg1, VOID *arg2, VOID *arg3, VOID *arg4); // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct _IO_COMPLETION_CONTEXT {
  VOID *Port; // offset: 0x0 (0)
  VOID *Key;  // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _SECTION_OBJECT_POINTERS {
  VOID *DataSectionObject;  // offset: 0x0 (0)
  VOID *SharedCacheMap;     // offset: 0x8 (8)
  VOID *ImageSectionObject; // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _TERMINATION_PORT {
  struct _TERMINATION_PORT *Next; // offset: 0x0 (0)
  VOID *Port;                     // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _CLIENT_ID {
  VOID *UniqueProcess; // offset: 0x0 (0)
  VOID *UniqueThread;  // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _CACHE_MANAGER_CALLBACKS {
  UCHAR (*AcquireForLazyWrite)(VOID *arg1, UCHAR arg2); // offset: 0x0 (0)
  VOID (*ReleaseFromLazyWrite)(VOID *arg1);             // offset: 0x8 (8)
  UCHAR (*AcquireForReadAhead)(VOID *arg1, UCHAR arg2); // offset: 0x10 (16)
  VOID (*ReleaseFromReadAhead)(VOID *arg1);             // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _RTL_BALANCED_LINKS {
  struct _RTL_BALANCED_LINKS *Parent;     // offset: 0x0 (0)
  struct _RTL_BALANCED_LINKS *LeftChild;  // offset: 0x8 (8)
  struct _RTL_BALANCED_LINKS *RightChild; // offset: 0x10 (16)
  CHAR Balance;                           // offset: 0x18 (24)
  UCHAR Reserved[3];                      // offset: 0x19 (25)
};

// 0x28 (40) bytes
struct _KTMOBJECT_NAMESPACE_LINK {
  struct _RTL_BALANCED_LINKS Links; // offset: 0x0 (0)
  UCHAR Expired;                    // offset: 0x20 (32)
};

// 0x1 (1) bytes
struct _WDT_HANDLE {
  CHAR Reserved; // offset: 0x0 (0)
};

// 0x30 (48) bytes
struct _iobuf {
  CHAR *_ptr;      // offset: 0x0 (0)
  LONG _cnt;       // offset: 0x8 (8)
  CHAR *_base;     // offset: 0x10 (16)
  LONG _flag;      // offset: 0x18 (24)
  LONG _file;      // offset: 0x1c (28)
  LONG _charbuf;   // offset: 0x20 (32)
  LONG _bufsiz;    // offset: 0x24 (36)
  CHAR *_tmpfname; // offset: 0x28 (40)
};

// 0xac (172) bytes
struct _RTL_TIME_ZONE_INFORMATION {
  LONG Bias;                         // offset: 0x0 (0)
  WCHAR StandardName[32];            // offset: 0x4 (4)
  struct _TIME_FIELDS StandardStart; // offset: 0x44 (68)
  LONG StandardBias;                 // offset: 0x54 (84)
  WCHAR DaylightName[32];            // offset: 0x58 (88)
  struct _TIME_FIELDS DaylightStart; // offset: 0x98 (152)
  LONG DaylightBias;                 // offset: 0xa8 (168)
};

// 0x1b0 (432) bytes
struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION {
  struct _RTL_TIME_ZONE_INFORMATION tzi; // offset: 0x0 (0)
  WCHAR TimeZoneKeyName[128];            // offset: 0xac (172)
  UCHAR DynamicDaylightTimeDisabled;     // offset: 0x1ac (428)
};

// 0x4 (4) bytes
struct _HEAP_FREE_ENTRY_EXTRA {
  USHORT TagIndex;           // offset: 0x0 (0)
  USHORT FreeBackTraceIndex; // offset: 0x2 (2)
};

// 0x2 (2) bytes
union _HAL_UNMASKED_INTERRUPT_FLAGS {
  USHORT SecondaryInterrupt : 1; // offset: 0x0 (0)
  USHORT Reserved : 15;          // offset: 0x0 (0)
  USHORT AsUSHORT;               // offset: 0x0 (0)
};

// 0x8088 (32904) bytes
struct _STACK_TABLE {
  USHORT NumStackTraces;                    // offset: 0x0 (0)
  USHORT TraceCapacity;                     // offset: 0x2 (2)
  struct _OBJECT_REF_TRACE *StackTrace[16]; // offset: 0x8 (8)
  USHORT StackTableHash[16381];             // offset: 0x88 (136)
};

// 0x8 (8) bytes
struct _ACL {
  UCHAR AclRevision; // offset: 0x0 (0)
  UCHAR Sbz1;        // offset: 0x1 (1)
  USHORT AclSize;    // offset: 0x2 (2)
  USHORT AceCount;   // offset: 0x4 (4)
  USHORT Sbz2;       // offset: 0x6 (6)
};

// 0x28 (40) bytes
struct _SECURITY_DESCRIPTOR {
  UCHAR Revision;    // offset: 0x0 (0)
  UCHAR Sbz1;        // offset: 0x1 (1)
  USHORT Control;    // offset: 0x2 (2)
  VOID *Owner;       // offset: 0x8 (8)
  VOID *Group;       // offset: 0x10 (16)
  struct _ACL *Sacl; // offset: 0x18 (24)
  struct _ACL *Dacl; // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _ETW_SYSTEMTIME {
  USHORT Year;         // offset: 0x0 (0)
  USHORT Month;        // offset: 0x2 (2)
  USHORT DayOfWeek;    // offset: 0x4 (4)
  USHORT Day;          // offset: 0x6 (6)
  USHORT Hour;         // offset: 0x8 (8)
  USHORT Minute;       // offset: 0xa (10)
  USHORT Second;       // offset: 0xc (12)
  USHORT Milliseconds; // offset: 0xe (14)
};

// 0x10 (16) bytes
struct _IO_IRP_EXT_TRACK_OFFSET_HEADER {
  USHORT Validation; // offset: 0x0 (0)
  USHORT Flags;      // offset: 0x2 (2)
  VOID (*TrackedOffsetCallback)
  (struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *arg1,
   struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *arg2,
   LONGLONG arg3); // offset: 0x8 (8)
};

// 0x2 (2) bytes
union _HEAP_SEGMENT_MGR_COMMIT_STATE {
  USHORT CommittedPageCount : 11;          // offset: 0x0 (0)
  USHORT Spare : 3;                        // offset: 0x0 (0)
  USHORT LargePageOperationInProgress : 1; // offset: 0x0 (0)
  USHORT LargePageCommit : 1;              // offset: 0x0 (0)
  volatile USHORT EntireUShortV;           // offset: 0x0 (0)
  USHORT EntireUShort;                     // offset: 0x0 (0)
};

// 0x2 (2) bytes
struct _HEAP_VS_UNUSED_BYTES_INFO {
  union {
    struct {
      USHORT UnusedBytes : 13;  // offset: 0x0 (0)
      USHORT LfhSubsegment : 1; // offset: 0x0 (0)
      USHORT ExtraPresent : 1;  // offset: 0x0 (0)
      USHORT OneByteUnused : 1; // offset: 0x0 (0)
    };
    UCHAR Bytes[2]; // offset: 0x0 (0)
  };
};

// 0x2 (2) bytes
struct _HEAP_LFH_UNUSED_BYTES_INFO {
  union {
    struct {
      USHORT UnusedBytes : 14;  // offset: 0x0 (0)
      USHORT ExtraPresent : 1;  // offset: 0x0 (0)
      USHORT OneByteUnused : 1; // offset: 0x0 (0)
    };
    UCHAR Bytes[2]; // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
union _HEAP_LFH_ONDEMAND_POINTER {
  USHORT Invalid : 1;              // offset: 0x0 (0)
  USHORT AllocationInProgress : 1; // offset: 0x0 (0)
  struct {
    USHORT Spare0 : 14; // offset: 0x0 (0)
    USHORT UsageData;   // offset: 0x2 (2)
  };
  VOID *AllBits; // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _RTL_HP_LFH_CONFIG {
  USHORT MaxBlockSize;                  // offset: 0x0 (0)
  USHORT WitholdPageCrossingBlocks : 1; // offset: 0x2 (2)
  USHORT DisableRandomization : 1;      // offset: 0x2 (2)
};

// 0x10 (16) bytes
struct _SEGMENT_HEAP_EXTRA {
  USHORT AllocationTag;       // offset: 0x0 (0)
  UCHAR InterceptorIndex : 4; // offset: 0x2 (2)
  UCHAR UserFlags : 4;        // offset: 0x2 (2)
  UCHAR ExtraSizeInUnits;     // offset: 0x3 (3)
  VOID *Settable;             // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _PCW_COUNTER_DESCRIPTOR {
  USHORT Id;          // offset: 0x0 (0)
  USHORT StructIndex; // offset: 0x2 (2)
  USHORT Offset;      // offset: 0x4 (4)
  USHORT Size;        // offset: 0x6 (6)
};

// 0x2 (2) bytes
struct _HV_GET_BIN_CONTEXT {
  USHORT OutstandingReference : 1; // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MMSUBSECTION_FLAGS {
  USHORT SubsectionAccessed : 1;  // offset: 0x0 (0)
  USHORT Protection : 5;          // offset: 0x0 (0)
  USHORT StartingSector4132 : 10; // offset: 0x0 (0)
  USHORT SubsectionStatic : 1;    // offset: 0x2 (2)
  USHORT GlobalMemory : 1;        // offset: 0x2 (2)
  USHORT Spare : 1;               // offset: 0x2 (2)
  USHORT OnDereferenceList : 1;   // offset: 0x2 (2)
  USHORT SectorEndOffset : 12;    // offset: 0x2 (2)
};

// 0x4 (4) bytes
struct _MMSECTION_FLAGS2 {
  USHORT PartitionId : 10;                             // offset: 0x0 (0)
  UCHAR NoCrossPartitionAccess : 1;                    // offset: 0x2 (2)
  UCHAR SubsectionCrossPartitionReferenceOverflow : 1; // offset: 0x2 (2)
};

// 0x4 (4) bytes
struct _SEGMENT_FLAGS {
  union {
    struct {
      USHORT TotalNumberOfPtes4132 : 10; // offset: 0x0 (0)
      USHORT Spare0 : 1;                 // offset: 0x0 (0)
      USHORT SessionDriverProtos : 1;    // offset: 0x0 (0)
      USHORT LargePages : 1;             // offset: 0x0 (0)
      USHORT DebugSymbolsLoaded : 1;     // offset: 0x0 (0)
      USHORT WriteCombined : 1;          // offset: 0x0 (0)
      USHORT NoCache : 1;                // offset: 0x0 (0)
    };
    USHORT Short0; // offset: 0x0 (0)
  };
  union {
    struct {
      UCHAR Spare : 1;                 // offset: 0x2 (2)
      UCHAR DefaultProtectionMask : 5; // offset: 0x2 (2)
      UCHAR Binary32 : 1;              // offset: 0x2 (2)
      UCHAR ContainsDebug : 1;         // offset: 0x2 (2)
    };
    UCHAR UChar1; // offset: 0x2 (2)
  };
  union {
    struct {
      UCHAR ForceCollision : 1;    // offset: 0x3 (3)
      UCHAR ImageSigningType : 3;  // offset: 0x3 (3)
      UCHAR ImageSigningLevel : 4; // offset: 0x3 (3)
    };
    UCHAR UChar2; // offset: 0x3 (3)
  };
};

// 0x8 (8) bytes
struct _RTL_FEATURE_USAGE_REPORT {
  ULONG FeatureId;         // offset: 0x0 (0)
  USHORT ReportingKind;    // offset: 0x4 (4)
  USHORT ReportingOptions; // offset: 0x6 (6)
};

// 0x8 (8) bytes
struct _wil_details_UsageSubscriptionData {
  ULONG featureId;             // offset: 0x0 (0)
  USHORT serviceReportingKind; // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct wil_details_StagingConfigHeader {
  UCHAR version;                   // offset: 0x0 (0)
  UCHAR versionMinor;              // offset: 0x1 (1)
  USHORT headerSizeBytes;          // offset: 0x2 (2)
  USHORT featureCount;             // offset: 0x4 (4)
  USHORT featureUsageTriggerCount; // offset: 0x6 (6)
  struct wil_details_StagingConfigHeaderProperties
      sessionProperties; // offset: 0x8 (8)
  struct wil_details_StagingConfigHeaderProperties
      properties; // offset: 0xc (12)
};

// 0x6 (6) bytes
struct FEATURE_LOGGED_TRAITS {
  USHORT version;     // offset: 0x0 (0)
  USHORT baseVersion; // offset: 0x2 (2)
  UCHAR stage;        // offset: 0x4 (4)
};

// 0x68 (104) bytes
struct FEATURE_ERROR {
  HRESULT hr;                            // offset: 0x0 (0)
  USHORT lineNumber;                     // offset: 0x4 (4)
  const CHAR *file;                      // offset: 0x8 (8)
  const CHAR *process;                   // offset: 0x10 (16)
  const CHAR *modulePath;                // offset: 0x18 (24)
  ULONG callerReturnAddressOffset;       // offset: 0x20 (32)
  const CHAR *callerModule;              // offset: 0x28 (40)
  const CHAR *message;                   // offset: 0x30 (48)
  USHORT originLineNumber;               // offset: 0x38 (56)
  const CHAR *originFile;                // offset: 0x40 (64)
  const CHAR *originModule;              // offset: 0x48 (72)
  ULONG originCallerReturnAddressOffset; // offset: 0x50 (80)
  const CHAR *originCallerModule;        // offset: 0x58 (88)
  const CHAR *originName;                // offset: 0x60 (96)
};

// 0x10 (16) bytes
struct _UNICODE_STRING {
  USHORT Length;        // offset: 0x0 (0)
  USHORT MaximumLength; // offset: 0x2 (2)
  WCHAR *Buffer;        // offset: 0x8 (8)
};

// 0x6 (6) bytes
struct _LOCAL_NMISOURCE {
  UCHAR Type;        // offset: 0x0 (0)
  UCHAR Length;      // offset: 0x1 (1)
  UCHAR ProcessorID; // offset: 0x2 (2)
  USHORT Flags;      // offset: 0x3 (3)
  UCHAR LINTIN;      // offset: 0x5 (5)
};

// 0x2 (2) bytes
union _WHEA_REVISION {
  struct {
    UCHAR MinorRevision; // offset: 0x0 (0)
    UCHAR MajorRevision; // offset: 0x1 (1)
  };
  USHORT AsUSHORT; // offset: 0x0 (0)
};

// 0x2 (2) bytes
union _WHEA_NOTIFICATION_FLAGS {
  USHORT PollIntervalRW : 1;             // offset: 0x0 (0)
  USHORT SwitchToPollingThresholdRW : 1; // offset: 0x0 (0)
  USHORT SwitchToPollingWindowRW : 1;    // offset: 0x0 (0)
  USHORT ErrorThresholdRW : 1;           // offset: 0x0 (0)
  USHORT ErrorThresholdWindowRW : 1;     // offset: 0x0 (0)
  USHORT Reserved : 11;                  // offset: 0x0 (0)
  USHORT AsUSHORT;                       // offset: 0x0 (0)
};

// 0x2 (2) bytes
union _AER_BRIDGE_DESCRIPTOR_FLAGS {
  USHORT UncorrectableErrorMaskRW : 1;          // offset: 0x0 (0)
  USHORT UncorrectableErrorSeverityRW : 1;      // offset: 0x0 (0)
  USHORT CorrectableErrorMaskRW : 1;            // offset: 0x0 (0)
  USHORT AdvancedCapsAndControlRW : 1;          // offset: 0x0 (0)
  USHORT SecondaryUncorrectableErrorMaskRW : 1; // offset: 0x0 (0)
  USHORT SecondaryUncorrectableErrorSevRW : 1;  // offset: 0x0 (0)
  USHORT SecondaryCapsAndControlRW : 1;         // offset: 0x0 (0)
  USHORT Reserved : 9;                          // offset: 0x0 (0)
  USHORT AsUSHORT;                              // offset: 0x0 (0)
};

// 0x2 (2) bytes
union _AER_ENDPOINT_DESCRIPTOR_FLAGS {
  USHORT UncorrectableErrorMaskRW : 1;     // offset: 0x0 (0)
  USHORT UncorrectableErrorSeverityRW : 1; // offset: 0x0 (0)
  USHORT CorrectableErrorMaskRW : 1;       // offset: 0x0 (0)
  USHORT AdvancedCapsAndControlRW : 1;     // offset: 0x0 (0)
  USHORT Reserved : 12;                    // offset: 0x0 (0)
  USHORT AsUSHORT;                         // offset: 0x0 (0)
};

// 0x2 (2) bytes
union _AER_ROOTPORT_DESCRIPTOR_FLAGS {
  USHORT UncorrectableErrorMaskRW : 1;     // offset: 0x0 (0)
  USHORT UncorrectableErrorSeverityRW : 1; // offset: 0x0 (0)
  USHORT CorrectableErrorMaskRW : 1;       // offset: 0x0 (0)
  USHORT AdvancedCapsAndControlRW : 1;     // offset: 0x0 (0)
  USHORT RootErrorCommandRW : 1;           // offset: 0x0 (0)
  USHORT Reserved : 11;                    // offset: 0x0 (0)
  USHORT AsUSHORT;                         // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _WHEA_IPF_CPE_DESCRIPTOR {
  USHORT Type;    // offset: 0x0 (0)
  UCHAR Enabled;  // offset: 0x2 (2)
  UCHAR Reserved; // offset: 0x3 (3)
};

// 0x4 (4) bytes
struct _WHEA_IPF_CMC_DESCRIPTOR {
  USHORT Type;    // offset: 0x0 (0)
  UCHAR Enabled;  // offset: 0x2 (2)
  UCHAR Reserved; // offset: 0x3 (3)
};

// 0x4 (4) bytes
struct _WHEA_IPF_MCA_DESCRIPTOR {
  USHORT Type;    // offset: 0x0 (0)
  UCHAR Enabled;  // offset: 0x2 (2)
  UCHAR Reserved; // offset: 0x3 (3)
};

// 0x3 (3) bytes
struct _WHEA_XPF_NMI_DESCRIPTOR {
  USHORT Type;   // offset: 0x0 (0)
  UCHAR Enabled; // offset: 0x2 (2)
};

// 0x10 (16) bytes
struct _TXN_PARAMETER_BLOCK {
  USHORT Length;           // offset: 0x0 (0)
  USHORT TxFsContext;      // offset: 0x2 (2)
  VOID *TransactionObject; // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _INTERFACE {
  USHORT Size;                              // offset: 0x0 (0)
  USHORT Version;                           // offset: 0x2 (2)
  VOID *Context;                            // offset: 0x8 (8)
  VOID (*InterfaceReference)(VOID *arg1);   // offset: 0x10 (16)
  VOID (*InterfaceDereference)(VOID *arg1); // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct _ETW_FILTER_STRING_TOKEN_ELEMENT {
  USHORT Length; // offset: 0x0 (0)
  WCHAR *String; // offset: 0x8 (8)
};

// 0x40 (64) bytes
struct _IMAGE_DOS_HEADER {
  USHORT e_magic;    // offset: 0x0 (0)
  USHORT e_cblp;     // offset: 0x2 (2)
  USHORT e_cp;       // offset: 0x4 (4)
  USHORT e_crlc;     // offset: 0x6 (6)
  USHORT e_cparhdr;  // offset: 0x8 (8)
  USHORT e_minalloc; // offset: 0xa (10)
  USHORT e_maxalloc; // offset: 0xc (12)
  USHORT e_ss;       // offset: 0xe (14)
  USHORT e_sp;       // offset: 0x10 (16)
  USHORT e_csum;     // offset: 0x12 (18)
  USHORT e_ip;       // offset: 0x14 (20)
  USHORT e_cs;       // offset: 0x16 (22)
  USHORT e_lfarlc;   // offset: 0x18 (24)
  USHORT e_ovno;     // offset: 0x1a (26)
  USHORT e_res[4];   // offset: 0x1c (28)
  USHORT e_oemid;    // offset: 0x24 (36)
  USHORT e_oeminfo;  // offset: 0x26 (38)
  USHORT e_res2[10]; // offset: 0x28 (40)
  LONG e_lfanew;     // offset: 0x3c (60)
};

// 0x20 (32) bytes
struct _ETW_PMC_SUPPORT {
  enum _KPROFILE_SOURCE *Source;              // offset: 0x0 (0)
  volatile ULONG HookIdCount;                 // offset: 0x8 (8)
  USHORT HookId[4];                           // offset: 0xc (12)
  volatile ULONG CountersCount;               // offset: 0x14 (20)
  struct _HAL_PMC_COUNTERS *ProcessorCtrs[1]; // offset: 0x18 (24)
};

// 0x4 (4) bytes
struct _ETW_BUFFER_CONTEXT {
  union {
    struct {
      UCHAR ProcessorNumber; // offset: 0x0 (0)
      UCHAR Alignment;       // offset: 0x1 (1)
    };
    USHORT ProcessorIndex; // offset: 0x0 (0)
  };
  USHORT LoggerId; // offset: 0x2 (2)
};

// 0x18 (24) bytes
struct _ETW_FILTER_STRING_TOKEN {
  USHORT Count;                                      // offset: 0x0 (0)
  struct _ETW_FILTER_STRING_TOKEN_ELEMENT Tokens[1]; // offset: 0x8 (8)
};

// 0xa (10) bytes
struct _PROC_PERF_HISTORY_ENTRY {
  USHORT Utility;            // offset: 0x0 (0)
  USHORT AffinitizedUtility; // offset: 0x2 (2)
  USHORT Frequency;          // offset: 0x4 (4)
  UCHAR TaggedPercent[3];    // offset: 0x6 (6)
};

// 0x4 (4) bytes
struct _WNF_NODE_HEADER {
  USHORT NodeTypeCode; // offset: 0x0 (0)
  USHORT NodeByteSize; // offset: 0x2 (2)
};

// 0x4 (4) bytes
struct _PROCESSOR_NUMBER {
  USHORT Group;   // offset: 0x0 (0)
  UCHAR Number;   // offset: 0x2 (2)
  UCHAR Reserved; // offset: 0x3 (3)
};

// 0x10 (16) bytes
struct _KDESCRIPTOR {
  USHORT Pad[3]; // offset: 0x0 (0)
  USHORT Limit;  // offset: 0x6 (6)
  VOID *Base;    // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct _MMSUPPORT_FLAGS {
  union {
    struct {
      UCHAR WorkingSetType : 3;        // offset: 0x0 (0)
      UCHAR Reserved0 : 3;             // offset: 0x0 (0)
      UCHAR MaximumWorkingSetHard : 1; // offset: 0x0 (0)
      UCHAR MinimumWorkingSetHard : 1; // offset: 0x0 (0)
      UCHAR SessionMaster : 1;         // offset: 0x1 (1)
      UCHAR TrimmerState : 2;          // offset: 0x1 (1)
      UCHAR Reserved : 1;              // offset: 0x1 (1)
      UCHAR PageStealers : 4;          // offset: 0x1 (1)
    };
    USHORT u1; // offset: 0x0 (0)
  };
  UCHAR MemoryPriority; // offset: 0x2 (2)
  union {
    struct {
      UCHAR WsleDeleted : 1;        // offset: 0x3 (3)
      UCHAR SvmEnabled : 1;         // offset: 0x3 (3)
      UCHAR ForceAge : 1;           // offset: 0x3 (3)
      UCHAR ForceTrim : 1;          // offset: 0x3 (3)
      UCHAR NewMaximum : 1;         // offset: 0x3 (3)
      UCHAR CommitReleaseState : 2; // offset: 0x3 (3)
    };
    UCHAR u2; // offset: 0x3 (3)
  };
};

// 0x10 (16) bytes
struct _EWOW64PROCESS {
  VOID *Peb;                       // offset: 0x0 (0)
  USHORT Machine;                  // offset: 0x8 (8)
  enum _SYSTEM_DLL_TYPE NtdllType; // offset: 0xc (12)
};

// 0x10 (16) bytes
struct _STRING {
  USHORT Length;        // offset: 0x0 (0)
  USHORT MaximumLength; // offset: 0x2 (2)
  CHAR *Buffer;         // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR {
  enum _SEP_CACHED_HANDLES_ENTRY_TYPE DescriptorType; // offset: 0x0 (0)
  union {
    VOID *PackageSid;                       // offset: 0x8 (8)
    struct _UNICODE_STRING IsolationPrefix; // offset: 0x8 (8)
  };
};

// 0x20 (32) bytes
struct _RELATIVE_SYMLINK_INFO {
  USHORT ExposedNamespaceLength;                     // offset: 0x0 (0)
  USHORT Flags;                                      // offset: 0x2 (2)
  USHORT DeviceNameLength;                           // offset: 0x4 (4)
  USHORT Reserved;                                   // offset: 0x6 (6)
  struct _RELATIVE_SYMLINK_INFO *InteriorMountPoint; // offset: 0x8 (8)
  struct _UNICODE_STRING OpenedName;                 // offset: 0x10 (16)
};

// 0x18 (24) bytes
struct _CURDIR {
  struct _UNICODE_STRING DosPath; // offset: 0x0 (0)
  VOID *Handle;                   // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _OBJECT_NAME_INFORMATION {
  struct _UNICODE_STRING Name; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _SE_AUDIT_PROCESS_CREATION_INFO {
  struct _OBJECT_NAME_INFORMATION *ImageFileName; // offset: 0x0 (0)
};

// 0x30 (48) bytes
struct _SEP_SILOSTATE {
  struct _SEP_LOGON_SESSION_REFERENCES *SystemLogonSession; // offset: 0x0 (0)
  struct _SEP_LOGON_SESSION_REFERENCES
      *AnonymousLogonSession;             // offset: 0x8 (8)
  VOID *AnonymousLogonToken;              // offset: 0x10 (16)
  VOID *AnonymousLogonTokenNoEveryone;    // offset: 0x18 (24)
  struct _UNICODE_STRING *UncSystemPaths; // offset: 0x20 (32)
  struct _CI_NGEN_PATHS *NgenPaths;       // offset: 0x28 (40)
};

// 0x8 (8) bytes
struct _LDRP_CSLIST {
  struct _SINGLE_LIST_ENTRY *Tail; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _SINGLE_LIST_ENTRY {
  struct _SINGLE_LIST_ENTRY *Next; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _ETW_BUFFER_QUEUE {
  struct _SINGLE_LIST_ENTRY *QueueTail; // offset: 0x0 (0)
  struct _SINGLE_LIST_ENTRY QueueEntry; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _KDPC_LIST {
  struct _SINGLE_LIST_ENTRY ListHead;   // offset: 0x0 (0)
  struct _SINGLE_LIST_ENTRY *LastEntry; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _LIST_ENTRY {
  struct _LIST_ENTRY *Flink; // offset: 0x0 (0)
  struct _LIST_ENTRY *Blink; // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _FAST_OWNER_ENTRY_INTERNAL {
  struct _LIST_ENTRY ListEntry;     // offset: 0x0 (0)
  UCHAR AbLockHandle;               // offset: 0x10 (16)
  UCHAR Disowned : 1;               // offset: 0x11 (17)
  UCHAR DynamicallyAllocated : 1;   // offset: 0x11 (17)
  UCHAR CallerExclusive : 1;        // offset: 0x11 (17)
  UCHAR IsSublistHead;              // offset: 0x12 (18)
  UCHAR IsWaiting;                  // offset: 0x13 (19)
  VOID *LockAddress;                // offset: 0x18 (24)
  VOID *ThreadAddress;              // offset: 0x20 (32)
  struct _LIST_ENTRY SublistHead;   // offset: 0x28 (40)
  struct _LIST_ENTRY LockListEntry; // offset: 0x38 (56)
};

// 0x20 (32) bytes
struct _TRIAGE_POP_IRP_DATA {
  struct _LIST_ENTRY Link;    // offset: 0x0 (0)
  struct _IRP *Irp;           // offset: 0x10 (16)
  struct _DEVICE_OBJECT *Pdo; // offset: 0x18 (24)
};

// 0x38 (56) bytes
struct _TRIAGE_POP_FX_DEVICE {
  struct _LIST_ENTRY Link;                // offset: 0x0 (0)
  struct _IRP *Irp;                       // offset: 0x10 (16)
  struct _TRIAGE_POP_IRP_DATA *IrpData;   // offset: 0x18 (24)
  LONG Status;                            // offset: 0x20 (32)
  LONG PowerReqCall;                      // offset: 0x24 (36)
  LONG PowerNotReqCall;                   // offset: 0x28 (40)
  struct _TRIAGE_DEVICE_NODE *DeviceNode; // offset: 0x30 (48)
};

// 0x58 (88) bytes
struct _TRIAGE_DEVICE_NODE {
  struct _TRIAGE_DEVICE_NODE *Sibling;         // offset: 0x0 (0)
  struct _TRIAGE_DEVICE_NODE *Child;           // offset: 0x8 (8)
  struct _TRIAGE_DEVICE_NODE *Parent;          // offset: 0x10 (16)
  struct _TRIAGE_DEVICE_NODE *LastChild;       // offset: 0x18 (24)
  struct _DEVICE_OBJECT *PhysicalDeviceObject; // offset: 0x20 (32)
  struct _UNICODE_STRING InstancePath;         // offset: 0x28 (40)
  struct _UNICODE_STRING ServiceName;          // offset: 0x38 (56)
  struct _IRP *PendingIrp;                     // offset: 0x48 (72)
  struct _TRIAGE_POP_FX_DEVICE *FxDevice;      // offset: 0x50 (80)
};

// 0x18 (24) bytes
struct _TRIAGE_PNP_DEVICE_COMPLETION_REQUEST {
  struct _LIST_ENTRY ListEntry;           // offset: 0x0 (0)
  struct _TRIAGE_DEVICE_NODE *DeviceNode; // offset: 0x10 (16)
};

// 0x40 (64) bytes
struct _POP_POLICY_DEVICE {
  struct _LIST_ENTRY Link;                  // offset: 0x0 (0)
  enum POWER_POLICY_DEVICE_TYPE DeviceType; // offset: 0x10 (16)
  VOID *Notification;                       // offset: 0x18 (24)
  struct _UNICODE_STRING Name;              // offset: 0x20 (32)
  struct _DEVICE_OBJECT *Device;            // offset: 0x30 (48)
  struct _IRP *Irp;                         // offset: 0x38 (56)
};

// 0x10 (16) bytes
struct _ARC_DISK_INFORMATION {
  struct _LIST_ENTRY DiskSignatures; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _DELAY_ACK_FO {
  struct _LIST_ENTRY Links;                // offset: 0x0 (0)
  struct _FILE_OBJECT *OriginalFileObject; // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE {
  struct _LIST_ENTRY DispatchedList; // offset: 0x0 (0)
};

// 0x30 (48) bytes
struct _POP_IRP_WORKER_ENTRY {
  struct _LIST_ENTRY Link;       // offset: 0x0 (0)
  struct _ETHREAD *Thread;       // offset: 0x10 (16)
  struct _IRP *Irp;              // offset: 0x18 (24)
  struct _DEVICE_OBJECT *Device; // offset: 0x20 (32)
  UCHAR Static;                  // offset: 0x28 (40)
};

// 0x18 (24) bytes
struct _CMP_VOLUME_MANAGER {
  struct _CMSI_RW_LOCK VolumeContextListLock; // offset: 0x0 (0)
  struct _LIST_ENTRY VolumeContextListHead;   // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT {
  struct _CM_KEY_CONTROL_BLOCK *BaseKcb; // offset: 0x0 (0)
  LONG PrepareStatus;                    // offset: 0x8 (8)
  struct _LIST_ENTRY ClonedKcbListHead;  // offset: 0x10 (16)
};

// 0x30 (48) bytes
struct _CM_KCB_LAYER_INFO {
  struct _LIST_ENTRY LayerListEntry;     // offset: 0x0 (0)
  struct _CM_KEY_CONTROL_BLOCK *Kcb;     // offset: 0x10 (16)
  struct _CM_KCB_LAYER_INFO *LowerLayer; // offset: 0x18 (24)
  struct _LIST_ENTRY UpperLayerListHead; // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _MMWORKING_SET_EXPANSION_HEAD {
  struct _LIST_ENTRY ListHead; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _HALP_EMERGENCY_LA_QUEUE_ENTRY {
  struct _LIST_ENTRY ListEntry;                 // offset: 0x0 (0)
  enum _HALP_EMERGENCY_LA_QUEUE_TYPE EntryType; // offset: 0x10 (16)
};

// 0x30 (48) bytes
struct _IO_TIMER {
  SHORT Type;                   // offset: 0x0 (0)
  SHORT TimerFlag;              // offset: 0x2 (2)
  struct _LIST_ENTRY TimerList; // offset: 0x8 (8)
  VOID (*TimerRoutine)
  (struct _DEVICE_OBJECT *arg1, VOID *arg2); // offset: 0x18 (24)
  VOID *Context;                             // offset: 0x20 (32)
  struct _DEVICE_OBJECT *DeviceObject;       // offset: 0x28 (40)
};

// 0x20 (32) bytes
struct _WORK_QUEUE_ITEM {
  struct _LIST_ENTRY List;           // offset: 0x0 (0)
  VOID (*WorkerRoutine)(VOID *arg1); // offset: 0x10 (16)
  VOID *Parameter;                   // offset: 0x18 (24)
};

// 0x30 (48) bytes
struct _WNF_DISPATCHER {
  struct _WNF_NODE_HEADER Header;   // offset: 0x0 (0)
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x8 (8)
  LONG State;                       // offset: 0x28 (40)
};

// 0x28 (40) bytes
struct _MI_REBUILD_LARGE_PAGE_TIMER {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 (0)
  UCHAR SecondsLeft;                // offset: 0x20 (32)
  UCHAR RebuildActive;              // offset: 0x21 (33)
  UCHAR NextPassDelta;              // offset: 0x22 (34)
  UCHAR LargeSubPagesActive;        // offset: 0x23 (35)
};

// 0x28 (40) bytes
struct _MI_COMBINE_WORKITEM {
  VOID *NextEntry;                  // offset: 0x0 (0)
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x8 (8)
};

// 0x38 (56) bytes
struct _MI_LDW_WORK_CONTEXT {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 (0)
  struct _FILE_OBJECT *FileObject;  // offset: 0x20 (32)
  LONG ErrorStatus;                 // offset: 0x28 (40)
  volatile LONG Active;             // offset: 0x2c (44)
  UCHAR FreeWhenDone;               // offset: 0x30 (48)
};

// 0x38 (56) bytes
struct _POP_FX_WORK_ORDER {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 (0)
  LONG WorkCount;                   // offset: 0x20 (32)
  VOID *Context;                    // offset: 0x28 (40)
  struct _POP_FX_WORK_ORDER_WATCHDOG_INFO
      *WatchdogTimerInfo; // offset: 0x30 (48)
};

// 0x18 (24) bytes
struct _DISPATCHER_HEADER {
  union {
    volatile LONG Lock; // offset: 0x0 (0)
    LONG LockNV;        // offset: 0x0 (0)
    struct {
      UCHAR Type;       // offset: 0x0 (0)
      UCHAR Signalling; // offset: 0x1 (1)
      UCHAR Size;       // offset: 0x2 (2)
      UCHAR Reserved1;  // offset: 0x3 (3)
    };
    struct {
      UCHAR TimerType; // offset: 0x0 (0)
      union {
        UCHAR TimerControlFlags; // offset: 0x1 (1)
        struct {
          UCHAR Absolute : 1;              // offset: 0x1 (1)
          UCHAR Wake : 1;                  // offset: 0x1 (1)
          UCHAR EncodedTolerableDelay : 6; // offset: 0x1 (1)
        };
      };
      UCHAR Hand; // offset: 0x2 (2)
      union {
        UCHAR TimerMiscFlags; // offset: 0x3 (3)
        struct {
          UCHAR Index : 6;            // offset: 0x3 (3)
          UCHAR Inserted : 1;         // offset: 0x3 (3)
          volatile UCHAR Expired : 1; // offset: 0x3 (3)
        };
      };
    };
    struct {
      UCHAR Timer2Type; // offset: 0x0 (0)
      union {
        UCHAR Timer2Flags; // offset: 0x1 (1)
        struct {
          UCHAR Timer2Inserted : 1;      // offset: 0x1 (1)
          UCHAR Timer2Expiring : 1;      // offset: 0x1 (1)
          UCHAR Timer2CancelPending : 1; // offset: 0x1 (1)
          UCHAR Timer2SetPending : 1;    // offset: 0x1 (1)
          UCHAR Timer2Running : 1;       // offset: 0x1 (1)
          UCHAR Timer2Disabled : 1;      // offset: 0x1 (1)
          UCHAR Timer2ReservedFlags : 2; // offset: 0x1 (1)
        };
      };
      UCHAR Timer2ComponentId; // offset: 0x2 (2)
      UCHAR Timer2RelativeId;  // offset: 0x3 (3)
    };
    struct {
      UCHAR QueueType; // offset: 0x0 (0)
      union {
        UCHAR QueueControlFlags; // offset: 0x1 (1)
        struct {
          UCHAR Abandoned : 1;                 // offset: 0x1 (1)
          UCHAR DisableIncrement : 1;          // offset: 0x1 (1)
          UCHAR QueueReservedControlFlags : 6; // offset: 0x1 (1)
        };
      };
      UCHAR QueueSize;     // offset: 0x2 (2)
      UCHAR QueueReserved; // offset: 0x3 (3)
    };
    struct {
      UCHAR ThreadType;     // offset: 0x0 (0)
      UCHAR ThreadReserved; // offset: 0x1 (1)
      union {
        UCHAR ThreadControlFlags; // offset: 0x2 (2)
        struct {
          UCHAR CycleProfiling : 1;             // offset: 0x2 (2)
          UCHAR CounterProfiling : 1;           // offset: 0x2 (2)
          UCHAR GroupScheduling : 1;            // offset: 0x2 (2)
          UCHAR AffinitySet : 1;                // offset: 0x2 (2)
          UCHAR Tagged : 1;                     // offset: 0x2 (2)
          UCHAR EnergyProfiling : 1;            // offset: 0x2 (2)
          UCHAR SchedulerAssist : 1;            // offset: 0x2 (2)
          UCHAR ThreadReservedControlFlags : 1; // offset: 0x2 (2)
        };
      };
      union {
        UCHAR DebugActive; // offset: 0x3 (3)
        struct {
          UCHAR ActiveDR7 : 1;    // offset: 0x3 (3)
          UCHAR Instrumented : 1; // offset: 0x3 (3)
          UCHAR Minimal : 1;      // offset: 0x3 (3)
          UCHAR Reserved4 : 2;    // offset: 0x3 (3)
          UCHAR AltSyscall : 1;   // offset: 0x3 (3)
          UCHAR UmsScheduled : 1; // offset: 0x3 (3)
          UCHAR UmsPrimary : 1;   // offset: 0x3 (3)
        };
      };
    };
    struct {
      UCHAR MutantType;     // offset: 0x0 (0)
      UCHAR MutantSize;     // offset: 0x1 (1)
      UCHAR DpcActive;      // offset: 0x2 (2)
      UCHAR MutantReserved; // offset: 0x3 (3)
    };
  };
  LONG SignalState;                // offset: 0x4 (4)
  struct _LIST_ENTRY WaitListHead; // offset: 0x8 (8)
};

// 0x38 (56) bytes
struct _KMUTANT {
  struct _DISPATCHER_HEADER Header;   // offset: 0x0 (0)
  struct _LIST_ENTRY MutantListEntry; // offset: 0x18 (24)
  struct _KTHREAD *OwnerThread;       // offset: 0x28 (40)
  union {
    UCHAR MutantFlags; // offset: 0x30 (48)
    struct {
      UCHAR Abandoned : 1;  // offset: 0x30 (48)
      UCHAR Spare1 : 7;     // offset: 0x30 (48)
      UCHAR Abandoned2 : 1; // offset: 0x30 (48)
      UCHAR AbEnabled : 1;  // offset: 0x30 (48)
      UCHAR Spare2 : 6;     // offset: 0x30 (48)
    };
  };
  UCHAR ApcDisable; // offset: 0x31 (49)
};

// 0x18 (24) bytes
struct _KGATE {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _MI_EXTENT_DELETION_WAIT_BLOCK {
  struct _MI_EXTENT_DELETION_WAIT_BLOCK *Next; // offset: 0x0 (0)
  struct _KGATE Gate;                          // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _MI_LARGE_PAGE_LISTS_CHANGING {
  struct _MI_LARGE_PAGE_LISTS_CHANGING *Next; // offset: 0x0 (0)
  struct _KGATE Gate;                         // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _KSEMAPHORE {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 (0)
  LONG Limit;                       // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _LPCP_NONPAGED_PORT_QUEUE {
  struct _KSEMAPHORE Semaphore;          // offset: 0x0 (0)
  struct _LPCP_PORT_OBJECT *BackPointer; // offset: 0x20 (32)
};

// 0x20 (32) bytes
struct _LPCP_PORT_QUEUE {
  struct _LPCP_NONPAGED_PORT_QUEUE *NonPagedPortQueue; // offset: 0x0 (0)
  struct _KSEMAPHORE *Semaphore;                       // offset: 0x8 (8)
  struct _LIST_ENTRY ReceiveHead;                      // offset: 0x10 (16)
};

// 0x50 (80) bytes
struct _MMDEREFERENCE_SEGMENT_HEADER {
  struct _KSEMAPHORE Semaphore;                   // offset: 0x0 (0)
  struct _LIST_ENTRY ControlAreaDeleteListHead;   // offset: 0x20 (32)
  struct _LIST_ENTRY UnusedSegmentDeleteListHead; // offset: 0x30 (48)
  struct _LIST_ENTRY PagefileExtensionListHead;   // offset: 0x40 (64)
};

// 0x18 (24) bytes
struct _KEVENT {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 (0)
};

// 0x30 (48) bytes
struct _KWAIT_CHAIN_ENTRY {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
  struct _KTHREAD *Thread;      // offset: 0x10 (16)
  struct _KEVENT Event;         // offset: 0x18 (24)
};

// 0x38 (56) bytes
struct _MI_RESUME_WORKITEM {
  struct _KEVENT ResumeCompleteEvent; // offset: 0x0 (0)
  struct _WORK_QUEUE_ITEM WorkItem;   // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _PALPC_PORT_REFERENCE_WAIT_BLOCK {
  struct _KEVENT DesiredReferenceNoEvent; // offset: 0x0 (0)
  LONG DesiredReferenceNo;                // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _CACHE_UNINITIALIZE_EVENT {
  struct _CACHE_UNINITIALIZE_EVENT *Next; // offset: 0x0 (0)
  struct _KEVENT Event;                   // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _HIVE_WAIT_PACKET {
  struct _KEVENT WakeEvent;       // offset: 0x0 (0)
  LONG Status;                    // offset: 0x18 (24)
  struct _HIVE_WAIT_PACKET *Next; // offset: 0x20 (32)
};

// 0x28 (40) bytes
struct _MMMOD_WRITER_LISTHEAD {
  struct _LIST_ENTRY ListHead; // offset: 0x0 (0)
  union {
    struct _KGATE Gate;   // offset: 0x10 (16)
    struct _KEVENT Event; // offset: 0x10 (16)
  };
};

// 0x20 (32) bytes
struct _IO_REMOVE_LOCK_COMMON_BLOCK {
  UCHAR Removed;              // offset: 0x0 (0)
  UCHAR Reserved[3];          // offset: 0x1 (1)
  LONG IoCount;               // offset: 0x4 (4)
  struct _KEVENT RemoveEvent; // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _IO_REMOVE_LOCK {
  struct _IO_REMOVE_LOCK_COMMON_BLOCK Common; // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _MI_RESERVATION_CLUSTER_INFO {
  ULONG ClusterSize : 10;    // offset: 0x0 (0)
  ULONG SequenceNumber : 22; // offset: 0x0 (0)
  LONG EntireInfo;           // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _ACPI_METHOD_ARGUMENT_V1 {
  USHORT Type;       // offset: 0x0 (0)
  USHORT DataLength; // offset: 0x2 (2)
  union {
    ULONG Argument; // offset: 0x4 (4)
    UCHAR Data[1];  // offset: 0x4 (4)
  };
};

// 0x28 (40) bytes
struct _CALL_HASH_ENTRY {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
  VOID *CallersAddress;         // offset: 0x10 (16)
  VOID *CallersCaller;          // offset: 0x18 (24)
  ULONG CallCount;              // offset: 0x20 (32)
};

// 0x4 (4) bytes
struct _OBJECT_HEADER_PADDING_INFO {
  ULONG PaddingAmount; // offset: 0x0 (0)
};

// 0x1c (28) bytes
struct _IMAGE_DEBUG_DIRECTORY {
  ULONG Characteristics;  // offset: 0x0 (0)
  ULONG TimeDateStamp;    // offset: 0x4 (4)
  USHORT MajorVersion;    // offset: 0x8 (8)
  USHORT MinorVersion;    // offset: 0xa (10)
  ULONG Type;             // offset: 0xc (12)
  ULONG SizeOfData;       // offset: 0x10 (16)
  ULONG AddressOfRawData; // offset: 0x14 (20)
  ULONG PointerToRawData; // offset: 0x18 (24)
};

// 0x14 (20) bytes
struct _NB10 {
  ULONG Signature; // offset: 0x0 (0)
  ULONG Offset;    // offset: 0x4 (4)
  ULONG TimeStamp; // offset: 0x8 (8)
  ULONG Age;       // offset: 0xc (12)
  CHAR PdbName[1]; // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _IMAGE_SECTION_HEADER {
  UCHAR Name[8]; // offset: 0x0 (0)
  union {
    ULONG PhysicalAddress; // offset: 0x8 (8)
    ULONG VirtualSize;     // offset: 0x8 (8)

  } Misc;                     // offset: 0x8 (8)
  ULONG VirtualAddress;       // offset: 0xc (12)
  ULONG SizeOfRawData;        // offset: 0x10 (16)
  ULONG PointerToRawData;     // offset: 0x14 (20)
  ULONG PointerToRelocations; // offset: 0x18 (24)
  ULONG PointerToLinenumbers; // offset: 0x1c (28)
  USHORT NumberOfRelocations; // offset: 0x20 (32)
  USHORT NumberOfLinenumbers; // offset: 0x22 (34)
  ULONG Characteristics;      // offset: 0x24 (36)
};

// 0x4 (4) bytes
struct _MMVAD_FLAGS2 {
  ULONG FileOffset : 24;        // offset: 0x0 (0)
  ULONG Large : 1;              // offset: 0x0 (0)
  ULONG TrimBehind : 1;         // offset: 0x0 (0)
  ULONG Inherit : 1;            // offset: 0x0 (0)
  ULONG NoValidationNeeded : 1; // offset: 0x0 (0)
  ULONG PrivateDemandZero : 1;  // offset: 0x0 (0)
  ULONG Spare : 3;              // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _VF_WATCHDOG_IRP {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
  struct _IRP *Irp;             // offset: 0x10 (16)
  ULONG DueTickCount;           // offset: 0x18 (24)
  volatile UCHAR Inserted;      // offset: 0x1c (28)
  CHAR TrackedStackLocation;    // offset: 0x1d (29)
  USHORT CancelTimeoutTicks;    // offset: 0x1e (30)
};

// 0x10 (16) bytes
struct _LDR_SERVICE_TAG_RECORD {
  struct _LDR_SERVICE_TAG_RECORD *Next; // offset: 0x0 (0)
  ULONG ServiceTag;                     // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _LDR_DDAG_NODE {
  struct _LIST_ENTRY Modules;                     // offset: 0x0 (0)
  struct _LDR_SERVICE_TAG_RECORD *ServiceTagList; // offset: 0x10 (16)
  ULONG LoadCount;                                // offset: 0x18 (24)
  ULONG LoadWhileUnloadingCount;                  // offset: 0x1c (28)
  ULONG LowestLink;                               // offset: 0x20 (32)
  struct _LDRP_CSLIST Dependencies;               // offset: 0x28 (40)
  struct _LDRP_CSLIST IncomingDependencies;       // offset: 0x30 (48)
  enum _LDR_DDAG_STATE State;                     // offset: 0x38 (56)
  struct _SINGLE_LIST_ENTRY CondenseLink;         // offset: 0x40 (64)
  ULONG PreorderNumber;                           // offset: 0x48 (72)
};

// 0x1c (28) bytes
struct PROCESSOR_PERFSTATE_POLICY {
  ULONG Revision;         // offset: 0x0 (0)
  UCHAR MaxThrottle;      // offset: 0x4 (4)
  UCHAR MinThrottle;      // offset: 0x5 (5)
  UCHAR BusyAdjThreshold; // offset: 0x6 (6)
  union {
    UCHAR Spare; // offset: 0x7 (7)
    union {
      UCHAR AsUCHAR;                // offset: 0x7 (7)
      UCHAR NoDomainAccounting : 1; // offset: 0x7 (7)
      UCHAR IncreasePolicy : 2;     // offset: 0x7 (7)
      UCHAR DecreasePolicy : 2;     // offset: 0x7 (7)
      UCHAR Reserved : 3;           // offset: 0x7 (7)

    } Flags; // offset: 0x7 (7)
  };
  ULONG TimeCheck;       // offset: 0x8 (8)
  ULONG IncreaseTime;    // offset: 0xc (12)
  ULONG DecreaseTime;    // offset: 0x10 (16)
  ULONG IncreasePercent; // offset: 0x14 (20)
  ULONG DecreasePercent; // offset: 0x18 (24)
};

// 0x4 (4) bytes
union _PPM_IDLE_SYNCHRONIZATION_STATE {
  LONG AsLong;        // offset: 0x0 (0)
  LONG RefCount : 24; // offset: 0x0 (0)
  ULONG State : 8;    // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _CM_FAST_LEAF_HINT {
  union {
    UCHAR Characters[4]; // offset: 0x0 (0)
    ULONG FullHint;      // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
struct _LEARNING_MODE_DATA {
  ULONG Settings;              // offset: 0x0 (0)
  UCHAR Enabled;               // offset: 0x4 (4)
  UCHAR PermissiveModeEnabled; // offset: 0x5 (5)
};

// 0x40 (64) bytes
struct _WAITING_IRP {
  struct _LIST_ENTRY Links;                                 // offset: 0x0 (0)
  struct _IRP *Irp;                                         // offset: 0x10 (16)
  VOID (*CompletionRoutine)(VOID *arg1, struct _IRP *arg2); // offset: 0x18 (24)
  VOID *Context;                                            // offset: 0x20 (32)
  struct _KEVENT *Event;                                    // offset: 0x28 (40)
  ULONG Information;                                        // offset: 0x30 (48)
  UCHAR BreakAllRH;                                         // offset: 0x34 (52)
  UCHAR OplockBreakNotify;                                  // offset: 0x35 (53)
  struct _FILE_OBJECT *FileObject;                          // offset: 0x38 (56)
};

// 0x4 (4) bytes
union RTLP_HP_LFH_PERF_FLAGS {
  ULONG HotspotDetection : 1;            // offset: 0x0 (0)
  ULONG HotspotFullCommit : 1;           // offset: 0x0 (0)
  ULONG ActiveSubsegment : 1;            // offset: 0x0 (0)
  ULONG SmallerSubsegment : 1;           // offset: 0x0 (0)
  ULONG SingleAffinitySlot : 1;          // offset: 0x0 (0)
  ULONG ApplyLfhDecommitPolicy : 1;      // offset: 0x0 (0)
  ULONG EnableGarbageCollection : 1;     // offset: 0x0 (0)
  ULONG LargePagePreCommit : 1;          // offset: 0x0 (0)
  ULONG OpportunisticLargePreCommit : 1; // offset: 0x0 (0)
  ULONG LfhForcedAffinity : 1;           // offset: 0x0 (0)
  ULONG LfhCachelinePadding : 1;         // offset: 0x0 (0)
  ULONG AllFlags;                        // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _PPM_COORDINATED_SYNCHRONIZATION {
  LONG AsLong;               // offset: 0x0 (0)
  ULONG EnterProcessor : 12; // offset: 0x0 (0)
  ULONG ExitProcessor : 12;  // offset: 0x0 (0)
  ULONG Transition : 2;      // offset: 0x0 (0)
  ULONG Entered : 1;         // offset: 0x0 (0)
  ULONG EntryPriority : 5;   // offset: 0x0 (0)
};

// 0x80 (128) bytes
struct _IOV_IRP_TRACE {
  struct _IRP *Irp;        // offset: 0x0 (0)
  struct _KTHREAD *Thread; // offset: 0x8 (8)
  union {
    struct {
      SHORT KernelApcDisable;  // offset: 0x10 (16)
      SHORT SpecialApcDisable; // offset: 0x12 (18)
    };
    ULONG CombinedApcDisable; // offset: 0x10 (16)
  };
  UCHAR Irql;           // offset: 0x14 (20)
  VOID *StackTrace[13]; // offset: 0x18 (24)
};

// 0x38 (56) bytes
struct _VI_TRACK_IRQL {
  VOID *Thread;        // offset: 0x0 (0)
  UCHAR OldIrql;       // offset: 0x8 (8)
  UCHAR NewIrql;       // offset: 0x9 (9)
  USHORT Processor;    // offset: 0xa (10)
  ULONG TickCount;     // offset: 0xc (12)
  VOID *StackTrace[5]; // offset: 0x10 (16)
};

// 0x4 (4) bytes
struct _HEAP_GLOBAL_APPCOMPAT_FLAGS {
  ULONG SafeInputValidation : 1;  // offset: 0x0 (0)
  ULONG Padding : 1;              // offset: 0x0 (0)
  ULONG CommitLFHSubsegments : 1; // offset: 0x0 (0)
  ULONG AllocateHeapFromEnv : 1;  // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _TEB_ACTIVE_FRAME_CONTEXT {
  ULONG Flags;           // offset: 0x0 (0)
  const CHAR *FrameName; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _VF_TRACKER {
  ULONG TrackerFlags; // offset: 0x0 (0)
  ULONG TrackerSize;  // offset: 0x4 (4)
  ULONG TrackerIndex; // offset: 0x8 (8)
  ULONG TraceDepth;   // offset: 0xc (12)
};

// 0xc (12) bytes
struct _IOP_IRP_EXTENSION_STATUS {
  ULONG Flags;      // offset: 0x0 (0)
  ULONG ActivityId; // offset: 0x4 (4)
  ULONG IoTracking; // offset: 0x8 (8)
};

// 0x4 (4) bytes
union _KSTACK_COUNT {
  LONG Value;            // offset: 0x0 (0)
  ULONG State : 3;       // offset: 0x0 (0)
  ULONG StackCount : 29; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _RTL_ATOM_TABLE_REFERENCE {
  struct _LIST_ENTRY LowBoxList; // offset: 0x0 (0)
  ULONG LowBoxID;                // offset: 0x10 (16)
  USHORT ReferenceCount;         // offset: 0x14 (20)
  USHORT Flags;                  // offset: 0x16 (22)
};

// 0x30 (48) bytes
struct _RTL_ATOM_TABLE_ENTRY {
  struct _RTL_ATOM_TABLE_ENTRY *HashLink;     // offset: 0x0 (0)
  USHORT HandleIndex;                         // offset: 0x8 (8)
  USHORT Atom;                                // offset: 0xa (10)
  struct _RTL_ATOM_TABLE_REFERENCE Reference; // offset: 0x10 (16)
  UCHAR NameLength;                           // offset: 0x28 (40)
  WCHAR Name[1];                              // offset: 0x2a (42)
};

// 0x18 (24) bytes
struct _POP_ACTION_TRIGGER {
  enum POWER_POLICY_DEVICE_TYPE Type; // offset: 0x0 (0)
  ULONG Flags;                        // offset: 0x4 (4)
  struct _POP_TRIGGER_WAIT *Wait;     // offset: 0x8 (8)
  union {
    struct {
      ULONG PercentLevel; // offset: 0x0 (0)
    } Battery;            // offset: 0x10 (16)
    struct {
      ULONG Type; // offset: 0x0 (0)
    } Button;     // offset: 0x10 (16)
  };
};

// 0x38 (56) bytes
struct _POP_TRIGGER_WAIT {
  struct _KEVENT Event;                // offset: 0x0 (0)
  LONG Status;                         // offset: 0x18 (24)
  struct _LIST_ENTRY Link;             // offset: 0x20 (32)
  struct _POP_ACTION_TRIGGER *Trigger; // offset: 0x30 (48)
};

// 0x70 (112) bytes
struct _PI_BUS_EXTENSION {
  ULONG Flags;                                // offset: 0x0 (0)
  UCHAR NumberCSNs;                           // offset: 0x4 (4)
  UCHAR *ReadDataPort;                        // offset: 0x8 (8)
  UCHAR DataPortMapped;                       // offset: 0x10 (16)
  UCHAR *AddressPort;                         // offset: 0x18 (24)
  UCHAR AddrPortMapped;                       // offset: 0x20 (32)
  UCHAR *CommandPort;                         // offset: 0x28 (40)
  UCHAR CmdPortMapped;                        // offset: 0x30 (48)
  ULONG NextSlotNumber;                       // offset: 0x34 (52)
  struct _SINGLE_LIST_ENTRY DeviceList;       // offset: 0x38 (56)
  struct _SINGLE_LIST_ENTRY CardList;         // offset: 0x40 (64)
  struct _DEVICE_OBJECT *PhysicalBusDevice;   // offset: 0x48 (72)
  struct _DEVICE_OBJECT *FunctionalBusDevice; // offset: 0x50 (80)
  struct _DEVICE_OBJECT *AttachedDevice;      // offset: 0x58 (88)
  ULONG BusNumber;                            // offset: 0x60 (96)
  enum _SYSTEM_POWER_STATE SystemPowerState;  // offset: 0x64 (100)
  enum _DEVICE_POWER_STATE DevicePowerState;  // offset: 0x68 (104)
};

// 0x10 (16) bytes
struct _BUS_EXTENSION_LIST {
  VOID *Next;                             // offset: 0x0 (0)
  struct _PI_BUS_EXTENSION *BusExtension; // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _THERMAL_POLICY {
  ULONG Version;           // offset: 0x0 (0)
  UCHAR WaitForUpdate;     // offset: 0x4 (4)
  UCHAR Hibernate;         // offset: 0x5 (5)
  UCHAR Critical;          // offset: 0x6 (6)
  UCHAR ThermalStandby;    // offset: 0x7 (7)
  ULONG ActivationReasons; // offset: 0x8 (8)
  ULONG PassiveLimit;      // offset: 0xc (12)
  ULONG ActiveLevel;       // offset: 0x10 (16)
  UCHAR OverThrottled;     // offset: 0x14 (20)
};

// 0x8 (8) bytes
struct BATTERY_REPORTING_SCALE {
  ULONG Granularity; // offset: 0x0 (0)
  ULONG Capacity;    // offset: 0x4 (4)
};

// 0x4c (76) bytes
struct SYSTEM_POWER_CAPABILITIES {
  UCHAR PowerButtonPresent;                       // offset: 0x0 (0)
  UCHAR SleepButtonPresent;                       // offset: 0x1 (1)
  UCHAR LidPresent;                               // offset: 0x2 (2)
  UCHAR SystemS1;                                 // offset: 0x3 (3)
  UCHAR SystemS2;                                 // offset: 0x4 (4)
  UCHAR SystemS3;                                 // offset: 0x5 (5)
  UCHAR SystemS4;                                 // offset: 0x6 (6)
  UCHAR SystemS5;                                 // offset: 0x7 (7)
  UCHAR HiberFilePresent;                         // offset: 0x8 (8)
  UCHAR FullWake;                                 // offset: 0x9 (9)
  UCHAR VideoDimPresent;                          // offset: 0xa (10)
  UCHAR ApmPresent;                               // offset: 0xb (11)
  UCHAR UpsPresent;                               // offset: 0xc (12)
  UCHAR ThermalControl;                           // offset: 0xd (13)
  UCHAR ProcessorThrottle;                        // offset: 0xe (14)
  UCHAR ProcessorMinThrottle;                     // offset: 0xf (15)
  UCHAR ProcessorMaxThrottle;                     // offset: 0x10 (16)
  UCHAR FastSystemS4;                             // offset: 0x11 (17)
  UCHAR Hiberboot;                                // offset: 0x12 (18)
  UCHAR WakeAlarmPresent;                         // offset: 0x13 (19)
  UCHAR AoAc;                                     // offset: 0x14 (20)
  UCHAR DiskSpinDown;                             // offset: 0x15 (21)
  UCHAR HiberFileType;                            // offset: 0x16 (22)
  UCHAR AoAcConnectivitySupported;                // offset: 0x17 (23)
  UCHAR spare3[6];                                // offset: 0x18 (24)
  UCHAR SystemBatteriesPresent;                   // offset: 0x1e (30)
  UCHAR BatteriesAreShortTerm;                    // offset: 0x1f (31)
  struct BATTERY_REPORTING_SCALE BatteryScale[3]; // offset: 0x20 (32)
  enum _SYSTEM_POWER_STATE AcOnLineWake;          // offset: 0x38 (56)
  enum _SYSTEM_POWER_STATE SoftLidWake;           // offset: 0x3c (60)
  enum _SYSTEM_POWER_STATE RtcWake;               // offset: 0x40 (64)
  enum _SYSTEM_POWER_STATE MinDeviceWakeState;    // offset: 0x44 (68)
  enum _SYSTEM_POWER_STATE DefaultLowLatencyWake; // offset: 0x48 (72)
};

// 0x4 (4) bytes
union _MI_FLAGS {
  LONG EntireFlags;                       // offset: 0x0 (0)
  ULONG VerifierEnabled : 1;              // offset: 0x0 (0)
  ULONG KernelVerifierEnabled : 1;        // offset: 0x0 (0)
  ULONG LargePageKernel : 1;              // offset: 0x0 (0)
  ULONG StopOn4d : 1;                     // offset: 0x0 (0)
  ULONG InitializationPhase : 2;          // offset: 0x0 (0)
  ULONG PageKernelStacks : 1;             // offset: 0x0 (0)
  ULONG CheckZeroPages : 1;               // offset: 0x0 (0)
  ULONG ProcessorPrewalks : 1;            // offset: 0x0 (0)
  ULONG ProcessorPostwalks : 1;           // offset: 0x0 (0)
  ULONG CoverageBuild : 1;                // offset: 0x0 (0)
  ULONG AccessBitReplacementDisabled : 1; // offset: 0x0 (0)
  ULONG CheckExecute : 1;                 // offset: 0x0 (0)
  ULONG ProtectedPagesEnabled : 1;        // offset: 0x0 (0)
  ULONG SecureRelocations : 1;            // offset: 0x0 (0)
  ULONG StrongPageIdentity : 1;           // offset: 0x0 (0)
  ULONG StrongCodeGuarantees : 1;         // offset: 0x0 (0)
  ULONG HardCodeGuarantees : 1;           // offset: 0x0 (0)
  ULONG ExecutePagePrivilegeRequired : 1; // offset: 0x0 (0)
  ULONG SecureKernelCfgEnabled : 1;       // offset: 0x0 (0)
  ULONG FullHvci : 1;                     // offset: 0x0 (0)
  ULONG BootDebuggerActive : 1;           // offset: 0x0 (0)
  ULONG ExceptionHandlingReady : 1;       // offset: 0x0 (0)
  ULONG ShadowStacksSupported : 1;        // offset: 0x0 (0)
  ULONG AccessBitFenceRequired : 1;       // offset: 0x0 (0)
  ULONG PfnDatabaseExists : 1;            // offset: 0x0 (0)
  ULONG DeferredHotAddsCompleted : 1;     // offset: 0x0 (0)
  ULONG SystemPtesReady : 1;              // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _RTL_RANGE_LIST {
  struct _LIST_ENTRY ListHead; // offset: 0x0 (0)
  ULONG Flags;                 // offset: 0x10 (16)
  ULONG Count;                 // offset: 0x14 (20)
  ULONG Stamp;                 // offset: 0x18 (24)
};

// 0x8 (8) bytes
struct PROCESSOR_IDLESTATE_INFO {
  ULONG TimeCheck;      // offset: 0x0 (0)
  UCHAR DemotePercent;  // offset: 0x4 (4)
  UCHAR PromotePercent; // offset: 0x5 (5)
  UCHAR Spare[2];       // offset: 0x6 (6)
};

// 0x20 (32) bytes
struct PROCESSOR_IDLESTATE_POLICY {
  USHORT Revision; // offset: 0x0 (0)
  union {
    USHORT AsUSHORT;         // offset: 0x2 (2)
    USHORT AllowScaling : 1; // offset: 0x2 (2)
    USHORT Disabled : 1;     // offset: 0x2 (2)
    USHORT Reserved : 14;    // offset: 0x2 (2)

  } Flags;                                   // offset: 0x2 (2)
  ULONG PolicyCount;                         // offset: 0x4 (4)
  struct PROCESSOR_IDLESTATE_INFO Policy[3]; // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct _MI_NODE_NUMBER_ZERO_BASED {
  ULONG ZeroBased; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _MI_HUGE_SYSTEM_VIEW_HEAD {
  struct _RTL_AVL_TREE ViewRoot; // offset: 0x0 (0)
  ULONG ViewCount;               // offset: 0x8 (8)
  volatile LONG Lock;            // offset: 0xc (12)
};

// 0x8 (8) bytes
struct _MI_RESAVAIL_FAILURES {
  ULONG Wrap;     // offset: 0x0 (0)
  ULONG NoCharge; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _MI_FORCED_COMMITS {
  ULONG Regular; // offset: 0x0 (0)
  ULONG Wrap;    // offset: 0x4 (4)
};

// 0x44 (68) bytes
struct _MI_PROBE_RAISE_TRACKER {
  ULONG UserRangeInKernel;              // offset: 0x0 (0)
  ULONG FaultFailed;                    // offset: 0x4 (4)
  ULONG WriteFaultFailed;               // offset: 0x8 (8)
  ULONG LargePageFailed;                // offset: 0xc (12)
  ULONG UserAccessToKernelPte;          // offset: 0x10 (16)
  ULONG BadPageLocation;                // offset: 0x14 (20)
  ULONG InsufficientCharge;             // offset: 0x18 (24)
  ULONG PageTableCharge;                // offset: 0x1c (28)
  ULONG NoPhysicalMapping;              // offset: 0x20 (32)
  ULONG NoIoReference;                  // offset: 0x24 (36)
  ULONG ProbeFailed;                    // offset: 0x28 (40)
  ULONG PteIsZero;                      // offset: 0x2c (44)
  ULONG StrongCodeWrite;                // offset: 0x30 (48)
  ULONG ReducedCloneCommitChargeFailed; // offset: 0x34 (52)
  ULONG CopyOnWriteAtDispatchNoPages;   // offset: 0x38 (56)
  ULONG NoPageTablesAllowed;            // offset: 0x3c (60)
  ULONG EnclavePageFailed;              // offset: 0x40 (64)
};

// 0x10 (16) bytes
struct _MM_SYSTEM_PAGE_COUNTS {
  ULONG SystemCodePage;        // offset: 0x0 (0)
  ULONG SystemDriverPage;      // offset: 0x4 (4)
  LONG TotalSystemCodePages;   // offset: 0x8 (8)
  LONG TotalSystemDriverPages; // offset: 0xc (12)
};

// 0x18 (24) bytes
struct _LOADER_FEATURE_CONFIGURATION_DIAGNOSTIC_INFORMATION {
  UCHAR OriginalBootStatus;  // offset: 0x0 (0)
  UCHAR NewBootStatus;       // offset: 0x1 (1)
  UCHAR ConfigurationLoaded; // offset: 0x2 (2)
  UCHAR Spare;               // offset: 0x3 (3)
  union {
    ULONG AllFlags;                              // offset: 0x4 (4)
    ULONG LkgSupported : 1;                      // offset: 0x4 (4)
    ULONG FinalBootBeforeRecovery : 1;           // offset: 0x4 (4)
    ULONG ConfigurationComparisonAttempted : 1;  // offset: 0x4 (4)
    ULONG CurrentConfigurationLoadAttempted : 1; // offset: 0x4 (4)
    ULONG LkgConfigurationLoadAttempted : 1;     // offset: 0x4 (4)
    ULONG UsageSubscriptionLoadAttempted : 1;    // offset: 0x4 (4)
    ULONG Spare : 26;                            // offset: 0x4 (4)

  } Flags;                             // offset: 0x4 (4)
  LONG ConfigurationComparisonStatus;  // offset: 0x8 (8)
  LONG CurrentConfigurationLoadStatus; // offset: 0xc (12)
  LONG LkgConfigurationLoadStatus;     // offset: 0x10 (16)
  LONG UsageSubscriptionLoadStatus;    // offset: 0x14 (20)
};

// 0x4 (4) bytes
struct _INPUT_MAPPING_ELEMENT {
  ULONG InputMappingId; // offset: 0x0 (0)
};

// 0xc (12) bytes
union _IOMMU_SVM_CAPABILITIES {
  ULONG AtsCapability : 1; // offset: 0x0 (0)
  ULONG PriCapability : 1; // offset: 0x0 (0)
  struct {
    ULONG PasidCapability : 1; // offset: 0x0 (0)
    struct {
      ULONG PasidMaxWidth : 5;           // offset: 0x0 (0)
      ULONG PasidExePerm : 1;            // offset: 0x0 (0)
      ULONG PasidPrivMode : 1;           // offset: 0x0 (0)
      ULONG AtsPageAlignedRequest : 1;   // offset: 0x0 (0)
      ULONG AtsGlobalInvalidate : 1;     // offset: 0x0 (0)
      ULONG AtsInvalidateQueueDepth : 5; // offset: 0x0 (0)
    } CapReg;                            // offset: 0x4 (4)
  };
  struct {
    ULONG Rsvd : 15; // offset: 0x8 (8)
  };
  ULONG AsULONG; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _NETWORK_LOADER_BLOCK {
  UCHAR *DHCPServerACK;              // offset: 0x0 (0)
  ULONG DHCPServerACKLength;         // offset: 0x8 (8)
  UCHAR *BootServerReplyPacket;      // offset: 0x10 (16)
  ULONG BootServerReplyPacketLength; // offset: 0x18 (24)
};

// 0x4 (4) bytes
struct _DEVICE_FLAGS {
  ULONG Failed : 1;     // offset: 0x0 (0)
  ULONG ReadOnly : 1;   // offset: 0x0 (0)
  ULONG Removable : 1;  // offset: 0x0 (0)
  ULONG ConsoleIn : 1;  // offset: 0x0 (0)
  ULONG ConsoleOut : 1; // offset: 0x0 (0)
  ULONG Input : 1;      // offset: 0x0 (0)
  ULONG Output : 1;     // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _INTERRUPT_HT_INTR_INFO {
  union {
    struct {
      ULONG Mask : 1;            // offset: 0x0 (0)
      ULONG Polarity : 1;        // offset: 0x0 (0)
      ULONG MessageType : 3;     // offset: 0x0 (0)
      ULONG RequestEOI : 1;      // offset: 0x0 (0)
      ULONG DestinationMode : 1; // offset: 0x0 (0)
      ULONG MessageType3 : 1;    // offset: 0x0 (0)
      ULONG Destination : 8;     // offset: 0x0 (0)
      ULONG Vector : 8;          // offset: 0x0 (0)
      ULONG ExtendedAddress : 8; // offset: 0x0 (0)
    } bits;                      // offset: 0x0 (0)
    ULONG AsULONG;               // offset: 0x0 (0)

  } LowPart; // offset: 0x0 (0)
  union {
    struct {
      ULONG ExtendedDestination : 24; // offset: 0x0 (0)
      ULONG Reserved : 6;             // offset: 0x0 (0)
      ULONG PassPW : 1;               // offset: 0x0 (0)
      ULONG WaitingForEOI : 1;        // offset: 0x0 (0)
    } bits;                           // offset: 0x4 (4)
    ULONG AsULONG;                    // offset: 0x4 (4)

  } HighPart; // offset: 0x4 (4)
};

// 0x4 (4) bytes
struct _PCAT_FIRMWARE_INFORMATION {
  ULONG PlaceHolder; // offset: 0x0 (0)
};

// 0x14 (20) bytes
struct _LOADER_HIVE_RECOVERY_INFO {
  ULONG Recovered : 1;          // offset: 0x0 (0)
  ULONG LegacyRecovery : 1;     // offset: 0x0 (0)
  ULONG SoftRebootConflict : 1; // offset: 0x0 (0)
  ULONG MostRecentLog : 3;      // offset: 0x0 (0)
  ULONG Spare : 27;             // offset: 0x4 (4)
  ULONG LogNextSequence;        // offset: 0x8 (8)
  ULONG LogMinimumSequence;     // offset: 0xc (12)
  ULONG LogCurrentOffset;       // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _PROFILE_PARAMETER_BLOCK {
  USHORT Status;       // offset: 0x0 (0)
  USHORT Reserved;     // offset: 0x2 (2)
  USHORT DockingState; // offset: 0x4 (4)
  USHORT Capabilities; // offset: 0x6 (6)
  ULONG DockID;        // offset: 0x8 (8)
  ULONG SerialNumber;  // offset: 0xc (12)
};

// 0x28 (40) bytes
struct _CONFIGURATION_COMPONENT {
  enum _CONFIGURATION_CLASS Class; // offset: 0x0 (0)
  enum _CONFIGURATION_TYPE Type;   // offset: 0x4 (4)
  struct _DEVICE_FLAGS Flags;      // offset: 0x8 (8)
  USHORT Version;                  // offset: 0xc (12)
  USHORT Revision;                 // offset: 0xe (14)
  ULONG Key;                       // offset: 0x10 (16)
  union {
    ULONG AffinityMask; // offset: 0x14 (20)
    struct {
      USHORT Group;      // offset: 0x14 (20)
      USHORT GroupIndex; // offset: 0x16 (22)
    };
  };
  ULONG ConfigurationDataLength; // offset: 0x18 (24)
  ULONG IdentifierLength;        // offset: 0x1c (28)
  CHAR *Identifier;              // offset: 0x20 (32)
};

// 0x48 (72) bytes
struct _CONFIGURATION_COMPONENT_DATA {
  struct _CONFIGURATION_COMPONENT_DATA *Parent;   // offset: 0x0 (0)
  struct _CONFIGURATION_COMPONENT_DATA *Child;    // offset: 0x8 (8)
  struct _CONFIGURATION_COMPONENT_DATA *Sibling;  // offset: 0x10 (16)
  struct _CONFIGURATION_COMPONENT ComponentEntry; // offset: 0x18 (24)
  VOID *ConfigurationData;                        // offset: 0x40 (64)
};

// 0x28 (40) bytes
struct _SUPPORTED_RANGE {
  struct _SUPPORTED_RANGE *Next; // offset: 0x0 (0)
  ULONG SystemAddressSpace;      // offset: 0x8 (8)
  LONGLONG SystemBase;           // offset: 0x10 (16)
  LONGLONG Base;                 // offset: 0x18 (24)
  LONGLONG Limit;                // offset: 0x20 (32)
};

// 0x4 (4) bytes
struct _FAULT_INFORMATION_X64_FLAGS {
  ULONG FaultAddressValid : 1; // offset: 0x0 (0)
  ULONG Reserved : 31;         // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _FAULT_INFORMATION_ARM64_FLAGS {
  ULONG WriteNotRead : 1;       // offset: 0x0 (0)
  ULONG InstructionNotData : 1; // offset: 0x0 (0)
  ULONG Privileged : 1;         // offset: 0x0 (0)
  ULONG FaultAddressValid : 1;  // offset: 0x0 (0)
  ULONG Reserved : 28;          // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _ARM_LOADER_BLOCK {
  ULONG PlaceHolder; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _I386_LOADER_BLOCK {
  VOID *CommonDataArea; // offset: 0x0 (0)
  ULONG MachineType;    // offset: 0x8 (8)
  ULONG VirtualBias;    // offset: 0xc (12)
};

// 0x18 (24) bytes
struct DEBUG_DEVICE_ADDRESS {
  UCHAR Type;  // offset: 0x0 (0)
  UCHAR Valid; // offset: 0x1 (1)
  union {
    UCHAR Reserved[2]; // offset: 0x2 (2)
    struct {
      UCHAR BitWidth;   // offset: 0x2 (2)
      UCHAR AccessSize; // offset: 0x3 (3)
    };
  };
  UCHAR *TranslatedAddress; // offset: 0x8 (8)
  ULONG Length;             // offset: 0x10 (16)
};

// 0xc0 (192) bytes
struct _SUPPORTED_RANGES {
  USHORT Version;                         // offset: 0x0 (0)
  UCHAR Sorted;                           // offset: 0x2 (2)
  UCHAR Reserved;                         // offset: 0x3 (3)
  ULONG NoIO;                             // offset: 0x4 (4)
  struct _SUPPORTED_RANGE IO;             // offset: 0x8 (8)
  ULONG NoMemory;                         // offset: 0x30 (48)
  struct _SUPPORTED_RANGE Memory;         // offset: 0x38 (56)
  ULONG NoPrefetchMemory;                 // offset: 0x60 (96)
  struct _SUPPORTED_RANGE PrefetchMemory; // offset: 0x68 (104)
  ULONG NoDma;                            // offset: 0x90 (144)
  struct _SUPPORTED_RANGE Dma;            // offset: 0x98 (152)
};

// 0x8 (8) bytes
struct _DEBUG_TRANSPORT_DATA {
  ULONG HwContextSize;    // offset: 0x0 (0)
  UCHAR UseSerialFraming; // offset: 0x4 (4)
  UCHAR ValidUSBCoreId;   // offset: 0x5 (5)
  UCHAR USBCoreId;        // offset: 0x6 (6)
};

// 0x20 (32) bytes
struct _HAL_UNMASKED_INTERRUPT_INFORMATION {
  USHORT Version;                            // offset: 0x0 (0)
  USHORT Size;                               // offset: 0x2 (2)
  union _HAL_UNMASKED_INTERRUPT_FLAGS Flags; // offset: 0x4 (4)
  enum _KINTERRUPT_MODE Mode;                // offset: 0x8 (8)
  enum _KINTERRUPT_POLARITY Polarity;        // offset: 0xc (12)
  ULONG Gsiv;                                // offset: 0x10 (16)
  USHORT PinNumber;                          // offset: 0x14 (20)
  VOID *DeviceHandle;                        // offset: 0x18 (24)
};

// 0xc (12) bytes
struct _PCI_BUSMASTER_DESCRIPTOR {
  enum _PCI_BUSMASTER_RID_TYPE Type; // offset: 0x0 (0)
  ULONG Segment;                     // offset: 0x4 (4)
  union {
    struct {
      UCHAR Bus;      // offset: 0x0 (0)
      UCHAR Device;   // offset: 0x1 (1)
      UCHAR Function; // offset: 0x2 (2)
      UCHAR Reserved; // offset: 0x3 (3)
    } DeviceRid;      // offset: 0x8 (8)
    struct {
      UCHAR Bus;      // offset: 0x0 (0)
      UCHAR Device;   // offset: 0x1 (1)
      UCHAR Function; // offset: 0x2 (2)
      UCHAR Reserved; // offset: 0x3 (3)
    } BridgeRid;      // offset: 0x8 (8)
    struct {
      UCHAR SecondaryBus;   // offset: 0x0 (0)
      UCHAR SubordinateBus; // offset: 0x1 (1)
    } MultipleBridges;      // offset: 0x8 (8)
  };
};

// 0x10 (16) bytes
struct _HAL_LOG_REGISTER_CONTEXT {
  VOID (*LogRoutine)(ULONG arg1, VOID *arg2, ULONG arg3); // offset: 0x0 (0)
  ULONG Flag;                                             // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _INTERRUPT_REMAPPING_INFO {
  ULONG IrtIndex : 30;       // offset: 0x0 (0)
  ULONG FlagHalInternal : 1; // offset: 0x0 (0)
  ULONG FlagTranslated : 1;  // offset: 0x0 (0)
  union {
    struct {
      ULONG MessageAddressHigh; // offset: 0x0 (0)
      ULONG MessageAddressLow;  // offset: 0x4 (4)
      USHORT MessageData;       // offset: 0x8 (8)
      USHORT Reserved;          // offset: 0xa (10)
    } Msi;                      // offset: 0x4 (4)

  } u; // offset: 0x4 (4)
};

// 0xc (12) bytes
struct POWER_ACTION_POLICY {
  enum POWER_ACTION Action; // offset: 0x0 (0)
  ULONG Flags;              // offset: 0x4 (4)
  ULONG EventCode;          // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct SYSTEM_POWER_LEVEL {
  UCHAR Enable;                            // offset: 0x0 (0)
  UCHAR Spare[3];                          // offset: 0x1 (1)
  ULONG BatteryLevel;                      // offset: 0x4 (4)
  struct POWER_ACTION_POLICY PowerPolicy;  // offset: 0x8 (8)
  enum _SYSTEM_POWER_STATE MinSystemState; // offset: 0x14 (20)
};

// 0x28 (40) bytes
struct _VF_SUSPECT_DRIVER_ENTRY {
  struct _LIST_ENTRY Links;        // offset: 0x0 (0)
  ULONG Loads;                     // offset: 0x10 (16)
  ULONG Unloads;                   // offset: 0x14 (20)
  struct _UNICODE_STRING BaseName; // offset: 0x18 (24)
};

// 0x4 (4) bytes
struct _HEAP_STOP_ON_TAG {
  union {
    ULONG HeapAndTagIndex; // offset: 0x0 (0)
    struct {
      USHORT TagIndex;  // offset: 0x0 (0)
      USHORT HeapIndex; // offset: 0x2 (2)
    };
  };
};

// 0xc (12) bytes
struct _OBJECT_REF_STACK_INFO {
  ULONG Sequence;   // offset: 0x0 (0)
  USHORT Index;     // offset: 0x4 (4)
  USHORT NumTraces; // offset: 0x6 (6)
  ULONG Tag;        // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _PO_NOTIFY_ORDER_LEVEL {
  ULONG DeviceCount;             // offset: 0x0 (0)
  ULONG ActiveCount;             // offset: 0x4 (4)
  struct _LIST_ENTRY WaitSleep;  // offset: 0x8 (8)
  struct _LIST_ENTRY ReadySleep; // offset: 0x18 (24)
  struct _LIST_ENTRY ReadyS0;    // offset: 0x28 (40)
  struct _LIST_ENTRY WaitS0;     // offset: 0x38 (56)
};

// 0x180 (384) bytes
struct _PO_DEVICE_NOTIFY_ORDER {
  UCHAR Locked;                                // offset: 0x0 (0)
  struct _DEVICE_OBJECT **WarmEjectPdoPointer; // offset: 0x8 (8)
  struct _PO_NOTIFY_ORDER_LEVEL OrderLevel[5]; // offset: 0x10 (16)
  ULONG Flags;                                 // offset: 0x178 (376)
};

// 0x2b0 (688) bytes
struct _KPRIQUEUE {
  struct _DISPATCHER_HEADER Header;     // offset: 0x0 (0)
  struct _LIST_ENTRY EntryListHead[32]; // offset: 0x18 (24)
  volatile LONG CurrentCount[32];       // offset: 0x218 (536)
  ULONG MaximumCount;                   // offset: 0x298 (664)
  struct _LIST_ENTRY ThreadListHead;    // offset: 0x2a0 (672)
};

// 0x2b0 (688) bytes
struct _TRIAGE_EX_WORK_QUEUE {
  struct _KPRIQUEUE WorkPriQueue; // offset: 0x0 (0)
};

// 0x28 (40) bytes
struct _TRIAGE_9F_POWER {
  USHORT Signature;                                 // offset: 0x0 (0)
  USHORT Revision;                                  // offset: 0x2 (2)
  struct _LIST_ENTRY *IrpList;                      // offset: 0x8 (8)
  struct _LIST_ENTRY *ThreadList;                   // offset: 0x10 (16)
  struct _TRIAGE_EX_WORK_QUEUE *DelayedWorkQueue;   // offset: 0x18 (24)
  struct _TRIAGE_EX_WORK_QUEUE *DelayedIoWorkQueue; // offset: 0x20 (32)
};

// 0x20 (32) bytes
struct _TRIAGE_9F_PNP {
  USHORT Signature; // offset: 0x0 (0)
  USHORT Revision;  // offset: 0x2 (2)
  struct _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE
      *CompletionQueue;                             // offset: 0x8 (8)
  struct _TRIAGE_EX_WORK_QUEUE *DelayedWorkQueue;   // offset: 0x10 (16)
  struct _TRIAGE_EX_WORK_QUEUE *DelayedIoWorkQueue; // offset: 0x18 (24)
};

// 0x48 (72) bytes
struct _SK_CRASH_MODULE {
  WCHAR ImageName[32]; // offset: 0x0 (0)
  ULONG SizeOfImage;   // offset: 0x40 (64)
  ULONG TimeDateStamp; // offset: 0x44 (68)
};

// 0x38 (56) bytes
struct _VI_DEADLOCK_THREAD {
  struct _KTHREAD *Thread;                    // offset: 0x0 (0)
  struct _VI_DEADLOCK_NODE *CurrentSpinNode;  // offset: 0x8 (8)
  struct _VI_DEADLOCK_NODE *CurrentOtherNode; // offset: 0x10 (16)
  union {
    struct _LIST_ENTRY ListEntry;     // offset: 0x18 (24)
    struct _LIST_ENTRY FreeListEntry; // offset: 0x18 (24)
  };
  ULONG NodeCount;            // offset: 0x28 (40)
  volatile ULONG PagingCount; // offset: 0x2c (44)
  UCHAR ThreadUsesEresources; // offset: 0x30 (48)
};

// 0xf8 (248) bytes
struct _VI_DEADLOCK_RESOURCE {
  enum _VI_DEADLOCK_RESOURCE_TYPE Type;    // offset: 0x0 (0)
  ULONG NodeCount : 16;                    // offset: 0x4 (4)
  ULONG RecursionCount : 16;               // offset: 0x4 (4)
  VOID *ResourceAddress;                   // offset: 0x8 (8)
  struct _VI_DEADLOCK_THREAD *ThreadOwner; // offset: 0x10 (16)
  struct _LIST_ENTRY ResourceList;         // offset: 0x18 (24)
  union {
    struct _LIST_ENTRY HashChainList; // offset: 0x28 (40)
    struct _LIST_ENTRY FreeListEntry; // offset: 0x28 (40)
  };
  VOID *StackTrace[8];       // offset: 0x38 (56)
  VOID *LastAcquireTrace[8]; // offset: 0x78 (120)
  VOID *LastReleaseTrace[8]; // offset: 0xb8 (184)
};

// 0xd0 (208) bytes
struct _VI_DEADLOCK_NODE {
  struct _VI_DEADLOCK_NODE *Parent; // offset: 0x0 (0)
  struct _LIST_ENTRY ChildrenList;  // offset: 0x8 (8)
  struct _LIST_ENTRY SiblingsList;  // offset: 0x18 (24)
  union {
    struct _LIST_ENTRY ResourceList;  // offset: 0x28 (40)
    struct _LIST_ENTRY FreeListEntry; // offset: 0x28 (40)
  };
  struct _VI_DEADLOCK_RESOURCE *Root;      // offset: 0x38 (56)
  struct _VI_DEADLOCK_THREAD *ThreadEntry; // offset: 0x40 (64)
  union {
    ULONG Active : 1;             // offset: 0x48 (72)
    ULONG OnlyTryAcquireUsed : 1; // offset: 0x48 (72)
    ULONG ReleasedOutOfOrder : 1; // offset: 0x48 (72)
    ULONG SequenceNumber : 29;    // offset: 0x48 (72)
    ULONG Whole;                  // offset: 0x48 (72)

  } u1;                      // offset: 0x48 (72)
  LONG ChildrenCount;        // offset: 0x4c (76)
  VOID *StackTrace[8];       // offset: 0x50 (80)
  VOID *ParentStackTrace[8]; // offset: 0x90 (144)
};

// 0x10 (16) bytes
struct _WNF_STATE_DATA {
  struct _WNF_NODE_HEADER Header; // offset: 0x0 (0)
  ULONG AllocatedSize;            // offset: 0x4 (4)
  ULONG DataSize;                 // offset: 0x8 (8)
  ULONG ChangeStamp;              // offset: 0xc (12)
};

// 0x4 (4) bytes
union _WHEAP_ERROR_RECORD_WRAPPER_FLAGS {
  ULONG Preallocated : 1;            // offset: 0x0 (0)
  ULONG FromPersistentStore : 1;     // offset: 0x0 (0)
  ULONG PlatformPfaControl : 1;      // offset: 0x0 (0)
  ULONG PlatformDirectedOffline : 1; // offset: 0x0 (0)
  ULONG Reserved : 28;               // offset: 0x0 (0)
  ULONG AsULONG;                     // offset: 0x0 (0)
};

// 0x38 (56) bytes
struct _WHEAP_ERROR_SOURCE_TABLE {
  ULONG Signature;           // offset: 0x0 (0)
  LONG Count;                // offset: 0x4 (4)
  ULONG NextId;              // offset: 0x8 (8)
  struct _LIST_ENTRY Items;  // offset: 0x10 (16)
  struct _KEVENT InsertLock; // offset: 0x20 (32)
};

// 0x28 (40) bytes
struct _OBP_LOOKUP_CONTEXT {
  struct _OBJECT_DIRECTORY *Directory;        // offset: 0x0 (0)
  VOID *Object;                               // offset: 0x8 (8)
  struct _OBJECT_DIRECTORY_ENTRY **EntryLink; // offset: 0x10 (16)
  ULONG HashValue;                            // offset: 0x18 (24)
  USHORT HashIndex;                           // offset: 0x1c (28)
  UCHAR DirectoryLocked;                      // offset: 0x1e (30)
  UCHAR LockedExclusive;                      // offset: 0x1f (31)
  ULONG LockStateSignature;                   // offset: 0x20 (32)
};

// 0x20 (32) bytes
struct _OBJECT_HEADER_CREATOR_INFO {
  struct _LIST_ENTRY TypeList;  // offset: 0x0 (0)
  VOID *CreatorUniqueProcess;   // offset: 0x10 (16)
  USHORT CreatorBackTraceIndex; // offset: 0x18 (24)
  USHORT Reserved1;             // offset: 0x1a (26)
  ULONG Reserved2;              // offset: 0x1c (28)
};

// 0x20 (32) bytes
struct _OBJECT_HEADER_NAME_INFO {
  struct _OBJECT_DIRECTORY *Directory; // offset: 0x0 (0)
  struct _UNICODE_STRING Name;         // offset: 0x8 (8)
  LONG ReferenceCount;                 // offset: 0x18 (24)
  ULONG Reserved;                      // offset: 0x1c (28)
};

// 0x58 (88) bytes
struct _IOP_FILE_OBJECT_EXTENSION {
  ULONG FoExtFlags;                         // offset: 0x0 (0)
  VOID *FoExtPerTypeExtension[9];           // offset: 0x8 (8)
  enum _IOP_PRIORITY_HINT FoIoPriorityHint; // offset: 0x50 (80)
};

// 0x10 (16) bytes
struct _OB_EXTENDED_PARSE_PARAMETERS {
  USHORT Length;              // offset: 0x0 (0)
  ULONG RestrictedAccessMask; // offset: 0x4 (4)
  struct _EJOB *Silo;         // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _OBJECT_DUMP_CONTROL {
  VOID *Stream; // offset: 0x0 (0)
  ULONG Detail; // offset: 0x8 (8)
};

// 0x30 (48) bytes
struct _OBJECT_ATTRIBUTES {
  ULONG Length;                       // offset: 0x0 (0)
  VOID *RootDirectory;                // offset: 0x8 (8)
  struct _UNICODE_STRING *ObjectName; // offset: 0x10 (16)
  ULONG Attributes;                   // offset: 0x18 (24)
  VOID *SecurityDescriptor;           // offset: 0x20 (32)
  VOID *SecurityQualityOfService;     // offset: 0x28 (40)
};

// 0x8 (8) bytes
struct _ALPC_WORK_ON_BEHALF_TICKET {
  ULONG ThreadId;              // offset: 0x0 (0)
  ULONG ThreadCreationTimeLow; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _KALPC_WORK_ON_BEHALF_DATA {
  struct _ALPC_WORK_ON_BEHALF_TICKET Ticket; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _BLOB_COUNTERS {
  ULONG CreatedObjects; // offset: 0x0 (0)
  ULONG DeletedObjects; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _ALPC_MESSAGE_ATTRIBUTES {
  ULONG AllocatedAttributes; // offset: 0x0 (0)
  ULONG ValidAttributes;     // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct _HEAP_EXTENDED_ENTRY {
  VOID *Reserved; // offset: 0x0 (0)
  union {
    struct {
      USHORT FunctionIndex; // offset: 0x8 (8)
      USHORT ContextValue;  // offset: 0xa (10)
    };
    ULONG InterceptorValue; // offset: 0x8 (8)
  };
  USHORT UnusedBytesLength;     // offset: 0xc (12)
  UCHAR EntryOffset;            // offset: 0xe (14)
  UCHAR ExtendedBlockSignature; // offset: 0xf (15)
};

// 0x4 (4) bytes
struct _HEAP_DESCRIPTOR_KEY {
  union {
    ULONG Key; // offset: 0x0 (0)
    struct {
      ULONG EncodedCommittedPageCount : 16; // offset: 0x0 (0)
      ULONG LargePageCost : 8;              // offset: 0x0 (0)
      ULONG UnitCount : 8;                  // offset: 0x0 (0)
    };
  };
};

// 0x4 (4) bytes
struct _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS {
  union {
    struct {
      USHORT BlockSize;        // offset: 0x0 (0)
      USHORT FirstBlockOffset; // offset: 0x2 (2)
    };
    ULONG EncodedData; // offset: 0x0 (0)
  };
};

// 0x4 (4) bytes
struct _RTL_HP_VS_CONFIG {
  struct {
    ULONG PageAlignLargeAllocs : 1; // offset: 0x0 (0)
    ULONG FullDecommit : 1;         // offset: 0x0 (0)
    ULONG EnableDelayFree : 1;      // offset: 0x0 (0)
  } Flags;                          // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _RTL_HP_SUB_ALLOCATOR_CONFIGS {
  struct _RTL_HP_LFH_CONFIG LfhConfigs; // offset: 0x0 (0)
  struct _RTL_HP_VS_CONFIG VsConfigs;   // offset: 0x4 (4)
};

// 0x20 (32) bytes
struct VACB_LEVEL_ALLOCATION_LIST {
  struct _LIST_ENTRY VacbLevelList; // offset: 0x0 (0)
  VOID *VacbLevelWithBcbListHeads;  // offset: 0x10 (16)
  ULONG VacbLevelsAllocated;        // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _CC_ASYNC_READ_CONTEXT {
  UCHAR (*CompletionRoutine)(VOID *arg1); // offset: 0x0 (0)
  VOID *Context;                          // offset: 0x8 (8)
  struct _MDL *Mdl;                       // offset: 0x10 (16)
  CHAR RequestorMode;                     // offset: 0x18 (24)
  ULONG NestingLevel;                     // offset: 0x1c (28)
};

// 0x194 (404) bytes
struct _ASYNC_READ_THREAD_STATS {
  ULONG CurrentLoad[101]; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _VACB_ARRAY_HEADER {
  ULONG VacbArrayIndex;     // offset: 0x0 (0)
  ULONG MappingCount;       // offset: 0x4 (4)
  ULONG HighestMappedIndex; // offset: 0x8 (8)
  ULONG Reserved;           // offset: 0xc (12)
};

// 0x8 (8) bytes
struct _WRITE_BEHIND_THROUGHPUT {
  ULONG PagesYetToWrite; // offset: 0x0 (0)
  ULONG Throughput;      // offset: 0x4 (4)
};

// 0x18 (24) bytes
struct _SHARED_CACHE_MAP_LIST_CURSOR {
  struct _LIST_ENTRY SharedCacheMapLinks; // offset: 0x0 (0)
  ULONG Flags;                            // offset: 0x10 (16)
};

// 0x4 (4) bytes
struct _PRIVATE_CACHE_MAP_FLAGS {
  ULONG DontUse : 16;           // offset: 0x0 (0)
  ULONG ReadAheadActive : 1;    // offset: 0x0 (0)
  ULONG ReadAheadEnabled : 1;   // offset: 0x0 (0)
  ULONG PagePriority : 3;       // offset: 0x0 (0)
  ULONG PipelineReadAheads : 1; // offset: 0x0 (0)
  ULONG Available : 10;         // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _POP_FX_DEVICE_STATUS {
  LONG Value;                             // offset: 0x0 (0)
  ULONG SystemTransition : 1;             // offset: 0x0 (0)
  ULONG PepD0Notify : 1;                  // offset: 0x0 (0)
  ULONG IdleTimerOn : 1;                  // offset: 0x0 (0)
  ULONG IgnoreIdleTimeout : 1;            // offset: 0x0 (0)
  ULONG IrpInUse : 1;                     // offset: 0x0 (0)
  ULONG IrpPending : 1;                   // offset: 0x0 (0)
  ULONG DPNRDeviceNotified : 1;           // offset: 0x0 (0)
  ULONG DPNRReceivedFromPep : 1;          // offset: 0x0 (0)
  ULONG IrpFirstPendingIndex : 1;         // offset: 0x0 (0)
  ULONG IrpLastPendingIndex : 1;          // offset: 0x0 (0)
  ULONG SIrpBlocked : 1;                  // offset: 0x0 (0)
  ULONG BlockFastResume : 1;              // offset: 0x0 (0)
  ULONG DirectedPoweredDown : 1;          // offset: 0x0 (0)
  ULONG DirectedTransitionInProgress : 1; // offset: 0x0 (0)
  ULONG Reserved : 18;                    // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _POP_FX_PERF_FLAGS {
  LONG Value;                    // offset: 0x0 (0)
  ULONG Progress : 3;            // offset: 0x0 (0)
  ULONG Reserved : 24;           // offset: 0x0 (0)
  ULONG Synchronicity : 2;       // offset: 0x0 (0)
  ULONG RequestPepCompleted : 1; // offset: 0x0 (0)
  ULONG RequestSucceeded : 1;    // offset: 0x0 (0)
  ULONG NestedCallback : 1;      // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _POP_FX_COMPONENT_FLAGS {
  struct {
    LONG Value;  // offset: 0x0 (0)
    LONG Value2; // offset: 0x4 (4)
  };
  ULONG RefCount : 30; // offset: 0x0 (0)
  ULONG Idling : 1;    // offset: 0x0 (0)
  struct {
    ULONG Active : 1;               // offset: 0x0 (0)
    ULONG CriticalIdleOverride : 1; // offset: 0x4 (4)
    ULONG ResidentOverride : 1;     // offset: 0x4 (4)
  };
  ULONG Reserved : 30; // offset: 0x4 (4)
};

// 0x10 (16) bytes
union _CPU_INFO {
  ULONG AsUINT32[4]; // offset: 0x0 (0)
  struct {
    ULONG Eax; // offset: 0x0 (0)
    ULONG Ebx; // offset: 0x4 (4)
  };
  struct {
    ULONG Ecx; // offset: 0x8 (8)
  };
  ULONG Edx; // offset: 0xc (12)
};

// 0x4 (4) bytes
union _PEP_ACPI_RESOURCE_FLAGS {
  ULONG AsULong;            // offset: 0x0 (0)
  ULONG Shared : 1;         // offset: 0x0 (0)
  ULONG Wake : 1;           // offset: 0x0 (0)
  ULONG ResourceUsage : 1;  // offset: 0x0 (0)
  ULONG SlaveMode : 1;      // offset: 0x0 (0)
  ULONG AddressingMode : 1; // offset: 0x0 (0)
  ULONG SharedMode : 1;     // offset: 0x0 (0)
  ULONG Reserved : 26;      // offset: 0x0 (0)
};

// 0x28 (40) bytes
struct _PEP_ACPI_SPB_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;          // offset: 0x0 (0)
  union _PEP_ACPI_RESOURCE_FLAGS Flags;       // offset: 0x4 (4)
  USHORT TypeSpecificFlags;                   // offset: 0x8 (8)
  UCHAR ResourceSourceIndex;                  // offset: 0xa (10)
  struct _UNICODE_STRING *ResourceSourceName; // offset: 0x10 (16)
  CHAR *VendorData;                           // offset: 0x18 (24)
  USHORT VendorDataLength;                    // offset: 0x20 (32)
};

// 0x48 (72) bytes
struct _PEP_ACPI_GPIO_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;                   // offset: 0x0 (0)
  union _PEP_ACPI_RESOURCE_FLAGS Flags;                // offset: 0x4 (4)
  enum _KINTERRUPT_MODE InterruptType;                 // offset: 0x8 (8)
  enum _KINTERRUPT_POLARITY InterruptPolarity;         // offset: 0xc (12)
  enum _GPIO_PIN_CONFIG_TYPE PinConfig;                // offset: 0x10 (16)
  enum _GPIO_PIN_IORESTRICTION_TYPE IoRestrictionType; // offset: 0x14 (20)
  USHORT DriveStrength;                                // offset: 0x18 (24)
  USHORT DebounceTimeout;                              // offset: 0x1a (26)
  WCHAR *PinTable;                                     // offset: 0x20 (32)
  USHORT PinCount;                                     // offset: 0x28 (40)
  UCHAR ResourceSourceIndex;                           // offset: 0x2a (42)
  struct _UNICODE_STRING *ResourceSourceName;          // offset: 0x30 (48)
  UCHAR *VendorData;                                   // offset: 0x38 (56)
  USHORT VendorDataLength;                             // offset: 0x40 (64)
};

// 0x38 (56) bytes
struct _PEP_ACPI_SPB_UART_RESOURCE {
  struct _PEP_ACPI_SPB_RESOURCE SpbCommon; // offset: 0x0 (0)
  ULONG BaudRate;                          // offset: 0x28 (40)
  USHORT RxBufferSize;                     // offset: 0x2c (44)
  USHORT TxBufferSize;                     // offset: 0x2e (46)
  UCHAR Parity;                            // offset: 0x30 (48)
  UCHAR LinesInUse;                        // offset: 0x31 (49)
};

// 0x38 (56) bytes
struct _PEP_ACPI_SPB_SPI_RESOURCE {
  struct _PEP_ACPI_SPB_RESOURCE SpbCommon; // offset: 0x0 (0)
  ULONG ConnectionSpeed;                   // offset: 0x28 (40)
  UCHAR DataBitLength;                     // offset: 0x2c (44)
  UCHAR Phase;                             // offset: 0x2d (45)
  UCHAR Polarity;                          // offset: 0x2e (46)
  USHORT DeviceSelection;                  // offset: 0x30 (48)
};

// 0x30 (48) bytes
struct _PEP_ACPI_SPB_I2C_RESOURCE {
  struct _PEP_ACPI_SPB_RESOURCE SpbCommon; // offset: 0x0 (0)
  ULONG ConnectionSpeed;                   // offset: 0x28 (40)
  USHORT SlaveAddress;                     // offset: 0x2c (44)
};

// 0x24 (36) bytes
struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
  ULONG Size;                // offset: 0x0 (0)
  ULONG Action;              // offset: 0x4 (4)
  ULONG Flags;               // offset: 0x8 (8)
  ULONG OperationStatus;     // offset: 0xc (12)
  ULONG ExtendedError;       // offset: 0x10 (16)
  ULONG TargetDetailedError; // offset: 0x14 (20)
  ULONG ReservedStatus;      // offset: 0x18 (24)
  ULONG OutputBlockOffset;   // offset: 0x1c (28)
  ULONG OutputBlockLength;   // offset: 0x20 (32)
};

// 0x1c (28) bytes
struct _DEVICE_DSM_DEFINITION {
  ULONG Action;                  // offset: 0x0 (0)
  UCHAR SingleRange;             // offset: 0x4 (4)
  ULONG ParameterBlockAlignment; // offset: 0x8 (8)
  ULONG ParameterBlockLength;    // offset: 0xc (12)
  UCHAR HasOutput;               // offset: 0x10 (16)
  ULONG OutputBlockAlignment;    // offset: 0x14 (20)
  ULONG OutputBlockLength;       // offset: 0x18 (24)
};

// 0x1c (28) bytes
struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
  ULONG Size;                 // offset: 0x0 (0)
  ULONG Action;               // offset: 0x4 (4)
  ULONG Flags;                // offset: 0x8 (8)
  ULONG ParameterBlockOffset; // offset: 0xc (12)
  ULONG ParameterBlockLength; // offset: 0x10 (16)
  ULONG DataSetRangesOffset;  // offset: 0x14 (20)
  ULONG DataSetRangesLength;  // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _DBGKD_GET_VERSION32 {
  USHORT MajorVersion;            // offset: 0x0 (0)
  USHORT MinorVersion;            // offset: 0x2 (2)
  USHORT ProtocolVersion;         // offset: 0x4 (4)
  USHORT Flags;                   // offset: 0x6 (6)
  ULONG KernBase;                 // offset: 0x8 (8)
  ULONG PsLoadedModuleList;       // offset: 0xc (12)
  USHORT MachineType;             // offset: 0x10 (16)
  USHORT ThCallbackStack;         // offset: 0x12 (18)
  USHORT NextCallback;            // offset: 0x14 (20)
  USHORT FramePointer;            // offset: 0x16 (22)
  ULONG KiCallUserMode;           // offset: 0x18 (24)
  ULONG KeUserCallbackDispatcher; // offset: 0x1c (28)
  ULONG BreakpointWithStatus;     // offset: 0x20 (32)
  ULONG DebuggerDataList;         // offset: 0x24 (36)
};

// 0xc (12) bytes
struct _PPC_DBGKD_CONTROL_SET {
  ULONG Continue;           // offset: 0x0 (0)
  ULONG CurrentSymbolStart; // offset: 0x4 (4)
  ULONG CurrentSymbolEnd;   // offset: 0x8 (8)
};

// 0xc (12) bytes
struct _ARMCE_DBGKD_CONTROL_SET {
  ULONG Continue;           // offset: 0x0 (0)
  ULONG CurrentSymbolStart; // offset: 0x4 (4)
  ULONG CurrentSymbolEnd;   // offset: 0x8 (8)
};

// 0xc (12) bytes
struct _ARM_DBGKD_CONTROL_SET {
  ULONG Continue;           // offset: 0x0 (0)
  ULONG CurrentSymbolStart; // offset: 0x4 (4)
  ULONG CurrentSymbolEnd;   // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _X86_DBGKD_CONTROL_SET {
  ULONG TraceFlag;          // offset: 0x0 (0)
  ULONG Dr7;                // offset: 0x4 (4)
  ULONG CurrentSymbolStart; // offset: 0x8 (8)
  ULONG CurrentSymbolEnd;   // offset: 0xc (12)
};

// 0xc (12) bytes
struct _DBGKD_CONTEXT_EX {
  ULONG Offset;      // offset: 0x0 (0)
  ULONG ByteCount;   // offset: 0x4 (4)
  ULONG BytesCopied; // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct _DBGKD_SWITCH_PARTITION {
  ULONG Partition; // offset: 0x0 (0)
};

// 0x14 (20) bytes
struct _DBGKD_GET_SET_BUS_DATA {
  ULONG BusDataType; // offset: 0x0 (0)
  ULONG BusNumber;   // offset: 0x4 (4)
  ULONG SlotNumber;  // offset: 0x8 (8)
  ULONG Offset;      // offset: 0xc (12)
  ULONG Length;      // offset: 0x10 (16)
};

// 0xc (12) bytes
struct _DBGKD_READ_WRITE_MSR {
  ULONG Msr;           // offset: 0x0 (0)
  ULONG DataValueLow;  // offset: 0x4 (4)
  ULONG DataValueHigh; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _DBGKD_BREAKPOINTEX {
  ULONG BreakPointCount; // offset: 0x0 (0)
  LONG ContinueStatus;   // offset: 0x4 (4)
};

// 0x4 (4) bytes
struct _DBGKD_QUERY_SPECIAL_CALLS {
  ULONG NumberOfSpecialCalls; // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _DBGKD_RESTORE_BREAKPOINT {
  ULONG BreakPointHandle; // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _DBGKD_SET_CONTEXT {
  ULONG ContextFlags; // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _DBGKD_GET_CONTEXT {
  ULONG Unused; // offset: 0x0 (0)
};

// 0x1c (28) bytes
struct _DBGKD_GET_INTERNAL_BREAKPOINT32 {
  ULONG BreakpointAddress; // offset: 0x0 (0)
  ULONG Flags;             // offset: 0x4 (4)
  ULONG Calls;             // offset: 0x8 (8)
  ULONG MaxCallsPerPeriod; // offset: 0xc (12)
  ULONG MinInstructions;   // offset: 0x10 (16)
  ULONG MaxInstructions;   // offset: 0x14 (20)
  ULONG TotalInstructions; // offset: 0x18 (24)
};

// 0x8 (8) bytes
struct _DBGKD_SET_INTERNAL_BREAKPOINT32 {
  ULONG BreakpointAddress; // offset: 0x0 (0)
  ULONG Flags;             // offset: 0x4 (4)
};

// 0x4 (4) bytes
struct _DBGKD_SET_SPECIAL_CALL32 {
  ULONG SpecialCall; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _DBGKD_READ_WRITE_IO_EXTENDED32 {
  ULONG DataSize;      // offset: 0x0 (0)
  ULONG InterfaceType; // offset: 0x4 (4)
  ULONG BusNumber;     // offset: 0x8 (8)
  ULONG AddressSpace;  // offset: 0xc (12)
  ULONG IoAddress;     // offset: 0x10 (16)
  ULONG DataValue;     // offset: 0x14 (20)
};

// 0xc (12) bytes
struct _DBGKD_READ_WRITE_IO32 {
  ULONG DataSize;  // offset: 0x0 (0)
  ULONG IoAddress; // offset: 0x4 (4)
  ULONG DataValue; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _DBGKD_WRITE_BREAKPOINT32 {
  ULONG BreakPointAddress; // offset: 0x0 (0)
  ULONG BreakPointHandle;  // offset: 0x4 (4)
};

// 0xc (12) bytes
struct _DBGKD_WRITE_MEMORY32 {
  ULONG TargetBaseAddress;  // offset: 0x0 (0)
  ULONG TransferCount;      // offset: 0x4 (4)
  ULONG ActualBytesWritten; // offset: 0x8 (8)
};

// 0xc (12) bytes
struct _DBGKD_READ_MEMORY32 {
  ULONG TargetBaseAddress; // offset: 0x0 (0)
  ULONG TransferCount;     // offset: 0x4 (4)
  ULONG ActualBytesRead;   // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _DBGKD_LOAD_SYMBOLS32 {
  ULONG PathNameLength; // offset: 0x0 (0)
  ULONG BaseOfDll;      // offset: 0x4 (4)
  ULONG ProcessId;      // offset: 0x8 (8)
  ULONG CheckSum;       // offset: 0xc (12)
  ULONG SizeOfImage;    // offset: 0x10 (16)
  UCHAR UnloadSymbols;  // offset: 0x14 (20)
};

// 0x8c (140) bytes
struct _X86_KTRAP_FRAME_BLUE {
  ULONG DbgEbp;               // offset: 0x0 (0)
  ULONG DbgEip;               // offset: 0x4 (4)
  ULONG DbgArgMark;           // offset: 0x8 (8)
  USHORT TempSegCs;           // offset: 0xc (12)
  UCHAR Logging;              // offset: 0xe (14)
  UCHAR FrameType;            // offset: 0xf (15)
  ULONG TempEsp;              // offset: 0x10 (16)
  ULONG Dr0;                  // offset: 0x14 (20)
  ULONG Dr1;                  // offset: 0x18 (24)
  ULONG Dr2;                  // offset: 0x1c (28)
  ULONG Dr3;                  // offset: 0x20 (32)
  ULONG Dr6;                  // offset: 0x24 (36)
  ULONG Dr7;                  // offset: 0x28 (40)
  ULONG SegGs;                // offset: 0x2c (44)
  ULONG SegEs;                // offset: 0x30 (48)
  ULONG SegDs;                // offset: 0x34 (52)
  ULONG Edx;                  // offset: 0x38 (56)
  ULONG Ecx;                  // offset: 0x3c (60)
  ULONG Eax;                  // offset: 0x40 (64)
  UCHAR PreviousPreviousMode; // offset: 0x44 (68)
  UCHAR EntropyQueueDpc;      // offset: 0x45 (69)
  UCHAR Reserved[2];          // offset: 0x46 (70)
  ULONG MxCsr;                // offset: 0x48 (72)
  ULONG ExceptionList;        // offset: 0x4c (76)
  ULONG SegFs;                // offset: 0x50 (80)
  ULONG Edi;                  // offset: 0x54 (84)
  ULONG Esi;                  // offset: 0x58 (88)
  ULONG Ebx;                  // offset: 0x5c (92)
  ULONG Ebp;                  // offset: 0x60 (96)
  ULONG ErrCode;              // offset: 0x64 (100)
  ULONG Eip;                  // offset: 0x68 (104)
  ULONG SegCs;                // offset: 0x6c (108)
  ULONG EFlags;               // offset: 0x70 (112)
  ULONG HardwareEsp;          // offset: 0x74 (116)
  ULONG HardwareSegSs;        // offset: 0x78 (120)
  ULONG V86Es;                // offset: 0x7c (124)
  ULONG V86Ds;                // offset: 0x80 (128)
  ULONG V86Fs;                // offset: 0x84 (132)
  ULONG V86Gs;                // offset: 0x88 (136)
};

// 0x8c (140) bytes
struct _X86_KTRAP_FRAME {
  ULONG DbgEbp;               // offset: 0x0 (0)
  ULONG DbgEip;               // offset: 0x4 (4)
  ULONG DbgArgMark;           // offset: 0x8 (8)
  ULONG DbgArgPointer;        // offset: 0xc (12)
  ULONG TempSegCs;            // offset: 0x10 (16)
  ULONG TempEsp;              // offset: 0x14 (20)
  ULONG Dr0;                  // offset: 0x18 (24)
  ULONG Dr1;                  // offset: 0x1c (28)
  ULONG Dr2;                  // offset: 0x20 (32)
  ULONG Dr3;                  // offset: 0x24 (36)
  ULONG Dr6;                  // offset: 0x28 (40)
  ULONG Dr7;                  // offset: 0x2c (44)
  ULONG SegGs;                // offset: 0x30 (48)
  ULONG SegEs;                // offset: 0x34 (52)
  ULONG SegDs;                // offset: 0x38 (56)
  ULONG Edx;                  // offset: 0x3c (60)
  ULONG Ecx;                  // offset: 0x40 (64)
  ULONG Eax;                  // offset: 0x44 (68)
  UCHAR PreviousPreviousMode; // offset: 0x48 (72)
  UCHAR EntropyQueueDpc;      // offset: 0x49 (73)
  UCHAR Reserved[2];          // offset: 0x4a (74)
  ULONG ExceptionList;        // offset: 0x4c (76)
  ULONG SegFs;                // offset: 0x50 (80)
  ULONG Edi;                  // offset: 0x54 (84)
  ULONG Esi;                  // offset: 0x58 (88)
  ULONG Ebx;                  // offset: 0x5c (92)
  ULONG Ebp;                  // offset: 0x60 (96)
  ULONG ErrCode;              // offset: 0x64 (100)
  ULONG Eip;                  // offset: 0x68 (104)
  ULONG SegCs;                // offset: 0x6c (108)
  ULONG EFlags;               // offset: 0x70 (112)
  ULONG HardwareEsp;          // offset: 0x74 (116)
  ULONG HardwareSegSs;        // offset: 0x78 (120)
  ULONG V86Es;                // offset: 0x7c (124)
  ULONG V86Ds;                // offset: 0x80 (128)
  ULONG V86Fs;                // offset: 0x84 (132)
  ULONG V86Gs;                // offset: 0x88 (136)
};

// 0x10 (16) bytes
struct _PNP_ASSIGN_RESOURCES_CONTEXT {
  ULONG IncludeFailedDevices;           // offset: 0x0 (0)
  ULONG DeviceCount;                    // offset: 0x4 (4)
  struct _DEVICE_OBJECT *DeviceList[1]; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _STRING32 {
  USHORT Length;        // offset: 0x0 (0)
  USHORT MaximumLength; // offset: 0x2 (2)
  ULONG Buffer;         // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _CLIENT_ID32 {
  ULONG UniqueProcess; // offset: 0x0 (0)
  ULONG UniqueThread;  // offset: 0x4 (4)
};

// 0x18 (24) bytes
struct _PORT_MESSAGE32 {
  union {
    struct {
      SHORT DataLength;  // offset: 0x0 (0)
      SHORT TotalLength; // offset: 0x2 (2)
    } s1;                // offset: 0x0 (0)
    ULONG Length;        // offset: 0x0 (0)

  } u1; // offset: 0x0 (0)
  union {
    struct {
      SHORT Type;           // offset: 0x0 (0)
      SHORT DataInfoOffset; // offset: 0x2 (2)
    } s2;                   // offset: 0x4 (4)
    ULONG ZeroInit;         // offset: 0x4 (4)

  } u2; // offset: 0x4 (4)
  union {
    struct _CLIENT_ID32 ClientId; // offset: 0x8 (8)
    double DoNotUseThisField;     // offset: 0x8 (8)
  };
  ULONG MessageId; // offset: 0x10 (16)
  union {
    ULONG ClientViewSize; // offset: 0x14 (20)
    ULONG CallbackId;     // offset: 0x14 (20)
  };
};

// 0x1c (28) bytes
struct _NT_TIB32 {
  ULONG ExceptionList; // offset: 0x0 (0)
  ULONG StackBase;     // offset: 0x4 (4)
  ULONG StackLimit;    // offset: 0x8 (8)
  ULONG SubSystemTib;  // offset: 0xc (12)
  union {
    ULONG FiberData; // offset: 0x10 (16)
    ULONG Version;   // offset: 0x10 (16)
  };
  ULONG ArbitraryUserPointer; // offset: 0x14 (20)
  ULONG Self;                 // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct _THERMAL_ZONE_COUNTERS {
  ULONG Temperature;              // offset: 0x0 (0)
  ULONG ThrottleLimit;            // offset: 0x4 (4)
  ULONG ThrottleReasons;          // offset: 0x8 (8)
  ULONG TemperatureHighPrecision; // offset: 0xc (12)
};

// 0xb8 (184) bytes
struct _SYNCH_COUNTERS {
  ULONG SpinLockAcquireCount;                           // offset: 0x0 (0)
  ULONG SpinLockContentionCount;                        // offset: 0x4 (4)
  ULONG SpinLockSpinCount;                              // offset: 0x8 (8)
  ULONG IpiSendRequestBroadcastCount;                   // offset: 0xc (12)
  ULONG IpiSendRequestRoutineCount;                     // offset: 0x10 (16)
  ULONG IpiSendSoftwareInterruptCount;                  // offset: 0x14 (20)
  ULONG ExInitializeResourceCount;                      // offset: 0x18 (24)
  ULONG ExReInitializeResourceCount;                    // offset: 0x1c (28)
  ULONG ExDeleteResourceCount;                          // offset: 0x20 (32)
  ULONG ExecutiveResourceAcquiresCount;                 // offset: 0x24 (36)
  ULONG ExecutiveResourceContentionsCount;              // offset: 0x28 (40)
  ULONG ExecutiveResourceReleaseExclusiveCount;         // offset: 0x2c (44)
  ULONG ExecutiveResourceReleaseSharedCount;            // offset: 0x30 (48)
  ULONG ExecutiveResourceConvertsCount;                 // offset: 0x34 (52)
  ULONG ExAcqResExclusiveAttempts;                      // offset: 0x38 (56)
  ULONG ExAcqResExclusiveAcquiresExclusive;             // offset: 0x3c (60)
  ULONG ExAcqResExclusiveAcquiresExclusiveRecursive;    // offset: 0x40 (64)
  ULONG ExAcqResExclusiveWaits;                         // offset: 0x44 (68)
  ULONG ExAcqResExclusiveNotAcquires;                   // offset: 0x48 (72)
  ULONG ExAcqResSharedAttempts;                         // offset: 0x4c (76)
  ULONG ExAcqResSharedAcquiresExclusive;                // offset: 0x50 (80)
  ULONG ExAcqResSharedAcquiresShared;                   // offset: 0x54 (84)
  ULONG ExAcqResSharedAcquiresSharedRecursive;          // offset: 0x58 (88)
  ULONG ExAcqResSharedWaits;                            // offset: 0x5c (92)
  ULONG ExAcqResSharedNotAcquires;                      // offset: 0x60 (96)
  ULONG ExAcqResSharedStarveExclusiveAttempts;          // offset: 0x64 (100)
  ULONG ExAcqResSharedStarveExclusiveAcquiresExclusive; // offset: 0x68 (104)
  ULONG ExAcqResSharedStarveExclusiveAcquiresShared;    // offset: 0x6c (108)
  ULONG ExAcqResSharedStarveExclusiveAcquiresSharedRecursive; // offset: 0x70
                                                              // (112)
  ULONG ExAcqResSharedStarveExclusiveWaits;              // offset: 0x74 (116)
  ULONG ExAcqResSharedStarveExclusiveNotAcquires;        // offset: 0x78 (120)
  ULONG ExAcqResSharedWaitForExclusiveAttempts;          // offset: 0x7c (124)
  ULONG ExAcqResSharedWaitForExclusiveAcquiresExclusive; // offset: 0x80 (128)
  ULONG ExAcqResSharedWaitForExclusiveAcquiresShared;    // offset: 0x84 (132)
  ULONG ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive; // offset: 0x88
                                                               // (136)
  ULONG ExAcqResSharedWaitForExclusiveWaits;           // offset: 0x8c (140)
  ULONG ExAcqResSharedWaitForExclusiveNotAcquires;     // offset: 0x90 (144)
  ULONG ExSetResOwnerPointerExclusive;                 // offset: 0x94 (148)
  ULONG ExSetResOwnerPointerSharedNew;                 // offset: 0x98 (152)
  ULONG ExSetResOwnerPointerSharedOld;                 // offset: 0x9c (156)
  ULONG ExTryToAcqExclusiveAttempts;                   // offset: 0xa0 (160)
  ULONG ExTryToAcqExclusiveAcquires;                   // offset: 0xa4 (164)
  ULONG ExBoostExclusiveOwner;                         // offset: 0xa8 (168)
  ULONG ExBoostSharedOwners;                           // offset: 0xac (172)
  ULONG ExEtwSynchTrackingNotificationsCount;          // offset: 0xb0 (176)
  ULONG ExEtwSynchTrackingNotificationsAccountedCount; // offset: 0xb4 (180)
};

// 0x10 (16) bytes
struct _PCW_DATA {
  const VOID *Data; // offset: 0x0 (0)
  ULONG Size;       // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _CM_PARSE_DEBUG_INFO {
  struct _CM_KEY_CONTROL_BLOCK *SymlinkCachedKcb; // offset: 0x0 (0)
  struct _CM_KEY_CONTROL_BLOCK *StartingKcb;      // offset: 0x8 (8)
  struct _CM_KEY_CONTROL_BLOCK *KcbCacheResult;   // offset: 0x10 (16)
  struct _CM_KEY_CONTROL_BLOCK *WalkResult;       // offset: 0x18 (24)
  struct _CM_KEY_CONTROL_BLOCK *DeepestKcbFound;  // offset: 0x20 (32)
  UCHAR KcbCacheLevels;                           // offset: 0x28 (40)
  UCHAR WalkLevels;                               // offset: 0x29 (41)
  UCHAR FailureCount;                             // offset: 0x2a (42)
  struct {
    LONG Status;      // offset: 0x0 (0)
    ULONG Point;      // offset: 0x4 (4)
  } FailurePoints[4]; // offset: 0x2c (44)
};

// 0x8 (8) bytes
struct _HCELL {
  LONG Size; // offset: 0x0 (0)
  union {
    struct {
      union {
        ULONG UserData; // offset: 0x4 (4)
        ULONG Next;     // offset: 0x4 (4)

      } u;     // offset: 0x0 (0)
    } NewCell; // offset: 0x4 (4)

  } u; // offset: 0x4 (4)
};

// 0x48 (72) bytes
struct _CM_DIRTY_VECTOR_LOG_ENTRY {
  struct _ETHREAD *Thread;                   // offset: 0x0 (0)
  enum _CM_DIRTY_VECTOR_OPERATION Operation; // offset: 0x8 (8)
  union {
    struct {
      ULONG Start;                // offset: 0x0 (0)
      ULONG Length;               // offset: 0x4 (4)
    } DirtyVectorModifiedContext; // offset: 0xc (12)
    struct {
      ULONG RangeCount;        // offset: 0x0 (0)
      ULONG SetBitCount;       // offset: 0x4 (4)
    } DirtyDataCaptureContext; // offset: 0xc (12)
    struct {
      ULONG Context1; // offset: 0x0 (0)
      ULONG Context2; // offset: 0x4 (4)
    } Raw;            // offset: 0xc (12)

  } Data;         // offset: 0xc (12)
  VOID *Stack[6]; // offset: 0x18 (24)
};

// 0x8 (8) bytes
struct _KTRANSACTION_HISTORY {
  enum<unnamed - enum - KTMOH_CommitTransaction_Result>
      RecordType; // offset: 0x0 (0)
  ULONG Payload;  // offset: 0x4 (4)
};

// 0x68 (104) bytes
struct _RTL_AVL_TABLE {
  struct _RTL_BALANCED_LINKS BalancedRoot; // offset: 0x0 (0)
  VOID *OrderedPointer;                    // offset: 0x20 (32)
  ULONG WhichOrderedElement;               // offset: 0x28 (40)
  ULONG NumberGenericTableElements;        // offset: 0x2c (44)
  ULONG DepthOfTree;                       // offset: 0x30 (48)
  struct _RTL_BALANCED_LINKS *RestartKey;  // offset: 0x38 (56)
  ULONG DeleteCount;                       // offset: 0x40 (64)
  enum _RTL_GENERIC_COMPARE_RESULTS (*CompareRoutine)(
      struct _RTL_AVL_TABLE *arg1, VOID *arg2, VOID *arg3); // offset: 0x48 (72)
  VOID *(*AllocateRoutine)(struct _RTL_AVL_TABLE *arg1,
                           ULONG arg2); // offset: 0x50 (80)
  VOID (*FreeRoutine)
  (struct _RTL_AVL_TABLE *arg1, VOID *arg2); // offset: 0x58 (88)
  VOID *TableContext;                        // offset: 0x60 (96)
};

// 0xa8 (168) bytes
struct _KTMOBJECT_NAMESPACE {
  struct _RTL_AVL_TABLE Table; // offset: 0x0 (0)
  struct _KMUTANT Mutex;       // offset: 0x68 (104)
  USHORT LinksOffset;          // offset: 0xa0 (160)
  USHORT GuidOffset;           // offset: 0xa2 (162)
  UCHAR Expired;               // offset: 0xa4 (164)
};

// 0x10 (16) bytes
struct _CM_UOW_SET_VALUE_KEY_DATA {
  ULONG PreparedCell; // offset: 0x0 (0)
  ULONG OldValueCell; // offset: 0x4 (4)
  USHORT NameLength;  // offset: 0x8 (8)
  ULONG DataSize;     // offset: 0xc (12)
};

// 0x4 (4) bytes
struct _CM_UOW_SET_SD_DATA {
  ULONG SecurityCell; // offset: 0x0 (0)
};

// 0x488 (1160) bytes
struct _CM_DIRTY_VECTOR_LOG {
  volatile ULONG Next;                       // offset: 0x0 (0)
  ULONG Size;                                // offset: 0x4 (4)
  struct _CM_DIRTY_VECTOR_LOG_ENTRY Log[16]; // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _CM_WORKITEM {
  struct _LIST_ENTRY ListEntry;      // offset: 0x0 (0)
  ULONG Private;                     // offset: 0x10 (16)
  VOID (*WorkerRoutine)(VOID *arg1); // offset: 0x18 (24)
  VOID *Parameter;                   // offset: 0x20 (32)
};

// 0x8 (8) bytes
struct _KENLISTMENT_HISTORY {
  ULONG Notification;               // offset: 0x0 (0)
  enum _KENLISTMENT_STATE NewState; // offset: 0x4 (4)
};

// 0x4 (4) bytes
struct _CM_COMPONENT_HASH {
  ULONG Hash; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _CM_INDEX {
  ULONG Cell; // offset: 0x0 (0)
  union {
    struct _CM_FAST_LEAF_HINT NameHint; // offset: 0x4 (4)
    struct _CM_COMPONENT_HASH HashKey;  // offset: 0x4 (4)
  };
};

// 0x18 (24) bytes
struct _CM_NAME_HASH {
  struct _CM_COMPONENT_HASH ConvKey; // offset: 0x0 (0)
  struct _CM_NAME_HASH *NextHash;    // offset: 0x8 (8)
  USHORT NameLength;                 // offset: 0x10 (16)
  WCHAR Name[1];                     // offset: 0x12 (18)
};

// 0x20 (32) bytes
struct _CM_NAME_CONTROL_BLOCK {
  ULONG Compressed : 1; // offset: 0x0 (0)
  ULONG RefCount : 31;  // offset: 0x0 (0)
  union {
    struct _CM_NAME_HASH NameHash; // offset: 0x8 (8)
    struct {
      struct _CM_COMPONENT_HASH ConvKey; // offset: 0x8 (8)
      struct _CM_KEY_HASH *NextHash;     // offset: 0x10 (16)
      USHORT NameLength;                 // offset: 0x18 (24)
      WCHAR Name[1];                     // offset: 0x1a (26)
    };
  };
};

// 0x10 (16) bytes
struct _CM_INTENT_LOCK {
  ULONG OwnerCount;                // offset: 0x0 (0)
  struct _CM_KCB_UOW **OwnerTable; // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct _CM_PATH_HASH {
  ULONG Hash; // offset: 0x0 (0)
};

// 0x14 (20) bytes
struct _SECURITY_DESCRIPTOR_RELATIVE {
  UCHAR Revision; // offset: 0x0 (0)
  UCHAR Sbz1;     // offset: 0x1 (1)
  USHORT Control; // offset: 0x2 (2)
  ULONG Owner;    // offset: 0x4 (4)
  ULONG Group;    // offset: 0x8 (8)
  ULONG Sacl;     // offset: 0xc (12)
  ULONG Dacl;     // offset: 0x10 (16)
};

// 0x38 (56) bytes
struct _CM_KEY_SECURITY_CACHE {
  ULONG Cell;                                      // offset: 0x0 (0)
  ULONG ConvKey;                                   // offset: 0x4 (4)
  struct _LIST_ENTRY List;                         // offset: 0x8 (8)
  ULONG DescriptorLength;                          // offset: 0x18 (24)
  ULONG RealRefCount;                              // offset: 0x1c (28)
  struct _SECURITY_DESCRIPTOR_RELATIVE Descriptor; // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _CM_KEY_SECURITY_CACHE_ENTRY {
  ULONG Cell;                                    // offset: 0x0 (0)
  struct _CM_KEY_SECURITY_CACHE *CachedSecurity; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _CHILD_LIST {
  ULONG Count; // offset: 0x0 (0)
  ULONG List;  // offset: 0x4 (4)
};

// 0xc (12) bytes
struct _CM_UOW_SET_VALUE_LIST_DATA {
  ULONG RefCount;               // offset: 0x0 (0)
  struct _CHILD_LIST ValueList; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _CM_BIG_DATA {
  USHORT Signature; // offset: 0x0 (0)
  USHORT Count;     // offset: 0x2 (2)
  ULONG List;       // offset: 0x4 (4)
};

// 0x28 (40) bytes
struct _CM_KEY_SECURITY {
  USHORT Signature;                                // offset: 0x0 (0)
  USHORT Reserved;                                 // offset: 0x2 (2)
  ULONG Flink;                                     // offset: 0x4 (4)
  ULONG Blink;                                     // offset: 0x8 (8)
  ULONG ReferenceCount;                            // offset: 0xc (12)
  ULONG DescriptorLength;                          // offset: 0x10 (16)
  struct _SECURITY_DESCRIPTOR_RELATIVE Descriptor; // offset: 0x14 (20)
};

// 0x18 (24) bytes
struct _CM_KEY_VALUE {
  USHORT Signature;  // offset: 0x0 (0)
  USHORT NameLength; // offset: 0x2 (2)
  ULONG DataLength;  // offset: 0x4 (4)
  ULONG Data;        // offset: 0x8 (8)
  ULONG Type;        // offset: 0xc (12)
  USHORT Flags;      // offset: 0x10 (16)
  USHORT Spare;      // offset: 0x12 (18)
  WCHAR Name[1];     // offset: 0x14 (20)
};

// 0x18 (24) bytes
struct CMP_OFFSET_ARRAY {
  ULONG FileOffset; // offset: 0x0 (0)
  VOID *DataBuffer; // offset: 0x8 (8)
  ULONG DataLength; // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _HV_GET_CELL_CONTEXT {
  ULONG Cell;                            // offset: 0x0 (0)
  struct _HV_GET_BIN_CONTEXT BinContext; // offset: 0x4 (4)
};

// 0x38 (56) bytes
struct _HVP_VIEW_MAP {
  VOID *SectionReference;                   // offset: 0x0 (0)
  LONGLONG StorageEndFileOffset;            // offset: 0x8 (8)
  LONGLONG SectionEndFileOffset;            // offset: 0x10 (16)
  struct _CMSI_PROCESS_TUPLE *ProcessTuple; // offset: 0x18 (24)
  ULONG Flags;                              // offset: 0x20 (32)
  struct _RTL_RB_TREE ViewTree;             // offset: 0x28 (40)
};

// 0x4 (4) bytes
struct _MI_SUBSECTION_ENTRY1 {
  ULONG CrossPartitionReferences : 30; // offset: 0x0 (0)
  ULONG SubsectionMappedLarge : 2;     // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MI_STORE_INPAGE_COMPLETE_FLAGS {
  union {
    ULONG EntireFlags; // offset: 0x0 (0)
    struct {
      ULONG StoreFault : 1;          // offset: 0x0 (0)
      ULONG LowResourceFailure : 1;  // offset: 0x0 (0)
      ULONG Spare : 14;              // offset: 0x0 (0)
      ULONG RemainingPageCount : 16; // offset: 0x0 (0)
    };
  };
};

// 0x4 (4) bytes
struct _MMINPAGE_FLAGS {
  ULONG GetExtents : 1;              // offset: 0x0 (0)
  ULONG PrefetchSystemVmType : 2;    // offset: 0x0 (0)
  ULONG VaPrefetchReadBlock : 1;     // offset: 0x0 (0)
  ULONG CollidedFlowThrough : 1;     // offset: 0x0 (0)
  ULONG ForceCollisions : 1;         // offset: 0x0 (0)
  ULONG InPageExpanded : 1;          // offset: 0x0 (0)
  ULONG IssuedAtLowPriority : 1;     // offset: 0x0 (0)
  ULONG FaultFromStore : 1;          // offset: 0x0 (0)
  ULONG PagePriority : 3;            // offset: 0x0 (0)
  ULONG ClusteredPagePriority : 3;   // offset: 0x0 (0)
  ULONG MakeClusterValid : 1;        // offset: 0x0 (0)
  ULONG PerformRelocations : 1;      // offset: 0x0 (0)
  ULONG ZeroLastPage : 1;            // offset: 0x0 (0)
  ULONG UserFault : 1;               // offset: 0x0 (0)
  ULONG StandbyProtectionNeeded : 1; // offset: 0x0 (0)
  ULONG PteChanged : 1;              // offset: 0x0 (0)
  ULONG PageFileFault : 1;           // offset: 0x0 (0)
  ULONG PageFilePageHashActive : 1;  // offset: 0x0 (0)
  ULONG CoalescedIo : 1;             // offset: 0x0 (0)
  ULONG VmLockNotNeeded : 1;         // offset: 0x0 (0)
  ULONG Spare0 : 1;                  // offset: 0x0 (0)
  ULONG Spare1 : 6;                  // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MMSECURE_FLAGS {
  ULONG ReadOnly : 1;            // offset: 0x0 (0)
  ULONG ReadWrite : 1;           // offset: 0x0 (0)
  ULONG SecNoChange : 1;         // offset: 0x0 (0)
  ULONG NoDelete : 1;            // offset: 0x0 (0)
  ULONG RequiresPteReversal : 1; // offset: 0x0 (0)
  ULONG ExclusiveSecure : 1;     // offset: 0x0 (0)
  ULONG UserModeOnly : 1;        // offset: 0x0 (0)
  ULONG NoInherit : 1;           // offset: 0x0 (0)
  ULONG CheckVad : 1;            // offset: 0x0 (0)
  ULONG Spare : 3;               // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _MMADDRESS_LIST {
  union {
    struct _MMSECURE_FLAGS Flags; // offset: 0x0 (0)
    ULONG FlagsLong;              // offset: 0x0 (0)
    VOID *StartVa;                // offset: 0x0 (0)

  } u1;        // offset: 0x0 (0)
  VOID *EndVa; // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct _MMVAD_FLAGS1 {
  ULONG CommitCharge : 31; // offset: 0x0 (0)
  ULONG MemCommit : 1;     // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MM_SHARED_VAD_FLAGS {
  ULONG Lock : 1;                     // offset: 0x0 (0)
  ULONG LockContended : 1;            // offset: 0x0 (0)
  ULONG DeleteInProgress : 1;         // offset: 0x0 (0)
  ULONG NoChange : 1;                 // offset: 0x0 (0)
  ULONG VadType : 3;                  // offset: 0x0 (0)
  ULONG Protection : 5;               // offset: 0x0 (0)
  ULONG PreferredNode : 6;            // offset: 0x0 (0)
  ULONG PageSize : 2;                 // offset: 0x0 (0)
  ULONG PrivateMemoryAlwaysClear : 1; // offset: 0x0 (0)
  ULONG PrivateFixup : 1;             // offset: 0x0 (0)
  ULONG HotPatchAllowed : 1;          // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MM_GRAPHICS_VAD_FLAGS {
  ULONG Lock : 1;                   // offset: 0x0 (0)
  ULONG LockContended : 1;          // offset: 0x0 (0)
  ULONG DeleteInProgress : 1;       // offset: 0x0 (0)
  ULONG NoChange : 1;               // offset: 0x0 (0)
  ULONG VadType : 3;                // offset: 0x0 (0)
  ULONG Protection : 5;             // offset: 0x0 (0)
  ULONG PreferredNode : 6;          // offset: 0x0 (0)
  ULONG PageSize : 2;               // offset: 0x0 (0)
  ULONG PrivateMemoryAlwaysSet : 1; // offset: 0x0 (0)
  ULONG WriteWatch : 1;             // offset: 0x0 (0)
  ULONG FixedLargePageSize : 1;     // offset: 0x0 (0)
  ULONG ZeroFillPagesOptional : 1;  // offset: 0x0 (0)
  ULONG GraphicsAlwaysSet : 1;      // offset: 0x0 (0)
  ULONG GraphicsUseCoherentBus : 1; // offset: 0x0 (0)
  ULONG GraphicsNoCache : 1;        // offset: 0x0 (0)
  ULONG GraphicsPageProtection : 3; // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MM_PRIVATE_VAD_FLAGS {
  ULONG Lock : 1;                         // offset: 0x0 (0)
  ULONG LockContended : 1;                // offset: 0x0 (0)
  ULONG DeleteInProgress : 1;             // offset: 0x0 (0)
  ULONG NoChange : 1;                     // offset: 0x0 (0)
  ULONG VadType : 3;                      // offset: 0x0 (0)
  ULONG Protection : 5;                   // offset: 0x0 (0)
  ULONG PreferredNode : 6;                // offset: 0x0 (0)
  ULONG PageSize : 2;                     // offset: 0x0 (0)
  ULONG PrivateMemoryAlwaysSet : 1;       // offset: 0x0 (0)
  ULONG WriteWatch : 1;                   // offset: 0x0 (0)
  ULONG FixedLargePageSize : 1;           // offset: 0x0 (0)
  ULONG ZeroFillPagesOptional : 1;        // offset: 0x0 (0)
  ULONG Graphics : 1;                     // offset: 0x0 (0)
  ULONG Enclave : 1;                      // offset: 0x0 (0)
  ULONG ShadowStack : 1;                  // offset: 0x0 (0)
  ULONG PhysicalMemoryPfnsReferenced : 1; // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MMVAD_FLAGS {
  ULONG Lock : 1;             // offset: 0x0 (0)
  ULONG LockContended : 1;    // offset: 0x0 (0)
  ULONG DeleteInProgress : 1; // offset: 0x0 (0)
  ULONG NoChange : 1;         // offset: 0x0 (0)
  ULONG VadType : 3;          // offset: 0x0 (0)
  ULONG Protection : 5;       // offset: 0x0 (0)
  ULONG PreferredNode : 6;    // offset: 0x0 (0)
  ULONG PageSize : 2;         // offset: 0x0 (0)
  ULONG PrivateMemory : 1;    // offset: 0x0 (0)
};

// 0x4 (4) bytes
struct _MODWRITER_FLAGS {
  ULONG KeepForever : 1;        // offset: 0x0 (0)
  ULONG Networked : 1;          // offset: 0x0 (0)
  ULONG IoPriority : 3;         // offset: 0x0 (0)
  ULONG ModifiedStoreWrite : 1; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _MI_EXTRA_IMAGE_INFORMATION {
  ULONG SizeOfHeaders;                                 // offset: 0x0 (0)
  ULONG SizeOfImage;                                   // offset: 0x4 (4)
  ULONG TimeDateStamp;                                 // offset: 0x8 (8)
  ULONG ImageCetShadowStacksReady : 1;                 // offset: 0xc (12)
  ULONG ImageCetShadowStacksStrictMode : 1;            // offset: 0xc (12)
  ULONG ImageCetSetContextIpValidationRelaxedMode : 1; // offset: 0xc (12)
  ULONG ImageCetDynamicApisAllowInProc : 1;            // offset: 0xc (12)
  ULONG ImageCetDowngradeReserved1 : 1;                // offset: 0xc (12)
  ULONG ImageCetDowngradeReserved2 : 1;                // offset: 0xc (12)
  ULONG Spare : 26;                                    // offset: 0xc (12)
};

// 0x28 (40) bytes
struct _MI_CONTROL_AREA_WAIT_BLOCK {
  struct _MI_CONTROL_AREA_WAIT_BLOCK *Next; // offset: 0x0 (0)
  ULONG WaitReason;                         // offset: 0x8 (8)
  ULONG WaitResponse;                       // offset: 0xc (12)
  struct _KGATE Gate;                       // offset: 0x10 (16)
};

// 0x4 (4) bytes
struct _MMSECTION_FLAGS {
  ULONG BeingDeleted : 1;                     // offset: 0x0 (0)
  ULONG BeingCreated : 1;                     // offset: 0x0 (0)
  ULONG BeingPurged : 1;                      // offset: 0x0 (0)
  ULONG NoModifiedWriting : 1;                // offset: 0x0 (0)
  ULONG FailAllIo : 1;                        // offset: 0x0 (0)
  ULONG Image : 1;                            // offset: 0x0 (0)
  ULONG Based : 1;                            // offset: 0x0 (0)
  ULONG File : 1;                             // offset: 0x0 (0)
  ULONG AttemptingDelete : 1;                 // offset: 0x0 (0)
  ULONG PrefetchCreated : 1;                  // offset: 0x0 (0)
  ULONG PhysicalMemory : 1;                   // offset: 0x0 (0)
  ULONG ImageControlAreaOnRemovableMedia : 1; // offset: 0x0 (0)
  ULONG Reserve : 1;                          // offset: 0x0 (0)
  ULONG Commit : 1;                           // offset: 0x0 (0)
  ULONG NoChange : 1;                         // offset: 0x0 (0)
  ULONG WasPurged : 1;                        // offset: 0x0 (0)
  ULONG UserReference : 1;                    // offset: 0x0 (0)
  ULONG GlobalMemory : 1;                     // offset: 0x0 (0)
  ULONG DeleteOnClose : 1;                    // offset: 0x0 (0)
  ULONG FilePointerNull : 1;                  // offset: 0x0 (0)
  ULONG PreferredNode : 6;                    // offset: 0x0 (0)
  ULONG GlobalOnlyPerSession : 1;             // offset: 0x0 (0)
  ULONG UserWritable : 1;                     // offset: 0x0 (0)
  ULONG SystemVaAllocated : 1;                // offset: 0x0 (0)
  ULONG PreferredFsCompressionBoundary : 1;   // offset: 0x0 (0)
  ULONG UsingFileExtents : 1;                 // offset: 0x0 (0)
  ULONG PageSize64K : 1;                      // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _MI_AVAILABLE_PAGE_WAIT_STATES {
  struct _KEVENT Event; // offset: 0x0 (0)
  ULONG EventSets;      // offset: 0x18 (24)
};

// 0x4 (4) bytes
struct _MI_PARTITION_FLAGS {
  ULONG BeingDeleted : 1;                 // offset: 0x0 (0)
  ULONG PageListsInitialized : 1;         // offset: 0x0 (0)
  ULONG StoreReservedPagesCharged : 1;    // offset: 0x0 (0)
  ULONG UseProtectedSlabAllocators : 1;   // offset: 0x0 (0)
  ULONG UseUnprotectedSlabAllocators : 1; // offset: 0x0 (0)
  ULONG PureHoldingPartition : 1;         // offset: 0x0 (0)
  ULONG ZeroPagesOptional : 1;            // offset: 0x0 (0)
  ULONG BackgroundZeroingDisabled : 1;    // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MI_CACHED_PTE {
  union {
    struct {
      ULONG GlobalTimeStamp; // offset: 0x0 (0)
      ULONG PteIndex;        // offset: 0x4 (4)
    };
    LONGLONG Long; // offset: 0x0 (0)
  };
};

// 0x4 (4) bytes
struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
  union {
    struct {
      ULONG Expanded : 1;      // offset: 0x0 (0)
      ULONG Transitioning : 1; // offset: 0x0 (0)
      ULONG Pageable : 1;      // offset: 0x0 (0)
    };
    ULONG Value; // offset: 0x0 (0)
  };
};

// 0x10 (16) bytes
struct _GUID {
  ULONG Data1;    // offset: 0x0 (0)
  USHORT Data2;   // offset: 0x4 (4)
  USHORT Data3;   // offset: 0x6 (6)
  UCHAR Data4[8]; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _RTL_HASH_TABLE {
  ULONG EntryCount;                   // offset: 0x0 (0)
  ULONG MaskBitCount : 5;             // offset: 0x4 (4)
  ULONG BucketCount : 27;             // offset: 0x4 (4)
  struct _SINGLE_LIST_ENTRY *Buckets; // offset: 0x8 (8)
};

// 0x4 (4) bytes
union _MM_PAGE_ACCESS_INFO_FLAGS {
  struct {
    ULONG FilePointerIndex : 9; // offset: 0x0 (0)
    ULONG HardFault : 1;        // offset: 0x0 (0)
    ULONG Image : 1;            // offset: 0x0 (0)
    ULONG Spare0 : 1;           // offset: 0x0 (0)
  } File;                       // offset: 0x0 (0)
  struct {
    ULONG FilePointerIndex : 9; // offset: 0x0 (0)
    ULONG HardFault : 1;        // offset: 0x0 (0)
    ULONG Spare1 : 2;           // offset: 0x0 (0)
  } Private;                    // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _IO_PRIORITY_INFO {
  ULONG Size;                        // offset: 0x0 (0)
  ULONG ThreadPriority;              // offset: 0x4 (4)
  ULONG PagePriority;                // offset: 0x8 (8)
  enum _IO_PRIORITY_HINT IoPriority; // offset: 0xc (12)
};

// 0x8 (8) bytes
struct _OBJECT_HANDLE_INFORMATION {
  ULONG HandleAttributes; // offset: 0x0 (0)
  ULONG GrantedAccess;    // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct _GENERIC_MAPPING {
  ULONG GenericRead;    // offset: 0x0 (0)
  ULONG GenericWrite;   // offset: 0x4 (4)
  ULONG GenericExecute; // offset: 0x8 (8)
  ULONG GenericAll;     // offset: 0xc (12)
};

// 0x4 (4) bytes
struct _PS_TRUSTLET_ATTRIBUTE_TYPE {
  union {
    struct {
      UCHAR Version;                                          // offset: 0x0 (0)
      UCHAR DataCount;                                        // offset: 0x1 (1)
      UCHAR SemanticType;                                     // offset: 0x2 (2)
      union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS AccessRights; // offset: 0x3 (3)
    };
    ULONG AttributeType; // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
struct _PS_TRUSTLET_ATTRIBUTE_HEADER {
  struct _PS_TRUSTLET_ATTRIBUTE_TYPE AttributeType; // offset: 0x0 (0)
  ULONG InstanceNumber : 8;                         // offset: 0x4 (4)
  ULONG Reserved : 24;                              // offset: 0x4 (4)
};

// 0x4 (4) bytes
struct _SINGLE_LIST_ENTRY32 {
  ULONG Next; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _IMAGE_DATA_DIRECTORY {
  ULONG VirtualAddress; // offset: 0x0 (0)
  ULONG Size;           // offset: 0x4 (4)
};

// 0x14 (20) bytes
struct _IMAGE_FILE_HEADER {
  USHORT Machine;              // offset: 0x0 (0)
  USHORT NumberOfSections;     // offset: 0x2 (2)
  ULONG TimeDateStamp;         // offset: 0x4 (4)
  ULONG PointerToSymbolTable;  // offset: 0x8 (8)
  ULONG NumberOfSymbols;       // offset: 0xc (12)
  USHORT SizeOfOptionalHeader; // offset: 0x10 (16)
  USHORT Characteristics;      // offset: 0x12 (18)
};

// 0x18 (24) bytes
struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
  struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME *Previous; // offset: 0x0 (0)
  struct _ACTIVATION_CONTEXT *ActivationContext;        // offset: 0x8 (8)
  ULONG Flags;                                          // offset: 0x10 (16)
};

// 0x18 (24) bytes
struct _TEB_ACTIVE_FRAME {
  ULONG Flags;                               // offset: 0x0 (0)
  struct _TEB_ACTIVE_FRAME *Previous;        // offset: 0x8 (8)
  struct _TEB_ACTIVE_FRAME_CONTEXT *Context; // offset: 0x10 (16)
};

// 0x4e0 (1248) bytes
struct _GDI_TEB_BATCH32 {
  ULONG Offset : 31;             // offset: 0x0 (0)
  ULONG HasRenderingCommand : 1; // offset: 0x0 (0)
  ULONG HDC;                     // offset: 0x4 (4)
  ULONG Buffer[310];             // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _ACTIVATION_CONTEXT_STACK {
  struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME *ActiveFrame; // offset: 0x0 (0)
  struct _LIST_ENTRY FrameListCache;                       // offset: 0x8 (8)
  ULONG Flags;                                             // offset: 0x18 (24)
  ULONG NextCookieSequenceNumber;                          // offset: 0x1c (28)
  ULONG StackId;                                           // offset: 0x20 (32)
};

// 0x48 (72) bytes
struct _TP_CALLBACK_ENVIRON_V3 {
  ULONG Version;                          // offset: 0x0 (0)
  struct _TP_POOL *Pool;                  // offset: 0x8 (8)
  struct _TP_CLEANUP_GROUP *CleanupGroup; // offset: 0x10 (16)
  VOID (*CleanupGroupCancelCallback)
  (VOID *arg1, VOID *arg2);                      // offset: 0x18 (24)
  VOID *RaceDll;                                 // offset: 0x20 (32)
  struct _ACTIVATION_CONTEXT *ActivationContext; // offset: 0x28 (40)
  VOID (*FinalizationCallback)
  (struct _TP_CALLBACK_INSTANCE *arg1, VOID *arg2); // offset: 0x30 (48)
  union {
    ULONG Flags; // offset: 0x38 (56)
    struct {
      ULONG LongFunction : 1; // offset: 0x0 (0)
      ULONG Persistent : 1;   // offset: 0x0 (0)
      ULONG Private : 30;     // offset: 0x0 (0)
    } s;                      // offset: 0x38 (56)

  } u;                                         // offset: 0x38 (56)
  enum _TP_CALLBACK_PRIORITY CallbackPriority; // offset: 0x3c (60)
  ULONG Size;                                  // offset: 0x40 (64)
};

// 0x8 (8) bytes
struct _XSTATE_FEATURE {
  ULONG Offset; // offset: 0x0 (0)
  ULONG Size;   // offset: 0x4 (4)
};

// 0xc (12) bytes
struct _KSYSTEM_TIME {
  ULONG LowPart;  // offset: 0x0 (0)
  LONG High1Time; // offset: 0x4 (4)
  LONG High2Time; // offset: 0x8 (8)
};

// 0xa (10) bytes
struct _ISA_VECTOR {
  UCHAR Type;                        // offset: 0x0 (0)
  UCHAR Length;                      // offset: 0x1 (1)
  UCHAR Bus;                         // offset: 0x2 (2)
  UCHAR Source;                      // offset: 0x3 (3)
  ULONG GlobalSystemInterruptVector; // offset: 0x4 (4)
  USHORT Flags;                      // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _IO_NMISOURCE {
  UCHAR Type;                        // offset: 0x0 (0)
  UCHAR Length;                      // offset: 0x1 (1)
  USHORT Flags;                      // offset: 0x2 (2)
  ULONG GlobalSystemInterruptVector; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _HAL_HV_DMA_DOMAIN_INFO {
  ULONG DomainId; // offset: 0x0 (0)
  UCHAR IsStage1; // offset: 0x4 (4)
};

// 0xc (12) bytes
struct _HAL_HV_SVM_DEVICE_CAPABILITIES {
  ULONG SvmSupported : 1;     // offset: 0x0 (0)
  ULONG PciExecute : 1;       // offset: 0x0 (0)
  ULONG NoExecute : 1;        // offset: 0x0 (0)
  ULONG Reserved : 28;        // offset: 0x0 (0)
  ULONG OverflowPossible : 1; // offset: 0x0 (0)
  ULONG PasidCount;           // offset: 0x4 (4)
  ULONG IommuIndex;           // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _HAL_HV_SVM_SYSTEM_CAPABILITIES {
  ULONG SvmSupported : 1;        // offset: 0x0 (0)
  ULONG GpaAlwaysValid : 1;      // offset: 0x0 (0)
  ULONG MaxPasidSpaceCount;      // offset: 0x4 (4)
  ULONG MaxPasidSpacePasidCount; // offset: 0x8 (8)
  ULONG MaxPrqSize;              // offset: 0xc (12)
  ULONG IommuCount;              // offset: 0x10 (16)
  ULONG MinIommuPasidCount;      // offset: 0x14 (20)
};

// 0xc (12) bytes
struct _IOAPIC {
  UCHAR Type;             // offset: 0x0 (0)
  UCHAR Length;           // offset: 0x1 (1)
  UCHAR IOAPICID;         // offset: 0x2 (2)
  UCHAR Reserved;         // offset: 0x3 (3)
  ULONG IOAPICAddress;    // offset: 0x4 (4)
  ULONG SystemVectorBase; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _DMA_TRANSFER_INFO_V2 {
  ULONG MapRegisterCount;          // offset: 0x0 (0)
  ULONG ScatterGatherElementCount; // offset: 0x4 (4)
  ULONG ScatterGatherListSize;     // offset: 0x8 (8)
  ULONG LogicalPageCount;          // offset: 0xc (12)
};

// 0xc (12) bytes
struct _DMA_TRANSFER_INFO_V1 {
  ULONG MapRegisterCount;          // offset: 0x0 (0)
  ULONG ScatterGatherElementCount; // offset: 0x4 (4)
  ULONG ScatterGatherListSize;     // offset: 0x8 (8)
};

// 0x14 (20) bytes
struct _DMA_ADAPTER_INFO_V1 {
  ULONG ReadDmaCounterAvailable; // offset: 0x0 (0)
  ULONG ScatterGatherLimit;      // offset: 0x4 (4)
  ULONG DmaAddressWidth;         // offset: 0x8 (8)
  ULONG Flags;                   // offset: 0xc (12)
  ULONG MinimumTransferUnit;     // offset: 0x10 (16)
};

// 0x14 (20) bytes
struct _DMA_TRANSFER_INFO {
  ULONG Version; // offset: 0x0 (0)
  union {
    struct _DMA_TRANSFER_INFO_V1 V1; // offset: 0x4 (4)
    struct _DMA_TRANSFER_INFO_V2 V2; // offset: 0x4 (4)
  };
};

// 0x18 (24) bytes
struct _DMA_ADAPTER_INFO {
  ULONG Version;                  // offset: 0x0 (0)
  struct _DMA_ADAPTER_INFO_V1 V1; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _DMA_REQUEST_LINE_BINDING_DESCRIPTION {
  ULONG RequestLine;   // offset: 0x0 (0)
  ULONG ChannelNumber; // offset: 0x4 (4)
};

// 0x18 (24) bytes
struct _HALP_DMA_TRANSLATION_BUFFER {
  struct _HALP_DMA_TRANSLATION_BUFFER *Next;   // offset: 0x0 (0)
  ULONG EntryCount;                            // offset: 0x8 (8)
  struct _HALP_DMA_TRANSLATION_ENTRY *Entries; // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _HALP_DMA_TRANSLATION_BUFFER_POSITION {
  struct _HALP_DMA_TRANSLATION_BUFFER *Buffer; // offset: 0x0 (0)
  ULONG Offset;                                // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _PLATFORM_INTERRUPT {
  UCHAR Type;          // offset: 0x0 (0)
  UCHAR Length;        // offset: 0x1 (1)
  USHORT Flags;        // offset: 0x2 (2)
  UCHAR InterruptType; // offset: 0x4 (4)
  UCHAR APICID;        // offset: 0x5 (5)
  UCHAR ACPIEID;       // offset: 0x6 (6)
  UCHAR IOSAPICVector; // offset: 0x7 (7)
  ULONG GlobalVector;  // offset: 0x8 (8)
  ULONG Reserved;      // offset: 0xc (12)
};

// 0x8 (8) bytes
struct _PROCLOCALAPIC {
  UCHAR Type;            // offset: 0x0 (0)
  UCHAR Length;          // offset: 0x1 (1)
  UCHAR ACPIProcessorID; // offset: 0x2 (2)
  UCHAR APICID;          // offset: 0x3 (3)
  ULONG Flags;           // offset: 0x4 (4)
};

// 0x24 (36) bytes
struct _DESCRIPTION_HEADER {
  ULONG Signature;    // offset: 0x0 (0)
  ULONG Length;       // offset: 0x4 (4)
  UCHAR Revision;     // offset: 0x8 (8)
  UCHAR Checksum;     // offset: 0x9 (9)
  CHAR OEMID[6];      // offset: 0xa (10)
  CHAR OEMTableID[8]; // offset: 0x10 (16)
  ULONG OEMRevision;  // offset: 0x18 (24)
  CHAR CreatorID[4];  // offset: 0x1c (28)
  ULONG CreatorRev;   // offset: 0x20 (32)
};

// 0x58 (88) bytes
struct _KAPC {
  UCHAR Type;                      // offset: 0x0 (0)
  UCHAR SpareByte0;                // offset: 0x1 (1)
  UCHAR Size;                      // offset: 0x2 (2)
  UCHAR SpareByte1;                // offset: 0x3 (3)
  ULONG SpareLong0;                // offset: 0x4 (4)
  struct _KTHREAD *Thread;         // offset: 0x8 (8)
  struct _LIST_ENTRY ApcListEntry; // offset: 0x10 (16)
  VOID *Reserved[3];               // offset: 0x20 (32)
  VOID *NormalContext;             // offset: 0x38 (56)
  VOID *SystemArgument1;           // offset: 0x40 (64)
  VOID *SystemArgument2;           // offset: 0x48 (72)
  CHAR ApcStateIndex;              // offset: 0x50 (80)
  CHAR ApcMode;                    // offset: 0x51 (81)
  UCHAR Inserted;                  // offset: 0x52 (82)
};

// 0x11 (17) bytes
struct _PROCLOCALSAPIC {
  UCHAR Type;                     // offset: 0x0 (0)
  UCHAR Length;                   // offset: 0x1 (1)
  UCHAR ACPIProcessorID;          // offset: 0x2 (2)
  UCHAR APICID;                   // offset: 0x3 (3)
  UCHAR APICEID;                  // offset: 0x4 (4)
  UCHAR Reserved[3];              // offset: 0x5 (5)
  ULONG Flags;                    // offset: 0x8 (8)
  ULONG ACPIProcessorUIDInteger;  // offset: 0xc (12)
  CHAR ACPIProcessorUIDString[1]; // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _INTERRUPT_LINE {
  ULONG UnitId; // offset: 0x0 (0)
  LONG Line;    // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct _SECONDARY_INTERRUPT_LINE_STATE {
  enum _KINTERRUPT_POLARITY Polarity; // offset: 0x0 (0)
  enum _KINTERRUPT_MODE Mode;         // offset: 0x4 (4)
  ULONG Vector;                       // offset: 0x8 (8)
  UCHAR Unmasked;                     // offset: 0xc (12)
};

// 0x4 (4) bytes
union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
  ULONG Primary : 1;              // offset: 0x0 (0)
  ULONG ContainmentWarning : 1;   // offset: 0x0 (0)
  ULONG Reset : 1;                // offset: 0x0 (0)
  ULONG ThresholdExceeded : 1;    // offset: 0x0 (0)
  ULONG ResourceNotAvailable : 1; // offset: 0x0 (0)
  ULONG LatentError : 1;          // offset: 0x0 (0)
  ULONG Propagated : 1;           // offset: 0x0 (0)
  ULONG Reserved : 25;            // offset: 0x0 (0)
  ULONG AsULONG;                  // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _WHEA_ERROR_RECORD_HEADER_FLAGS {
  ULONG Recovered : 1;     // offset: 0x0 (0)
  ULONG PreviousError : 1; // offset: 0x0 (0)
  ULONG Simulated : 1;     // offset: 0x0 (0)
  ULONG DeviceDriver : 1;  // offset: 0x0 (0)
  ULONG CriticalEvent : 1; // offset: 0x0 (0)
  ULONG PersistPfn : 1;    // offset: 0x0 (0)
  ULONG Reserved : 26;     // offset: 0x0 (0)
  ULONG AsULONG;           // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
  ULONG PlatformId : 1;  // offset: 0x0 (0)
  ULONG Timestamp : 1;   // offset: 0x0 (0)
  ULONG PartitionId : 1; // offset: 0x0 (0)
  ULONG Reserved : 29;   // offset: 0x0 (0)
  ULONG AsULONG;         // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _WHEA_ERROR_PACKET_FLAGS {
  ULONG PreviousError : 1;               // offset: 0x0 (0)
  ULONG CriticalEvent : 1;               // offset: 0x0 (0)
  ULONG HypervisorError : 1;             // offset: 0x0 (0)
  ULONG Simulated : 1;                   // offset: 0x0 (0)
  ULONG PlatformPfaControl : 1;          // offset: 0x0 (0)
  ULONG PlatformDirectedOffline : 1;     // offset: 0x0 (0)
  ULONG AddressTranslationRequired : 1;  // offset: 0x0 (0)
  ULONG AddressTranslationCompleted : 1; // offset: 0x0 (0)
  ULONG Reserved2 : 24;                  // offset: 0x0 (0)
  ULONG AsULONG;                         // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _WHEA_EVENT_LOG_ENTRY_FLAGS {
  ULONG Reserved1 : 1;      // offset: 0x0 (0)
  ULONG LogInternalEtw : 1; // offset: 0x0 (0)
  ULONG LogBlackbox : 1;    // offset: 0x0 (0)
  ULONG LogSel : 1;         // offset: 0x0 (0)
  ULONG RawSel : 1;         // offset: 0x0 (0)
  ULONG NoFormat : 1;       // offset: 0x0 (0)
  ULONG Driver : 1;         // offset: 0x0 (0)
  ULONG Reserved2 : 25;     // offset: 0x0 (0)
  ULONG AsULONG;            // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _WHEA_EVENT_LOG_ENTRY_HEADER {
  ULONG Signature;                         // offset: 0x0 (0)
  ULONG Version;                           // offset: 0x4 (4)
  ULONG Length;                            // offset: 0x8 (8)
  enum _WHEA_EVENT_LOG_ENTRY_TYPE Type;    // offset: 0xc (12)
  ULONG OwnerTag;                          // offset: 0x10 (16)
  enum _WHEA_EVENT_LOG_ENTRY_ID Id;        // offset: 0x14 (20)
  union _WHEA_EVENT_LOG_ENTRY_FLAGS Flags; // offset: 0x18 (24)
  ULONG PayloadLength;                     // offset: 0x1c (28)
};

// 0x20 (32) bytes
struct _WHEA_EVENT_LOG_ENTRY {
  struct _WHEA_EVENT_LOG_ENTRY_HEADER Header; // offset: 0x0 (0)
};

// 0x1c (28) bytes
struct _WHEA_NOTIFICATION_DESCRIPTOR {
  UCHAR Type;                           // offset: 0x0 (0)
  UCHAR Length;                         // offset: 0x1 (1)
  union _WHEA_NOTIFICATION_FLAGS Flags; // offset: 0x2 (2)
  union {
    struct {
      ULONG PollInterval; // offset: 0x0 (0)
    } Polled;             // offset: 0x4 (4)
    struct {
      ULONG PollInterval;             // offset: 0x0 (0)
      ULONG Vector;                   // offset: 0x4 (4)
      ULONG SwitchToPollingThreshold; // offset: 0x8 (8)
      ULONG SwitchToPollingWindow;    // offset: 0xc (12)
      ULONG ErrorThreshold;           // offset: 0x10 (16)
      ULONG ErrorThresholdWindow;     // offset: 0x14 (20)
    } Interrupt;                      // offset: 0x4 (4)
    struct {
      ULONG PollInterval;             // offset: 0x0 (0)
      ULONG Vector;                   // offset: 0x4 (4)
      ULONG SwitchToPollingThreshold; // offset: 0x8 (8)
      ULONG SwitchToPollingWindow;    // offset: 0xc (12)
      ULONG ErrorThreshold;           // offset: 0x10 (16)
      ULONG ErrorThresholdWindow;     // offset: 0x14 (20)
    } LocalInterrupt;                 // offset: 0x4 (4)
    struct {
      ULONG PollInterval;             // offset: 0x0 (0)
      ULONG Vector;                   // offset: 0x4 (4)
      ULONG SwitchToPollingThreshold; // offset: 0x8 (8)
      ULONG SwitchToPollingWindow;    // offset: 0xc (12)
      ULONG ErrorThreshold;           // offset: 0x10 (16)
      ULONG ErrorThresholdWindow;     // offset: 0x14 (20)
    } Sci;                            // offset: 0x4 (4)
    struct {
      ULONG PollInterval;             // offset: 0x0 (0)
      ULONG Vector;                   // offset: 0x4 (4)
      ULONG SwitchToPollingThreshold; // offset: 0x8 (8)
      ULONG SwitchToPollingWindow;    // offset: 0xc (12)
      ULONG ErrorThreshold;           // offset: 0x10 (16)
      ULONG ErrorThresholdWindow;     // offset: 0x14 (20)
    } Nmi;                            // offset: 0x4 (4)
    struct {
      ULONG PollInterval;             // offset: 0x0 (0)
      ULONG Vector;                   // offset: 0x4 (4)
      ULONG SwitchToPollingThreshold; // offset: 0x8 (8)
      ULONG SwitchToPollingWindow;    // offset: 0xc (12)
      ULONG ErrorThreshold;           // offset: 0x10 (16)
      ULONG ErrorThresholdWindow;     // offset: 0x14 (20)
    } Sea;                            // offset: 0x4 (4)
    struct {
      ULONG PollInterval;             // offset: 0x0 (0)
      ULONG Vector;                   // offset: 0x4 (4)
      ULONG SwitchToPollingThreshold; // offset: 0x8 (8)
      ULONG SwitchToPollingWindow;    // offset: 0xc (12)
      ULONG ErrorThreshold;           // offset: 0x10 (16)
      ULONG ErrorThresholdWindow;     // offset: 0x14 (20)
    } Sei;                            // offset: 0x4 (4)
    struct {
      ULONG PollInterval;             // offset: 0x0 (0)
      ULONG Vector;                   // offset: 0x4 (4)
      ULONG SwitchToPollingThreshold; // offset: 0x8 (8)
      ULONG SwitchToPollingWindow;    // offset: 0xc (12)
      ULONG ErrorThreshold;           // offset: 0x10 (16)
      ULONG ErrorThresholdWindow;     // offset: 0x14 (20)
    } Gsiv;                           // offset: 0x4 (4)

  } u; // offset: 0x4 (4)
};

// 0x4 (4) bytes
struct _WHEA_PCI_SLOT_NUMBER {
  union {
    struct {
      ULONG DeviceNumber : 5;   // offset: 0x0 (0)
      ULONG FunctionNumber : 3; // offset: 0x0 (0)
      ULONG Reserved : 24;      // offset: 0x0 (0)
    } bits;                     // offset: 0x0 (0)
    ULONG AsULONG;              // offset: 0x0 (0)

  } u; // offset: 0x0 (0)
};

// 0x4 (4) bytes
union _XPF_MCE_FLAGS {
  ULONG MCG_CapabilityRW : 1;    // offset: 0x0 (0)
  ULONG MCG_GlobalControlRW : 1; // offset: 0x0 (0)
  ULONG Reserved : 30;           // offset: 0x0 (0)
  ULONG AsULONG;                 // offset: 0x0 (0)
};

// 0x2c (44) bytes
struct _WHEA_AER_BRIDGE_DESCRIPTOR {
  USHORT Type;                              // offset: 0x0 (0)
  UCHAR Enabled;                            // offset: 0x2 (2)
  UCHAR Reserved;                           // offset: 0x3 (3)
  ULONG BusNumber;                          // offset: 0x4 (4)
  struct _WHEA_PCI_SLOT_NUMBER Slot;        // offset: 0x8 (8)
  USHORT DeviceControl;                     // offset: 0xc (12)
  union _AER_BRIDGE_DESCRIPTOR_FLAGS Flags; // offset: 0xe (14)
  ULONG UncorrectableErrorMask;             // offset: 0x10 (16)
  ULONG UncorrectableErrorSeverity;         // offset: 0x14 (20)
  ULONG CorrectableErrorMask;               // offset: 0x18 (24)
  ULONG AdvancedCapsAndControl;             // offset: 0x1c (28)
  ULONG SecondaryUncorrectableErrorMask;    // offset: 0x20 (32)
  ULONG SecondaryUncorrectableErrorSev;     // offset: 0x24 (36)
  ULONG SecondaryCapsAndControl;            // offset: 0x28 (40)
};

// 0x20 (32) bytes
struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
  USHORT Type;                                // offset: 0x0 (0)
  UCHAR Enabled;                              // offset: 0x2 (2)
  UCHAR Reserved;                             // offset: 0x3 (3)
  ULONG BusNumber;                            // offset: 0x4 (4)
  struct _WHEA_PCI_SLOT_NUMBER Slot;          // offset: 0x8 (8)
  USHORT DeviceControl;                       // offset: 0xc (12)
  union _AER_ENDPOINT_DESCRIPTOR_FLAGS Flags; // offset: 0xe (14)
  ULONG UncorrectableErrorMask;               // offset: 0x10 (16)
  ULONG UncorrectableErrorSeverity;           // offset: 0x14 (20)
  ULONG CorrectableErrorMask;                 // offset: 0x18 (24)
  ULONG AdvancedCapsAndControl;               // offset: 0x1c (28)
};

// 0x24 (36) bytes
struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
  USHORT Type;                                // offset: 0x0 (0)
  UCHAR Enabled;                              // offset: 0x2 (2)
  UCHAR Reserved;                             // offset: 0x3 (3)
  ULONG BusNumber;                            // offset: 0x4 (4)
  struct _WHEA_PCI_SLOT_NUMBER Slot;          // offset: 0x8 (8)
  USHORT DeviceControl;                       // offset: 0xc (12)
  union _AER_ROOTPORT_DESCRIPTOR_FLAGS Flags; // offset: 0xe (14)
  ULONG UncorrectableErrorMask;               // offset: 0x10 (16)
  ULONG UncorrectableErrorSeverity;           // offset: 0x14 (20)
  ULONG CorrectableErrorMask;                 // offset: 0x18 (24)
  ULONG AdvancedCapsAndControl;               // offset: 0x1c (28)
  ULONG RootErrorCommand;                     // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _ECP_LIST {
  ULONG Signature;            // offset: 0x0 (0)
  ULONG Flags;                // offset: 0x4 (4)
  struct _LIST_ENTRY EcpList; // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _IO_DRIVER_CREATE_CONTEXT {
  SHORT Size;                                 // offset: 0x0 (0)
  struct _ECP_LIST *ExtraCreateParameter;     // offset: 0x8 (8)
  VOID *DeviceObjectHint;                     // offset: 0x10 (16)
  struct _TXN_PARAMETER_BLOCK *TxnParameters; // offset: 0x18 (24)
  struct _EJOB *SiloContext;                  // offset: 0x20 (32)
};

// 0x10 (16) bytes
union _KGDTENTRY64 {
  struct {
    USHORT LimitLow; // offset: 0x0 (0)
    USHORT BaseLow;  // offset: 0x2 (2)
  };
  struct {
    UCHAR BaseMiddle; // offset: 0x0 (0)
    UCHAR Flags1;     // offset: 0x1 (1)
    UCHAR Flags2;     // offset: 0x2 (2)
    UCHAR BaseHigh;   // offset: 0x3 (3)
  } Bytes;            // offset: 0x4 (4)
  struct {
    struct {
      ULONG BaseMiddle : 8;  // offset: 0x0 (0)
      ULONG Type : 5;        // offset: 0x0 (0)
      ULONG Dpl : 2;         // offset: 0x0 (0)
      ULONG Present : 1;     // offset: 0x0 (0)
      ULONG LimitHigh : 4;   // offset: 0x0 (0)
      ULONG System : 1;      // offset: 0x0 (0)
      ULONG LongMode : 1;    // offset: 0x0 (0)
      ULONG DefaultBig : 1;  // offset: 0x0 (0)
      ULONG Granularity : 1; // offset: 0x0 (0)
      ULONG BaseHigh : 8;    // offset: 0x0 (0)
    } Bits;                  // offset: 0x4 (4)
    ULONG BaseUpper;         // offset: 0x8 (8)
  };
  struct {
    ULONG MustBeZero; // offset: 0xc (12)
    LONGLONG DataLow; // offset: 0x0 (0)
  };
  LONGLONG DataHigh; // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _RTL_RETPOLINE_ROUTINES {
  ULONG UnwindDataOffset;    // offset: 0x0 (0)
  ULONG SwitchtableJump[16]; // offset: 0x4 (4)
  ULONG CfgIndirectRax;      // offset: 0x44 (68)
  ULONG NonCfgIndirectRax;   // offset: 0x48 (72)
  ULONG ImportR10;           // offset: 0x4c (76)
};

// 0x50 (80) bytes
struct _EXCEPTION_RECORD32 {
  LONG ExceptionCode;             // offset: 0x0 (0)
  ULONG ExceptionFlags;           // offset: 0x4 (4)
  ULONG ExceptionRecord;          // offset: 0x8 (8)
  ULONG ExceptionAddress;         // offset: 0xc (12)
  ULONG NumberParameters;         // offset: 0x10 (16)
  ULONG ExceptionInformation[15]; // offset: 0x14 (20)
};

// 0x54 (84) bytes
struct _DBGKM_EXCEPTION32 {
  struct _EXCEPTION_RECORD32 ExceptionRecord; // offset: 0x0 (0)
  ULONG FirstChance;                          // offset: 0x50 (80)
};

// 0x38 (56) bytes
struct _NT_TIB {
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // offset: 0x0 (0)
  VOID *StackBase;                                      // offset: 0x8 (8)
  VOID *StackLimit;                                     // offset: 0x10 (16)
  VOID *SubSystemTib;                                   // offset: 0x18 (24)
  union {
    VOID *FiberData; // offset: 0x20 (32)
    ULONG Version;   // offset: 0x20 (32)
  };
  VOID *ArbitraryUserPointer; // offset: 0x28 (40)
  struct _NT_TIB *Self;       // offset: 0x30 (48)
};

// 0x10 (16) bytes
struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
  ULONG Size;             // offset: 0x0 (0)
  const WCHAR *TriggerId; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _FS_FILTER_SECTION_SYNC_OUTPUT {
  ULONG StructureSize;        // offset: 0x0 (0)
  ULONG SizeReturned;         // offset: 0x4 (4)
  ULONG Flags;                // offset: 0x8 (8)
  ULONG DesiredReadAlignment; // offset: 0xc (12)
};

// 0x18 (24) bytes
struct _DEVICE_OBJECT_LIST_ENTRY {
  struct _DEVICE_OBJECT *DeviceObject;       // offset: 0x0 (0)
  enum _DEVICE_RELATION_LEVEL RelationLevel; // offset: 0x8 (8)
  ULONG Ordinal;                             // offset: 0xc (12)
  ULONG Flags;                               // offset: 0x10 (16)
};

// 0x30 (48) bytes
struct DOCK_INTERFACE {
  USHORT Size;                              // offset: 0x0 (0)
  USHORT Version;                           // offset: 0x2 (2)
  VOID *Context;                            // offset: 0x8 (8)
  VOID (*InterfaceReference)(VOID *arg1);   // offset: 0x10 (16)
  VOID (*InterfaceDereference)(VOID *arg1); // offset: 0x18 (24)
  ULONG (*ProfileDepartureSetMode)
  (VOID *arg1, enum PROFILE_DEPARTURE_STYLE arg2); // offset: 0x20 (32)
  ULONG (*ProfileDepartureUpdate)(VOID *arg1);     // offset: 0x28 (40)
};

// 0x28 (40) bytes
struct _DEVICE_OBJECT_LIST {
  ULONG Count;                                 // offset: 0x0 (0)
  ULONG MaxCount;                              // offset: 0x4 (4)
  ULONG TagCount;                              // offset: 0x8 (8)
  enum _PNP_DEVICE_DELETE_TYPE OperationCode;  // offset: 0xc (12)
  struct _DEVICE_OBJECT_LIST_ENTRY Devices[1]; // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _RELATION_LIST {
  struct _DEVICE_OBJECT_LIST *DeviceObjectList; // offset: 0x0 (0)
  UCHAR Sorted;                                 // offset: 0x8 (8)
};

// 0xc (12) bytes
struct _POWER_SEQUENCE {
  ULONG SequenceD1; // offset: 0x0 (0)
  ULONG SequenceD2; // offset: 0x4 (4)
  ULONG SequenceD3; // offset: 0x8 (8)
};

// 0x40 (64) bytes
struct _DEVICE_CAPABILITIES {
  USHORT Size;                             // offset: 0x0 (0)
  USHORT Version;                          // offset: 0x2 (2)
  ULONG DeviceD1 : 1;                      // offset: 0x4 (4)
  ULONG DeviceD2 : 1;                      // offset: 0x4 (4)
  ULONG LockSupported : 1;                 // offset: 0x4 (4)
  ULONG EjectSupported : 1;                // offset: 0x4 (4)
  ULONG Removable : 1;                     // offset: 0x4 (4)
  ULONG DockDevice : 1;                    // offset: 0x4 (4)
  ULONG UniqueID : 1;                      // offset: 0x4 (4)
  ULONG SilentInstall : 1;                 // offset: 0x4 (4)
  ULONG RawDeviceOK : 1;                   // offset: 0x4 (4)
  ULONG SurpriseRemovalOK : 1;             // offset: 0x4 (4)
  ULONG WakeFromD0 : 1;                    // offset: 0x4 (4)
  ULONG WakeFromD1 : 1;                    // offset: 0x4 (4)
  ULONG WakeFromD2 : 1;                    // offset: 0x4 (4)
  ULONG WakeFromD3 : 1;                    // offset: 0x4 (4)
  ULONG HardwareDisabled : 1;              // offset: 0x4 (4)
  ULONG NonDynamic : 1;                    // offset: 0x4 (4)
  ULONG WarmEjectSupported : 1;            // offset: 0x4 (4)
  ULONG NoDisplayInUI : 1;                 // offset: 0x4 (4)
  ULONG Reserved1 : 1;                     // offset: 0x4 (4)
  ULONG WakeFromInterrupt : 1;             // offset: 0x4 (4)
  ULONG SecureDevice : 1;                  // offset: 0x4 (4)
  ULONG ChildOfVgaEnabledBridge : 1;       // offset: 0x4 (4)
  ULONG DecodeIoOnBoot : 1;                // offset: 0x4 (4)
  ULONG Reserved : 9;                      // offset: 0x4 (4)
  ULONG Address;                           // offset: 0x8 (8)
  ULONG UINumber;                          // offset: 0xc (12)
  enum _DEVICE_POWER_STATE DeviceState[7]; // offset: 0x10 (16)
  enum _SYSTEM_POWER_STATE SystemWake;     // offset: 0x2c (44)
  enum _DEVICE_POWER_STATE DeviceWake;     // offset: 0x30 (48)
  ULONG D1Latency;                         // offset: 0x34 (52)
  ULONG D2Latency;                         // offset: 0x38 (56)
  ULONG D3Latency;                         // offset: 0x3c (60)
};

// 0x4 (4) bytes
struct _SYSTEM_POWER_STATE_CONTEXT {
  union {
    struct {
      ULONG Reserved1 : 8;               // offset: 0x0 (0)
      ULONG TargetSystemState : 4;       // offset: 0x0 (0)
      ULONG EffectiveSystemState : 4;    // offset: 0x0 (0)
      ULONG CurrentSystemState : 4;      // offset: 0x0 (0)
      ULONG IgnoreHibernationPath : 1;   // offset: 0x0 (0)
      ULONG PseudoTransition : 1;        // offset: 0x0 (0)
      ULONG KernelSoftReboot : 1;        // offset: 0x0 (0)
      ULONG DirectedDripsTransition : 1; // offset: 0x0 (0)
      ULONG Reserved2 : 8;               // offset: 0x0 (0)
    };
    ULONG ContextAsUlong; // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
struct _POP_FX_DEPENDENT {
  ULONG Index;         // offset: 0x0 (0)
  ULONG ProviderIndex; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _POP_FX_PROVIDER {
  ULONG Index;      // offset: 0x0 (0)
  UCHAR Activating; // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct _DEVICE_RELATIONS {
  ULONG Count;                       // offset: 0x0 (0)
  struct _DEVICE_OBJECT *Objects[1]; // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct _TOKEN_MANDATORY_POLICY {
  ULONG Policy; // offset: 0x0 (0)
};

// 0x68 (104) bytes
struct _FAST_ERESOURCE {
  VOID *Reserved1[3]; // offset: 0x0 (0)
  ULONG Reserved2;    // offset: 0x18 (24)
  VOID *Reserved3[4]; // offset: 0x20 (32)
  ULONG Reserved4[4]; // offset: 0x40 (64)
  VOID *Reserved5;    // offset: 0x50 (80)
  VOID *Reserved6[2]; // offset: 0x58 (88)
};

// 0x38 (56) bytes
struct _IMAGE_ROM_OPTIONAL_HEADER {
  USHORT Magic;                  // offset: 0x0 (0)
  UCHAR MajorLinkerVersion;      // offset: 0x2 (2)
  UCHAR MinorLinkerVersion;      // offset: 0x3 (3)
  ULONG SizeOfCode;              // offset: 0x4 (4)
  ULONG SizeOfInitializedData;   // offset: 0x8 (8)
  ULONG SizeOfUninitializedData; // offset: 0xc (12)
  ULONG AddressOfEntryPoint;     // offset: 0x10 (16)
  ULONG BaseOfCode;              // offset: 0x14 (20)
  ULONG BaseOfData;              // offset: 0x18 (24)
  ULONG BaseOfBss;               // offset: 0x1c (28)
  ULONG GprMask;                 // offset: 0x20 (32)
  ULONG CprMask[4];              // offset: 0x24 (36)
  ULONG GpValue;                 // offset: 0x34 (52)
};

// 0x10 (16) bytes
struct _MI_PAGE_COLORS {
  ULONG PageSize[4]; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _OBJECT_DIRECTORY_ENTRY {
  struct _OBJECT_DIRECTORY_ENTRY *ChainLink; // offset: 0x0 (0)
  VOID *Object;                              // offset: 0x8 (8)
  ULONG HashValue;                           // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _PO_POWER_PLANE_PROFILE {
  ULONG ExclusivePowerMw; // offset: 0x0 (0)
  ULONG PeakPowerMw;      // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct _PEP_WORK_ACPI_NOTIFY {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  ULONG NotifyCode;                // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _PEP_WORK_COMPLETE_PERF_STATE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  ULONG Component;                 // offset: 0x8 (8)
  UCHAR Succeeded;                 // offset: 0xc (12)
};

// 0x10 (16) bytes
struct _PEP_WORK_COMPLETE_IDLE_STATE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  ULONG Component;                 // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _PEP_WORK_IDLE_STATE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  ULONG Component;                 // offset: 0x8 (8)
  ULONG State;                     // offset: 0xc (12)
};

// 0x10 (16) bytes
struct _PEP_WORK_ACTIVE_COMPLETE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  ULONG Component;                 // offset: 0x8 (8)
};

// 0x70 (112) bytes
struct _PENDING_RELATIONS_LIST_ENTRY {
  struct _LIST_ENTRY Link;                     // offset: 0x0 (0)
  struct _WORK_QUEUE_ITEM WorkItem;            // offset: 0x10 (16)
  struct _PNP_DEVICE_EVENT_ENTRY *DeviceEvent; // offset: 0x30 (48)
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x38 (56)
  struct _RELATION_LIST *RelationsList;        // offset: 0x40 (64)
  struct _IRP *EjectIrp;                       // offset: 0x48 (72)
  enum IRPLOCK Lock;                           // offset: 0x50 (80)
  ULONG Problem;                               // offset: 0x54 (84)
  UCHAR ProfileChangingEject;                  // offset: 0x58 (88)
  UCHAR DisplaySafeRemovalDialog;              // offset: 0x59 (89)
  enum _SYSTEM_POWER_STATE LightestSleepState; // offset: 0x5c (92)
  struct DOCK_INTERFACE *DockInterface;        // offset: 0x60 (96)
  UCHAR DequeuePending;                        // offset: 0x68 (104)
  enum _PNP_DEVICE_DELETE_TYPE DeleteType;     // offset: 0x6c (108)
};

// 0x14 (20) bytes
struct _ETW_LBR_SUPPORT {
  ULONG LbrHandle;            // offset: 0x0 (0)
  ULONG LbrOptions;           // offset: 0x4 (4)
  volatile ULONG HookIdCount; // offset: 0x8 (8)
  USHORT HookId[4];           // offset: 0xc (12)
};

// 0xc (12) bytes
struct _SECURITY_QUALITY_OF_SERVICE {
  ULONG Length;                                          // offset: 0x0 (0)
  enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; // offset: 0x4 (4)
  UCHAR ContextTrackingMode;                             // offset: 0x8 (8)
  UCHAR EffectiveOnly;                                   // offset: 0x9 (9)
};

// 0x40 (64) bytes
struct _OBJECT_CREATE_INFORMATION {
  ULONG Attributes;                                 // offset: 0x0 (0)
  VOID *RootDirectory;                              // offset: 0x8 (8)
  CHAR ProbeMode;                                   // offset: 0x10 (16)
  ULONG PagedPoolCharge;                            // offset: 0x14 (20)
  ULONG NonPagedPoolCharge;                         // offset: 0x18 (24)
  ULONG SecurityDescriptorCharge;                   // offset: 0x1c (28)
  VOID *SecurityDescriptor;                         // offset: 0x20 (32)
  struct _SECURITY_QUALITY_OF_SERVICE *SecurityQos; // offset: 0x28 (40)
  struct _SECURITY_QUALITY_OF_SERVICE
      SecurityQualityOfService; // offset: 0x30 (48)
};

// 0x30 (48) bytes
struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION {
  ULONG SecurityAttributeCount;                     // offset: 0x0 (0)
  struct _LIST_ENTRY SecurityAttributesList;        // offset: 0x8 (8)
  ULONG WorkingSecurityAttributeCount;              // offset: 0x18 (24)
  struct _LIST_ENTRY WorkingSecurityAttributesList; // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _SID_AND_ATTRIBUTES {
  VOID *Sid;        // offset: 0x0 (0)
  ULONG Attributes; // offset: 0x8 (8)
};

// 0x38 (56) bytes
struct _PO_DIRECTED_DRIPS_STATE {
  struct _LIST_ENTRY QueueLink;        // offset: 0x0 (0)
  struct _LIST_ENTRY VisitedQueueLink; // offset: 0x10 (16)
  volatile ULONG Flags;                // offset: 0x20 (32)
  ULONG CachedFlags;                   // offset: 0x24 (36)
  ULONG DeviceUsageCount;              // offset: 0x28 (40)
  VOID *Diagnostic;                    // offset: 0x30 (48)
};

// 0x68 (104) bytes
struct _PO_DEVICE_NOTIFY {
  struct _LIST_ENTRY Link;             // offset: 0x0 (0)
  struct _LIST_ENTRY PowerChildren;    // offset: 0x10 (16)
  struct _LIST_ENTRY PowerParents;     // offset: 0x20 (32)
  struct _DEVICE_OBJECT *TargetDevice; // offset: 0x30 (48)
  UCHAR OrderLevel;                    // offset: 0x38 (56)
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x40 (64)
  WCHAR *DeviceName;                   // offset: 0x48 (72)
  WCHAR *DriverName;                   // offset: 0x50 (80)
  ULONG ChildCount;                    // offset: 0x58 (88)
  ULONG ActiveChild;                   // offset: 0x5c (92)
  ULONG ParentCount;                   // offset: 0x60 (96)
  ULONG ActiveParent;                  // offset: 0x64 (100)
};

// 0x1c (28) bytes
struct _PROC_PERF_QOS_CLASS_POLICY {
  ULONG MaxPolicyPercent;              // offset: 0x0 (0)
  ULONG MaxEquivalentFrequencyPercent; // offset: 0x4 (4)
  ULONG MinPolicyPercent;              // offset: 0x8 (8)
  ULONG AutonomousActivityWindow;      // offset: 0xc (12)
  ULONG EnergyPerfPreference;          // offset: 0x10 (16)
  UCHAR ProvideGuidance;               // offset: 0x14 (20)
  UCHAR AllowThrottling;               // offset: 0x15 (21)
  UCHAR PerfBoostMode;                 // offset: 0x16 (22)
  UCHAR LatencyHintPerf;               // offset: 0x17 (23)
  UCHAR TrackDesiredCrossClass;        // offset: 0x18 (24)
};

// 0xc (12) bytes
struct _SID {
  UCHAR Revision;                                       // offset: 0x0 (0)
  UCHAR SubAuthorityCount;                              // offset: 0x1 (1)
  struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority; // offset: 0x2 (2)
  ULONG SubAuthority[1];                                // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _CM_INDEX_HINT_BLOCK {
  ULONG Count;      // offset: 0x0 (0)
  ULONG HashKey[1]; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _CM_KEY_INDEX {
  USHORT Signature; // offset: 0x0 (0)
  USHORT Count;     // offset: 0x2 (2)
  ULONG List[1];    // offset: 0x4 (4)
};

// 0x30 (48) bytes
struct _MAPIC {
  struct _DESCRIPTION_HEADER Header; // offset: 0x0 (0)
  ULONG LocalAPICAddress;            // offset: 0x24 (36)
  ULONG Flags;                       // offset: 0x28 (40)
  ULONG APICTables[1];               // offset: 0x2c (44)
};

// 0x28 (40) bytes
struct _RSDT_32 {
  struct _DESCRIPTION_HEADER Header; // offset: 0x0 (0)
  ULONG Tables[1];                   // offset: 0x24 (36)
};

// 0x14 (20) bytes
struct _FILE_GET_QUOTA_INFORMATION {
  ULONG NextEntryOffset; // offset: 0x0 (0)
  ULONG SidLength;       // offset: 0x4 (4)
  struct _SID Sid;       // offset: 0x8 (8)
};

// 0xc (12) bytes
struct _COMPRESSED_DATA_INFO {
  USHORT CompressionFormatAndEngine; // offset: 0x0 (0)
  UCHAR CompressionUnitShift;        // offset: 0x2 (2)
  UCHAR ChunkShift;                  // offset: 0x3 (3)
  UCHAR ClusterShift;                // offset: 0x4 (4)
  UCHAR Reserved;                    // offset: 0x5 (5)
  USHORT NumberOfChunks;             // offset: 0x6 (6)
  ULONG CompressedChunkSizes[1];     // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _PROCESSOR_IDLE_DEPENDENCY {
  ULONG ProcessorIndex;    // offset: 0x0 (0)
  UCHAR ExpectedState;     // offset: 0x4 (4)
  UCHAR AllowDeeperStates; // offset: 0x5 (5)
  UCHAR LooseDependency;   // offset: 0x6 (6)
};

// 0x28 (40) bytes
struct _RTL_DYNAMIC_HASH_TABLE {
  ULONG Flags;           // offset: 0x0 (0)
  ULONG Shift;           // offset: 0x4 (4)
  ULONG TableSize;       // offset: 0x8 (8)
  ULONG Pivot;           // offset: 0xc (12)
  ULONG DivisorMask;     // offset: 0x10 (16)
  ULONG NumEntries;      // offset: 0x14 (20)
  ULONG NonEmptyBuckets; // offset: 0x18 (24)
  ULONG NumEnumerators;  // offset: 0x1c (28)
  VOID *Directory;       // offset: 0x20 (32)
};

// 0xe8 (232) bytes
struct _SYSTEM_POWER_POLICY {
  ULONG Revision;                               // offset: 0x0 (0)
  struct POWER_ACTION_POLICY PowerButton;       // offset: 0x4 (4)
  struct POWER_ACTION_POLICY SleepButton;       // offset: 0x10 (16)
  struct POWER_ACTION_POLICY LidClose;          // offset: 0x1c (28)
  enum _SYSTEM_POWER_STATE LidOpenWake;         // offset: 0x28 (40)
  ULONG Reserved;                               // offset: 0x2c (44)
  struct POWER_ACTION_POLICY Idle;              // offset: 0x30 (48)
  ULONG IdleTimeout;                            // offset: 0x3c (60)
  UCHAR IdleSensitivity;                        // offset: 0x40 (64)
  UCHAR DynamicThrottle;                        // offset: 0x41 (65)
  UCHAR Spare2[2];                              // offset: 0x42 (66)
  enum _SYSTEM_POWER_STATE MinSleep;            // offset: 0x44 (68)
  enum _SYSTEM_POWER_STATE MaxSleep;            // offset: 0x48 (72)
  enum _SYSTEM_POWER_STATE ReducedLatencySleep; // offset: 0x4c (76)
  ULONG WinLogonFlags;                          // offset: 0x50 (80)
  ULONG Spare3;                                 // offset: 0x54 (84)
  ULONG DozeS4Timeout;                          // offset: 0x58 (88)
  ULONG BroadcastCapacityResolution;            // offset: 0x5c (92)
  struct SYSTEM_POWER_LEVEL DischargePolicy[4]; // offset: 0x60 (96)
  ULONG VideoTimeout;                           // offset: 0xc0 (192)
  UCHAR VideoDimDisplay;                        // offset: 0xc4 (196)
  ULONG VideoReserved[3];                       // offset: 0xc8 (200)
  ULONG SpindownTimeout;                        // offset: 0xd4 (212)
  UCHAR OptimizeForPower;                       // offset: 0xd8 (216)
  UCHAR FanThrottleTolerance;                   // offset: 0xd9 (217)
  UCHAR ForcedThrottle;                         // offset: 0xda (218)
  UCHAR MinThrottle;                            // offset: 0xdb (219)
  struct POWER_ACTION_POLICY OverThrottled;     // offset: 0xdc (220)
};

// 0x148 (328) bytes
struct _POP_POWER_SETTING_VALUES {
  ULONG StructureSize;                               // offset: 0x0 (0)
  struct _SYSTEM_POWER_POLICY PopPolicy;             // offset: 0x4 (4)
  enum SYSTEM_POWER_CONDITION CurrentAcDcPowerState; // offset: 0xec (236)
  UCHAR AwayModeEnabled;                             // offset: 0xf0 (240)
  UCHAR AwayModeEngaged;                             // offset: 0xf1 (241)
  UCHAR AwayModePolicyAllowed;                       // offset: 0xf2 (242)
  volatile LONG AwayModeIgnoreUserPresent;           // offset: 0xf4 (244)
  volatile LONG AwayModeIgnoreAction;                // offset: 0xf8 (248)
  UCHAR DisableFastS4;                               // offset: 0xfc (252)
  UCHAR DisableStandbyStates;                        // offset: 0xfd (253)
  ULONG UnattendSleepTimeout;                        // offset: 0x100 (256)
  volatile ULONG DiskIgnoreTime;                     // offset: 0x104 (260)
  volatile ULONG DeviceIdlePolicy;                   // offset: 0x108 (264)
  ULONG VideoDimTimeout;                             // offset: 0x10c (268)
  ULONG VideoNormalBrightness;                       // offset: 0x110 (272)
  ULONG VideoDimBrightness;                          // offset: 0x114 (276)
  ULONG AlsOffset;                                   // offset: 0x118 (280)
  ULONG AlsEnabled;                                  // offset: 0x11c (284)
  ULONG EsBrightness;                                // offset: 0x120 (288)
  UCHAR SwitchShutdownForced;                        // offset: 0x124 (292)
  ULONG SystemCoolingPolicy;                         // offset: 0x128 (296)
  UCHAR MediaBufferingEngaged;                       // offset: 0x12c (300)
  UCHAR AudioActivity;                               // offset: 0x12d (301)
  UCHAR FullscreenVideoPlayback;                     // offset: 0x12e (302)
  ULONG EsBatteryThreshold;                          // offset: 0x130 (304)
  UCHAR EsAggressive;                                // offset: 0x134 (308)
  UCHAR EsUserAwaySetting;                           // offset: 0x135 (309)
  ULONG ConnectivityInStandby;                       // offset: 0x138 (312)
  ULONG DisconnectedStandbyMode;                     // offset: 0x13c (316)
  ULONG UserPresencePredictionEnabled;               // offset: 0x140 (320)
  UCHAR AirplaneModeEnabled;                         // offset: 0x144 (324)
  UCHAR BluetoothDeviceCharging;                     // offset: 0x145 (325)
};

// 0xc (12) bytes
struct _PERFINFO_PPM_STATE_SELECTION {
  ULONG SelectedState; // offset: 0x0 (0)
  ULONG VetoedStates;  // offset: 0x4 (4)
  ULONG VetoReason[1]; // offset: 0x8 (8)
};

// 0x38 (56) bytes
struct _THERMAL_COOLING_INTERFACE {
  USHORT Size;                                    // offset: 0x0 (0)
  USHORT Version;                                 // offset: 0x2 (2)
  VOID *Context;                                  // offset: 0x8 (8)
  VOID (*InterfaceReference)(VOID *arg1);         // offset: 0x10 (16)
  VOID (*InterfaceDereference)(VOID *arg1);       // offset: 0x18 (24)
  ULONG Flags;                                    // offset: 0x20 (32)
  VOID (*ActiveCooling)(VOID *arg1, UCHAR arg2);  // offset: 0x28 (40)
  VOID (*PassiveCooling)(VOID *arg1, ULONG arg2); // offset: 0x30 (48)
};

// 0x24 (36) bytes
struct _ETW_FILTER_PID {
  ULONG Count;   // offset: 0x0 (0)
  ULONG Pids[8]; // offset: 0x4 (4)
};

// 0x20 (32) bytes
struct _PERFINFO_GROUPMASK {
  ULONG Masks[8]; // offset: 0x0 (0)
};

// 0x174 (372) bytes
struct _ETW_SYSTEM_LOGGER_SETTINGS {
  struct _ETW_SYSTEM_LOGGER EtwpSystemLogger[8];  // offset: 0x0 (0)
  volatile ULONG EtwpActiveSystemLoggers;         // offset: 0x10 (16)
  struct _PERFINFO_GROUPMASK SiloGlobalGroupMask; // offset: 0x14 (20)
  struct _PERFINFO_GROUPMASK EtwpGroupMasks[10];  // offset: 0x34 (52)
};

// 0x10 (16) bytes
struct _POP_FX_DEVICE_DIRECTED_TRANSITION_STATE {
  VOID *CompletionContext; // offset: 0x0 (0)
  LONG CompletionStatus;   // offset: 0x8 (8)
  ULONG DIrpPending : 1;   // offset: 0xc (12)
  ULONG DIrpCompleted : 1; // offset: 0xc (12)
};

// 0x28 (40) bytes
struct _POP_FX_DRIPS_WATCHDOG_CONTEXT {
  struct _LIST_ENTRY Link;            // offset: 0x0 (0)
  ULONG ComponentIndex;               // offset: 0x10 (16)
  struct _DEVICE_NODE **ChildDevices; // offset: 0x18 (24)
  ULONG ChildDeviceCount;             // offset: 0x20 (32)
};

// 0x2c (44) bytes
struct _PROC_PERF_HISTORY {
  ULONG Count;                                    // offset: 0x0 (0)
  ULONG Slot;                                     // offset: 0x4 (4)
  ULONG UtilityTotal;                             // offset: 0x8 (8)
  ULONG AffinitizedUtilityTotal;                  // offset: 0xc (12)
  ULONG FrequencyTotal;                           // offset: 0x10 (16)
  ULONG TaggedPercentTotal[3];                    // offset: 0x14 (20)
  struct _PROC_PERF_HISTORY_ENTRY HistoryList[1]; // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _PPM_SELECTION_MENU {
  ULONG Count;                               // offset: 0x0 (0)
  struct _PPM_SELECTION_MENU_ENTRY *Entries; // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _PPM_SELECTION_DEPENDENCY {
  ULONG Processor;                 // offset: 0x0 (0)
  struct _PPM_SELECTION_MENU Menu; // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _PPM_SELECTION_MENU_ENTRY {
  UCHAR StrictDependency;                           // offset: 0x0 (0)
  UCHAR InitiatingState;                            // offset: 0x1 (1)
  UCHAR DependentState;                             // offset: 0x2 (2)
  ULONG StateIndex;                                 // offset: 0x4 (4)
  ULONG Dependencies;                               // offset: 0x8 (8)
  struct _PPM_SELECTION_DEPENDENCY *DependencyList; // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _HANDLE_TABLE_ENTRY_INFO {
  ULONG AuditMask;             // offset: 0x0 (0)
  ULONG MaxRelativeAccessMask; // offset: 0x4 (4)
};

// 0x8 (8) bytes
struct _LUID {
  ULONG LowPart; // offset: 0x0 (0)
  LONG HighPart; // offset: 0x4 (4)
};

// 0xc (12) bytes
struct _LUID_AND_ATTRIBUTES {
  struct _LUID Luid; // offset: 0x0 (0)
  ULONG Attributes;  // offset: 0x8 (8)
};

// 0x2c (44) bytes
struct _INITIAL_PRIVILEGE_SET {
  ULONG PrivilegeCount;                     // offset: 0x0 (0)
  ULONG Control;                            // offset: 0x4 (4)
  struct _LUID_AND_ATTRIBUTES Privilege[3]; // offset: 0x8 (8)
};

// 0x14 (20) bytes
struct _PRIVILEGE_SET {
  ULONG PrivilegeCount;                     // offset: 0x0 (0)
  ULONG Control;                            // offset: 0x4 (4)
  struct _LUID_AND_ATTRIBUTES Privilege[1]; // offset: 0x8 (8)
};

// 0xa0 (160) bytes
struct _ACCESS_STATE {
  struct _LUID OperationID;                                // offset: 0x0 (0)
  UCHAR SecurityEvaluated;                                 // offset: 0x8 (8)
  UCHAR GenerateAudit;                                     // offset: 0x9 (9)
  UCHAR GenerateOnClose;                                   // offset: 0xa (10)
  UCHAR PrivilegesAllocated;                               // offset: 0xb (11)
  ULONG Flags;                                             // offset: 0xc (12)
  ULONG RemainingDesiredAccess;                            // offset: 0x10 (16)
  ULONG PreviouslyGrantedAccess;                           // offset: 0x14 (20)
  ULONG OriginalDesiredAccess;                             // offset: 0x18 (24)
  struct _SECURITY_SUBJECT_CONTEXT SubjectSecurityContext; // offset: 0x20 (32)
  VOID *SecurityDescriptor;                                // offset: 0x40 (64)
  VOID *AuxData;                                           // offset: 0x48 (72)
  union {
    struct _INITIAL_PRIVILEGE_SET InitialPrivilegeSet; // offset: 0x50 (80)
    struct _PRIVILEGE_SET PrivilegeSet;                // offset: 0x50 (80)

  } Privileges;                          // offset: 0x50 (80)
  UCHAR AuditPrivileges;                 // offset: 0x7c (124)
  struct _UNICODE_STRING ObjectName;     // offset: 0x80 (128)
  struct _UNICODE_STRING ObjectTypeName; // offset: 0x90 (144)
};

// 0x18 (24) bytes
struct _IO_SECURITY_CONTEXT {
  struct _SECURITY_QUALITY_OF_SERVICE *SecurityQos; // offset: 0x0 (0)
  struct _ACCESS_STATE *AccessState;                // offset: 0x8 (8)
  ULONG DesiredAccess;                              // offset: 0x10 (16)
  ULONG FullCreateOptions;                          // offset: 0x14 (20)
};

// 0x10 (16) bytes
struct _TOKEN_PRIVILEGES {
  ULONG PrivilegeCount;                      // offset: 0x0 (0)
  struct _LUID_AND_ATTRIBUTES Privileges[1]; // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct _TOKEN_SOURCE {
  CHAR SourceName[8];            // offset: 0x0 (0)
  struct _LUID SourceIdentifier; // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _TOKEN_CONTROL {
  struct _LUID TokenId;             // offset: 0x0 (0)
  struct _LUID AuthenticationId;    // offset: 0x8 (8)
  struct _LUID ModifiedId;          // offset: 0x10 (16)
  struct _TOKEN_SOURCE TokenSource; // offset: 0x18 (24)
};

// 0x48 (72) bytes
struct _SECURITY_CLIENT_CONTEXT {
  struct _SECURITY_QUALITY_OF_SERVICE SecurityQos; // offset: 0x0 (0)
  VOID *ClientToken;                               // offset: 0x10 (16)
  UCHAR DirectlyAccessClientToken;                 // offset: 0x18 (24)
  UCHAR DirectAccessEffectiveOnly;                 // offset: 0x19 (25)
  UCHAR ServerIsRemote;                            // offset: 0x1a (26)
  struct _TOKEN_CONTROL ClientTokenControl;        // offset: 0x1c (28)
};

// 0x48 (72) bytes
struct _MI_CACHED_PTES {
  struct _MI_CACHED_PTE Bins[8]; // offset: 0x0 (0)
  LONG CachedPteCount;           // offset: 0x40 (64)
};

// 0x48 (72) bytes
struct _DEVICE_MAP {
  struct _OBJECT_DIRECTORY *DosDevicesDirectory;       // offset: 0x0 (0)
  struct _OBJECT_DIRECTORY *GlobalDosDevicesDirectory; // offset: 0x8 (8)
  VOID *DosDevicesDirectoryHandle;                     // offset: 0x10 (16)
  volatile LONG ReferenceCount;                        // offset: 0x18 (24)
  ULONG DriveMap;                                      // offset: 0x1c (28)
  UCHAR DriveType[32];                                 // offset: 0x20 (32)
  struct _EJOB *ServerSilo;                            // offset: 0x40 (64)
};

// 0x18 (24) bytes
struct _KDEVICE_QUEUE_ENTRY {
  struct _LIST_ENTRY DeviceListEntry; // offset: 0x0 (0)
  ULONG SortKey;                      // offset: 0x10 (16)
  UCHAR Inserted;                     // offset: 0x14 (20)
};

// 0xc (12) bytes
struct _CACHE_DESCRIPTOR {
  UCHAR Level;                     // offset: 0x0 (0)
  UCHAR Associativity;             // offset: 0x1 (1)
  USHORT LineSize;                 // offset: 0x2 (2)
  ULONG Size;                      // offset: 0x4 (4)
  enum _PROCESSOR_CACHE_TYPE Type; // offset: 0x8 (8)
};

// 0xc (12) bytes
struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
  ULONG BeginAddress; // offset: 0x0 (0)
  ULONG EndAddress;   // offset: 0x4 (4)
  union {
    ULONG UnwindInfoAddress; // offset: 0x8 (8)
    ULONG UnwindData;        // offset: 0x8 (8)
  };
};

// 0xa0 (160) bytes
struct _HANDLE_TRACE_DB_ENTRY {
  struct _CLIENT_ID ClientId; // offset: 0x0 (0)
  VOID *Handle;               // offset: 0x10 (16)
  ULONG Type;                 // offset: 0x18 (24)
  VOID *StackTrace[16];       // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _RTL_DRIVE_LETTER_CURDIR {
  USHORT Flags;           // offset: 0x0 (0)
  USHORT Length;          // offset: 0x2 (2)
  ULONG TimeStamp;        // offset: 0x4 (4)
  struct _STRING DosPath; // offset: 0x8 (8)
};

// 0x6c (108) bytes
struct _OBP_SYSTEM_DOS_DEVICE_STATE {
  ULONG GlobalDeviceMap;      // offset: 0x0 (0)
  ULONG LocalDeviceCount[26]; // offset: 0x4 (4)
};

// 0x54 (84) bytes
struct _IOP_IRP_STACK_PROFILER {
  ULONG Profile[20]; // offset: 0x0 (0)
  ULONG TotalIrps;   // offset: 0x50 (80)
};

// 0x5c (92) bytes
struct _THERMAL_INFORMATION_EX {
  ULONG ThermalStamp;                 // offset: 0x0 (0)
  ULONG ThermalConstant1;             // offset: 0x4 (4)
  ULONG ThermalConstant2;             // offset: 0x8 (8)
  ULONG SamplingPeriod;               // offset: 0xc (12)
  ULONG CurrentTemperature;           // offset: 0x10 (16)
  ULONG PassiveTripPoint;             // offset: 0x14 (20)
  ULONG ThermalStandbyTripPoint;      // offset: 0x18 (24)
  ULONG CriticalTripPoint;            // offset: 0x1c (28)
  UCHAR ActiveTripPointCount;         // offset: 0x20 (32)
  UCHAR PassiveCoolingDevicesPresent; // offset: 0x21 (33)
  ULONG ActiveTripPoint[10];          // offset: 0x24 (36)
  ULONG S4TransitionTripPoint;        // offset: 0x4c (76)
  ULONG MinimumThrottle;              // offset: 0x50 (80)
  ULONG OverThrottleThreshold;        // offset: 0x54 (84)
  ULONG PollingPeriod;                // offset: 0x58 (88)
};

// 0x4 (4) bytes
union _KPRCBFLAG {
  volatile LONG PrcbFlags;         // offset: 0x0 (0)
  ULONG BamQosLevel : 8;           // offset: 0x0 (0)
  ULONG PendingQosUpdate : 2;      // offset: 0x0 (0)
  ULONG CacheIsolationEnabled : 1; // offset: 0x0 (0)
  ULONG TracepointActive : 1;      // offset: 0x0 (0)
  ULONG PrcbFlagsReserved : 20;    // offset: 0x0 (0)
};

// 0x40 (64) bytes
struct _KQUEUE {
  struct _DISPATCHER_HEADER Header;  // offset: 0x0 (0)
  struct _LIST_ENTRY EntryListHead;  // offset: 0x18 (24)
  volatile ULONG CurrentCount;       // offset: 0x28 (40)
  ULONG MaximumCount;                // offset: 0x2c (44)
  struct _LIST_ENTRY ThreadListHead; // offset: 0x30 (48)
};

// 0x48 (72) bytes
struct _ETW_REPLY_QUEUE {
  struct _KQUEUE Queue; // offset: 0x0 (0)
  LONG EventsLost;      // offset: 0x40 (64)
};

// 0x30 (48) bytes
struct _KWAIT_BLOCK {
  struct _LIST_ENTRY WaitListEntry; // offset: 0x0 (0)
  UCHAR WaitType;                   // offset: 0x10 (16)
  volatile UCHAR BlockState;        // offset: 0x11 (17)
  USHORT WaitKey;                   // offset: 0x12 (18)
  LONG SpareLong;                   // offset: 0x14 (20)
  union {
    struct _KTHREAD *Thread;           // offset: 0x18 (24)
    struct _KQUEUE *NotificationQueue; // offset: 0x18 (24)
  };
  VOID *Object;   // offset: 0x20 (32)
  VOID *SparePtr; // offset: 0x28 (40)
};

// 0x4 (4) bytes
union _KLOCK_ENTRY_BOOST_BITMAP {
  ULONG AllFields;             // offset: 0x0 (0)
  ULONG AllBoosts : 17;        // offset: 0x0 (0)
  ULONG Reserved : 15;         // offset: 0x0 (0)
  USHORT CpuBoostsBitmap : 15; // offset: 0x0 (0)
  struct {
    USHORT IoBoost : 1;                     // offset: 0x0 (0)
    USHORT IoQoSBoost : 1;                  // offset: 0x2 (2)
    USHORT IoNormalPriorityWaiterCount : 8; // offset: 0x2 (2)
  };
  USHORT IoQoSWaiterCount : 7; // offset: 0x2 (2)
};

// 0x88 (136) bytes
struct _UMS_CONTROL_BLOCK {
  struct _RTL_UMS_CONTEXT *UmsContext;            // offset: 0x0 (0)
  struct _SINGLE_LIST_ENTRY *CompletionListEntry; // offset: 0x8 (8)
  struct _KEVENT *CompletionListEvent;            // offset: 0x10 (16)
  ULONG ServiceSequenceNumber;                    // offset: 0x18 (24)
  union {
    struct {
      struct _KQUEUE UmsQueue;                     // offset: 0x20 (32)
      struct _LIST_ENTRY QueueEntry;               // offset: 0x60 (96)
      struct _RTL_UMS_CONTEXT *YieldingUmsContext; // offset: 0x70 (112)
      VOID *YieldingParam;                         // offset: 0x78 (120)
      VOID *UmsTeb;                                // offset: 0x80 (128)
    };
    struct {
      struct _KQUEUE *UmsAssociatedQueue;    // offset: 0x20 (32)
      struct _LIST_ENTRY *UmsQueueListEntry; // offset: 0x28 (40)
      struct _KEVENT UmsWaitEvent;           // offset: 0x30 (48)
      VOID *StagingArea;                     // offset: 0x48 (72)
      union {
        struct {
          ULONG UmsPrimaryDeliveredContext : 1; // offset: 0x50 (80)
          ULONG UmsAssociatedQueueUsed : 1;     // offset: 0x50 (80)
          ULONG UmsThreadParked : 1;            // offset: 0x50 (80)
        };
        ULONG UmsFlags; // offset: 0x50 (80)
      };
    };
  };
};

// 0x60 (96) bytes
struct _VPB {
  SHORT Type;                          // offset: 0x0 (0)
  SHORT Size;                          // offset: 0x2 (2)
  USHORT Flags;                        // offset: 0x4 (4)
  USHORT VolumeLabelLength;            // offset: 0x6 (6)
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 (8)
  struct _DEVICE_OBJECT *RealDevice;   // offset: 0x10 (16)
  ULONG SerialNumber;                  // offset: 0x18 (24)
  ULONG ReferenceCount;                // offset: 0x1c (28)
  WCHAR VolumeLabel[32];               // offset: 0x20 (32)
};

// 0x4 (4) bytes
struct _MM_SESSION_SPACE_FLAGS {
  ULONG Initialized : 1;            // offset: 0x0 (0)
  ULONG DeletePending : 1;          // offset: 0x0 (0)
  ULONG PoolInitialized : 1;        // offset: 0x0 (0)
  ULONG DynamicVaInitialized : 1;   // offset: 0x0 (0)
  ULONG WsInitialized : 1;          // offset: 0x0 (0)
  ULONG PoolDestroyed : 1;          // offset: 0x0 (0)
  ULONG ObjectInitialized : 1;      // offset: 0x0 (0)
  ULONG SessionHeapInitialized : 1; // offset: 0x0 (0)
  ULONG SessionHeapDestroyed : 1;   // offset: 0x0 (0)
  ULONG LeakedPoolDeliberately : 1; // offset: 0x0 (0)
  ULONG Filler : 22;                // offset: 0x0 (0)
};

// 0x58 (88) bytes
struct _PEB_LDR_DATA {
  ULONG Length;                                       // offset: 0x0 (0)
  UCHAR Initialized;                                  // offset: 0x4 (4)
  VOID *SsHandle;                                     // offset: 0x8 (8)
  struct _LIST_ENTRY InLoadOrderModuleList;           // offset: 0x10 (16)
  struct _LIST_ENTRY InMemoryOrderModuleList;         // offset: 0x20 (32)
  struct _LIST_ENTRY InInitializationOrderModuleList; // offset: 0x30 (48)
  VOID *EntryInProgress;                              // offset: 0x40 (64)
  UCHAR ShutdownInProgress;                           // offset: 0x48 (72)
  VOID *ShutdownThreadId;                             // offset: 0x50 (80)
};

// 0x60 (96) bytes
struct _ETW_APC_ENTRY {
  union {
    struct _SLIST_ENTRY SListEntry; // offset: 0x0 (0)
    struct _KAPC Apc;               // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
struct _KSCHEDULING_GROUP_POLICY {
  union {
    ULONG Value;   // offset: 0x0 (0)
    USHORT Weight; // offset: 0x0 (0)
    struct {
      USHORT MinRate; // offset: 0x0 (0)
      USHORT MaxRate; // offset: 0x2 (2)
    };
  };
  union {
    ULONG AllFlags; // offset: 0x4 (4)
    struct {
      ULONG Type : 1;     // offset: 0x4 (4)
      ULONG Disabled : 1; // offset: 0x4 (4)
      ULONG RankBias : 1; // offset: 0x4 (4)
      ULONG Spare1 : 29;  // offset: 0x4 (4)
    };
  };
};

// 0x80 (128) bytes
struct _ACCESS_REASONS {
  ULONG Data[32]; // offset: 0x0 (0)
};

// 0x1c (28) bytes
struct _RSDS {
  ULONG Signature;   // offset: 0x0 (0)
  struct _GUID Guid; // offset: 0x4 (4)
  ULONG Age;         // offset: 0x14 (20)
  CHAR PdbName[1];   // offset: 0x18 (24)
};

// 0x1c (28) bytes
union _CVDD {
  ULONG Signature;   // offset: 0x0 (0)
  struct _NB10 NB10; // offset: 0x0 (0)
  struct _RSDS RsDs; // offset: 0x0 (0)
};

// 0x38 (56) bytes
struct _ETW_DEBUGID_TRACKING_ENTRY {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
  UCHAR ConsumersNotified;      // offset: 0x10 (16)
  UCHAR Spare[3];               // offset: 0x11 (17)
  ULONG DebugIdSize;            // offset: 0x14 (20)
  union _CVDD DebugId;          // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct __WIL__WNF_TYPE_ID {
  struct _GUID TypeId; // offset: 0x0 (0)
};

// 0x58 (88) bytes
struct _IO_WORKITEM {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 (0)
  VOID (*Routine)
  (VOID *arg1, VOID *arg2, struct _IO_WORKITEM *arg3); // offset: 0x20 (32)
  VOID *IoObject;                                      // offset: 0x28 (40)
  VOID *Context;                                       // offset: 0x30 (48)
  struct _ETHREAD *WorkOnBehalfThread;                 // offset: 0x38 (56)
  ULONG Type;                                          // offset: 0x40 (64)
  struct _GUID ActivityId;                             // offset: 0x44 (68)
};

// 0x40 (64) bytes
struct _HEADLESS_LOADER_BLOCK {
  UCHAR UsedBiosSettings;   // offset: 0x0 (0)
  UCHAR DataBits;           // offset: 0x1 (1)
  UCHAR StopBits;           // offset: 0x2 (2)
  UCHAR Parity;             // offset: 0x3 (3)
  ULONG BaudRate;           // offset: 0x4 (4)
  ULONG PortNumber;         // offset: 0x8 (8)
  UCHAR *PortAddress;       // offset: 0x10 (16)
  USHORT PciDeviceId;       // offset: 0x18 (24)
  USHORT PciVendorId;       // offset: 0x1a (26)
  UCHAR PciBusNumber;       // offset: 0x1c (28)
  USHORT PciBusSegment;     // offset: 0x1e (30)
  UCHAR PciSlotNumber;      // offset: 0x20 (32)
  UCHAR PciFunctionNumber;  // offset: 0x21 (33)
  ULONG PciFlags;           // offset: 0x24 (36)
  struct _GUID SystemGUID;  // offset: 0x28 (40)
  UCHAR IsMMIODevice;       // offset: 0x38 (56)
  UCHAR TerminalType;       // offset: 0x39 (57)
  UCHAR InterfaceType;      // offset: 0x3a (58)
  UCHAR RegisterBitWidth;   // offset: 0x3b (59)
  UCHAR RegisterAccessSize; // offset: 0x3c (60)
};

// 0x48 (72) bytes
struct _CMP_VOLUME_CONTEXT {
  struct _LIST_ENTRY VolumeContextListEntry; // offset: 0x0 (0)
  struct _CMP_VOLUME_MANAGER *VolumeManager; // offset: 0x10 (16)
  LONGLONG RefCount;                         // offset: 0x18 (24)
  struct _GUID VolumeGuid;                   // offset: 0x20 (32)
  VOID *VolumeFileObject;                    // offset: 0x30 (48)
  struct _CMSI_RW_LOCK VolumeContextLock;    // offset: 0x38 (56)
  UCHAR DeviceUsageNotificationSent;         // offset: 0x40 (64)
};

// 0x10 (16) bytes
struct _WNF_TYPE_ID {
  struct _GUID TypeId; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _WNF_STATE_NAME_REGISTRATION {
  ULONG MaxStateSize;                              // offset: 0x0 (0)
  struct _WNF_TYPE_ID *TypeId;                     // offset: 0x8 (8)
  struct _SECURITY_DESCRIPTOR *SecurityDescriptor; // offset: 0x10 (16)
};

// 0x13 (19) bytes
struct _tlgProviderMetadata_t {
  UCHAR Type;              // offset: 0x0 (0)
  struct _GUID ProviderId; // offset: 0x1 (1)
  USHORT RemainingSize;    // offset: 0x11 (17)
};

// 0xe0 (224) bytes
struct _AUX_ACCESS_DATA {
  struct _PRIVILEGE_SET *PrivilegesUsed;                   // offset: 0x0 (0)
  struct _GENERIC_MAPPING GenericMapping;                  // offset: 0x8 (8)
  ULONG AccessesToAudit;                                   // offset: 0x18 (24)
  ULONG MaximumAuditMask;                                  // offset: 0x1c (28)
  struct _GUID TransactionId;                              // offset: 0x20 (32)
  VOID *NewSecurityDescriptor;                             // offset: 0x30 (48)
  VOID *ExistingSecurityDescriptor;                        // offset: 0x38 (56)
  VOID *ParentSecurityDescriptor;                          // offset: 0x40 (64)
  VOID (*DeRefSecurityDescriptor)(VOID *arg1, VOID *arg2); // offset: 0x48 (72)
  VOID *SDLock;                                            // offset: 0x50 (80)
  struct _ACCESS_REASONS AccessReasons;                    // offset: 0x58 (88)
  UCHAR GenerateStagingEvents;                             // offset: 0xd8 (216)
};

// 0x14 (20) bytes
struct _DEVPROPKEY {
  struct _GUID fmtid; // offset: 0x0 (0)
  ULONG pid;          // offset: 0x10 (16)
};

// 0x48 (72) bytes
struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
  ULONG SectionOffset;           // offset: 0x0 (0)
  ULONG SectionLength;           // offset: 0x4 (4)
  union _WHEA_REVISION Revision; // offset: 0x8 (8)
  union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS
      ValidBits;                                           // offset: 0xa (10)
  UCHAR Reserved;                                          // offset: 0xb (11)
  union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS Flags; // offset: 0xc (12)
  struct _GUID SectionType;                                // offset: 0x10 (16)
  struct _GUID FRUId;                                      // offset: 0x20 (32)
  enum _WHEA_ERROR_SEVERITY SectionSeverity;               // offset: 0x30 (48)
  CHAR FRUText[20];                                        // offset: 0x34 (52)
};

// 0x10 (16) bytes
struct _PERIODIC_CAPTURE_STATE_GUIDS {
  USHORT ProviderCount;    // offset: 0x0 (0)
  struct _GUID *Providers; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _DISALLOWED_GUIDS {
  USHORT Count;        // offset: 0x0 (0)
  struct _GUID *Guids; // offset: 0x8 (8)
};

// 0x30 (48) bytes
struct _ETW_DECODE_CONTROL_ENTRY {
  struct _ETW_DECODE_CONTROL_ENTRY *Next; // offset: 0x0 (0)
  struct _GUID Decode;                    // offset: 0x8 (8)
  struct _GUID Control;                   // offset: 0x18 (24)
  UCHAR ConsumersNotified;                // offset: 0x28 (40)
};

// 0x8 (8) bytes
struct _JOBOBJECT_WAKE_FILTER {
  ULONG HighEdgeFilter; // offset: 0x0 (0)
  ULONG LowEdgeFilter;  // offset: 0x4 (4)
};

// 0x10 (16) bytes
struct _PO_DIAG_STACK_RECORD {
  ULONG StackDepth; // offset: 0x0 (0)
  VOID *Stack[1];   // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _EXT_DELETE_PARAMETERS {
  ULONG Version;                      // offset: 0x0 (0)
  ULONG Reserved;                     // offset: 0x4 (4)
  VOID (*DeleteCallback)(VOID *arg1); // offset: 0x8 (8)
  VOID *DeleteContext;                // offset: 0x10 (16)
};

// 0x14 (20) bytes
struct _CM_UOW_KEY_STATE_MODIFICATION {
  ULONG RefCount;           // offset: 0x0 (0)
  ULONG SubKeyListCount[2]; // offset: 0x4 (4)
  ULONG NewSubKeyList[2];   // offset: 0xc (12)
};

// 0x8 (8) bytes
struct _WNF_STATE_NAME {
  ULONG Data[2]; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct __WIL__WNF_STATE_NAME {
  ULONG Data[2]; // offset: 0x0 (0)
};

// 0x38 (56) bytes
struct _FAST_MUTEX {
  LONG Count;           // offset: 0x0 (0)
  VOID *Owner;          // offset: 0x8 (8)
  ULONG Contention;     // offset: 0x10 (16)
  struct _KEVENT Event; // offset: 0x18 (24)
  ULONG OldIrql;        // offset: 0x30 (48)
};

// 0x88 (136) bytes
struct _PNP_DEVICE_EVENT_LIST {
  LONG Status;                     // offset: 0x0 (0)
  struct _KMUTANT EventQueueMutex; // offset: 0x8 (8)
  struct _FAST_MUTEX Lock;         // offset: 0x40 (64)
  struct _LIST_ENTRY List;         // offset: 0x78 (120)
};

// 0xf0 (240) bytes
struct _HANDLE_TRACE_DEBUG_INFO {
  LONG RefCount;                            // offset: 0x0 (0)
  ULONG TableSize;                          // offset: 0x4 (4)
  ULONG BitMaskFlags;                       // offset: 0x8 (8)
  struct _FAST_MUTEX CloseCompactionLock;   // offset: 0x10 (16)
  ULONG CurrentStackIndex;                  // offset: 0x48 (72)
  struct _HANDLE_TRACE_DB_ENTRY TraceDb[1]; // offset: 0x50 (80)
};

// 0x10 (16) bytes
struct _EXT_SET_PARAMETERS_V0 {
  ULONG Version;            // offset: 0x0 (0)
  ULONG Reserved;           // offset: 0x4 (4)
  LONGLONG NoWakeTolerance; // offset: 0x8 (8)
};

// 0x4 (4) bytes
struct _KFLOATING_SAVE {
  ULONG Dummy; // offset: 0x0 (0)
};

// 0x38 (56) bytes
struct _HEAP_LIST_LOOKUP {
  struct _HEAP_LIST_LOOKUP *ExtendedLookup; // offset: 0x0 (0)
  ULONG ArraySize;                          // offset: 0x8 (8)
  ULONG ExtraItem;                          // offset: 0xc (12)
  ULONG ItemCount;                          // offset: 0x10 (16)
  ULONG OutOfRangeItems;                    // offset: 0x14 (20)
  ULONG BaseIndex;                          // offset: 0x18 (24)
  struct _LIST_ENTRY *ListHead;             // offset: 0x20 (32)
  ULONG *ListsInUseUlong;                   // offset: 0x28 (40)
  struct _LIST_ENTRY **ListHints;           // offset: 0x30 (48)
};

// 0x30 (48) bytes
struct _BITMAP_RANGE {
  struct _LIST_ENTRY Links; // offset: 0x0 (0)
  LONGLONG BasePage;        // offset: 0x10 (16)
  ULONG FirstDirtyPage;     // offset: 0x18 (24)
  ULONG LastDirtyPage;      // offset: 0x1c (28)
  ULONG DirtyPages;         // offset: 0x20 (32)
  ULONG *Bitmap;            // offset: 0x28 (40)
};

// 0xc0 (192) bytes
struct _MBCB {
  SHORT NodeTypeCode;                // offset: 0x0 (0)
  SHORT NodeIsInZone;                // offset: 0x2 (2)
  ULONG PagesToWrite;                // offset: 0x4 (4)
  ULONG DirtyPages;                  // offset: 0x8 (8)
  ULONG Reserved;                    // offset: 0xc (12)
  struct _LIST_ENTRY BitmapRanges;   // offset: 0x10 (16)
  LONGLONG ResumeWritePage;          // offset: 0x20 (32)
  LONGLONG MostRecentlyDirtiedPage;  // offset: 0x28 (40)
  struct _BITMAP_RANGE BitmapRange1; // offset: 0x30 (48)
  struct _BITMAP_RANGE BitmapRange2; // offset: 0x60 (96)
  struct _BITMAP_RANGE BitmapRange3; // offset: 0x90 (144)
};

// 0x20 (32) bytes
struct _PEP_ACPI_INTERRUPT_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;           // offset: 0x0 (0)
  enum _KINTERRUPT_MODE InterruptType;         // offset: 0x4 (4)
  enum _KINTERRUPT_POLARITY InterruptPolarity; // offset: 0x8 (8)
  union _PEP_ACPI_RESOURCE_FLAGS Flags;        // offset: 0xc (12)
  UCHAR Count;                                 // offset: 0x10 (16)
  ULONG *Pins;                                 // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _WHEA_ERROR_SOURCE_CONFIGURATION_DD {
  LONG (*Initialize)(VOID *arg1, ULONG arg2); // offset: 0x0 (0)
  VOID (*Uninitialize)(VOID *arg1);           // offset: 0x8 (8)
  LONG (*Correct)(VOID *arg1, ULONG *arg2);   // offset: 0x10 (16)
};

// 0x74 (116) bytes
struct _WHEA_DEVICE_DRIVER_DESCRIPTOR {
  USHORT Type;                                       // offset: 0x0 (0)
  UCHAR Enabled;                                     // offset: 0x2 (2)
  UCHAR Reserved;                                    // offset: 0x3 (3)
  struct _GUID SourceGuid;                           // offset: 0x4 (4)
  USHORT LogTag;                                     // offset: 0x14 (20)
  USHORT Reserved2;                                  // offset: 0x16 (22)
  ULONG PacketLength;                                // offset: 0x18 (24)
  ULONG PacketCount;                                 // offset: 0x1c (28)
  UCHAR *PacketBuffer;                               // offset: 0x20 (32)
  struct _WHEA_ERROR_SOURCE_CONFIGURATION_DD Config; // offset: 0x28 (40)
  struct _GUID CreatorId;                            // offset: 0x40 (64)
  struct _GUID PartitionId;                          // offset: 0x50 (80)
  ULONG MaxSectionDataLength;                        // offset: 0x60 (96)
  ULONG MaxSectionsPerRecord;                        // offset: 0x64 (100)
  UCHAR *PacketStateBuffer;                          // offset: 0x68 (104)
  LONG OpenHandles;                                  // offset: 0x70 (112)
};

// 0x50 (80) bytes
struct _PLUGPLAY_EVENT_BLOCK {
  struct _GUID EventGuid;                      // offset: 0x0 (0)
  enum _PLUGPLAY_EVENT_CATEGORY EventCategory; // offset: 0x10 (16)
  ULONG *Result;                               // offset: 0x18 (24)
  ULONG Flags;                                 // offset: 0x20 (32)
  ULONG TotalSize;                             // offset: 0x24 (36)
  VOID *DeviceObject;                          // offset: 0x28 (40)
  union {
    struct {
      struct _GUID ClassGuid;    // offset: 0x0 (0)
      WCHAR SymbolicLinkName[1]; // offset: 0x10 (16)
    } DeviceClass;               // offset: 0x30 (48)
    struct {
      WCHAR DeviceId[1]; // offset: 0x0 (0)
    } TargetDevice;      // offset: 0x30 (48)
    struct {
      WCHAR DeviceId[1]; // offset: 0x0 (0)
    } InstallDevice;     // offset: 0x30 (48)
    struct {
      VOID *NotificationStructure; // offset: 0x0 (0)
      WCHAR DeviceId[1];           // offset: 0x8 (8)
    } CustomNotification;          // offset: 0x30 (48)
    struct {
      VOID *Notification;  // offset: 0x0 (0)
    } ProfileNotification; // offset: 0x30 (48)
    struct {
      ULONG NotificationCode; // offset: 0x0 (0)
      ULONG NotificationData; // offset: 0x4 (4)
    } PowerNotification;      // offset: 0x30 (48)
    struct {
      enum _PNP_VETO_TYPE VetoType;    // offset: 0x0 (0)
      WCHAR DeviceIdVetoNameBuffer[1]; // offset: 0x4 (4)
    } VetoNotification;                // offset: 0x30 (48)
    struct {
      struct _GUID BlockedDriverGuid; // offset: 0x0 (0)
    } BlockedDriverNotification;      // offset: 0x30 (48)
    struct {
      WCHAR ParentId[1];     // offset: 0x0 (0)
    } InvalidIDNotification; // offset: 0x30 (48)
    struct {
      struct _GUID PowerSettingGuid; // offset: 0x0 (0)
      ULONG Flags;                   // offset: 0x10 (16)
      ULONG SessionId;               // offset: 0x14 (20)
      ULONG DataLength;              // offset: 0x18 (24)
      UCHAR Data[1];                 // offset: 0x1c (28)
    } PowerSettingNotification;      // offset: 0x30 (48)
    struct {
      WCHAR DeviceId[1];          // offset: 0x0 (0)
    } PropertyChangeNotification; // offset: 0x30 (48)
    struct {
      WCHAR DeviceId[1];          // offset: 0x0 (0)
    } DeviceInstanceNotification; // offset: 0x30 (48)

  } u; // offset: 0x30 (48)
};

// 0x18 (24) bytes
struct _PPM_COORDINATED_SELECTION {
  ULONG MaximumStates;    // offset: 0x0 (0)
  ULONG SelectedStates;   // offset: 0x4 (4)
  ULONG DefaultSelection; // offset: 0x8 (8)
  ULONG *Selection;       // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _RTL_BITMAP {
  ULONG SizeOfBitMap; // offset: 0x0 (0)
  ULONG *Buffer;      // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _FREE_DISPLAY {
  ULONG RealVectorSize;       // offset: 0x0 (0)
  ULONG Hint;                 // offset: 0x4 (4)
  struct _RTL_BITMAP Display; // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _MI_PAGING_FILE_SPACE_BITMAPS {
  union {
    ULONG RefCount;                               // offset: 0x0 (0)
    struct _MI_PAGING_FILE_SPACE_BITMAPS *Anchor; // offset: 0x0 (0)
  };
  struct _RTL_BITMAP AllocationBitmap; // offset: 0x8 (8)
  union {
    struct _RTL_BITMAP ReservationBitmap; // offset: 0x18 (24)
    struct _RTL_BITMAP EvictedBitmap;     // offset: 0x18 (24)
  };
};

// 0x8 (8) bytes
union _LARGE_INTEGER {
  struct {
    ULONG LowPart; // offset: 0x0 (0)
    LONG HighPart; // offset: 0x4 (4)
  };
  struct {
    ULONG LowPart;   // offset: 0x0 (0)
    LONG HighPart;   // offset: 0x4 (4)
  } u;               // offset: 0x0 (0)
  LONGLONG QuadPart; // offset: 0x0 (0)
};

// 0x2c (44) bytes
struct _XSDT {
  struct _DESCRIPTION_HEADER Header; // offset: 0x0 (0)
  union _LARGE_INTEGER Tables[1];    // offset: 0x24 (36)
};

// 0x40 (64) bytes
struct _DEVICE_DESCRIPTION {
  ULONG Version;                      // offset: 0x0 (0)
  UCHAR Master;                       // offset: 0x4 (4)
  UCHAR ScatterGather;                // offset: 0x5 (5)
  UCHAR DemandMode;                   // offset: 0x6 (6)
  UCHAR AutoInitialize;               // offset: 0x7 (7)
  UCHAR Dma32BitAddresses;            // offset: 0x8 (8)
  UCHAR IgnoreCount;                  // offset: 0x9 (9)
  UCHAR Reserved1;                    // offset: 0xa (10)
  UCHAR Dma64BitAddresses;            // offset: 0xb (11)
  ULONG BusNumber;                    // offset: 0xc (12)
  ULONG DmaChannel;                   // offset: 0x10 (16)
  enum _INTERFACE_TYPE InterfaceType; // offset: 0x14 (20)
  enum _DMA_WIDTH DmaWidth;           // offset: 0x18 (24)
  enum _DMA_SPEED DmaSpeed;           // offset: 0x1c (28)
  ULONG MaximumLength;                // offset: 0x20 (32)
  ULONG DmaPort;                      // offset: 0x24 (36)
  ULONG DmaAddressWidth;              // offset: 0x28 (40)
  ULONG DmaControllerInstance;        // offset: 0x2c (44)
  ULONG DmaRequestLine;               // offset: 0x30 (48)
  union _LARGE_INTEGER DeviceAddress; // offset: 0x38 (56)
};

// 0x28 (40) bytes
struct _OBJECT_SYMBOLIC_LINK {
  union _LARGE_INTEGER CreationTime; // offset: 0x0 (0)
  union {
    struct _UNICODE_STRING LinkTarget; // offset: 0x8 (8)
    struct {
      LONG (*Callback)
      (struct _OBJECT_SYMBOLIC_LINK *arg1, VOID *arg2,
       struct _UNICODE_STRING *arg3, VOID **arg4); // offset: 0x8 (8)
      VOID *CallbackContext;                       // offset: 0x10 (16)
    };
  };
  ULONG DosDeviceDriveIndex; // offset: 0x18 (24)
  ULONG Flags;               // offset: 0x1c (28)
  ULONG AccessMask;          // offset: 0x20 (32)
};

// 0x38 (56) bytes
struct _MI_BAD_MEMORY_EVENT_ENTRY {
  ULONG BugCheckCode;                   // offset: 0x0 (0)
  LONG Active;                          // offset: 0x4 (4)
  ULONG Data;                           // offset: 0x8 (8)
  union _LARGE_INTEGER PhysicalAddress; // offset: 0x10 (16)
  struct _WORK_QUEUE_ITEM WorkItem;     // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _DOMAIN_CONFIGURATION_ARM64 {
  union _LARGE_INTEGER Ttbr0; // offset: 0x0 (0)
  union _LARGE_INTEGER Ttbr1; // offset: 0x8 (8)
  ULONG Mair0;                // offset: 0x10 (16)
  ULONG Mair1;                // offset: 0x14 (20)
  UCHAR InputSize0;           // offset: 0x18 (24)
  UCHAR InputSize1;           // offset: 0x19 (25)
  UCHAR CoherentTableWalks;   // offset: 0x1a (26)
  UCHAR TranslationEnabled;   // offset: 0x1b (27)
};

// 0x28 (40) bytes
struct _DOMAIN_CONFIGURATION {
  enum _DOMAIN_CONFIGURATION_ARCH Type;     // offset: 0x0 (0)
  struct _DOMAIN_CONFIGURATION_ARM64 Arm64; // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _LOADER_PARAMETER_CI_EXTENSION {
  ULONG CodeIntegrityOptions;                  // offset: 0x0 (0)
  ULONG UpgradeInProgress : 1;                 // offset: 0x4 (4)
  ULONG IsWinPE : 1;                           // offset: 0x4 (4)
  ULONG CustomKernelSignersAllowed : 1;        // offset: 0x4 (4)
  ULONG StateSeparationEnabled : 1;            // offset: 0x4 (4)
  ULONG Reserved : 28;                         // offset: 0x4 (4)
  union _LARGE_INTEGER WhqlEnforcementDate;    // offset: 0x8 (8)
  ULONG RevocationListOffset;                  // offset: 0x10 (16)
  ULONG RevocationListSize;                    // offset: 0x14 (20)
  ULONG CodeIntegrityPolicyOffset;             // offset: 0x18 (24)
  ULONG CodeIntegrityPolicySize;               // offset: 0x1c (28)
  ULONG CodeIntegrityPolicyHashOffset;         // offset: 0x20 (32)
  ULONG CodeIntegrityPolicyHashSize;           // offset: 0x24 (36)
  ULONG CodeIntegrityPolicyOriginalHashOffset; // offset: 0x28 (40)
  ULONG CodeIntegrityPolicyOriginalHashSize;   // offset: 0x2c (44)
  LONG WeakCryptoPolicyLoadStatus;             // offset: 0x30 (48)
  ULONG WeakCryptoPolicyOffset;                // offset: 0x34 (52)
  ULONG WeakCryptoPolicySize;                  // offset: 0x38 (56)
  ULONG SecureBootPolicyOffset;                // offset: 0x3c (60)
  ULONG SecureBootPolicySize;                  // offset: 0x40 (64)
  ULONG Reserved2;                             // offset: 0x44 (68)
  UCHAR SerializedData[1];                     // offset: 0x48 (72)
};

// 0x20 (32) bytes
struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
  ULONG Version;                         // offset: 0x0 (0)
  ULONG AbnormalResetOccurred;           // offset: 0x4 (4)
  ULONG OfflineMemoryDumpCapable;        // offset: 0x8 (8)
  union _LARGE_INTEGER ResetDataAddress; // offset: 0x10 (16)
  ULONG ResetDataSize;                   // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct DEBUG_MEMORY_REQUIREMENTS {
  union _LARGE_INTEGER Start;  // offset: 0x0 (0)
  union _LARGE_INTEGER MaxEnd; // offset: 0x8 (8)
  VOID *VirtualAddress;        // offset: 0x10 (16)
  ULONG Length;                // offset: 0x18 (24)
  UCHAR Cached;                // offset: 0x1c (28)
  UCHAR Aligned;               // offset: 0x1d (29)
};

// 0xf8 (248) bytes
struct _DEBUG_DEVICE_DESCRIPTOR {
  ULONG Bus;       // offset: 0x0 (0)
  ULONG Slot;      // offset: 0x4 (4)
  USHORT Segment;  // offset: 0x8 (8)
  USHORT VendorID; // offset: 0xa (10)
  USHORT DeviceID; // offset: 0xc (12)
  UCHAR BaseClass; // offset: 0xe (14)
  UCHAR SubClass;  // offset: 0xf (15)
  UCHAR ProgIf;    // offset: 0x10 (16)
  union {
    UCHAR Flags; // offset: 0x11 (17)
    struct {
      UCHAR DbgHalScratchAllocated : 1; // offset: 0x11 (17)
      UCHAR DbgBarsMapped : 1;          // offset: 0x11 (17)
      UCHAR DbgScratchAllocated : 1;    // offset: 0x11 (17)
    };
  };
  UCHAR Initialized;                          // offset: 0x12 (18)
  UCHAR Configured;                           // offset: 0x13 (19)
  struct DEBUG_DEVICE_ADDRESS BaseAddress[6]; // offset: 0x18 (24)
  struct DEBUG_MEMORY_REQUIREMENTS Memory;    // offset: 0xa8 (168)
  ULONG Dbg2TableIndex;                       // offset: 0xc8 (200)
  USHORT PortType;                            // offset: 0xcc (204)
  USHORT PortSubtype;                         // offset: 0xce (206)
  VOID *OemData;                              // offset: 0xd0 (208)
  ULONG OemDataLength;                        // offset: 0xd8 (216)
  enum KD_NAMESPACE_ENUM NameSpace;           // offset: 0xdc (220)
  WCHAR *NameSpacePath;                       // offset: 0xe0 (224)
  ULONG NameSpacePathLength;                  // offset: 0xe8 (232)
  ULONG TransportType;                        // offset: 0xec (236)
  struct _DEBUG_TRANSPORT_DATA TransportData; // offset: 0xf0 (240)
};

// 0x118 (280) bytes
struct _TRACE_LOGFILE_HEADER {
  ULONG BufferSize; // offset: 0x0 (0)
  union {
    ULONG Version; // offset: 0x4 (4)
    struct {
      UCHAR MajorVersion;    // offset: 0x0 (0)
      UCHAR MinorVersion;    // offset: 0x1 (1)
      UCHAR SubVersion;      // offset: 0x2 (2)
      UCHAR SubMinorVersion; // offset: 0x3 (3)
    } VersionDetail;         // offset: 0x4 (4)
  };
  ULONG ProviderVersion;        // offset: 0x8 (8)
  ULONG NumberOfProcessors;     // offset: 0xc (12)
  union _LARGE_INTEGER EndTime; // offset: 0x10 (16)
  ULONG TimerResolution;        // offset: 0x18 (24)
  ULONG MaximumFileSize;        // offset: 0x1c (28)
  ULONG LogFileMode;            // offset: 0x20 (32)
  ULONG BuffersWritten;         // offset: 0x24 (36)
  union {
    struct _GUID LogInstanceGuid; // offset: 0x28 (40)
    struct {
      ULONG StartBuffers;  // offset: 0x28 (40)
      ULONG PointerSize;   // offset: 0x2c (44)
      ULONG EventsLost;    // offset: 0x30 (48)
      ULONG CpuSpeedInMHz; // offset: 0x34 (52)
    };
  };
  WCHAR *LoggerName;                          // offset: 0x38 (56)
  WCHAR *LogFileName;                         // offset: 0x40 (64)
  struct _RTL_TIME_ZONE_INFORMATION TimeZone; // offset: 0x48 (72)
  union _LARGE_INTEGER BootTime;              // offset: 0xf8 (248)
  union _LARGE_INTEGER PerfFreq;              // offset: 0x100 (256)
  union _LARGE_INTEGER StartTime;             // offset: 0x108 (264)
  ULONG ReservedFlags;                        // offset: 0x110 (272)
  ULONG BuffersLost;                          // offset: 0x114 (276)
};

// 0x48 (72) bytes
struct _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR {
  ULONG Version;                           // offset: 0x0 (0)
  ULONG Size;                              // offset: 0x4 (4)
  ULONG CryptoIndex;                       // offset: 0x8 (8)
  ULONG AlgorithmId;                       // offset: 0xc (12)
  ULONG DataUnitSize;                      // offset: 0x10 (16)
  ULONG KeySize;                           // offset: 0x14 (20)
  UCHAR KeyHash[32];                       // offset: 0x18 (24)
  VOID *KeyVirtualAddress;                 // offset: 0x38 (56)
  union _LARGE_INTEGER KeyPhysicalAddress; // offset: 0x40 (64)
};

// 0x28 (40) bytes
struct _VACB {
  VOID *BaseAddress;                        // offset: 0x0 (0)
  struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x8 (8)
  union {
    union _LARGE_INTEGER FileOffset; // offset: 0x10 (16)
    USHORT ActiveCount;              // offset: 0x10 (16)
    struct _LIST_ENTRY Links;        // offset: 0x10 (16)

  } Overlay;                            // offset: 0x10 (16)
  struct _VACB_ARRAY_HEADER *ArrayHead; // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _LOGGED_STREAM_CALLBACK_V1 {
  VOID *LogHandle; // offset: 0x0 (0)
  VOID (*FlushToLsnRoutine)
  (VOID *arg1, union _LARGE_INTEGER arg2); // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _PEP_ACPI_IO_MEMORY_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;   // offset: 0x0 (0)
  UCHAR Information;                   // offset: 0x4 (4)
  union _LARGE_INTEGER MinimumAddress; // offset: 0x8 (8)
  union _LARGE_INTEGER MaximumAddress; // offset: 0x10 (16)
  ULONG Alignment;                     // offset: 0x18 (24)
  ULONG Length;                        // offset: 0x1c (28)
};

// 0x20 (32) bytes
struct _HBIN {
  ULONG Signature;                // offset: 0x0 (0)
  ULONG FileOffset;               // offset: 0x4 (4)
  ULONG Size;                     // offset: 0x8 (8)
  ULONG Reserved1[2];             // offset: 0xc (12)
  union _LARGE_INTEGER TimeStamp; // offset: 0x14 (20)
  ULONG Spare;                    // offset: 0x1c (28)
};

// 0x40 (64) bytes
struct _FACS {
  ULONG Signature;                             // offset: 0x0 (0)
  ULONG Length;                                // offset: 0x4 (4)
  ULONG HardwareSignature;                     // offset: 0x8 (8)
  ULONG pFirmwareWakingVector;                 // offset: 0xc (12)
  ULONG GlobalLock;                            // offset: 0x10 (16)
  ULONG Flags;                                 // offset: 0x14 (20)
  union _LARGE_INTEGER x_FirmwareWakingVector; // offset: 0x18 (24)
  UCHAR version;                               // offset: 0x20 (32)
  UCHAR Reserved[31];                          // offset: 0x21 (33)
};

// 0x10 (16) bytes
struct _DMA_COMMON_BUFFER_ENTRY {
  VOID *VirtualAddress;                // offset: 0x0 (0)
  union _LARGE_INTEGER LogicalAddress; // offset: 0x8 (8)
};

// 0x40 (64) bytes
struct _ACPI_CACHED_TABLE {
  struct _LIST_ENTRY Links;             // offset: 0x0 (0)
  union _LARGE_INTEGER PhysicalAddress; // offset: 0x10 (16)
  struct _DESCRIPTION_HEADER Header;    // offset: 0x18 (24)
};

// 0xc (12) bytes
struct _GEN_ADDR {
  UCHAR AddressSpaceID;         // offset: 0x0 (0)
  UCHAR BitWidth;               // offset: 0x1 (1)
  UCHAR BitOffset;              // offset: 0x2 (2)
  UCHAR AccessSize;             // offset: 0x3 (3)
  union _LARGE_INTEGER Address; // offset: 0x4 (4)
};

// 0x10c (268) bytes
struct _FADT {
  struct _DESCRIPTION_HEADER Header;    // offset: 0x0 (0)
  ULONG facs;                           // offset: 0x24 (36)
  ULONG dsdt;                           // offset: 0x28 (40)
  UCHAR int_model;                      // offset: 0x2c (44)
  UCHAR pm_profile;                     // offset: 0x2d (45)
  USHORT sci_int_vector;                // offset: 0x2e (46)
  ULONG smi_cmd_io_port;                // offset: 0x30 (48)
  UCHAR acpi_on_value;                  // offset: 0x34 (52)
  UCHAR acpi_off_value;                 // offset: 0x35 (53)
  UCHAR s4bios_req;                     // offset: 0x36 (54)
  UCHAR pstate_control;                 // offset: 0x37 (55)
  ULONG pm1a_evt_blk_io_port;           // offset: 0x38 (56)
  ULONG pm1b_evt_blk_io_port;           // offset: 0x3c (60)
  ULONG pm1a_ctrl_blk_io_port;          // offset: 0x40 (64)
  ULONG pm1b_ctrl_blk_io_port;          // offset: 0x44 (68)
  ULONG pm2_ctrl_blk_io_port;           // offset: 0x48 (72)
  ULONG pm_tmr_blk_io_port;             // offset: 0x4c (76)
  ULONG gp0_blk_io_port;                // offset: 0x50 (80)
  ULONG gp1_blk_io_port;                // offset: 0x54 (84)
  UCHAR pm1_evt_len;                    // offset: 0x58 (88)
  UCHAR pm1_ctrl_len;                   // offset: 0x59 (89)
  UCHAR pm2_ctrl_len;                   // offset: 0x5a (90)
  UCHAR pm_tmr_len;                     // offset: 0x5b (91)
  UCHAR gp0_blk_len;                    // offset: 0x5c (92)
  UCHAR gp1_blk_len;                    // offset: 0x5d (93)
  UCHAR gp1_base;                       // offset: 0x5e (94)
  UCHAR cstate_control;                 // offset: 0x5f (95)
  USHORT lvl2_latency;                  // offset: 0x60 (96)
  USHORT lvl3_latency;                  // offset: 0x62 (98)
  USHORT flush_size;                    // offset: 0x64 (100)
  USHORT flush_stride;                  // offset: 0x66 (102)
  UCHAR duty_offset;                    // offset: 0x68 (104)
  UCHAR duty_width;                     // offset: 0x69 (105)
  UCHAR day_alarm_index;                // offset: 0x6a (106)
  UCHAR month_alarm_index;              // offset: 0x6b (107)
  UCHAR century_alarm_index;            // offset: 0x6c (108)
  USHORT boot_arch;                     // offset: 0x6d (109)
  UCHAR reserved3[1];                   // offset: 0x6f (111)
  ULONG flags;                          // offset: 0x70 (112)
  struct _GEN_ADDR reset_reg;           // offset: 0x74 (116)
  UCHAR reset_val;                      // offset: 0x80 (128)
  USHORT arm_boot_arch;                 // offset: 0x81 (129)
  UCHAR minor_version_number;           // offset: 0x83 (131)
  union _LARGE_INTEGER x_firmware_ctrl; // offset: 0x84 (132)
  union _LARGE_INTEGER x_dsdt;          // offset: 0x8c (140)
  struct _GEN_ADDR x_pm1a_evt_blk;      // offset: 0x94 (148)
  struct _GEN_ADDR x_pm1b_evt_blk;      // offset: 0xa0 (160)
  struct _GEN_ADDR x_pm1a_ctrl_blk;     // offset: 0xac (172)
  struct _GEN_ADDR x_pm1b_ctrl_blk;     // offset: 0xb8 (184)
  struct _GEN_ADDR x_pm2_ctrl_blk;      // offset: 0xc4 (196)
  struct _GEN_ADDR x_pm_tmr_blk;        // offset: 0xd0 (208)
  struct _GEN_ADDR x_gp0_blk;           // offset: 0xdc (220)
  struct _GEN_ADDR x_gp1_blk;           // offset: 0xe8 (232)
  struct _GEN_ADDR sleep_control_reg;   // offset: 0xf4 (244)
  struct _GEN_ADDR sleep_status_reg;    // offset: 0x100 (256)
};

// 0x34 (52) bytes
struct _WHEA_GENERIC_ERROR_DESCRIPTOR {
  USHORT Type;                                 // offset: 0x0 (0)
  UCHAR Reserved;                              // offset: 0x2 (2)
  UCHAR Enabled;                               // offset: 0x3 (3)
  ULONG ErrStatusBlockLength;                  // offset: 0x4 (4)
  ULONG RelatedErrorSourceId;                  // offset: 0x8 (8)
  UCHAR ErrStatusAddressSpaceID;               // offset: 0xc (12)
  UCHAR ErrStatusAddressBitWidth;              // offset: 0xd (13)
  UCHAR ErrStatusAddressBitOffset;             // offset: 0xe (14)
  UCHAR ErrStatusAddressAccessSize;            // offset: 0xf (15)
  union _LARGE_INTEGER ErrStatusAddress;       // offset: 0x10 (16)
  struct _WHEA_NOTIFICATION_DESCRIPTOR Notify; // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _MAILSLOT_CREATE_PARAMETERS {
  ULONG MailslotQuota;              // offset: 0x0 (0)
  ULONG MaximumMessageSize;         // offset: 0x4 (4)
  union _LARGE_INTEGER ReadTimeout; // offset: 0x8 (8)
  UCHAR TimeoutSpecified;           // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _NAMED_PIPE_CREATE_PARAMETERS {
  ULONG NamedPipeType;                 // offset: 0x0 (0)
  ULONG ReadMode;                      // offset: 0x4 (4)
  ULONG CompletionMode;                // offset: 0x8 (8)
  ULONG MaximumInstances;              // offset: 0xc (12)
  ULONG InboundQuota;                  // offset: 0x10 (16)
  ULONG OutboundQuota;                 // offset: 0x14 (20)
  union _LARGE_INTEGER DefaultTimeout; // offset: 0x18 (24)
  UCHAR TimeoutSpecified;              // offset: 0x20 (32)
};

// 0x38 (56) bytes
struct _FILE_NETWORK_OPEN_INFORMATION {
  union _LARGE_INTEGER CreationTime;   // offset: 0x0 (0)
  union _LARGE_INTEGER LastAccessTime; // offset: 0x8 (8)
  union _LARGE_INTEGER LastWriteTime;  // offset: 0x10 (16)
  union _LARGE_INTEGER ChangeTime;     // offset: 0x18 (24)
  union _LARGE_INTEGER AllocationSize; // offset: 0x20 (32)
  union _LARGE_INTEGER EndOfFile;      // offset: 0x28 (40)
  ULONG FileAttributes;                // offset: 0x30 (48)
};

// 0x18 (24) bytes
struct _FILE_STANDARD_INFORMATION {
  union _LARGE_INTEGER AllocationSize; // offset: 0x0 (0)
  union _LARGE_INTEGER EndOfFile;      // offset: 0x8 (8)
  ULONG NumberOfLinks;                 // offset: 0x10 (16)
  UCHAR DeletePending;                 // offset: 0x14 (20)
  UCHAR Directory;                     // offset: 0x15 (21)
};

// 0x28 (40) bytes
struct _FILE_BASIC_INFORMATION {
  union _LARGE_INTEGER CreationTime;   // offset: 0x0 (0)
  union _LARGE_INTEGER LastAccessTime; // offset: 0x8 (8)
  union _LARGE_INTEGER LastWriteTime;  // offset: 0x10 (16)
  union _LARGE_INTEGER ChangeTime;     // offset: 0x18 (24)
  ULONG FileAttributes;                // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _ETW_REF_CLOCK {
  union _LARGE_INTEGER StartTime;      // offset: 0x0 (0)
  union _LARGE_INTEGER StartPerfClock; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _ETW_LAST_ENABLE_INFO {
  union _LARGE_INTEGER EnableFlags; // offset: 0x0 (0)
  USHORT LoggerId;                  // offset: 0x8 (8)
  UCHAR Level;                      // offset: 0xa (10)
  UCHAR Enabled : 1;                // offset: 0xb (11)
  UCHAR InternalFlag : 7;           // offset: 0xb (11)
};

// 0x270 (624) bytes
struct _SILO_USER_SHARED_DATA {
  ULONG ServiceSessionId;                          // offset: 0x0 (0)
  ULONG ActiveConsoleId;                           // offset: 0x4 (4)
  LONGLONG ConsoleSessionForegroundProcessId;      // offset: 0x8 (8)
  enum _NT_PRODUCT_TYPE NtProductType;             // offset: 0x10 (16)
  ULONG SuiteMask;                                 // offset: 0x14 (20)
  ULONG SharedUserSessionId;                       // offset: 0x18 (24)
  UCHAR IsMultiSessionSku;                         // offset: 0x1c (28)
  WCHAR NtSystemRoot[260];                         // offset: 0x1e (30)
  USHORT UserModeGlobalLogger[16];                 // offset: 0x226 (550)
  ULONG TimeZoneId;                                // offset: 0x248 (584)
  volatile LONG TimeZoneBiasStamp;                 // offset: 0x24c (588)
  struct _KSYSTEM_TIME TimeZoneBias;               // offset: 0x250 (592)
  union _LARGE_INTEGER TimeZoneBiasEffectiveStart; // offset: 0x260 (608)
  union _LARGE_INTEGER TimeZoneBiasEffectiveEnd;   // offset: 0x268 (616)
};

// 0x10 (16) bytes
struct _LEAP_SECOND_DATA {
  UCHAR Enabled;                // offset: 0x0 (0)
  ULONG Count;                  // offset: 0x4 (4)
  union _LARGE_INTEGER Data[1]; // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _SEP_RM_LSA_CONNECTION_STATE {
  VOID *LsaProcessHandle;                         // offset: 0x0 (0)
  VOID *LsaCommandPortHandle;                     // offset: 0x8 (8)
  VOID *SepRmThreadHandle;                        // offset: 0x10 (16)
  VOID *RmCommandPortHandle;                      // offset: 0x18 (24)
  VOID *RmCommandServerPortHandle;                // offset: 0x20 (32)
  VOID *LsaCommandPortSectionHandle;              // offset: 0x28 (40)
  union _LARGE_INTEGER LsaCommandPortSectionSize; // offset: 0x30 (48)
  VOID *LsaViewPortMemory;                        // offset: 0x38 (56)
  VOID *RmViewPortMemory;                         // offset: 0x40 (64)
  LONG LsaCommandPortMemoryDelta;                 // offset: 0x48 (72)
  UCHAR LsaCommandPortActive;                     // offset: 0x4c (76)
};

// 0x38 (56) bytes
struct _RTL_QUERY_REGISTRY_TABLE {
  LONG (*QueryRoutine)
  (WCHAR *arg1, ULONG arg2, VOID *arg3, ULONG arg4, VOID *arg5,
   VOID *arg6);        // offset: 0x0 (0)
  ULONG Flags;         // offset: 0x8 (8)
  WCHAR *Name;         // offset: 0x10 (16)
  VOID *EntryContext;  // offset: 0x18 (24)
  ULONG DefaultType;   // offset: 0x20 (32)
  VOID *DefaultData;   // offset: 0x28 (40)
  ULONG DefaultLength; // offset: 0x30 (48)
};

// 0x8 (8) bytes
struct LIST_ENTRY32 {
  ULONG Flink; // offset: 0x0 (0)
  ULONG Blink; // offset: 0x4 (4)
};

// 0x18 (24) bytes
struct _ACTIVATION_CONTEXT_STACK32 {
  ULONG ActiveFrame;                  // offset: 0x0 (0)
  struct LIST_ENTRY32 FrameListCache; // offset: 0x4 (4)
  ULONG Flags;                        // offset: 0xc (12)
  ULONG NextCookieSequenceNumber;     // offset: 0x10 (16)
  ULONG StackId;                      // offset: 0x14 (20)
};

// 0x38 (56) bytes
struct _BLOB_TYPE {
  enum _BLOB_ID ResourceId;             // offset: 0x0 (0)
  ULONG PoolTag;                        // offset: 0x4 (4)
  ULONG LookasideIndex;                 // offset: 0x8 (8)
  ULONG Flags;                          // offset: 0xc (12)
  struct _BLOB_COUNTERS *Counters;      // offset: 0x10 (16)
  VOID (*CleanupProcedure)(VOID *arg1); // offset: 0x18 (24)
  VOID (*DeleteProcedure)(VOID *arg1);  // offset: 0x20 (32)
  LONG (*DestroyProcedure)(VOID *arg1); // offset: 0x28 (40)
  ULONGLONG UsualSize;                  // offset: 0x30 (48)
};

// 0x38 (56) bytes
struct _MI_TRIAGE_DUMP_DATA {
  ULONGLONG BadPageCount;                 // offset: 0x0 (0)
  LONG BadPagesDetected;                  // offset: 0x8 (8)
  LONG ZeroedPageSingleBitErrorsDetected; // offset: 0xc (12)
  LONG ScrubPasses;                       // offset: 0x10 (16)
  LONG ScrubBadPagesFound;                // offset: 0x14 (20)
  ULONG PageHashErrors;                   // offset: 0x18 (24)
  ULONGLONG FeatureBits;                  // offset: 0x20 (32)
  ULONG TimeZoneId;                       // offset: 0x28 (40)
  union _MI_FLAGS Flags;                  // offset: 0x2c (44)
  VOID *VsmConnection;                    // offset: 0x30 (48)
};

// 0x58 (88) bytes
struct _THERMAL_INFORMATION {
  ULONG ThermalStamp;         // offset: 0x0 (0)
  ULONG ThermalConstant1;     // offset: 0x4 (4)
  ULONG ThermalConstant2;     // offset: 0x8 (8)
  ULONGLONG Processors;       // offset: 0x10 (16)
  ULONG SamplingPeriod;       // offset: 0x18 (24)
  ULONG CurrentTemperature;   // offset: 0x1c (28)
  ULONG PassiveTripPoint;     // offset: 0x20 (32)
  ULONG CriticalTripPoint;    // offset: 0x24 (36)
  UCHAR ActiveTripPointCount; // offset: 0x28 (40)
  ULONG ActiveTripPoint[10];  // offset: 0x2c (44)
};

// 0x38 (56) bytes
struct _RTLP_RANGE_LIST_ENTRY {
  ULONGLONG Start; // offset: 0x0 (0)
  ULONGLONG End;   // offset: 0x8 (8)
  union {
    struct {
      VOID *UserData; // offset: 0x0 (0)
      VOID *Owner;    // offset: 0x8 (8)
    } Allocated;      // offset: 0x10 (16)
    struct {
      struct _LIST_ENTRY ListHead; // offset: 0x0 (0)
    } Merged;                      // offset: 0x10 (16)
  };
  UCHAR Attributes;             // offset: 0x20 (32)
  UCHAR PublicFlags;            // offset: 0x21 (33)
  USHORT PrivateFlags;          // offset: 0x22 (34)
  struct _LIST_ENTRY ListEntry; // offset: 0x28 (40)
};

// 0x30 (48) bytes
struct _HEAP_UCR_DESCRIPTOR {
  struct _LIST_ENTRY ListEntry;    // offset: 0x0 (0)
  struct _LIST_ENTRY SegmentEntry; // offset: 0x10 (16)
  VOID *Address;                   // offset: 0x20 (32)
  ULONGLONG Size;                  // offset: 0x28 (40)
};

// 0xf0 (240) bytes
struct _ETW_WMITRACE_WORK {
  ULONG LoggerId;      // offset: 0x0 (0)
  ULONG SiloSessionId; // offset: 0x4 (4)
  union {
    struct {
      CHAR LoggerName[65];   // offset: 0x8 (8)
      CHAR FileName[129];    // offset: 0x49 (73)
      ULONG MaximumFileSize; // offset: 0xcc (204)
      ULONG MinBuffers;      // offset: 0xd0 (208)
      ULONG MaxBuffers;      // offset: 0xd4 (212)
      ULONG BufferSize;      // offset: 0xd8 (216)
      ULONG Mode;            // offset: 0xdc (220)
      ULONG FlushTimer;      // offset: 0xe0 (224)
    };
    struct {
      ULONGLONG MatchAny;   // offset: 0x8 (8)
      ULONGLONG MatchAll;   // offset: 0x10 (16)
      ULONG EnableProperty; // offset: 0x18 (24)
      struct _GUID Guid;    // offset: 0x1c (28)
      UCHAR Level;          // offset: 0x2c (44)
    };
  };
  LONG Status; // offset: 0xe8 (232)
};

// 0x18 (24) bytes
struct _KTIMER2_COLLECTION {
  struct _RTL_RB_TREE Tree; // offset: 0x0 (0)
  ULONGLONG NextDueTime;    // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _MI_VAD_SEQUENTIAL_INFO {
  ULONGLONG Length : 12; // offset: 0x0 (0)
  ULONGLONG Vpn : 52;    // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _POOL_TRACKER_BIG_PAGES {
  volatile ULONGLONG Va;   // offset: 0x0 (0)
  ULONG Key;               // offset: 0x8 (8)
  ULONG Pattern : 8;       // offset: 0xc (12)
  ULONG PoolType : 12;     // offset: 0xc (12)
  ULONG SlushSize : 12;    // offset: 0xc (12)
  ULONGLONG NumberOfBytes; // offset: 0x10 (16)
};

// 0x408 (1032) bytes
struct _CALL_PERFORMANCE_DATA {
  ULONGLONG SpinLock;               // offset: 0x0 (0)
  struct _LIST_ENTRY HashTable[64]; // offset: 0x8 (8)
};

// 0x30 (48) bytes
struct _CRITICAL_PROCESS_EXCEPTION_DATA {
  struct _GUID ReportId;             // offset: 0x0 (0)
  struct _UNICODE_STRING ModuleName; // offset: 0x10 (16)
  ULONG ModuleTimestamp;             // offset: 0x20 (32)
  ULONG ModuleSize;                  // offset: 0x24 (36)
  ULONGLONG Offset;                  // offset: 0x28 (40)
};

// 0x80 (128) bytes
struct _PTE_TRACKER {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
  struct _MDL *Mdl;             // offset: 0x10 (16)
  ULONGLONG Count;              // offset: 0x18 (24)
  VOID *SystemVa;               // offset: 0x20 (32)
  VOID *StartVa;                // offset: 0x28 (40)
  ULONG Offset;                 // offset: 0x30 (48)
  ULONG Length;                 // offset: 0x34 (52)
  ULONGLONG Page;               // offset: 0x38 (56)
  ULONG IoMapping : 1;          // offset: 0x40 (64)
  ULONG Matched : 1;            // offset: 0x40 (64)
  ULONG CacheAttribute : 2;     // offset: 0x40 (64)
  ULONG GuardPte : 1;           // offset: 0x40 (64)
  ULONG Spare : 27;             // offset: 0x40 (64)
  VOID *StackTrace[7];          // offset: 0x48 (72)
};

// 0x8180 (33152) bytes
struct _VI_DEADLOCK_GLOBALS {
  LONGLONG TimeAcquire;                                // offset: 0x0 (0)
  LONGLONG TimeRelease;                                // offset: 0x8 (8)
  struct _LIST_ENTRY *ResourceDatabase;                // offset: 0x10 (16)
  ULONGLONG ResourceDatabaseCount;                     // offset: 0x18 (24)
  struct _VF_ADDRESS_RANGE ResourceAddressRange[1023]; // offset: 0x20 (32)
  struct _LIST_ENTRY *ThreadDatabase;                  // offset: 0x4010 (16400)
  ULONGLONG ThreadDatabaseCount;                       // offset: 0x4018 (16408)
  struct _VF_ADDRESS_RANGE ThreadAddressRange[1023];   // offset: 0x4020 (16416)
  volatile ULONG AllocationFailures;                   // offset: 0x8010 (32784)
  ULONG NodesTrimmedBasedOnAge;                        // offset: 0x8014 (32788)
  ULONG NodesTrimmedBasedOnCount;                      // offset: 0x8018 (32792)
  ULONG NodesSearched;                                 // offset: 0x801c (32796)
  ULONG MaxNodesSearched;                              // offset: 0x8020 (32800)
  ULONG SequenceNumber;                                // offset: 0x8024 (32804)
  ULONG RecursionDepthLimit;                           // offset: 0x8028 (32808)
  ULONG SearchedNodesLimit;                            // offset: 0x802c (32812)
  ULONG DepthLimitHits;                                // offset: 0x8030 (32816)
  ULONG SearchLimitHits;                               // offset: 0x8034 (32820)
  ULONG StackLimitHits;                                // offset: 0x8038 (32824)
  ULONG ABC_ACB_Skipped;                               // offset: 0x803c (32828)
  ULONG OutOfOrderReleases;                            // offset: 0x8040 (32832)
  ULONG NodesReleasedOutOfOrder;                       // offset: 0x8044 (32836)
  ULONG TotalReleases;                                 // offset: 0x8048 (32840)
  ULONG RootNodesDeleted;                              // offset: 0x804c (32844)
  ULONG ForgetHistoryCounter;                          // offset: 0x8050 (32848)
  VOID *Instigator;                                    // offset: 0x8058 (32856)
  ULONG NumberOfParticipants;                          // offset: 0x8060 (32864)
  struct _VI_DEADLOCK_NODE *Participant[32];           // offset: 0x8068 (32872)
  LONG ChildrenCountWatermark;                         // offset: 0x8168 (33128)
  enum _KERNEL_STACK_LIMITS StackType;                 // offset: 0x816c (33132)
  ULONGLONG StackLowLimit;                             // offset: 0x8170 (33136)
  ULONGLONG StackHighLimit;                            // offset: 0x8178 (33144)
};

// 0x68 (104) bytes
struct _FAST_ERESOURCE_INTERNAL {
  struct _LIST_ENTRY SystemResourcesList; // offset: 0x0 (0)
  VOID *ReservedPointer;                  // offset: 0x10 (16)
  SHORT ActiveCount;                      // offset: 0x18 (24)
  USHORT Flag;                            // offset: 0x1a (26)
  struct _KWAIT_CHAIN SharedWaiters;      // offset: 0x20 (32)
  struct _KWAIT_CHAIN ExclusiveWaiters;   // offset: 0x28 (40)
  struct _LIST_ENTRY OwnerEntryListHead;  // offset: 0x30 (48)
  ULONG ActiveEntries;                    // offset: 0x40 (64)
  ULONG ContentionCount;                  // offset: 0x44 (68)
  ULONG NumberOfSharedWaiters;            // offset: 0x48 (72)
  ULONG NumberOfExclusiveWaiters;         // offset: 0x4c (76)
  VOID *ReservedWin64OnlyPointer;         // offset: 0x50 (80)
  union {
    VOID *Address;                   // offset: 0x58 (88)
    ULONGLONG CreatorBackTraceIndex; // offset: 0x58 (88)
  };
  ULONGLONG SpinLock; // offset: 0x60 (96)
};

// 0x1f8 (504) bytes
struct _PO_HIBER_PERF {
  ULONGLONG HiberIoTicks;                          // offset: 0x0 (0)
  ULONGLONG HiberIoCpuTicks;                       // offset: 0x8 (8)
  ULONGLONG HiberInitTicks;                        // offset: 0x10 (16)
  ULONGLONG HiberHiberFileTicks;                   // offset: 0x18 (24)
  ULONGLONG HiberCompressTicks;                    // offset: 0x20 (32)
  ULONGLONG HiberSharedBufferTicks;                // offset: 0x28 (40)
  ULONGLONG HiberChecksumTicks;                    // offset: 0x30 (48)
  ULONGLONG HiberChecksumIoTicks;                  // offset: 0x38 (56)
  union _LARGE_INTEGER TotalHibernateTime;         // offset: 0x40 (64)
  union _LARGE_INTEGER HibernateCompleteTimestamp; // offset: 0x48 (72)
  ULONG POSTTime;                                  // offset: 0x50 (80)
  ULONG ResumeBootMgrTime;                         // offset: 0x54 (84)
  ULONG BootmgrUserInputTime;                      // offset: 0x58 (88)
  ULONGLONG ResumeAppTicks;                        // offset: 0x60 (96)
  ULONGLONG ResumeAppStartTimestamp;               // offset: 0x68 (104)
  ULONGLONG ResumeLibraryInitTicks;                // offset: 0x70 (112)
  ULONGLONG ResumeInitTicks;                       // offset: 0x78 (120)
  ULONGLONG ResumeRestoreImageStartTimestamp;      // offset: 0x80 (128)
  ULONGLONG ResumeHiberFileTicks;                  // offset: 0x88 (136)
  ULONGLONG ResumeIoTicks;                         // offset: 0x90 (144)
  ULONGLONG ResumeDecompressTicks;                 // offset: 0x98 (152)
  ULONGLONG ResumeAllocateTicks;                   // offset: 0xa0 (160)
  ULONGLONG ResumeUserInOutTicks;                  // offset: 0xa8 (168)
  ULONGLONG ResumeMapTicks;                        // offset: 0xb0 (176)
  ULONGLONG ResumeUnmapTicks;                      // offset: 0xb8 (184)
  ULONGLONG ResumeChecksumTicks;                   // offset: 0xc0 (192)
  ULONGLONG ResumeChecksumIoTicks;                 // offset: 0xc8 (200)
  ULONGLONG ResumeKernelSwitchTimestamp;           // offset: 0xd0 (208)
  ULONGLONG CyclesPerMs;                           // offset: 0xd8 (216)
  ULONGLONG WriteLogDataTimestamp;                 // offset: 0xe0 (224)
  ULONGLONG KernelReturnFromHandler;               // offset: 0xe8 (232)
  ULONGLONG TimeStampCounterAtSwitchTime;          // offset: 0xf0 (240)
  ULONGLONG HalTscOffset;                          // offset: 0xf8 (248)
  ULONGLONG HvlTscOffset;                          // offset: 0x100 (256)
  ULONGLONG SleeperThreadEnd;                      // offset: 0x108 (264)
  ULONGLONG PostCmosUpdateTimestamp;               // offset: 0x110 (272)
  ULONGLONG KernelReturnSystemPowerStateTimestamp; // offset: 0x118 (280)
  ULONGLONG IoBoundedness;                         // offset: 0x120 (288)
  ULONGLONG KernelDecompressTicks;                 // offset: 0x128 (296)
  ULONGLONG KernelIoTicks;                         // offset: 0x130 (304)
  ULONGLONG KernelCopyTicks;                       // offset: 0x138 (312)
  ULONGLONG ReadCheckCount;                        // offset: 0x140 (320)
  ULONGLONG KernelInitTicks;                       // offset: 0x148 (328)
  ULONGLONG KernelResumeHiberFileTicks;            // offset: 0x150 (336)
  ULONGLONG KernelIoCpuTicks;                      // offset: 0x158 (344)
  ULONGLONG KernelSharedBufferTicks;               // offset: 0x160 (352)
  ULONGLONG KernelAnimationTicks;                  // offset: 0x168 (360)
  ULONGLONG KernelChecksumTicks;                   // offset: 0x170 (368)
  ULONGLONG KernelChecksumIoTicks;                 // offset: 0x178 (376)
  union _LARGE_INTEGER AnimationStart;             // offset: 0x180 (384)
  union _LARGE_INTEGER AnimationStop;              // offset: 0x188 (392)
  ULONG DeviceResumeTime;                          // offset: 0x190 (400)
  ULONGLONG SecurePagesProcessed;                  // offset: 0x198 (408)
  ULONGLONG BootPagesProcessed;                    // offset: 0x1a0 (416)
  ULONGLONG KernelPagesProcessed;                  // offset: 0x1a8 (424)
  ULONGLONG BootBytesWritten;                      // offset: 0x1b0 (432)
  ULONGLONG KernelBytesWritten;                    // offset: 0x1b8 (440)
  ULONGLONG BootPagesWritten;                      // offset: 0x1c0 (448)
  ULONGLONG KernelPagesWritten;                    // offset: 0x1c8 (456)
  ULONGLONG BytesWritten;                          // offset: 0x1d0 (464)
  ULONG PagesWritten;                              // offset: 0x1d8 (472)
  ULONG FileRuns;                                  // offset: 0x1dc (476)
  ULONG NoMultiStageResumeReason;                  // offset: 0x1e0 (480)
  ULONG MaxHuffRatio;                              // offset: 0x1e4 (484)
  ULONGLONG AdjustedTotalResumeTime;               // offset: 0x1e8 (488)
  ULONGLONG ResumeCompleteTimestamp;               // offset: 0x1f0 (496)
};

// 0x70 (112) bytes
struct _POP_IO_INFO {
  struct _MDL *DumpMdl;            // offset: 0x0 (0)
  enum _POP_IO_STATUS IoStatus;    // offset: 0x8 (8)
  ULONGLONG IoStartCount;          // offset: 0x10 (16)
  ULONGLONG IoBytesCompleted;      // offset: 0x18 (24)
  ULONGLONG IoBytesInProgress;     // offset: 0x20 (32)
  ULONGLONG RequestSize;           // offset: 0x28 (40)
  union _LARGE_INTEGER IoLocation; // offset: 0x30 (48)
  ULONGLONG FileOffset;            // offset: 0x38 (56)
  VOID *Buffer;                    // offset: 0x40 (64)
  UCHAR AsyncCapable;              // offset: 0x48 (72)
  ULONGLONG BytesToRead;           // offset: 0x50 (80)
  ULONG Pages;                     // offset: 0x58 (88)
  ULONGLONG HighestChecksumIndex;  // offset: 0x60 (96)
  USHORT PreviousChecksum;         // offset: 0x68 (104)
};

// 0x28 (40) bytes
struct _DIAGNOSTIC_BUFFER {
  ULONGLONG Size;                  // offset: 0x0 (0)
  enum _REQUESTER_TYPE CallerType; // offset: 0x8 (8)
  union {
    struct {
      ULONGLONG ProcessImageNameOffset; // offset: 0x10 (16)
      ULONG ProcessId;                  // offset: 0x18 (24)
      ULONG ServiceTag;                 // offset: 0x1c (28)
    };
    struct {
      ULONGLONG DeviceDescriptionOffset; // offset: 0x10 (16)
      ULONGLONG DevicePathOffset;        // offset: 0x18 (24)
    };
  };
  ULONGLONG ReasonOffset; // offset: 0x20 (32)
};

// 0x8 (8) bytes
union _PS_INTERLOCKED_TIMER_DELAY_VALUES {
  ULONGLONG DelayMs : 30;            // offset: 0x0 (0)
  ULONGLONG CoalescingWindowMs : 30; // offset: 0x0 (0)
  ULONGLONG Reserved : 1;            // offset: 0x0 (0)
  ULONGLONG NewTimerWheel : 1;       // offset: 0x0 (0)
  ULONGLONG Retry : 1;               // offset: 0x0 (0)
  ULONGLONG Locked : 1;              // offset: 0x0 (0)
  ULONGLONG All;                     // offset: 0x0 (0)
};

// 0x48 (72) bytes
struct _ETWP_NOTIFICATION_HEADER {
  enum _ETW_NOTIFICATION_TYPE NotificationType; // offset: 0x0 (0)
  ULONG NotificationSize;                       // offset: 0x4 (4)
  LONG RefCount;                                // offset: 0x8 (8)
  UCHAR ReplyRequested;                         // offset: 0xc (12)
  union {
    ULONG ReplyIndex; // offset: 0x10 (16)
    ULONG Timeout;    // offset: 0x10 (16)
  };
  union {
    ULONG ReplyCount;    // offset: 0x14 (20)
    ULONG NotifyeeCount; // offset: 0x14 (20)
  };
  union {
    ULONGLONG ReplyHandle; // offset: 0x18 (24)
    VOID *ReplyObject;     // offset: 0x18 (24)
    ULONG RegIndex;        // offset: 0x18 (24)
  };
  ULONG TargetPID;              // offset: 0x20 (32)
  ULONG SourcePID;              // offset: 0x24 (36)
  struct _GUID DestinationGuid; // offset: 0x28 (40)
  struct _GUID SourceGuid;      // offset: 0x38 (56)
};

// 0x8 (8) bytes
struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES {
  ULONGLONG NumberOfPtes : 6;   // offset: 0x0 (0)
  ULONGLONG PartitionId : 10;   // offset: 0x0 (0)
  ULONGLONG SectionOffset : 48; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _VI_POOL_ENTRY_INUSE {
  VOID *VirtualAddress;    // offset: 0x0 (0)
  VOID *CallingAddress;    // offset: 0x8 (8)
  ULONGLONG NumberOfBytes; // offset: 0x10 (16)
  ULONGLONG Tag;           // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _VI_POOL_PAGE_HEADER {
  struct _SLIST_ENTRY *NextPage; // offset: 0x0 (0)
  VOID *VerifierEntry;           // offset: 0x8 (8)
  ULONGLONG Signature;           // offset: 0x10 (16)
};

// 0x20 (32) bytes
struct _VI_POOL_ENTRY {
  union {
    struct _VI_POOL_PAGE_HEADER PageHeader; // offset: 0x0 (0)
    struct _VI_POOL_ENTRY_INUSE InUse;      // offset: 0x0 (0)
    struct _SLIST_ENTRY *NextFree;          // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
struct _VI_VERIFIER_POOL_HEADER {
  struct _VI_POOL_ENTRY *VerifierPoolEntry; // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _WHEA_ERROR_STATUS {
  ULONGLONG ErrorStatus;    // offset: 0x0 (0)
  ULONGLONG Reserved1 : 8;  // offset: 0x0 (0)
  ULONGLONG ErrorType : 8;  // offset: 0x0 (0)
  ULONGLONG Address : 1;    // offset: 0x0 (0)
  ULONGLONG Control : 1;    // offset: 0x0 (0)
  ULONGLONG Data : 1;       // offset: 0x0 (0)
  ULONGLONG Responder : 1;  // offset: 0x0 (0)
  ULONGLONG Requester : 1;  // offset: 0x0 (0)
  ULONGLONG FirstError : 1; // offset: 0x0 (0)
  ULONGLONG Overflow : 1;   // offset: 0x0 (0)
  ULONGLONG Reserved2 : 41; // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
  ULONGLONG ErrorStatus : 1;         // offset: 0x0 (0)
  ULONGLONG PhysicalAddress : 1;     // offset: 0x0 (0)
  ULONGLONG PhysicalAddressMask : 1; // offset: 0x0 (0)
  ULONGLONG Node : 1;                // offset: 0x0 (0)
  ULONGLONG Card : 1;                // offset: 0x0 (0)
  ULONGLONG Module : 1;              // offset: 0x0 (0)
  ULONGLONG Bank : 1;                // offset: 0x0 (0)
  ULONGLONG Device : 1;              // offset: 0x0 (0)
  ULONGLONG Row : 1;                 // offset: 0x0 (0)
  ULONGLONG Column : 1;              // offset: 0x0 (0)
  ULONGLONG BitPosition : 1;         // offset: 0x0 (0)
  ULONGLONG RequesterId : 1;         // offset: 0x0 (0)
  ULONGLONG ResponderId : 1;         // offset: 0x0 (0)
  ULONGLONG TargetId : 1;            // offset: 0x0 (0)
  ULONGLONG ErrorType : 1;           // offset: 0x0 (0)
  ULONGLONG RankNumber : 1;          // offset: 0x0 (0)
  ULONGLONG CardHandle : 1;          // offset: 0x0 (0)
  ULONGLONG ModuleHandle : 1;        // offset: 0x0 (0)
  ULONGLONG ExtendedRow : 1;         // offset: 0x0 (0)
  ULONGLONG BankGroup : 1;           // offset: 0x0 (0)
  ULONGLONG BankAddress : 1;         // offset: 0x0 (0)
  ULONGLONG ChipIdentification : 1;  // offset: 0x0 (0)
  ULONGLONG Reserved : 42;           // offset: 0x0 (0)
  ULONGLONG ValidBits;               // offset: 0x0 (0)
};

// 0x50 (80) bytes
struct _WHEA_MEMORY_ERROR_SECTION {
  union _WHEA_MEMORY_ERROR_SECTION_VALIDBITS ValidBits; // offset: 0x0 (0)
  union _WHEA_ERROR_STATUS ErrorStatus;                 // offset: 0x8 (8)
  ULONGLONG PhysicalAddress;                            // offset: 0x10 (16)
  ULONGLONG PhysicalAddressMask;                        // offset: 0x18 (24)
  USHORT Node;                                          // offset: 0x20 (32)
  USHORT Card;                                          // offset: 0x22 (34)
  USHORT Module;                                        // offset: 0x24 (36)
  USHORT Bank;                                          // offset: 0x26 (38)
  USHORT Device;                                        // offset: 0x28 (40)
  USHORT Row;                                           // offset: 0x2a (42)
  USHORT Column;                                        // offset: 0x2c (44)
  USHORT BitPosition;                                   // offset: 0x2e (46)
  ULONGLONG RequesterId;                                // offset: 0x30 (48)
  ULONGLONG ResponderId;                                // offset: 0x38 (56)
  ULONGLONG TargetId;                                   // offset: 0x40 (64)
  UCHAR ErrorType;                                      // offset: 0x48 (72)
  UCHAR Extended;                                       // offset: 0x49 (73)
  USHORT RankNumber;                                    // offset: 0x4a (74)
  USHORT CardHandle;                                    // offset: 0x4c (76)
  USHORT ModuleHandle;                                  // offset: 0x4e (78)
};

// 0x10 (16) bytes
struct _TraceLoggingMetadata_t {
  ULONG Signature; // offset: 0x0 (0)
  USHORT Size;     // offset: 0x4 (4)
  UCHAR Version;   // offset: 0x6 (6)
  UCHAR Flags;     // offset: 0x7 (7)
  ULONGLONG Magic; // offset: 0x8 (8)
};

// 0x30 (48) bytes
struct _WNF_DELIVERY_DESCRIPTOR {
  ULONGLONG SubscriptionId;         // offset: 0x0 (0)
  struct _WNF_STATE_NAME StateName; // offset: 0x8 (8)
  ULONG ChangeStamp;                // offset: 0x10 (16)
  ULONG StateDataSize;              // offset: 0x14 (20)
  ULONG EventMask;                  // offset: 0x18 (24)
  struct _WNF_TYPE_ID TypeId;       // offset: 0x1c (28)
  ULONG StateDataOffset;            // offset: 0x2c (44)
};

// 0xa8 (168) bytes
struct _MM_DRIVER_VERIFIER_DATA {
  ULONG Level;                                       // offset: 0x0 (0)
  volatile ULONG RaiseIrqls;                         // offset: 0x4 (4)
  volatile ULONG AcquireSpinLocks;                   // offset: 0x8 (8)
  volatile ULONG SynchronizeExecutions;              // offset: 0xc (12)
  volatile ULONG AllocationsAttempted;               // offset: 0x10 (16)
  volatile ULONG AllocationsSucceeded;               // offset: 0x14 (20)
  volatile ULONG AllocationsSucceededSpecialPool;    // offset: 0x18 (24)
  ULONG AllocationsWithNoTag;                        // offset: 0x1c (28)
  ULONG TrimRequests;                                // offset: 0x20 (32)
  ULONG Trims;                                       // offset: 0x24 (36)
  ULONG AllocationsFailed;                           // offset: 0x28 (40)
  volatile ULONG AllocationsFailedDeliberately;      // offset: 0x2c (44)
  volatile ULONG Loads;                              // offset: 0x30 (48)
  volatile ULONG Unloads;                            // offset: 0x34 (52)
  ULONG UnTrackedPool;                               // offset: 0x38 (56)
  ULONG UserTrims;                                   // offset: 0x3c (60)
  volatile ULONG CurrentPagedPoolAllocations;        // offset: 0x40 (64)
  volatile ULONG CurrentNonPagedPoolAllocations;     // offset: 0x44 (68)
  ULONG PeakPagedPoolAllocations;                    // offset: 0x48 (72)
  ULONG PeakNonPagedPoolAllocations;                 // offset: 0x4c (76)
  volatile ULONGLONG PagedBytes;                     // offset: 0x50 (80)
  volatile ULONGLONG NonPagedBytes;                  // offset: 0x58 (88)
  ULONGLONG PeakPagedBytes;                          // offset: 0x60 (96)
  ULONGLONG PeakNonPagedBytes;                       // offset: 0x68 (104)
  volatile ULONG BurstAllocationsFailedDeliberately; // offset: 0x70 (112)
  ULONG SessionTrims;                                // offset: 0x74 (116)
  volatile ULONG OptionChanges;                      // offset: 0x78 (120)
  volatile ULONG VerifyMode;                         // offset: 0x7c (124)
  struct _UNICODE_STRING PreviousBucketName;         // offset: 0x80 (128)
  volatile ULONG ExecutePoolTypes;                   // offset: 0x90 (144)
  volatile ULONG ExecutePageProtections;             // offset: 0x94 (148)
  volatile ULONG ExecutePageMappings;                // offset: 0x98 (152)
  volatile ULONG ExecuteWriteSections;               // offset: 0x9c (156)
  volatile ULONG SectionAlignmentFailures;           // offset: 0xa0 (160)
  volatile ULONG IATInExecutableSection;             // offset: 0xa4 (164)
};

// 0x218 (536) bytes
struct _POP_THERMAL_TELEMETRY_TRACKER {
  UCHAR AccountingDisabled;        // offset: 0x0 (0)
  UCHAR ActiveLevels;              // offset: 0x1 (1)
  ULONGLONG LastPassiveUpdateTime; // offset: 0x8 (8)
  ULONGLONG LastActiveUpdateTime;  // offset: 0x10 (16)
  ULONGLONG TotalPassiveTime[21];  // offset: 0x18 (24)
  ULONGLONG PassiveTimeSnap[21];   // offset: 0xc0 (192)
  ULONGLONG TotalActiveTime[10];   // offset: 0x168 (360)
  ULONGLONG ActiveTimeSnap[10];    // offset: 0x1b8 (440)
  ULONGLONG TotalTime;             // offset: 0x208 (520)
  ULONGLONG TotalTimeSnap;         // offset: 0x210 (528)
};

// 0x80 (128) bytes
struct _VF_POOL_TRACE {
  VOID *Address;           // offset: 0x0 (0)
  ULONGLONG Size;          // offset: 0x8 (8)
  struct _ETHREAD *Thread; // offset: 0x10 (16)
  VOID *StackTrace[13];    // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _ARBITER_CONFLICT_INFO {
  struct _DEVICE_OBJECT *OwningObject; // offset: 0x0 (0)
  ULONGLONG Start;                     // offset: 0x8 (8)
  ULONGLONG End;                       // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _RTL_RANGE {
  ULONGLONG Start;  // offset: 0x0 (0)
  ULONGLONG End;    // offset: 0x8 (8)
  VOID *UserData;   // offset: 0x10 (16)
  VOID *Owner;      // offset: 0x18 (24)
  UCHAR Attributes; // offset: 0x20 (32)
  UCHAR Flags;      // offset: 0x21 (33)
};

// 0x10 (16) bytes
struct _ARBITER_ORDERING {
  ULONGLONG Start; // offset: 0x0 (0)
  ULONGLONG End;   // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _ARBITER_ORDERING_LIST {
  USHORT Count;                        // offset: 0x0 (0)
  USHORT Maximum;                      // offset: 0x2 (2)
  struct _ARBITER_ORDERING *Orderings; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _VF_AVL_TREE_NODE {
  VOID *p;             // offset: 0x0 (0)
  ULONGLONG RangeSize; // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _VF_AVL_TREE_NODE_EX {
  struct _VF_AVL_TREE_NODE Base; // offset: 0x0 (0)
  ULONG SessionId;               // offset: 0x10 (16)
};

// 0xc0 (192) bytes
struct _VF_AVL_TABLE {
  struct _RTL_AVL_TABLE RtlTable;         // offset: 0x0 (0)
  struct _VF_AVL_TREE_NODE *ReservedNode; // offset: 0x68 (104)
  VOID *NodeToFree;                       // offset: 0x70 (112)
  volatile LONG Lock;                     // offset: 0x80 (128)
};

// 0x28 (40) bytes
struct _VF_AVL_TREE {
  ULONGLONG NodeRangeSize;      // offset: 0x0 (0)
  volatile ULONGLONG NodeCount; // offset: 0x8 (8)
  struct _VF_AVL_TABLE *Tables; // offset: 0x10 (16)
  ULONG TablesNo;               // offset: 0x18 (24)
  UCHAR UseSessionId;           // offset: 0x1c (28)
  union {
    ULONG NodeSize;     // offset: 0x20 (32)
    ULONG UseLookaside; // offset: 0x20 (32)

  } u1; // offset: 0x20 (32)
};

// 0x8 (8) bytes
struct _MI_HUGE_PFN {
  union {
    struct {
      ULONGLONG EntireField; // offset: 0x0 (0)
    } e1;                    // offset: 0x0 (0)
    struct {
      ULONGLONG Flink : 18;          // offset: 0x0 (0)
      ULONGLONG PageState : 3;       // offset: 0x0 (0)
      ULONGLONG Blink : 18;          // offset: 0x0 (0)
      ULONGLONG WriteInProgress : 1; // offset: 0x0 (0)
      ULONGLONG HasError : 1;        // offset: 0x0 (0)
      ULONGLONG Partition : 11;      // offset: 0x0 (0)
      ULONGLONG Reserved : 12;       // offset: 0x0 (0)
    } e2;                            // offset: 0x0 (0)

  } u1; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _NON_PAGED_DEBUG_INFO {
  USHORT Signature;       // offset: 0x0 (0)
  USHORT Flags;           // offset: 0x2 (2)
  ULONG Size;             // offset: 0x4 (4)
  USHORT Machine;         // offset: 0x8 (8)
  USHORT Characteristics; // offset: 0xa (10)
  ULONG TimeDateStamp;    // offset: 0xc (12)
  ULONG CheckSum;         // offset: 0x10 (16)
  ULONG SizeOfImage;      // offset: 0x14 (20)
  ULONGLONG ImageBase;    // offset: 0x18 (24)
};

// 0xa0 (160) bytes
struct _KLDR_DATA_TABLE_ENTRY {
  struct _LIST_ENTRY InLoadOrderLinks;             // offset: 0x0 (0)
  VOID *ExceptionTable;                            // offset: 0x10 (16)
  ULONG ExceptionTableSize;                        // offset: 0x18 (24)
  VOID *GpValue;                                   // offset: 0x20 (32)
  struct _NON_PAGED_DEBUG_INFO *NonPagedDebugInfo; // offset: 0x28 (40)
  VOID *DllBase;                                   // offset: 0x30 (48)
  VOID *EntryPoint;                                // offset: 0x38 (56)
  ULONG SizeOfImage;                               // offset: 0x40 (64)
  struct _UNICODE_STRING FullDllName;              // offset: 0x48 (72)
  struct _UNICODE_STRING BaseDllName;              // offset: 0x58 (88)
  ULONG Flags;                                     // offset: 0x68 (104)
  USHORT LoadCount;                                // offset: 0x6c (108)
  union {
    USHORT SignatureLevel : 4; // offset: 0x6e (110)
    USHORT SignatureType : 3;  // offset: 0x6e (110)
    USHORT Unused : 9;         // offset: 0x6e (110)
    USHORT EntireField;        // offset: 0x6e (110)

  } u1;                        // offset: 0x6e (110)
  VOID *SectionPointer;        // offset: 0x70 (112)
  ULONG CheckSum;              // offset: 0x78 (120)
  ULONG CoverageSectionSize;   // offset: 0x7c (124)
  VOID *CoverageSection;       // offset: 0x80 (128)
  VOID *LoadedImports;         // offset: 0x88 (136)
  VOID *Spare;                 // offset: 0x90 (144)
  ULONG SizeOfImageNotRounded; // offset: 0x98 (152)
  ULONG TimeDateStamp;         // offset: 0x9c (156)
};

// 0x10 (16) bytes
struct _MI_SYSTEM_VA_ASSIGNMENT {
  VOID *BaseAddress;       // offset: 0x0 (0)
  ULONGLONG NumberOfBytes; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _MI_ZERO_COST_COUNTS {
  ULONGLONG NativeSum; // offset: 0x0 (0)
  ULONGLONG CachedSum; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _HAL_CHANNEL_MEMORY_RANGES {
  ULONGLONG PageFrameIndex; // offset: 0x0 (0)
  USHORT MpnId;             // offset: 0x8 (8)
  USHORT Node;              // offset: 0xa (10)
  USHORT Channel;           // offset: 0xc (12)
  UCHAR IsPowerManageable;  // offset: 0xe (14)
  UCHAR DeepPowerState;     // offset: 0xf (15)
};

// 0x10 (16) bytes
struct _HAL_NODE_RANGE {
  ULONGLONG PageFrameIndex; // offset: 0x0 (0)
  ULONG Node;               // offset: 0x8 (8)
};

// 0x118 (280) bytes
struct _SYSPTES_HEADER {
  struct _LIST_ENTRY ListHead[16]; // offset: 0x0 (0)
  ULONGLONG Count;                 // offset: 0x100 (256)
  ULONGLONG NumberOfEntries;       // offset: 0x108 (264)
  ULONGLONG NumberOfEntriesPeak;   // offset: 0x110 (272)
};

// 0x28 (40) bytes
struct _MI_IO_CACHE_STATS {
  ULONGLONG UnusedBlocks;             // offset: 0x0 (0)
  ULONG ActiveCacheMatch;             // offset: 0x8 (8)
  ULONG ActiveCacheOverride;          // offset: 0xc (12)
  ULONG UnmappedCacheFlush;           // offset: 0x10 (16)
  ULONG UnmappedCacheMatch;           // offset: 0x14 (20)
  ULONG UnmappedCacheConflict;        // offset: 0x18 (24)
  ULONG PermanentIoAttributeConflict; // offset: 0x1c (28)
  ULONG PermanentIoNodeConflict;      // offset: 0x20 (32)
};

// 0x68 (104) bytes
struct _MI_IO_PAGE_STATE {
  volatile LONG IoPfnLock;                // offset: 0x0 (0)
  struct _RTL_AVL_TREE IoPfnRoot[3];      // offset: 0x8 (8)
  struct _LIST_ENTRY UnusedCachedMaps;    // offset: 0x20 (32)
  ULONG OldestCacheFlushTimeStamp;        // offset: 0x30 (48)
  struct _MI_IO_CACHE_STATS IoCacheStats; // offset: 0x38 (56)
  struct _RTL_AVL_TREE InvariantIoSpace;  // offset: 0x60 (96)
};

// 0x40 (64) bytes
struct _MI_SYSTEM_TRIM_STATE {
  ULONGLONG ExpansionLock;                // offset: 0x0 (0)
  volatile LONG TrimInProgressCount;      // offset: 0x8 (8)
  struct _KEVENT PeriodicWorkingSetEvent; // offset: 0x10 (16)
  ULONG TrimAllPageFaultCount[3];         // offset: 0x28 (40)
};

// 0xc8 (200) bytes
struct _MI_ERROR_STATE {
  struct _MI_BAD_MEMORY_EVENT_ENTRY BadMemoryEventEntry; // offset: 0x0 (0)
  ULONGLONG PageOfInterest;                              // offset: 0x38 (56)
  struct _MI_PROBE_RAISE_TRACKER ProbeRaises;            // offset: 0x40 (64)
  struct _MI_FORCED_COMMITS ForcedCommits;               // offset: 0x84 (132)
  ULONG WsleFailures[1];                                 // offset: 0x8c (140)
  ULONG PageHashErrors;                                  // offset: 0x90 (144)
  ULONG CheckZeroCount;                                  // offset: 0x94 (148)
  volatile LONG ZeroedPageSingleBitErrorsDetected;       // offset: 0x98 (152)
  volatile LONG BadPagesDetected;                        // offset: 0x9c (156)
  LONG ScrubPasses;                                      // offset: 0xa0 (160)
  LONG ScrubBadPagesFound;                               // offset: 0xa4 (164)
  ULONG UserViewFailures;                                // offset: 0xa8 (168)
  ULONG UserViewCollisionFailures;                       // offset: 0xac (172)
  ULONG UserAllocateFailures;                            // offset: 0xb0 (176)
  ULONG UserAllocateCollisionFailures;                   // offset: 0xb4 (180)
  struct _MI_RESAVAIL_FAILURES ResavailFailures;         // offset: 0xb8 (184)
  UCHAR PendingBadPages;                                 // offset: 0xc0 (192)
  UCHAR FatalGraphicsFailures;                           // offset: 0xc1 (193)
  UCHAR InitFailure;                                     // offset: 0xc2 (194)
  UCHAR StopBadMaps;                                     // offset: 0xc3 (195)
};

// 0x20 (32) bytes
struct _MI_COMBINE_STATE {
  volatile LONG ActiveSpinLock;          // offset: 0x0 (0)
  ULONG CombiningThreadCount;            // offset: 0x4 (4)
  struct _RTL_AVL_TREE ActiveThreadTree; // offset: 0x8 (8)
  ULONGLONG CommonPageCombineDomain;     // offset: 0x10 (16)
  ULONG CommonCombineDomainAssigned;     // offset: 0x18 (24)
};

// 0x70 (112) bytes
struct _VIRTUAL_EFI_RUNTIME_SERVICES {
  ULONGLONG GetTime;                   // offset: 0x0 (0)
  ULONGLONG SetTime;                   // offset: 0x8 (8)
  ULONGLONG GetWakeupTime;             // offset: 0x10 (16)
  ULONGLONG SetWakeupTime;             // offset: 0x18 (24)
  ULONGLONG SetVirtualAddressMap;      // offset: 0x20 (32)
  ULONGLONG ConvertPointer;            // offset: 0x28 (40)
  ULONGLONG GetVariable;               // offset: 0x30 (48)
  ULONGLONG GetNextVariableName;       // offset: 0x38 (56)
  ULONGLONG SetVariable;               // offset: 0x40 (64)
  ULONGLONG GetNextHighMonotonicCount; // offset: 0x48 (72)
  ULONGLONG ResetSystem;               // offset: 0x50 (80)
  ULONGLONG UpdateCapsule;             // offset: 0x58 (88)
  ULONGLONG QueryCapsuleCapabilities;  // offset: 0x60 (96)
  ULONGLONG QueryVariableInfo;         // offset: 0x68 (104)
};

// 0x38 (56) bytes
struct _EFI_FIRMWARE_INFORMATION {
  ULONG FirmwareVersion; // offset: 0x0 (0)
  struct _VIRTUAL_EFI_RUNTIME_SERVICES
      *VirtualEfiRuntimeServices;          // offset: 0x8 (8)
  LONG SetVirtualAddressMapStatus;         // offset: 0x10 (16)
  ULONG MissedMappingsCount;               // offset: 0x14 (20)
  struct _LIST_ENTRY FirmwareResourceList; // offset: 0x18 (24)
  VOID *EfiMemoryMap;                      // offset: 0x28 (40)
  ULONG EfiMemoryMapSize;                  // offset: 0x30 (48)
  ULONG EfiMemoryMapDescriptorSize;        // offset: 0x34 (52)
};

// 0x40 (64) bytes
struct _FIRMWARE_INFORMATION_LOADER_BLOCK {
  ULONG FirmwareTypeUefi : 1;                  // offset: 0x0 (0)
  ULONG EfiRuntimeUseIum : 1;                  // offset: 0x0 (0)
  ULONG EfiRuntimePageProtectionSupported : 1; // offset: 0x0 (0)
  ULONG Reserved : 29;                         // offset: 0x0 (0)
  union {
    struct _EFI_FIRMWARE_INFORMATION EfiInformation;   // offset: 0x8 (8)
    struct _PCAT_FIRMWARE_INFORMATION PcatInformation; // offset: 0x8 (8)

  } u; // offset: 0x8 (8)
};

// 0x68 (104) bytes
struct _BOOT_ENTROPY_SOURCE_LDR_RESULT {
  enum _BOOT_ENTROPY_SOURCE_ID SourceId;            // offset: 0x0 (0)
  ULONGLONG Policy;                                 // offset: 0x8 (8)
  enum _BOOT_ENTROPY_SOURCE_RESULT_CODE ResultCode; // offset: 0x10 (16)
  LONG ResultStatus;                                // offset: 0x14 (20)
  ULONGLONG Time;                                   // offset: 0x18 (24)
  ULONG EntropyLength;                              // offset: 0x20 (32)
  UCHAR EntropyData[64];                            // offset: 0x24 (36)
};

// 0x868 (2152) bytes
struct _BOOT_ENTROPY_LDR_RESULT {
  ULONG maxEntropySources; // offset: 0x0 (0)
  struct _BOOT_ENTROPY_SOURCE_LDR_RESULT
      EntropySourceResult[10];     // offset: 0x8 (8)
  UCHAR SeedBytesForCng[48];       // offset: 0x418 (1048)
  UCHAR RngBytesForNtoskrnl[1024]; // offset: 0x448 (1096)
  UCHAR KdEntropy[32];             // offset: 0x848 (2120)
};

// 0x28 (40) bytes
struct _ISRDPCSTATS_SEQUENCE {
  ULONG SequenceNumber; // offset: 0x0 (0)
  ULONGLONG IsrTime;    // offset: 0x8 (8)
  ULONGLONG IsrCount;   // offset: 0x10 (16)
  ULONGLONG DpcTime;    // offset: 0x18 (24)
  ULONGLONG DpcCount;   // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _NUMA_MEMORY_RANGE {
  ULONG ProximityId;  // offset: 0x0 (0)
  ULONGLONG BasePage; // offset: 0x8 (8)
  ULONGLONG EndPage;  // offset: 0x10 (16)
};

// 0x30 (48) bytes
struct _LOADER_RESET_REASON {
  UCHAR Supplied; // offset: 0x0 (0)
  union {
    struct {
      UCHAR Pch;                // offset: 0x0 (0)
      UCHAR EmbeddedController; // offset: 0x1 (1)
      UCHAR Reserved[6];        // offset: 0x2 (2)
    } Component;                // offset: 0x8 (8)
    ULONGLONG AsULONG64;        // offset: 0x8 (8)
    UCHAR AsBytes[8];           // offset: 0x8 (8)

  } Basic;                 // offset: 0x8 (8)
  ULONG AdditionalInfo[8]; // offset: 0x10 (16)
};

// 0x18 (24) bytes
struct _SMBIOS3_TABLE_HEADER {
  UCHAR Signature[5];              // offset: 0x0 (0)
  UCHAR Checksum;                  // offset: 0x5 (5)
  UCHAR Length;                    // offset: 0x6 (6)
  UCHAR MajorVersion;              // offset: 0x7 (7)
  UCHAR MinorVersion;              // offset: 0x8 (8)
  UCHAR Docrev;                    // offset: 0x9 (9)
  UCHAR EntryPointRevision;        // offset: 0xa (10)
  UCHAR Reserved;                  // offset: 0xb (11)
  ULONG StructureTableMaximumSize; // offset: 0xc (12)
  ULONGLONG StructureTableAddress; // offset: 0x10 (16)
};

// 0x60 (96) bytes
struct _ISRDPCSTATS {
  ULONGLONG IsrTime;                        // offset: 0x0 (0)
  ULONGLONG IsrTimeStart;                   // offset: 0x8 (8)
  ULONGLONG IsrCount;                       // offset: 0x10 (16)
  ULONGLONG DpcTime;                        // offset: 0x18 (24)
  ULONGLONG DpcTimeStart;                   // offset: 0x20 (32)
  ULONGLONG DpcCount;                       // offset: 0x28 (40)
  UCHAR IsrActive;                          // offset: 0x30 (48)
  UCHAR Reserved[7];                        // offset: 0x31 (49)
  struct _ISRDPCSTATS_SEQUENCE DpcWatchdog; // offset: 0x38 (56)
};

// 0x48 (72) bytes
struct _LOADER_FEATURE_CONFIGURATION_INFORMATION {
  VOID *FeatureConfigurationBuffer;         // offset: 0x0 (0)
  ULONGLONG FeatureConfigurationBufferSize; // offset: 0x8 (8)
  VOID *UsageSubscriptionBuffer;            // offset: 0x10 (16)
  ULONGLONG UsageSubscriptionBufferSize;    // offset: 0x18 (24)
  VOID *DelayedUsageReportBuffer;           // offset: 0x20 (32)
  ULONGLONG DelayedUsageReportBufferSize;   // offset: 0x28 (40)
  struct _LOADER_FEATURE_CONFIGURATION_DIAGNOSTIC_INFORMATION
      DiagnosticInformation; // offset: 0x30 (48)
};

// 0x28 (40) bytes
struct _LOADER_BUGCHECK_PARAMETERS {
  ULONG BugcheckCode;           // offset: 0x0 (0)
  ULONGLONG BugcheckParameter1; // offset: 0x8 (8)
  ULONGLONG BugcheckParameter2; // offset: 0x10 (16)
  ULONGLONG BugcheckParameter3; // offset: 0x18 (24)
  ULONGLONG BugcheckParameter4; // offset: 0x20 (32)
};

// 0x40 (64) bytes
struct _LOADER_PARAMETER_HYPERVISOR_EXTENSION {
  ULONG InitialHypervisorCrashdumpAreaPageCount; // offset: 0x0 (0)
  ULONG HypervisorCrashdumpAreaPageCount;        // offset: 0x4 (4)
  ULONGLONG InitialHypervisorCrashdumpAreaSpa;   // offset: 0x8 (8)
  ULONGLONG HypervisorCrashdumpAreaSpa;          // offset: 0x10 (16)
  ULONGLONG HypervisorLaunchStatus;              // offset: 0x18 (24)
  ULONGLONG HypervisorLaunchStatusArg1;          // offset: 0x20 (32)
  ULONGLONG HypervisorLaunchStatusArg2;          // offset: 0x28 (40)
  ULONGLONG HypervisorLaunchStatusArg3;          // offset: 0x30 (48)
  ULONGLONG HypervisorLaunchStatusArg4;          // offset: 0x38 (56)
};

// 0x60 (96) bytes
struct _LOADER_PERFORMANCE_DATA {
  ULONGLONG StartTime;                  // offset: 0x0 (0)
  ULONGLONG EndTime;                    // offset: 0x8 (8)
  ULONGLONG PreloadEndTime;             // offset: 0x10 (16)
  ULONGLONG TcbLoaderStartTime;         // offset: 0x18 (24)
  ULONGLONG LoadHypervisorTime;         // offset: 0x20 (32)
  ULONGLONG LaunchHypervisorTime;       // offset: 0x28 (40)
  ULONGLONG LoadVsmTime;                // offset: 0x30 (48)
  ULONGLONG LaunchVsmTime;              // offset: 0x38 (56)
  ULONGLONG ExecuteTransitionStartTime; // offset: 0x40 (64)
  ULONGLONG ExecuteTransitionEndTime;   // offset: 0x48 (72)
  ULONGLONG LoadDriversTime;            // offset: 0x50 (80)
  ULONGLONG CleanupVsmTime;             // offset: 0x58 (88)
};

// 0x28 (40) bytes
struct _FAULT_INFORMATION_X64 {
  VOID *DomainHandle;                        // offset: 0x0 (0)
  VOID *FaultAddress;                        // offset: 0x8 (8)
  struct _FAULT_INFORMATION_X64_FLAGS Flags; // offset: 0x10 (16)
  enum _FAULT_INFORMATION_ARM64_TYPE Type;   // offset: 0x14 (20)
  ULONGLONG IommuBaseAddress;                // offset: 0x18 (24)
  ULONG PciSegment;                          // offset: 0x20 (32)
};

// 0x30 (48) bytes
struct _FAULT_INFORMATION_ARM64 {
  VOID *DomainHandle;                          // offset: 0x0 (0)
  VOID *FaultAddress;                          // offset: 0x8 (8)
  struct _DEVICE_OBJECT *PhysicalDeviceObject; // offset: 0x10 (16)
  ULONG InputMappingId;                        // offset: 0x18 (24)
  struct _FAULT_INFORMATION_ARM64_FLAGS Flags; // offset: 0x1c (28)
  enum _FAULT_INFORMATION_ARM64_TYPE Type;     // offset: 0x20 (32)
  ULONGLONG IommuBaseAddress;                  // offset: 0x28 (40)
};

// 0x38 (56) bytes
struct _FAULT_INFORMATION {
  enum _FAULT_INFORMATION_ARCH Type; // offset: 0x0 (0)
  UCHAR IsStage1;                    // offset: 0x4 (4)
  union {
    struct _FAULT_INFORMATION_ARM64 Arm64; // offset: 0x8 (8)
    struct _FAULT_INFORMATION_X64 X64;     // offset: 0x8 (8)
  };
};

// 0x10 (16) bytes
struct _DEVICE_FAULT_CONFIGURATION {
  VOID (*FaultHandler)
  (VOID *arg1, struct _FAULT_INFORMATION *arg2); // offset: 0x0 (0)
  VOID *FaultContext;                            // offset: 0x8 (8)
};

// 0x70 (112) bytes
struct _DMA_IOMMU_INTERFACE {
  ULONG Version; // offset: 0x0 (0)
  LONG (*CreateDomain)
  (UCHAR arg1, struct _IOMMU_DMA_DOMAIN **arg2);        // offset: 0x8 (8)
  LONG (*DeleteDomain)(struct _IOMMU_DMA_DOMAIN *arg1); // offset: 0x10 (16)
  LONG (*AttachDevice)
  (struct _IOMMU_DMA_DOMAIN *arg1, struct _DEVICE_OBJECT *arg2, ULONG arg3,
   ULONG arg4); // offset: 0x18 (24)
  LONG (*DetachDevice)
  (struct _IOMMU_DMA_DOMAIN *arg1, struct _DEVICE_OBJECT *arg2,
   ULONG arg3);                                        // offset: 0x20 (32)
  LONG (*FlushDomain)(struct _IOMMU_DMA_DOMAIN *arg1); // offset: 0x28 (40)
  LONG (*FlushDomainByVaList)
  (struct _IOMMU_DMA_DOMAIN *arg1, UCHAR arg2, ULONG arg3,
   VOID *arg4); // offset: 0x30 (48)
  LONG (*QueryInputMappings)
  (struct _DEVICE_OBJECT *arg1, struct _INPUT_MAPPING_ELEMENT *arg2, ULONG arg3,
   ULONG *arg4); // offset: 0x38 (56)
  LONG (*MapLogicalRange)
  (struct _IOMMU_DMA_DOMAIN *arg1, ULONG arg2, struct _MDL *arg3,
   ULONGLONG arg4); // offset: 0x40 (64)
  LONG (*UnmapLogicalRange)
  (struct _IOMMU_DMA_DOMAIN *arg1, ULONGLONG arg2,
   ULONGLONG arg3); // offset: 0x48 (72)
  LONG (*MapIdentityRange)
  (struct _IOMMU_DMA_DOMAIN *arg1, ULONG arg2,
   struct _MDL *arg3); // offset: 0x50 (80)
  LONG (*UnmapIdentityRange)
  (struct _IOMMU_DMA_DOMAIN *arg1, struct _MDL *arg2); // offset: 0x58 (88)
  LONG (*SetDeviceFaultReporting)
  (struct _DEVICE_OBJECT *arg1, ULONG arg2, UCHAR arg3,
   struct _DEVICE_FAULT_CONFIGURATION *arg4); // offset: 0x60 (96)
  LONG (*ConfigureDomain)
  (struct _IOMMU_DMA_DOMAIN *arg1,
   struct _DOMAIN_CONFIGURATION *arg2); // offset: 0x68 (104)
};

// 0x20 (32) bytes
struct _HAL_CLOCK_TIMER_CONFIGURATION {
  union {
    UCHAR Flags; // offset: 0x0 (0)
    struct {
      UCHAR AlwaysOnTimer : 1;        // offset: 0x0 (0)
      UCHAR HighLatency : 1;          // offset: 0x0 (0)
      UCHAR PerCpuTimer : 1;          // offset: 0x0 (0)
      UCHAR DynamicTickSupported : 1; // offset: 0x0 (0)
    };
  };
  ULONG KnownType;        // offset: 0x4 (4)
  ULONG Capabilities;     // offset: 0x8 (8)
  ULONGLONG MaxIncrement; // offset: 0x10 (16)
  ULONG MinIncrement;     // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _MEMORY_ALLOCATION_DESCRIPTOR {
  struct _LIST_ENTRY ListEntry;    // offset: 0x0 (0)
  enum _TYPE_OF_MEMORY MemoryType; // offset: 0x10 (16)
  ULONGLONG BasePage;              // offset: 0x18 (24)
  ULONGLONG PageCount;             // offset: 0x20 (32)
};

// 0x30 (48) bytes
struct _HEAP_STOP_ON_VALUES {
  ULONGLONG AllocAddress;              // offset: 0x0 (0)
  struct _HEAP_STOP_ON_TAG AllocTag;   // offset: 0x8 (8)
  ULONGLONG ReAllocAddress;            // offset: 0x10 (16)
  struct _HEAP_STOP_ON_TAG ReAllocTag; // offset: 0x18 (24)
  ULONGLONG FreeAddress;               // offset: 0x20 (32)
  struct _HEAP_STOP_ON_TAG FreeTag;    // offset: 0x28 (40)
};

// 0x1d8 (472) bytes
struct _POP_DEVICE_SYS_STATE {
  UCHAR IrpMinor;                        // offset: 0x0 (0)
  enum _SYSTEM_POWER_STATE SystemState;  // offset: 0x4 (4)
  ULONGLONG SpinLock;                    // offset: 0x8 (8)
  struct _KTHREAD *Thread;               // offset: 0x10 (16)
  struct _KEVENT *AbortEvent;            // offset: 0x18 (24)
  struct _KSEMAPHORE *ReadySemaphore;    // offset: 0x20 (32)
  struct _KSEMAPHORE *FinishedSemaphore; // offset: 0x28 (40)
  struct _PO_DEVICE_NOTIFY_ORDER Order;  // offset: 0x30 (48)
  struct _LIST_ENTRY Pending;            // offset: 0x1b0 (432)
  LONG Status;                           // offset: 0x1c0 (448)
  struct _DEVICE_OBJECT *FailedDevice;   // offset: 0x1c8 (456)
  UCHAR Waking;                          // offset: 0x1d0 (464)
  UCHAR Cancelled;                       // offset: 0x1d1 (465)
  UCHAR IgnoreErrors;                    // offset: 0x1d2 (466)
  UCHAR IgnoreNotImplemented;            // offset: 0x1d3 (467)
  UCHAR TimeRefreshLockAcquired;         // offset: 0x1d4 (468)
};

// 0x18 (24) bytes
struct _POP_CURRENT_BROADCAST {
  UCHAR InProgress;                                 // offset: 0x0 (0)
  struct _SYSTEM_POWER_STATE_CONTEXT SystemContext; // offset: 0x4 (4)
  enum POWER_ACTION PowerAction;                    // offset: 0x8 (8)
  struct _POP_DEVICE_SYS_STATE *DeviceState;        // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _SK_CRASH_STACK_FRAME {
  union {
    struct {
      ULONG ModuleId; // offset: 0x0 (0)
      ULONG Rva;      // offset: 0x4 (4)
    };
    ULONGLONG Pc; // offset: 0x0 (0)
  };
};

// 0x1000 (4096) bytes
struct _SK_CRASH_MINIDUMP {
  ULONG Size;                                    // offset: 0x0 (0)
  ULONG Version;                                 // offset: 0x4 (4)
  ULONG ModuleCount;                             // offset: 0x8 (8)
  ULONG FrameCount;                              // offset: 0xc (12)
  struct _SK_CRASH_MODULE Modules[16];           // offset: 0x10 (16)
  struct _SK_CRASH_STACK_FRAME StackFrames[366]; // offset: 0x490 (1168)
};

// 0x28 (40) bytes
struct _LOCK_HEADER {
  struct _RTL_AVL_TREE LockTree;            // offset: 0x0 (0)
  struct _RTL_AVL_TREE LockMdlSwitchedTree; // offset: 0x8 (8)
  ULONGLONG Count;                          // offset: 0x10 (16)
  ULONGLONG Lock;                           // offset: 0x18 (24)
  ULONG Valid;                              // offset: 0x20 (32)
};

// 0x38 (56) bytes
struct _POOL_TRACKER_TABLE {
  volatile LONG Key;        // offset: 0x0 (0)
  ULONGLONG NonPagedBytes;  // offset: 0x8 (8)
  ULONGLONG NonPagedAllocs; // offset: 0x10 (16)
  ULONGLONG NonPagedFrees;  // offset: 0x18 (24)
  ULONGLONG PagedBytes;     // offset: 0x20 (32)
  ULONGLONG PagedAllocs;    // offset: 0x28 (40)
  ULONGLONG PagedFrees;     // offset: 0x30 (48)
};

// 0x8 (8) bytes
struct _WNF_STATE_NAME_STRUCT {
  ULONGLONG Version : 4;       // offset: 0x0 (0)
  ULONGLONG NameLifetime : 2;  // offset: 0x0 (0)
  ULONGLONG DataScope : 4;     // offset: 0x0 (0)
  ULONGLONG PermanentData : 1; // offset: 0x0 (0)
  ULONGLONG Sequence : 53;     // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _OBJECT_HEADER_AUDIT_INFO {
  VOID *SecurityDescriptor; // offset: 0x0 (0)
  ULONGLONG Reserved;       // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _OBJECT_HEADER_QUOTA_INFO {
  ULONG PagedPoolCharge;              // offset: 0x0 (0)
  ULONG NonPagedPoolCharge;           // offset: 0x4 (4)
  ULONG SecurityDescriptorCharge;     // offset: 0x8 (8)
  ULONG Reserved1;                    // offset: 0xc (12)
  VOID *SecurityDescriptorQuotaBlock; // offset: 0x10 (16)
  ULONGLONG Reserved2;                // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _SEP_TOKEN_PRIVILEGES {
  ULONGLONG Present;          // offset: 0x0 (0)
  ULONGLONG Enabled;          // offset: 0x8 (8)
  ULONGLONG EnabledByDefault; // offset: 0x10 (16)
};

// 0x8 (8) bytes
union _FILE_SEGMENT_ELEMENT {
  VOID *Buffer;        // offset: 0x0 (0)
  ULONGLONG Alignment; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _IO_ADAPTER_CRYPTO_PARAMETERS {
  ULONGLONG Tweak;                                         // offset: 0x0 (0)
  struct _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR *KeyDescriptor; // offset: 0x8 (8)
};

// 0x40 (64) bytes
struct _IOP_IRP_EXTENSION {
  union {
    USHORT ExtensionFlags; // offset: 0x0 (0)
    struct {
      USHORT Allocated : 1;   // offset: 0x0 (0)
      USHORT PropagateId : 1; // offset: 0x0 (0)
      USHORT SpareBits : 14;  // offset: 0x0 (0)
    };
  };
  USHORT TypesAllocated;             // offset: 0x2 (2)
  UCHAR GenericExtension[4];         // offset: 0x4 (4)
  VOID *VerifierContext;             // offset: 0x8 (8)
  ULONGLONG DiskIoAttributionHandle; // offset: 0x10 (16)
  struct _GUID ActivityId;           // offset: 0x18 (24)
  union {
    union _LARGE_INTEGER Timestamp; // offset: 0x28 (40)
    ULONG ZeroingOffset;            // offset: 0x28 (40)
    struct {
      struct _IO_IRP_EXT_TRACK_OFFSET_HEADER
          *FsTrackOffsetBlob;   // offset: 0x28 (40)
      LONGLONG FsTrackedOffset; // offset: 0x30 (48)
    };
    struct _IO_ADAPTER_CRYPTO_PARAMETERS
        AdapterCryptoParameters; // offset: 0x28 (40)
  };
  union {
    ULONGLONG Value;            // offset: 0x38 (56)
    ULONGLONG UserFlags : 32;   // offset: 0x38 (56)
    ULONGLONG SystemFlags : 16; // offset: 0x38 (56)
    ULONGLONG UserFlagsId : 16; // offset: 0x38 (56)

  } DriverFlags; // offset: 0x38 (56)
};

// 0x18 (24) bytes
struct _REMOTE_PORT_VIEW {
  ULONG Length;       // offset: 0x0 (0)
  ULONGLONG ViewSize; // offset: 0x8 (8)
  VOID *ViewBase;     // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _ALPC_COMPLETION_LIST_STATE {
  union {
    struct {
      ULONGLONG Head : 24;              // offset: 0x0 (0)
      ULONGLONG Tail : 24;              // offset: 0x0 (0)
      ULONGLONG ActiveThreadCount : 16; // offset: 0x0 (0)
    } s1;                               // offset: 0x0 (0)
    LONGLONG Value;                     // offset: 0x0 (0)

  } u1; // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _KALPC_DIRECT_EVENT {
  ULONGLONG Value;                // offset: 0x0 (0)
  ULONGLONG DirectType : 1;       // offset: 0x0 (0)
  ULONGLONG EventReferenced : 1;  // offset: 0x0 (0)
  ULONGLONG EventObjectBits : 62; // offset: 0x0 (0)
};

// 0x48 (72) bytes
struct _ALPC_PORT_ATTRIBUTES {
  ULONG Flags;                                     // offset: 0x0 (0)
  struct _SECURITY_QUALITY_OF_SERVICE SecurityQos; // offset: 0x4 (4)
  ULONGLONG MaxMessageLength;                      // offset: 0x10 (16)
  ULONGLONG MemoryBandwidth;                       // offset: 0x18 (24)
  ULONGLONG MaxPoolUsage;                          // offset: 0x20 (32)
  ULONGLONG MaxSectionSize;                        // offset: 0x28 (40)
  ULONGLONG MaxViewSize;                           // offset: 0x30 (48)
  ULONGLONG MaxTotalSectionSize;                   // offset: 0x38 (56)
  ULONG DupObjectTypes;                            // offset: 0x40 (64)
  ULONG Reserved;                                  // offset: 0x44 (68)
};

// 0x28 (40) bytes
struct _PORT_MESSAGE {
  union {
    struct {
      SHORT DataLength;  // offset: 0x0 (0)
      SHORT TotalLength; // offset: 0x2 (2)
    } s1;                // offset: 0x0 (0)
    ULONG Length;        // offset: 0x0 (0)

  } u1; // offset: 0x0 (0)
  union {
    struct {
      SHORT Type;           // offset: 0x0 (0)
      SHORT DataInfoOffset; // offset: 0x2 (2)
    } s2;                   // offset: 0x4 (4)
    ULONG ZeroInit;         // offset: 0x4 (4)

  } u2; // offset: 0x4 (4)
  union {
    struct _CLIENT_ID ClientId; // offset: 0x8 (8)
    double DoNotUseThisField;   // offset: 0x8 (8)
  };
  ULONG MessageId; // offset: 0x18 (24)
  union {
    ULONGLONG ClientViewSize; // offset: 0x20 (32)
    ULONG CallbackId;         // offset: 0x20 (32)
  };
};

// 0x50 (80) bytes
struct _LPCP_MESSAGE {
  union {
    struct _LIST_ENTRY Entry; // offset: 0x0 (0)
    struct {
      struct _SINGLE_LIST_ENTRY FreeEntry; // offset: 0x0 (0)
      ULONG Reserved0;                     // offset: 0x8 (8)
    };
  };
  VOID *SenderPort;                 // offset: 0x10 (16)
  struct _ETHREAD *RepliedToThread; // offset: 0x18 (24)
  VOID *PortContext;                // offset: 0x20 (32)
  struct _PORT_MESSAGE Request;     // offset: 0x28 (40)
};

// 0x10 (16) bytes
struct _RTLP_HP_PADDING_HEADER {
  ULONGLONG PaddingSize; // offset: 0x0 (0)
  ULONGLONG Spare;       // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _HEAP_ENTRY_EXTRA {
  union {
    struct {
      USHORT AllocatorBackTraceIndex; // offset: 0x0 (0)
      USHORT TagIndex;                // offset: 0x2 (2)
      ULONGLONG Settable;             // offset: 0x8 (8)
    };
    struct {
      ULONGLONG ZeroInit;  // offset: 0x0 (0)
      ULONGLONG ZeroInit1; // offset: 0x8 (8)
    };
  };
};

// 0x10 (16) bytes
struct _HEAP_PSEUDO_TAG_ENTRY {
  ULONG Allocs;   // offset: 0x0 (0)
  ULONG Frees;    // offset: 0x4 (4)
  ULONGLONG Size; // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _HEAP_TAG_ENTRY {
  ULONG Allocs;                 // offset: 0x0 (0)
  ULONG Frees;                  // offset: 0x4 (4)
  ULONGLONG Size;               // offset: 0x8 (8)
  USHORT TagIndex;              // offset: 0x10 (16)
  USHORT CreatorBackTraceIndex; // offset: 0x12 (18)
  WCHAR TagName[24];            // offset: 0x14 (20)
};

// 0x10 (16) bytes
struct _HEAP_UNPACKED_ENTRY {
  VOID *PreviousBlockPrivateData; // offset: 0x0 (0)
  union {
    struct {
      USHORT Size;         // offset: 0x8 (8)
      UCHAR Flags;         // offset: 0xa (10)
      UCHAR SmallTagIndex; // offset: 0xb (11)
    };
    struct {
      ULONG SubSegmentCode; // offset: 0x8 (8)
      USHORT PreviousSize;  // offset: 0xc (12)
      union {
        UCHAR SegmentOffset; // offset: 0xe (14)
        UCHAR LFHFlags;      // offset: 0xe (14)
      };
      UCHAR UnusedBytes; // offset: 0xf (15)
    };
    ULONGLONG CompactHeader; // offset: 0x8 (8)
  };
};

// 0x10 (16) bytes
struct _HEAP_TUNING_PARAMETERS {
  ULONG CommittThresholdShift;      // offset: 0x0 (0)
  ULONGLONG MaxPreCommittThreshold; // offset: 0x8 (8)
};

// 0x78 (120) bytes
struct _HEAP_COUNTERS {
  ULONGLONG TotalMemoryReserved;      // offset: 0x0 (0)
  ULONGLONG TotalMemoryCommitted;     // offset: 0x8 (8)
  ULONGLONG TotalMemoryLargeUCR;      // offset: 0x10 (16)
  ULONGLONG TotalSizeInVirtualBlocks; // offset: 0x18 (24)
  ULONG TotalSegments;                // offset: 0x20 (32)
  ULONG TotalUCRs;                    // offset: 0x24 (36)
  ULONG CommittOps;                   // offset: 0x28 (40)
  ULONG DeCommitOps;                  // offset: 0x2c (44)
  ULONG LockAcquires;                 // offset: 0x30 (48)
  ULONG LockCollisions;               // offset: 0x34 (52)
  ULONG CommitRate;                   // offset: 0x38 (56)
  ULONG DecommittRate;                // offset: 0x3c (60)
  ULONG CommitFailures;               // offset: 0x40 (64)
  ULONG InBlockCommitFailures;        // offset: 0x44 (68)
  ULONG PollIntervalCounter;          // offset: 0x48 (72)
  ULONG DecommitsSinceLastCheck;      // offset: 0x4c (76)
  ULONG HeapPollInterval;             // offset: 0x50 (80)
  ULONG AllocAndFreeOps;              // offset: 0x54 (84)
  ULONG AllocationIndicesActive;      // offset: 0x58 (88)
  ULONG InBlockDeccommits;            // offset: 0x5c (92)
  ULONGLONG InBlockDeccomitSize;      // offset: 0x60 (96)
  ULONGLONG HighWatermarkSize;        // offset: 0x68 (104)
  ULONGLONG LastPolledSize;           // offset: 0x70 (112)
};

// 0x10 (16) bytes
struct _HEAP_ENTRY {
  union {
    struct _HEAP_UNPACKED_ENTRY UnpackedEntry; // offset: 0x0 (0)
    struct {
      VOID *PreviousBlockPrivateData; // offset: 0x0 (0)
      union {
        struct {
          USHORT Size;         // offset: 0x8 (8)
          UCHAR Flags;         // offset: 0xa (10)
          UCHAR SmallTagIndex; // offset: 0xb (11)
        };
        struct {
          ULONG SubSegmentCode; // offset: 0x8 (8)
          USHORT PreviousSize;  // offset: 0xc (12)
          union {
            UCHAR SegmentOffset; // offset: 0xe (14)
            UCHAR LFHFlags;      // offset: 0xe (14)
          };
          UCHAR UnusedBytes; // offset: 0xf (15)
        };
        ULONGLONG CompactHeader; // offset: 0x8 (8)
      };
    };
    struct _HEAP_EXTENDED_ENTRY ExtendedEntry; // offset: 0x0 (0)
    struct {
      VOID *Reserved; // offset: 0x0 (0)
      union {
        struct {
          USHORT FunctionIndex; // offset: 0x8 (8)
          USHORT ContextValue;  // offset: 0xa (10)
        };
        ULONG InterceptorValue; // offset: 0x8 (8)
      };
      USHORT UnusedBytesLength;     // offset: 0xc (12)
      UCHAR EntryOffset;            // offset: 0xe (14)
      UCHAR ExtendedBlockSignature; // offset: 0xf (15)
    };
    struct {
      VOID *ReservedForAlignment; // offset: 0x0 (0)
      union {
        struct {
          ULONG Code1; // offset: 0x8 (8)
          union {
            struct {
              USHORT Code2; // offset: 0xc (12)
              UCHAR Code3;  // offset: 0xe (14)
              UCHAR Code4;  // offset: 0xf (15)
            };
            ULONG Code234; // offset: 0xc (12)
          };
        };
        ULONGLONG AgregateCode; // offset: 0x8 (8)
      };
    };
  };
};

// 0x20 (32) bytes
struct _HEAP_FREE_ENTRY {
  union {
    struct _HEAP_ENTRY HeapEntry;              // offset: 0x0 (0)
    struct _HEAP_UNPACKED_ENTRY UnpackedEntry; // offset: 0x0 (0)
    struct {
      VOID *PreviousBlockPrivateData; // offset: 0x0 (0)
      union {
        struct {
          USHORT Size;         // offset: 0x8 (8)
          UCHAR Flags;         // offset: 0xa (10)
          UCHAR SmallTagIndex; // offset: 0xb (11)
        };
        struct {
          ULONG SubSegmentCode; // offset: 0x8 (8)
          USHORT PreviousSize;  // offset: 0xc (12)
          union {
            UCHAR SegmentOffset; // offset: 0xe (14)
            UCHAR LFHFlags;      // offset: 0xe (14)
          };
          UCHAR UnusedBytes; // offset: 0xf (15)
        };
        ULONGLONG CompactHeader; // offset: 0x8 (8)
      };
    };
    struct _HEAP_EXTENDED_ENTRY ExtendedEntry; // offset: 0x0 (0)
    struct {
      VOID *Reserved; // offset: 0x0 (0)
      union {
        struct {
          USHORT FunctionIndex; // offset: 0x8 (8)
          USHORT ContextValue;  // offset: 0xa (10)
        };
        ULONG InterceptorValue; // offset: 0x8 (8)
      };
      USHORT UnusedBytesLength;     // offset: 0xc (12)
      UCHAR EntryOffset;            // offset: 0xe (14)
      UCHAR ExtendedBlockSignature; // offset: 0xf (15)
    };
    struct {
      VOID *ReservedForAlignment; // offset: 0x0 (0)
      union {
        struct {
          ULONG Code1; // offset: 0x8 (8)
          union {
            struct {
              USHORT Code2; // offset: 0xc (12)
              UCHAR Code3;  // offset: 0xe (14)
              UCHAR Code4;  // offset: 0xf (15)
            };
            ULONG Code234; // offset: 0xc (12)
          };
        };
        ULONGLONG AgregateCode; // offset: 0x8 (8)
      };
    };
  };
  struct _LIST_ENTRY FreeList; // offset: 0x10 (16)
};

// 0x40 (64) bytes
struct _HEAP_VIRTUAL_ALLOC_ENTRY {
  struct _LIST_ENTRY Entry;            // offset: 0x0 (0)
  struct _HEAP_ENTRY_EXTRA ExtraStuff; // offset: 0x10 (16)
  ULONGLONG CommitSize;                // offset: 0x20 (32)
  ULONGLONG ReserveSize;               // offset: 0x28 (40)
  struct _HEAP_ENTRY BusyBlock;        // offset: 0x30 (48)
};

// 0x70 (112) bytes
struct _HEAP_SEGMENT {
  struct _HEAP_ENTRY Entry;              // offset: 0x0 (0)
  ULONG SegmentSignature;                // offset: 0x10 (16)
  ULONG SegmentFlags;                    // offset: 0x14 (20)
  struct _LIST_ENTRY SegmentListEntry;   // offset: 0x18 (24)
  struct _HEAP *Heap;                    // offset: 0x28 (40)
  VOID *BaseAddress;                     // offset: 0x30 (48)
  ULONG NumberOfPages;                   // offset: 0x38 (56)
  struct _HEAP_ENTRY *FirstEntry;        // offset: 0x40 (64)
  struct _HEAP_ENTRY *LastValidEntry;    // offset: 0x48 (72)
  ULONG NumberOfUnCommittedPages;        // offset: 0x50 (80)
  ULONG NumberOfUnCommittedRanges;       // offset: 0x54 (84)
  USHORT SegmentAllocatorBackTraceIndex; // offset: 0x58 (88)
  USHORT Reserved;                       // offset: 0x5a (90)
  struct _LIST_ENTRY UCRSegmentList;     // offset: 0x60 (96)
};

// 0x28 (40) bytes
struct _HEAP_VS_SUBSEGMENT {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
  ULONGLONG CommitBitmap;       // offset: 0x10 (16)
  ULONGLONG CommitLock;         // offset: 0x18 (24)
  USHORT Size;                  // offset: 0x20 (32)
  USHORT Signature : 15;        // offset: 0x22 (34)
  USHORT FullCommit : 1;        // offset: 0x22 (34)
};

// 0x8 (8) bytes
union _HEAP_VS_CHUNK_HEADER_SIZE {
  ULONG MemoryCost : 16; // offset: 0x0 (0)
  struct {
    ULONG UnsafeSize : 16;     // offset: 0x0 (0)
    ULONG UnsafePrevSize : 16; // offset: 0x4 (4)
    ULONG Allocated : 8;       // offset: 0x4 (4)
  };
  USHORT KeyUShort;     // offset: 0x0 (0)
  ULONG KeyULong;       // offset: 0x0 (0)
  ULONGLONG HeaderBits; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _HEAP_VS_CHUNK_HEADER {
  union _HEAP_VS_CHUNK_HEADER_SIZE Sizes; // offset: 0x0 (0)
  union {
    struct {
      ULONG EncodedSegmentPageOffset : 8; // offset: 0x8 (8)
      ULONG UnusedBytes : 1;              // offset: 0x8 (8)
      ULONG SkipDuringWalk : 1;           // offset: 0x8 (8)
      ULONG Spare : 22;                   // offset: 0x8 (8)
    };
    ULONG AllocatedChunkBits; // offset: 0x8 (8)
  };
};

// 0x18 (24) bytes
struct _RTLP_HP_QUEUE_LOCK_HANDLE {
  ULONGLONG Reserved1;  // offset: 0x0 (0)
  ULONGLONG LockPtr;    // offset: 0x8 (8)
  ULONGLONG HandleData; // offset: 0x10 (16)
};

// 0x8 (8) bytes
union _HEAP_LFH_SUBSEGMENT_DELAY_FREE {
  ULONGLONG DelayFree : 1; // offset: 0x0 (0)
  ULONGLONG Count : 63;    // offset: 0x0 (0)
  VOID *AllBits;           // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _RTL_SRWLOCK {
  union {
    struct {
      ULONGLONG Locked : 1;         // offset: 0x0 (0)
      ULONGLONG Waiting : 1;        // offset: 0x0 (0)
      ULONGLONG Waking : 1;         // offset: 0x0 (0)
      ULONGLONG MultipleShared : 1; // offset: 0x0 (0)
      ULONGLONG Shared : 60;        // offset: 0x0 (0)
    };
    ULONGLONG Value; // offset: 0x0 (0)
    VOID *Ptr;       // offset: 0x0 (0)
  };
};

// 0x180 (384) bytes
struct _ALPC_COMPLETION_LIST_HEADER {
  ULONGLONG StartMagic;                              // offset: 0x0 (0)
  ULONG TotalSize;                                   // offset: 0x8 (8)
  ULONG ListOffset;                                  // offset: 0xc (12)
  ULONG ListSize;                                    // offset: 0x10 (16)
  ULONG BitmapOffset;                                // offset: 0x14 (20)
  ULONG BitmapSize;                                  // offset: 0x18 (24)
  ULONG DataOffset;                                  // offset: 0x1c (28)
  ULONG DataSize;                                    // offset: 0x20 (32)
  ULONG AttributeFlags;                              // offset: 0x24 (36)
  ULONG AttributeSize;                               // offset: 0x28 (40)
  volatile struct _ALPC_COMPLETION_LIST_STATE State; // offset: 0x40 (64)
  volatile ULONG LastMessageId;                      // offset: 0x48 (72)
  volatile ULONG LastCallbackId;                     // offset: 0x4c (76)
  volatile ULONG PostCount;                          // offset: 0x80 (128)
  volatile ULONG ReturnCount;                        // offset: 0xc0 (192)
  volatile ULONG LogSequenceNumber;                  // offset: 0x100 (256)
  struct _RTL_SRWLOCK UserLock;                      // offset: 0x140 (320)
  ULONGLONG EndMagic;                                // offset: 0x148 (328)
};

// 0x48 (72) bytes
struct _RTL_STACKDB_CONTEXT {
  struct _RTL_HASH_TABLE StackSegmentTable;      // offset: 0x0 (0)
  struct _RTL_HASH_TABLE StackEntryTable;        // offset: 0x10 (16)
  struct _RTL_SRWLOCK StackEntryTableLock;       // offset: 0x20 (32)
  struct _RTL_SRWLOCK SegmentTableLock;          // offset: 0x28 (40)
  VOID *(*Allocate)(ULONGLONG arg1, VOID *arg2); // offset: 0x30 (48)
  VOID (*Free)(VOID *arg1, VOID *arg2);          // offset: 0x38 (56)
  VOID *AllocatorContext;                        // offset: 0x40 (64)
};

// 0x8 (8) bytes
struct _HEAP_LFH_FAST_REF {
  union {
    VOID *Target;            // offset: 0x0 (0)
    ULONGLONG Value;         // offset: 0x0 (0)
    ULONGLONG RefCount : 12; // offset: 0x0 (0)
  };
};

// 0x38 (56) bytes
struct _HEAP_LFH_SUBSEGMENT_OWNER {
  UCHAR IsBucket : 1; // offset: 0x0 (0)
  UCHAR Spare0 : 7;   // offset: 0x0 (0)
  UCHAR BucketIndex;  // offset: 0x1 (1)
  union {
    UCHAR SlotCount; // offset: 0x2 (2)
    UCHAR SlotIndex; // offset: 0x2 (2)
  };
  UCHAR Spare1;                               // offset: 0x3 (3)
  ULONGLONG AvailableSubsegmentCount;         // offset: 0x8 (8)
  ULONGLONG Lock;                             // offset: 0x10 (16)
  struct _LIST_ENTRY AvailableSubsegmentList; // offset: 0x18 (24)
  struct _LIST_ENTRY FullSubsegmentList;      // offset: 0x28 (40)
};

// 0x40 (64) bytes
struct _HEAP_LFH_AFFINITY_SLOT {
  struct _HEAP_LFH_SUBSEGMENT_OWNER State;    // offset: 0x0 (0)
  struct _HEAP_LFH_FAST_REF ActiveSubsegment; // offset: 0x38 (56)
};

// 0x68 (104) bytes
struct _HEAP_LFH_BUCKET {
  struct _HEAP_LFH_SUBSEGMENT_OWNER State;        // offset: 0x0 (0)
  ULONGLONG TotalBlockCount;                      // offset: 0x38 (56)
  ULONGLONG TotalSubsegmentCount;                 // offset: 0x40 (64)
  ULONG ReciprocalBlockSize;                      // offset: 0x48 (72)
  UCHAR Shift;                                    // offset: 0x4c (76)
  UCHAR ContentionCount;                          // offset: 0x4d (77)
  ULONGLONG AffinityMappingLock;                  // offset: 0x50 (80)
  UCHAR *ProcAffinityMapping;                     // offset: 0x58 (88)
  struct _HEAP_LFH_AFFINITY_SLOT **AffinitySlots; // offset: 0x60 (96)
};

// 0xc0 (192) bytes
struct _HEAP_SEG_CONTEXT {
  ULONGLONG SegmentMask;       // offset: 0x0 (0)
  UCHAR UnitShift;             // offset: 0x8 (8)
  UCHAR PagesPerUnitShift;     // offset: 0x9 (9)
  UCHAR FirstDescriptorIndex;  // offset: 0xa (10)
  UCHAR CachedCommitSoftShift; // offset: 0xb (11)
  UCHAR CachedCommitHighShift; // offset: 0xc (12)
  union {
    UCHAR LargePagePolicy : 3;      // offset: 0xd (13)
    UCHAR FullDecommit : 1;         // offset: 0xd (13)
    UCHAR ReleaseEmptySegments : 1; // offset: 0xd (13)
    UCHAR AllFlags;                 // offset: 0xd (13)

  } Flags;                                      // offset: 0xd (13)
  ULONG MaxAllocationSize;                      // offset: 0x10 (16)
  SHORT OlpStatsOffset;                         // offset: 0x14 (20)
  SHORT MemStatsOffset;                         // offset: 0x16 (22)
  VOID *LfhContext;                             // offset: 0x18 (24)
  VOID *VsContext;                              // offset: 0x20 (32)
  struct RTL_HP_ENV_HANDLE EnvHandle;           // offset: 0x28 (40)
  VOID *Heap;                                   // offset: 0x38 (56)
  ULONGLONG SegmentLock;                        // offset: 0x40 (64)
  struct _LIST_ENTRY SegmentListHead;           // offset: 0x48 (72)
  ULONGLONG SegmentCount;                       // offset: 0x58 (88)
  struct _RTL_RB_TREE FreePageRanges;           // offset: 0x60 (96)
  ULONGLONG FreeSegmentListLock;                // offset: 0x70 (112)
  struct _SINGLE_LIST_ENTRY FreeSegmentList[2]; // offset: 0x78 (120)
};

// 0x18 (24) bytes
struct _RTL_HP_SEG_ALLOC_POLICY {
  ULONGLONG MinLargePages; // offset: 0x0 (0)
  ULONGLONG MaxLargePages; // offset: 0x8 (8)
  UCHAR MinUtilization;    // offset: 0x10 (16)
};

// 0x58 (88) bytes
struct _HEAP_RUNTIME_MEMORY_STATS {
  volatile ULONGLONG TotalReservedPages;  // offset: 0x0 (0)
  volatile ULONGLONG TotalCommittedPages; // offset: 0x8 (8)
  ULONGLONG FreeCommittedPages;           // offset: 0x10 (16)
  ULONGLONG LfhFreeCommittedPages;        // offset: 0x18 (24)
  struct _HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS
      LargePageStats[2]; // offset: 0x20 (32)
  struct _RTL_HP_SEG_ALLOC_POLICY
      LargePageUtilizationPolicy; // offset: 0x40 (64)
};

// 0x10 (16) bytes
struct _FAKE_HEAP_ENTRY {
  ULONGLONG Size;         // offset: 0x0 (0)
  ULONGLONG PreviousSize; // offset: 0x8 (8)
};

// 0x8 (8) bytes
union _RTL_RUN_ONCE {
  VOID *Ptr;           // offset: 0x0 (0)
  ULONGLONG Value;     // offset: 0x0 (0)
  ULONGLONG State : 2; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _RTL_HEAP_MEMORY_LIMIT_DATA {
  ULONGLONG CommitLimitBytes;           // offset: 0x0 (0)
  ULONGLONG CommitLimitFailureCode;     // offset: 0x8 (8)
  ULONGLONG MaxAllocationSizeBytes;     // offset: 0x10 (16)
  ULONGLONG AllocationLimitFailureCode; // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _HEAP_SUBALLOCATOR_CALLBACKS {
  ULONGLONG Allocate;      // offset: 0x0 (0)
  ULONGLONG Free;          // offset: 0x8 (8)
  ULONGLONG Commit;        // offset: 0x10 (16)
  ULONGLONG Decommit;      // offset: 0x18 (24)
  ULONGLONG ExtendContext; // offset: 0x20 (32)
};

// 0x4c0 (1216) bytes
struct _HEAP_LFH_CONTEXT {
  VOID *BackendCtx;                              // offset: 0x0 (0)
  struct _HEAP_SUBALLOCATOR_CALLBACKS Callbacks; // offset: 0x8 (8)
  const UCHAR *AffinityModArray;                 // offset: 0x30 (48)
  UCHAR MaxAffinity;                             // offset: 0x38 (56)
  UCHAR LockType;                                // offset: 0x39 (57)
  SHORT MemStatsOffset;                          // offset: 0x3a (58)
  struct _RTL_HP_LFH_CONFIG Config;              // offset: 0x3c (60)
  union _HEAP_LFH_SUBSEGMENT_STATS BucketStats;  // offset: 0x40 (64)
  ULONGLONG SubsegmentCreationLock;              // offset: 0x48 (72)
  struct _HEAP_LFH_BUCKET *Buckets[129];         // offset: 0x80 (128)
};

// 0x78 (120) bytes
struct _PRIVATE_CACHE_MAP {
  union {
    SHORT NodeTypeCode;                    // offset: 0x0 (0)
    struct _PRIVATE_CACHE_MAP_FLAGS Flags; // offset: 0x0 (0)
  };
  ULONG ReadAheadMask;                          // offset: 0x4 (4)
  struct _FILE_OBJECT *FileObject;              // offset: 0x8 (8)
  union _LARGE_INTEGER FileOffset1;             // offset: 0x10 (16)
  union _LARGE_INTEGER BeyondLastByte1;         // offset: 0x18 (24)
  union _LARGE_INTEGER FileOffset2;             // offset: 0x20 (32)
  union _LARGE_INTEGER BeyondLastByte2;         // offset: 0x28 (40)
  ULONG SequentialReadCount;                    // offset: 0x30 (48)
  ULONG ReadAheadLength;                        // offset: 0x34 (52)
  union _LARGE_INTEGER ReadAheadOffset;         // offset: 0x38 (56)
  union _LARGE_INTEGER ReadAheadBeyondLastByte; // offset: 0x40 (64)
  ULONGLONG PrevReadAheadBeyondLastByte;        // offset: 0x48 (72)
  ULONGLONG ReadAheadSpinLock;                  // offset: 0x50 (80)
  ULONG PipelinedReadAheadRequestSize;          // offset: 0x58 (88)
  ULONG ReadAheadGrowth;                        // offset: 0x5c (92)
  struct _LIST_ENTRY PrivateLinks;              // offset: 0x60 (96)
  VOID *ReadAheadWorkItem;                      // offset: 0x70 (112)
};

// 0x38 (56) bytes
struct _DIRTY_PAGE_THRESHOLDS {
  ULONGLONG DirtyPageThreshold;       // offset: 0x0 (0)
  ULONGLONG DirtyPageThresholdTop;    // offset: 0x8 (8)
  ULONGLONG DirtyPageThresholdBottom; // offset: 0x10 (16)
  ULONG DirtyPageTarget;              // offset: 0x18 (24)
  ULONGLONG AggregateAvailablePages;  // offset: 0x20 (32)
  ULONGLONG AggregateDirtyPages;      // offset: 0x28 (40)
  ULONG AvailableHistory;             // offset: 0x30 (48)
};

// 0x18 (24) bytes
struct _DIRTY_PAGE_STATISTICS {
  ULONGLONG DirtyPages;              // offset: 0x0 (0)
  ULONGLONG DirtyPagesLastScan;      // offset: 0x8 (8)
  ULONG DirtyPagesScheduledLastScan; // offset: 0x10 (16)
};

// 0x30 (48) bytes
struct _CC_EXTERNAL_CACHE_INFO {
  VOID (*Callback)(VOID *arg1, ULONGLONG arg2, ULONG arg3); // offset: 0x0 (0)
  struct _DIRTY_PAGE_STATISTICS DirtyPageStatistics;        // offset: 0x8 (8)
  struct _LIST_ENTRY Links;                                 // offset: 0x20 (32)
};

// 0x98 (152) bytes
struct _LOG_HANDLE_CONTEXT {
  VOID *LogHandle; // offset: 0x0 (0)
  VOID (*FlushToLsnRoutine)
  (VOID *arg1, union _LARGE_INTEGER arg2); // offset: 0x8 (8)
  VOID (*QueryLogHandleInfoRoutine)
  (VOID *arg1, WCHAR *arg2);                         // offset: 0x10 (16)
  struct _DIRTY_PAGE_STATISTICS DirtyPageStatistics; // offset: 0x18 (24)
  struct _DIRTY_PAGE_THRESHOLDS DirtyPageThresholds; // offset: 0x30 (48)
  ULONG AdditionalPagesToWrite;                      // offset: 0x68 (104)
  ULONG CcLWScanDPThreshold;                         // offset: 0x6c (108)
  union _LARGE_INTEGER LargestLsnForCurrentLWScan;   // offset: 0x70 (112)
  struct _FILE_OBJECT *RelatedFileObject;            // offset: 0x78 (120)
  ULONGLONG LargestLsnFileObjectKey;                 // offset: 0x80 (128)
  union _LARGE_INTEGER LastLWTimeStamp;              // offset: 0x88 (136)
  ULONG Flags;                                       // offset: 0x90 (144)
};

// 0x8 (8) bytes
struct _LOGGED_STREAM_CALLBACK_V2 {
  struct _LOG_HANDLE_CONTEXT *LogHandleContext; // offset: 0x0 (0)
};

// 0xd0 (208) bytes
struct _VOLUME_CACHE_MAP {
  SHORT NodeTypeCode;                          // offset: 0x0 (0)
  SHORT NodeByteCode;                          // offset: 0x2 (2)
  ULONG UseCount;                              // offset: 0x4 (4)
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x8 (8)
  struct _LIST_ENTRY VolumeCacheMapLinks;      // offset: 0x10 (16)
  ULONGLONG DirtyPages;                        // offset: 0x20 (32)
  struct _LOG_HANDLE_CONTEXT LogHandleContext; // offset: 0x28 (40)
  ULONG Flags;                                 // offset: 0xc0 (192)
  ULONG PagesQueuedToDisk;                     // offset: 0xc4 (196)
  ULONG LoggedPagesQueuedToDisk;               // offset: 0xc8 (200)
};

// 0x8 (8) bytes
union _PPM_POLICY_SETTINGS_MASK {
  ULONGLONG Value;                               // offset: 0x0 (0)
  ULONG PerfDecreaseTime : 1;                    // offset: 0x0 (0)
  ULONG PerfIncreaseTime : 1;                    // offset: 0x0 (0)
  ULONG PerfDecreasePolicy : 1;                  // offset: 0x0 (0)
  ULONG PerfIncreasePolicy : 1;                  // offset: 0x0 (0)
  ULONG PerfDecreaseThreshold : 1;               // offset: 0x0 (0)
  ULONG PerfIncreaseThreshold : 1;               // offset: 0x0 (0)
  ULONG PerfMinPolicy : 1;                       // offset: 0x0 (0)
  ULONG PerfMaxPolicy : 1;                       // offset: 0x0 (0)
  ULONG PerfTimeCheck : 1;                       // offset: 0x0 (0)
  ULONG PerfBoostPolicy : 1;                     // offset: 0x0 (0)
  ULONG PerfBoostMode : 1;                       // offset: 0x0 (0)
  ULONG AllowThrottling : 1;                     // offset: 0x0 (0)
  ULONG PerfHistoryCount : 1;                    // offset: 0x0 (0)
  ULONG ParkingPerfState : 1;                    // offset: 0x0 (0)
  ULONG LatencyHintPerf : 1;                     // offset: 0x0 (0)
  ULONG LatencyHintUnpark : 1;                   // offset: 0x0 (0)
  ULONG CoreParkingMinCores : 1;                 // offset: 0x0 (0)
  ULONG CoreParkingMaxCores : 1;                 // offset: 0x0 (0)
  ULONG CoreParkingDecreasePolicy : 1;           // offset: 0x0 (0)
  ULONG CoreParkingIncreasePolicy : 1;           // offset: 0x0 (0)
  ULONG CoreParkingDecreaseTime : 1;             // offset: 0x0 (0)
  ULONG CoreParkingIncreaseTime : 1;             // offset: 0x0 (0)
  ULONG CoreParkingOverUtilizationThreshold : 1; // offset: 0x0 (0)
  ULONG CoreParkingDistributeUtility : 1;        // offset: 0x0 (0)
  ULONG CoreParkingConcurrencyThreshold : 1;     // offset: 0x0 (0)
  ULONG CoreParkingHeadroomThreshold : 1;        // offset: 0x0 (0)
  ULONG CoreParkingDistributionThreshold : 1;    // offset: 0x0 (0)
  ULONG IdleAllowScaling : 1;                    // offset: 0x0 (0)
  ULONG IdleDisable : 1;                         // offset: 0x0 (0)
  ULONG IdleTimeCheck : 1;                       // offset: 0x0 (0)
  ULONG IdleDemoteThreshold : 1;                 // offset: 0x0 (0)
  struct {
    ULONG IdlePromoteThreshold : 1;           // offset: 0x0 (0)
    ULONG HeteroDecreaseTime : 1;             // offset: 0x4 (4)
    ULONG HeteroIncreaseTime : 1;             // offset: 0x4 (4)
    ULONG HeteroDecreaseThreshold : 1;        // offset: 0x4 (4)
    ULONG HeteroIncreaseThreshold : 1;        // offset: 0x4 (4)
    ULONG Class0FloorPerformance : 1;         // offset: 0x4 (4)
    ULONG Class1InitialPerformance : 1;       // offset: 0x4 (4)
    ULONG EnergyPerfPreference : 1;           // offset: 0x4 (4)
    ULONG AutonomousActivityWindow : 1;       // offset: 0x4 (4)
    ULONG AutonomousMode : 1;                 // offset: 0x4 (4)
    ULONG DutyCycling : 1;                    // offset: 0x4 (4)
    ULONG FrequencyCap : 1;                   // offset: 0x4 (4)
    ULONG ThreadPolicy : 1;                   // offset: 0x4 (4)
    ULONG ShortThreadPolicy : 1;              // offset: 0x4 (4)
    ULONG IdleStateMax : 1;                   // offset: 0x4 (4)
    ULONG ResponsivenessDisableThreshold : 1; // offset: 0x4 (4)
    ULONG ResponsivenessEnableThreshold : 1;  // offset: 0x4 (4)
    ULONG ResponsivenessDisableTime : 1;      // offset: 0x4 (4)
    ULONG ResponsivenessEnableTime : 1;       // offset: 0x4 (4)
    ULONG ResponsivenessEppCeiling : 1;       // offset: 0x4 (4)
    ULONG ResponsivenessPerfFloor : 1;        // offset: 0x4 (4)
    ULONG SoftParkLatency : 1;                // offset: 0x4 (4)
  };
  ULONG Spare : 11; // offset: 0x4 (4)
};

// 0xab0 (2736) bytes
struct _PPM_ENGINE_SETTINGS {
  union _PPM_POLICY_SETTINGS_MASK ExplicitSetting[2]; // offset: 0x0 (0)
  UCHAR ThrottlingPolicy;                             // offset: 0x10 (16)
  ULONG PerfTimeCheck;                                // offset: 0x14 (20)
  UCHAR PerfHistoryCount[2];                          // offset: 0x18 (24)
  UCHAR PerfMinPolicy[2];                             // offset: 0x1a (26)
  UCHAR PerfMaxPolicy[2];                             // offset: 0x1c (28)
  UCHAR PerfDecreaseTime[2];                          // offset: 0x1e (30)
  UCHAR PerfIncreaseTime[2];                          // offset: 0x20 (32)
  UCHAR PerfDecreasePolicy[2];                        // offset: 0x22 (34)
  UCHAR PerfIncreasePolicy[2];                        // offset: 0x24 (36)
  UCHAR PerfDecreaseThreshold[2];                     // offset: 0x26 (38)
  UCHAR PerfIncreaseThreshold[2];                     // offset: 0x28 (40)
  ULONG PerfFrequencyCap[2];                          // offset: 0x2c (44)
  ULONG PerfBoostPolicy;                              // offset: 0x34 (52)
  ULONG PerfBoostMode;                                // offset: 0x38 (56)
  ULONG PerfReductionTolerance;                       // offset: 0x3c (60)
  ULONG EnergyPerfPreference[2];                      // offset: 0x40 (64)
  ULONG AutonomousActivityWindow;                     // offset: 0x48 (72)
  UCHAR AutonomousPreference;                         // offset: 0x4c (76)
  UCHAR LatencyHintPerf[2];                           // offset: 0x4d (77)
  UCHAR LatencyHintUnpark[2];                         // offset: 0x4f (79)
  ULONG ResponsivenessDisableThreshold[2];            // offset: 0x54 (84)
  ULONG ResponsivenessEnableThreshold[2];             // offset: 0x5c (92)
  UCHAR ResponsivenessDisableTime[2];                 // offset: 0x64 (100)
  UCHAR ResponsivenessEnableTime[2];                  // offset: 0x66 (102)
  ULONG ResponsivenessEppCeiling[2];                  // offset: 0x68 (104)
  ULONG ResponsivenessPerfFloor[2];                   // offset: 0x70 (112)
  UCHAR DutyCycling;                                  // offset: 0x78 (120)
  UCHAR ParkingPerfState[2];                          // offset: 0x79 (121)
  UCHAR DistributeUtility;                            // offset: 0x7b (123)
  UCHAR CoreParkingOverUtilizationThreshold;          // offset: 0x7c (124)
  UCHAR CoreParkingConcurrencyThreshold;              // offset: 0x7d (125)
  UCHAR CoreParkingHeadroomThreshold;                 // offset: 0x7e (126)
  UCHAR CoreParkingDistributionThreshold;             // offset: 0x7f (127)
  UCHAR CoreParkingDecreasePolicy;                    // offset: 0x80 (128)
  UCHAR CoreParkingIncreasePolicy;                    // offset: 0x81 (129)
  ULONG CoreParkingDecreaseTime;                      // offset: 0x84 (132)
  ULONG CoreParkingIncreaseTime;                      // offset: 0x88 (136)
  UCHAR CoreParkingMinCores[2];                       // offset: 0x8c (140)
  UCHAR CoreParkingMaxCores[2];                       // offset: 0x8e (142)
  ULONG SoftParkLatency;                              // offset: 0x90 (144)
  UCHAR AllowScaling;                                 // offset: 0x94 (148)
  UCHAR IdleDisabled;                                 // offset: 0x95 (149)
  ULONG IdleTimeCheck;                                // offset: 0x98 (152)
  UCHAR IdleDemotePercent;                            // offset: 0x9c (156)
  UCHAR IdlePromotePercent;                           // offset: 0x9d (157)
  UCHAR IdleStateMax;                                 // offset: 0x9e (158)
  UCHAR HeteroDecreaseTime;                           // offset: 0x9f (159)
  UCHAR HeteroIncreaseTime;                           // offset: 0xa0 (160)
  UCHAR HeteroDecreaseThreshold[1280];                // offset: 0xa1 (161)
  UCHAR HeteroIncreaseThreshold[1280];                // offset: 0x5a1 (1441)
  UCHAR Class0FloorPerformance;                       // offset: 0xaa1 (2721)
  UCHAR Class1InitialPerformance;                     // offset: 0xaa2 (2722)
  enum _KHETERO_CPU_POLICY ThreadPolicies[2];         // offset: 0xaa4 (2724)
};

// 0x15b0 (5552) bytes
struct _POP_PPM_PROFILE {
  WCHAR *Name;                             // offset: 0x0 (0)
  UCHAR Id;                                // offset: 0x8 (8)
  struct _GUID Guid;                       // offset: 0xc (12)
  ULONG Flags;                             // offset: 0x1c (28)
  UCHAR Priority;                          // offset: 0x20 (32)
  struct _PPM_ENGINE_SETTINGS Settings[2]; // offset: 0x28 (40)
  ULONGLONG StartTime;                     // offset: 0x1588 (5512)
  ULONGLONG Count;                         // offset: 0x1590 (5520)
  ULONGLONG MaxDuration;                   // offset: 0x1598 (5528)
  ULONGLONG MinDuration;                   // offset: 0x15a0 (5536)
  ULONGLONG TotalDuration;                 // offset: 0x15a8 (5544)
};

// 0x10 (16) bytes
struct _PROCESSOR_PLATFORM_STATE_RESIDENCY {
  ULONGLONG Residency;       // offset: 0x0 (0)
  ULONGLONG TransitionCount; // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _PROCESSOR_PLATFORM_STATE_RESIDENCIES {
  ULONG Count;                                          // offset: 0x0 (0)
  struct _PROCESSOR_PLATFORM_STATE_RESIDENCY States[1]; // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _PEP_ACPI_EXTENDED_ADDRESS {
  enum _PEP_ACPI_RESOURCE_TYPE Type;      // offset: 0x0 (0)
  union _PEP_ACPI_RESOURCE_FLAGS Flags;   // offset: 0x4 (4)
  UCHAR ResourceFlags;                    // offset: 0x8 (8)
  UCHAR GeneralFlags;                     // offset: 0x9 (9)
  UCHAR TypeSpecificFlags;                // offset: 0xa (10)
  UCHAR RevisionId;                       // offset: 0xb (11)
  UCHAR Reserved;                         // offset: 0xc (12)
  ULONGLONG Granularity;                  // offset: 0x10 (16)
  ULONGLONG MinimumAddress;               // offset: 0x18 (24)
  ULONGLONG MaximumAddress;               // offset: 0x20 (32)
  ULONGLONG TranslationAddress;           // offset: 0x28 (40)
  ULONGLONG AddressLength;                // offset: 0x30 (48)
  ULONGLONG TypeAttribute;                // offset: 0x38 (56)
  struct _UNICODE_STRING *DescriptorName; // offset: 0x40 (64)
};

// 0x48 (72) bytes
union _PEP_ACPI_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;                 // offset: 0x0 (0)
  struct _PEP_ACPI_IO_MEMORY_RESOURCE IoMemory;      // offset: 0x0 (0)
  struct _PEP_ACPI_INTERRUPT_RESOURCE Interrupt;     // offset: 0x0 (0)
  struct _PEP_ACPI_GPIO_RESOURCE Gpio;               // offset: 0x0 (0)
  struct _PEP_ACPI_SPB_I2C_RESOURCE SpbI2c;          // offset: 0x0 (0)
  struct _PEP_ACPI_SPB_SPI_RESOURCE SpbSpi;          // offset: 0x0 (0)
  struct _PEP_ACPI_SPB_UART_RESOURCE SpbUart;        // offset: 0x0 (0)
  struct _PEP_ACPI_EXTENDED_ADDRESS ExtendedAddress; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _DEVICE_DATA_SET_RANGE {
  LONGLONG StartingOffset; // offset: 0x0 (0)
  ULONGLONG LengthInBytes; // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _ARM64_DBGKD_CONTROL_SET {
  ULONG Continue;               // offset: 0x0 (0)
  ULONG TraceFlag;              // offset: 0x4 (4)
  ULONGLONG CurrentSymbolStart; // offset: 0x8 (8)
  ULONGLONG CurrentSymbolEnd;   // offset: 0x10 (16)
};

// 0x14 (20) bytes
struct _IA64_DBGKD_CONTROL_SET {
  ULONG Continue;               // offset: 0x0 (0)
  ULONGLONG CurrentSymbolStart; // offset: 0x4 (4)
  ULONGLONG CurrentSymbolEnd;   // offset: 0xc (12)
};

// 0x1c (28) bytes
struct _AMD64_DBGKD_CONTROL_SET {
  ULONG TraceFlag;              // offset: 0x0 (0)
  ULONGLONG Dr7;                // offset: 0x4 (4)
  ULONGLONG CurrentSymbolStart; // offset: 0xc (12)
  ULONGLONG CurrentSymbolEnd;   // offset: 0x14 (20)
};

// 0x1c (28) bytes
struct _DBGKD_ANY_CONTROL_SET {
  union {
    struct _X86_DBGKD_CONTROL_SET X86ControlSet;     // offset: 0x0 (0)
    ULONG AlphaControlSet;                           // offset: 0x0 (0)
    struct _IA64_DBGKD_CONTROL_SET IA64ControlSet;   // offset: 0x0 (0)
    struct _AMD64_DBGKD_CONTROL_SET Amd64ControlSet; // offset: 0x0 (0)
    struct _ARM_DBGKD_CONTROL_SET ArmControlSet;     // offset: 0x0 (0)
    struct _ARM64_DBGKD_CONTROL_SET Arm64ControlSet; // offset: 0x0 (0)
    struct _ARMCE_DBGKD_CONTROL_SET ArmCeControlSet; // offset: 0x0 (0)
    struct _PPC_DBGKD_CONTROL_SET PpcControlSet;     // offset: 0x0 (0)
  };
};

// 0x20 (32) bytes
struct _DBGKD_CONTINUE2 {
  LONG ContinueStatus; // offset: 0x0 (0)
  union {
    struct _AMD64_DBGKD_CONTROL_SET ControlSet;  // offset: 0x4 (4)
    struct _DBGKD_ANY_CONTROL_SET AnyControlSet; // offset: 0x4 (4)
  };
};

// 0x18 (24) bytes
struct _DBGKD_WRITE_CUSTOM_BREAKPOINT {
  ULONGLONG BreakPointAddress;          // offset: 0x0 (0)
  ULONGLONG BreakPointInstruction;      // offset: 0x8 (8)
  ULONG BreakPointHandle;               // offset: 0x10 (16)
  UCHAR BreakPointInstructionSize;      // offset: 0x14 (20)
  UCHAR BreakPointInstructionAlignment; // offset: 0x15 (21)
};

// 0x18 (24) bytes
struct _DBGKD_QUERY_MEMORY {
  ULONGLONG Address;  // offset: 0x0 (0)
  ULONGLONG Reserved; // offset: 0x8 (8)
  ULONG AddressSpace; // offset: 0x10 (16)
  ULONG Flags;        // offset: 0x14 (20)
};

// 0x10 (16) bytes
struct _DBGKD_FILL_MEMORY {
  ULONGLONG Address;    // offset: 0x0 (0)
  ULONG Length;         // offset: 0x8 (8)
  USHORT Flags;         // offset: 0xc (12)
  USHORT PatternLength; // offset: 0xe (14)
};

// 0x18 (24) bytes
struct _DBGKD_SEARCH_MEMORY {
  union {
    ULONGLONG SearchAddress; // offset: 0x0 (0)
    ULONGLONG FoundAddress;  // offset: 0x0 (0)
  };
  ULONGLONG SearchLength; // offset: 0x8 (8)
  ULONG PatternLength;    // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _DBGKD_GET_VERSION64 {
  USHORT MajorVersion;          // offset: 0x0 (0)
  USHORT MinorVersion;          // offset: 0x2 (2)
  UCHAR ProtocolVersion;        // offset: 0x4 (4)
  UCHAR KdSecondaryVersion;     // offset: 0x5 (5)
  USHORT Flags;                 // offset: 0x6 (6)
  USHORT MachineType;           // offset: 0x8 (8)
  UCHAR MaxPacketType;          // offset: 0xa (10)
  UCHAR MaxStateChange;         // offset: 0xb (11)
  UCHAR MaxManipulate;          // offset: 0xc (12)
  UCHAR Simulation;             // offset: 0xd (13)
  USHORT Unused[1];             // offset: 0xe (14)
  ULONGLONG KernBase;           // offset: 0x10 (16)
  ULONGLONG PsLoadedModuleList; // offset: 0x18 (24)
  ULONGLONG DebuggerDataList;   // offset: 0x20 (32)
};

// 0x20 (32) bytes
struct _DBGKD_GET_INTERNAL_BREAKPOINT64 {
  ULONGLONG BreakpointAddress; // offset: 0x0 (0)
  ULONG Flags;                 // offset: 0x8 (8)
  ULONG Calls;                 // offset: 0xc (12)
  ULONG MaxCallsPerPeriod;     // offset: 0x10 (16)
  ULONG MinInstructions;       // offset: 0x14 (20)
  ULONG MaxInstructions;       // offset: 0x18 (24)
  ULONG TotalInstructions;     // offset: 0x1c (28)
};

// 0x10 (16) bytes
struct _DBGKD_SET_INTERNAL_BREAKPOINT64 {
  ULONGLONG BreakpointAddress; // offset: 0x0 (0)
  ULONG Flags;                 // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _DBGKD_SET_SPECIAL_CALL64 {
  ULONGLONG SpecialCall; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _DBGKD_READ_WRITE_IO_EXTENDED64 {
  ULONG DataSize;      // offset: 0x0 (0)
  ULONG InterfaceType; // offset: 0x4 (4)
  ULONG BusNumber;     // offset: 0x8 (8)
  ULONG AddressSpace;  // offset: 0xc (12)
  ULONGLONG IoAddress; // offset: 0x10 (16)
  ULONG DataValue;     // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct _DBGKD_READ_WRITE_IO64 {
  ULONGLONG IoAddress; // offset: 0x0 (0)
  ULONG DataSize;      // offset: 0x8 (8)
  ULONG DataValue;     // offset: 0xc (12)
};

// 0x10 (16) bytes
struct _DBGKD_WRITE_BREAKPOINT64 {
  ULONGLONG BreakPointAddress; // offset: 0x0 (0)
  ULONG BreakPointHandle;      // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _DBGKD_WRITE_MEMORY64 {
  ULONGLONG TargetBaseAddress; // offset: 0x0 (0)
  ULONG TransferCount;         // offset: 0x8 (8)
  ULONG ActualBytesWritten;    // offset: 0xc (12)
};

// 0x10 (16) bytes
struct _DBGKD_READ_MEMORY64 {
  ULONGLONG TargetBaseAddress; // offset: 0x0 (0)
  ULONG TransferCount;         // offset: 0x8 (8)
  ULONG ActualBytesRead;       // offset: 0xc (12)
};

// 0x34 (52) bytes
struct _DBGKD_MANIPULATE_STATE32 {
  ULONG ApiNumber;       // offset: 0x0 (0)
  USHORT ProcessorLevel; // offset: 0x4 (4)
  USHORT Processor;      // offset: 0x6 (6)
  LONG ReturnStatus;     // offset: 0x8 (8)
  union {
    struct _DBGKD_READ_MEMORY32 ReadMemory;             // offset: 0xc (12)
    struct _DBGKD_WRITE_MEMORY32 WriteMemory;           // offset: 0xc (12)
    struct _DBGKD_READ_MEMORY64 ReadMemory64;           // offset: 0xc (12)
    struct _DBGKD_WRITE_MEMORY64 WriteMemory64;         // offset: 0xc (12)
    struct _DBGKD_GET_CONTEXT GetContext;               // offset: 0xc (12)
    struct _DBGKD_SET_CONTEXT SetContext;               // offset: 0xc (12)
    struct _DBGKD_WRITE_BREAKPOINT32 WriteBreakPoint;   // offset: 0xc (12)
    struct _DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint; // offset: 0xc (12)
    struct _DBGKD_CONTINUE Continue;                    // offset: 0xc (12)
    struct _DBGKD_CONTINUE2 Continue2;                  // offset: 0xc (12)
    struct _DBGKD_READ_WRITE_IO32 ReadWriteIo;          // offset: 0xc (12)
    struct _DBGKD_READ_WRITE_IO_EXTENDED32
        ReadWriteIoExtended;                             // offset: 0xc (12)
    struct _DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls; // offset: 0xc (12)
    struct _DBGKD_SET_SPECIAL_CALL32 SetSpecialCall;     // offset: 0xc (12)
    struct _DBGKD_SET_INTERNAL_BREAKPOINT32
        SetInternalBreakpoint; // offset: 0xc (12)
    struct _DBGKD_GET_INTERNAL_BREAKPOINT32
        GetInternalBreakpoint;                 // offset: 0xc (12)
    struct _DBGKD_GET_VERSION32 GetVersion32;  // offset: 0xc (12)
    struct _DBGKD_BREAKPOINTEX BreakPointEx;   // offset: 0xc (12)
    struct _DBGKD_READ_WRITE_MSR ReadWriteMsr; // offset: 0xc (12)
    struct _DBGKD_SEARCH_MEMORY SearchMemory;  // offset: 0xc (12)
    struct _DBGKD_CONTEXT_EX GetContextEx;     // offset: 0xc (12)
    struct _DBGKD_CONTEXT_EX SetContextEx;     // offset: 0xc (12)

  } u; // offset: 0xc (12)
};

// 0x38 (56) bytes
struct _DBGKD_MANIPULATE_STATE64 {
  ULONG ApiNumber;       // offset: 0x0 (0)
  USHORT ProcessorLevel; // offset: 0x4 (4)
  USHORT Processor;      // offset: 0x6 (6)
  LONG ReturnStatus;     // offset: 0x8 (8)
  union {
    struct _DBGKD_READ_MEMORY64 ReadMemory;             // offset: 0x10 (16)
    struct _DBGKD_WRITE_MEMORY64 WriteMemory;           // offset: 0x10 (16)
    struct _DBGKD_GET_CONTEXT GetContext;               // offset: 0x10 (16)
    struct _DBGKD_SET_CONTEXT SetContext;               // offset: 0x10 (16)
    struct _DBGKD_WRITE_BREAKPOINT64 WriteBreakPoint;   // offset: 0x10 (16)
    struct _DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint; // offset: 0x10 (16)
    struct _DBGKD_CONTINUE Continue;                    // offset: 0x10 (16)
    struct _DBGKD_CONTINUE2 Continue2;                  // offset: 0x10 (16)
    struct _DBGKD_READ_WRITE_IO64 ReadWriteIo;          // offset: 0x10 (16)
    struct _DBGKD_READ_WRITE_IO_EXTENDED64
        ReadWriteIoExtended;                             // offset: 0x10 (16)
    struct _DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls; // offset: 0x10 (16)
    struct _DBGKD_SET_SPECIAL_CALL64 SetSpecialCall;     // offset: 0x10 (16)
    struct _DBGKD_SET_INTERNAL_BREAKPOINT64
        SetInternalBreakpoint; // offset: 0x10 (16)
    struct _DBGKD_GET_INTERNAL_BREAKPOINT64
        GetInternalBreakpoint;                      // offset: 0x10 (16)
    struct _DBGKD_GET_VERSION64 GetVersion64;       // offset: 0x10 (16)
    struct _DBGKD_BREAKPOINTEX BreakPointEx;        // offset: 0x10 (16)
    struct _DBGKD_READ_WRITE_MSR ReadWriteMsr;      // offset: 0x10 (16)
    struct _DBGKD_SEARCH_MEMORY SearchMemory;       // offset: 0x10 (16)
    struct _DBGKD_GET_SET_BUS_DATA GetSetBusData;   // offset: 0x10 (16)
    struct _DBGKD_FILL_MEMORY FillMemory;           // offset: 0x10 (16)
    struct _DBGKD_QUERY_MEMORY QueryMemory;         // offset: 0x10 (16)
    struct _DBGKD_SWITCH_PARTITION SwitchPartition; // offset: 0x10 (16)
    struct _DBGKD_CONTEXT_EX GetContextEx;          // offset: 0x10 (16)
    struct _DBGKD_CONTEXT_EX SetContextEx;          // offset: 0x10 (16)
    struct _DBGKD_WRITE_CUSTOM_BREAKPOINT
        WriteCustomBreakPoint; // offset: 0x10 (16)

  } u; // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _DBGKD_LOAD_SYMBOLS64 {
  ULONG PathNameLength; // offset: 0x0 (0)
  ULONGLONG BaseOfDll;  // offset: 0x8 (8)
  ULONGLONG ProcessId;  // offset: 0x10 (16)
  ULONG CheckSum;       // offset: 0x18 (24)
  ULONG SizeOfImage;    // offset: 0x1c (28)
  UCHAR UnloadSymbols;  // offset: 0x20 (32)
};

// 0x50 (80) bytes
struct _PNP_DEVICE_COMPLETION_QUEUE {
  struct _LIST_ENTRY DispatchedList;     // offset: 0x0 (0)
  ULONG DispatchedCount;                 // offset: 0x10 (16)
  struct _LIST_ENTRY CompletedList;      // offset: 0x18 (24)
  struct _KSEMAPHORE CompletedSemaphore; // offset: 0x28 (40)
  ULONGLONG SpinLock;                    // offset: 0x48 (72)
};

// 0x48 (72) bytes
struct _MCGEN_TRACE_CONTEXT {
  ULONGLONG RegistrationHandle;    // offset: 0x0 (0)
  ULONGLONG Logger;                // offset: 0x8 (8)
  ULONGLONG MatchAnyKeyword;       // offset: 0x10 (16)
  ULONGLONG MatchAllKeyword;       // offset: 0x18 (24)
  ULONG Flags;                     // offset: 0x20 (32)
  ULONG IsEnabled;                 // offset: 0x24 (36)
  UCHAR Level;                     // offset: 0x28 (40)
  UCHAR Reserve;                   // offset: 0x29 (41)
  USHORT EnableBitsCount;          // offset: 0x2a (42)
  ULONG *EnableBitMask;            // offset: 0x30 (48)
  const ULONGLONG *EnableKeyWords; // offset: 0x38 (56)
  const UCHAR *EnableLevel;        // offset: 0x40 (64)
};

// 0x8 (8) bytes
union _HV_PARTITION_PRIVILEGE_MASK {
  ULONGLONG AsUINT64;                            // offset: 0x0 (0)
  ULONGLONG AccessVpRunTimeReg : 1;              // offset: 0x0 (0)
  ULONGLONG AccessPartitionReferenceCounter : 1; // offset: 0x0 (0)
  ULONGLONG AccessSynicRegs : 1;                 // offset: 0x0 (0)
  ULONGLONG AccessSyntheticTimerRegs : 1;        // offset: 0x0 (0)
  ULONGLONG AccessIntrCtrlRegs : 1;              // offset: 0x0 (0)
  ULONGLONG AccessHypercallMsrs : 1;             // offset: 0x0 (0)
  ULONGLONG AccessVpIndex : 1;                   // offset: 0x0 (0)
  ULONGLONG AccessResetReg : 1;                  // offset: 0x0 (0)
  ULONGLONG AccessStatsReg : 1;                  // offset: 0x0 (0)
  ULONGLONG AccessPartitionReferenceTsc : 1;     // offset: 0x0 (0)
  ULONGLONG AccessGuestIdleReg : 1;              // offset: 0x0 (0)
  ULONGLONG AccessFrequencyRegs : 1;             // offset: 0x0 (0)
  ULONGLONG AccessDebugRegs : 1;                 // offset: 0x0 (0)
  ULONGLONG AccessReenlightenmentControls : 1;   // offset: 0x0 (0)
  ULONGLONG AccessRootSchedulerReg : 1;          // offset: 0x0 (0)
  ULONGLONG AccessTscInvariantControls : 1;      // offset: 0x0 (0)
  ULONGLONG Reserved1 : 16;                      // offset: 0x0 (0)
  ULONGLONG CreatePartitions : 1;                // offset: 0x0 (0)
  ULONGLONG AccessPartitionId : 1;               // offset: 0x0 (0)
  ULONGLONG AccessMemoryPool : 1;                // offset: 0x0 (0)
  ULONGLONG AdjustMessageBuffers : 1;            // offset: 0x0 (0)
  ULONGLONG PostMessages : 1;                    // offset: 0x0 (0)
  ULONGLONG SignalEvents : 1;                    // offset: 0x0 (0)
  ULONGLONG CreatePort : 1;                      // offset: 0x0 (0)
  ULONGLONG ConnectPort : 1;                     // offset: 0x0 (0)
  ULONGLONG AccessStats : 1;                     // offset: 0x0 (0)
  ULONGLONG Reserved2 : 2;                       // offset: 0x0 (0)
  ULONGLONG Debugging : 1;                       // offset: 0x0 (0)
  ULONGLONG CpuManagement : 1;                   // offset: 0x0 (0)
  ULONGLONG ConfigureProfiler : 1;               // offset: 0x0 (0)
  ULONGLONG AccessVpExitTracing : 1;             // offset: 0x0 (0)
  ULONGLONG
      EnableExtendedGvaRangesForFlushVirtualAddressList : 1; // offset: 0x0 (0)
  ULONGLONG AccessVsm : 1;                                   // offset: 0x0 (0)
  ULONGLONG AccessVpRegisters : 1;                           // offset: 0x0 (0)
  ULONGLONG UnusedBit : 1;                                   // offset: 0x0 (0)
  ULONGLONG FastHypercallOutput : 1;                         // offset: 0x0 (0)
  ULONGLONG EnableExtendedHypercalls : 1;                    // offset: 0x0 (0)
  ULONGLONG StartVirtualProcessor : 1;                       // offset: 0x0 (0)
  ULONGLONG Isolation : 1;                                   // offset: 0x0 (0)
  ULONGLONG Reserved3 : 9;                                   // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _HV_X64_HYPERVISOR_FEATURES {
  union _HV_PARTITION_PRIVILEGE_MASK PartitionPrivileges; // offset: 0x0 (0)
  ULONG MaxSupportedCState : 4;                           // offset: 0x8 (8)
  ULONG HpetNeededForC3PowerState_Deprecated : 1;         // offset: 0x8 (8)
  ULONG Reserved : 27;                                    // offset: 0x8 (8)
  ULONG MwaitAvailable_Deprecated : 1;                    // offset: 0xc (12)
  ULONG GuestDebuggingAvailable : 1;                      // offset: 0xc (12)
  ULONG PerformanceMonitorsAvailable : 1;                 // offset: 0xc (12)
  ULONG CpuDynamicPartitioningAvailable : 1;              // offset: 0xc (12)
  ULONG XmmRegistersForFastHypercallAvailable : 1;        // offset: 0xc (12)
  ULONG GuestIdleAvailable : 1;                           // offset: 0xc (12)
  ULONG HypervisorSleepStateSupportAvailable : 1;         // offset: 0xc (12)
  ULONG NumaDistanceQueryAvailable : 1;                   // offset: 0xc (12)
  ULONG FrequencyRegsAvailable : 1;                       // offset: 0xc (12)
  ULONG SyntheticMachineCheckAvailable : 1;               // offset: 0xc (12)
  ULONG GuestCrashRegsAvailable : 1;                      // offset: 0xc (12)
  ULONG DebugRegsAvailable : 1;                           // offset: 0xc (12)
  ULONG Npiep1Available : 1;                              // offset: 0xc (12)
  ULONG DisableHypervisorAvailable : 1;                   // offset: 0xc (12)
  ULONG ExtendedGvaRangesForFlushVirtualAddressListAvailable : 1; // offset: 0xc
                                                                  // (12)
  ULONG FastHypercallOutputAvailable : 1;        // offset: 0xc (12)
  ULONG SvmFeaturesAvailable : 1;                // offset: 0xc (12)
  ULONG SintPollingModeAvailable : 1;            // offset: 0xc (12)
  ULONG HypercallMsrLockAvailable : 1;           // offset: 0xc (12)
  ULONG DirectSyntheticTimers : 1;               // offset: 0xc (12)
  ULONG RegisterPatAvailable : 1;                // offset: 0xc (12)
  ULONG RegisterBndcfgsAvailable : 1;            // offset: 0xc (12)
  ULONG WatchdogTimerAvailable : 1;              // offset: 0xc (12)
  ULONG SyntheticTimeUnhaltedTimerAvailable : 1; // offset: 0xc (12)
  ULONG DeviceDomainsAvailable : 1;              // offset: 0xc (12)
  ULONG S1DeviceDomainsAvailable : 1;            // offset: 0xc (12)
  ULONG LbrAvailable : 1;                        // offset: 0xc (12)
  ULONG IptAvailable : 1;                        // offset: 0xc (12)
  ULONG CrossVtlFlushAvailable : 1;              // offset: 0xc (12)
  ULONG IdleSpecCtrlAvailable : 1;               // offset: 0xc (12)
  ULONG Reserved1 : 2;                           // offset: 0xc (12)
};

// 0x10 (16) bytes
struct _STRING64 {
  USHORT Length;        // offset: 0x0 (0)
  USHORT MaximumLength; // offset: 0x2 (2)
  ULONGLONG Buffer;     // offset: 0x8 (8)
};

// 0x4e8 (1256) bytes
struct _GDI_TEB_BATCH64 {
  ULONG Offset : 31;             // offset: 0x0 (0)
  ULONG HasRenderingCommand : 1; // offset: 0x0 (0)
  ULONGLONG HDC;                 // offset: 0x8 (8)
  ULONG Buffer[310];             // offset: 0x10 (16)
};

// 0x120 (288) bytes
struct _SEP_TOKEN_DIAG_TRACK_ENTRY {
  VOID *ProcessCid;          // offset: 0x0 (0)
  VOID *ThreadCid;           // offset: 0x8 (8)
  UCHAR ImageFileName[16];   // offset: 0x10 (16)
  ULONG CreateMethod;        // offset: 0x20 (32)
  ULONGLONG CreateTrace[30]; // offset: 0x28 (40)
  LONG Count;                // offset: 0x118 (280)
  LONG CaptureCount;         // offset: 0x11c (284)
};

// 0x10 (16) bytes
struct _CLIENT_ID64 {
  ULONGLONG UniqueProcess; // offset: 0x0 (0)
  ULONGLONG UniqueThread;  // offset: 0x8 (8)
};

// 0x38 (56) bytes
struct _NT_TIB64 {
  ULONGLONG ExceptionList; // offset: 0x0 (0)
  ULONGLONG StackBase;     // offset: 0x8 (8)
  ULONGLONG StackLimit;    // offset: 0x10 (16)
  ULONGLONG SubSystemTib;  // offset: 0x18 (24)
  union {
    ULONGLONG FiberData; // offset: 0x20 (32)
    ULONG Version;       // offset: 0x20 (32)
  };
  ULONGLONG ArbitraryUserPointer; // offset: 0x28 (40)
  ULONGLONG Self;                 // offset: 0x30 (48)
};

// 0x1000 (4096) bytes
struct _TEB32 {
  struct _NT_TIB32 NtTib;                              // offset: 0x0 (0)
  ULONG EnvironmentPointer;                            // offset: 0x1c (28)
  struct _CLIENT_ID32 ClientId;                        // offset: 0x20 (32)
  ULONG ActiveRpcHandle;                               // offset: 0x28 (40)
  ULONG ThreadLocalStoragePointer;                     // offset: 0x2c (44)
  ULONG ProcessEnvironmentBlock;                       // offset: 0x30 (48)
  ULONG LastErrorValue;                                // offset: 0x34 (52)
  ULONG CountOfOwnedCriticalSections;                  // offset: 0x38 (56)
  ULONG CsrClientThread;                               // offset: 0x3c (60)
  ULONG Win32ThreadInfo;                               // offset: 0x40 (64)
  ULONG User32Reserved[26];                            // offset: 0x44 (68)
  ULONG UserReserved[5];                               // offset: 0xac (172)
  ULONG WOW32Reserved;                                 // offset: 0xc0 (192)
  ULONG CurrentLocale;                                 // offset: 0xc4 (196)
  ULONG FpSoftwareStatusRegister;                      // offset: 0xc8 (200)
  ULONG ReservedForDebuggerInstrumentation[16];        // offset: 0xcc (204)
  ULONG SystemReserved1[26];                           // offset: 0x10c (268)
  CHAR PlaceholderCompatibilityMode;                   // offset: 0x174 (372)
  UCHAR PlaceholderHydrationAlwaysExplicit;            // offset: 0x175 (373)
  CHAR PlaceholderReserved[10];                        // offset: 0x176 (374)
  ULONG ProxiedProcessId;                              // offset: 0x180 (384)
  struct _ACTIVATION_CONTEXT_STACK32 _ActivationStack; // offset: 0x184 (388)
  UCHAR WorkingOnBehalfTicket[8];                      // offset: 0x19c (412)
  LONG ExceptionCode;                                  // offset: 0x1a4 (420)
  ULONG ActivationContextStackPointer;                 // offset: 0x1a8 (424)
  ULONG InstrumentationCallbackSp;                     // offset: 0x1ac (428)
  ULONG InstrumentationCallbackPreviousPc;             // offset: 0x1b0 (432)
  ULONG InstrumentationCallbackPreviousSp;             // offset: 0x1b4 (436)
  UCHAR InstrumentationCallbackDisabled;               // offset: 0x1b8 (440)
  UCHAR SpareBytes[23];                                // offset: 0x1b9 (441)
  ULONG TxFsContext;                                   // offset: 0x1d0 (464)
  struct _GDI_TEB_BATCH32 GdiTebBatch;                 // offset: 0x1d4 (468)
  struct _CLIENT_ID32 RealClientId;                    // offset: 0x6b4 (1716)
  ULONG GdiCachedProcessHandle;                        // offset: 0x6bc (1724)
  ULONG GdiClientPID;                                  // offset: 0x6c0 (1728)
  ULONG GdiClientTID;                                  // offset: 0x6c4 (1732)
  ULONG GdiThreadLocalInfo;                            // offset: 0x6c8 (1736)
  ULONG Win32ClientInfo[62];                           // offset: 0x6cc (1740)
  ULONG glDispatchTable[233];                          // offset: 0x7c4 (1988)
  ULONG glReserved1[29];                               // offset: 0xb68 (2920)
  ULONG glReserved2;                                   // offset: 0xbdc (3036)
  ULONG glSectionInfo;                                 // offset: 0xbe0 (3040)
  ULONG glSection;                                     // offset: 0xbe4 (3044)
  ULONG glTable;                                       // offset: 0xbe8 (3048)
  ULONG glCurrentRC;                                   // offset: 0xbec (3052)
  ULONG glContext;                                     // offset: 0xbf0 (3056)
  ULONG LastStatusValue;                               // offset: 0xbf4 (3060)
  struct _STRING32 StaticUnicodeString;                // offset: 0xbf8 (3064)
  WCHAR StaticUnicodeBuffer[261];                      // offset: 0xc00 (3072)
  ULONG DeallocationStack;                             // offset: 0xe0c (3596)
  ULONG TlsSlots[64];                                  // offset: 0xe10 (3600)
  struct LIST_ENTRY32 TlsLinks;                        // offset: 0xf10 (3856)
  ULONG Vdm;                                           // offset: 0xf18 (3864)
  ULONG ReservedForNtRpc;                              // offset: 0xf1c (3868)
  ULONG DbgSsReserved[2];                              // offset: 0xf20 (3872)
  ULONG HardErrorMode;                                 // offset: 0xf28 (3880)
  ULONG Instrumentation[9];                            // offset: 0xf2c (3884)
  struct _GUID ActivityId;                             // offset: 0xf50 (3920)
  ULONG SubProcessTag;                                 // offset: 0xf60 (3936)
  ULONG PerflibData;                                   // offset: 0xf64 (3940)
  ULONG EtwTraceData;                                  // offset: 0xf68 (3944)
  ULONG WinSockData;                                   // offset: 0xf6c (3948)
  ULONG GdiBatchCount;                                 // offset: 0xf70 (3952)
  union {
    struct _PROCESSOR_NUMBER CurrentIdealProcessor; // offset: 0xf74 (3956)
    ULONG IdealProcessorValue;                      // offset: 0xf74 (3956)
    struct {
      UCHAR ReservedPad0;   // offset: 0xf74 (3956)
      UCHAR ReservedPad1;   // offset: 0xf75 (3957)
      UCHAR ReservedPad2;   // offset: 0xf76 (3958)
      UCHAR IdealProcessor; // offset: 0xf77 (3959)
    };
  };
  ULONG GuaranteedStackBytes;     // offset: 0xf78 (3960)
  ULONG ReservedForPerf;          // offset: 0xf7c (3964)
  ULONG ReservedForOle;           // offset: 0xf80 (3968)
  ULONG WaitingOnLoaderLock;      // offset: 0xf84 (3972)
  ULONG SavedPriorityState;       // offset: 0xf88 (3976)
  ULONG ReservedForCodeCoverage;  // offset: 0xf8c (3980)
  ULONG ThreadPoolData;           // offset: 0xf90 (3984)
  ULONG TlsExpansionSlots;        // offset: 0xf94 (3988)
  ULONG MuiGeneration;            // offset: 0xf98 (3992)
  ULONG IsImpersonating;          // offset: 0xf9c (3996)
  ULONG NlsCache;                 // offset: 0xfa0 (4000)
  ULONG pShimData;                // offset: 0xfa4 (4004)
  ULONG HeapData;                 // offset: 0xfa8 (4008)
  ULONG CurrentTransactionHandle; // offset: 0xfac (4012)
  ULONG ActiveFrame;              // offset: 0xfb0 (4016)
  ULONG FlsData;                  // offset: 0xfb4 (4020)
  ULONG PreferredLanguages;       // offset: 0xfb8 (4024)
  ULONG UserPrefLanguages;        // offset: 0xfbc (4028)
  ULONG MergedPrefLanguages;      // offset: 0xfc0 (4032)
  ULONG MuiImpersonation;         // offset: 0xfc4 (4036)
  union {
    volatile USHORT CrossTebFlags; // offset: 0xfc8 (4040)
    USHORT SpareCrossTebBits : 16; // offset: 0xfc8 (4040)
  };
  union {
    USHORT SameTebFlags; // offset: 0xfca (4042)
    struct {
      USHORT SafeThunkCall : 1;        // offset: 0xfca (4042)
      USHORT InDebugPrint : 1;         // offset: 0xfca (4042)
      USHORT HasFiberData : 1;         // offset: 0xfca (4042)
      USHORT SkipThreadAttach : 1;     // offset: 0xfca (4042)
      USHORT WerInShipAssertCode : 1;  // offset: 0xfca (4042)
      USHORT RanProcessInit : 1;       // offset: 0xfca (4042)
      USHORT ClonedThread : 1;         // offset: 0xfca (4042)
      USHORT SuppressDebugMsg : 1;     // offset: 0xfca (4042)
      USHORT DisableUserStackWalk : 1; // offset: 0xfca (4042)
      USHORT RtlExceptionAttached : 1; // offset: 0xfca (4042)
      USHORT InitialThread : 1;        // offset: 0xfca (4042)
      USHORT SessionAware : 1;         // offset: 0xfca (4042)
      USHORT LoadOwner : 1;            // offset: 0xfca (4042)
      USHORT LoaderWorker : 1;         // offset: 0xfca (4042)
      USHORT SkipLoaderInit : 1;       // offset: 0xfca (4042)
      USHORT SpareSameTebBits : 1;     // offset: 0xfca (4042)
    };
  };
  ULONG TxnScopeEnterCallback;       // offset: 0xfcc (4044)
  ULONG TxnScopeExitCallback;        // offset: 0xfd0 (4048)
  ULONG TxnScopeContext;             // offset: 0xfd4 (4052)
  ULONG LockCount;                   // offset: 0xfd8 (4056)
  LONG WowTebOffset;                 // offset: 0xfdc (4060)
  ULONG ResourceRetValue;            // offset: 0xfe0 (4064)
  ULONG ReservedForWdf;              // offset: 0xfe4 (4068)
  ULONGLONG ReservedForCrt;          // offset: 0xfe8 (4072)
  struct _GUID EffectiveContainerId; // offset: 0xff0 (4080)
};

// 0x10 (16) bytes
struct _FILESYSTEM_DISK_COUNTERS {
  ULONGLONG FsBytesRead;    // offset: 0x0 (0)
  ULONGLONG FsBytesWritten; // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _ETW_SESSION_PERF_COUNTERS {
  LONG BufferMemoryPagedPool;    // offset: 0x0 (0)
  LONG BufferMemoryNonPagedPool; // offset: 0x4 (4)
  ULONGLONG EventsLoggedCount;   // offset: 0x8 (8)
  LONG EventsLost;               // offset: 0x10 (16)
  LONG NumConsumers;             // offset: 0x14 (20)
};

// 0xc8 (200) bytes
struct _PCW_PROCESSOR_INFO {
  ULONGLONG IdleTime;               // offset: 0x0 (0)
  ULONGLONG AvailableTime;          // offset: 0x8 (8)
  ULONGLONG UserTime;               // offset: 0x10 (16)
  ULONGLONG KernelTime;             // offset: 0x18 (24)
  ULONG Interrupts;                 // offset: 0x20 (32)
  ULONGLONG DpcTime;                // offset: 0x28 (40)
  ULONGLONG InterruptTime;          // offset: 0x30 (48)
  ULONG ClockInterrupts;            // offset: 0x38 (56)
  ULONG DpcCount;                   // offset: 0x3c (60)
  ULONG DpcRate;                    // offset: 0x40 (64)
  ULONGLONG C1Time;                 // offset: 0x48 (72)
  ULONGLONG C2Time;                 // offset: 0x50 (80)
  ULONGLONG C3Time;                 // offset: 0x58 (88)
  ULONGLONG C1Transitions;          // offset: 0x60 (96)
  ULONGLONG C2Transitions;          // offset: 0x68 (104)
  ULONGLONG C3Transitions;          // offset: 0x70 (112)
  ULONGLONG StallTime;              // offset: 0x78 (120)
  ULONG ParkingStatus;              // offset: 0x80 (128)
  ULONG CurrentFrequency;           // offset: 0x84 (132)
  ULONG PercentMaxFrequency;        // offset: 0x88 (136)
  ULONG StateFlags;                 // offset: 0x8c (140)
  ULONG NominalThroughput;          // offset: 0x90 (144)
  ULONG ActiveThroughput;           // offset: 0x94 (148)
  ULONGLONG ScaledThroughput;       // offset: 0x98 (152)
  ULONGLONG ScaledKernelThroughput; // offset: 0xa0 (160)
  ULONGLONG AverageIdleTime;        // offset: 0xa8 (168)
  ULONGLONG IdleBreakEvents;        // offset: 0xb0 (176)
  ULONG PerformanceLimit;           // offset: 0xb8 (184)
  ULONG PerformanceLimitFlags;      // offset: 0xbc (188)
  ULONGLONG ScaledFrequency;        // offset: 0xc0 (192)
};

// 0x28 (40) bytes
struct _PCW_MASK_INFORMATION {
  ULONGLONG CounterMask;                // offset: 0x0 (0)
  struct _UNICODE_STRING *InstanceMask; // offset: 0x8 (8)
  ULONG InstanceId;                     // offset: 0x10 (16)
  UCHAR CollectMultiple;                // offset: 0x14 (20)
  struct _PCW_BUFFER *Buffer;           // offset: 0x18 (24)
  struct _KEVENT *CancelEvent;          // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _PCW_COUNTER_INFORMATION {
  ULONGLONG CounterMask;                // offset: 0x0 (0)
  struct _UNICODE_STRING *InstanceMask; // offset: 0x8 (8)
};

// 0x28 (40) bytes
union _PCW_CALLBACK_INFORMATION {
  struct _PCW_COUNTER_INFORMATION AddCounter;      // offset: 0x0 (0)
  struct _PCW_COUNTER_INFORMATION RemoveCounter;   // offset: 0x0 (0)
  struct _PCW_MASK_INFORMATION EnumerateInstances; // offset: 0x0 (0)
  struct _PCW_MASK_INFORMATION CollectData;        // offset: 0x0 (0)
};

// 0x30 (48) bytes
struct _PCW_REGISTRATION_INFORMATION {
  ULONG Version;                            // offset: 0x0 (0)
  struct _UNICODE_STRING *Name;             // offset: 0x8 (8)
  ULONG CounterCount;                       // offset: 0x10 (16)
  struct _PCW_COUNTER_DESCRIPTOR *Counters; // offset: 0x18 (24)
  LONG (*Callback)
  (enum _PCW_CALLBACK_TYPE arg1, union _PCW_CALLBACK_INFORMATION *arg2,
   VOID *arg3);          // offset: 0x20 (32)
  VOID *CallbackContext; // offset: 0x28 (40)
};

// 0x340 (832) bytes
struct tagSWITCH_CONTEXT_DATA {
  ULONGLONG ullOsMaxVersionTested; // offset: 0x0 (0)
  ULONG ulTargetPlatform;          // offset: 0x8 (8)
  ULONGLONG ullContextMinimum;     // offset: 0x10 (16)
  struct _GUID guPlatform;         // offset: 0x18 (24)
  struct _GUID guMinPlatform;      // offset: 0x28 (40)
  ULONG ulContextSource;           // offset: 0x38 (56)
  ULONG ulElementCount;            // offset: 0x3c (60)
  struct _GUID guElements[48];     // offset: 0x40 (64)
};

// 0x18 (24) bytes
struct tagSWITCH_CONTEXT_ATTRIBUTE {
  ULONGLONG ulContextUpdateCounter; // offset: 0x0 (0)
  LONG fAllowContextUpdate;         // offset: 0x8 (8)
  LONG fEnableTrace;                // offset: 0xc (12)
  ULONGLONG EtwHandle;              // offset: 0x10 (16)
};

// 0x358 (856) bytes
struct tagSWITCH_CONTEXT {
  struct tagSWITCH_CONTEXT_ATTRIBUTE Attribute; // offset: 0x0 (0)
  struct tagSWITCH_CONTEXT_DATA Data;           // offset: 0x18 (24)
};

// 0x8 (8) bytes
union _CLS_LSN {
  struct {
    ULONG idxRecord;    // offset: 0x0 (0)
    ULONG cidContainer; // offset: 0x4 (4)
  } offset;             // offset: 0x0 (0)
  ULONGLONG ullOffset;  // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _CM_TRANS_PTR {
  ULONGLONG LightWeight : 1; // offset: 0x0 (0)
  VOID *TransPtr;            // offset: 0x0 (0)
};

// 0x68 (104) bytes
struct _CM_KEY_BODY {
  ULONG Type;                                    // offset: 0x0 (0)
  struct _CM_KEY_CONTROL_BLOCK *KeyControlBlock; // offset: 0x8 (8)
  struct _CM_NOTIFY_BLOCK *NotifyBlock;          // offset: 0x10 (16)
  VOID *ProcessID;                               // offset: 0x18 (24)
  struct _LIST_ENTRY KeyBodyList;                // offset: 0x20 (32)
  ULONG Flags : 16;                              // offset: 0x30 (48)
  ULONG HandleTags : 16;                         // offset: 0x30 (48)
  union _CM_TRANS_PTR Trans;                     // offset: 0x38 (56)
  struct _GUID *KtmUow;                          // offset: 0x40 (64)
  struct _LIST_ENTRY ContextListHead;            // offset: 0x48 (72)
  VOID *EnumerationResumeContext;                // offset: 0x58 (88)
  ULONG RestrictedAccessMask;                    // offset: 0x60 (96)
};

// 0x58 (88) bytes
struct _CM_NOTIFY_BLOCK {
  struct _LIST_ENTRY HiveList;                     // offset: 0x0 (0)
  struct _LIST_ENTRY PostList;                     // offset: 0x10 (16)
  struct _CM_KEY_CONTROL_BLOCK *KeyControlBlock;   // offset: 0x20 (32)
  struct _CM_KEY_BODY *KeyBody;                    // offset: 0x28 (40)
  ULONG Filter : 30;                               // offset: 0x30 (48)
  ULONG WatchTree : 1;                             // offset: 0x30 (48)
  ULONG NotifyPending : 1;                         // offset: 0x30 (48)
  struct _SECURITY_SUBJECT_CONTEXT SubjectContext; // offset: 0x38 (56)
};

// 0x18 (24) bytes
struct _HMAP_ENTRY {
  ULONGLONG BlockOffset;         // offset: 0x0 (0)
  ULONGLONG PermanentBinAddress; // offset: 0x8 (8)
  ULONG MemAlloc;                // offset: 0x10 (16)
};

// 0x3000 (12288) bytes
struct _HMAP_TABLE {
  struct _HMAP_ENTRY Table[512]; // offset: 0x0 (0)
};

// 0x2000 (8192) bytes
struct _HMAP_DIRECTORY {
  struct _HMAP_TABLE *Directory[1024]; // offset: 0x0 (0)
};

// 0x278 (632) bytes
struct _DUAL {
  ULONG Length;                         // offset: 0x0 (0)
  struct _HMAP_DIRECTORY *Map;          // offset: 0x8 (8)
  struct _HMAP_TABLE *SmallDir;         // offset: 0x10 (16)
  ULONG Guard;                          // offset: 0x18 (24)
  struct _FREE_DISPLAY FreeDisplay[24]; // offset: 0x20 (32)
  struct _LIST_ENTRY FreeBins;          // offset: 0x260 (608)
  ULONG FreeSummary;                    // offset: 0x270 (624)
};

// 0x1000 (4096) bytes
struct _HBASE_BLOCK {
  ULONG Signature;                // offset: 0x0 (0)
  ULONG Sequence1;                // offset: 0x4 (4)
  ULONG Sequence2;                // offset: 0x8 (8)
  union _LARGE_INTEGER TimeStamp; // offset: 0xc (12)
  ULONG Major;                    // offset: 0x14 (20)
  ULONG Minor;                    // offset: 0x18 (24)
  ULONG Type;                     // offset: 0x1c (28)
  ULONG Format;                   // offset: 0x20 (32)
  ULONG RootCell;                 // offset: 0x24 (36)
  ULONG Length;                   // offset: 0x28 (40)
  ULONG Cluster;                  // offset: 0x2c (44)
  UCHAR FileName[64];             // offset: 0x30 (48)
  struct _GUID RmId;              // offset: 0x70 (112)
  struct _GUID LogId;             // offset: 0x80 (128)
  ULONG Flags;                    // offset: 0x90 (144)
  struct _GUID TmId;              // offset: 0x94 (148)
  ULONG GuidSignature;            // offset: 0xa4 (164)
  ULONGLONG LastReorganizeTime;   // offset: 0xa8 (168)
  ULONG Reserved1[83];            // offset: 0xb0 (176)
  ULONG CheckSum;                 // offset: 0x1fc (508)
  ULONG Reserved2[882];           // offset: 0x200 (512)
  struct _GUID ThawTmId;          // offset: 0xfc8 (4040)
  struct _GUID ThawRmId;          // offset: 0xfd8 (4056)
  struct _GUID ThawLogId;         // offset: 0xfe8 (4072)
  ULONG BootType;                 // offset: 0xff8 (4088)
  ULONG BootRecover;              // offset: 0xffc (4092)
};

// 0x600 (1536) bytes
struct _HHIVE {
  ULONG Signature; // offset: 0x0 (0)
  struct _CELL_DATA *(*GetCellRoutine)(
      struct _HHIVE *arg1, ULONG arg2,
      struct _HV_GET_CELL_CONTEXT *arg3); // offset: 0x8 (8)
  VOID (*ReleaseCellRoutine)
  (struct _HHIVE *arg1, struct _HV_GET_CELL_CONTEXT *arg2); // offset: 0x10 (16)
  VOID *(*Allocate)(ULONG arg1, UCHAR arg2, ULONG arg3);    // offset: 0x18 (24)
  VOID (*Free)(VOID *arg1, ULONG arg2);                     // offset: 0x20 (32)
  LONG (*FileWrite)
  (struct _HHIVE *arg1, ULONG arg2, struct CMP_OFFSET_ARRAY *arg3, ULONG arg4,
   ULONG arg5); // offset: 0x28 (40)
  LONG (*FileRead)
  (struct _HHIVE *arg1, ULONG arg2, ULONG arg3, VOID *arg4,
   ULONG arg5);                          // offset: 0x30 (48)
  VOID *HiveLoadFailure;                 // offset: 0x38 (56)
  struct _HBASE_BLOCK *BaseBlock;        // offset: 0x40 (64)
  struct _CMSI_RW_LOCK FlusherLock;      // offset: 0x48 (72)
  struct _CMSI_RW_LOCK WriterLock;       // offset: 0x50 (80)
  struct _RTL_BITMAP DirtyVector;        // offset: 0x58 (88)
  ULONG DirtyCount;                      // offset: 0x68 (104)
  ULONG DirtyAlloc;                      // offset: 0x6c (108)
  struct _RTL_BITMAP UnreconciledVector; // offset: 0x70 (112)
  ULONG UnreconciledCount;               // offset: 0x80 (128)
  ULONG BaseBlockAlloc;                  // offset: 0x84 (132)
  ULONG Cluster;                         // offset: 0x88 (136)
  UCHAR Flat : 1;                        // offset: 0x8c (140)
  UCHAR ReadOnly : 1;                    // offset: 0x8c (140)
  UCHAR Reserved : 6;                    // offset: 0x8c (140)
  UCHAR DirtyFlag;                       // offset: 0x8d (141)
  ULONG HvBinHeadersUse;                 // offset: 0x90 (144)
  ULONG HvFreeCellsUse;                  // offset: 0x94 (148)
  ULONG HvUsedCellsUse;                  // offset: 0x98 (152)
  ULONG CmUsedCellsUse;                  // offset: 0x9c (156)
  ULONG HiveFlags;                       // offset: 0xa0 (160)
  ULONG CurrentLog;                      // offset: 0xa4 (164)
  ULONG CurrentLogSequence;              // offset: 0xa8 (168)
  ULONG CurrentLogMinimumSequence;       // offset: 0xac (172)
  ULONG CurrentLogOffset;                // offset: 0xb0 (176)
  ULONG MinimumLogSequence;              // offset: 0xb4 (180)
  ULONG LogFileSizeCap;                  // offset: 0xb8 (184)
  UCHAR LogDataPresent[2];               // offset: 0xbc (188)
  UCHAR PrimaryFileValid;                // offset: 0xbe (190)
  UCHAR BaseBlockDirty;                  // offset: 0xbf (191)
  union _LARGE_INTEGER LastLogSwapTime;  // offset: 0xc0 (192)
  union {
    struct {
      USHORT FirstLogFile : 3;                // offset: 0xc8 (200)
      USHORT SecondLogFile : 3;               // offset: 0xc8 (200)
      USHORT HeaderRecovered : 1;             // offset: 0xc8 (200)
      USHORT LegacyRecoveryIndicated : 1;     // offset: 0xc8 (200)
      USHORT RecoveryInformationReserved : 8; // offset: 0xc8 (200)
    };
    USHORT RecoveryInformation; // offset: 0xc8 (200)
  };
  UCHAR LogEntriesRecovered[2]; // offset: 0xca (202)
  ULONG RefreshCount;           // offset: 0xcc (204)
  ULONG StorageTypeCount;       // offset: 0xd0 (208)
  ULONG Version;                // offset: 0xd4 (212)
  struct _HVP_VIEW_MAP ViewMap; // offset: 0xd8 (216)
  struct _DUAL Storage[2];      // offset: 0x110 (272)
};

// 0x20 (32) bytes
struct _CM_KEY_HASH {
  struct _CM_PATH_HASH ConvKey;  // offset: 0x0 (0)
  struct _CM_KEY_HASH *NextHash; // offset: 0x8 (8)
  struct _HHIVE *KeyHive;        // offset: 0x10 (16)
  ULONG KeyCell;                 // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct _CM_KEY_REFERENCE {
  ULONG KeyCell;          // offset: 0x0 (0)
  struct _HHIVE *KeyHive; // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _CM_KEY_NODE {
  USHORT Signature;                   // offset: 0x0 (0)
  USHORT Flags;                       // offset: 0x2 (2)
  union _LARGE_INTEGER LastWriteTime; // offset: 0x4 (4)
  UCHAR AccessBits;                   // offset: 0xc (12)
  UCHAR LayerSemantics : 2;           // offset: 0xd (13)
  UCHAR Spare1 : 5;                   // offset: 0xd (13)
  UCHAR InheritClass : 1;             // offset: 0xd (13)
  USHORT Spare2;                      // offset: 0xe (14)
  ULONG Parent;                       // offset: 0x10 (16)
  ULONG SubKeyCounts[2];              // offset: 0x14 (20)
  union {
    struct {
      ULONG SubKeyLists[2];         // offset: 0x1c (28)
      struct _CHILD_LIST ValueList; // offset: 0x24 (36)
    };
    struct _CM_KEY_REFERENCE ChildHiveReference; // offset: 0x1c (28)
  };
  ULONG Security;             // offset: 0x2c (44)
  ULONG Class;                // offset: 0x30 (48)
  ULONG MaxNameLen : 16;      // offset: 0x34 (52)
  ULONG UserFlags : 4;        // offset: 0x34 (52)
  ULONG VirtControlFlags : 4; // offset: 0x34 (52)
  ULONG Debug : 8;            // offset: 0x34 (52)
  ULONG MaxClassLen;          // offset: 0x38 (56)
  ULONG MaxValueNameLen;      // offset: 0x3c (60)
  ULONG MaxValueDataLen;      // offset: 0x40 (64)
  ULONG WorkVar;              // offset: 0x44 (68)
  USHORT NameLength;          // offset: 0x48 (72)
  USHORT ClassLength;         // offset: 0x4a (74)
  WCHAR Name[1];              // offset: 0x4c (76)
};

// 0x50 (80) bytes
union _u {
  struct _CM_KEY_NODE KeyNode;         // offset: 0x0 (0)
  struct _CM_KEY_VALUE KeyValue;       // offset: 0x0 (0)
  struct _CM_KEY_SECURITY KeySecurity; // offset: 0x0 (0)
  struct _CM_KEY_INDEX KeyIndex;       // offset: 0x0 (0)
  struct _CM_BIG_DATA ValueData;       // offset: 0x0 (0)
  ULONG KeyList[1];                    // offset: 0x0 (0)
  WCHAR KeyString[1];                  // offset: 0x0 (0)
};

// 0x50 (80) bytes
struct _CELL_DATA {
  union _u u; // offset: 0x0 (0)
};

// 0x1b0 (432) bytes
struct _HIVE_LOAD_FAILURE {
  struct _HHIVE *Hive;     // offset: 0x0 (0)
  USHORT Index;            // offset: 0x8 (8)
  USHORT RecoverableIndex; // offset: 0xa (10)
  struct {
    enum _CM_LOAD_FAILURE_TYPE Failure; // offset: 0x0 (0)
    LONG Status;                        // offset: 0x4 (4)
    ULONG Point;                        // offset: 0x8 (8)
  } Locations[8];                       // offset: 0xc (12)
  struct {
    enum _CM_LOAD_FAILURE_TYPE Failure; // offset: 0x0 (0)
    LONG Status;                        // offset: 0x4 (4)
    ULONG Point;                        // offset: 0x8 (8)
  } RecoverableLocations[8];            // offset: 0x6c (108)
  struct {
    ULONG Action; // offset: 0x0 (0)
    VOID *Handle; // offset: 0x8 (8)
    LONG Status;  // offset: 0x10 (16)
  } RegistryIO;   // offset: 0xd0 (208)
  struct {
    VOID *CheckStack; // offset: 0x0 (0)
  } CheckRegistry2;   // offset: 0xe8 (232)
  struct {
    ULONG Cell;                   // offset: 0x0 (0)
    struct _CELL_DATA *CellPoint; // offset: 0x8 (8)
    VOID *RootPoint;              // offset: 0x10 (16)
    ULONG Index;                  // offset: 0x18 (24)
  } CheckKey;                     // offset: 0xf0 (240)
  struct {
    struct _CELL_DATA *List;      // offset: 0x0 (0)
    ULONG Index;                  // offset: 0x8 (8)
    ULONG Cell;                   // offset: 0xc (12)
    struct _CELL_DATA *CellPoint; // offset: 0x10 (16)
  } CheckValueList;               // offset: 0x110 (272)
  struct {
    ULONG Space;            // offset: 0x0 (0)
    ULONG MapPoint;         // offset: 0x4 (4)
    struct _HBIN *BinPoint; // offset: 0x8 (8)
  } CheckHive;              // offset: 0x128 (296)
  struct {
    ULONG Space;            // offset: 0x0 (0)
    ULONG MapPoint;         // offset: 0x4 (4)
    struct _HBIN *BinPoint; // offset: 0x8 (8)
  } CheckHive1;             // offset: 0x138 (312)
  struct {
    struct _HBIN *Bin;        // offset: 0x0 (0)
    struct _HCELL *CellPoint; // offset: 0x8 (8)
  } CheckBin;                 // offset: 0x148 (328)
  struct {
    ULONG FileOffset;                    // offset: 0x0 (0)
  } RecoverData;                         // offset: 0x158 (344)
  struct _CM_PARSE_DEBUG_INFO LinkDebug; // offset: 0x160 (352)
};

// 0x8 (8) bytes
union _MM_STORE_KEY {
  ULONGLONG KeyLow : 60; // offset: 0x0 (0)
  ULONGLONG KeyHigh : 4; // offset: 0x0 (0)
  ULONGLONG EntireKey;   // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _MI_LARGEPAGE_VAD_INFO {
  UCHAR LargeImageBias;                    // offset: 0x0 (0)
  UCHAR Spare[3];                          // offset: 0x1 (1)
  ULONGLONG ActualImageViewSize;           // offset: 0x8 (8)
  struct _EPARTITION *ReferencedPartition; // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _MIPFNBLINK {
  union {
    struct {
      ULONGLONG Blink : 36;                  // offset: 0x0 (0)
      ULONGLONG NodeBlinkHigh : 20;          // offset: 0x0 (0)
      ULONGLONG TbFlushStamp : 4;            // offset: 0x0 (0)
      ULONGLONG Unused : 2;                  // offset: 0x0 (0)
      ULONGLONG PageBlinkDeleteBit : 1;      // offset: 0x0 (0)
      ULONGLONG PageBlinkLockBit : 1;        // offset: 0x0 (0)
      ULONGLONG ShareCount : 62;             // offset: 0x0 (0)
      ULONGLONG PageShareCountDeleteBit : 1; // offset: 0x0 (0)
      ULONGLONG PageShareCountLockBit : 1;   // offset: 0x0 (0)
    };
    ULONGLONG EntireField;  // offset: 0x0 (0)
    volatile LONGLONG Lock; // offset: 0x0 (0)
    struct {
      ULONGLONG LockNotUsed : 62; // offset: 0x0 (0)
      ULONGLONG DeleteBit : 1;    // offset: 0x0 (0)
      ULONGLONG LockBit : 1;      // offset: 0x0 (0)
    };
  };
};

// 0x8 (8) bytes
struct _MI_ACTIVE_PFN {
  union {
    struct {
      ULONGLONG Tradable : 1;       // offset: 0x0 (0)
      ULONGLONG NonPagedBuddy : 43; // offset: 0x0 (0)
    } Leaf;                         // offset: 0x0 (0)
    struct {
      ULONGLONG Tradable : 1;               // offset: 0x0 (0)
      ULONGLONG WsleAge : 3;                // offset: 0x0 (0)
      ULONGLONG OldestWsleLeafEntries : 10; // offset: 0x0 (0)
      ULONGLONG OldestWsleLeafAge : 3;      // offset: 0x0 (0)
      ULONGLONG NonPagedBuddy : 43;         // offset: 0x0 (0)
    } PageTable;                            // offset: 0x0 (0)
    ULONGLONG EntireActiveField;            // offset: 0x0 (0)
  };
};

// 0x8 (8) bytes
struct _IMAGE_SECURITY_CONTEXT {
  union {
    VOID *PageHashes; // offset: 0x0 (0)
    ULONGLONG Value;  // offset: 0x0 (0)
    struct {
      ULONGLONG SecurityBeingCreated : 2; // offset: 0x0 (0)
      ULONGLONG SecurityMandatory : 1;    // offset: 0x0 (0)
      ULONGLONG PageHashPointer : 61;     // offset: 0x0 (0)
    };
  };
};

// 0x40 (64) bytes
struct _SECTION_IMAGE_INFORMATION {
  VOID *TransferAddress;        // offset: 0x0 (0)
  ULONG ZeroBits;               // offset: 0x8 (8)
  ULONGLONG MaximumStackSize;   // offset: 0x10 (16)
  ULONGLONG CommittedStackSize; // offset: 0x18 (24)
  ULONG SubSystemType;          // offset: 0x20 (32)
  union {
    struct {
      USHORT SubSystemMinorVersion; // offset: 0x24 (36)
      USHORT SubSystemMajorVersion; // offset: 0x26 (38)
    };
    ULONG SubSystemVersion; // offset: 0x24 (36)
  };
  union {
    struct {
      USHORT MajorOperatingSystemVersion; // offset: 0x28 (40)
      USHORT MinorOperatingSystemVersion; // offset: 0x2a (42)
    };
    ULONG OperatingSystemVersion; // offset: 0x28 (40)
  };
  USHORT ImageCharacteristics; // offset: 0x2c (44)
  USHORT DllCharacteristics;   // offset: 0x2e (46)
  USHORT Machine;              // offset: 0x30 (48)
  UCHAR ImageContainsCode;     // offset: 0x32 (50)
  union {
    UCHAR ImageFlags; // offset: 0x33 (51)
    struct {
      UCHAR ComPlusNativeReady : 1;        // offset: 0x33 (51)
      UCHAR ComPlusILOnly : 1;             // offset: 0x33 (51)
      UCHAR ImageDynamicallyRelocated : 1; // offset: 0x33 (51)
      UCHAR ImageMappedFlat : 1;           // offset: 0x33 (51)
      UCHAR BaseBelow4gb : 1;              // offset: 0x33 (51)
      UCHAR ComPlusPrefer32bit : 1;        // offset: 0x33 (51)
      UCHAR Reserved : 2;                  // offset: 0x33 (51)
    };
  };
  ULONG LoaderFlags;   // offset: 0x34 (52)
  ULONG ImageFileSize; // offset: 0x38 (56)
  ULONG CheckSum;      // offset: 0x3c (60)
};

// 0x50 (80) bytes
struct _MI_SECTION_IMAGE_INFORMATION {
  struct _SECTION_IMAGE_INFORMATION ExportedImageInformation; // offset: 0x0 (0)
  struct _MI_EXTRA_IMAGE_INFORMATION
      InternalImageInformation; // offset: 0x40 (64)
};

// 0x10 (16) bytes
struct _MMEXTEND_INFO {
  ULONGLONG CommittedSize; // offset: 0x0 (0)
  ULONG ReferenceCount;    // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _MMPFNLIST_SHORT {
  ULONGLONG Total; // offset: 0x0 (0)
  ULONGLONG Flink; // offset: 0x8 (8)
  ULONGLONG Blink; // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _MI_DECAY_TIMER_LINKAGE {
  ULONGLONG Spare0 : 1;            // offset: 0x0 (0)
  ULONGLONG PreviousDecayPfn : 31; // offset: 0x0 (0)
  ULONGLONG Spare1 : 1;            // offset: 0x0 (0)
  ULONGLONG NextDecayPfn : 31;     // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _PHYSICAL_MEMORY_RUN {
  ULONGLONG BasePage;  // offset: 0x0 (0)
  ULONGLONG PageCount; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _MI_DECAY_TIMER_LINK {
  union {
    ULONGLONG Long;                    // offset: 0x0 (0)
    struct _MI_DECAY_TIMER_LINKAGE e1; // offset: 0x0 (0)

  } u1; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _MI_FREE_LARGE_PAGE_LIST {
  struct _LIST_ENTRY ListHead; // offset: 0x0 (0)
  ULONGLONG EntryCount;        // offset: 0x10 (16)
};

// 0x20 (32) bytes
struct _MI_CROSS_PARTITION_CHARGES {
  ULONGLONG CurrentCharges; // offset: 0x0 (0)
  ULONGLONG ChargeFailures; // offset: 0x8 (8)
  ULONGLONG ChargePeak;     // offset: 0x10 (16)
  ULONGLONG ChargeMinimum;  // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _PHYSICAL_MEMORY_DESCRIPTOR {
  ULONG NumberOfRuns;                 // offset: 0x0 (0)
  ULONGLONG NumberOfPages;            // offset: 0x8 (8)
  struct _PHYSICAL_MEMORY_RUN Run[1]; // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _MI_PAGE_COMBINE_STATISTICS {
  ULONGLONG PagesScannedActive;         // offset: 0x0 (0)
  ULONGLONG PagesScannedStandby;        // offset: 0x8 (8)
  ULONGLONG PagesCombined;              // offset: 0x10 (16)
  ULONG CombineScanCount;               // offset: 0x18 (24)
  LONG CombinedBlocksInUse;             // offset: 0x1c (28)
  LONG SumCombinedBlocksReferenceCount; // offset: 0x20 (32)
};

// 0x40 (64) bytes
struct _MI_MODWRITE_DATA {
  LONGLONG PagesLoad;                    // offset: 0x0 (0)
  ULONGLONG PagesAverage;                // offset: 0x8 (8)
  ULONGLONG AverageAvailablePages;       // offset: 0x10 (16)
  ULONGLONG PagesWritten;                // offset: 0x18 (24)
  ULONG WritesIssued;                    // offset: 0x20 (32)
  ULONG IgnoredReservationsCount;        // offset: 0x24 (36)
  ULONG FreedReservationsCount;          // offset: 0x28 (40)
  ULONG WriteBurstCount;                 // offset: 0x2c (44)
  ULONGLONG IgnoreReservationsStartTime; // offset: 0x30 (48)
  union _MI_RESERVATION_CLUSTER_INFO volatile ReservationClusterInfo; // offset:
                                                                      // 0x38
                                                                      // (56)
  USHORT IgnoreReservations : 1; // offset: 0x3c (60)
  USHORT Spare : 15;             // offset: 0x3c (60)
  USHORT Spare1;                 // offset: 0x3e (62)
};

// 0x190 (400) bytes
struct _MI_PAGE_COMBINING_SUPPORT {
  struct _MI_PARTITION *Partition;                 // offset: 0x0 (0)
  struct _LIST_ENTRY ArbitraryPfnMapList;          // offset: 0x8 (8)
  struct _MI_COMBINE_WORKITEM FreeCombinePoolItem; // offset: 0x18 (24)
  ULONG CombiningThreadCount;                      // offset: 0x40 (64)
  struct _LIST_ENTRY CombinePageFreeList;          // offset: 0x48 (72)
  ULONGLONG CombineFreeListLock;                   // offset: 0x58 (88)
  struct _MI_COMBINE_PAGE_LISTHEAD
      CombinePageListHeads[16];                        // offset: 0x60 (96)
  ULONGLONG CommonPageCombineDomain;                   // offset: 0x160 (352)
  struct _MI_PAGE_COMBINE_STATISTICS PageCombineStats; // offset: 0x168 (360)
};

// 0x40 (64) bytes
struct _MI_PARTITION_COMMIT {
  ULONGLONG PeakCommitment;          // offset: 0x0 (0)
  ULONGLONG TotalCommitLimitMaximum; // offset: 0x8 (8)
  volatile LONG Popups[2];           // offset: 0x10 (16)
  ULONGLONG LowCommitThreshold;      // offset: 0x18 (24)
  ULONGLONG HighCommitThreshold;     // offset: 0x20 (32)
  ULONGLONG EventLock;               // offset: 0x28 (40)
  ULONGLONG SystemCommitReserve;     // offset: 0x30 (48)
  ULONGLONG OverCommit;              // offset: 0x38 (56)
};

// 0x8 (8) bytes
struct _MI_CLONE_BLOCK_FLAGS {
  ULONGLONG ActualCloneCommit : 59; // offset: 0x0 (0)
  ULONGLONG CloneProtection : 5;    // offset: 0x0 (0)
};

// 0x28 (40) bytes
struct _MMPFNLIST {
  ULONGLONG Total;        // offset: 0x0 (0)
  enum _MMLISTS ListName; // offset: 0x8 (8)
  ULONGLONG Flink;        // offset: 0x10 (16)
  ULONGLONG Blink;        // offset: 0x18 (24)
  ULONGLONG Lock;         // offset: 0x20 (32)
};

// 0x78 (120) bytes
struct _MI_SLAB_ALLOCATOR_CONTEXT {
  struct _RTL_RB_TREE AllocationsTree;            // offset: 0x0 (0)
  volatile LONG Lock;                             // offset: 0x10 (16)
  struct _MI_SLAB_ALLOCATOR_ENTRY *SlabEntryHint; // offset: 0x18 (24)
  ULONGLONG FreePageCount;                        // offset: 0x20 (32)
  ULONGLONG SlabEntryCount;                       // offset: 0x28 (40)
  enum _MI_SLAB_ALLOCATOR_TYPE Type;              // offset: 0x30 (48)
  enum _MI_SLAB_ALLOCATOR_PROTECTION Protection;  // offset: 0x34 (52)
  union {
    ULONG EntryBecameEmpty : 1; // offset: 0x38 (56)
    ULONG Spare : 31;           // offset: 0x38 (56)
    ULONG AllFlags;             // offset: 0x38 (56)

  } Flags;                       // offset: 0x38 (56)
  struct _MMPFNLIST StandbyList; // offset: 0x40 (64)
  ULONGLONG LastReplenishTime;   // offset: 0x68 (104)
  ULONGLONG LastFailureTime;     // offset: 0x70 (112)
};

// 0x58 (88) bytes
struct wil_details_StagingConfig {
  enum wil_FeatureStore store;                            // offset: 0x0 (0)
  LONG forUpdate;                                         // offset: 0x4 (4)
  ULONG readChangeStamp;                                  // offset: 0x8 (8)
  UCHAR readVersion;                                      // offset: 0xc (12)
  LONG modified;                                          // offset: 0x10 (16)
  struct wil_details_StagingConfigHeader *header;         // offset: 0x18 (24)
  struct wil_details_StagingConfigFeature *features;      // offset: 0x20 (32)
  struct wil_details_StagingConfigUsageTrigger *triggers; // offset: 0x28 (40)
  LONG changedInSession;                                  // offset: 0x30 (48)
  VOID *buffer;                                           // offset: 0x38 (56)
  ULONGLONG bufferSize;                                   // offset: 0x40 (64)
  ULONGLONG bufferAlloc;                                  // offset: 0x48 (72)
  LONG bufferOwned;                                       // offset: 0x50 (80)
};

// 0x8 (8) bytes
union wil_details_FeatureStateCache {
  ULONG exchange;                  // offset: 0x0 (0)
  ULONG stateCached : 1;           // offset: 0x0 (0)
  ULONG hasNotificationCached : 1; // offset: 0x0 (0)
  ULONG variantCached : 1;         // offset: 0x0 (0)
  ULONG effectiveState : 1;        // offset: 0x0 (0)
  ULONG desiredState : 1;          // offset: 0x0 (0)
  ULONG configuredState : 2;       // offset: 0x0 (0)
  ULONG needsRefresh : 1;          // offset: 0x0 (0)
  ULONG hasNotification : 1;       // offset: 0x0 (0)
  ULONG isVariant : 1;             // offset: 0x0 (0)
  ULONG variant : 6;               // offset: 0x0 (0)
  struct {
    ULONG unused : 16; // offset: 0x0 (0)
    ULONG payloadId;   // offset: 0x4 (4)
  };
  ULONGLONG exchange64; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct wil_details_FeatureDescriptor {
  union wil_details_FeatureStateCache *featureStateCache; // offset: 0x0 (0)
  ULONG featureId;                                        // offset: 0x8 (8)
  UCHAR changeTime;                                       // offset: 0xc (12)
  UCHAR isAlwaysDisabled;                                 // offset: 0xd (13)
  UCHAR isAlwaysEnabled;                                  // offset: 0xe (14)
  UCHAR isEnabledByDefault;                               // offset: 0xf (15)
  struct wil_details_FeatureDescriptor *const
      *requiresFeatures; // offset: 0x10 (16)
};

// 0x8 (8) bytes
union __m64 {
  ULONGLONG m64_u64; // offset: 0x0 (0)
  float m64_f32[2];  // offset: 0x0 (0)
  CHAR m64_i8[8];    // offset: 0x0 (0)
  SHORT m64_i16[4];  // offset: 0x0 (0)
  LONG m64_i32[2];   // offset: 0x0 (0)
  LONGLONG m64_i64;  // offset: 0x0 (0)
  UCHAR m64_u8[8];   // offset: 0x0 (0)
  USHORT m64_u16[4]; // offset: 0x0 (0)
  ULONG m64_u32[2];  // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _EVENT_FILTER_DESCRIPTOR {
  ULONGLONG Ptr; // offset: 0x0 (0)
  ULONG Size;    // offset: 0x8 (8)
  ULONG Type;    // offset: 0xc (12)
};

// 0x38 (56) bytes
struct _tlgProvider_t {
  ULONG LevelPlus1;                  // offset: 0x0 (0)
  const USHORT *ProviderMetadataPtr; // offset: 0x8 (8)
  ULONGLONG KeywordAny;              // offset: 0x10 (16)
  ULONGLONG KeywordAll;              // offset: 0x18 (24)
  ULONGLONG RegHandle;               // offset: 0x20 (32)
  VOID (*EnableCallback)
  (struct _GUID *arg1, ULONG arg2, UCHAR arg3, ULONGLONG arg4, ULONGLONG arg5,
   struct _EVENT_FILTER_DESCRIPTOR *arg6, VOID *arg7); // offset: 0x28 (40)
  VOID *CallbackContext;                               // offset: 0x30 (48)
};

// 0x8 (8) bytes
struct _RTL_CHASH_ENTRY {
  ULONGLONG Key; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _RTL_CHASH_TABLE {
  struct _RTL_CHASH_ENTRY *Table; // offset: 0x0 (0)
  ULONG EntrySizeShift;           // offset: 0x8 (8)
  ULONG EntryMax;                 // offset: 0xc (12)
  ULONG EntryCount;               // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _RTL_HASH_ENTRY {
  struct _SINGLE_LIST_ENTRY BucketLink; // offset: 0x0 (0)
  ULONGLONG Key;                        // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _RTL_HASH_TABLE_ITERATOR {
  struct _RTL_HASH_TABLE *Hash;      // offset: 0x0 (0)
  struct _RTL_HASH_ENTRY *HashEntry; // offset: 0x8 (8)
  struct _SINGLE_LIST_ENTRY *Bucket; // offset: 0x10 (16)
};

// 0x8 (8) bytes
struct _MM_PAGE_ACCESS_INFO {
  union {
    union _MM_PAGE_ACCESS_INFO_FLAGS Flags; // offset: 0x0 (0)
    ULONGLONG FileOffset;                   // offset: 0x0 (0)
    VOID *VirtualAddress;                   // offset: 0x0 (0)
    VOID *PointerProtoPte;                  // offset: 0x0 (0)
  };
};

// 0x10 (16) bytes
struct _EVENT_HEADER_EXTENDED_DATA_ITEM {
  USHORT Reserved1;      // offset: 0x0 (0)
  USHORT ExtType;        // offset: 0x2 (2)
  USHORT Linkage : 1;    // offset: 0x4 (4)
  USHORT Reserved2 : 15; // offset: 0x4 (4)
  USHORT DataSize;       // offset: 0x6 (6)
  ULONGLONG DataPtr;     // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _EX_FAST_REF {
  union {
    VOID *Object;         // offset: 0x0 (0)
    ULONGLONG RefCnt : 4; // offset: 0x0 (0)
    ULONGLONG Value;      // offset: 0x0 (0)
  };
};

// 0x10 (16) bytes
struct _IO_STATUS_BLOCK {
  union {
    LONG Status;   // offset: 0x0 (0)
    VOID *Pointer; // offset: 0x0 (0)
  };
  ULONGLONG Information; // offset: 0x8 (8)
};

// 0x8 (8) bytes
union _ULARGE_INTEGER {
  struct {
    ULONG LowPart;  // offset: 0x0 (0)
    ULONG HighPart; // offset: 0x4 (4)
  };
  struct {
    ULONG LowPart;    // offset: 0x0 (0)
    ULONG HighPart;   // offset: 0x4 (4)
  } u;                // offset: 0x0 (0)
  ULONGLONG QuadPart; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _KERNEL_STACK_SEGMENT {
  ULONGLONG StackBase;    // offset: 0x0 (0)
  ULONGLONG StackLimit;   // offset: 0x8 (8)
  ULONGLONG KernelStack;  // offset: 0x10 (16)
  ULONGLONG InitialStack; // offset: 0x18 (24)
};

// 0x30 (48) bytes
struct _KSTACK_CONTROL {
  ULONGLONG StackBase; // offset: 0x0 (0)
  union {
    ULONGLONG ActualLimit;        // offset: 0x8 (8)
    ULONGLONG StackExpansion : 1; // offset: 0x8 (8)
  };
  struct _KERNEL_STACK_SEGMENT Previous; // offset: 0x10 (16)
};

// 0xf0 (240) bytes
struct _IMAGE_OPTIONAL_HEADER64 {
  USHORT Magic;                                   // offset: 0x0 (0)
  UCHAR MajorLinkerVersion;                       // offset: 0x2 (2)
  UCHAR MinorLinkerVersion;                       // offset: 0x3 (3)
  ULONG SizeOfCode;                               // offset: 0x4 (4)
  ULONG SizeOfInitializedData;                    // offset: 0x8 (8)
  ULONG SizeOfUninitializedData;                  // offset: 0xc (12)
  ULONG AddressOfEntryPoint;                      // offset: 0x10 (16)
  ULONG BaseOfCode;                               // offset: 0x14 (20)
  ULONGLONG ImageBase;                            // offset: 0x18 (24)
  ULONG SectionAlignment;                         // offset: 0x20 (32)
  ULONG FileAlignment;                            // offset: 0x24 (36)
  USHORT MajorOperatingSystemVersion;             // offset: 0x28 (40)
  USHORT MinorOperatingSystemVersion;             // offset: 0x2a (42)
  USHORT MajorImageVersion;                       // offset: 0x2c (44)
  USHORT MinorImageVersion;                       // offset: 0x2e (46)
  USHORT MajorSubsystemVersion;                   // offset: 0x30 (48)
  USHORT MinorSubsystemVersion;                   // offset: 0x32 (50)
  ULONG Win32VersionValue;                        // offset: 0x34 (52)
  ULONG SizeOfImage;                              // offset: 0x38 (56)
  ULONG SizeOfHeaders;                            // offset: 0x3c (60)
  ULONG CheckSum;                                 // offset: 0x40 (64)
  USHORT Subsystem;                               // offset: 0x44 (68)
  USHORT DllCharacteristics;                      // offset: 0x46 (70)
  ULONGLONG SizeOfStackReserve;                   // offset: 0x48 (72)
  ULONGLONG SizeOfStackCommit;                    // offset: 0x50 (80)
  ULONGLONG SizeOfHeapReserve;                    // offset: 0x58 (88)
  ULONGLONG SizeOfHeapCommit;                     // offset: 0x60 (96)
  ULONG LoaderFlags;                              // offset: 0x68 (104)
  ULONG NumberOfRvaAndSizes;                      // offset: 0x6c (108)
  struct _IMAGE_DATA_DIRECTORY DataDirectory[16]; // offset: 0x70 (112)
};

// 0x108 (264) bytes
struct _IMAGE_NT_HEADERS64 {
  ULONG Signature;                                // offset: 0x0 (0)
  struct _IMAGE_FILE_HEADER FileHeader;           // offset: 0x4 (4)
  struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader; // offset: 0x18 (24)
};

// 0x4e8 (1256) bytes
struct _GDI_TEB_BATCH {
  ULONG Offset : 31;             // offset: 0x0 (0)
  ULONG HasRenderingCommand : 1; // offset: 0x0 (0)
  ULONGLONG HDC;                 // offset: 0x8 (8)
  ULONG Buffer[310];             // offset: 0x10 (16)
};

// 0x338 (824) bytes
struct _XSTATE_CONFIGURATION {
  ULONGLONG EnabledFeatures;         // offset: 0x0 (0)
  ULONGLONG EnabledVolatileFeatures; // offset: 0x8 (8)
  ULONG Size;                        // offset: 0x10 (16)
  union {
    ULONG ControlFlags; // offset: 0x14 (20)
    struct {
      ULONG OptimizedSave : 1;     // offset: 0x14 (20)
      ULONG CompactionEnabled : 1; // offset: 0x14 (20)
    };
  };
  struct _XSTATE_FEATURE Features[64];            // offset: 0x18 (24)
  ULONGLONG EnabledSupervisorFeatures;            // offset: 0x218 (536)
  ULONGLONG AlignedFeatures;                      // offset: 0x220 (544)
  ULONG AllFeatureSize;                           // offset: 0x228 (552)
  ULONG AllFeatures[64];                          // offset: 0x22c (556)
  ULONGLONG EnabledUserVisibleSupervisorFeatures; // offset: 0x330 (816)
};

// 0x8 (8) bytes
union _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS {
  ULONGLONG ProcessorType : 1;      // offset: 0x0 (0)
  ULONGLONG InstructionSet : 1;     // offset: 0x0 (0)
  ULONGLONG ErrorType : 1;          // offset: 0x0 (0)
  ULONGLONG Operation : 1;          // offset: 0x0 (0)
  ULONGLONG Flags : 1;              // offset: 0x0 (0)
  ULONGLONG Level : 1;              // offset: 0x0 (0)
  ULONGLONG CPUVersion : 1;         // offset: 0x0 (0)
  ULONGLONG CPUBrandString : 1;     // offset: 0x0 (0)
  ULONGLONG ProcessorId : 1;        // offset: 0x0 (0)
  ULONGLONG TargetAddress : 1;      // offset: 0x0 (0)
  ULONGLONG RequesterId : 1;        // offset: 0x0 (0)
  ULONGLONG ResponderId : 1;        // offset: 0x0 (0)
  ULONGLONG InstructionPointer : 1; // offset: 0x0 (0)
  ULONGLONG Reserved : 51;          // offset: 0x0 (0)
  ULONGLONG ValidBits;              // offset: 0x0 (0)
};

// 0xc0 (192) bytes
struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION {
  union _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS
      ValidBits;                // offset: 0x0 (0)
  UCHAR ProcessorType;          // offset: 0x8 (8)
  UCHAR InstructionSet;         // offset: 0x9 (9)
  UCHAR ErrorType;              // offset: 0xa (10)
  UCHAR Operation;              // offset: 0xb (11)
  UCHAR Flags;                  // offset: 0xc (12)
  UCHAR Level;                  // offset: 0xd (13)
  USHORT Reserved;              // offset: 0xe (14)
  ULONGLONG CPUVersion;         // offset: 0x10 (16)
  UCHAR CPUBrandString[128];    // offset: 0x18 (24)
  ULONGLONG ProcessorId;        // offset: 0x98 (152)
  ULONGLONG TargetAddress;      // offset: 0xa0 (160)
  ULONGLONG RequesterId;        // offset: 0xa8 (168)
  ULONGLONG ResponderId;        // offset: 0xb0 (176)
  ULONGLONG InstructionPointer; // offset: 0xb8 (184)
};

// 0x8 (8) bytes
struct _KTB_FLUSH_VA {
  union {
    ULONGLONG NumberOfEntries : 10; // offset: 0x0 (0)
    ULONGLONG PageSize : 2;         // offset: 0x0 (0)
    VOID *Va;                       // offset: 0x0 (0)
    ULONGLONG VaLong;               // offset: 0x0 (0)

  } u1; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _WHEA_RECOVERY_CONTEXT {
  union {
    struct {
      ULONGLONG Address;    // offset: 0x0 (0)
      UCHAR Consumed;       // offset: 0x8 (8)
      USHORT ErrorCode;     // offset: 0xa (10)
      UCHAR ErrorIpValid;   // offset: 0xc (12)
      UCHAR RestartIpValid; // offset: 0xd (13)
      UCHAR ClearPoison;    // offset: 0xe (14)
    } MemoryError;          // offset: 0x0 (0)
    struct {
      ULONGLONG PmemErrInfo; // offset: 0x0 (0)
    } PmemError;             // offset: 0x0 (0)
  };
  ULONGLONG PartitionId;                            // offset: 0x10 (16)
  ULONG VpIndex;                                    // offset: 0x18 (24)
  enum _WHEA_RECOVERY_CONTEXT_ERROR_TYPE ErrorType; // offset: 0x1c (28)
};

// 0x24 (36) bytes
struct _RSDP {
  ULONGLONG Signature;              // offset: 0x0 (0)
  UCHAR Checksum;                   // offset: 0x8 (8)
  UCHAR OEMID[6];                   // offset: 0x9 (9)
  UCHAR Revision;                   // offset: 0xf (15)
  ULONG RsdtAddress;                // offset: 0x10 (16)
  ULONG Length;                     // offset: 0x14 (20)
  union _LARGE_INTEGER XsdtAddress; // offset: 0x18 (24)
  UCHAR XChecksum;                  // offset: 0x20 (32)
  UCHAR Reserved[3];                // offset: 0x21 (33)
};

// 0x48 (72) bytes
struct _DMA_COMMON_BUFFER_VECTOR {
  struct _LIST_ENTRY ListEntry;             // offset: 0x0 (0)
  ULONGLONG SizeOfEntries;                  // offset: 0x10 (16)
  ULONG NumberOfEntries;                    // offset: 0x18 (24)
  struct _HALP_DMA_DOMAIN_OBJECT *Domain;   // offset: 0x20 (32)
  struct _MDL *Mdl;                         // offset: 0x28 (40)
  VOID *BaseAddress;                        // offset: 0x30 (48)
  ULONGLONG BaseLogicalAddress;             // offset: 0x38 (56)
  struct _DMA_COMMON_BUFFER_ENTRY *Entries; // offset: 0x40 (64)
};

// 0x18 (24) bytes
struct _SCATTER_GATHER_ELEMENT {
  union _LARGE_INTEGER Address; // offset: 0x0 (0)
  ULONG Length;                 // offset: 0x8 (8)
  ULONGLONG Reserved;           // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _DMA_SCATTER_GATHER_LIST {
  ULONG NumberOfElements;                     // offset: 0x0 (0)
  ULONGLONG Reserved;                         // offset: 0x8 (8)
  struct _SCATTER_GATHER_ELEMENT Elements[0]; // offset: 0x10 (16)
};

// 0x50 (80) bytes
struct _DMA_FUNCTION_TABLE {
  VOID (*InitializeController)(VOID *arg1); // offset: 0x0 (0)
  UCHAR (*ValidateRequestLineBinding)
  (VOID *arg1,
   struct _DMA_REQUEST_LINE_BINDING_DESCRIPTION *arg2); // offset: 0x8 (8)
  ULONG (*QueryMaxFragments)
  (VOID *arg1, ULONG arg2, ULONG arg3); // offset: 0x10 (16)
  VOID (*ProgramChannel)
  (VOID *arg1, ULONG arg2, ULONG arg3, struct _DMA_SCATTER_GATHER_LIST *arg4,
   union _LARGE_INTEGER arg5, UCHAR arg6, UCHAR arg7); // offset: 0x18 (24)
  LONG (*ConfigureChannel)
  (VOID *arg1, ULONG arg2, ULONG arg3, VOID *arg4); // offset: 0x20 (32)
  VOID (*FlushChannel)(VOID *arg1, ULONG arg2);     // offset: 0x28 (40)
  UCHAR (*HandleInterrupt)
  (VOID *arg1, ULONG *arg2,
   enum _DMA_INTERRUPT_TYPE *arg3);                // offset: 0x30 (48)
  ULONG (*ReadDmaCounter)(VOID *arg1, ULONG arg2); // offset: 0x38 (56)
  VOID (*ReportCommonBuffer)
  (VOID *arg1, ULONG arg2, VOID *arg3,
   union _LARGE_INTEGER arg4);                     // offset: 0x40 (64)
  UCHAR (*CancelTransfer)(VOID *arg1, ULONG arg2); // offset: 0x48 (72)
};

// 0x8 (8) bytes
struct _EXT_IOMMU_DEVICE_ID_TEST {
  ULONGLONG UniqueId; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _EXT_IOMMU_DEVICE_ID_PCI {
  union {
    ULONGLONG AsUINT64; // offset: 0x0 (0)
    struct {
      USHORT PciSegmentNumber;        // offset: 0x0 (0)
      USHORT PhantomFunctionBits : 2; // offset: 0x2 (2)
      USHORT BusRange : 1;            // offset: 0x2 (2)
      USHORT Reserved : 5;            // offset: 0x2 (2)
      USHORT StartBusNumber : 8;      // offset: 0x2 (2)
      union {
        USHORT Bdf; // offset: 0x4 (4)
        struct {
          UCHAR SubordinateBus; // offset: 0x4 (4)
          UCHAR SecondaryBus;   // offset: 0x5 (5)
        };
      };
      USHORT DevicePathLength; // offset: 0x6 (6)
    };
  };
  WCHAR *DevicePath; // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _HALP_DMA_TRANSLATION_ENTRY {
  ULONGLONG PhysicalAddress;                // offset: 0x0 (0)
  struct _HALP_DMA_TRANSLATION_ENTRY *Next; // offset: 0x8 (8)
  ULONG MappedLength;                       // offset: 0x10 (16)
  ULONGLONG LogicalAddress;                 // offset: 0x18 (24)
  ULONGLONG LogicalMappedLength;            // offset: 0x20 (32)
  ULONGLONG NextLogicalAddress;             // offset: 0x28 (40)
  union {
    VOID *VirtualAddress; // offset: 0x30 (48)
    struct {
      ULONGLONG BoundToMaster : 1;      // offset: 0x0 (0)
      ULONGLONG BoundToScatterPool : 1; // offset: 0x0 (0)
      ULONGLONG OwnedByMaster : 1;      // offset: 0x0 (0)
      ULONGLONG OwnedByScatterPool : 1; // offset: 0x0 (0)
      ULONGLONG TemporaryMapping : 1;   // offset: 0x0 (0)
      ULONGLONG ZeroBuffer : 1;         // offset: 0x0 (0)
      ULONGLONG Address : 58;           // offset: 0x0 (0)
    } Flags;                            // offset: 0x30 (48)

  } u;                                             // offset: 0x30 (48)
  struct _HALP_DMA_TRANSLATION_ENTRY *NextMapping; // offset: 0x38 (56)
  UCHAR LogicalBounceBufferPremapped;              // offset: 0x40 (64)
};

// 0x18 (24) bytes
struct _EXT_IOMMU_DEVICE_ID {
  enum _EXT_IOMMU_DEVICE_TYPE DeviceType; // offset: 0x0 (0)
  union {
    struct _EXT_IOMMU_DEVICE_ID_PCI Pci;   // offset: 0x8 (8)
    struct _EXT_IOMMU_DEVICE_ID_ACPI Acpi; // offset: 0x8 (8)
    UCHAR IoApicId;                        // offset: 0x8 (8)
    ULONGLONG LogicalId;                   // offset: 0x8 (8)
    struct _EXT_IOMMU_DEVICE_ID_TEST Test; // offset: 0x8 (8)
    struct _EXT_IOMMU_DEVICE_ID_GIC Gic;   // offset: 0x8 (8)
  };
};

// 0x98 (152) bytes
struct _HAL_IOMMU_DISPATCH {
  UCHAR (*HalIommuSupportEnabled)(); // offset: 0x0 (0)
  LONG (*HalIommuGetConfiguration)
  (ULONG arg1, ULONG *arg2, ULONG *arg3, VOID **arg4); // offset: 0x8 (8)
  LONG (*HalIommuGetLibraryContext)
  (ULONG arg1, ULONG arg2, VOID **arg3); // offset: 0x10 (16)
  LONG (*HalIommuMapDevice)
  (VOID *arg1, struct _EXT_IOMMU_DEVICE_ID *arg2,
   union _IOMMU_SVM_CAPABILITIES *arg3, VOID **arg4); // offset: 0x18 (24)
  LONG (*HalIommuEnableDevicePasid)
  (VOID *arg1, VOID *arg2); // offset: 0x20 (32)
  LONG (*HalIommuSetAddressSpace)
  (VOID *arg1, ULONGLONG arg2); // offset: 0x28 (40)
  LONG (*HalIommuDisableDevicePasid)
  (VOID *arg1, VOID *arg2);                            // offset: 0x30 (48)
  LONG (*HalIommuUnmapDevice)(VOID *arg1, VOID *arg2); // offset: 0x38 (56)
  LONG (*HalIommuFreeLibraryContext)(VOID *arg1);      // offset: 0x40 (64)
  VOID (*HalIommuFlushTb)
  (VOID *arg1, ULONG arg2, struct _KTB_FLUSH_VA *arg3); // offset: 0x48 (72)
  VOID (*HalIommuFlushAllPasid)
  (VOID *arg1, ULONG arg2, struct _KTB_FLUSH_VA *arg3); // offset: 0x50 (80)
  UCHAR (*HalIommuProcessPageRequestQueue)(ULONG arg1); // offset: 0x58 (88)
  VOID (*HalIommuFaultRoutine)(ULONG arg1);             // offset: 0x60 (96)
  VOID *(*HalIommuReferenceAsid)(ULONG arg1);           // offset: 0x68 (104)
  VOID (*HalIommuDereferenceAsid)(ULONG arg1);          // offset: 0x70 (112)
  LONG (*HalIommuServicePageFault)
  (ULONGLONG arg1, VOID *arg2, ULONG arg3); // offset: 0x78 (120)
  LONG (*HalIommuDevicePowerChange)
  (VOID *arg1, VOID *arg2, UCHAR arg3); // offset: 0x80 (128)
  LONG (*HalIommuBeginDeviceReset)
  (VOID *arg1, ULONG *arg2);                       // offset: 0x88 (136)
  LONG (*HalIommuFinalizeDeviceReset)(VOID *arg1); // offset: 0x90 (144)
};

// 0x10 (16) bytes
struct _SCATTER_GATHER_LIST {
  ULONG NumberOfElements;                     // offset: 0x0 (0)
  ULONGLONG Reserved;                         // offset: 0x8 (8)
  struct _SCATTER_GATHER_ELEMENT Elements[0]; // offset: 0x10 (16)
};

// 0x138 (312) bytes
struct _DMA_OPERATIONS {
  ULONG Size;                                       // offset: 0x0 (0)
  VOID (*PutDmaAdapter)(struct _DMA_ADAPTER *arg1); // offset: 0x8 (8)
  VOID *(*AllocateCommonBuffer)(struct _DMA_ADAPTER *arg1, ULONG arg2,
                                union _LARGE_INTEGER *arg3,
                                UCHAR arg4); // offset: 0x10 (16)
  VOID (*FreeCommonBuffer)
  (struct _DMA_ADAPTER *arg1, ULONG arg2, union _LARGE_INTEGER arg3, VOID *arg4,
   UCHAR arg5); // offset: 0x18 (24)
  LONG (*AllocateAdapterChannel)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2, ULONG arg3,
   enum _IO_ALLOCATION_ACTION (*arg4)(struct _DEVICE_OBJECT *arg1,
                                      struct _IRP *arg2, VOID *arg3,
                                      VOID *arg4),
   VOID *arg5); // offset: 0x20 (32)
  UCHAR (*FlushAdapterBuffers)
  (struct _DMA_ADAPTER *arg1, struct _MDL *arg2, VOID *arg3, VOID *arg4,
   ULONG arg5, UCHAR arg6);                              // offset: 0x28 (40)
  VOID (*FreeAdapterChannel)(struct _DMA_ADAPTER *arg1); // offset: 0x30 (48)
  VOID (*FreeMapRegisters)
  (struct _DMA_ADAPTER *arg1, VOID *arg2, ULONG arg3); // offset: 0x38 (56)
  union _LARGE_INTEGER (*MapTransfer)(struct _DMA_ADAPTER *arg1,
                                      struct _MDL *arg2, VOID *arg3, VOID *arg4,
                                      ULONG *arg5,
                                      UCHAR arg6);     // offset: 0x40 (64)
  ULONG (*GetDmaAlignment)(struct _DMA_ADAPTER *arg1); // offset: 0x48 (72)
  ULONG (*ReadDmaCounter)(struct _DMA_ADAPTER *arg1);  // offset: 0x50 (80)
  LONG (*GetScatterGatherList)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2, struct _MDL *arg3,
   VOID *arg4, ULONG arg5,
   VOID (*arg6)(struct _DEVICE_OBJECT *arg1, struct _IRP *arg2,
                struct _SCATTER_GATHER_LIST *arg3, VOID *arg4),
   VOID *arg7, UCHAR arg8); // offset: 0x58 (88)
  VOID (*PutScatterGatherList)
  (struct _DMA_ADAPTER *arg1, struct _SCATTER_GATHER_LIST *arg2,
   UCHAR arg3); // offset: 0x60 (96)
  LONG (*CalculateScatterGatherList)
  (struct _DMA_ADAPTER *arg1, struct _MDL *arg2, VOID *arg3, ULONG arg4,
   ULONG *arg5, ULONG *arg6); // offset: 0x68 (104)
  LONG (*BuildScatterGatherList)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2, struct _MDL *arg3,
   VOID *arg4, ULONG arg5,
   VOID (*arg6)(struct _DEVICE_OBJECT *arg1, struct _IRP *arg2,
                struct _SCATTER_GATHER_LIST *arg3, VOID *arg4),
   VOID *arg7, UCHAR arg8, VOID *arg9, ULONG arg10); // offset: 0x70 (112)
  LONG (*BuildMdlFromScatterGatherList)
  (struct _DMA_ADAPTER *arg1, struct _SCATTER_GATHER_LIST *arg2,
   struct _MDL *arg3, struct _MDL **arg4); // offset: 0x78 (120)
  LONG (*GetDmaAdapterInfo)
  (struct _DMA_ADAPTER *arg1,
   struct _DMA_ADAPTER_INFO *arg2); // offset: 0x80 (128)
  LONG (*GetDmaTransferInfo)
  (struct _DMA_ADAPTER *arg1, struct _MDL *arg2, ULONGLONG arg3, ULONG arg4,
   UCHAR arg5, struct _DMA_TRANSFER_INFO *arg6); // offset: 0x88 (136)
  LONG (*InitializeDmaTransferContext)
  (struct _DMA_ADAPTER *arg1, VOID *arg2); // offset: 0x90 (144)
  VOID *(*AllocateCommonBufferEx)(struct _DMA_ADAPTER *arg1,
                                  union _LARGE_INTEGER *arg2, ULONG arg3,
                                  union _LARGE_INTEGER *arg4, UCHAR arg5,
                                  ULONG arg6); // offset: 0x98 (152)
  LONG (*AllocateAdapterChannelEx)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2, VOID *arg3,
   ULONG arg4, ULONG arg5,
   enum _IO_ALLOCATION_ACTION (*arg6)(struct _DEVICE_OBJECT *arg1,
                                      struct _IRP *arg2, VOID *arg3,
                                      VOID *arg4),
   VOID *arg7, VOID **arg8); // offset: 0xa0 (160)
  LONG (*ConfigureAdapterChannel)
  (struct _DMA_ADAPTER *arg1, ULONG arg2, VOID *arg3); // offset: 0xa8 (168)
  UCHAR (*CancelAdapterChannel)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2,
   VOID *arg3); // offset: 0xb0 (176)
  LONG (*MapTransferEx)
  (struct _DMA_ADAPTER *arg1, struct _MDL *arg2, VOID *arg3, ULONGLONG arg4,
   ULONG arg5, ULONG *arg6, UCHAR arg7, struct _SCATTER_GATHER_LIST *arg8,
   ULONG arg9,
   VOID (*arg10)(struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2,
                 VOID *arg3, enum DMA_COMPLETION_STATUS arg4),
   VOID *arg11); // offset: 0xb8 (184)
  LONG (*GetScatterGatherListEx)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2, VOID *arg3,
   struct _MDL *arg4, ULONGLONG arg5, ULONG arg6, ULONG arg7,
   VOID (*arg8)(struct _DEVICE_OBJECT *arg1, struct _IRP *arg2,
                struct _SCATTER_GATHER_LIST *arg3, VOID *arg4),
   VOID *arg9, UCHAR arg10,
   VOID (*arg11)(struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2,
                 VOID *arg3, enum DMA_COMPLETION_STATUS arg4),
   VOID *arg12, struct _SCATTER_GATHER_LIST **arg13); // offset: 0xc0 (192)
  LONG (*BuildScatterGatherListEx)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2, VOID *arg3,
   struct _MDL *arg4, ULONGLONG arg5, ULONG arg6, ULONG arg7,
   VOID (*arg8)(struct _DEVICE_OBJECT *arg1, struct _IRP *arg2,
                struct _SCATTER_GATHER_LIST *arg3, VOID *arg4),
   VOID *arg9, UCHAR arg10, VOID *arg11, ULONG arg12,
   VOID (*arg13)(struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2,
                 VOID *arg3, enum DMA_COMPLETION_STATUS arg4),
   VOID *arg14, VOID *arg15); // offset: 0xc8 (200)
  LONG (*FlushAdapterBuffersEx)
  (struct _DMA_ADAPTER *arg1, struct _MDL *arg2, VOID *arg3, ULONGLONG arg4,
   ULONG arg5, UCHAR arg6); // offset: 0xd0 (208)
  VOID (*FreeAdapterObject)
  (struct _DMA_ADAPTER *arg1,
   enum _IO_ALLOCATION_ACTION arg2); // offset: 0xd8 (216)
  LONG (*CancelMappedTransfer)
  (struct _DMA_ADAPTER *arg1, VOID *arg2); // offset: 0xe0 (224)
  LONG (*AllocateDomainCommonBuffer)
  (struct _DMA_ADAPTER *arg1, VOID *arg2, union _LARGE_INTEGER *arg3,
   ULONG arg4, ULONG arg5, enum _MEMORY_CACHING_TYPE *arg6, ULONG arg7,
   union _LARGE_INTEGER *arg8, VOID **arg9); // offset: 0xe8 (232)
  LONG (*FlushDmaBuffer)
  (struct _DMA_ADAPTER *arg1, struct _MDL *arg2,
   UCHAR arg3); // offset: 0xf0 (240)
  LONG (*JoinDmaDomain)
  (struct _DMA_ADAPTER *arg1, VOID *arg2);           // offset: 0xf8 (248)
  LONG (*LeaveDmaDomain)(struct _DMA_ADAPTER *arg1); // offset: 0x100 (256)
  VOID *(*GetDmaDomain)(struct _DMA_ADAPTER *arg1);  // offset: 0x108 (264)
  VOID *(*AllocateCommonBufferWithBounds)(
      struct _DMA_ADAPTER *arg1, union _LARGE_INTEGER *arg2,
      union _LARGE_INTEGER *arg3, ULONG arg4, ULONG arg5,
      enum _MEMORY_CACHING_TYPE *arg6, ULONG arg7,
      union _LARGE_INTEGER *arg8); // offset: 0x110 (272)
  LONG (*AllocateCommonBufferVector)
  (struct _DMA_ADAPTER *arg1, union _LARGE_INTEGER arg2,
   union _LARGE_INTEGER arg3, enum _MEMORY_CACHING_TYPE arg4, ULONG arg5,
   ULONG arg6, ULONG arg7, ULONGLONG arg8,
   struct _DMA_COMMON_BUFFER_VECTOR **arg9); // offset: 0x118 (280)
  VOID (*GetCommonBufferFromVectorByIndex)
  (struct _DMA_ADAPTER *arg1, struct _DMA_COMMON_BUFFER_VECTOR *arg2,
   ULONG arg3, VOID **arg4, union _LARGE_INTEGER *arg5); // offset: 0x120 (288)
  VOID (*FreeCommonBufferFromVector)
  (struct _DMA_ADAPTER *arg1, struct _DMA_COMMON_BUFFER_VECTOR *arg2,
   ULONG arg3); // offset: 0x128 (296)
  VOID (*FreeCommonBufferVector)
  (struct _DMA_ADAPTER *arg1,
   struct _DMA_COMMON_BUFFER_VECTOR *arg2); // offset: 0x130 (304)
};

// 0x10 (16) bytes
struct _DMA_ADAPTER {
  USHORT Version;                        // offset: 0x0 (0)
  USHORT Size;                           // offset: 0x2 (2)
  struct _DMA_OPERATIONS *DmaOperations; // offset: 0x8 (8)
};

// 0x98 (152) bytes
struct _HALP_DMA_ADAPTER_OBJECT {
  struct _DMA_ADAPTER DmaHeader;              // offset: 0x0 (0)
  struct _RTL_BITMAP *ContiguousMapRegisters; // offset: 0x10 (16)
  struct _HALP_DMA_TRANSLATION_ENTRY
      *ScatterBufferListHead;       // offset: 0x18 (24)
  ULONG NumberOfFreeScatterBuffers; // offset: 0x20 (32)
  struct _HALP_DMA_TRANSLATION_BUFFER
      *ContiguousTranslations;                              // offset: 0x28 (40)
  struct _HALP_DMA_TRANSLATION_BUFFER *ScatterTranslations; // offset: 0x30 (48)
  struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
      ContiguousTranslationEnd; // offset: 0x38 (56)
  struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
      ScatterTranslationEnd; // offset: 0x48 (72)
  struct {
    struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
        ContiguousHint; // offset: 0x0 (0)
    struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
        ScatterHint;                           // offset: 0x10 (16)
  } CrashDump;                                 // offset: 0x58 (88)
  ULONGLONG SpinLock;                          // offset: 0x78 (120)
  ULONGLONG GrowLock;                          // offset: 0x80 (128)
  union _LARGE_INTEGER MaximumPhysicalAddress; // offset: 0x88 (136)
  UCHAR IsMasterAdapter;                       // offset: 0x90 (144)
  UCHAR DmaCanCross64K;                        // offset: 0x91 (145)
  ULONG LibraryVersion;                        // offset: 0x94 (148)
};

// 0xd8 (216) bytes
struct _HALP_DMA_MASTER_ADAPTER_OBJECT {
  struct _HALP_DMA_ADAPTER_OBJECT AdapterObject; // offset: 0x0 (0)
  struct _LIST_ENTRY ContiguousAdapterQueue;     // offset: 0x98 (152)
  struct _LIST_ENTRY ScatterAdapterQueue;        // offset: 0xa8 (168)
  ULONG MapBufferSize;                           // offset: 0xb8 (184)
  union _LARGE_INTEGER MapBufferPhysicalAddress; // offset: 0xc0 (192)
  ULONG ContiguousPageCount;                     // offset: 0xc8 (200)
  ULONG ContiguousPageLimit;                     // offset: 0xcc (204)
  ULONG ScatterPageCount;                        // offset: 0xd0 (208)
  ULONG ScatterPageLimit;                        // offset: 0xd4 (212)
};

// 0x10 (16) bytes
struct _IOSAPIC {
  UCHAR Type;               // offset: 0x0 (0)
  UCHAR Length;             // offset: 0x1 (1)
  UCHAR IOSAPICID;          // offset: 0x2 (2)
  UCHAR Reserved;           // offset: 0x3 (3)
  ULONG SystemVectorBase;   // offset: 0x4 (4)
  ULONGLONG IOSAPICAddress; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _MCI_STATUS_INTEL_BITS {
  ULONGLONG McaErrorCode : 16;        // offset: 0x0 (0)
  ULONGLONG ModelErrorCode : 16;      // offset: 0x0 (0)
  ULONGLONG OtherInfo : 5;            // offset: 0x0 (0)
  ULONGLONG FirmwareUpdateError : 1;  // offset: 0x0 (0)
  ULONGLONG CorrectedErrorCount : 15; // offset: 0x0 (0)
  ULONGLONG ThresholdErrorStatus : 2; // offset: 0x0 (0)
  ULONGLONG ActionRequired : 1;       // offset: 0x0 (0)
  ULONGLONG Signalling : 1;           // offset: 0x0 (0)
  ULONGLONG ContextCorrupt : 1;       // offset: 0x0 (0)
  ULONGLONG AddressValid : 1;         // offset: 0x0 (0)
  ULONGLONG MiscValid : 1;            // offset: 0x0 (0)
  ULONGLONG ErrorEnabled : 1;         // offset: 0x0 (0)
  ULONGLONG UncorrectedError : 1;     // offset: 0x0 (0)
  ULONGLONG StatusOverFlow : 1;       // offset: 0x0 (0)
  ULONGLONG Valid : 1;                // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MCI_STATUS_AMD_BITS {
  ULONGLONG McaErrorCode : 16;            // offset: 0x0 (0)
  ULONGLONG ModelErrorCode : 16;          // offset: 0x0 (0)
  ULONGLONG ImplementationSpecific2 : 11; // offset: 0x0 (0)
  ULONGLONG Poison : 1;                   // offset: 0x0 (0)
  ULONGLONG Deferred : 1;                 // offset: 0x0 (0)
  ULONGLONG ImplementationSpecific1 : 12; // offset: 0x0 (0)
  ULONGLONG ContextCorrupt : 1;           // offset: 0x0 (0)
  ULONGLONG AddressValid : 1;             // offset: 0x0 (0)
  ULONGLONG MiscValid : 1;                // offset: 0x0 (0)
  ULONGLONG ErrorEnabled : 1;             // offset: 0x0 (0)
  ULONGLONG UncorrectedError : 1;         // offset: 0x0 (0)
  ULONGLONG StatusOverFlow : 1;           // offset: 0x0 (0)
  ULONGLONG Valid : 1;                    // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MCI_STATUS_BITS_COMMON {
  ULONGLONG McaErrorCode : 16;    // offset: 0x0 (0)
  ULONGLONG ModelErrorCode : 16;  // offset: 0x0 (0)
  ULONGLONG Reserved : 25;        // offset: 0x0 (0)
  ULONGLONG ContextCorrupt : 1;   // offset: 0x0 (0)
  ULONGLONG AddressValid : 1;     // offset: 0x0 (0)
  ULONGLONG MiscValid : 1;        // offset: 0x0 (0)
  ULONGLONG ErrorEnabled : 1;     // offset: 0x0 (0)
  ULONGLONG UncorrectedError : 1; // offset: 0x0 (0)
  ULONGLONG StatusOverFlow : 1;   // offset: 0x0 (0)
  ULONGLONG Valid : 1;            // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _MCG_CAP {
  ULONGLONG CountField : 8;                     // offset: 0x0 (0)
  ULONGLONG ControlMsrPresent : 1;              // offset: 0x0 (0)
  ULONGLONG ExtendedMsrsPresent : 1;            // offset: 0x0 (0)
  ULONGLONG SignalingExtensionPresent : 1;      // offset: 0x0 (0)
  ULONGLONG ThresholdErrorStatusPresent : 1;    // offset: 0x0 (0)
  ULONGLONG Reserved : 4;                       // offset: 0x0 (0)
  ULONGLONG ExtendedRegisterCount : 8;          // offset: 0x0 (0)
  ULONGLONG SoftwareErrorRecoverySupported : 1; // offset: 0x0 (0)
  ULONGLONG EnhancedMachineCheckCapability : 1; // offset: 0x0 (0)
  ULONGLONG ExtendedErrorLogging : 1;           // offset: 0x0 (0)
  ULONGLONG LocalMachineCheckException : 1;     // offset: 0x0 (0)
  ULONGLONG QuadPart;                           // offset: 0x0 (0)
};

// 0xc0 (192) bytes
struct _WHEA_AMD_EXTENDED_REGISTERS {
  ULONGLONG IPID;         // offset: 0x0 (0)
  ULONGLONG SYND;         // offset: 0x8 (8)
  ULONGLONG CONFIG;       // offset: 0x10 (16)
  ULONGLONG DESTAT;       // offset: 0x18 (24)
  ULONGLONG DEADDR;       // offset: 0x20 (32)
  ULONGLONG MISC1;        // offset: 0x28 (40)
  ULONGLONG MISC2;        // offset: 0x30 (48)
  ULONGLONG MISC3;        // offset: 0x38 (56)
  ULONGLONG MISC4;        // offset: 0x40 (64)
  ULONGLONG RasCap;       // offset: 0x48 (72)
  ULONGLONG Reserved[14]; // offset: 0x50 (80)
};

// 0x8 (8) bytes
union _MCI_STATUS {
  struct _MCI_STATUS_BITS_COMMON CommonBits; // offset: 0x0 (0)
  struct _MCI_STATUS_AMD_BITS AmdBits;       // offset: 0x0 (0)
  struct _MCI_STATUS_INTEL_BITS IntelBits;   // offset: 0x0 (0)
  ULONGLONG QuadPart;                        // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _MCG_STATUS {
  ULONG RestartIpValid : 1;         // offset: 0x0 (0)
  ULONG ErrorIpValid : 1;           // offset: 0x0 (0)
  ULONG MachineCheckInProgress : 1; // offset: 0x0 (0)
  ULONG LocalMceValid : 1;          // offset: 0x0 (0)
  struct {
    ULONG Reserved1 : 28; // offset: 0x0 (0)
    ULONG Reserved2;      // offset: 0x4 (4)
  };
  ULONGLONG QuadPart; // offset: 0x0 (0)
};

// 0x110 (272) bytes
struct _WHEA_XPF_MCA_SECTION {
  ULONG VersionNumber;             // offset: 0x0 (0)
  enum _WHEA_CPU_VENDOR CpuVendor; // offset: 0x4 (4)
  union _LARGE_INTEGER Timestamp;  // offset: 0x8 (8)
  ULONG ProcessorNumber;           // offset: 0x10 (16)
  union _MCG_STATUS GlobalStatus;  // offset: 0x14 (20)
  ULONGLONG InstructionPointer;    // offset: 0x1c (28)
  ULONG BankNumber;                // offset: 0x24 (36)
  union _MCI_STATUS Status;        // offset: 0x28 (40)
  ULONGLONG Address;               // offset: 0x30 (48)
  ULONGLONG Misc;                  // offset: 0x38 (56)
  ULONG ExtendedRegisterCount;     // offset: 0x40 (64)
  ULONG ApicId;                    // offset: 0x44 (68)
  union {
    ULONGLONG ExtendedRegisters[24]; // offset: 0x48 (72)
    struct _WHEA_AMD_EXTENDED_REGISTERS
        AMDExtendedRegisters; // offset: 0x48 (72)
  };
  union _MCG_CAP GlobalCapability; // offset: 0x108 (264)
};

// 0x18 (24) bytes
struct _INTERRUPT_TARGET {
  enum _INTERRUPT_TARGET_TYPE Target; // offset: 0x0 (0)
  union {
    ULONG PhysicalTarget;    // offset: 0x8 (8)
    ULONG LogicalFlatTarget; // offset: 0x8 (8)
    ULONG RemapIndex;        // offset: 0x8 (8)
    struct {
      ULONG ClusterId;   // offset: 0x8 (8)
      ULONG ClusterMask; // offset: 0xc (12)
    };
    struct {
      ULONG Low32;             // offset: 0x0 (0)
      ULONG High32;            // offset: 0x4 (4)
      ULONGLONG InterruptData; // offset: 0x8 (8)
    } HypervisorTarget;        // offset: 0x8 (8)
  };
};

// 0x38 (56) bytes
struct _INTERRUPT_LINE_STATE {
  enum _KINTERRUPT_POLARITY Polarity;       // offset: 0x0 (0)
  UCHAR EmulateActiveBoth;                  // offset: 0x4 (4)
  enum _KINTERRUPT_MODE TriggerMode;        // offset: 0x8 (8)
  ULONG Flags;                              // offset: 0xc (12)
  struct _INTERRUPT_LINE Routing;           // offset: 0x10 (16)
  struct _INTERRUPT_TARGET ProcessorTarget; // offset: 0x18 (24)
  ULONG Vector;                             // offset: 0x30 (48)
  ULONG Priority;                           // offset: 0x34 (52)
};

// 0x30 (48) bytes
struct _IO_APIC_DATA {
  ULONGLONG PhysicalAddress;              // offset: 0x0 (0)
  ULONG Identifier;                       // offset: 0x8 (8)
  struct _IO_APIC_REGISTERS *BaseAddress; // offset: 0x10 (16)
  UCHAR Version;                          // offset: 0x18 (24)
  UCHAR PinCount;                         // offset: 0x19 (25)
  UCHAR Initialized;                      // offset: 0x1a (26)
  UCHAR InitializedFirstLocalUnit;        // offset: 0x1b (27)
  ULONG GsiBase;                          // offset: 0x1c (28)
  ULONG CmciRegister;                     // offset: 0x20 (32)
  ULONG DeferredErrorRegister;            // offset: 0x24 (36)
  UCHAR IoUnitMissing;                    // offset: 0x28 (40)
};

// 0x8 (8) bytes
union _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS {
  ULONGLONG LocalAPICId : 1;      // offset: 0x0 (0)
  ULONGLONG CpuId : 1;            // offset: 0x0 (0)
  ULONGLONG ProcInfoCount : 6;    // offset: 0x0 (0)
  ULONGLONG ContextInfoCount : 6; // offset: 0x0 (0)
  ULONGLONG Reserved : 50;        // offset: 0x0 (0)
  ULONGLONG ValidBits;            // offset: 0x0 (0)
};

// 0x41 (65) bytes
struct _WHEA_XPF_PROCESSOR_ERROR_SECTION {
  union _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS
      ValidBits;         // offset: 0x0 (0)
  ULONGLONG LocalAPICId; // offset: 0x8 (8)
  UCHAR CpuId[48];       // offset: 0x10 (16)
  UCHAR VariableInfo[1]; // offset: 0x40 (64)
};

// 0x8 (8) bytes
struct _HARDWARE_PTE {
  ULONGLONG Valid : 1;            // offset: 0x0 (0)
  ULONGLONG Write : 1;            // offset: 0x0 (0)
  ULONGLONG Owner : 1;            // offset: 0x0 (0)
  ULONGLONG WriteThrough : 1;     // offset: 0x0 (0)
  ULONGLONG CacheDisable : 1;     // offset: 0x0 (0)
  ULONGLONG Accessed : 1;         // offset: 0x0 (0)
  ULONGLONG Dirty : 1;            // offset: 0x0 (0)
  ULONGLONG LargePage : 1;        // offset: 0x0 (0)
  ULONGLONG Global : 1;           // offset: 0x0 (0)
  ULONGLONG CopyOnWrite : 1;      // offset: 0x0 (0)
  ULONGLONG Prototype : 1;        // offset: 0x0 (0)
  ULONGLONG reserved0 : 1;        // offset: 0x0 (0)
  ULONGLONG PageFrameNumber : 36; // offset: 0x0 (0)
  ULONGLONG reserved1 : 4;        // offset: 0x0 (0)
  ULONGLONG SoftwareWsIndex : 11; // offset: 0x0 (0)
  ULONGLONG NoExecute : 1;        // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _HALP_ALLOC_CONTEXT {
  struct _LIST_ENTRY BufferList; // offset: 0x0 (0)
  ULONGLONG Lock;                // offset: 0x10 (16)
};

// 0x8 (8) bytes
union _WHEA_PERSISTENCE_INFO {
  ULONGLONG Signature : 16;  // offset: 0x0 (0)
  ULONGLONG Length : 24;     // offset: 0x0 (0)
  ULONGLONG Identifier : 16; // offset: 0x0 (0)
  ULONGLONG Attributes : 2;  // offset: 0x0 (0)
  ULONGLONG DoNotLog : 1;    // offset: 0x0 (0)
  ULONGLONG Reserved : 5;    // offset: 0x0 (0)
  ULONGLONG AsULONGLONG;     // offset: 0x0 (0)
};

// 0x8 (8) bytes
union _WHEA_TIMESTAMP {
  ULONGLONG Seconds : 8;                // offset: 0x0 (0)
  ULONGLONG Minutes : 8;                // offset: 0x0 (0)
  ULONGLONG Hours : 8;                  // offset: 0x0 (0)
  ULONGLONG Precise : 1;                // offset: 0x0 (0)
  ULONGLONG Reserved : 7;               // offset: 0x0 (0)
  ULONGLONG Day : 8;                    // offset: 0x0 (0)
  ULONGLONG Month : 8;                  // offset: 0x0 (0)
  ULONGLONG Year : 8;                   // offset: 0x0 (0)
  ULONGLONG Century : 8;                // offset: 0x0 (0)
  union _LARGE_INTEGER AsLARGE_INTEGER; // offset: 0x0 (0)
};

// 0x80 (128) bytes
struct _WHEA_ERROR_RECORD_HEADER {
  ULONG Signature;                                     // offset: 0x0 (0)
  union _WHEA_REVISION Revision;                       // offset: 0x4 (4)
  ULONG SignatureEnd;                                  // offset: 0x6 (6)
  USHORT SectionCount;                                 // offset: 0xa (10)
  enum _WHEA_ERROR_SEVERITY Severity;                  // offset: 0xc (12)
  union _WHEA_ERROR_RECORD_HEADER_VALIDBITS ValidBits; // offset: 0x10 (16)
  ULONG Length;                                        // offset: 0x14 (20)
  union _WHEA_TIMESTAMP Timestamp;                     // offset: 0x18 (24)
  struct _GUID PlatformId;                             // offset: 0x20 (32)
  struct _GUID PartitionId;                            // offset: 0x30 (48)
  struct _GUID CreatorId;                              // offset: 0x40 (64)
  struct _GUID NotifyType;                             // offset: 0x50 (80)
  ULONGLONG RecordId;                                  // offset: 0x60 (96)
  union _WHEA_ERROR_RECORD_HEADER_FLAGS Flags;         // offset: 0x68 (104)
  union _WHEA_PERSISTENCE_INFO PersistenceInfo;        // offset: 0x6c (108)
  UCHAR Reserved[12];                                  // offset: 0x74 (116)
};

// 0xc8 (200) bytes
struct _WHEA_ERROR_RECORD {
  struct _WHEA_ERROR_RECORD_HEADER Header; // offset: 0x0 (0)
  struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR
      SectionDescriptor[1]; // offset: 0x80 (128)
};

// 0x50 (80) bytes
struct _WHEA_ERROR_PACKET_V2 {
  ULONG Signature;                                // offset: 0x0 (0)
  ULONG Version;                                  // offset: 0x4 (4)
  ULONG Length;                                   // offset: 0x8 (8)
  union _WHEA_ERROR_PACKET_FLAGS Flags;           // offset: 0xc (12)
  enum _WHEA_ERROR_TYPE ErrorType;                // offset: 0x10 (16)
  enum _WHEA_ERROR_SEVERITY ErrorSeverity;        // offset: 0x14 (20)
  ULONG ErrorSourceId;                            // offset: 0x18 (24)
  enum _WHEA_ERROR_SOURCE_TYPE ErrorSourceType;   // offset: 0x1c (28)
  struct _GUID NotifyType;                        // offset: 0x20 (32)
  ULONGLONG Context;                              // offset: 0x30 (48)
  enum _WHEA_ERROR_PACKET_DATA_FORMAT DataFormat; // offset: 0x38 (56)
  ULONG Reserved1;                                // offset: 0x3c (60)
  ULONG DataOffset;                               // offset: 0x40 (64)
  ULONG DataLength;                               // offset: 0x44 (68)
  ULONG PshedDataOffset;                          // offset: 0x48 (72)
  ULONG PshedDataLength;                          // offset: 0x4c (76)
};

// 0x1c (28) bytes
struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
  UCHAR BankNumber;               // offset: 0x0 (0)
  UCHAR ClearOnInitialization;    // offset: 0x1 (1)
  UCHAR StatusDataFormat;         // offset: 0x2 (2)
  union _XPF_MC_BANK_FLAGS Flags; // offset: 0x3 (3)
  ULONG ControlMsr;               // offset: 0x4 (4)
  ULONG StatusMsr;                // offset: 0x8 (8)
  ULONG AddressMsr;               // offset: 0xc (12)
  ULONG MiscMsr;                  // offset: 0x10 (16)
  ULONGLONG ControlData;          // offset: 0x14 (20)
};

// 0x3a4 (932) bytes
struct _WHEA_XPF_CMC_DESCRIPTOR {
  USHORT Type;                                   // offset: 0x0 (0)
  UCHAR Enabled;                                 // offset: 0x2 (2)
  UCHAR NumberOfBanks;                           // offset: 0x3 (3)
  ULONG Reserved;                                // offset: 0x4 (4)
  struct _WHEA_NOTIFICATION_DESCRIPTOR Notify;   // offset: 0x8 (8)
  struct _WHEA_XPF_MC_BANK_DESCRIPTOR Banks[32]; // offset: 0x24 (36)
};

// 0x50 (80) bytes
struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 {
  USHORT Type;                                 // offset: 0x0 (0)
  UCHAR Reserved;                              // offset: 0x2 (2)
  UCHAR Enabled;                               // offset: 0x3 (3)
  ULONG ErrStatusBlockLength;                  // offset: 0x4 (4)
  ULONG RelatedErrorSourceId;                  // offset: 0x8 (8)
  UCHAR ErrStatusAddressSpaceID;               // offset: 0xc (12)
  UCHAR ErrStatusAddressBitWidth;              // offset: 0xd (13)
  UCHAR ErrStatusAddressBitOffset;             // offset: 0xe (14)
  UCHAR ErrStatusAddressAccessSize;            // offset: 0xf (15)
  union _LARGE_INTEGER ErrStatusAddress;       // offset: 0x10 (16)
  struct _WHEA_NOTIFICATION_DESCRIPTOR Notify; // offset: 0x18 (24)
  UCHAR ReadAckAddressSpaceID;                 // offset: 0x34 (52)
  UCHAR ReadAckAddressBitWidth;                // offset: 0x35 (53)
  UCHAR ReadAckAddressBitOffset;               // offset: 0x36 (54)
  UCHAR ReadAckAddressAccessSize;              // offset: 0x37 (55)
  union _LARGE_INTEGER ReadAckAddress;         // offset: 0x38 (56)
  ULONGLONG ReadAckPreserveMask;               // offset: 0x40 (64)
  ULONGLONG ReadAckWriteMask;                  // offset: 0x48 (72)
};

// 0x398 (920) bytes
struct _WHEA_XPF_MCE_DESCRIPTOR {
  USHORT Type;                                   // offset: 0x0 (0)
  UCHAR Enabled;                                 // offset: 0x2 (2)
  UCHAR NumberOfBanks;                           // offset: 0x3 (3)
  union _XPF_MCE_FLAGS Flags;                    // offset: 0x4 (4)
  ULONGLONG MCG_Capability;                      // offset: 0x8 (8)
  ULONGLONG MCG_GlobalControl;                   // offset: 0x10 (16)
  struct _WHEA_XPF_MC_BANK_DESCRIPTOR Banks[32]; // offset: 0x18 (24)
};

// 0x3cc (972) bytes
struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
  ULONG Length;                        // offset: 0x0 (0)
  ULONG Version;                       // offset: 0x4 (4)
  enum _WHEA_ERROR_SOURCE_TYPE Type;   // offset: 0x8 (8)
  enum _WHEA_ERROR_SOURCE_STATE State; // offset: 0xc (12)
  ULONG MaxRawDataLength;              // offset: 0x10 (16)
  ULONG NumRecordsToPreallocate;       // offset: 0x14 (20)
  ULONG MaxSectionsPerRecord;          // offset: 0x18 (24)
  ULONG ErrorSourceId;                 // offset: 0x1c (28)
  ULONG PlatformErrorSourceId;         // offset: 0x20 (32)
  ULONG Flags;                         // offset: 0x24 (36)
  union {
    struct _WHEA_XPF_MCE_DESCRIPTOR XpfMceDescriptor; // offset: 0x28 (40)
    struct _WHEA_XPF_CMC_DESCRIPTOR XpfCmcDescriptor; // offset: 0x28 (40)
    struct _WHEA_XPF_NMI_DESCRIPTOR XpfNmiDescriptor; // offset: 0x28 (40)
    struct _WHEA_IPF_MCA_DESCRIPTOR IpfMcaDescriptor; // offset: 0x28 (40)
    struct _WHEA_IPF_CMC_DESCRIPTOR IpfCmcDescriptor; // offset: 0x28 (40)
    struct _WHEA_IPF_CPE_DESCRIPTOR IpfCpeDescriptor; // offset: 0x28 (40)
    struct _WHEA_AER_ROOTPORT_DESCRIPTOR
        AerRootportDescriptor; // offset: 0x28 (40)
    struct _WHEA_AER_ENDPOINT_DESCRIPTOR
        AerEndpointDescriptor;                              // offset: 0x28 (40)
    struct _WHEA_AER_BRIDGE_DESCRIPTOR AerBridgeDescriptor; // offset: 0x28 (40)
    struct _WHEA_GENERIC_ERROR_DESCRIPTOR GenErrDescriptor; // offset: 0x28 (40)
    struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2
        GenErrDescriptorV2; // offset: 0x28 (40)
    struct _WHEA_DEVICE_DRIVER_DESCRIPTOR
        DeviceDriverDescriptor; // offset: 0x28 (40)

  } Info; // offset: 0x28 (40)
};

// 0x430 (1072) bytes
struct _WHEAP_ERROR_SOURCE {
  struct _LIST_ENTRY ListEntry;                    // offset: 0x0 (0)
  ULONG FailedAllocations;                         // offset: 0x10 (16)
  ULONG PlatformErrorSourceId;                     // offset: 0x14 (20)
  LONG ErrorCount;                                 // offset: 0x18 (24)
  ULONG RecordCount;                               // offset: 0x1c (28)
  ULONG RecordLength;                              // offset: 0x20 (32)
  ULONG PoolTag;                                   // offset: 0x24 (36)
  enum _WHEA_ERROR_SOURCE_TYPE Type;               // offset: 0x28 (40)
  struct _WHEAP_ERROR_RECORD_WRAPPER *Records;     // offset: 0x30 (48)
  VOID *Context;                                   // offset: 0x38 (56)
  ULONG SectionCount;                              // offset: 0x40 (64)
  ULONG SectionLength;                             // offset: 0x44 (68)
  union _LARGE_INTEGER TickCountAtLastError;       // offset: 0x48 (72)
  ULONG AccumulatedErrors;                         // offset: 0x50 (80)
  ULONG TotalErrors;                               // offset: 0x54 (84)
  UCHAR Deferred;                                  // offset: 0x58 (88)
  volatile LONG Busy;                              // offset: 0x5c (92)
  struct _WHEA_ERROR_SOURCE_DESCRIPTOR Descriptor; // offset: 0x60 (96)
};

// 0xf0 (240) bytes
struct _WHEAP_ERROR_RECORD_WRAPPER {
  struct _LIST_ENTRY WorkEntry;                  // offset: 0x0 (0)
  ULONG Length;                                  // offset: 0x10 (16)
  ULONG ProcessorNumber;                         // offset: 0x14 (20)
  union _WHEAP_ERROR_RECORD_WRAPPER_FLAGS Flags; // offset: 0x18 (24)
  volatile LONG InUse;                           // offset: 0x1c (28)
  struct _WHEAP_ERROR_SOURCE *ErrorSource;       // offset: 0x20 (32)
  struct _WHEA_ERROR_RECORD ErrorRecord;         // offset: 0x28 (40)
};

// 0x98 (152) bytes
struct _EXCEPTION_RECORD64 {
  LONG ExceptionCode;                 // offset: 0x0 (0)
  ULONG ExceptionFlags;               // offset: 0x4 (4)
  ULONGLONG ExceptionRecord;          // offset: 0x8 (8)
  ULONGLONG ExceptionAddress;         // offset: 0x10 (16)
  ULONG NumberParameters;             // offset: 0x18 (24)
  ULONG __unusedAlignment;            // offset: 0x1c (28)
  ULONGLONG ExceptionInformation[15]; // offset: 0x20 (32)
};

// 0xa0 (160) bytes
struct _DBGKM_EXCEPTION64 {
  struct _EXCEPTION_RECORD64 ExceptionRecord; // offset: 0x0 (0)
  ULONG FirstChance;                          // offset: 0x98 (152)
};

// 0x98 (152) bytes
struct _EXCEPTION_RECORD {
  LONG ExceptionCode;                        // offset: 0x0 (0)
  ULONG ExceptionFlags;                      // offset: 0x4 (4)
  struct _EXCEPTION_RECORD *ExceptionRecord; // offset: 0x8 (8)
  VOID *ExceptionAddress;                    // offset: 0x10 (16)
  ULONG NumberParameters;                    // offset: 0x18 (24)
  ULONGLONG ExceptionInformation[15];        // offset: 0x20 (32)
};

// 0x10 (16) bytes
union _KIDTENTRY64 {
  struct {
    USHORT OffsetLow; // offset: 0x0 (0)
    USHORT Selector;  // offset: 0x2 (2)
  };
  USHORT IstIndex : 3;  // offset: 0x4 (4)
  USHORT Reserved0 : 5; // offset: 0x4 (4)
  USHORT Type : 5;      // offset: 0x4 (4)
  USHORT Dpl : 2;       // offset: 0x4 (4)
  struct {
    USHORT Present : 1;  // offset: 0x4 (4)
    USHORT OffsetMiddle; // offset: 0x6 (6)
  };
  struct {
    ULONG OffsetHigh; // offset: 0x8 (8)
    ULONG Reserved1;  // offset: 0xc (12)
  };
  ULONGLONG Alignment; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
  struct _LIST_ENTRY Linkage; // offset: 0x0 (0)
  ULONGLONG Signature;        // offset: 0x10 (16)
};

// 0x38 (56) bytes
struct _SEP_LUID_TO_INDEX_MAP_ENTRY {
  struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 (0)
  LONGLONG ReferenceCount;                        // offset: 0x18 (24)
  ULONGLONG Luid;                                 // offset: 0x20 (32)
  ULONGLONG IndexIntoGlobalSingletonTable;        // offset: 0x28 (40)
  UCHAR MarkedForDeletion;                        // offset: 0x30 (48)
};

// 0x48 (72) bytes
struct _SEP_CACHED_HANDLES_ENTRY {
  struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 (0)
  LONGLONG ReferenceCount;                        // offset: 0x18 (24)
  struct _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR
      EntryDescriptor; // offset: 0x20 (32)
  ULONG HandleCount;   // offset: 0x38 (56)
  VOID **Handles;      // offset: 0x40 (64)
};

// 0x38 (56) bytes
struct _SEP_LOWBOX_NUMBER_ENTRY {
  struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 (0)
  LONGLONG ReferenceCount;                        // offset: 0x18 (24)
  VOID *PackageSid;                               // offset: 0x20 (32)
  ULONG LowboxNumber;                             // offset: 0x28 (40)
  VOID *AtomTable;                                // offset: 0x30 (48)
};

// 0x28 (40) bytes
struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
  union {
    struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 (0)
    struct _LIST_ENTRY *CurEntry;                   // offset: 0x0 (0)
  };
  struct _LIST_ENTRY *ChainHead; // offset: 0x18 (24)
  ULONG BucketIndex;             // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
  struct _LIST_ENTRY *ChainHead;   // offset: 0x0 (0)
  struct _LIST_ENTRY *PrevLinkage; // offset: 0x8 (8)
  ULONGLONG Signature;             // offset: 0x10 (16)
};

// 0x10 (16) bytes
struct _EVENT_DESCRIPTOR {
  USHORT Id;         // offset: 0x0 (0)
  UCHAR Version;     // offset: 0x2 (2)
  UCHAR Channel;     // offset: 0x3 (3)
  UCHAR Level;       // offset: 0x4 (4)
  UCHAR Opcode;      // offset: 0x5 (5)
  USHORT Task;       // offset: 0x6 (6)
  ULONGLONG Keyword; // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _EVENT_HEADER {
  USHORT Size;                              // offset: 0x0 (0)
  USHORT HeaderType;                        // offset: 0x2 (2)
  USHORT Flags;                             // offset: 0x4 (4)
  USHORT EventProperty;                     // offset: 0x6 (6)
  ULONG ThreadId;                           // offset: 0x8 (8)
  ULONG ProcessId;                          // offset: 0xc (12)
  union _LARGE_INTEGER TimeStamp;           // offset: 0x10 (16)
  struct _GUID ProviderId;                  // offset: 0x18 (24)
  struct _EVENT_DESCRIPTOR EventDescriptor; // offset: 0x28 (40)
  union {
    struct {
      ULONG KernelTime; // offset: 0x38 (56)
      ULONG UserTime;   // offset: 0x3c (60)
    };
    ULONGLONG ProcessorTime; // offset: 0x38 (56)
  };
  struct _GUID ActivityId; // offset: 0x40 (64)
};

// 0x70 (112) bytes
struct _EVENT_RECORD {
  struct _EVENT_HEADER EventHeader;                      // offset: 0x0 (0)
  struct _ETW_BUFFER_CONTEXT BufferContext;              // offset: 0x50 (80)
  USHORT ExtendedDataCount;                              // offset: 0x54 (84)
  USHORT UserDataLength;                                 // offset: 0x56 (86)
  struct _EVENT_HEADER_EXTENDED_DATA_ITEM *ExtendedData; // offset: 0x58 (88)
  VOID *UserData;                                        // offset: 0x60 (96)
  VOID *UserContext;                                     // offset: 0x68 (104)
};

// 0x10 (16) bytes
struct _EVENT_DATA_DESCRIPTOR {
  ULONGLONG Ptr; // offset: 0x0 (0)
  ULONG Size;    // offset: 0x8 (8)
  union {
    ULONG Reserved; // offset: 0xc (12)
    struct {
      UCHAR Type;       // offset: 0xc (12)
      UCHAR Reserved1;  // offset: 0xd (13)
      USHORT Reserved2; // offset: 0xe (14)
    };
  };
};

// 0x10 (16) bytes
struct _PO_FX_PERF_STATE {
  ULONGLONG Value; // offset: 0x0 (0)
  VOID *Context;   // offset: 0x8 (8)
};

// 0x14 (20) bytes
struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
  UCHAR Type;             // offset: 0x0 (0)
  UCHAR ShareDisposition; // offset: 0x1 (1)
  USHORT Flags;           // offset: 0x2 (2)
  union {
    struct {
      union _LARGE_INTEGER Start; // offset: 0x0 (0)
      ULONG Length;               // offset: 0x8 (8)
    } Generic;                    // offset: 0x4 (4)
    struct {
      union _LARGE_INTEGER Start; // offset: 0x0 (0)
      ULONG Length;               // offset: 0x8 (8)
    } Port;                       // offset: 0x4 (4)
    struct {
      USHORT Level;       // offset: 0x0 (0)
      USHORT Group;       // offset: 0x2 (2)
      ULONG Vector;       // offset: 0x4 (4)
      ULONGLONG Affinity; // offset: 0x8 (8)
    } Interrupt;          // offset: 0x4 (4)
    struct {
      union {
        struct {
          USHORT Group;        // offset: 0x0 (0)
          USHORT MessageCount; // offset: 0x2 (2)
          ULONG Vector;        // offset: 0x4 (4)
          ULONGLONG Affinity;  // offset: 0x8 (8)
        } Raw;                 // offset: 0x0 (0)
        struct {
          USHORT Level;       // offset: 0x0 (0)
          USHORT Group;       // offset: 0x2 (2)
          ULONG Vector;       // offset: 0x4 (4)
          ULONGLONG Affinity; // offset: 0x8 (8)
        } Translated;         // offset: 0x0 (0)
      };
    } MessageInterrupt; // offset: 0x4 (4)
    struct {
      union _LARGE_INTEGER Start; // offset: 0x0 (0)
      ULONG Length;               // offset: 0x8 (8)
    } Memory;                     // offset: 0x4 (4)
    struct {
      ULONG Channel;   // offset: 0x0 (0)
      ULONG Port;      // offset: 0x4 (4)
      ULONG Reserved1; // offset: 0x8 (8)
    } Dma;             // offset: 0x4 (4)
    struct {
      ULONG Channel;       // offset: 0x0 (0)
      ULONG RequestLine;   // offset: 0x4 (4)
      UCHAR TransferWidth; // offset: 0x8 (8)
      UCHAR Reserved1;     // offset: 0x9 (9)
      UCHAR Reserved2;     // offset: 0xa (10)
      UCHAR Reserved3;     // offset: 0xb (11)
    } DmaV3;               // offset: 0x4 (4)
    struct {
      ULONG Data[3]; // offset: 0x0 (0)
    } DevicePrivate; // offset: 0x4 (4)
    struct {
      ULONG Start;    // offset: 0x0 (0)
      ULONG Length;   // offset: 0x4 (4)
      ULONG Reserved; // offset: 0x8 (8)
    } BusNumber;      // offset: 0x4 (4)
    struct {
      ULONG DataSize;     // offset: 0x0 (0)
      ULONG Reserved1;    // offset: 0x4 (4)
      ULONG Reserved2;    // offset: 0x8 (8)
    } DeviceSpecificData; // offset: 0x4 (4)
    struct {
      union _LARGE_INTEGER Start; // offset: 0x0 (0)
      ULONG Length40;             // offset: 0x8 (8)
    } Memory40;                   // offset: 0x4 (4)
    struct {
      union _LARGE_INTEGER Start; // offset: 0x0 (0)
      ULONG Length48;             // offset: 0x8 (8)
    } Memory48;                   // offset: 0x4 (4)
    struct {
      union _LARGE_INTEGER Start; // offset: 0x0 (0)
      ULONG Length64;             // offset: 0x8 (8)
    } Memory64;                   // offset: 0x4 (4)
    struct {
      UCHAR Class;      // offset: 0x0 (0)
      UCHAR Type;       // offset: 0x1 (1)
      UCHAR Reserved1;  // offset: 0x2 (2)
      UCHAR Reserved2;  // offset: 0x3 (3)
      ULONG IdLowPart;  // offset: 0x4 (4)
      ULONG IdHighPart; // offset: 0x8 (8)
    } Connection;       // offset: 0x4 (4)

  } u; // offset: 0x4 (4)
};

// 0x18 (24) bytes
struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList;                  // offset: 0x0 (0)
  ULONG AllocateFromCount;                              // offset: 0x8 (8)
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *AllocateFrom; // offset: 0x10 (16)
};

// 0x18 (24) bytes
struct _ARBITER_TEST_ALLOCATION_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList;                  // offset: 0x0 (0)
  ULONG AllocateFromCount;                              // offset: 0x8 (8)
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *AllocateFrom; // offset: 0x10 (16)
};

// 0x1c (28) bytes
struct _CM_PARTIAL_RESOURCE_LIST {
  USHORT Version;  // offset: 0x0 (0)
  USHORT Revision; // offset: 0x2 (2)
  ULONG Count;     // offset: 0x4 (4)
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR
      PartialDescriptors[1]; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
  struct _CM_PARTIAL_RESOURCE_LIST **AllocatedResources; // offset: 0x0 (0)
};

// 0x24 (36) bytes
struct _CM_FULL_RESOURCE_DESCRIPTOR {
  enum _INTERFACE_TYPE InterfaceType;                   // offset: 0x0 (0)
  ULONG BusNumber;                                      // offset: 0x4 (4)
  struct _CM_PARTIAL_RESOURCE_LIST PartialResourceList; // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _CM_RESOURCE_LIST {
  ULONG Count;                                 // offset: 0x0 (0)
  struct _CM_FULL_RESOURCE_DESCRIPTOR List[1]; // offset: 0x4 (4)
};

// 0x30 (48) bytes
struct _PO_FX_COMPONENT_PERF_SET {
  struct _UNICODE_STRING Name;      // offset: 0x0 (0)
  ULONGLONG Flags;                  // offset: 0x10 (16)
  enum _PO_FX_PERF_STATE_UNIT Unit; // offset: 0x18 (24)
  enum _PO_FX_PERF_STATE_TYPE Type; // offset: 0x1c (28)
  union {
    struct {
      ULONG Count;                      // offset: 0x0 (0)
      struct _PO_FX_PERF_STATE *States; // offset: 0x8 (8)
    } Discrete;                         // offset: 0x20 (32)
    struct {
      ULONGLONG Minimum; // offset: 0x0 (0)
      ULONGLONG Maximum; // offset: 0x8 (8)
    } Range;             // offset: 0x20 (32)
  };
};

// 0x20 (32) bytes
struct _IO_RESOURCE_DESCRIPTOR {
  UCHAR Option;           // offset: 0x0 (0)
  UCHAR Type;             // offset: 0x1 (1)
  UCHAR ShareDisposition; // offset: 0x2 (2)
  UCHAR Spare1;           // offset: 0x3 (3)
  USHORT Flags;           // offset: 0x4 (4)
  USHORT Spare2;          // offset: 0x6 (6)
  union {
    struct {
      ULONG Length;                        // offset: 0x0 (0)
      ULONG Alignment;                     // offset: 0x4 (4)
      union _LARGE_INTEGER MinimumAddress; // offset: 0x8 (8)
      union _LARGE_INTEGER MaximumAddress; // offset: 0x10 (16)
    } Port;                                // offset: 0x8 (8)
    struct {
      ULONG Length;                        // offset: 0x0 (0)
      ULONG Alignment;                     // offset: 0x4 (4)
      union _LARGE_INTEGER MinimumAddress; // offset: 0x8 (8)
      union _LARGE_INTEGER MaximumAddress; // offset: 0x10 (16)
    } Memory;                              // offset: 0x8 (8)
    struct {
      ULONG MinimumVector;               // offset: 0x0 (0)
      ULONG MaximumVector;               // offset: 0x4 (4)
      USHORT AffinityPolicy;             // offset: 0x8 (8)
      USHORT Group;                      // offset: 0xa (10)
      enum _IRQ_PRIORITY PriorityPolicy; // offset: 0xc (12)
      ULONGLONG TargetedProcessors;      // offset: 0x10 (16)
    } Interrupt;                         // offset: 0x8 (8)
    struct {
      ULONG MinimumChannel; // offset: 0x0 (0)
      ULONG MaximumChannel; // offset: 0x4 (4)
    } Dma;                  // offset: 0x8 (8)
    struct {
      ULONG RequestLine;   // offset: 0x0 (0)
      ULONG Reserved;      // offset: 0x4 (4)
      ULONG Channel;       // offset: 0x8 (8)
      ULONG TransferWidth; // offset: 0xc (12)
    } DmaV3;               // offset: 0x8 (8)
    struct {
      ULONG Length;                        // offset: 0x0 (0)
      ULONG Alignment;                     // offset: 0x4 (4)
      union _LARGE_INTEGER MinimumAddress; // offset: 0x8 (8)
      union _LARGE_INTEGER MaximumAddress; // offset: 0x10 (16)
    } Generic;                             // offset: 0x8 (8)
    struct {
      ULONG Data[3]; // offset: 0x0 (0)
    } DevicePrivate; // offset: 0x8 (8)
    struct {
      ULONG Length;       // offset: 0x0 (0)
      ULONG MinBusNumber; // offset: 0x4 (4)
      ULONG MaxBusNumber; // offset: 0x8 (8)
      ULONG Reserved;     // offset: 0xc (12)
    } BusNumber;          // offset: 0x8 (8)
    struct {
      ULONG Priority;  // offset: 0x0 (0)
      ULONG Reserved1; // offset: 0x4 (4)
      ULONG Reserved2; // offset: 0x8 (8)
    } ConfigData;      // offset: 0x8 (8)
    struct {
      ULONG Length40;                      // offset: 0x0 (0)
      ULONG Alignment40;                   // offset: 0x4 (4)
      union _LARGE_INTEGER MinimumAddress; // offset: 0x8 (8)
      union _LARGE_INTEGER MaximumAddress; // offset: 0x10 (16)
    } Memory40;                            // offset: 0x8 (8)
    struct {
      ULONG Length48;                      // offset: 0x0 (0)
      ULONG Alignment48;                   // offset: 0x4 (4)
      union _LARGE_INTEGER MinimumAddress; // offset: 0x8 (8)
      union _LARGE_INTEGER MaximumAddress; // offset: 0x10 (16)
    } Memory48;                            // offset: 0x8 (8)
    struct {
      ULONG Length64;                      // offset: 0x0 (0)
      ULONG Alignment64;                   // offset: 0x4 (4)
      union _LARGE_INTEGER MinimumAddress; // offset: 0x8 (8)
      union _LARGE_INTEGER MaximumAddress; // offset: 0x10 (16)
    } Memory64;                            // offset: 0x8 (8)
    struct {
      UCHAR Class;      // offset: 0x0 (0)
      UCHAR Type;       // offset: 0x1 (1)
      UCHAR Reserved1;  // offset: 0x2 (2)
      UCHAR Reserved2;  // offset: 0x3 (3)
      ULONG IdLowPart;  // offset: 0x4 (4)
      ULONG IdHighPart; // offset: 0x8 (8)
    } Connection;       // offset: 0x8 (8)

  } u; // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _IO_RESOURCE_LIST {
  USHORT Version;                                // offset: 0x0 (0)
  USHORT Revision;                               // offset: 0x2 (2)
  ULONG Count;                                   // offset: 0x4 (4)
  struct _IO_RESOURCE_DESCRIPTOR Descriptors[1]; // offset: 0x8 (8)
};

// 0x48 (72) bytes
struct _IO_RESOURCE_REQUIREMENTS_LIST {
  ULONG ListSize;                     // offset: 0x0 (0)
  enum _INTERFACE_TYPE InterfaceType; // offset: 0x4 (4)
  ULONG BusNumber;                    // offset: 0x8 (8)
  ULONG SlotNumber;                   // offset: 0xc (12)
  ULONG Reserved[3];                  // offset: 0x10 (16)
  ULONG AlternativeLists;             // offset: 0x1c (28)
  struct _IO_RESOURCE_LIST List[1];   // offset: 0x20 (32)
};

// 0x40 (64) bytes
struct _PNP_RESOURCE_REQUEST {
  struct _DEVICE_OBJECT *PhysicalDevice;       // offset: 0x0 (0)
  ULONG Flags;                                 // offset: 0x8 (8)
  enum _ARBITER_REQUEST_SOURCE AllocationType; // offset: 0xc (12)
  ULONG Priority;                              // offset: 0x10 (16)
  ULONG Position;                              // offset: 0x14 (20)
  struct _IO_RESOURCE_REQUIREMENTS_LIST
      *ResourceRequirements;                              // offset: 0x18 (24)
  VOID *ReqList;                                          // offset: 0x20 (32)
  struct _CM_RESOURCE_LIST *ResourceAssignment;           // offset: 0x28 (40)
  struct _CM_RESOURCE_LIST *TranslatedResourceAssignment; // offset: 0x30 (48)
  LONG Status;                                            // offset: 0x38 (56)
};

// 0x20 (32) bytes
struct _ARBITER_QUERY_CONFLICT_PARAMETERS {
  struct _DEVICE_OBJECT *PhysicalDeviceObject;         // offset: 0x0 (0)
  struct _IO_RESOURCE_DESCRIPTOR *ConflictingResource; // offset: 0x8 (8)
  ULONG *ConflictCount;                                // offset: 0x10 (16)
  struct _ARBITER_CONFLICT_INFO **Conflicts;           // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _ARBITER_PARAMETERS {
  union {
    struct _ARBITER_TEST_ALLOCATION_PARAMETERS
        TestAllocation; // offset: 0x0 (0)
    struct _ARBITER_RETEST_ALLOCATION_PARAMETERS
        RetestAllocation; // offset: 0x0 (0)
    struct _ARBITER_BOOT_ALLOCATION_PARAMETERS
        BootAllocation; // offset: 0x0 (0)
    struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS
        QueryAllocatedResources;                             // offset: 0x0 (0)
    struct _ARBITER_QUERY_CONFLICT_PARAMETERS QueryConflict; // offset: 0x0 (0)
    struct _ARBITER_QUERY_ARBITRATE_PARAMETERS
        QueryArbitrate;                                  // offset: 0x0 (0)
    struct _ARBITER_ADD_RESERVED_PARAMETERS AddReserved; // offset: 0x0 (0)

  } Parameters; // offset: 0x0 (0)
};

// 0x30 (48) bytes
struct _ARBITER_INTERFACE {
  USHORT Size;                              // offset: 0x0 (0)
  USHORT Version;                           // offset: 0x2 (2)
  VOID *Context;                            // offset: 0x8 (8)
  VOID (*InterfaceReference)(VOID *arg1);   // offset: 0x10 (16)
  VOID (*InterfaceDereference)(VOID *arg1); // offset: 0x18 (24)
  LONG (*ArbiterHandler)
  (VOID *arg1, enum _ARBITER_ACTION arg2,
   struct _ARBITER_PARAMETERS *arg3); // offset: 0x20 (32)
  ULONG Flags;                        // offset: 0x28 (40)
};

// 0x70 (112) bytes
struct _PI_RESOURCE_ARBITER_ENTRY {
  struct _LIST_ENTRY DeviceArbiterList;        // offset: 0x0 (0)
  UCHAR ResourceType;                          // offset: 0x10 (16)
  struct _ARBITER_INTERFACE *ArbiterInterface; // offset: 0x18 (24)
  struct _DEVICE_NODE *DeviceNode;             // offset: 0x20 (32)
  struct _LIST_ENTRY ResourceList;             // offset: 0x28 (40)
  struct _LIST_ENTRY BestResourceList;         // offset: 0x38 (56)
  struct _LIST_ENTRY BestConfig;               // offset: 0x48 (72)
  struct _LIST_ENTRY ActiveArbiterList;        // offset: 0x58 (88)
  UCHAR State;                                 // offset: 0x68 (104)
  UCHAR ResourcesChanged;                      // offset: 0x69 (105)
};

// 0x40 (64) bytes
struct _ARBITER_ALTERNATIVE {
  ULONGLONG Minimum;                          // offset: 0x0 (0)
  ULONGLONG Maximum;                          // offset: 0x8 (8)
  ULONGLONG Length;                           // offset: 0x10 (16)
  ULONGLONG Alignment;                        // offset: 0x18 (24)
  LONG Priority;                              // offset: 0x20 (32)
  ULONG Flags;                                // offset: 0x24 (36)
  struct _IO_RESOURCE_DESCRIPTOR *Descriptor; // offset: 0x28 (40)
  ULONG Reserved[3];                          // offset: 0x30 (48)
};

// 0x60 (96) bytes
struct _ARBITER_LIST_ENTRY {
  struct _LIST_ENTRY ListEntry;                        // offset: 0x0 (0)
  ULONG AlternativeCount;                              // offset: 0x10 (16)
  struct _IO_RESOURCE_DESCRIPTOR *Alternatives;        // offset: 0x18 (24)
  struct _DEVICE_OBJECT *PhysicalDeviceObject;         // offset: 0x20 (32)
  enum _ARBITER_REQUEST_SOURCE RequestSource;          // offset: 0x28 (40)
  ULONG Flags;                                         // offset: 0x2c (44)
  LONGLONG WorkSpace;                                  // offset: 0x30 (48)
  enum _INTERFACE_TYPE InterfaceType;                  // offset: 0x38 (56)
  ULONG SlotNumber;                                    // offset: 0x3c (60)
  ULONG BusNumber;                                     // offset: 0x40 (64)
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *Assignment;  // offset: 0x48 (72)
  struct _IO_RESOURCE_DESCRIPTOR *SelectedAlternative; // offset: 0x50 (80)
  enum _ARBITER_RESULT Result;                         // offset: 0x58 (88)
};

// 0x50 (80) bytes
struct _ARBITER_ALLOCATION_STATE {
  ULONGLONG Start;                                 // offset: 0x0 (0)
  ULONGLONG End;                                   // offset: 0x8 (8)
  ULONGLONG CurrentMinimum;                        // offset: 0x10 (16)
  ULONGLONG CurrentMaximum;                        // offset: 0x18 (24)
  struct _ARBITER_LIST_ENTRY *Entry;               // offset: 0x20 (32)
  struct _ARBITER_ALTERNATIVE *CurrentAlternative; // offset: 0x28 (40)
  ULONG AlternativeCount;                          // offset: 0x30 (48)
  struct _ARBITER_ALTERNATIVE *Alternatives;       // offset: 0x38 (56)
  USHORT Flags;                                    // offset: 0x40 (64)
  UCHAR RangeAttributes;                           // offset: 0x42 (66)
  UCHAR RangeAvailableAttributes;                  // offset: 0x43 (67)
  ULONGLONG WorkSpace;                             // offset: 0x48 (72)
};

// 0x18 (24) bytes
struct _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT {
  UCHAR ResourceType;                               // offset: 0x0 (0)
  ULONG AlternativeCount;                           // offset: 0x4 (4)
  struct _IO_RESOURCE_DESCRIPTOR *ResourceRequests; // offset: 0x8 (8)
  VOID *ArbiterInstance;                            // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _PNP_WATCHDOG {
  ULONGLONG WatchdogStart;                     // offset: 0x0 (0)
  struct _WDT_HANDLE *WatchdogTimer;           // offset: 0x8 (8)
  enum _PNP_WATCHDOG_TYPE WatchdogContextType; // offset: 0x10 (16)
  VOID *WatchdogContext;                       // offset: 0x18 (24)
  UCHAR TriggerEventLogged;                    // offset: 0x20 (32)
};

// 0x48 (72) bytes
struct _PNP_DEVICE_COMPLETION_REQUEST {
  struct _LIST_ENTRY ListEntry;            // offset: 0x0 (0)
  struct _DEVICE_NODE *DeviceNode;         // offset: 0x10 (16)
  VOID *Context;                           // offset: 0x18 (24)
  enum _PNP_DEVNODE_STATE CompletionState; // offset: 0x20 (32)
  ULONG IrpPended;                         // offset: 0x24 (36)
  LONG Status;                             // offset: 0x28 (40)
  VOID *Information;                       // offset: 0x30 (48)
  LONG ReferenceCount;                     // offset: 0x38 (56)
  struct _PNP_WATCHDOG *Watchdog;          // offset: 0x40 (64)
};

// 0xc0 (192) bytes
struct _PNP_DEVICE_EVENT_ENTRY {
  struct _LIST_ENTRY ListEntry;           // offset: 0x0 (0)
  ULONG Argument;                         // offset: 0x10 (16)
  LONG ArgumentStatus;                    // offset: 0x14 (20)
  struct _KEVENT *CallerEvent;            // offset: 0x18 (24)
  VOID (*Callback)(VOID *arg1);           // offset: 0x20 (32)
  VOID *Context;                          // offset: 0x28 (40)
  enum _PNP_VETO_TYPE *VetoType;          // offset: 0x30 (48)
  struct _UNICODE_STRING *VetoName;       // offset: 0x38 (56)
  ULONG RefCount;                         // offset: 0x40 (64)
  ULONG Lock;                             // offset: 0x44 (68)
  UCHAR Cancel;                           // offset: 0x48 (72)
  struct _PNP_DEVICE_EVENT_ENTRY *Parent; // offset: 0x50 (80)
  struct _GUID ActivityId;                // offset: 0x58 (88)
  struct _PNP_WATCHDOG *Watchdog;         // offset: 0x68 (104)
  struct _PLUGPLAY_EVENT_BLOCK Data;      // offset: 0x70 (112)
};

// 0x18 (24) bytes
struct _ETW_HW_TRACE_EXT_INTERFACE {
  LONG (*StartProcessorTraceOnEachCore)
  (ULONGLONG arg1, VOID **arg2);                    // offset: 0x0 (0)
  LONG (*StopProcessorTraceOnEachCore)(VOID *arg1); // offset: 0x8 (8)
  LONG (*LogProcessorTraceOnCurrentCore)
  (VOID *arg1, VOID *arg2); // offset: 0x10 (16)
};

// 0x20 (32) bytes
struct _POP_FX_PERF_SET {
  struct _PO_FX_COMPONENT_PERF_SET *PerfSet; // offset: 0x0 (0)
  ULONGLONG CurrentPerf;                     // offset: 0x8 (8)
  ULONGLONG CurrentPerfStamp;                // offset: 0x10 (16)
  UCHAR CurrentPerfNominal;                  // offset: 0x18 (24)
};

// 0x10 (16) bytes
struct _PO_FX_PERF_STATE_CHANGE {
  ULONG Set; // offset: 0x0 (0)
  union {
    ULONG StateIndex;     // offset: 0x8 (8)
    ULONGLONG StateValue; // offset: 0x8 (8)
  };
};

// 0x28 (40) bytes
struct _POP_COMPONENT_POWER_PROFILE {
  struct _GUID ComponentGuid;                // offset: 0x0 (0)
  struct _POP_DEVICE_POWER_PROFILE *Device;  // offset: 0x10 (16)
  ULONGLONG FxCount;                         // offset: 0x18 (24)
  struct _PO_POWER_PLANE_PROFILE FxPower[1]; // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _POP_FX_IDLE_STATE {
  ULONGLONG TransitionLatency;    // offset: 0x0 (0)
  ULONGLONG ResidencyRequirement; // offset: 0x8 (8)
  ULONG NominalPower;             // offset: 0x10 (16)
};

// 0x40 (64) bytes
struct _PPM_VETO_ENTRY {
  struct _LIST_ENTRY Link;      // offset: 0x0 (0)
  ULONG VetoReason;             // offset: 0x10 (16)
  ULONG ReferenceCount;         // offset: 0x14 (20)
  ULONGLONG HitCount;           // offset: 0x18 (24)
  ULONGLONG LastActivationTime; // offset: 0x20 (32)
  ULONGLONG TotalActiveTime;    // offset: 0x28 (40)
  ULONGLONG CsActivationTime;   // offset: 0x30 (48)
  ULONGLONG CsActiveTime;       // offset: 0x38 (56)
};

// 0x28 (40) bytes
struct _PPM_VETO_ACCOUNTING {
  volatile LONG VetoPresent;                    // offset: 0x0 (0)
  struct _LIST_ENTRY VetoListHead;              // offset: 0x8 (8)
  UCHAR CsAccountingBlocks;                     // offset: 0x18 (24)
  UCHAR BlocksDrips;                            // offset: 0x19 (25)
  ULONG PreallocatedVetoCount;                  // offset: 0x1c (28)
  struct _PPM_VETO_ENTRY *PreallocatedVetoList; // offset: 0x20 (32)
};

// 0x48 (72) bytes
struct _IO_STACK_LOCATION {
  UCHAR MajorFunction; // offset: 0x0 (0)
  UCHAR MinorFunction; // offset: 0x1 (1)
  UCHAR Flags;         // offset: 0x2 (2)
  UCHAR Control;       // offset: 0x3 (3)
  union {
    struct {
      struct _IO_SECURITY_CONTEXT *SecurityContext; // offset: 0x0 (0)
      ULONG Options;                                // offset: 0x8 (8)
      USHORT FileAttributes;                        // offset: 0x10 (16)
      USHORT ShareAccess;                           // offset: 0x12 (18)
      ULONG EaLength;                               // offset: 0x18 (24)
    } Create;                                       // offset: 0x8 (8)
    struct {
      struct _IO_SECURITY_CONTEXT *SecurityContext;     // offset: 0x0 (0)
      ULONG Options;                                    // offset: 0x8 (8)
      USHORT Reserved;                                  // offset: 0x10 (16)
      USHORT ShareAccess;                               // offset: 0x12 (18)
      struct _NAMED_PIPE_CREATE_PARAMETERS *Parameters; // offset: 0x18 (24)
    } CreatePipe;                                       // offset: 0x8 (8)
    struct {
      struct _IO_SECURITY_CONTEXT *SecurityContext;   // offset: 0x0 (0)
      ULONG Options;                                  // offset: 0x8 (8)
      USHORT Reserved;                                // offset: 0x10 (16)
      USHORT ShareAccess;                             // offset: 0x12 (18)
      struct _MAILSLOT_CREATE_PARAMETERS *Parameters; // offset: 0x18 (24)
    } CreateMailslot;                                 // offset: 0x8 (8)
    struct {
      ULONG Length;                    // offset: 0x0 (0)
      ULONG Key;                       // offset: 0x8 (8)
      ULONG Flags;                     // offset: 0xc (12)
      union _LARGE_INTEGER ByteOffset; // offset: 0x10 (16)
    } Read;                            // offset: 0x8 (8)
    struct {
      ULONG Length;                    // offset: 0x0 (0)
      ULONG Key;                       // offset: 0x8 (8)
      ULONG Flags;                     // offset: 0xc (12)
      union _LARGE_INTEGER ByteOffset; // offset: 0x10 (16)
    } Write;                           // offset: 0x8 (8)
    struct {
      ULONG Length;                                      // offset: 0x0 (0)
      struct _UNICODE_STRING *FileName;                  // offset: 0x8 (8)
      enum _FILE_INFORMATION_CLASS FileInformationClass; // offset: 0x10 (16)
      ULONG FileIndex;                                   // offset: 0x18 (24)
    } QueryDirectory;                                    // offset: 0x8 (8)
    struct {
      ULONG Length;           // offset: 0x0 (0)
      ULONG CompletionFilter; // offset: 0x8 (8)
    } NotifyDirectory;        // offset: 0x8 (8)
    struct {
      ULONG Length;           // offset: 0x0 (0)
      ULONG CompletionFilter; // offset: 0x8 (8)
      enum _DIRECTORY_NOTIFY_INFORMATION_CLASS
          DirectoryNotifyInformationClass; // offset: 0x10 (16)
    } NotifyDirectoryEx;                   // offset: 0x8 (8)
    struct {
      ULONG Length;                                      // offset: 0x0 (0)
      enum _FILE_INFORMATION_CLASS FileInformationClass; // offset: 0x8 (8)
    } QueryFile;                                         // offset: 0x8 (8)
    struct {
      ULONG Length;                                      // offset: 0x0 (0)
      enum _FILE_INFORMATION_CLASS FileInformationClass; // offset: 0x8 (8)
      struct _FILE_OBJECT *FileObject;                   // offset: 0x10 (16)
      union {
        struct {
          UCHAR ReplaceIfExists; // offset: 0x18 (24)
          UCHAR AdvanceOnly;     // offset: 0x19 (25)
        };
        ULONG ClusterCount; // offset: 0x18 (24)
        VOID *DeleteHandle; // offset: 0x18 (24)
      };
    } SetFile; // offset: 0x8 (8)
    struct {
      ULONG Length;       // offset: 0x0 (0)
      VOID *EaList;       // offset: 0x8 (8)
      ULONG EaListLength; // offset: 0x10 (16)
      ULONG EaIndex;      // offset: 0x18 (24)
    } QueryEa;            // offset: 0x8 (8)
    struct {
      ULONG Length; // offset: 0x0 (0)
    } SetEa;        // offset: 0x8 (8)
    struct {
      ULONG Length;                         // offset: 0x0 (0)
      enum _FSINFOCLASS FsInformationClass; // offset: 0x8 (8)
    } QueryVolume;                          // offset: 0x8 (8)
    struct {
      ULONG Length;                         // offset: 0x0 (0)
      enum _FSINFOCLASS FsInformationClass; // offset: 0x8 (8)
    } SetVolume;                            // offset: 0x8 (8)
    struct {
      ULONG OutputBufferLength; // offset: 0x0 (0)
      ULONG InputBufferLength;  // offset: 0x8 (8)
      ULONG FsControlCode;      // offset: 0x10 (16)
      VOID *Type3InputBuffer;   // offset: 0x18 (24)
    } FileSystemControl;        // offset: 0x8 (8)
    struct {
      union _LARGE_INTEGER *Length;    // offset: 0x0 (0)
      ULONG Key;                       // offset: 0x8 (8)
      union _LARGE_INTEGER ByteOffset; // offset: 0x10 (16)
    } LockControl;                     // offset: 0x8 (8)
    struct {
      ULONG OutputBufferLength; // offset: 0x0 (0)
      ULONG InputBufferLength;  // offset: 0x8 (8)
      ULONG IoControlCode;      // offset: 0x10 (16)
      VOID *Type3InputBuffer;   // offset: 0x18 (24)
    } DeviceIoControl;          // offset: 0x8 (8)
    struct {
      ULONG SecurityInformation; // offset: 0x0 (0)
      ULONG Length;              // offset: 0x8 (8)
    } QuerySecurity;             // offset: 0x8 (8)
    struct {
      ULONG SecurityInformation; // offset: 0x0 (0)
      VOID *SecurityDescriptor;  // offset: 0x8 (8)
    } SetSecurity;               // offset: 0x8 (8)
    struct {
      struct _VPB *Vpb;                    // offset: 0x0 (0)
      struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 (8)
    } MountVolume;                         // offset: 0x8 (8)
    struct {
      struct _VPB *Vpb;                    // offset: 0x0 (0)
      struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 (8)
    } VerifyVolume;                        // offset: 0x8 (8)
    struct {
      struct _SCSI_REQUEST_BLOCK *Srb; // offset: 0x0 (0)
    } Scsi;                            // offset: 0x8 (8)
    struct {
      ULONG Length;                                // offset: 0x0 (0)
      VOID *StartSid;                              // offset: 0x8 (8)
      struct _FILE_GET_QUOTA_INFORMATION *SidList; // offset: 0x10 (16)
      ULONG SidListLength;                         // offset: 0x18 (24)
    } QueryQuota;                                  // offset: 0x8 (8)
    struct {
      ULONG Length; // offset: 0x0 (0)
    } SetQuota;     // offset: 0x8 (8)
    struct {
      enum _DEVICE_RELATION_TYPE Type; // offset: 0x0 (0)
    } QueryDeviceRelations;            // offset: 0x8 (8)
    struct {
      struct _GUID *InterfaceType;  // offset: 0x0 (0)
      USHORT Size;                  // offset: 0x8 (8)
      USHORT Version;               // offset: 0xa (10)
      struct _INTERFACE *Interface; // offset: 0x10 (16)
      VOID *InterfaceSpecificData;  // offset: 0x18 (24)
    } QueryInterface;               // offset: 0x8 (8)
    struct {
      struct _DEVICE_CAPABILITIES *Capabilities; // offset: 0x0 (0)
    } DeviceCapabilities;                        // offset: 0x8 (8)
    struct {
      struct _IO_RESOURCE_REQUIREMENTS_LIST
          *IoResourceRequirementList; // offset: 0x0 (0)
    } FilterResourceRequirements;     // offset: 0x8 (8)
    struct {
      ULONG WhichSpace; // offset: 0x0 (0)
      VOID *Buffer;     // offset: 0x8 (8)
      ULONG Offset;     // offset: 0x10 (16)
      ULONG Length;     // offset: 0x18 (24)
    } ReadWriteConfig;  // offset: 0x8 (8)
    struct {
      UCHAR Lock; // offset: 0x0 (0)
    } SetLock;    // offset: 0x8 (8)
    struct {
      enum BUS_QUERY_ID_TYPE IdType; // offset: 0x0 (0)
    } QueryId;                       // offset: 0x8 (8)
    struct {
      enum DEVICE_TEXT_TYPE DeviceTextType; // offset: 0x0 (0)
      ULONG LocaleId;                       // offset: 0x8 (8)
    } QueryDeviceText;                      // offset: 0x8 (8)
    struct {
      UCHAR InPath;                              // offset: 0x0 (0)
      UCHAR Reserved[3];                         // offset: 0x1 (1)
      enum _DEVICE_USAGE_NOTIFICATION_TYPE Type; // offset: 0x8 (8)
    } UsageNotification;                         // offset: 0x8 (8)
    struct {
      enum _SYSTEM_POWER_STATE PowerState; // offset: 0x0 (0)
    } WaitWake;                            // offset: 0x8 (8)
    struct {
      struct _POWER_SEQUENCE *PowerSequence; // offset: 0x0 (0)
    } PowerSequence;                         // offset: 0x8 (8)
    struct {
      union {
        ULONG SystemContext; // offset: 0x0 (0)
        struct _SYSTEM_POWER_STATE_CONTEXT
            SystemPowerStateContext; // offset: 0x0 (0)
      };
      enum _POWER_STATE_TYPE Type;    // offset: 0x8 (8)
      union _POWER_STATE State;       // offset: 0x10 (16)
      enum POWER_ACTION ShutdownType; // offset: 0x18 (24)
    } Power;                          // offset: 0x8 (8)
    struct {
      struct _CM_RESOURCE_LIST *AllocatedResources;           // offset: 0x0 (0)
      struct _CM_RESOURCE_LIST *AllocatedResourcesTranslated; // offset: 0x8 (8)
    } StartDevice;                                            // offset: 0x8 (8)
    struct {
      ULONGLONG ProviderId; // offset: 0x0 (0)
      VOID *DataPath;       // offset: 0x8 (8)
      ULONG BufferSize;     // offset: 0x10 (16)
      VOID *Buffer;         // offset: 0x18 (24)
    } WMI;                  // offset: 0x8 (8)
    struct {
      VOID *Argument1; // offset: 0x0 (0)
      VOID *Argument2; // offset: 0x8 (8)
      VOID *Argument3; // offset: 0x10 (16)
      VOID *Argument4; // offset: 0x18 (24)
    } Others;          // offset: 0x8 (8)

  } Parameters;                        // offset: 0x8 (8)
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x28 (40)
  struct _FILE_OBJECT *FileObject;     // offset: 0x30 (48)
  LONG (*CompletionRoutine)
  (struct _DEVICE_OBJECT *arg1, struct _IRP *arg2,
   VOID *arg3);  // offset: 0x38 (56)
  VOID *Context; // offset: 0x40 (64)
};

// 0x40 (64) bytes
struct _POP_POWER_PLANE {
  struct _UNICODE_STRING PowerPlaneId;                   // offset: 0x0 (0)
  ULONGLONG Lock;                                        // offset: 0x10 (16)
  UCHAR OldIrql;                                         // offset: 0x18 (24)
  volatile LONG DevicePowerMw;                           // offset: 0x1c (28)
  VOID *PmaxHandle;                                      // offset: 0x20 (32)
  VOID (*NotifyDevicePowerDraw)(VOID *arg1, ULONG arg2); // offset: 0x28 (40)
  ULONGLONG DeviceCount;                                 // offset: 0x30 (48)
  struct _POP_DEVICE_POWER_PROFILE **Devices;            // offset: 0x38 (56)
};

// 0x28 (40) bytes
struct _PEP_WORK_ACPI_EVALUATE_CONTROL_METHOD_COMPLETE {
  struct POHANDLE__ *DeviceHandle;                  // offset: 0x0 (0)
  ULONG CompletionFlags;                            // offset: 0x8 (8)
  LONG MethodStatus;                                // offset: 0xc (12)
  VOID *CompletionContext;                          // offset: 0x10 (16)
  ULONGLONG OutputArgumentSize;                     // offset: 0x18 (24)
  struct _ACPI_METHOD_ARGUMENT_V1 *OutputArguments; // offset: 0x20 (32)
};

// 0x38 (56) bytes
struct _PEP_WORK_POWER_CONTROL {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 (0)
  struct _GUID *PowerControlCode;  // offset: 0x8 (8)
  VOID *RequestContext;            // offset: 0x10 (16)
  VOID *InBuffer;                  // offset: 0x18 (24)
  ULONGLONG InBufferSize;          // offset: 0x20 (32)
  VOID *OutBuffer;                 // offset: 0x28 (40)
  ULONGLONG OutBufferSize;         // offset: 0x30 (48)
};

// 0x40 (64) bytes
struct _PEP_WORK_INFORMATION {
  enum _PEP_WORK_TYPE WorkType; // offset: 0x0 (0)
  union {
    struct _PEP_WORK_ACTIVE_COMPLETE ActiveComplete;        // offset: 0x8 (8)
    struct _PEP_WORK_IDLE_STATE IdleState;                  // offset: 0x8 (8)
    struct _PEP_WORK_DEVICE_POWER DevicePower;              // offset: 0x8 (8)
    struct _PEP_WORK_POWER_CONTROL PowerControl;            // offset: 0x8 (8)
    struct _PEP_WORK_DEVICE_IDLE DeviceIdle;                // offset: 0x8 (8)
    struct _PEP_WORK_COMPLETE_IDLE_STATE CompleteIdleState; // offset: 0x8 (8)
    struct _PEP_WORK_COMPLETE_PERF_STATE CompletePerfState; // offset: 0x8 (8)
    struct _PEP_WORK_ACPI_NOTIFY AcpiNotify;                // offset: 0x8 (8)
    struct _PEP_WORK_ACPI_EVALUATE_CONTROL_METHOD_COMPLETE
        ControlMethodComplete; // offset: 0x8 (8)
  };
};

// 0x70 (112) bytes
struct _PNP_REBALANCE_TRACE_CONTEXT {
  ULONG DeviceCount;                       // offset: 0x0 (0)
  ULONG RebalancePhase;                    // offset: 0x4 (4)
  enum _PNP_REBALANCE_REASON Reason[2];    // offset: 0x8 (8)
  enum _PNP_REBALANCE_FAILURE Failure[2];  // offset: 0x10 (16)
  struct _DEVICE_NODE *SubtreeRoot;        // offset: 0x18 (24)
  UCHAR SubtreeIncludesRoot;               // offset: 0x20 (32)
  struct _DEVICE_NODE *TriggerRoot;        // offset: 0x28 (40)
  UCHAR RebalanceDueToDynamicPartitioning; // offset: 0x30 (48)
  ULONGLONG BeginTime;                     // offset: 0x38 (56)
  struct _DEVICE_NODE *VetoNode[2];        // offset: 0x40 (64)
  enum _PNP_DEVNODE_QUERY_REBALANCE_VETO_REASON
      VetoQueryRebalanceReason[2]; // offset: 0x50 (80)
  struct _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT
      ConflictContext; // offset: 0x58 (88)
};

// 0x20 (32) bytes
struct _PROC_IDLE_STATE_BUCKET {
  ULONGLONG TotalTime; // offset: 0x0 (0)
  ULONGLONG MinTime;   // offset: 0x8 (8)
  ULONGLONG MaxTime;   // offset: 0x10 (16)
  ULONG Count;         // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _ETW_IPT_SUPPORT {
  VOID *IptHandle;     // offset: 0x0 (0)
  ULONGLONG IptOption; // offset: 0x8 (8)
  struct _ETW_HW_TRACE_EXT_INTERFACE
      *EtwHwTraceExtInterface; // offset: 0x10 (16)
  volatile ULONG HookIdCount;  // offset: 0x18 (24)
  USHORT HookId[4];            // offset: 0x1c (28)
};

// 0x48 (72) bytes
struct _WMI_BUFFER_HEADER {
  ULONG BufferSize;               // offset: 0x0 (0)
  ULONG SavedOffset;              // offset: 0x4 (4)
  volatile ULONG CurrentOffset;   // offset: 0x8 (8)
  volatile LONG ReferenceCount;   // offset: 0xc (12)
  union _LARGE_INTEGER TimeStamp; // offset: 0x10 (16)
  LONGLONG SequenceNumber;        // offset: 0x18 (24)
  union {
    struct {
      ULONGLONG ClockType : 3;  // offset: 0x20 (32)
      ULONGLONG Frequency : 61; // offset: 0x20 (32)
    };
    struct _SINGLE_LIST_ENTRY SlistEntry;  // offset: 0x20 (32)
    struct _WMI_BUFFER_HEADER *NextBuffer; // offset: 0x20 (32)
  };
  struct _ETW_BUFFER_CONTEXT ClientContext; // offset: 0x28 (40)
  enum _ETW_BUFFER_STATE State;             // offset: 0x2c (44)
  ULONG Offset;                             // offset: 0x30 (48)
  USHORT BufferFlag;                        // offset: 0x34 (52)
  USHORT BufferType;                        // offset: 0x36 (54)
  union {
    ULONG Padding1[4];                   // offset: 0x38 (56)
    struct _ETW_REF_CLOCK ReferenceTime; // offset: 0x38 (56)
    struct _LIST_ENTRY GlobalEntry;      // offset: 0x38 (56)
    struct {
      VOID *Pointer0; // offset: 0x38 (56)
      VOID *Pointer1; // offset: 0x40 (64)
    };
  };
};

// 0x18 (24) bytes
struct _EVENT_FILTER_HEADER {
  USHORT Id;            // offset: 0x0 (0)
  UCHAR Version;        // offset: 0x2 (2)
  UCHAR Reserved[5];    // offset: 0x3 (3)
  ULONGLONG InstanceId; // offset: 0x8 (8)
  ULONG Size;           // offset: 0x10 (16)
  ULONG NextOffset;     // offset: 0x14 (20)
};

// 0x18 (24) bytes
struct _EVENT_FILTER_LEVEL_KW {
  ULONGLONG MatchAnyKeyword; // offset: 0x0 (0)
  ULONGLONG MatchAllKeyword; // offset: 0x8 (8)
  UCHAR Level;               // offset: 0x10 (16)
  UCHAR FilterIn;            // offset: 0x11 (17)
};

// 0x28 (40) bytes
struct _ETW_FILTER_EVENT_NAME_DATA {
  UCHAR FilterIn;                   // offset: 0x0 (0)
  UCHAR Level;                      // offset: 0x1 (1)
  ULONGLONG MatchAnyKeyword;        // offset: 0x8 (8)
  ULONGLONG MatchAllKeyword;        // offset: 0x10 (16)
  struct _RTL_HASH_TABLE NameTable; // offset: 0x18 (24)
};

// 0x100 (256) bytes
union _LFH_RANDOM_DATA {
  UCHAR Bytes[256];        // offset: 0x0 (0)
  USHORT Words[128];       // offset: 0x0 (0)
  ULONGLONG Quadwords[32]; // offset: 0x0 (0)
};

// 0x110 (272) bytes
struct _SID_AND_ATTRIBUTES_HASH {
  ULONG SidCount;                      // offset: 0x0 (0)
  struct _SID_AND_ATTRIBUTES *SidAttr; // offset: 0x8 (8)
  ULONGLONG Hash[32];                  // offset: 0x10 (16)
};

// 0x58 (88) bytes
struct _TOKEN_ACCESS_INFORMATION {
  struct _SID_AND_ATTRIBUTES_HASH *SidHash;              // offset: 0x0 (0)
  struct _SID_AND_ATTRIBUTES_HASH *RestrictedSidHash;    // offset: 0x8 (8)
  struct _TOKEN_PRIVILEGES *Privileges;                  // offset: 0x10 (16)
  struct _LUID AuthenticationId;                         // offset: 0x18 (24)
  enum _TOKEN_TYPE TokenType;                            // offset: 0x20 (32)
  enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; // offset: 0x24 (36)
  struct _TOKEN_MANDATORY_POLICY MandatoryPolicy;        // offset: 0x28 (40)
  ULONG Flags;                                           // offset: 0x2c (44)
  ULONG AppContainerNumber;                              // offset: 0x30 (48)
  VOID *PackageSid;                                      // offset: 0x38 (56)
  struct _SID_AND_ATTRIBUTES_HASH *CapabilitiesHash;     // offset: 0x40 (64)
  VOID *TrustLevelSid;                                   // offset: 0x48 (72)
  VOID *SecurityAttributes;                              // offset: 0x50 (80)
};

// 0x260 (608) bytes
struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION {
  ULONG DeviceGroupsCount;                             // offset: 0x0 (0)
  struct _SID_AND_ATTRIBUTES *pDeviceGroups;           // offset: 0x8 (8)
  ULONG RestrictedDeviceGroupsCount;                   // offset: 0x10 (16)
  struct _SID_AND_ATTRIBUTES *pRestrictedDeviceGroups; // offset: 0x18 (24)
  struct _SID_AND_ATTRIBUTES_HASH DeviceGroupsHash;    // offset: 0x20 (32)
  struct _SID_AND_ATTRIBUTES_HASH
      RestrictedDeviceGroupsHash; // offset: 0x130 (304)
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pUserSecurityAttributes; // offset: 0x240 (576)
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pDeviceSecurityAttributes; // offset: 0x248 (584)
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pRestrictedUserSecurityAttributes; // offset: 0x250 (592)
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pRestrictedDeviceSecurityAttributes; // offset: 0x258 (600)
};

// 0x130 (304) bytes
struct _POP_FX_WORK_POOL {
  struct _POP_FX_PLUGIN *Plugin;              // offset: 0x0 (0)
  ULONGLONG EmergencyWorkQueueLock;           // offset: 0x8 (8)
  struct _LIST_ENTRY EmergencyWorkQueue;      // offset: 0x10 (16)
  struct _KSEMAPHORE WorkPoolQueues[2];       // offset: 0x20 (32)
  volatile LONG WorkItemStatus;               // offset: 0x60 (96)
  struct _POP_FX_WORK_POOL_ITEM WorkItems[4]; // offset: 0x68 (104)
  struct _KTHREAD *EmergencyWorkerThread;     // offset: 0x108 (264)
  struct _KTHREAD *DynamicWorkerThreads[4];   // offset: 0x110 (272)
};

// 0x28 (40) bytes
struct _POP_FX_WORK_POOL_ITEM {
  struct _POP_FX_WORK_POOL *WorkPool; // offset: 0x0 (0)
  struct _WORK_QUEUE_ITEM WorkItem;   // offset: 0x8 (8)
};

// 0x80 (128) bytes
struct _PPM_SELECTION_STATISTICS {
  ULONGLONG SelectedCount;                        // offset: 0x0 (0)
  ULONGLONG VetoCount;                            // offset: 0x8 (8)
  ULONGLONG PreVetoCount;                         // offset: 0x10 (16)
  ULONGLONG WrongProcessorCount;                  // offset: 0x18 (24)
  ULONGLONG LatencyCount;                         // offset: 0x20 (32)
  ULONGLONG IdleDurationCount;                    // offset: 0x28 (40)
  ULONGLONG DeviceDependencyCount;                // offset: 0x30 (48)
  ULONGLONG ProcessorDependencyCount;             // offset: 0x38 (56)
  ULONGLONG PlatformOnlyCount;                    // offset: 0x40 (64)
  ULONGLONG InterruptibleCount;                   // offset: 0x48 (72)
  ULONGLONG LegacyOverrideCount;                  // offset: 0x50 (80)
  ULONGLONG CstateCheckCount;                     // offset: 0x58 (88)
  ULONGLONG NoCStateCount;                        // offset: 0x60 (96)
  ULONGLONG CoordinatedDependencyCount;           // offset: 0x68 (104)
  ULONGLONG NotClockOwnerCount;                   // offset: 0x70 (112)
  struct _PPM_VETO_ACCOUNTING *PreVetoAccounting; // offset: 0x78 (120)
};

// 0x3f0 (1008) bytes
struct _PLATFORM_IDLE_STATE_ACCOUNTING {
  ULONG CancelCount;                                    // offset: 0x0 (0)
  ULONG FailureCount;                                   // offset: 0x4 (4)
  ULONG SuccessCount;                                   // offset: 0x8 (8)
  ULONGLONG MaxTime;                                    // offset: 0x10 (16)
  ULONGLONG MinTime;                                    // offset: 0x18 (24)
  ULONGLONG TotalTime;                                  // offset: 0x20 (32)
  ULONG InvalidBucketIndex;                             // offset: 0x28 (40)
  struct _PPM_SELECTION_STATISTICS SelectionStatistics; // offset: 0x30 (48)
  struct _PROC_IDLE_STATE_BUCKET IdleTimeBuckets[26];   // offset: 0xb0 (176)
};

// 0x408 (1032) bytes
struct _PLATFORM_IDLE_ACCOUNTING {
  ULONG ResetCount;                                // offset: 0x0 (0)
  ULONG StateCount;                                // offset: 0x4 (4)
  ULONG DeepSleepCount;                            // offset: 0x8 (8)
  enum PPM_IDLE_BUCKET_TIME_TYPE TimeUnit;         // offset: 0xc (12)
  ULONGLONG StartTime;                             // offset: 0x10 (16)
  struct _PLATFORM_IDLE_STATE_ACCOUNTING State[1]; // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _POP_FX_LOG_ENTRY {
  ULONGLONG Timestamp;   // offset: 0x0 (0)
  UCHAR Operation;       // offset: 0x8 (8)
  UCHAR Component;       // offset: 0x9 (9)
  USHORT Processor;      // offset: 0xa (10)
  USHORT Process;        // offset: 0xc (12)
  USHORT Thread;         // offset: 0xe (14)
  ULONGLONG Information; // offset: 0x10 (16)
};

// 0x1a8 (424) bytes
struct _POP_FX_PLUGIN {
  struct _LIST_ENTRY Link;  // offset: 0x0 (0)
  ULONG Version;            // offset: 0x10 (16)
  ULONGLONG Flags;          // offset: 0x18 (24)
  struct _KQUEUE WorkQueue; // offset: 0x20 (32)
  UCHAR (*AcceptDeviceNotification)
  (ULONG arg1, VOID *arg2); // offset: 0x60 (96)
  UCHAR (*AcceptProcessorNotification)
  (struct PEPHANDLE__ *arg1, ULONG arg2, VOID *arg3);      // offset: 0x68 (104)
  UCHAR (*AcceptAcpiNotification)(ULONG arg1, VOID *arg2); // offset: 0x70 (112)
  struct _POP_FX_WORK_POOL PluginWorkPool;                 // offset: 0x78 (120)
};

// 0x28 (40) bytes
struct _PERF_CONTROL_STATE_SELECTION {
  ULONGLONG SelectedState;        // offset: 0x0 (0)
  ULONG SelectedPercent;          // offset: 0x8 (8)
  ULONG SelectedFrequency;        // offset: 0xc (12)
  ULONG MinPercent;               // offset: 0x10 (16)
  ULONG MaxPercent;               // offset: 0x14 (20)
  ULONG TolerancePercent;         // offset: 0x18 (24)
  ULONG EppPercent;               // offset: 0x1c (28)
  ULONG AutonomousActivityWindow; // offset: 0x20 (32)
  UCHAR Autonomous;               // offset: 0x24 (36)
  UCHAR InheritFromDomain;        // offset: 0x25 (37)
};

// 0x3e8 (1000) bytes
struct _PROC_IDLE_STATE_ACCOUNTING {
  ULONGLONG TotalTime;                                  // offset: 0x0 (0)
  ULONG CancelCount;                                    // offset: 0x8 (8)
  ULONG FailureCount;                                   // offset: 0xc (12)
  ULONG SuccessCount;                                   // offset: 0x10 (16)
  ULONG InvalidBucketIndex;                             // offset: 0x14 (20)
  ULONGLONG MinTime;                                    // offset: 0x18 (24)
  ULONGLONG MaxTime;                                    // offset: 0x20 (32)
  struct _PPM_SELECTION_STATISTICS SelectionStatistics; // offset: 0x28 (40)
  struct _PROC_IDLE_STATE_BUCKET IdleTimeBuckets[26];   // offset: 0xa8 (168)
};

// 0x30 (48) bytes
struct _PROCESSOR_IDLE_CONSTRAINTS {
  ULONGLONG TotalTime;            // offset: 0x0 (0)
  ULONGLONG IdleTime;             // offset: 0x8 (8)
  ULONGLONG ExpectedIdleDuration; // offset: 0x10 (16)
  ULONGLONG MaxIdleDuration;      // offset: 0x18 (24)
  ULONG OverrideState;            // offset: 0x20 (32)
  ULONG TimeCheck;                // offset: 0x24 (36)
  UCHAR PromotePercent;           // offset: 0x28 (40)
  UCHAR DemotePercent;            // offset: 0x29 (41)
  UCHAR Parked;                   // offset: 0x2a (42)
  UCHAR Interruptible;            // offset: 0x2b (43)
  UCHAR PlatformIdle;             // offset: 0x2c (44)
  UCHAR ExpectedWakeReason;       // offset: 0x2d (45)
  UCHAR IdleStateMax;             // offset: 0x2e (46)
};

// 0x58 (88) bytes
struct _PROCESSOR_IDLE_PREPARE_INFO {
  VOID *Context;                                      // offset: 0x0 (0)
  struct _PROCESSOR_IDLE_CONSTRAINTS Constraints;     // offset: 0x8 (8)
  ULONG DependencyCount;                              // offset: 0x38 (56)
  ULONG DependencyUsed;                               // offset: 0x3c (60)
  struct _PROCESSOR_IDLE_DEPENDENCY *DependencyArray; // offset: 0x40 (64)
  ULONG PlatformIdleStateIndex;                       // offset: 0x48 (72)
  ULONG ProcessorIdleStateIndex;                      // offset: 0x4c (76)
  ULONG IdleSelectFailureMask;                        // offset: 0x50 (80)
};

// 0x20 (32) bytes
struct _SEP_SID_VALUES_BLOCK {
  ULONG BlockLength;        // offset: 0x0 (0)
  LONGLONG ReferenceCount;  // offset: 0x8 (8)
  ULONG SidCount;           // offset: 0x10 (16)
  ULONGLONG SidValuesStart; // offset: 0x18 (24)
};

// 0x88 (136) bytes
struct _PROC_PERF_CONSTRAINT {
  struct _PROC_PERF_CHECK_CONTEXT *CheckContext;  // offset: 0x0 (0)
  ULONGLONG PerfContext;                          // offset: 0x8 (8)
  enum _PROCESSOR_PRESENCE Presence;              // offset: 0x10 (16)
  ULONG ProcessorId;                              // offset: 0x14 (20)
  ULONG PlatformCap;                              // offset: 0x18 (24)
  ULONG ThermalCap;                               // offset: 0x1c (28)
  ULONG LimitReasons;                             // offset: 0x20 (32)
  ULONGLONG PlatformCapStartTime;                 // offset: 0x28 (40)
  ULONG ProcCap;                                  // offset: 0x30 (48)
  ULONG ProcFloor;                                // offset: 0x34 (52)
  ULONG TargetPercent;                            // offset: 0x38 (56)
  UCHAR EngageResponsivenessOverrides;            // offset: 0x3c (60)
  UCHAR ResponsivenessChangeCount;                // offset: 0x3d (61)
  struct _PERF_CONTROL_STATE_SELECTION Selection; // offset: 0x40 (64)
  ULONG DomainSelectionGeneration;                // offset: 0x68 (104)
  ULONG PreviousFrequency;                        // offset: 0x6c (108)
  ULONG PreviousPercent;                          // offset: 0x70 (112)
  ULONG LatestFrequencyPercent;                   // offset: 0x74 (116)
  ULONG LatestPerformancePercent;                 // offset: 0x78 (120)
  UCHAR Force;                                    // offset: 0x7c (124)
  UCHAR UseQosUpdateLock;                         // offset: 0x7d (125)
  ULONGLONG QosUpdateLock;                        // offset: 0x80 (128)
};

// 0x18 (24) bytes
struct _KHETERO_PROCESSOR_SET {
  ULONGLONG IdealMask;     // offset: 0x0 (0)
  ULONGLONG PreferredMask; // offset: 0x8 (8)
  ULONGLONG AvailableMask; // offset: 0x10 (16)
};

// 0x20 (32) bytes
struct _TRACE_ENABLE_INFO {
  ULONG IsEnabled;           // offset: 0x0 (0)
  UCHAR Level;               // offset: 0x4 (4)
  UCHAR Reserved1;           // offset: 0x5 (5)
  USHORT LoggerId;           // offset: 0x6 (6)
  ULONG EnableProperty;      // offset: 0x8 (8)
  ULONG Reserved2;           // offset: 0xc (12)
  ULONGLONG MatchAnyKeyword; // offset: 0x10 (16)
  ULONGLONG MatchAllKeyword; // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _MACHINE_FRAME {
  ULONGLONG Rip;   // offset: 0x0 (0)
  USHORT SegCs;    // offset: 0x8 (8)
  USHORT Fill1[3]; // offset: 0xa (10)
  ULONG EFlags;    // offset: 0x10 (16)
  ULONG Fill2;     // offset: 0x14 (20)
  ULONGLONG Rsp;   // offset: 0x18 (24)
  USHORT SegSs;    // offset: 0x20 (32)
  USHORT Fill3[3]; // offset: 0x22 (34)
};

// 0x410 (1040) bytes
struct _PROC_IDLE_ACCOUNTING {
  ULONG StateCount;                            // offset: 0x0 (0)
  ULONG TotalTransitions;                      // offset: 0x4 (4)
  ULONG ResetCount;                            // offset: 0x8 (8)
  ULONG AbortCount;                            // offset: 0xc (12)
  ULONGLONG StartTime;                         // offset: 0x10 (16)
  ULONGLONG PriorIdleTime;                     // offset: 0x18 (24)
  enum PPM_IDLE_BUCKET_TIME_TYPE TimeUnit;     // offset: 0x20 (32)
  struct _PROC_IDLE_STATE_ACCOUNTING State[1]; // offset: 0x28 (40)
};

// 0x10 (16) bytes
struct _KSPIN_LOCK_QUEUE {
  struct _KSPIN_LOCK_QUEUE *volatile Next; // offset: 0x0 (0)
  ULONGLONG *volatile Lock;                // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _KLOCK_QUEUE_HANDLE {
  struct _KSPIN_LOCK_QUEUE LockQueue; // offset: 0x0 (0)
  UCHAR OldIrql;                      // offset: 0x10 (16)
};

// 0x10 (16) bytes
union _KQOS_GROUPING_SETS {
  struct {
    ULONGLONG SingleCoreSet; // offset: 0x0 (0)
  };
  ULONGLONG SmtSet; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _EXHANDLE {
  union {
    struct {
      ULONG TagBits : 2; // offset: 0x0 (0)
      ULONG Index : 30;  // offset: 0x0 (0)
    };
    VOID *GenericHandleOverlay; // offset: 0x0 (0)
    ULONGLONG Value;            // offset: 0x0 (0)
  };
};

// 0xd0 (208) bytes
struct _IRP {
  SHORT Type;              // offset: 0x0 (0)
  USHORT Size;             // offset: 0x2 (2)
  struct _MDL *MdlAddress; // offset: 0x8 (8)
  ULONG Flags;             // offset: 0x10 (16)
  union {
    struct _IRP *MasterIrp; // offset: 0x18 (24)
    LONG IrpCount;          // offset: 0x18 (24)
    VOID *SystemBuffer;     // offset: 0x18 (24)

  } AssociatedIrp;                    // offset: 0x18 (24)
  struct _LIST_ENTRY ThreadListEntry; // offset: 0x20 (32)
  struct _IO_STATUS_BLOCK IoStatus;   // offset: 0x30 (48)
  CHAR RequestorMode;                 // offset: 0x40 (64)
  UCHAR PendingReturned;              // offset: 0x41 (65)
  CHAR StackCount;                    // offset: 0x42 (66)
  CHAR CurrentLocation;               // offset: 0x43 (67)
  UCHAR Cancel;                       // offset: 0x44 (68)
  UCHAR CancelIrql;                   // offset: 0x45 (69)
  CHAR ApcEnvironment;                // offset: 0x46 (70)
  UCHAR AllocationFlags;              // offset: 0x47 (71)
  struct _IO_STATUS_BLOCK *UserIosb;  // offset: 0x48 (72)
  struct _KEVENT *UserEvent;          // offset: 0x50 (80)
  union {
    struct {
      union {
        VOID (*UserApcRoutine)
        (VOID *arg1, struct _IO_STATUS_BLOCK *arg2,
         ULONG arg3);         // offset: 0x0 (0)
        VOID *IssuingProcess; // offset: 0x0 (0)
      };
      VOID *UserApcContext;              // offset: 0x8 (8)
    } AsynchronousParameters;            // offset: 0x58 (88)
    union _LARGE_INTEGER AllocationSize; // offset: 0x58 (88)

  } Overlay; // offset: 0x58 (88)
  VOID (*CancelRoutine)
  (struct _DEVICE_OBJECT *arg1, struct _IRP *arg2); // offset: 0x68 (104)
  VOID *UserBuffer;                                 // offset: 0x70 (112)
  union {
    struct {
      union {
        struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry; // offset: 0x0 (0)
        VOID *DriverContext[4];                       // offset: 0x0 (0)
      };
      struct _ETHREAD *Thread;      // offset: 0x20 (32)
      CHAR *AuxiliaryBuffer;        // offset: 0x28 (40)
      struct _LIST_ENTRY ListEntry; // offset: 0x30 (48)
      union {
        struct _IO_STACK_LOCATION *CurrentStackLocation; // offset: 0x40 (64)
        ULONG PacketType;                                // offset: 0x40 (64)
      };
      struct _FILE_OBJECT *OriginalFileObject; // offset: 0x48 (72)
    } Overlay;                                 // offset: 0x78 (120)
    struct _KAPC Apc;                          // offset: 0x78 (120)
    VOID *CompletionKey;                       // offset: 0x78 (120)

  } Tail; // offset: 0x78 (120)
};

// 0x50 (80) bytes
struct _MACHINE_CHECK_CONTEXT {
  struct _MACHINE_FRAME MachineFrame; // offset: 0x0 (0)
  ULONGLONG Rax;                      // offset: 0x28 (40)
  ULONGLONG Rcx;                      // offset: 0x30 (48)
  ULONGLONG Rdx;                      // offset: 0x38 (56)
  ULONGLONG GsBase;                   // offset: 0x40 (64)
  ULONGLONG Cr3;                      // offset: 0x48 (72)
};

// 0x40 (64) bytes
struct _REQUEST_MAILBOX {
  struct _REQUEST_MAILBOX *Next;         // offset: 0x0 (0)
  ULONGLONG RequestSummary;              // offset: 0x8 (8)
  struct _KREQUEST_PACKET RequestPacket; // offset: 0x10 (16)
  volatile LONG *NodeTargetCountAddr;    // offset: 0x30 (48)
  volatile LONG NodeTargetCount;         // offset: 0x38 (56)
};

// 0x10 (16) bytes
struct _KTIMER_EXPIRATION_TRACE {
  ULONGLONG InterruptTime;                 // offset: 0x0 (0)
  union _LARGE_INTEGER PerformanceCounter; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _PROC_IDLE_SNAP {
  ULONGLONG Time; // offset: 0x0 (0)
  ULONGLONG Idle; // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _PPM_FFH_THROTTLE_STATE_INFO {
  UCHAR EnableLogging;                   // offset: 0x0 (0)
  ULONG MismatchCount;                   // offset: 0x4 (4)
  UCHAR Initialized;                     // offset: 0x8 (8)
  ULONGLONG LastValue;                   // offset: 0x10 (16)
  union _LARGE_INTEGER LastLogTickCount; // offset: 0x18 (24)
};

// 0x40 (64) bytes
struct _XSAVE_AREA_HEADER {
  ULONGLONG Mask;           // offset: 0x0 (0)
  ULONGLONG CompactionMask; // offset: 0x8 (8)
  ULONGLONG Reserved2[6];   // offset: 0x10 (16)
};

// 0xf0 (240) bytes
struct _KSPECIAL_REGISTERS {
  ULONGLONG Cr0;                  // offset: 0x0 (0)
  ULONGLONG Cr2;                  // offset: 0x8 (8)
  ULONGLONG Cr3;                  // offset: 0x10 (16)
  ULONGLONG Cr4;                  // offset: 0x18 (24)
  ULONGLONG KernelDr0;            // offset: 0x20 (32)
  ULONGLONG KernelDr1;            // offset: 0x28 (40)
  ULONGLONG KernelDr2;            // offset: 0x30 (48)
  ULONGLONG KernelDr3;            // offset: 0x38 (56)
  ULONGLONG KernelDr6;            // offset: 0x40 (64)
  ULONGLONG KernelDr7;            // offset: 0x48 (72)
  struct _KDESCRIPTOR Gdtr;       // offset: 0x50 (80)
  struct _KDESCRIPTOR Idtr;       // offset: 0x60 (96)
  USHORT Tr;                      // offset: 0x70 (112)
  USHORT Ldtr;                    // offset: 0x72 (114)
  ULONG MxCsr;                    // offset: 0x74 (116)
  ULONGLONG DebugControl;         // offset: 0x78 (120)
  ULONGLONG LastBranchToRip;      // offset: 0x80 (128)
  ULONGLONG LastBranchFromRip;    // offset: 0x88 (136)
  ULONGLONG LastExceptionToRip;   // offset: 0x90 (144)
  ULONGLONG LastExceptionFromRip; // offset: 0x98 (152)
  ULONGLONG Cr8;                  // offset: 0xa0 (160)
  ULONGLONG MsrGsBase;            // offset: 0xa8 (168)
  ULONGLONG MsrGsSwap;            // offset: 0xb0 (176)
  ULONGLONG MsrStar;              // offset: 0xb8 (184)
  ULONGLONG MsrLStar;             // offset: 0xc0 (192)
  ULONGLONG MsrCStar;             // offset: 0xc8 (200)
  ULONGLONG MsrSyscallMask;       // offset: 0xd0 (208)
  ULONGLONG Xcr0;                 // offset: 0xd8 (216)
  ULONGLONG MsrFsBase;            // offset: 0xe0 (224)
  ULONGLONG SpecialPadding0;      // offset: 0xe8 (232)
};

// 0x18 (24) bytes
struct _COUNTER_READING {
  enum _HARDWARE_COUNTER_TYPE Type; // offset: 0x0 (0)
  ULONG Index;                      // offset: 0x4 (4)
  ULONGLONG Start;                  // offset: 0x8 (8)
  ULONGLONG Total;                  // offset: 0x10 (16)
};

// 0x1c0 (448) bytes
struct _THREAD_PERFORMANCE_DATA {
  USHORT Size;                              // offset: 0x0 (0)
  USHORT Version;                           // offset: 0x2 (2)
  struct _PROCESSOR_NUMBER ProcessorNumber; // offset: 0x4 (4)
  ULONG ContextSwitches;                    // offset: 0x8 (8)
  ULONG HwCountersCount;                    // offset: 0xc (12)
  volatile ULONGLONG UpdateCount;           // offset: 0x10 (16)
  ULONGLONG WaitReasonBitMap;               // offset: 0x18 (24)
  ULONGLONG HardwareCounters;               // offset: 0x20 (32)
  struct _COUNTER_READING CycleTime;        // offset: 0x28 (40)
  struct _COUNTER_READING HwCounters[16];   // offset: 0x40 (64)
};

// 0x10 (16) bytes
union _HANDLE_TABLE_ENTRY {
  volatile LONGLONG VolatileLowValue; // offset: 0x0 (0)
  LONGLONG LowValue;                  // offset: 0x0 (0)
  struct {
    struct _HANDLE_TABLE_ENTRY_INFO *volatile InfoTable; // offset: 0x0 (0)
    LONGLONG HighValue;                                  // offset: 0x8 (8)
    union _HANDLE_TABLE_ENTRY *NextFreeHandleEntry;      // offset: 0x8 (8)
    struct _EXHANDLE LeafHandleValue;                    // offset: 0x8 (8)
  };
  LONGLONG RefCountField;   // offset: 0x0 (0)
  ULONGLONG Unlocked : 1;   // offset: 0x0 (0)
  ULONGLONG RefCnt : 16;    // offset: 0x0 (0)
  ULONGLONG Attributes : 3; // offset: 0x0 (0)
  struct {
    ULONGLONG ObjectPointerBits : 44; // offset: 0x0 (0)
    ULONG GrantedAccessBits : 25;     // offset: 0x8 (8)
    ULONG NoRightsUpgrade : 1;        // offset: 0x8 (8)
    ULONG Spare1 : 6;                 // offset: 0x8 (8)
  };
  ULONG Spare2; // offset: 0xc (12)
};

// 0x8 (8) bytes
union _ENERGY_STATE_DURATION {
  ULONGLONG Value; // offset: 0x0 (0)
  struct {
    ULONG LastChangeTime; // offset: 0x0 (0)
    ULONG Duration : 31;  // offset: 0x4 (4)
  };
  ULONG IsInState : 1; // offset: 0x4 (4)
};

// 0x270 (624) bytes
struct _KSHARED_READY_QUEUE {
  ULONGLONG Lock;                       // offset: 0x0 (0)
  ULONG ReadySummary;                   // offset: 0x8 (8)
  struct _LIST_ENTRY ReadyListHead[32]; // offset: 0x10 (16)
  CHAR RunningSummary[64];              // offset: 0x210 (528)
  UCHAR Span;                           // offset: 0x250 (592)
  UCHAR LowProcIndex;                   // offset: 0x251 (593)
  UCHAR QueueIndex;                     // offset: 0x252 (594)
  UCHAR ProcCount;                      // offset: 0x253 (595)
  UCHAR ScanOwner;                      // offset: 0x254 (596)
  UCHAR Spare[3];                       // offset: 0x255 (597)
  ULONGLONG Affinity;                   // offset: 0x258 (600)
  ULONG ReadyThreadCount;               // offset: 0x260 (608)
  ULONGLONG ReadyQueueExpectedRunTime;  // offset: 0x268 (616)
};

// 0x10 (16) bytes
struct _KSECURE_FAULT_INFORMATION {
  ULONGLONG FaultCode; // offset: 0x0 (0)
  ULONGLONG FaultVa;   // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _PS_TRUSTLET_TKSESSION_ID {
  ULONGLONG SessionId[4]; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _PS_MITIGATION_AUDIT_OPTIONS_MAP {
  ULONGLONG Map[3]; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _PS_MITIGATION_OPTIONS_MAP {
  ULONGLONG Map[3]; // offset: 0x0 (0)
};

// 0x60 (96) bytes
struct _PROC_PERF_CHECK_SNAP {
  ULONGLONG Time;                          // offset: 0x0 (0)
  ULONGLONG Active;                        // offset: 0x8 (8)
  ULONGLONG Stall;                         // offset: 0x10 (16)
  ULONGLONG FrequencyScaledActive;         // offset: 0x18 (24)
  ULONGLONG PerformanceScaledActive;       // offset: 0x20 (32)
  ULONGLONG PerformanceScaledKernelActive; // offset: 0x28 (40)
  ULONGLONG CyclesActive;                  // offset: 0x30 (48)
  ULONGLONG CyclesAffinitized;             // offset: 0x38 (56)
  ULONGLONG TaggedThreadCycles[3];         // offset: 0x40 (64)
  ULONG ResponsivenessEvents;              // offset: 0x58 (88)
};

// 0x158 (344) bytes
struct _PROC_PERF_CHECK {
  ULONGLONG LastActive;                           // offset: 0x0 (0)
  ULONGLONG LastTime;                             // offset: 0x8 (8)
  ULONGLONG LastStall;                            // offset: 0x10 (16)
  ULONG LastResponsivenessEvents;                 // offset: 0x18 (24)
  struct _PROC_PERF_CHECK_SNAP LastPerfCheckSnap; // offset: 0x20 (32)
  struct _PROC_PERF_CHECK_SNAP CurrentSnap;       // offset: 0x80 (128)
  struct _PROC_PERF_CHECK_SNAP LastDeliveredSnap; // offset: 0xe0 (224)
  ULONG LastDeliveredPerformance;                 // offset: 0x140 (320)
  ULONG LastDeliveredFrequency;                   // offset: 0x144 (324)
  UCHAR TaggedThreadPercent[3];                   // offset: 0x148 (328)
  UCHAR Class0FloorPerfSelection;                 // offset: 0x14b (331)
  UCHAR Class1MinimumPerfSelection;               // offset: 0x14c (332)
  ULONG CurrentResponsivenessEvents;              // offset: 0x150 (336)
};

// 0x8 (8) bytes
struct _MMPTE_LIST {
  ULONGLONG Valid : 1;      // offset: 0x0 (0)
  ULONGLONG OneEntry : 1;   // offset: 0x0 (0)
  ULONGLONG filler0 : 2;    // offset: 0x0 (0)
  ULONGLONG SwizzleBit : 1; // offset: 0x0 (0)
  ULONGLONG Protection : 5; // offset: 0x0 (0)
  ULONGLONG Prototype : 1;  // offset: 0x0 (0)
  ULONGLONG Transition : 1; // offset: 0x0 (0)
  ULONGLONG filler1 : 16;   // offset: 0x0 (0)
  ULONGLONG NextEntry : 36; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MMPTE_SUBSECTION {
  ULONGLONG Valid : 1;             // offset: 0x0 (0)
  ULONGLONG Unused0 : 3;           // offset: 0x0 (0)
  ULONGLONG SwizzleBit : 1;        // offset: 0x0 (0)
  ULONGLONG Protection : 5;        // offset: 0x0 (0)
  ULONGLONG Prototype : 1;         // offset: 0x0 (0)
  ULONGLONG ColdPage : 1;          // offset: 0x0 (0)
  ULONGLONG Unused1 : 3;           // offset: 0x0 (0)
  ULONGLONG ExecutePrivilege : 1;  // offset: 0x0 (0)
  LONGLONG SubsectionAddress : 48; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MMPTE_TRANSITION {
  ULONGLONG Valid : 1;            // offset: 0x0 (0)
  ULONGLONG Write : 1;            // offset: 0x0 (0)
  ULONGLONG Spare : 1;            // offset: 0x0 (0)
  ULONGLONG IoTracker : 1;        // offset: 0x0 (0)
  ULONGLONG SwizzleBit : 1;       // offset: 0x0 (0)
  ULONGLONG Protection : 5;       // offset: 0x0 (0)
  ULONGLONG Prototype : 1;        // offset: 0x0 (0)
  ULONGLONG Transition : 1;       // offset: 0x0 (0)
  ULONGLONG PageFrameNumber : 36; // offset: 0x0 (0)
  ULONGLONG Unused : 16;          // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MMPTE_TIMESTAMP {
  ULONGLONG MustBeZero : 1;       // offset: 0x0 (0)
  ULONGLONG Unused : 3;           // offset: 0x0 (0)
  ULONGLONG SwizzleBit : 1;       // offset: 0x0 (0)
  ULONGLONG Protection : 5;       // offset: 0x0 (0)
  ULONGLONG Prototype : 1;        // offset: 0x0 (0)
  ULONGLONG Transition : 1;       // offset: 0x0 (0)
  ULONGLONG PageFileLow : 4;      // offset: 0x0 (0)
  ULONGLONG Reserved : 16;        // offset: 0x0 (0)
  ULONGLONG GlobalTimeStamp : 32; // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MMPTE_SOFTWARE {
  ULONGLONG Valid : 1;                 // offset: 0x0 (0)
  ULONGLONG PageFileReserved : 1;      // offset: 0x0 (0)
  ULONGLONG PageFileAllocated : 1;     // offset: 0x0 (0)
  ULONGLONG ColdPage : 1;              // offset: 0x0 (0)
  ULONGLONG SwizzleBit : 1;            // offset: 0x0 (0)
  ULONGLONG Protection : 5;            // offset: 0x0 (0)
  ULONGLONG Prototype : 1;             // offset: 0x0 (0)
  ULONGLONG Transition : 1;            // offset: 0x0 (0)
  ULONGLONG PageFileLow : 4;           // offset: 0x0 (0)
  ULONGLONG UsedPageTableEntries : 10; // offset: 0x0 (0)
  ULONGLONG ShadowStack : 1;           // offset: 0x0 (0)
  ULONGLONG Unused : 5;                // offset: 0x0 (0)
  ULONGLONG PageFileHigh : 32;         // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MMPTE_PROTOTYPE {
  ULONGLONG Valid : 1;                // offset: 0x0 (0)
  ULONGLONG DemandFillProto : 1;      // offset: 0x0 (0)
  ULONGLONG HiberVerifyConverted : 1; // offset: 0x0 (0)
  ULONGLONG ReadOnly : 1;             // offset: 0x0 (0)
  ULONGLONG SwizzleBit : 1;           // offset: 0x0 (0)
  ULONGLONG Protection : 5;           // offset: 0x0 (0)
  ULONGLONG Prototype : 1;            // offset: 0x0 (0)
  ULONGLONG Combined : 1;             // offset: 0x0 (0)
  ULONGLONG Unused1 : 4;              // offset: 0x0 (0)
  LONGLONG ProtoAddress : 48;         // offset: 0x0 (0)
};

// 0x8 (8) bytes
struct _MMPTE_HARDWARE {
  ULONGLONG Valid : 1;               // offset: 0x0 (0)
  ULONGLONG Dirty1 : 1;              // offset: 0x0 (0)
  ULONGLONG Owner : 1;               // offset: 0x0 (0)
  ULONGLONG WriteThrough : 1;        // offset: 0x0 (0)
  ULONGLONG CacheDisable : 1;        // offset: 0x0 (0)
  ULONGLONG Accessed : 1;            // offset: 0x0 (0)
  ULONGLONG Dirty : 1;               // offset: 0x0 (0)
  ULONGLONG LargePage : 1;           // offset: 0x0 (0)
  ULONGLONG Global : 1;              // offset: 0x0 (0)
  ULONGLONG CopyOnWrite : 1;         // offset: 0x0 (0)
  ULONGLONG Unused : 1;              // offset: 0x0 (0)
  ULONGLONG Write : 1;               // offset: 0x0 (0)
  ULONGLONG PageFrameNumber : 36;    // offset: 0x0 (0)
  ULONGLONG ReservedForHardware : 4; // offset: 0x0 (0)
  ULONGLONG ReservedForSoftware : 4; // offset: 0x0 (0)
  ULONGLONG WsleAge : 4;             // offset: 0x0 (0)
  ULONGLONG WsleProtection : 3;      // offset: 0x0 (0)
  ULONGLONG NoExecute : 1;           // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _KLOCK_ENTRY_LOCK_STATE {
  union {
    struct {
      ULONGLONG CrossThreadReleasable : 1; // offset: 0x0 (0)
      ULONGLONG Busy : 1;                  // offset: 0x0 (0)
      ULONGLONG Reserved : 61;             // offset: 0x0 (0)
      ULONGLONG InTree : 1;                // offset: 0x0 (0)
    };
    VOID *LockState; // offset: 0x0 (0)
  };
  union {
    VOID *SessionState; // offset: 0x8 (8)
    struct {
      ULONG SessionId;  // offset: 0x8 (8)
      ULONG SessionPad; // offset: 0xc (12)
    };
  };
};

// 0x10 (16) bytes
struct _M128A {
  ULONGLONG Low; // offset: 0x0 (0)
  LONGLONG High; // offset: 0x8 (8)
};

// 0x140 (320) bytes
struct _KEXCEPTION_FRAME {
  ULONGLONG P1Home;       // offset: 0x0 (0)
  ULONGLONG P2Home;       // offset: 0x8 (8)
  ULONGLONG P3Home;       // offset: 0x10 (16)
  ULONGLONG P4Home;       // offset: 0x18 (24)
  ULONGLONG P5;           // offset: 0x20 (32)
  ULONGLONG Spare1;       // offset: 0x28 (40)
  struct _M128A Xmm6;     // offset: 0x30 (48)
  struct _M128A Xmm7;     // offset: 0x40 (64)
  struct _M128A Xmm8;     // offset: 0x50 (80)
  struct _M128A Xmm9;     // offset: 0x60 (96)
  struct _M128A Xmm10;    // offset: 0x70 (112)
  struct _M128A Xmm11;    // offset: 0x80 (128)
  struct _M128A Xmm12;    // offset: 0x90 (144)
  struct _M128A Xmm13;    // offset: 0xa0 (160)
  struct _M128A Xmm14;    // offset: 0xb0 (176)
  struct _M128A Xmm15;    // offset: 0xc0 (192)
  ULONGLONG TrapFrame;    // offset: 0xd0 (208)
  ULONGLONG OutputBuffer; // offset: 0xd8 (216)
  ULONGLONG OutputLength; // offset: 0xe0 (224)
  ULONGLONG Spare2;       // offset: 0xe8 (232)
  ULONGLONG MxCsr;        // offset: 0xf0 (240)
  ULONGLONG Rbp;          // offset: 0xf8 (248)
  ULONGLONG Rbx;          // offset: 0x100 (256)
  ULONGLONG Rdi;          // offset: 0x108 (264)
  ULONGLONG Rsi;          // offset: 0x110 (272)
  ULONGLONG R12;          // offset: 0x118 (280)
  ULONGLONG R13;          // offset: 0x120 (288)
  ULONGLONG R14;          // offset: 0x128 (296)
  ULONGLONG R15;          // offset: 0x130 (304)
  ULONGLONG Return;       // offset: 0x138 (312)
};

// 0x200 (512) bytes
struct _XSAVE_FORMAT {
  USHORT ControlWord;              // offset: 0x0 (0)
  USHORT StatusWord;               // offset: 0x2 (2)
  UCHAR TagWord;                   // offset: 0x4 (4)
  UCHAR Reserved1;                 // offset: 0x5 (5)
  USHORT ErrorOpcode;              // offset: 0x6 (6)
  ULONG ErrorOffset;               // offset: 0x8 (8)
  USHORT ErrorSelector;            // offset: 0xc (12)
  USHORT Reserved2;                // offset: 0xe (14)
  ULONG DataOffset;                // offset: 0x10 (16)
  USHORT DataSelector;             // offset: 0x14 (20)
  USHORT Reserved3;                // offset: 0x16 (22)
  ULONG MxCsr;                     // offset: 0x18 (24)
  ULONG MxCsr_Mask;                // offset: 0x1c (28)
  struct _M128A FloatRegisters[8]; // offset: 0x20 (32)
  struct _M128A XmmRegisters[16];  // offset: 0xa0 (160)
  UCHAR Reserved4[96];             // offset: 0x1a0 (416)
};

// 0x240 (576) bytes
struct _XSAVE_AREA {
  struct _XSAVE_FORMAT LegacyState; // offset: 0x0 (0)
  struct _XSAVE_AREA_HEADER Header; // offset: 0x200 (512)
};

// 0x20 (32) bytes
struct _XSTATE_CONTEXT {
  ULONGLONG Mask;           // offset: 0x0 (0)
  ULONG Length;             // offset: 0x8 (8)
  ULONG Reserved1;          // offset: 0xc (12)
  struct _XSAVE_AREA *Area; // offset: 0x10 (16)
  VOID *Buffer;             // offset: 0x18 (24)
};

// 0x38 (56) bytes
struct _XSTATE_SAVE {
  struct _XSTATE_SAVE *Prev;            // offset: 0x0 (0)
  struct _KTHREAD *Thread;              // offset: 0x8 (8)
  UCHAR Level;                          // offset: 0x10 (16)
  struct _XSTATE_CONTEXT XStateContext; // offset: 0x18 (24)
};

// 0x8 (8) bytes
union _TIMELINE_BITMAP {
  ULONGLONG Value; // offset: 0x0 (0)
  struct {
    ULONG EndTime; // offset: 0x0 (0)
  };
  ULONG Bitmap; // offset: 0x4 (4)
};

// 0xa0 (160) bytes
struct _PROCESS_ENERGY_VALUES_EXTENSION {
  union {
    union _TIMELINE_BITMAP Timelines[14]; // offset: 0x0 (0)
    struct {
      union _TIMELINE_BITMAP CpuTimeline;                 // offset: 0x0 (0)
      union _TIMELINE_BITMAP DiskTimeline;                // offset: 0x8 (8)
      union _TIMELINE_BITMAP NetworkTimeline;             // offset: 0x10 (16)
      union _TIMELINE_BITMAP MBBTimeline;                 // offset: 0x18 (24)
      union _TIMELINE_BITMAP ForegroundTimeline;          // offset: 0x20 (32)
      union _TIMELINE_BITMAP DesktopVisibleTimeline;      // offset: 0x28 (40)
      union _TIMELINE_BITMAP CompositionRenderedTimeline; // offset: 0x30 (48)
      union _TIMELINE_BITMAP
          CompositionDirtyGeneratedTimeline; // offset: 0x38 (56)
      union _TIMELINE_BITMAP
          CompositionDirtyPropagatedTimeline;         // offset: 0x40 (64)
      union _TIMELINE_BITMAP InputTimeline;           // offset: 0x48 (72)
      union _TIMELINE_BITMAP AudioInTimeline;         // offset: 0x50 (80)
      union _TIMELINE_BITMAP AudioOutTimeline;        // offset: 0x58 (88)
      union _TIMELINE_BITMAP DisplayRequiredTimeline; // offset: 0x60 (96)
      union _TIMELINE_BITMAP KeyboardInputTimeline;   // offset: 0x68 (104)
    };
  };
  union {
    union _ENERGY_STATE_DURATION Durations[5]; // offset: 0x70 (112)
    struct {
      union _ENERGY_STATE_DURATION InputDuration;    // offset: 0x70 (112)
      union _ENERGY_STATE_DURATION AudioInDuration;  // offset: 0x78 (120)
      union _ENERGY_STATE_DURATION AudioOutDuration; // offset: 0x80 (128)
      union _ENERGY_STATE_DURATION
          DisplayRequiredDuration;                        // offset: 0x88 (136)
      union _ENERGY_STATE_DURATION PSMBackgroundDuration; // offset: 0x90 (144)
    };
  };
  ULONG KeyboardInput; // offset: 0x98 (152)
  ULONG MouseInput;    // offset: 0x9c (156)
};

// 0x28 (40) bytes
struct _KDEVICE_QUEUE {
  SHORT Type;                        // offset: 0x0 (0)
  SHORT Size;                        // offset: 0x2 (2)
  struct _LIST_ENTRY DeviceListHead; // offset: 0x8 (8)
  ULONGLONG Lock;                    // offset: 0x18 (24)
  union {
    UCHAR Busy; // offset: 0x20 (32)
    struct {
      LONGLONG Reserved : 8; // offset: 0x20 (32)
      LONGLONG Hint : 56;    // offset: 0x20 (32)
    };
  };
};

// 0x48 (72) bytes
struct _CONTROLLER_OBJECT {
  SHORT Type;                            // offset: 0x0 (0)
  SHORT Size;                            // offset: 0x2 (2)
  VOID *ControllerExtension;             // offset: 0x8 (8)
  struct _KDEVICE_QUEUE DeviceWaitQueue; // offset: 0x10 (16)
  ULONG Spare1;                          // offset: 0x38 (56)
  union _LARGE_INTEGER Spare2;           // offset: 0x40 (64)
};

// 0x1a8 (424) bytes
struct _KTHREAD_COUNTERS {
  ULONGLONG WaitReasonBitMap;                // offset: 0x0 (0)
  struct _THREAD_PERFORMANCE_DATA *UserData; // offset: 0x8 (8)
  ULONG Flags;                               // offset: 0x10 (16)
  ULONG ContextSwitches;                     // offset: 0x14 (20)
  ULONGLONG CycleTimeBias;                   // offset: 0x18 (24)
  ULONGLONG HardwareCounters;                // offset: 0x20 (32)
  struct _COUNTER_READING HwCounter[16];     // offset: 0x28 (40)
};

// 0x190 (400) bytes
struct _KTRAP_FRAME {
  ULONGLONG P1Home; // offset: 0x0 (0)
  ULONGLONG P2Home; // offset: 0x8 (8)
  ULONGLONG P3Home; // offset: 0x10 (16)
  ULONGLONG P4Home; // offset: 0x18 (24)
  ULONGLONG P5;     // offset: 0x20 (32)
  union {
    CHAR PreviousMode;             // offset: 0x28 (40)
    UCHAR InterruptRetpolineState; // offset: 0x28 (40)
  };
  UCHAR PreviousIrql; // offset: 0x29 (41)
  union {
    UCHAR FaultIndicator; // offset: 0x2a (42)
    UCHAR NmiMsrIbrs;     // offset: 0x2a (42)
  };
  UCHAR ExceptionActive; // offset: 0x2b (43)
  ULONG MxCsr;           // offset: 0x2c (44)
  ULONGLONG Rax;         // offset: 0x30 (48)
  ULONGLONG Rcx;         // offset: 0x38 (56)
  ULONGLONG Rdx;         // offset: 0x40 (64)
  ULONGLONG R8;          // offset: 0x48 (72)
  ULONGLONG R9;          // offset: 0x50 (80)
  ULONGLONG R10;         // offset: 0x58 (88)
  ULONGLONG R11;         // offset: 0x60 (96)
  union {
    ULONGLONG GsBase; // offset: 0x68 (104)
    ULONGLONG GsSwap; // offset: 0x68 (104)
  };
  struct _M128A Xmm0; // offset: 0x70 (112)
  struct _M128A Xmm1; // offset: 0x80 (128)
  struct _M128A Xmm2; // offset: 0x90 (144)
  struct _M128A Xmm3; // offset: 0xa0 (160)
  struct _M128A Xmm4; // offset: 0xb0 (176)
  struct _M128A Xmm5; // offset: 0xc0 (192)
  union {
    ULONGLONG FaultAddress;  // offset: 0xd0 (208)
    ULONGLONG ContextRecord; // offset: 0xd0 (208)
  };
  ULONGLONG Dr0;                  // offset: 0xd8 (216)
  ULONGLONG Dr1;                  // offset: 0xe0 (224)
  ULONGLONG Dr2;                  // offset: 0xe8 (232)
  ULONGLONG Dr3;                  // offset: 0xf0 (240)
  ULONGLONG Dr6;                  // offset: 0xf8 (248)
  ULONGLONG Dr7;                  // offset: 0x100 (256)
  ULONGLONG DebugControl;         // offset: 0x108 (264)
  ULONGLONG LastBranchToRip;      // offset: 0x110 (272)
  ULONGLONG LastBranchFromRip;    // offset: 0x118 (280)
  ULONGLONG LastExceptionToRip;   // offset: 0x120 (288)
  ULONGLONG LastExceptionFromRip; // offset: 0x128 (296)
  USHORT SegDs;                   // offset: 0x130 (304)
  USHORT SegEs;                   // offset: 0x132 (306)
  USHORT SegFs;                   // offset: 0x134 (308)
  USHORT SegGs;                   // offset: 0x136 (310)
  ULONGLONG TrapFrame;            // offset: 0x138 (312)
  ULONGLONG Rbx;                  // offset: 0x140 (320)
  ULONGLONG Rdi;                  // offset: 0x148 (328)
  ULONGLONG Rsi;                  // offset: 0x150 (336)
  ULONGLONG Rbp;                  // offset: 0x158 (344)
  union {
    ULONGLONG ErrorCode;      // offset: 0x160 (352)
    ULONGLONG ExceptionFrame; // offset: 0x160 (352)
  };
  ULONGLONG Rip;   // offset: 0x168 (360)
  USHORT SegCs;    // offset: 0x170 (368)
  UCHAR Fill0;     // offset: 0x172 (370)
  UCHAR Logging;   // offset: 0x173 (371)
  USHORT Fill1[2]; // offset: 0x174 (372)
  ULONG EFlags;    // offset: 0x178 (376)
  ULONG Fill2;     // offset: 0x17c (380)
  ULONGLONG Rsp;   // offset: 0x180 (384)
  USHORT SegSs;    // offset: 0x188 (392)
  USHORT Fill3;    // offset: 0x18a (394)
  ULONG Fill4;     // offset: 0x18c (396)
};

// 0x70 (112) bytes
struct _KUMS_CONTEXT_HEADER {
  ULONGLONG P1Home;              // offset: 0x0 (0)
  ULONGLONG P2Home;              // offset: 0x8 (8)
  ULONGLONG P3Home;              // offset: 0x10 (16)
  ULONGLONG P4Home;              // offset: 0x18 (24)
  VOID *StackTop;                // offset: 0x20 (32)
  ULONGLONG StackSize;           // offset: 0x28 (40)
  ULONGLONG RspOffset;           // offset: 0x30 (48)
  ULONGLONG Rip;                 // offset: 0x38 (56)
  struct _XSAVE_FORMAT *FltSave; // offset: 0x40 (64)
  union {
    struct {
      ULONGLONG Volatile : 1;  // offset: 0x48 (72)
      ULONGLONG Reserved : 63; // offset: 0x48 (72)
    };
    ULONGLONG Flags; // offset: 0x48 (72)
  };
  struct _KTRAP_FRAME *TrapFrame;           // offset: 0x50 (80)
  struct _KEXCEPTION_FRAME *ExceptionFrame; // offset: 0x58 (88)
  struct _KTHREAD *SourceThread;            // offset: 0x60 (96)
  ULONGLONG Return;                         // offset: 0x68 (104)
};

// 0x40 (64) bytes
struct _KDPC {
  union {
    ULONG TargetInfoAsUlong; // offset: 0x0 (0)
    struct {
      UCHAR Type;             // offset: 0x0 (0)
      UCHAR Importance;       // offset: 0x1 (1)
      volatile USHORT Number; // offset: 0x2 (2)
    };
  };
  struct _SINGLE_LIST_ENTRY DpcListEntry; // offset: 0x8 (8)
  ULONGLONG ProcessorHistory;             // offset: 0x10 (16)
  VOID (*DeferredRoutine)
  (struct _KDPC *arg1, VOID *arg2, VOID *arg3, VOID *arg4); // offset: 0x18 (24)
  VOID *DeferredContext;                                    // offset: 0x20 (32)
  VOID *SystemArgument1;                                    // offset: 0x28 (40)
  VOID *SystemArgument2;                                    // offset: 0x30 (48)
  VOID *DpcData;                                            // offset: 0x38 (56)
};

// 0x88 (136) bytes
struct _WHEAP_WORK_QUEUE {
  struct _LIST_ENTRY ListHead;      // offset: 0x0 (0)
  ULONGLONG ListLock;               // offset: 0x10 (16)
  volatile LONG ItemCount;          // offset: 0x18 (24)
  struct _KDPC Dpc;                 // offset: 0x20 (32)
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x60 (96)
  VOID (*WorkRoutine)
  (struct _WHEAP_WORK_QUEUE *arg1,
   struct _LIST_ENTRY *arg2); // offset: 0x80 (128)
};

// 0x18 (24) bytes
struct _WHEAP_INFO_BLOCK {
  ULONG ErrorSourceCount;                             // offset: 0x0 (0)
  struct _WHEAP_ERROR_SOURCE_TABLE *ErrorSourceTable; // offset: 0x8 (8)
  struct _WHEAP_WORK_QUEUE *WorkQueue;                // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _KDPC_DATA {
  struct _KDPC_LIST DpcList;        // offset: 0x0 (0)
  ULONGLONG DpcLock;                // offset: 0x10 (16)
  volatile LONG DpcQueueDepth;      // offset: 0x18 (24)
  ULONG DpcCount;                   // offset: 0x1c (28)
  struct _KDPC *volatile ActiveDpc; // offset: 0x20 (32)
};

// 0x150 (336) bytes
struct _KENTROPY_TIMING_STATE {
  ULONG EntropyCount;        // offset: 0x0 (0)
  ULONG Buffer[64];          // offset: 0x4 (4)
  struct _KDPC Dpc;          // offset: 0x108 (264)
  ULONG LastDeliveredBuffer; // offset: 0x148 (328)
};

// 0x48 (72) bytes
struct _WAIT_CONTEXT_BLOCK {
  union {
    struct _KDEVICE_QUEUE_ENTRY WaitQueueEntry; // offset: 0x0 (0)
    struct {
      struct _LIST_ENTRY DmaWaitEntry; // offset: 0x0 (0)
      ULONG NumberOfChannels;          // offset: 0x10 (16)
      ULONG SyncCallback : 1;          // offset: 0x14 (20)
      ULONG DmaContext : 1;            // offset: 0x14 (20)
      ULONG ZeroMapRegisters : 1;      // offset: 0x14 (20)
      ULONG Reserved : 9;              // offset: 0x14 (20)
      ULONG NumberOfRemapPages : 20;   // offset: 0x14 (20)
    };
  };
  enum _IO_ALLOCATION_ACTION (*DeviceRoutine)(struct _DEVICE_OBJECT *arg1,
                                              struct _IRP *arg2, VOID *arg3,
                                              VOID *arg4); // offset: 0x18 (24)
  VOID *DeviceContext;                                     // offset: 0x20 (32)
  ULONG NumberOfMapRegisters;                              // offset: 0x28 (40)
  VOID *DeviceObject;                                      // offset: 0x30 (48)
  VOID *CurrentIrp;                                        // offset: 0x38 (56)
  struct _KDPC *BufferChainingDpc;                         // offset: 0x40 (64)
};

// 0x58 (88) bytes
struct _DMA_TRANSFER_CONTEXT_V1 {
  LONG DmaState;                  // offset: 0x0 (0)
  ULONG TransferState;            // offset: 0x4 (4)
  struct _WAIT_CONTEXT_BLOCK Wcb; // offset: 0x8 (8)
  VOID *HalWcb;                   // offset: 0x50 (80)
};

// 0x60 (96) bytes
struct _DMA_TRANSFER_CONTEXT {
  ULONG Version;                      // offset: 0x0 (0)
  struct _DMA_TRANSFER_CONTEXT_V1 V1; // offset: 0x8 (8)
};

// 0x8 (8) bytes
struct _MMPTE {
  union {
    ULONGLONG Long;                    // offset: 0x0 (0)
    volatile ULONGLONG VolatileLong;   // offset: 0x0 (0)
    struct _MMPTE_HARDWARE Hard;       // offset: 0x0 (0)
    struct _MMPTE_PROTOTYPE Proto;     // offset: 0x0 (0)
    struct _MMPTE_SOFTWARE Soft;       // offset: 0x0 (0)
    struct _MMPTE_TIMESTAMP TimeStamp; // offset: 0x0 (0)
    struct _MMPTE_TRANSITION Trans;    // offset: 0x0 (0)
    struct _MMPTE_SUBSECTION Subsect;  // offset: 0x0 (0)
    struct _MMPTE_LIST List;           // offset: 0x0 (0)

  } u; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _MMCLONE_BLOCK {
  struct _MMPTE ProtoPte;             // offset: 0x0 (0)
  ULONGLONG CrossPartitionReferences; // offset: 0x8 (8)
  union {
    volatile ULONGLONG CloneCommitCount; // offset: 0x10 (16)
    struct _MI_CLONE_BLOCK_FLAGS u1;     // offset: 0x10 (16)
  };
  volatile ULONGLONG CloneRefCount; // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _MI_DRIVER_VA {
  struct _MI_DRIVER_VA *Next; // offset: 0x0 (0)
  struct _MMPTE *PointerPte;  // offset: 0x8 (8)
  struct _RTL_BITMAP BitMap;  // offset: 0x10 (16)
  ULONG Hint;                 // offset: 0x20 (32)
  ULONG Flags;                // offset: 0x24 (36)
};

// 0x48 (72) bytes
struct _MI_PROCESS_STATE {
  VOID *SystemDllBase;                         // offset: 0x0 (0)
  ULONG ColorSeed;                             // offset: 0x8 (8)
  LONG RotatingUniprocessorNumber;             // offset: 0xc (12)
  union _LARGE_INTEGER CriticalSectionTimeout; // offset: 0x10 (16)
  struct _LIST_ENTRY ProcessList;              // offset: 0x18 (24)
  struct _MMPTE *SharedUserDataPte[2];         // offset: 0x28 (40)
  VOID *HypervisorSharedVa;                    // offset: 0x38 (56)
  ULONGLONG VadSecureCookie;                   // offset: 0x40 (64)
};

// 0x118 (280) bytes
struct _MI_DEBUGGER_STATE {
  UCHAR TransientWrite;     // offset: 0x0 (0)
  UCHAR CodePageEdited;     // offset: 0x1 (1)
  struct _MMPTE *DebugPte;  // offset: 0x8 (8)
  ULONG PoisonedTb;         // offset: 0x10 (16)
  volatile LONG InDebugger; // offset: 0x14 (20)
  VOID *volatile Pfns[32];  // offset: 0x18 (24)
};

// 0x18 (24) bytes
struct _MI_PTE_CHAIN_HEAD {
  struct _MMPTE Flink;    // offset: 0x0 (0)
  struct _MMPTE Blink;    // offset: 0x8 (8)
  struct _MMPTE *PteBase; // offset: 0x10 (16)
};

// 0x28 (40) bytes
struct _RTL_CRITICAL_SECTION {
  struct _RTL_CRITICAL_SECTION_DEBUG *DebugInfo; // offset: 0x0 (0)
  LONG LockCount;                                // offset: 0x8 (8)
  LONG RecursionCount;                           // offset: 0xc (12)
  VOID *OwningThread;                            // offset: 0x10 (16)
  VOID *LockSemaphore;                           // offset: 0x18 (24)
  ULONGLONG SpinCount;                           // offset: 0x20 (32)
};

// 0x30 (48) bytes
struct _RTL_CRITICAL_SECTION_DEBUG {
  USHORT Type;                                   // offset: 0x0 (0)
  USHORT CreatorBackTraceIndex;                  // offset: 0x2 (2)
  struct _RTL_CRITICAL_SECTION *CriticalSection; // offset: 0x8 (8)
  struct _LIST_ENTRY ProcessLocksList;           // offset: 0x10 (16)
  ULONG EntryCount;                              // offset: 0x20 (32)
  ULONG ContentionCount;                         // offset: 0x24 (36)
  ULONG Flags;                                   // offset: 0x28 (40)
  USHORT CreatorBackTraceIndexHigh;              // offset: 0x2c (44)
  USHORT SpareUSHORT;                            // offset: 0x2e (46)
};

// 0x50 (80) bytes
struct _IO_MINI_COMPLETION_PACKET_USER {
  struct _LIST_ENTRY ListEntry;  // offset: 0x0 (0)
  ULONG PacketType;              // offset: 0x10 (16)
  VOID *KeyContext;              // offset: 0x18 (24)
  VOID *ApcContext;              // offset: 0x20 (32)
  LONG IoStatus;                 // offset: 0x28 (40)
  ULONGLONG IoStatusInformation; // offset: 0x30 (48)
  VOID (*MiniPacketCallback)
  (struct _IO_MINI_COMPLETION_PACKET_USER *arg1,
   VOID *arg2);    // offset: 0x38 (56)
  VOID *Context;   // offset: 0x40 (64)
  UCHAR Allocated; // offset: 0x48 (72)
};

// 0x18 (24) bytes
struct _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY {
  struct _SINGLE_LIST_ENTRY ListEntry;                 // offset: 0x0 (0)
  struct _IO_MINI_COMPLETION_PACKET_USER *Packet;      // offset: 0x8 (8)
  struct _ALPC_COMPLETION_PACKET_LOOKASIDE *Lookaside; // offset: 0x10 (16)
};

// 0x50 (80) bytes
struct _ALPC_COMPLETION_PACKET_LOOKASIDE {
  ULONGLONG Lock;                                          // offset: 0x0 (0)
  ULONG Size;                                              // offset: 0x8 (8)
  ULONG ActiveCount;                                       // offset: 0xc (12)
  ULONG PendingNullCount;                                  // offset: 0x10 (16)
  ULONG PendingCheckCompletionListCount;                   // offset: 0x14 (20)
  ULONG PendingDelete;                                     // offset: 0x18 (24)
  struct _SINGLE_LIST_ENTRY FreeListHead;                  // offset: 0x20 (32)
  VOID *CompletionPort;                                    // offset: 0x28 (40)
  VOID *CompletionKey;                                     // offset: 0x30 (48)
  struct _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY Entry[1]; // offset: 0x38 (56)
};

// 0x10 (16) bytes
struct _OWNER_ENTRY {
  ULONGLONG OwnerThread; // offset: 0x0 (0)
  union {
    struct {
      ULONG IoPriorityBoosted : 1;    // offset: 0x8 (8)
      ULONG OwnerReferenced : 1;      // offset: 0x8 (8)
      ULONG IoQoSPriorityBoosted : 1; // offset: 0x8 (8)
      ULONG OwnerCount : 29;          // offset: 0x8 (8)
    };
    ULONG TableSize; // offset: 0x8 (8)
  };
};

// 0x4d0 (1232) bytes
struct _CONTEXT {
  ULONGLONG P1Home;   // offset: 0x0 (0)
  ULONGLONG P2Home;   // offset: 0x8 (8)
  ULONGLONG P3Home;   // offset: 0x10 (16)
  ULONGLONG P4Home;   // offset: 0x18 (24)
  ULONGLONG P5Home;   // offset: 0x20 (32)
  ULONGLONG P6Home;   // offset: 0x28 (40)
  ULONG ContextFlags; // offset: 0x30 (48)
  ULONG MxCsr;        // offset: 0x34 (52)
  USHORT SegCs;       // offset: 0x38 (56)
  USHORT SegDs;       // offset: 0x3a (58)
  USHORT SegEs;       // offset: 0x3c (60)
  USHORT SegFs;       // offset: 0x3e (62)
  USHORT SegGs;       // offset: 0x40 (64)
  USHORT SegSs;       // offset: 0x42 (66)
  ULONG EFlags;       // offset: 0x44 (68)
  ULONGLONG Dr0;      // offset: 0x48 (72)
  ULONGLONG Dr1;      // offset: 0x50 (80)
  ULONGLONG Dr2;      // offset: 0x58 (88)
  ULONGLONG Dr3;      // offset: 0x60 (96)
  ULONGLONG Dr6;      // offset: 0x68 (104)
  ULONGLONG Dr7;      // offset: 0x70 (112)
  ULONGLONG Rax;      // offset: 0x78 (120)
  ULONGLONG Rcx;      // offset: 0x80 (128)
  ULONGLONG Rdx;      // offset: 0x88 (136)
  ULONGLONG Rbx;      // offset: 0x90 (144)
  ULONGLONG Rsp;      // offset: 0x98 (152)
  ULONGLONG Rbp;      // offset: 0xa0 (160)
  ULONGLONG Rsi;      // offset: 0xa8 (168)
  ULONGLONG Rdi;      // offset: 0xb0 (176)
  ULONGLONG R8;       // offset: 0xb8 (184)
  ULONGLONG R9;       // offset: 0xc0 (192)
  ULONGLONG R10;      // offset: 0xc8 (200)
  ULONGLONG R11;      // offset: 0xd0 (208)
  ULONGLONG R12;      // offset: 0xd8 (216)
  ULONGLONG R13;      // offset: 0xe0 (224)
  ULONGLONG R14;      // offset: 0xe8 (232)
  ULONGLONG R15;      // offset: 0xf0 (240)
  ULONGLONG Rip;      // offset: 0xf8 (248)
  union {
    struct _XSAVE_FORMAT FltSave; // offset: 0x100 (256)
    struct {
      struct _M128A Header[2]; // offset: 0x100 (256)
      struct _M128A Legacy[8]; // offset: 0x120 (288)
      struct _M128A Xmm0;      // offset: 0x1a0 (416)
      struct _M128A Xmm1;      // offset: 0x1b0 (432)
      struct _M128A Xmm2;      // offset: 0x1c0 (448)
      struct _M128A Xmm3;      // offset: 0x1d0 (464)
      struct _M128A Xmm4;      // offset: 0x1e0 (480)
      struct _M128A Xmm5;      // offset: 0x1f0 (496)
      struct _M128A Xmm6;      // offset: 0x200 (512)
      struct _M128A Xmm7;      // offset: 0x210 (528)
      struct _M128A Xmm8;      // offset: 0x220 (544)
      struct _M128A Xmm9;      // offset: 0x230 (560)
      struct _M128A Xmm10;     // offset: 0x240 (576)
      struct _M128A Xmm11;     // offset: 0x250 (592)
      struct _M128A Xmm12;     // offset: 0x260 (608)
      struct _M128A Xmm13;     // offset: 0x270 (624)
      struct _M128A Xmm14;     // offset: 0x280 (640)
      struct _M128A Xmm15;     // offset: 0x290 (656)
    };
  };
  struct _M128A VectorRegister[26]; // offset: 0x300 (768)
  ULONGLONG VectorControl;          // offset: 0x4a0 (1184)
  ULONGLONG DebugControl;           // offset: 0x4a8 (1192)
  ULONGLONG LastBranchToRip;        // offset: 0x4b0 (1200)
  ULONGLONG LastBranchFromRip;      // offset: 0x4b8 (1208)
  ULONGLONG LastExceptionToRip;     // offset: 0x4c0 (1216)
  ULONGLONG LastExceptionFromRip;   // offset: 0x4c8 (1224)
};

// 0x6d0 (1744) bytes
struct _HEAP_FAILURE_INFORMATION {
  ULONG Version;                                // offset: 0x0 (0)
  ULONG StructureSize;                          // offset: 0x4 (4)
  enum _HEAP_FAILURE_TYPE FailureType;          // offset: 0x8 (8)
  VOID *HeapAddress;                            // offset: 0x10 (16)
  VOID *Address;                                // offset: 0x18 (24)
  VOID *Param1;                                 // offset: 0x20 (32)
  VOID *Param2;                                 // offset: 0x28 (40)
  VOID *Param3;                                 // offset: 0x30 (48)
  VOID *PreviousBlock;                          // offset: 0x38 (56)
  VOID *NextBlock;                              // offset: 0x40 (64)
  struct _FAKE_HEAP_ENTRY ExpectedDecodedEntry; // offset: 0x48 (72)
  VOID *StackTrace[32];                         // offset: 0x58 (88)
  UCHAR HeapMajorVersion;                       // offset: 0x158 (344)
  UCHAR HeapMinorVersion;                       // offset: 0x159 (345)
  struct _EXCEPTION_RECORD ExceptionRecord;     // offset: 0x160 (352)
  struct _CONTEXT ContextRecord;                // offset: 0x200 (512)
};

// 0x38 (56) bytes
struct _RTLP_HP_HEAP_GLOBALS {
  ULONGLONG HeapKey;                                  // offset: 0x0 (0)
  ULONGLONG LfhKey;                                   // offset: 0x8 (8)
  struct _HEAP_FAILURE_INFORMATION *FailureInfo;      // offset: 0x10 (16)
  struct _RTL_HEAP_MEMORY_LIMIT_DATA CommitLimitData; // offset: 0x18 (24)
};

// 0x520 (1312) bytes
struct _RTL_UMS_CONTEXT {
  struct _SINGLE_LIST_ENTRY Link; // offset: 0x0 (0)
  struct _CONTEXT Context;        // offset: 0x10 (16)
  VOID *Teb;                      // offset: 0x4e0 (1248)
  VOID *UserContext;              // offset: 0x4e8 (1256)
  union {
    struct {
      volatile ULONG ScheduledThread : 1;         // offset: 0x4f0 (1264)
      volatile ULONG Suspended : 1;               // offset: 0x4f0 (1264)
      volatile ULONG VolatileContext : 1;         // offset: 0x4f0 (1264)
      volatile ULONG Terminated : 1;              // offset: 0x4f0 (1264)
      volatile ULONG DebugActive : 1;             // offset: 0x4f0 (1264)
      volatile ULONG RunningOnSelfThread : 1;     // offset: 0x4f0 (1264)
      volatile ULONG DenyRunningOnSelfThread : 1; // offset: 0x4f0 (1264)
    };
    volatile LONG Flags; // offset: 0x4f0 (1264)
  };
  union {
    struct {
      volatile ULONGLONG KernelUpdateLock : 2; // offset: 0x4f8 (1272)
      volatile ULONGLONG PrimaryClientID : 62; // offset: 0x4f8 (1272)
    };
    volatile ULONGLONG ContextLock; // offset: 0x4f8 (1272)
  };
  struct _RTL_UMS_CONTEXT *PrimaryUmsContext; // offset: 0x500 (1280)
  ULONG SwitchCount;                          // offset: 0x508 (1288)
  ULONG KernelYieldCount;                     // offset: 0x50c (1292)
  ULONG MixedYieldCount;                      // offset: 0x510 (1296)
  ULONG YieldCount;                           // offset: 0x514 (1300)
};

// 0x5c0 (1472) bytes
struct _KPROCESSOR_STATE {
  struct _KSPECIAL_REGISTERS SpecialRegisters; // offset: 0x0 (0)
  struct _CONTEXT ContextFrame;                // offset: 0xf0 (240)
};

// 0x10 (16) bytes
struct _EXCEPTION_POINTERS {
  struct _EXCEPTION_RECORD *ExceptionRecord; // offset: 0x0 (0)
  struct _CONTEXT *ContextRecord;            // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _EXCEPTION_REGISTRATION_RECORD {
  struct _EXCEPTION_REGISTRATION_RECORD *Next; // offset: 0x0 (0)
  enum _EXCEPTION_DISPOSITION (*Handler)(struct _EXCEPTION_RECORD *arg1,
                                         VOID *arg2, struct _CONTEXT *arg3,
                                         VOID *arg4); // offset: 0x8 (8)
};

// 0x60 (96) bytes
struct _POP_FX_ACTIVE_TIME_ACCOUNTING {
  ULONGLONG Total;        // offset: 0x0 (0)
  ULONGLONG Unattributed; // offset: 0x8 (8)
  ULONGLONG Buckets[5];   // offset: 0x10 (16)
  ULONGLONG PerBucket[5]; // offset: 0x38 (56)
};

// 0xe0 (224) bytes
struct _POP_FX_ACCOUNTING {
  ULONGLONG Lock;           // offset: 0x0 (0)
  UCHAR Active;             // offset: 0x8 (8)
  ULONG DripsRequiredState; // offset: 0xc (12)
  LONG Level;               // offset: 0x10 (16)
  LONGLONG ActiveStamp;     // offset: 0x18 (24)
  struct _POP_FX_ACTIVE_TIME_ACCOUNTING
      CsActiveTimeAccounting; // offset: 0x20 (32)
  struct _POP_FX_ACTIVE_TIME_ACCOUNTING
      CsCriticalActiveTimeAccounting; // offset: 0x80 (128)
};

// 0x3e0 (992) bytes
struct PO_MEMORY_IMAGE {
  ULONG Signature;                                 // offset: 0x0 (0)
  ULONG ImageType;                                 // offset: 0x4 (4)
  ULONG CheckSum;                                  // offset: 0x8 (8)
  ULONG LengthSelf;                                // offset: 0xc (12)
  ULONGLONG PageSelf;                              // offset: 0x10 (16)
  ULONG PageSize;                                  // offset: 0x18 (24)
  union _LARGE_INTEGER SystemTime;                 // offset: 0x20 (32)
  ULONGLONG InterruptTime;                         // offset: 0x28 (40)
  ULONGLONG FeatureFlags;                          // offset: 0x30 (48)
  UCHAR HiberFlags;                                // offset: 0x38 (56)
  UCHAR HiberSimulateFlags;                        // offset: 0x39 (57)
  UCHAR spare[2];                                  // offset: 0x3a (58)
  ULONG NoHiberPtes;                               // offset: 0x3c (60)
  ULONGLONG HiberVa;                               // offset: 0x40 (64)
  ULONG NoFreePages;                               // offset: 0x48 (72)
  ULONG FreeMapCheck;                              // offset: 0x4c (76)
  ULONG WakeCheck;                                 // offset: 0x50 (80)
  ULONGLONG NumPagesForLoader;                     // offset: 0x58 (88)
  ULONGLONG FirstSecureRestorePage;                // offset: 0x60 (96)
  ULONGLONG FirstBootRestorePage;                  // offset: 0x68 (104)
  ULONGLONG FirstKernelRestorePage;                // offset: 0x70 (112)
  ULONGLONG FirstChecksumRestorePage;              // offset: 0x78 (120)
  ULONGLONG NoChecksumEntries;                     // offset: 0x80 (128)
  struct _PO_HIBER_PERF PerfInfo;                  // offset: 0x88 (136)
  ULONG FirmwareRuntimeInformationPages;           // offset: 0x280 (640)
  ULONGLONG FirmwareRuntimeInformation[1];         // offset: 0x288 (648)
  ULONG SpareUlong;                                // offset: 0x290 (656)
  ULONG NoBootLoaderLogPages;                      // offset: 0x294 (660)
  ULONGLONG BootLoaderLogPages[24];                // offset: 0x298 (664)
  ULONG NotUsed;                                   // offset: 0x358 (856)
  ULONG ResumeContextCheck;                        // offset: 0x35c (860)
  ULONG ResumeContextPages;                        // offset: 0x360 (864)
  UCHAR Hiberboot;                                 // offset: 0x364 (868)
  UCHAR SecureLaunched;                            // offset: 0x365 (869)
  UCHAR SecureBoot;                                // offset: 0x366 (870)
  ULONGLONG HvPageTableRoot;                       // offset: 0x368 (872)
  ULONGLONG HvEntryPoint;                          // offset: 0x370 (880)
  ULONGLONG HvReservedTransitionAddress;           // offset: 0x378 (888)
  ULONGLONG HvReservedTransitionAddressSize;       // offset: 0x380 (896)
  ULONGLONG BootFlags;                             // offset: 0x388 (904)
  ULONGLONG RestoreProcessorStateRoutine;          // offset: 0x390 (912)
  ULONGLONG HighestPhysicalPage;                   // offset: 0x398 (920)
  ULONGLONG BitlockerKeyPfns[4];                   // offset: 0x3a0 (928)
  ULONG HardwareSignature;                         // offset: 0x3c0 (960)
  union _LARGE_INTEGER SMBiosTablePhysicalAddress; // offset: 0x3c8 (968)
  ULONG SMBiosTableLength;                         // offset: 0x3d0 (976)
  UCHAR SMBiosMajorVersion;                        // offset: 0x3d4 (980)
  UCHAR SMBiosMinorVersion;                        // offset: 0x3d5 (981)
  UCHAR HiberResumeXhciHandoffSkip;                // offset: 0x3d6 (982)
  UCHAR InitializeUSBCore;                         // offset: 0x3d7 (983)
  UCHAR ValidUSBCoreId;                            // offset: 0x3d8 (984)
  UCHAR USBCoreId;                                 // offset: 0x3d9 (985)
  UCHAR SkipMemoryMapValidation;                   // offset: 0x3da (986)
};

// 0x38 (56) bytes
struct _HEAP_LFH_SUBSEGMENT {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
  union {
    struct _HEAP_LFH_SUBSEGMENT_OWNER *Owner;        // offset: 0x10 (16)
    union _HEAP_LFH_SUBSEGMENT_DELAY_FREE DelayFree; // offset: 0x10 (16)
  };
  ULONGLONG CommitLock; // offset: 0x18 (24)
  union {
    struct {
      USHORT FreeCount;  // offset: 0x20 (32)
      USHORT BlockCount; // offset: 0x22 (34)
    };
    volatile SHORT InterlockedShort; // offset: 0x20 (32)
    volatile LONG InterlockedLong;   // offset: 0x20 (32)
  };
  USHORT FreeHint;                                          // offset: 0x24 (36)
  UCHAR Location;                                           // offset: 0x26 (38)
  UCHAR WitheldBlockCount;                                  // offset: 0x27 (39)
  struct _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS BlockOffsets; // offset: 0x28 (40)
  UCHAR CommitUnitShift;                                    // offset: 0x2c (44)
  UCHAR CommitUnitCount;                                    // offset: 0x2d (45)
  USHORT CommitStateOffset;                                 // offset: 0x2e (46)
  ULONGLONG BlockBitmap[1];                                 // offset: 0x30 (48)
};

// 0x10 (16) bytes
struct _PS_TRUSTLET_ATTRIBUTE_DATA {
  struct _PS_TRUSTLET_ATTRIBUTE_HEADER Header; // offset: 0x0 (0)
  ULONGLONG Data[1];                           // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _PS_TRUSTLET_CREATE_ATTRIBUTES {
  ULONGLONG TrustletIdentity;                       // offset: 0x0 (0)
  struct _PS_TRUSTLET_ATTRIBUTE_DATA Attributes[1]; // offset: 0x8 (8)
};

// 0x28 (40) bytes
struct _PPM_CONCURRENCY_ACCOUNTING {
  ULONGLONG Lock;               // offset: 0x0 (0)
  ULONG Processors;             // offset: 0x8 (8)
  ULONG ActiveProcessors;       // offset: 0xc (12)
  ULONGLONG LastUpdateTime;     // offset: 0x10 (16)
  ULONGLONG TotalTime;          // offset: 0x18 (24)
  ULONGLONG AccumulatedTime[1]; // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _GROUP_AFFINITY {
  ULONGLONG Mask;     // offset: 0x0 (0)
  USHORT Group;       // offset: 0x8 (8)
  USHORT Reserved[3]; // offset: 0xa (10)
};

// 0x58 (88) bytes
struct _INTERRUPT_VECTOR_DATA {
  enum INTERRUPT_CONNECTION_TYPE Type;           // offset: 0x0 (0)
  ULONG Vector;                                  // offset: 0x4 (4)
  UCHAR Irql;                                    // offset: 0x8 (8)
  enum _KINTERRUPT_POLARITY Polarity;            // offset: 0xc (12)
  enum _KINTERRUPT_MODE Mode;                    // offset: 0x10 (16)
  struct _GROUP_AFFINITY TargetProcessors;       // offset: 0x18 (24)
  struct _INTERRUPT_REMAPPING_INFO IntRemapInfo; // offset: 0x28 (40)
  struct {
    ULONG Gsiv;               // offset: 0x0 (0)
    ULONG WakeInterrupt : 1;  // offset: 0x4 (4)
    ULONG ReservedFlags : 31; // offset: 0x4 (4)
  } ControllerInput;          // offset: 0x38 (56)
  ULONGLONG HvDeviceId;       // offset: 0x40 (64)
  union {
    struct {
      union _LARGE_INTEGER Address; // offset: 0x0 (0)
      ULONG DataPayload;            // offset: 0x8 (8)
    } XapicMessage;                 // offset: 0x48 (72)
    struct {
      struct _INTERRUPT_HT_INTR_INFO IntrInfo; // offset: 0x0 (0)
    } Hypertransport;                          // offset: 0x48 (72)
    struct {
      union _LARGE_INTEGER Address; // offset: 0x0 (0)
      ULONG DataPayload;            // offset: 0x8 (8)
    } GenericMessage;               // offset: 0x48 (72)
    struct {
      enum HAL_APIC_DESTINATION_MODE DestinationMode; // offset: 0x0 (0)
    } MessageRequest;                                 // offset: 0x48 (72)
  };
};

// 0x60 (96) bytes
struct _INTERRUPT_CONNECTION_DATA {
  ULONG Count;                              // offset: 0x0 (0)
  struct _INTERRUPT_VECTOR_DATA Vectors[1]; // offset: 0x8 (8)
};

// 0x180 (384) bytes
struct _KNODE {
  ULONGLONG IdleNonParkedCpuSet; // offset: 0x0 (0)
  ULONGLONG IdleSmtSet;          // offset: 0x8 (8)
  ULONGLONG NonPairedSmtSet;     // offset: 0x10 (16)
  ULONGLONG IdleCpuSet;          // offset: 0x18 (24)
  ULONGLONG DeepIdleSet;         // offset: 0x40 (64)
  ULONGLONG IdleConstrainedSet;  // offset: 0x48 (72)
  ULONGLONG NonParkedSet;        // offset: 0x50 (80)
  ULONGLONG SoftParkedSet;       // offset: 0x58 (88)
  ULONGLONG NonIsrTargetedSet;   // offset: 0x60 (96)
  LONG ParkLock;                 // offset: 0x68 (104)
  USHORT ThreadSeed;             // offset: 0x6c (108)
  USHORT ProcessSeed;            // offset: 0x6e (110)
  ULONG SiblingMask;             // offset: 0x80 (128)
  union {
    struct _GROUP_AFFINITY Affinity; // offset: 0x88 (136)
    struct {
      UCHAR AffinityFill[10];   // offset: 0x88 (136)
      USHORT NodeNumber;        // offset: 0x92 (146)
      USHORT PrimaryNodeNumber; // offset: 0x94 (148)
      USHORT Spare0;            // offset: 0x96 (150)
    };
  };
  ULONGLONG SharedReadyQueueMask;              // offset: 0x98 (152)
  ULONGLONG StrideMask;                        // offset: 0xa0 (160)
  ULONG ProximityId;                           // offset: 0xa8 (168)
  ULONG Lowest;                                // offset: 0xac (172)
  ULONG Highest;                               // offset: 0xb0 (176)
  UCHAR MaximumProcessors;                     // offset: 0xb4 (180)
  struct _flags Flags;                         // offset: 0xb5 (181)
  UCHAR Spare10;                               // offset: 0xb6 (182)
  struct _KHETERO_PROCESSOR_SET HeteroSets[5]; // offset: 0xb8 (184)
  ULONGLONG PpmConfiguredQosSets[5];           // offset: 0x130 (304)
  ULONGLONG Spare11;                           // offset: 0x158 (344)
  union _KQOS_GROUPING_SETS QosGroupingSets;   // offset: 0x160 (352)
  ULONGLONG QosPreemptibleSet;                 // offset: 0x170 (368)
  ULONGLONG LLCLeaders;                        // offset: 0x178 (376)
};

// 0x1c0 (448) bytes
struct _ENODE {
  struct _KNODE Ncb;                               // offset: 0x0 (0)
  struct _WORK_QUEUE_ITEM HotAddProcessorWorkItem; // offset: 0x180 (384)
};

// 0x2e0 (736) bytes
struct _EX_WORK_QUEUE {
  struct _KPRIQUEUE WorkPriQueue;        // offset: 0x0 (0)
  struct _EX_PARTITION *Partition;       // offset: 0x2b0 (688)
  struct _ENODE *Node;                   // offset: 0x2b8 (696)
  volatile ULONG WorkItemsProcessed;     // offset: 0x2c0 (704)
  ULONG WorkItemsProcessedLastPass;      // offset: 0x2c4 (708)
  volatile LONG ThreadCount;             // offset: 0x2c8 (712)
  LONG MinThreads : 31;                  // offset: 0x2cc (716)
  volatile ULONG TryFailed : 1;          // offset: 0x2cc (716)
  LONG MaxThreads;                       // offset: 0x2d0 (720)
  enum _EXQUEUEINDEX QueueIndex;         // offset: 0x2d4 (724)
  struct _KEVENT *AllThreadsExitedEvent; // offset: 0x2d8 (728)
};

// 0x8 (8) bytes
struct _MI_SESSION_DRIVER_UNLOAD {
  union {
    VOID (*Function)(struct _DRIVER_OBJECT *arg1); // offset: 0x0 (0)
    ULONGLONG FunctionValue;                       // offset: 0x0 (0)
  };
};

// 0x20 (32) bytes
struct _MMSUPPORT_AGGREGATION {
  ULONG PageFaultCount;         // offset: 0x0 (0)
  ULONGLONG WorkingSetSize;     // offset: 0x8 (8)
  ULONGLONG WorkingSetLeafSize; // offset: 0x10 (16)
  ULONGLONG PeakWorkingSetSize; // offset: 0x18 (24)
};

// 0x28 (40) bytes
struct _MMWSL_INSTANCE {
  struct _MMPTE *NextPteToTrim;        // offset: 0x0 (0)
  struct _MMPTE *NextPteToAge;         // offset: 0x8 (8)
  struct _MMPTE *NextPteToAccessClear; // offset: 0x10 (16)
  ULONG LastAccessClearingRemainder;   // offset: 0x18 (24)
  ULONG LastAgingRemainder;            // offset: 0x1c (28)
  ULONGLONG LockedEntries;             // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _RTL_BALANCED_NODE {
  union {
    struct _RTL_BALANCED_NODE *Children[2]; // offset: 0x0 (0)
    struct {
      struct _RTL_BALANCED_NODE *Left;  // offset: 0x0 (0)
      struct _RTL_BALANCED_NODE *Right; // offset: 0x8 (8)
    };
  };
  union {
    struct {
      UCHAR Red : 1;     // offset: 0x10 (16)
      UCHAR Balance : 2; // offset: 0x10 (16)
    };
    ULONGLONG ParentValue; // offset: 0x10 (16)
  };
};

// 0x120 (288) bytes
struct _LDR_DATA_TABLE_ENTRY {
  struct _LIST_ENTRY InLoadOrderLinks;           // offset: 0x0 (0)
  struct _LIST_ENTRY InMemoryOrderLinks;         // offset: 0x10 (16)
  struct _LIST_ENTRY InInitializationOrderLinks; // offset: 0x20 (32)
  VOID *DllBase;                                 // offset: 0x30 (48)
  VOID *EntryPoint;                              // offset: 0x38 (56)
  ULONG SizeOfImage;                             // offset: 0x40 (64)
  struct _UNICODE_STRING FullDllName;            // offset: 0x48 (72)
  struct _UNICODE_STRING BaseDllName;            // offset: 0x58 (88)
  union {
    UCHAR FlagGroup[4]; // offset: 0x68 (104)
    ULONG Flags;        // offset: 0x68 (104)
    struct {
      ULONG PackagedBinary : 1;          // offset: 0x68 (104)
      ULONG MarkedForRemoval : 1;        // offset: 0x68 (104)
      ULONG ImageDll : 1;                // offset: 0x68 (104)
      ULONG LoadNotificationsSent : 1;   // offset: 0x68 (104)
      ULONG TelemetryEntryProcessed : 1; // offset: 0x68 (104)
      ULONG ProcessStaticImport : 1;     // offset: 0x68 (104)
      ULONG InLegacyLists : 1;           // offset: 0x68 (104)
      ULONG InIndexes : 1;               // offset: 0x68 (104)
      ULONG ShimDll : 1;                 // offset: 0x68 (104)
      ULONG InExceptionTable : 1;        // offset: 0x68 (104)
      ULONG ReservedFlags1 : 2;          // offset: 0x68 (104)
      ULONG LoadInProgress : 1;          // offset: 0x68 (104)
      ULONG LoadConfigProcessed : 1;     // offset: 0x68 (104)
      ULONG EntryProcessed : 1;          // offset: 0x68 (104)
      ULONG ProtectDelayLoad : 1;        // offset: 0x68 (104)
      ULONG ReservedFlags3 : 2;          // offset: 0x68 (104)
      ULONG DontCallForThreads : 1;      // offset: 0x68 (104)
      ULONG ProcessAttachCalled : 1;     // offset: 0x68 (104)
      ULONG ProcessAttachFailed : 1;     // offset: 0x68 (104)
      ULONG CorDeferredValidate : 1;     // offset: 0x68 (104)
      ULONG CorImage : 1;                // offset: 0x68 (104)
      ULONG DontRelocate : 1;            // offset: 0x68 (104)
      ULONG CorILOnly : 1;               // offset: 0x68 (104)
      ULONG ChpeImage : 1;               // offset: 0x68 (104)
      ULONG ReservedFlags5 : 2;          // offset: 0x68 (104)
      ULONG Redirected : 1;              // offset: 0x68 (104)
      ULONG ReservedFlags6 : 2;          // offset: 0x68 (104)
      ULONG CompatDatabaseProcessed : 1; // offset: 0x68 (104)
    };
  };
  USHORT ObsoleteLoadCount;                                // offset: 0x6c (108)
  USHORT TlsIndex;                                         // offset: 0x6e (110)
  struct _LIST_ENTRY HashLinks;                            // offset: 0x70 (112)
  ULONG TimeDateStamp;                                     // offset: 0x80 (128)
  struct _ACTIVATION_CONTEXT *EntryPointActivationContext; // offset: 0x88 (136)
  VOID *Lock;                                              // offset: 0x90 (144)
  struct _LDR_DDAG_NODE *DdagNode;                         // offset: 0x98 (152)
  struct _LIST_ENTRY NodeModuleLink;                       // offset: 0xa0 (160)
  struct _LDRP_LOAD_CONTEXT *LoadContext;                  // offset: 0xb0 (176)
  VOID *ParentDllBase;                                     // offset: 0xb8 (184)
  VOID *SwitchBackContext;                                 // offset: 0xc0 (192)
  struct _RTL_BALANCED_NODE BaseAddressIndexNode;          // offset: 0xc8 (200)
  struct _RTL_BALANCED_NODE MappingInfoIndexNode;          // offset: 0xe0 (224)
  ULONGLONG OriginalBase;                                  // offset: 0xf8 (248)
  union _LARGE_INTEGER LoadTime;        // offset: 0x100 (256)
  ULONG BaseNameHashValue;              // offset: 0x108 (264)
  enum _LDR_DLL_LOAD_REASON LoadReason; // offset: 0x10c (268)
  ULONG ImplicitPathOptions;            // offset: 0x110 (272)
  ULONG ReferenceCount;                 // offset: 0x114 (276)
  ULONG DependentLoadFlags;             // offset: 0x118 (280)
  UCHAR SigningLevel;                   // offset: 0x11c (284)
};

// 0x20 (32) bytes
struct _ETW_PROVIDER_TRAITS {
  struct _RTL_BALANCED_NODE Node; // offset: 0x0 (0)
  ULONG ReferenceCount;           // offset: 0x18 (24)
  UCHAR Traits[1];                // offset: 0x1c (28)
};

// 0x40 (64) bytes
struct _SECTION {
  struct _RTL_BALANCED_NODE SectionNode; // offset: 0x0 (0)
  ULONGLONG StartingVpn;                 // offset: 0x18 (24)
  ULONGLONG EndingVpn;                   // offset: 0x20 (32)
  union {
    struct _CONTROL_AREA *ControlArea;   // offset: 0x28 (40)
    struct _FILE_OBJECT *FileObject;     // offset: 0x28 (40)
    ULONGLONG RemoteImageFileObject : 1; // offset: 0x28 (40)
    ULONGLONG RemoteDataFileObject : 1;  // offset: 0x28 (40)

  } u1;                    // offset: 0x28 (40)
  ULONGLONG SizeOfSection; // offset: 0x30 (48)
  union {
    ULONG LongFlags;               // offset: 0x38 (56)
    struct _MMSECTION_FLAGS Flags; // offset: 0x38 (56)

  } u;                              // offset: 0x38 (56)
  ULONG InitialPageProtection : 12; // offset: 0x3c (60)
  ULONG SessionId : 19;             // offset: 0x3c (60)
  ULONG NoValidationNeeded : 1;     // offset: 0x3c (60)
};

// 0x28 (40) bytes
struct _MI_ACCESS_VIOLATION_RANGE {
  struct _RTL_BALANCED_NODE Node; // offset: 0x0 (0)
  VOID *Va;                       // offset: 0x18 (24)
  VOID *EndVaInclusive;           // offset: 0x20 (32)
};

// 0xa8 (168) bytes
struct _MI_POOL_STATE {
  ULONGLONG MaximumNonPagedPoolThreshold;         // offset: 0x0 (0)
  volatile ULONGLONG AllocatedNonPagedPool;       // offset: 0x8 (8)
  volatile ULONGLONG AllocatedSecureNonPagedPool; // offset: 0x10 (16)
  struct _SINGLE_LIST_ENTRY BadPoolHead;          // offset: 0x18 (24)
  ULONG HighEventSets;                            // offset: 0x20 (32)
  UCHAR HighEventSetsValid;                       // offset: 0x24 (36)
  ULONGLONG LowPagedPoolThreshold;                // offset: 0x28 (40)
  ULONGLONG HighPagedPoolThreshold;               // offset: 0x30 (48)
  volatile LONG PermittedFaultsLock;              // offset: 0x38 (56)
  struct _RTL_AVL_TREE PermittedFaultsTree;       // offset: 0x40 (64)
  struct _MI_ACCESS_VIOLATION_RANGE
      PermittedFaultsInitialNode[2]; // offset: 0x48 (72)
  ULONGLONG TotalPagedPoolQuota;     // offset: 0x98 (152)
  ULONGLONG TotalNonPagedPoolQuota;  // offset: 0xa0 (160)
};

// 0x28 (40) bytes
struct _HEAP_LARGE_ALLOC_DATA {
  struct _RTL_BALANCED_NODE TreeNode; // offset: 0x0 (0)
  union {
    ULONGLONG VirtualAddress;   // offset: 0x18 (24)
    ULONGLONG UnusedBytes : 16; // offset: 0x18 (24)
  };
  ULONGLONG ExtraPresent : 1;       // offset: 0x20 (32)
  ULONGLONG GuardPageCount : 1;     // offset: 0x20 (32)
  ULONGLONG GuardPageAlignment : 6; // offset: 0x20 (32)
  ULONGLONG Spare : 4;              // offset: 0x20 (32)
  ULONGLONG AllocatedPages : 52;    // offset: 0x20 (32)
};

// 0x20 (32) bytes
struct _HEAP_PAGE_RANGE_DESCRIPTOR {
  union {
    struct _RTL_BALANCED_NODE TreeNode; // offset: 0x0 (0)
    struct {
      ULONG TreeSignature;     // offset: 0x0 (0)
      ULONG UnusedBytes;       // offset: 0x4 (4)
      USHORT ExtraPresent : 1; // offset: 0x8 (8)
      USHORT Spare0 : 15;      // offset: 0x8 (8)
    };
  };
  volatile UCHAR RangeFlags; // offset: 0x18 (24)
  UCHAR CommittedPageCount;  // offset: 0x19 (25)
  USHORT Spare;              // offset: 0x1a (26)
  union {
    struct _HEAP_DESCRIPTOR_KEY Key; // offset: 0x1c (28)
    struct {
      UCHAR Align[3]; // offset: 0x1c (28)
      union {
        UCHAR UnitOffset; // offset: 0x1f (31)
        UCHAR UnitSize;   // offset: 0x1f (31)
      };
    };
  };
};

// 0x2000 (8192) bytes
union _HEAP_PAGE_SEGMENT {
  struct {
    struct _LIST_ENTRY ListEntry; // offset: 0x0 (0)
    ULONGLONG Signature;          // offset: 0x10 (16)
  };
  struct {
    union _HEAP_SEGMENT_MGR_COMMIT_STATE
        *SegmentCommitState; // offset: 0x18 (24)
    UCHAR UnusedWatermark;   // offset: 0x20 (32)
  };
  struct _HEAP_PAGE_RANGE_DESCRIPTOR DescArray[256]; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _HEAP_VS_CHUNK_FREE_HEADER {
  union {
    struct _HEAP_VS_CHUNK_HEADER Header; // offset: 0x0 (0)
    struct {
      ULONGLONG OverlapsHeader;       // offset: 0x0 (0)
      struct _RTL_BALANCED_NODE Node; // offset: 0x8 (8)
    };
  };
};

// 0x30 (48) bytes
struct _MI_PHYSICAL_VIEW {
  struct _RTL_BALANCED_NODE PhysicalNode; // offset: 0x0 (0)
  struct _MMVAD_SHORT *Vad;               // offset: 0x18 (24)
  struct _AWEINFO *AweInfo;               // offset: 0x20 (32)
  union {
    ULONG ViewPageSize : 2;            // offset: 0x28 (40)
    struct _CONTROL_AREA *ControlArea; // offset: 0x28 (40)

  } u1; // offset: 0x28 (40)
};

// 0x30 (48) bytes
struct _MMPFN {
  union {
    struct _LIST_ENTRY ListEntry;       // offset: 0x0 (0)
    struct _RTL_BALANCED_NODE TreeNode; // offset: 0x0 (0)
    struct {
      union {
        struct _SINGLE_LIST_ENTRY NextSlistPfn; // offset: 0x0 (0)
        VOID *Next;                             // offset: 0x0 (0)
        ULONGLONG Flink : 36;                   // offset: 0x0 (0)
        ULONGLONG NodeFlinkHigh : 28;           // offset: 0x0 (0)
        struct _MI_ACTIVE_PFN Active;           // offset: 0x0 (0)

      } u1; // offset: 0x0 (0)
      union {
        struct _MMPTE *PteAddress; // offset: 0x8 (8)
        ULONGLONG PteLong;         // offset: 0x8 (8)
      };
      struct _MMPTE OriginalPte; // offset: 0x10 (16)
    };
  };
  struct _MIPFNBLINK u2; // offset: 0x18 (24)
  union {
    struct {
      USHORT ReferenceCount;  // offset: 0x20 (32)
      struct _MMPFNENTRY1 e1; // offset: 0x22 (34)
    };
    struct {
      struct _MMPFNENTRY3 e3; // offset: 0x23 (35)
      struct {
        USHORT ReferenceCount; // offset: 0x0 (0)
      } e2;                    // offset: 0x20 (32)
    };
    struct {
      ULONG EntireField; // offset: 0x0 (0)
    } e4;                // offset: 0x20 (32)

  } u3;                // offset: 0x20 (32)
  USHORT NodeBlinkLow; // offset: 0x24 (36)
  UCHAR Unused : 4;    // offset: 0x26 (38)
  UCHAR Unused2 : 4;   // offset: 0x26 (38)
  union {
    UCHAR ViewCount;    // offset: 0x27 (39)
    UCHAR NodeFlinkLow; // offset: 0x27 (39)
    struct {
      UCHAR ModifiedListBucketIndex : 4; // offset: 0x27 (39)
      UCHAR AnchorLargePageSize : 2;     // offset: 0x27 (39)
    };
  };
  union {
    ULONGLONG PteFrame : 36;    // offset: 0x28 (40)
    ULONGLONG ResidentPage : 1; // offset: 0x28 (40)
    ULONGLONG Unused1 : 1;      // offset: 0x28 (40)
    ULONGLONG Unused2 : 1;      // offset: 0x28 (40)
    ULONGLONG Partition : 10;   // offset: 0x28 (40)
    ULONGLONG FileOnly : 1;     // offset: 0x28 (40)
    ULONGLONG PfnExists : 1;    // offset: 0x28 (40)
    ULONGLONG Spare : 9;        // offset: 0x28 (40)
    ULONGLONG PageIdentity : 3; // offset: 0x28 (40)
    ULONGLONG PrototypePte : 1; // offset: 0x28 (40)
    ULONGLONG EntireField;      // offset: 0x28 (40)

  } u4; // offset: 0x28 (40)
};

// 0x88 (136) bytes
struct _MI_PAGELIST_STATE {
  volatile LONG ActiveSpinLock;              // offset: 0x0 (0)
  struct _RTL_AVL_TREE ActiveThreadTree;     // offset: 0x8 (8)
  volatile LONG ActiveZeroSpinLock;          // offset: 0x10 (16)
  struct _RTL_AVL_TREE ActiveZeroThreadTree; // offset: 0x18 (24)
  struct _MMPFN LargePfnTemplate;            // offset: 0x20 (32)
  struct _MMPFN LargePfnBasePageTemplate;    // offset: 0x50 (80)
  ULONG NumberOfLargePageListHeads;          // offset: 0x80 (128)
};

// 0xa8 (168) bytes
struct _MI_COMMON_PAGE_STATE {
  struct _MMPFN *PageOfOnesPfn; // offset: 0x0 (0)
  ULONGLONG PageOfOnes;         // offset: 0x8 (8)
  struct _MMPFN *DummyPagePfn;  // offset: 0x10 (16)
  ULONGLONG DummyPage;          // offset: 0x18 (24)
  ULONGLONG PageOfZeroes;       // offset: 0x20 (32)
  VOID *ZeroMapping;            // offset: 0x28 (40)
  VOID *OnesMapping;            // offset: 0x30 (48)
  ULONGLONG ZeroCrc;            // offset: 0x38 (56)
  ULONGLONG OnesCrc;            // offset: 0x40 (64)
  ULONGLONG BitmapGapFrames[4]; // offset: 0x48 (72)
  ULONGLONG PfnGapFrames[4];    // offset: 0x68 (104)
  ULONGLONG PageTableOfZeroes;  // offset: 0x88 (136)
  struct _MMPTE PdeOfZeroes;    // offset: 0x90 (144)
  ULONGLONG PageTableOfOnes;    // offset: 0x98 (152)
  struct _MMPTE PdeOfOnes;      // offset: 0xa0 (160)
};

// 0x10 (16) bytes
struct _MI_HARD_FAULT_STATE {
  struct _MMPFN *SwapPfn;                            // offset: 0x0 (0)
  struct _MI_STORE_INPAGE_COMPLETE_FLAGS StoreFlags; // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _MI_PROTOTYPE_PTES_NODE {
  struct _RTL_BALANCED_NODE Node; // offset: 0x0 (0)
  union {
    struct {
      ULONGLONG AllocationType : 3; // offset: 0x0 (0)
      ULONGLONG Inserted : 1;       // offset: 0x0 (0)
    } e1;                           // offset: 0x18 (24)
    struct {
      ULONGLONG PrototypePtesFlags; // offset: 0x0 (0)
    } e2;                           // offset: 0x18 (24)

  } u1; // offset: 0x18 (24)
};

// 0x58 (88) bytes
struct _MI_PER_SESSION_PROTOS {
  union {
    struct _RTL_BALANCED_NODE SessionProtoNode; // offset: 0x0 (0)
    struct _SINGLE_LIST_ENTRY FreeList;         // offset: 0x0 (0)
    VOID *DriverAddress;                        // offset: 0x0 (0)
  };
  struct _MI_PROTOTYPE_PTES_NODE ProtosNode; // offset: 0x18 (24)
  ULONGLONG NumberOfPtes;                    // offset: 0x38 (56)
  union {
    ULONG SessionId;                // offset: 0x40 (64)
    struct _SUBSECTION *Subsection; // offset: 0x40 (64)
  };
  struct _MMPTE *SubsectionBase; // offset: 0x48 (72)
  union {
    ULONG ReferenceCount;     // offset: 0x50 (80)
    ULONG NumberOfPtesToFree; // offset: 0x50 (80)

  } u2; // offset: 0x50 (80)
};

// 0x38 (56) bytes
struct _SUBSECTION {
  struct _CONTROL_AREA *ControlArea;  // offset: 0x0 (0)
  struct _MMPTE *SubsectionBase;      // offset: 0x8 (8)
  struct _SUBSECTION *NextSubsection; // offset: 0x10 (16)
  union {
    struct _RTL_AVL_TREE GlobalPerSessionHead;            // offset: 0x18 (24)
    struct _MI_CONTROL_AREA_WAIT_BLOCK *CreationWaitList; // offset: 0x18 (24)
    struct _MI_PER_SESSION_PROTOS *SessionDriverProtos;   // offset: 0x18 (24)
  };
  union {
    ULONG LongFlags;                            // offset: 0x20 (32)
    struct _MMSUBSECTION_FLAGS SubsectionFlags; // offset: 0x20 (32)

  } u;                       // offset: 0x20 (32)
  ULONG StartingSector;      // offset: 0x24 (36)
  ULONG NumberOfFullSectors; // offset: 0x28 (40)
  ULONG PtesInSubsection;    // offset: 0x2c (44)
  union {
    struct _MI_SUBSECTION_ENTRY1 e1; // offset: 0x30 (48)
    ULONG EntireField;               // offset: 0x30 (48)

  } u1;                        // offset: 0x30 (48)
  ULONG UnusedPtes : 30;       // offset: 0x34 (52)
  ULONG ExtentQueryNeeded : 1; // offset: 0x34 (52)
  ULONG DirtyPages : 1;        // offset: 0x34 (52)
};

// 0x90 (144) bytes
struct _MSUBSECTION {
  struct _SUBSECTION Core;                   // offset: 0x0 (0)
  struct _RTL_BALANCED_NODE SubsectionNode;  // offset: 0x38 (56)
  struct _LIST_ENTRY DereferenceList;        // offset: 0x50 (80)
  ULONGLONG NumberOfMappedViews;             // offset: 0x60 (96)
  ULONG NumberOfPfnReferences;               // offset: 0x68 (104)
  ULONG LargeViews;                          // offset: 0x6c (108)
  struct _MI_PROTOTYPE_PTES_NODE ProtosNode; // offset: 0x70 (112)
};

// 0x40 (64) bytes
struct _MI_IMAGE_SECURITY_REFERENCE {
  struct _MI_PROTOTYPE_PTES_NODE ProtosNode;      // offset: 0x0 (0)
  VOID *DynamicRelocations;                       // offset: 0x20 (32)
  struct _IMAGE_SECURITY_CONTEXT SecurityContext; // offset: 0x28 (40)
  union {
    VOID *ImageFileExtents;             // offset: 0x30 (48)
    ULONGLONG ImageFileExtentsUlongPtr; // offset: 0x30 (48)
    ULONGLONG FilesystemWantsRva : 1;   // offset: 0x30 (48)
    ULONGLONG Spare : 3;                // offset: 0x30 (48)

  } u1;                           // offset: 0x30 (48)
  ULONGLONG StrongImageReference; // offset: 0x38 (56)
};

// 0x38 (56) bytes
struct _MI_PAGEFILE_BITMAPS_CACHE_ENTRY {
  union {
    struct _RTL_BALANCED_NODE LengthTreeNode; // offset: 0x0 (0)
    struct _LIST_ENTRY FreeListEntry;         // offset: 0x0 (0)
  };
  struct _RTL_BALANCED_NODE LocationTreeNode; // offset: 0x18 (24)
  ULONG StartingIndex;                        // offset: 0x30 (48)
  ULONG Length;                               // offset: 0x34 (52)
};

// 0x88 (136) bytes
struct _DYNAMIC_FUNCTION_TABLE {
  struct _LIST_ENTRY ListEntry;                        // offset: 0x0 (0)
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY *FunctionTable; // offset: 0x10 (16)
  union _LARGE_INTEGER TimeStamp;                      // offset: 0x18 (24)
  ULONGLONG MinimumAddress;                            // offset: 0x20 (32)
  ULONGLONG MaximumAddress;                            // offset: 0x28 (40)
  ULONGLONG BaseAddress;                               // offset: 0x30 (48)
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY *(*Callback)(
      ULONGLONG arg1, VOID *arg2);       // offset: 0x38 (56)
  VOID *Context;                         // offset: 0x40 (64)
  WCHAR *OutOfProcessCallbackDll;        // offset: 0x48 (72)
  enum _FUNCTION_TABLE_TYPE Type;        // offset: 0x50 (80)
  ULONG EntryCount;                      // offset: 0x54 (84)
  struct _RTL_BALANCED_NODE TreeNodeMin; // offset: 0x58 (88)
  struct _RTL_BALANCED_NODE TreeNodeMax; // offset: 0x70 (112)
};

// 0x18 (24) bytes
struct _INVERTED_FUNCTION_TABLE_ENTRY {
  union {
    struct _IMAGE_RUNTIME_FUNCTION_ENTRY *FunctionTable; // offset: 0x0 (0)
    struct _DYNAMIC_FUNCTION_TABLE *DynamicTable;        // offset: 0x0 (0)
  };
  VOID *ImageBase;   // offset: 0x8 (8)
  ULONG SizeOfImage; // offset: 0x10 (16)
  ULONG SizeOfTable; // offset: 0x14 (20)
};

// 0x1810 (6160) bytes
struct _INVERTED_FUNCTION_TABLE {
  ULONG CurrentSize;                                     // offset: 0x0 (0)
  ULONG MaximumSize;                                     // offset: 0x4 (4)
  volatile ULONG Epoch;                                  // offset: 0x8 (8)
  UCHAR Overflow;                                        // offset: 0xc (12)
  struct _INVERTED_FUNCTION_TABLE_ENTRY TableEntry[256]; // offset: 0x10 (16)
};

// 0x1a8 (424) bytes
struct _KSCB {
  ULONGLONG GenerationCycles;           // offset: 0x0 (0)
  ULONGLONG MinQuotaCycleTarget;        // offset: 0x8 (8)
  ULONGLONG MaxQuotaCycleTarget;        // offset: 0x10 (16)
  ULONGLONG RankCycleTarget;            // offset: 0x18 (24)
  ULONGLONG LongTermCycles;             // offset: 0x20 (32)
  ULONGLONG LastReportedCycles;         // offset: 0x28 (40)
  volatile ULONGLONG OverQuotaHistory;  // offset: 0x30 (48)
  ULONGLONG ReadyTime;                  // offset: 0x38 (56)
  ULONGLONG InsertTime;                 // offset: 0x40 (64)
  struct _LIST_ENTRY PerProcessorList;  // offset: 0x48 (72)
  struct _RTL_BALANCED_NODE QueueNode;  // offset: 0x58 (88)
  UCHAR Inserted : 1;                   // offset: 0x70 (112)
  UCHAR MaxOverQuota : 1;               // offset: 0x70 (112)
  UCHAR MinOverQuota : 1;               // offset: 0x70 (112)
  UCHAR RankBias : 1;                   // offset: 0x70 (112)
  UCHAR SoftCap : 1;                    // offset: 0x70 (112)
  UCHAR ShareRankOwner : 1;             // offset: 0x70 (112)
  UCHAR Spare1 : 2;                     // offset: 0x70 (112)
  UCHAR Depth;                          // offset: 0x71 (113)
  USHORT ReadySummary;                  // offset: 0x72 (114)
  ULONG Rank;                           // offset: 0x74 (116)
  volatile ULONG *ShareRank;            // offset: 0x78 (120)
  volatile ULONG OwnerShareRank;        // offset: 0x80 (128)
  struct _LIST_ENTRY ReadyListHead[16]; // offset: 0x88 (136)
  struct _RTL_RB_TREE ChildScbQueue;    // offset: 0x188 (392)
  struct _KSCB *Parent;                 // offset: 0x198 (408)
  struct _KSCB *Root;                   // offset: 0x1a0 (416)
};

// 0x60 (96) bytes
struct _KLOCK_ENTRY {
  union {
    struct _RTL_BALANCED_NODE TreeNode;      // offset: 0x0 (0)
    struct _SINGLE_LIST_ENTRY FreeListEntry; // offset: 0x0 (0)
  };
  union {
    ULONG EntryFlags; // offset: 0x18 (24)
    struct {
      UCHAR EntryOffset; // offset: 0x18 (24)
      union {
        UCHAR ThreadLocalFlags; // offset: 0x19 (25)
        struct {
          UCHAR WaitingBit : 1; // offset: 0x19 (25)
          UCHAR Spare0 : 7;     // offset: 0x19 (25)
        };
      };
      union {
        UCHAR AcquiredByte;    // offset: 0x1a (26)
        UCHAR AcquiredBit : 1; // offset: 0x1a (26)
      };
      union {
        UCHAR CrossThreadFlags; // offset: 0x1b (27)
        struct {
          UCHAR HeadNodeBit : 1;   // offset: 0x1b (27)
          UCHAR IoPriorityBit : 1; // offset: 0x1b (27)
          UCHAR IoQoSWaiter : 1;   // offset: 0x1b (27)
          UCHAR Spare1 : 5;        // offset: 0x1b (27)
        };
      };
    };
    struct {
      ULONG StaticState : 8; // offset: 0x18 (24)
      ULONG AllFlags : 24;   // offset: 0x18 (24)
    };
  };
  ULONG SpareFlags; // offset: 0x1c (28)
  union {
    struct _KLOCK_ENTRY_LOCK_STATE LockState; // offset: 0x20 (32)
    VOID *volatile LockUnsafe;                // offset: 0x20 (32)
    struct {
      volatile UCHAR CrossThreadReleasableAndBusyByte; // offset: 0x20 (32)
      UCHAR Reserved[6];                               // offset: 0x21 (33)
      volatile UCHAR InTreeByte;                       // offset: 0x27 (39)
      union {
        VOID *SessionState; // offset: 0x28 (40)
        struct {
          ULONG SessionId;  // offset: 0x28 (40)
          ULONG SessionPad; // offset: 0x2c (44)
        };
      };
    };
  };
  union {
    struct {
      struct _RTL_RB_TREE OwnerTree;  // offset: 0x30 (48)
      struct _RTL_RB_TREE WaiterTree; // offset: 0x40 (64)
    };
    CHAR CpuPriorityKey; // offset: 0x30 (48)
  };
  ULONGLONG EntryLock;                         // offset: 0x50 (80)
  union _KLOCK_ENTRY_BOOST_BITMAP BoostBitmap; // offset: 0x58 (88)
  ULONG SparePad;                              // offset: 0x5c (92)
};

// 0x8 (8) bytes
union _JOBOBJECT_ENERGY_TRACKING_STATE {
  ULONGLONG Value; // offset: 0x0 (0)
  struct {
    ULONG UpdateMask; // offset: 0x0 (0)
  };
  ULONG DesiredState; // offset: 0x4 (4)
};

// 0x28 (40) bytes
struct _JOB_RATE_CONTROL_HEADER {
  VOID *RateControlQuotaReference;     // offset: 0x0 (0)
  struct _RTL_BITMAP OverQuotaHistory; // offset: 0x8 (8)
  UCHAR *BitMapBuffer;                 // offset: 0x18 (24)
  ULONGLONG BitMapBufferSize;          // offset: 0x20 (32)
};

// 0x68 (104) bytes
struct _EPROCESS_VALUES {
  ULONGLONG KernelTime;         // offset: 0x0 (0)
  ULONGLONG UserTime;           // offset: 0x8 (8)
  ULONGLONG ReadyTime;          // offset: 0x10 (16)
  ULONGLONG CycleTime;          // offset: 0x18 (24)
  ULONGLONG ContextSwitches;    // offset: 0x20 (32)
  LONGLONG ReadOperationCount;  // offset: 0x28 (40)
  LONGLONG WriteOperationCount; // offset: 0x30 (48)
  LONGLONG OtherOperationCount; // offset: 0x38 (56)
  LONGLONG ReadTransferCount;   // offset: 0x40 (64)
  LONGLONG WriteTransferCount;  // offset: 0x48 (72)
  LONGLONG OtherTransferCount;  // offset: 0x50 (80)
  ULONGLONG KernelWaitTime;     // offset: 0x58 (88)
  ULONGLONG UserWaitTime;       // offset: 0x60 (96)
};

// 0x48 (72) bytes
struct _PS_JOB_WAKE_INFORMATION {
  ULONGLONG NotificationChannel; // offset: 0x0 (0)
  ULONGLONG WakeCounters[7];     // offset: 0x8 (8)
  ULONGLONG NoWakeCounter;       // offset: 0x40 (64)
};

// 0x68 (104) bytes
struct _ERESOURCE {
  struct _LIST_ENTRY SystemResourcesList; // offset: 0x0 (0)
  struct _OWNER_ENTRY *OwnerTable;        // offset: 0x10 (16)
  SHORT ActiveCount;                      // offset: 0x18 (24)
  union {
    USHORT Flag; // offset: 0x1a (26)
    struct {
      UCHAR ReservedLowFlags; // offset: 0x1a (26)
      UCHAR WaiterPriority;   // offset: 0x1b (27)
    };
  };
  VOID *SharedWaiters;            // offset: 0x20 (32)
  VOID *ExclusiveWaiters;         // offset: 0x28 (40)
  struct _OWNER_ENTRY OwnerEntry; // offset: 0x30 (48)
  ULONG ActiveEntries;            // offset: 0x40 (64)
  ULONG ContentionCount;          // offset: 0x44 (68)
  ULONG NumberOfSharedWaiters;    // offset: 0x48 (72)
  ULONG NumberOfExclusiveWaiters; // offset: 0x4c (76)
  VOID *Reserved2;                // offset: 0x50 (80)
  union {
    VOID *Address;                   // offset: 0x58 (88)
    ULONGLONG CreatorBackTraceIndex; // offset: 0x58 (88)
  };
  ULONGLONG SpinLock; // offset: 0x60 (96)
};

// 0x68 (104) bytes
struct _HEAP_LOCK {
  union {
    struct _RTL_CRITICAL_SECTION CriticalSection; // offset: 0x0 (0)
    struct _ERESOURCE Resource;                   // offset: 0x0 (0)

  } Lock; // offset: 0x0 (0)
};

// 0x498 (1176) bytes
struct _TOKEN {
  struct _TOKEN_SOURCE TokenSource;                      // offset: 0x0 (0)
  struct _LUID TokenId;                                  // offset: 0x10 (16)
  struct _LUID AuthenticationId;                         // offset: 0x18 (24)
  struct _LUID ParentTokenId;                            // offset: 0x20 (32)
  union _LARGE_INTEGER ExpirationTime;                   // offset: 0x28 (40)
  struct _ERESOURCE *TokenLock;                          // offset: 0x30 (48)
  struct _LUID ModifiedId;                               // offset: 0x38 (56)
  struct _SEP_TOKEN_PRIVILEGES Privileges;               // offset: 0x40 (64)
  struct _SEP_AUDIT_POLICY AuditPolicy;                  // offset: 0x58 (88)
  ULONG SessionId;                                       // offset: 0x78 (120)
  ULONG UserAndGroupCount;                               // offset: 0x7c (124)
  ULONG RestrictedSidCount;                              // offset: 0x80 (128)
  ULONG VariableLength;                                  // offset: 0x84 (132)
  ULONG DynamicCharged;                                  // offset: 0x88 (136)
  ULONG DynamicAvailable;                                // offset: 0x8c (140)
  ULONG DefaultOwnerIndex;                               // offset: 0x90 (144)
  struct _SID_AND_ATTRIBUTES *UserAndGroups;             // offset: 0x98 (152)
  struct _SID_AND_ATTRIBUTES *RestrictedSids;            // offset: 0xa0 (160)
  VOID *PrimaryGroup;                                    // offset: 0xa8 (168)
  ULONG *DynamicPart;                                    // offset: 0xb0 (176)
  struct _ACL *DefaultDacl;                              // offset: 0xb8 (184)
  enum _TOKEN_TYPE TokenType;                            // offset: 0xc0 (192)
  enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; // offset: 0xc4 (196)
  ULONG TokenFlags;                                      // offset: 0xc8 (200)
  UCHAR TokenInUse;                                      // offset: 0xcc (204)
  ULONG IntegrityLevelIndex;                             // offset: 0xd0 (208)
  ULONG MandatoryPolicy;                                 // offset: 0xd4 (212)
  struct _SEP_LOGON_SESSION_REFERENCES *LogonSession;    // offset: 0xd8 (216)
  struct _LUID OriginatingLogonSession;                  // offset: 0xe0 (224)
  struct _SID_AND_ATTRIBUTES_HASH SidHash;               // offset: 0xe8 (232)
  struct _SID_AND_ATTRIBUTES_HASH RestrictedSidHash;     // offset: 0x1f8 (504)
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pSecurityAttributes;                             // offset: 0x308 (776)
  VOID *Package;                                        // offset: 0x310 (784)
  struct _SID_AND_ATTRIBUTES *Capabilities;             // offset: 0x318 (792)
  ULONG CapabilityCount;                                // offset: 0x320 (800)
  struct _SID_AND_ATTRIBUTES_HASH CapabilitiesHash;     // offset: 0x328 (808)
  struct _SEP_LOWBOX_NUMBER_ENTRY *LowboxNumberEntry;   // offset: 0x438 (1080)
  struct _SEP_CACHED_HANDLES_ENTRY *LowboxHandlesEntry; // offset: 0x440 (1088)
  struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION
      *pClaimAttributes;                              // offset: 0x448 (1096)
  VOID *TrustLevelSid;                                // offset: 0x450 (1104)
  struct _TOKEN *TrustLinkedToken;                    // offset: 0x458 (1112)
  VOID *IntegrityLevelSidValue;                       // offset: 0x460 (1120)
  struct _SEP_SID_VALUES_BLOCK *TokenSidValues;       // offset: 0x468 (1128)
  struct _SEP_LUID_TO_INDEX_MAP_ENTRY *IndexEntry;    // offset: 0x470 (1136)
  struct _SEP_TOKEN_DIAG_TRACK_ENTRY *DiagnosticInfo; // offset: 0x478 (1144)
  struct _SEP_CACHED_HANDLES_ENTRY
      *BnoIsolationHandlesEntry; // offset: 0x480 (1152)
  VOID *SessionObject;           // offset: 0x488 (1160)
  ULONGLONG VariablePart;        // offset: 0x490 (1168)
};

// 0x28 (40) bytes
union _FS_FILTER_PARAMETERS {
  struct {
    union _LARGE_INTEGER *EndingOffset;    // offset: 0x0 (0)
    struct _ERESOURCE **ResourceToRelease; // offset: 0x8 (8)
  } AcquireForModifiedPageWriter;          // offset: 0x0 (0)
  struct {
    struct _ERESOURCE *ResourceToRelease; // offset: 0x0 (0)
  } ReleaseForModifiedPageWriter;         // offset: 0x0 (0)
  struct {
    enum _FS_FILTER_SECTION_SYNC_TYPE SyncType;               // offset: 0x0 (0)
    ULONG PageProtection;                                     // offset: 0x4 (4)
    struct _FS_FILTER_SECTION_SYNC_OUTPUT *OutputInformation; // offset: 0x8 (8)
    ULONG Flags;                      // offset: 0x10 (16)
  } AcquireForSectionSynchronization; // offset: 0x0 (0)
  struct {
    struct _IRP *Irp;                                  // offset: 0x0 (0)
    VOID *FileInformation;                             // offset: 0x8 (8)
    ULONG *Length;                                     // offset: 0x10 (16)
    enum _FILE_INFORMATION_CLASS FileInformationClass; // offset: 0x18 (24)
    LONG CompletionStatus;                             // offset: 0x1c (28)
  } QueryOpen;                                         // offset: 0x0 (0)
  struct {
    VOID *Argument1; // offset: 0x0 (0)
    VOID *Argument2; // offset: 0x8 (8)
    VOID *Argument3; // offset: 0x10 (16)
    VOID *Argument4; // offset: 0x18 (24)
    VOID *Argument5; // offset: 0x20 (32)
  } Others;          // offset: 0x0 (0)
};

// 0x40 (64) bytes
struct _FS_FILTER_CALLBACK_DATA {
  ULONG SizeOfFsFilterCallbackData;       // offset: 0x0 (0)
  UCHAR Operation;                        // offset: 0x4 (4)
  UCHAR Reserved;                         // offset: 0x5 (5)
  struct _DEVICE_OBJECT *DeviceObject;    // offset: 0x8 (8)
  struct _FILE_OBJECT *FileObject;        // offset: 0x10 (16)
  union _FS_FILTER_PARAMETERS Parameters; // offset: 0x18 (24)
};

// 0x78 (120) bytes
struct _FS_FILTER_CALLBACKS {
  ULONG SizeOfFsFilterCallbacks; // offset: 0x0 (0)
  ULONG Reserved;                // offset: 0x4 (4)
  LONG (*PreAcquireForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, VOID **arg2); // offset: 0x8 (8)
  VOID (*PostAcquireForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, LONG arg2,
   VOID *arg3); // offset: 0x10 (16)
  LONG (*PreReleaseForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, VOID **arg2); // offset: 0x18 (24)
  VOID (*PostReleaseForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, LONG arg2,
   VOID *arg3); // offset: 0x20 (32)
  LONG (*PreAcquireForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, VOID **arg2); // offset: 0x28 (40)
  VOID (*PostAcquireForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, LONG arg2,
   VOID *arg3); // offset: 0x30 (48)
  LONG (*PreReleaseForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, VOID **arg2); // offset: 0x38 (56)
  VOID (*PostReleaseForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, LONG arg2,
   VOID *arg3); // offset: 0x40 (64)
  LONG (*PreAcquireForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, VOID **arg2); // offset: 0x48 (72)
  VOID (*PostAcquireForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, LONG arg2,
   VOID *arg3); // offset: 0x50 (80)
  LONG (*PreReleaseForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, VOID **arg2); // offset: 0x58 (88)
  VOID (*PostReleaseForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, LONG arg2,
   VOID *arg3); // offset: 0x60 (96)
  LONG (*PreQueryOpen)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, VOID **arg2); // offset: 0x68 (104)
  VOID (*PostQueryOpen)
  (struct _FS_FILTER_CALLBACK_DATA *arg1, LONG arg2,
   VOID *arg3); // offset: 0x70 (112)
};

// 0x18 (24) bytes
struct _PS_PROPERTY_SET {
  struct _LIST_ENTRY ListHead; // offset: 0x0 (0)
  ULONGLONG Lock;              // offset: 0x10 (16)
};

// 0x8 (8) bytes
union _PS_CLIENT_SECURITY_CONTEXT {
  ULONGLONG ImpersonationData;      // offset: 0x0 (0)
  VOID *ImpersonationToken;         // offset: 0x0 (0)
  ULONGLONG ImpersonationLevel : 2; // offset: 0x0 (0)
  ULONGLONG EffectiveOnly : 1;      // offset: 0x0 (0)
};

// 0x240 (576) bytes
struct _KSCHEDULING_GROUP {
  struct _KSCHEDULING_GROUP_POLICY Policy;   // offset: 0x0 (0)
  ULONG RelativeWeight;                      // offset: 0x8 (8)
  ULONG ChildMinRate;                        // offset: 0xc (12)
  ULONG ChildMinWeight;                      // offset: 0x10 (16)
  ULONG ChildTotalWeight;                    // offset: 0x14 (20)
  ULONGLONG QueryHistoryTimeStamp;           // offset: 0x18 (24)
  LONGLONG NotificationCycles;               // offset: 0x20 (32)
  LONGLONG MaxQuotaLimitCycles;              // offset: 0x28 (40)
  volatile LONGLONG MaxQuotaCyclesRemaining; // offset: 0x30 (48)
  union {
    struct _LIST_ENTRY SchedulingGroupList; // offset: 0x38 (56)
    struct _LIST_ENTRY Sibling;             // offset: 0x38 (56)
  };
  struct _KDPC *NotificationDpc;     // offset: 0x48 (72)
  struct _LIST_ENTRY ChildList;      // offset: 0x50 (80)
  struct _KSCHEDULING_GROUP *Parent; // offset: 0x60 (96)
  struct _KSCB PerProcessor[1];      // offset: 0x80 (128)
};

// 0xa8 (168) bytes
struct _KAFFINITY_EX {
  USHORT Count;         // offset: 0x0 (0)
  USHORT Size;          // offset: 0x2 (2)
  ULONG Reserved;       // offset: 0x4 (4)
  ULONGLONG Bitmap[20]; // offset: 0x8 (8)
};

// 0x180 (384) bytes
struct _PPM_PLATFORM_STATE {
  ULONGLONG LevelId;                                 // offset: 0x0 (0)
  ULONG Latency;                                     // offset: 0x8 (8)
  ULONG BreakEvenDuration;                           // offset: 0xc (12)
  struct _PPM_VETO_ACCOUNTING VetoAccounting;        // offset: 0x10 (16)
  UCHAR TransitionDebugger;                          // offset: 0x38 (56)
  UCHAR Platform;                                    // offset: 0x39 (57)
  ULONG DependencyListCount;                         // offset: 0x3c (60)
  struct _KAFFINITY_EX Processors;                   // offset: 0x40 (64)
  struct _UNICODE_STRING Name;                       // offset: 0xe8 (232)
  struct _PPM_SELECTION_DEPENDENCY *DependencyLists; // offset: 0xf8 (248)
  union _PPM_COORDINATED_SYNCHRONIZATION volatile Synchronization; // offset:
                                                                   // 0x100
                                                                   // (256)
  volatile ULONGLONG EnterTime; // offset: 0x108 (264)
  union {
    volatile LONG RefCount; // offset: 0x140 (320)
    UCHAR CacheAlign0[64];  // offset: 0x140 (320)
  };
};

// 0x1c0 (448) bytes
struct _PPM_PLATFORM_STATES {
  ULONG StateCount;                                      // offset: 0x0 (0)
  ULONG InterfaceVersion;                                // offset: 0x4 (4)
  ULONG ProcessorCount;                                  // offset: 0x8 (8)
  UCHAR CoordinatedInterface;                            // offset: 0xc (12)
  ULONG (*IdleTest)(VOID *arg1, ULONG arg2, ULONG arg3); // offset: 0x10 (16)
  LONG (*IdlePreExecute)
  (VOID *arg1, ULONG arg2, ULONG arg3, ULONG arg4,
   ULONG *arg5); // offset: 0x18 (24)
  VOID (*IdleComplete)
  (VOID *arg1, ULONG arg2, ULONG arg3, ULONG arg4,
   ULONG *arg5); // offset: 0x20 (32)
  LONG (*QueryPlatformStateResidency)
  (VOID *arg1,
   struct _PROCESSOR_PLATFORM_STATE_RESIDENCIES *arg2); // offset: 0x28 (40)
  struct _PLATFORM_IDLE_ACCOUNTING *Accounting;         // offset: 0x30 (48)
  UCHAR DeepSleepEnabled;                               // offset: 0x38 (56)
  struct _PPM_PLATFORM_STATE State[1];                  // offset: 0x40 (64)
};

// 0xf8 (248) bytes
struct _PPM_IDLE_STATE {
  struct _KAFFINITY_EX DomainMembers;         // offset: 0x0 (0)
  struct _UNICODE_STRING Name;                // offset: 0xa8 (168)
  ULONG Latency;                              // offset: 0xb8 (184)
  ULONG BreakEvenDuration;                    // offset: 0xbc (188)
  ULONG Power;                                // offset: 0xc0 (192)
  ULONG StateFlags;                           // offset: 0xc4 (196)
  struct _PPM_VETO_ACCOUNTING VetoAccounting; // offset: 0xc8 (200)
  UCHAR StateType;                            // offset: 0xf0 (240)
  UCHAR InterruptsEnabled;                    // offset: 0xf1 (241)
  UCHAR Interruptible;                        // offset: 0xf2 (242)
  UCHAR ContextRetained;                      // offset: 0xf3 (243)
  UCHAR CacheCoherent;                        // offset: 0xf4 (244)
  UCHAR WakesSpuriously;                      // offset: 0xf5 (245)
  UCHAR PlatformOnly;                         // offset: 0xf6 (246)
  UCHAR NoCState;                             // offset: 0xf7 (247)
};

// 0x428 (1064) bytes
struct _PPM_IDLE_STATES {
  UCHAR InterfaceVersion;                      // offset: 0x0 (0)
  UCHAR IdleOverride;                          // offset: 0x1 (1)
  UCHAR EstimateIdleDuration;                  // offset: 0x2 (2)
  UCHAR ExitLatencyTraceEnabled;               // offset: 0x3 (3)
  UCHAR NonInterruptibleTransition;            // offset: 0x4 (4)
  UCHAR UnaccountedTransition;                 // offset: 0x5 (5)
  UCHAR IdleDurationLimited;                   // offset: 0x6 (6)
  UCHAR IdleCheckLimited;                      // offset: 0x7 (7)
  UCHAR StrictVetoBias;                        // offset: 0x8 (8)
  ULONG ExitLatencyCountdown;                  // offset: 0xc (12)
  ULONG TargetState;                           // offset: 0x10 (16)
  ULONG ActualState;                           // offset: 0x14 (20)
  ULONG OldState;                              // offset: 0x18 (24)
  ULONG OverrideIndex;                         // offset: 0x1c (28)
  ULONG ProcessorIdleCount;                    // offset: 0x20 (32)
  ULONG Type;                                  // offset: 0x24 (36)
  ULONGLONG LevelId;                           // offset: 0x28 (40)
  USHORT ReasonFlags;                          // offset: 0x30 (48)
  volatile ULONGLONG InitiateWakeStamp;        // offset: 0x38 (56)
  LONG PreviousStatus;                         // offset: 0x40 (64)
  ULONG PreviousCancelReason;                  // offset: 0x44 (68)
  struct _KAFFINITY_EX PrimaryProcessorMask;   // offset: 0x48 (72)
  struct _KAFFINITY_EX SecondaryProcessorMask; // offset: 0xf0 (240)
  VOID (*IdlePrepare)
  (struct _PROCESSOR_IDLE_PREPARE_INFO *arg1); // offset: 0x198 (408)
  LONG (*IdlePreExecute)
  (VOID *arg1, ULONG arg2, ULONG arg3, ULONG arg4,
   ULONG *arg5); // offset: 0x1a0 (416)
  LONG (*IdleExecute)
  (VOID *arg1, ULONGLONG arg2, ULONG arg3, ULONG arg4, ULONG arg5, ULONG arg6,
   ULONG *arg7); // offset: 0x1a8 (424)
  ULONG (*IdlePreselect)
  (VOID *arg1, struct _PROCESSOR_IDLE_CONSTRAINTS *arg2); // offset: 0x1b0 (432)
  ULONG (*IdleTest)(VOID *arg1, ULONG arg2, ULONG arg3);  // offset: 0x1b8 (440)
  ULONG (*IdleAvailabilityCheck)(VOID *arg1, ULONG arg2); // offset: 0x1c0 (448)
  VOID (*IdleComplete)
  (VOID *arg1, ULONG arg2, ULONG arg3, ULONG arg4,
   ULONG *arg5);                                   // offset: 0x1c8 (456)
  VOID (*IdleCancel)(VOID *arg1, ULONG arg2);      // offset: 0x1d0 (464)
  UCHAR (*IdleIsHalted)(VOID *arg1);               // offset: 0x1d8 (472)
  UCHAR (*IdleInitiateWake)(VOID *arg1);           // offset: 0x1e0 (480)
  struct _PROCESSOR_IDLE_PREPARE_INFO PrepareInfo; // offset: 0x1e8 (488)
  struct _KAFFINITY_EX DeepIdleSnapshot;           // offset: 0x240 (576)
  struct _PERFINFO_PPM_STATE_SELECTION *Tracing;   // offset: 0x2e8 (744)
  struct _PERFINFO_PPM_STATE_SELECTION
      *CoordinatedTracing;                                // offset: 0x2f0 (752)
  struct _PPM_SELECTION_MENU ProcessorMenu;               // offset: 0x2f8 (760)
  struct _PPM_SELECTION_MENU CoordinatedMenu;             // offset: 0x308 (776)
  struct _PPM_COORDINATED_SELECTION CoordinatedSelection; // offset: 0x318 (792)
  struct _PPM_IDLE_STATE State[1];                        // offset: 0x330 (816)
};

// 0x2a0 (672) bytes
struct _KSTATIC_AFFINITY_BLOCK {
  union {
    struct _KAFFINITY_EX KeFlushTbAffinity;     // offset: 0x0 (0)
    struct _KAFFINITY_EX KeFlushWbAffinity;     // offset: 0x0 (0)
    struct _KAFFINITY_EX KeSyncContextAffinity; // offset: 0x0 (0)
  };
  struct _KAFFINITY_EX KeFlushTbDeepIdleAffinity; // offset: 0xa8 (168)
  struct _KAFFINITY_EX KeIpiSendAffinity;         // offset: 0x150 (336)
  struct _KAFFINITY_EX KeIpiSendIpiSet;           // offset: 0x1f8 (504)
};

// 0x28 (40) bytes
struct _PROCESS_DISK_COUNTERS {
  ULONGLONG BytesRead;           // offset: 0x0 (0)
  ULONGLONG BytesWritten;        // offset: 0x8 (8)
  ULONGLONG ReadOperationCount;  // offset: 0x10 (16)
  ULONGLONG WriteOperationCount; // offset: 0x18 (24)
  ULONGLONG FlushOperationCount; // offset: 0x20 (32)
};

// 0x80 (128) bytes
struct _MMSUPPORT_SHARED {
  volatile LONG WorkingSetLock;        // offset: 0x0 (0)
  LONG GoodCitizenWaiting;             // offset: 0x4 (4)
  ULONGLONG ReleasedCommitDebt;        // offset: 0x8 (8)
  ULONGLONG ResetPagesRepurposedCount; // offset: 0x10 (16)
  VOID *WsSwapSupport;                 // offset: 0x18 (24)
  VOID *CommitReleaseContext;          // offset: 0x20 (32)
  VOID *AccessLog;                     // offset: 0x28 (40)
  volatile ULONGLONG ChargedWslePages; // offset: 0x30 (48)
  ULONGLONG ActualWslePages;           // offset: 0x38 (56)
  ULONGLONG WorkingSetCoreLock;        // offset: 0x40 (64)
  VOID *ShadowMapping;                 // offset: 0x48 (72)
};

// 0xd8 (216) bytes
struct _FILE_OBJECT {
  SHORT Type;                                            // offset: 0x0 (0)
  SHORT Size;                                            // offset: 0x2 (2)
  struct _DEVICE_OBJECT *DeviceObject;                   // offset: 0x8 (8)
  struct _VPB *Vpb;                                      // offset: 0x10 (16)
  VOID *FsContext;                                       // offset: 0x18 (24)
  VOID *FsContext2;                                      // offset: 0x20 (32)
  struct _SECTION_OBJECT_POINTERS *SectionObjectPointer; // offset: 0x28 (40)
  VOID *PrivateCacheMap;                                 // offset: 0x30 (48)
  LONG FinalStatus;                                      // offset: 0x38 (56)
  struct _FILE_OBJECT *RelatedFileObject;                // offset: 0x40 (64)
  UCHAR LockOperation;                                   // offset: 0x48 (72)
  UCHAR DeletePending;                                   // offset: 0x49 (73)
  UCHAR ReadAccess;                                      // offset: 0x4a (74)
  UCHAR WriteAccess;                                     // offset: 0x4b (75)
  UCHAR DeleteAccess;                                    // offset: 0x4c (76)
  UCHAR SharedRead;                                      // offset: 0x4d (77)
  UCHAR SharedWrite;                                     // offset: 0x4e (78)
  UCHAR SharedDelete;                                    // offset: 0x4f (79)
  ULONG Flags;                                           // offset: 0x50 (80)
  struct _UNICODE_STRING FileName;                       // offset: 0x58 (88)
  union _LARGE_INTEGER CurrentByteOffset;                // offset: 0x68 (104)
  ULONG Waiters;                                         // offset: 0x70 (112)
  ULONG Busy;                                            // offset: 0x74 (116)
  VOID *LastLock;                                        // offset: 0x78 (120)
  struct _KEVENT Lock;                                   // offset: 0x80 (128)
  struct _KEVENT Event;                                  // offset: 0x98 (152)
  struct _IO_COMPLETION_CONTEXT *CompletionContext;      // offset: 0xb0 (176)
  ULONGLONG IrpListLock;                                 // offset: 0xb8 (184)
  struct _LIST_ENTRY IrpList;                            // offset: 0xc0 (192)
  VOID *FileObjectExtension;                             // offset: 0xd0 (208)
};

// 0x40 (64) bytes
struct _VSM_PERFORMANCE_DATA {
  ULONGLONG LaunchVsmMark[8]; // offset: 0x0 (0)
};

// 0xe38 (3640) bytes
struct _LOADER_PARAMETER_EXTENSION {
  ULONG Size;                                            // offset: 0x0 (0)
  struct _PROFILE_PARAMETER_BLOCK Profile;               // offset: 0x4 (4)
  VOID *EmInfFileImage;                                  // offset: 0x18 (24)
  ULONG EmInfFileSize;                                   // offset: 0x20 (32)
  VOID *TriageDumpBlock;                                 // offset: 0x28 (40)
  struct _HEADLESS_LOADER_BLOCK *HeadlessLoaderBlock;    // offset: 0x30 (48)
  struct _SMBIOS3_TABLE_HEADER *SMBiosEPSHeader;         // offset: 0x38 (56)
  VOID *DrvDBImage;                                      // offset: 0x40 (64)
  ULONG DrvDBSize;                                       // offset: 0x48 (72)
  VOID *DrvDBPatchImage;                                 // offset: 0x50 (80)
  ULONG DrvDBPatchSize;                                  // offset: 0x58 (88)
  struct _NETWORK_LOADER_BLOCK *NetworkLoaderBlock;      // offset: 0x60 (96)
  struct _LIST_ENTRY FirmwareDescriptorListHead;         // offset: 0x68 (104)
  VOID *AcpiTable;                                       // offset: 0x78 (120)
  ULONG AcpiTableSize;                                   // offset: 0x80 (128)
  ULONG LastBootSucceeded : 1;                           // offset: 0x84 (132)
  ULONG LastBootShutdown : 1;                            // offset: 0x84 (132)
  ULONG IoPortAccessSupported : 1;                       // offset: 0x84 (132)
  ULONG BootDebuggerActive : 1;                          // offset: 0x84 (132)
  ULONG StrongCodeGuarantees : 1;                        // offset: 0x84 (132)
  ULONG HardStrongCodeGuarantees : 1;                    // offset: 0x84 (132)
  ULONG SidSharingDisabled : 1;                          // offset: 0x84 (132)
  ULONG TpmInitialized : 1;                              // offset: 0x84 (132)
  ULONG VsmConfigured : 1;                               // offset: 0x84 (132)
  ULONG IumEnabled : 1;                                  // offset: 0x84 (132)
  ULONG IsSmbboot : 1;                                   // offset: 0x84 (132)
  ULONG BootLogEnabled : 1;                              // offset: 0x84 (132)
  ULONG DriverVerifierEnabled : 1;                       // offset: 0x84 (132)
  ULONG SuppressMonitorX : 1;                            // offset: 0x84 (132)
  ULONG KernelCetEnabled : 1;                            // offset: 0x84 (132)
  ULONG SuppressSmap : 1;                                // offset: 0x84 (132)
  ULONG Unused : 5;                                      // offset: 0x84 (132)
  ULONG FeatureSimulations : 6;                          // offset: 0x84 (132)
  ULONG MicrocodeSelfHosting : 1;                        // offset: 0x84 (132)
  ULONG XhciLegacyHandoffSkip : 1;                       // offset: 0x84 (132)
  ULONG DisableInsiderOptInHVCI : 1;                     // offset: 0x84 (132)
  ULONG MicrocodeMinVerSupported : 1;                    // offset: 0x84 (132)
  ULONG GpuIommuEnabled : 1;                             // offset: 0x84 (132)
  struct _LOADER_PERFORMANCE_DATA LoaderPerformanceData; // offset: 0x88 (136)
  struct _LIST_ENTRY BootApplicationPersistentData;      // offset: 0xe8 (232)
  VOID *WmdTestResult;                                   // offset: 0xf8 (248)
  struct _GUID BootIdentifier;                           // offset: 0x100 (256)
  ULONG ResumePages;                                     // offset: 0x110 (272)
  VOID *DumpHeader;                                      // offset: 0x118 (280)
  VOID *BgContext;                                       // offset: 0x120 (288)
  VOID *NumaLocalityInfo;                                // offset: 0x128 (296)
  VOID *NumaGroupAssignment;                             // offset: 0x130 (304)
  struct _LIST_ENTRY AttachedHives;                      // offset: 0x138 (312)
  ULONG MemoryCachingRequirementsCount;                  // offset: 0x148 (328)
  VOID *MemoryCachingRequirements;                       // offset: 0x150 (336)
  struct _BOOT_ENTROPY_LDR_RESULT BootEntropyResult;     // offset: 0x158 (344)
  ULONGLONG ProcessorCounterFrequency;                   // offset: 0x9c0 (2496)
  struct _LOADER_PARAMETER_HYPERVISOR_EXTENSION
      HypervisorExtension;                   // offset: 0x9c8 (2504)
  struct _GUID HardwareConfigurationId;      // offset: 0xa08 (2568)
  struct _LIST_ENTRY HalExtensionModuleList; // offset: 0xa18 (2584)
  union _LARGE_INTEGER SystemTime;           // offset: 0xa28 (2600)
  ULONGLONG TimeStampAtSystemTimeRead;       // offset: 0xa30 (2608)
  union {
    ULONGLONG BootFlags; // offset: 0xa38 (2616)
    struct {
      ULONGLONG DbgMenuOsSelection : 1; // offset: 0xa38 (2616)
      ULONGLONG DbgHiberBoot : 1;       // offset: 0xa38 (2616)
      ULONGLONG DbgSoftRestart : 1;     // offset: 0xa38 (2616)
      ULONGLONG DbgMeasuredLaunch : 1;  // offset: 0xa38 (2616)
    };
  };
  union {
    ULONGLONG InternalBootFlags; // offset: 0xa40 (2624)
    struct {
      ULONGLONG DbgUtcBootTime : 1;      // offset: 0xa40 (2624)
      ULONGLONG DbgRtcBootTime : 1;      // offset: 0xa40 (2624)
      ULONGLONG DbgNoLegacyServices : 1; // offset: 0xa40 (2624)
    };
  };
  VOID *WfsFPData;                                       // offset: 0xa48 (2632)
  ULONG WfsFPDataSize;                                   // offset: 0xa50 (2640)
  struct _LOADER_BUGCHECK_PARAMETERS BugcheckParameters; // offset: 0xa58 (2648)
  VOID *ApiSetSchema;                                    // offset: 0xa80 (2688)
  ULONG ApiSetSchemaSize;                                // offset: 0xa88 (2696)
  struct _LIST_ENTRY ApiSetSchemaExtensions;             // offset: 0xa90 (2704)
  struct _UNICODE_STRING AcpiBiosVersion;                // offset: 0xaa0 (2720)
  struct _UNICODE_STRING SmbiosVersion;                  // offset: 0xab0 (2736)
  struct _UNICODE_STRING EfiVersion;                     // offset: 0xac0 (2752)
  struct _DEBUG_DEVICE_DESCRIPTOR *KdDebugDevice;        // offset: 0xad0 (2768)
  struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
      OfflineCrashdumpConfigurationTable;      // offset: 0xad8 (2776)
  struct _UNICODE_STRING ManufacturingProfile; // offset: 0xaf8 (2808)
  VOID *BbtBuffer;                             // offset: 0xb08 (2824)
  ULONGLONG XsaveAllowedFeatures;              // offset: 0xb10 (2832)
  ULONG XsaveFlags;                            // offset: 0xb18 (2840)
  VOID *BootOptions;                           // offset: 0xb20 (2848)
  ULONG IumEnablement;                         // offset: 0xb28 (2856)
  ULONG IumPolicy;                             // offset: 0xb2c (2860)
  LONG IumStatus;                              // offset: 0xb30 (2864)
  ULONG BootId;                                // offset: 0xb34 (2868)
  struct _LOADER_PARAMETER_CI_EXTENSION
      *CodeIntegrityData;      // offset: 0xb38 (2872)
  ULONG CodeIntegrityDataSize; // offset: 0xb40 (2880)
  struct _LOADER_HIVE_RECOVERY_INFO
      SystemHiveRecoveryInfo;               // offset: 0xb44 (2884)
  ULONG SoftRestartCount;                   // offset: 0xb58 (2904)
  LONGLONG SoftRestartTime;                 // offset: 0xb60 (2912)
  VOID *HypercallCodeVa;                    // offset: 0xb68 (2920)
  VOID *HalVirtualAddress;                  // offset: 0xb70 (2928)
  ULONGLONG HalNumberOfBytes;               // offset: 0xb78 (2936)
  struct _LEAP_SECOND_DATA *LeapSecondData; // offset: 0xb80 (2944)
  ULONG MajorRelease;                       // offset: 0xb88 (2952)
  ULONG Reserved1;                          // offset: 0xb8c (2956)
  CHAR NtBuildLab[224];                     // offset: 0xb90 (2960)
  CHAR NtBuildLabEx[224];                   // offset: 0xc70 (3184)
  struct _LOADER_RESET_REASON ResetReason;  // offset: 0xd50 (3408)
  ULONG MaxPciBusNumber;                    // offset: 0xd80 (3456)
  ULONG FeatureSettings;                    // offset: 0xd84 (3460)
  ULONG HotPatchReserveSize;                // offset: 0xd88 (3464)
  ULONG RetpolineReserveSize;               // offset: 0xd8c (3468)
  struct {
    VOID *CodeBase;                                // offset: 0x0 (0)
    ULONGLONG CodeSize;                            // offset: 0x8 (8)
  } MiniExecutive;                                 // offset: 0xd90 (3472)
  struct _VSM_PERFORMANCE_DATA VsmPerformanceData; // offset: 0xda0 (3488)
  struct _NUMA_MEMORY_RANGE *NumaMemoryRanges;     // offset: 0xde0 (3552)
  ULONG NumaMemoryRangeCount;                      // offset: 0xde8 (3560)
  ULONG IommuFaultPolicy;                          // offset: 0xdec (3564)
  struct _LOADER_FEATURE_CONFIGURATION_INFORMATION
      FeatureConfigurationInformation; // offset: 0xdf0 (3568)
};

// 0x160 (352) bytes
struct _LOADER_PARAMETER_BLOCK {
  ULONG OsMajorVersion;                                    // offset: 0x0 (0)
  ULONG OsMinorVersion;                                    // offset: 0x4 (4)
  ULONG Size;                                              // offset: 0x8 (8)
  ULONG OsLoaderSecurityVersion;                           // offset: 0xc (12)
  struct _LIST_ENTRY LoadOrderListHead;                    // offset: 0x10 (16)
  struct _LIST_ENTRY MemoryDescriptorListHead;             // offset: 0x20 (32)
  struct _LIST_ENTRY BootDriverListHead;                   // offset: 0x30 (48)
  struct _LIST_ENTRY EarlyLaunchListHead;                  // offset: 0x40 (64)
  struct _LIST_ENTRY CoreDriverListHead;                   // offset: 0x50 (80)
  struct _LIST_ENTRY CoreExtensionsDriverListHead;         // offset: 0x60 (96)
  struct _LIST_ENTRY TpmCoreDriverListHead;                // offset: 0x70 (112)
  ULONGLONG KernelStack;                                   // offset: 0x80 (128)
  ULONGLONG Prcb;                                          // offset: 0x88 (136)
  ULONGLONG Process;                                       // offset: 0x90 (144)
  ULONGLONG Thread;                                        // offset: 0x98 (152)
  ULONG KernelStackSize;                                   // offset: 0xa0 (160)
  ULONG RegistryLength;                                    // offset: 0xa4 (164)
  VOID *RegistryBase;                                      // offset: 0xa8 (168)
  struct _CONFIGURATION_COMPONENT_DATA *ConfigurationRoot; // offset: 0xb0 (176)
  CHAR *ArcBootDeviceName;                                 // offset: 0xb8 (184)
  CHAR *ArcHalDeviceName;                                  // offset: 0xc0 (192)
  CHAR *NtBootPathName;                                    // offset: 0xc8 (200)
  CHAR *NtHalPathName;                                     // offset: 0xd0 (208)
  CHAR *LoadOptions;                                       // offset: 0xd8 (216)
  struct _NLS_DATA_BLOCK *NlsData;                         // offset: 0xe0 (224)
  struct _ARC_DISK_INFORMATION *ArcDiskInformation;        // offset: 0xe8 (232)
  struct _LOADER_PARAMETER_EXTENSION *Extension;           // offset: 0xf0 (240)
  union {
    struct _I386_LOADER_BLOCK I386; // offset: 0xf8 (248)
    struct _ARM_LOADER_BLOCK Arm;   // offset: 0xf8 (248)

  } u; // offset: 0xf8 (248)
  struct _FIRMWARE_INFORMATION_LOADER_BLOCK
      FirmwareInformation;     // offset: 0x108 (264)
  CHAR *OsBootstatPathName;    // offset: 0x148 (328)
  CHAR *ArcOSDataDeviceName;   // offset: 0x150 (336)
  CHAR *ArcWindowsSysPartName; // offset: 0x158 (344)
};

// 0x68 (104) bytes
struct _KTSS64 {
  ULONG Reserved0;     // offset: 0x0 (0)
  ULONGLONG Rsp0;      // offset: 0x4 (4)
  ULONGLONG Rsp1;      // offset: 0xc (12)
  ULONGLONG Rsp2;      // offset: 0x14 (20)
  ULONGLONG Ist[8];    // offset: 0x1c (28)
  ULONGLONG Reserved1; // offset: 0x5c (92)
  USHORT Reserved2;    // offset: 0x64 (100)
  USHORT IoMapBase;    // offset: 0x66 (102)
};

// 0xa0 (160) bytes
struct _PEBS_DS_SAVE_AREA64 {
  ULONGLONG BtsBufferBase;            // offset: 0x0 (0)
  ULONGLONG BtsIndex;                 // offset: 0x8 (8)
  ULONGLONG BtsAbsoluteMaximum;       // offset: 0x10 (16)
  ULONGLONG BtsInterruptThreshold;    // offset: 0x18 (24)
  ULONGLONG PebsBufferBase;           // offset: 0x20 (32)
  ULONGLONG PebsIndex;                // offset: 0x28 (40)
  ULONGLONG PebsAbsoluteMaximum;      // offset: 0x30 (48)
  ULONGLONG PebsInterruptThreshold;   // offset: 0x38 (56)
  ULONGLONG PebsGpCounterReset[8];    // offset: 0x40 (64)
  ULONGLONG PebsFixedCounterReset[4]; // offset: 0x80 (128)
};

// 0x80 (128) bytes
struct _PEBS_DS_SAVE_AREA32 {
  ULONG BtsBufferBase;                // offset: 0x0 (0)
  ULONG BtsIndex;                     // offset: 0x4 (4)
  ULONG BtsAbsoluteMaximum;           // offset: 0x8 (8)
  ULONG BtsInterruptThreshold;        // offset: 0xc (12)
  ULONG PebsBufferBase;               // offset: 0x10 (16)
  ULONG PebsIndex;                    // offset: 0x14 (20)
  ULONG PebsAbsoluteMaximum;          // offset: 0x18 (24)
  ULONG PebsInterruptThreshold;       // offset: 0x1c (28)
  ULONGLONG PebsGpCounterReset[8];    // offset: 0x20 (32)
  ULONGLONG PebsFixedCounterReset[4]; // offset: 0x60 (96)
};

// 0xa0 (160) bytes
struct _PEBS_DS_SAVE_AREA {
  union {
    struct _PEBS_DS_SAVE_AREA32 As32Bit; // offset: 0x0 (0)
    struct _PEBS_DS_SAVE_AREA64 As64Bit; // offset: 0x0 (0)
  };
};

// 0xa0 (160) bytes
struct _PROCESSOR_PROFILE_CONTROL_AREA {
  struct _PEBS_DS_SAVE_AREA PebsDsSaveArea; // offset: 0x0 (0)
};

// 0xc0 (192) bytes
struct _MMSUPPORT_INSTANCE {
  ULONG NextPageColor;                         // offset: 0x0 (0)
  ULONG PageFaultCount;                        // offset: 0x4 (4)
  ULONGLONG TrimmedPageCount;                  // offset: 0x8 (8)
  struct _MMWSL_INSTANCE *VmWorkingSetList;    // offset: 0x10 (16)
  struct _LIST_ENTRY WorkingSetExpansionLinks; // offset: 0x18 (24)
  ULONGLONG AgeDistribution[8];                // offset: 0x28 (40)
  struct _KGATE *ExitOutswapGate;              // offset: 0x68 (104)
  ULONGLONG MinimumWorkingSetSize;             // offset: 0x70 (112)
  ULONGLONG WorkingSetLeafSize;                // offset: 0x78 (120)
  ULONGLONG WorkingSetLeafPrivateSize;         // offset: 0x80 (128)
  ULONGLONG WorkingSetSize;                    // offset: 0x88 (136)
  ULONGLONG WorkingSetPrivateSize;             // offset: 0x90 (144)
  ULONGLONG MaximumWorkingSetSize;             // offset: 0x98 (152)
  ULONGLONG PeakWorkingSetSize;                // offset: 0xa0 (160)
  ULONG HardFaultCount;                        // offset: 0xa8 (168)
  USHORT LastTrimStamp;                        // offset: 0xac (172)
  USHORT PartitionId;                          // offset: 0xae (174)
  ULONGLONG SelfmapLock;                       // offset: 0xb0 (176)
  struct _MMSUPPORT_FLAGS Flags;               // offset: 0xb8 (184)
};

// 0x140 (320) bytes
struct _MMSUPPORT_FULL {
  struct _MMSUPPORT_INSTANCE Instance; // offset: 0x0 (0)
  struct _MMSUPPORT_SHARED Shared;     // offset: 0xc0 (192)
};

// 0x30 (48) bytes
struct _PS_PROCESS_WAKE_INFORMATION {
  ULONGLONG NotificationChannel;            // offset: 0x0 (0)
  ULONG WakeCounters[7];                    // offset: 0x8 (8)
  struct _JOBOBJECT_WAKE_FILTER WakeFilter; // offset: 0x24 (36)
  ULONG NoWakeCounter;                      // offset: 0x2c (44)
};

// 0x158 (344) bytes
struct _ARBITER_INSTANCE {
  ULONG Signature;                                   // offset: 0x0 (0)
  struct _KEVENT *MutexEvent;                        // offset: 0x8 (8)
  WCHAR *Name;                                       // offset: 0x10 (16)
  WCHAR *OrderingName;                               // offset: 0x18 (24)
  LONG ResourceType;                                 // offset: 0x20 (32)
  struct _RTL_RANGE_LIST *Allocation;                // offset: 0x28 (40)
  struct _RTL_RANGE_LIST *PossibleAllocation;        // offset: 0x30 (48)
  struct _ARBITER_ORDERING_LIST OrderingList;        // offset: 0x38 (56)
  struct _ARBITER_ORDERING_LIST ReservedList;        // offset: 0x48 (72)
  LONG ReferenceCount;                               // offset: 0x58 (88)
  struct _ARBITER_INTERFACE *Interface;              // offset: 0x60 (96)
  ULONG AllocationStackMaxSize;                      // offset: 0x68 (104)
  struct _ARBITER_ALLOCATION_STATE *AllocationStack; // offset: 0x70 (112)
  LONG (*UnpackRequirement)
  (struct _IO_RESOURCE_DESCRIPTOR *arg1, ULONGLONG *arg2, ULONGLONG *arg3,
   ULONGLONG *arg4, ULONGLONG *arg5); // offset: 0x78 (120)
  LONG (*PackResource)
  (struct _IO_RESOURCE_DESCRIPTOR *arg1, ULONGLONG arg2,
   struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *arg3); // offset: 0x80 (128)
  LONG (*UnpackResource)
  (struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *arg1, ULONGLONG *arg2,
   ULONGLONG *arg3); // offset: 0x88 (136)
  LONG (*ScoreRequirement)
  (struct _IO_RESOURCE_DESCRIPTOR *arg1); // offset: 0x90 (144)
  LONG (*TestAllocation)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_TEST_ALLOCATION_PARAMETERS *arg2); // offset: 0x98 (152)
  LONG (*RetestAllocation)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_RETEST_ALLOCATION_PARAMETERS *arg2); // offset: 0xa0 (160)
  LONG (*CommitAllocation)
  (struct _ARBITER_INSTANCE *arg1); // offset: 0xa8 (168)
  LONG (*RollbackAllocation)
  (struct _ARBITER_INSTANCE *arg1); // offset: 0xb0 (176)
  LONG (*BootAllocation)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_BOOT_ALLOCATION_PARAMETERS *arg2); // offset: 0xb8 (184)
  LONG (*QueryArbitrate)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_QUERY_ARBITRATE_PARAMETERS *arg2); // offset: 0xc0 (192)
  LONG (*QueryConflict)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_QUERY_CONFLICT_PARAMETERS *arg2); // offset: 0xc8 (200)
  LONG (*AddReserved)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ADD_RESERVED_PARAMETERS *arg2); // offset: 0xd0 (208)
  LONG (*StartArbiter)
  (struct _ARBITER_INSTANCE *arg1,
   struct _CM_RESOURCE_LIST *arg2); // offset: 0xd8 (216)
  LONG (*PreprocessEntry)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ALLOCATION_STATE *arg2); // offset: 0xe0 (224)
  LONG (*AllocateEntry)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ALLOCATION_STATE *arg2); // offset: 0xe8 (232)
  UCHAR (*GetNextAllocationRange)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ALLOCATION_STATE *arg2); // offset: 0xf0 (240)
  UCHAR (*FindSuitableRange)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ALLOCATION_STATE *arg2); // offset: 0xf8 (248)
  VOID (*AddAllocation)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ALLOCATION_STATE *arg2); // offset: 0x100 (256)
  VOID (*BacktrackAllocation)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ALLOCATION_STATE *arg2); // offset: 0x108 (264)
  UCHAR (*OverrideConflict)
  (struct _ARBITER_INSTANCE *arg1,
   struct _ARBITER_ALLOCATION_STATE *arg2); // offset: 0x110 (272)
  LONG (*InitializeRangeList)
  (struct _ARBITER_INSTANCE *arg1, ULONG arg2,
   struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *arg3,
   struct _RTL_RANGE_LIST *arg4); // offset: 0x118 (280)
  LONG (*DeleteOwnerRanges)
  (struct _ARBITER_INSTANCE *arg1, VOID *arg2); // offset: 0x120 (288)
  UCHAR TransactionInProgress;                  // offset: 0x128 (296)
  struct _KEVENT *TransactionEvent;             // offset: 0x130 (304)
  VOID *Extension;                              // offset: 0x138 (312)
  struct _DEVICE_OBJECT *BusDeviceObject;       // offset: 0x140 (320)
  VOID *ConflictCallbackContext;                // offset: 0x148 (328)
  UCHAR (*ConflictCallback)
  (VOID *arg1, struct _RTL_RANGE *arg2); // offset: 0x150 (336)
};

// 0x28 (40) bytes
struct _HIDDEN_PROCESSOR_POWER_INTERFACE {
  ULONG Version; // offset: 0x0 (0)
  LONG (*ReadPerfMsr)
  (ULONG arg1, ULONG arg2, ULONGLONG *arg3); // offset: 0x8 (8)
  LONG (*WritePerfMsr)
  (ULONG arg1, ULONG arg2, ULONGLONG arg3, ULONGLONG arg4); // offset: 0x10 (16)
  LONG (*ReadPerfIoPort)
  (ULONG arg1, USHORT arg2, USHORT arg3, ULONG *arg4); // offset: 0x18 (24)
  LONG (*WritePerfIoPort)
  (ULONG arg1, USHORT arg2, USHORT arg3, ULONG arg4,
   ULONG arg5); // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _PNP_REPLACE_PROCESSOR_LIST {
  ULONGLONG *Affinity;  // offset: 0x0 (0)
  ULONG GroupCount;     // offset: 0x8 (8)
  ULONG AllocatedCount; // offset: 0xc (12)
  ULONG Count;          // offset: 0x10 (16)
  ULONG ApicIds[1];     // offset: 0x14 (20)
};

// 0x18 (24) bytes
struct _HAL_DP_REPLACE_PARAMETERS {
  ULONG Flags;                                          // offset: 0x0 (0)
  struct _PNP_REPLACE_PROCESSOR_LIST *TargetProcessors; // offset: 0x8 (8)
  struct _PNP_REPLACE_PROCESSOR_LIST *SpareProcessors;  // offset: 0x10 (16)
};

// 0x2c0 (704) bytes
struct _HEAP {
  union {
    struct _HEAP_SEGMENT Segment; // offset: 0x0 (0)
    struct {
      struct _HEAP_ENTRY Entry;              // offset: 0x0 (0)
      ULONG SegmentSignature;                // offset: 0x10 (16)
      ULONG SegmentFlags;                    // offset: 0x14 (20)
      struct _LIST_ENTRY SegmentListEntry;   // offset: 0x18 (24)
      struct _HEAP *Heap;                    // offset: 0x28 (40)
      VOID *BaseAddress;                     // offset: 0x30 (48)
      ULONG NumberOfPages;                   // offset: 0x38 (56)
      struct _HEAP_ENTRY *FirstEntry;        // offset: 0x40 (64)
      struct _HEAP_ENTRY *LastValidEntry;    // offset: 0x48 (72)
      ULONG NumberOfUnCommittedPages;        // offset: 0x50 (80)
      ULONG NumberOfUnCommittedRanges;       // offset: 0x54 (84)
      USHORT SegmentAllocatorBackTraceIndex; // offset: 0x58 (88)
      USHORT Reserved;                       // offset: 0x5a (90)
      struct _LIST_ENTRY UCRSegmentList;     // offset: 0x60 (96)
    };
  };
  ULONG Flags;                                     // offset: 0x70 (112)
  ULONG ForceFlags;                                // offset: 0x74 (116)
  ULONG CompatibilityFlags;                        // offset: 0x78 (120)
  ULONG EncodeFlagMask;                            // offset: 0x7c (124)
  struct _HEAP_ENTRY Encoding;                     // offset: 0x80 (128)
  ULONG Interceptor;                               // offset: 0x90 (144)
  ULONG VirtualMemoryThreshold;                    // offset: 0x94 (148)
  ULONG Signature;                                 // offset: 0x98 (152)
  ULONGLONG SegmentReserve;                        // offset: 0xa0 (160)
  ULONGLONG SegmentCommit;                         // offset: 0xa8 (168)
  ULONGLONG DeCommitFreeBlockThreshold;            // offset: 0xb0 (176)
  ULONGLONG DeCommitTotalFreeThreshold;            // offset: 0xb8 (184)
  ULONGLONG TotalFreeSize;                         // offset: 0xc0 (192)
  ULONGLONG MaximumAllocationSize;                 // offset: 0xc8 (200)
  USHORT ProcessHeapsListIndex;                    // offset: 0xd0 (208)
  USHORT HeaderValidateLength;                     // offset: 0xd2 (210)
  VOID *HeaderValidateCopy;                        // offset: 0xd8 (216)
  USHORT NextAvailableTagIndex;                    // offset: 0xe0 (224)
  USHORT MaximumTagIndex;                          // offset: 0xe2 (226)
  struct _HEAP_TAG_ENTRY *TagEntries;              // offset: 0xe8 (232)
  struct _LIST_ENTRY UCRList;                      // offset: 0xf0 (240)
  ULONGLONG AlignRound;                            // offset: 0x100 (256)
  ULONGLONG AlignMask;                             // offset: 0x108 (264)
  struct _LIST_ENTRY VirtualAllocdBlocks;          // offset: 0x110 (272)
  struct _LIST_ENTRY SegmentList;                  // offset: 0x120 (288)
  USHORT AllocatorBackTraceIndex;                  // offset: 0x130 (304)
  ULONG NonDedicatedListLength;                    // offset: 0x134 (308)
  VOID *BlocksIndex;                               // offset: 0x138 (312)
  VOID *UCRIndex;                                  // offset: 0x140 (320)
  struct _HEAP_PSEUDO_TAG_ENTRY *PseudoTagEntries; // offset: 0x148 (328)
  struct _LIST_ENTRY FreeLists;                    // offset: 0x150 (336)
  struct _HEAP_LOCK *LockVariable;                 // offset: 0x160 (352)
  LONG (*CommitRoutine)
  (VOID *arg1, VOID **arg2, ULONGLONG *arg3);         // offset: 0x168 (360)
  union _RTL_RUN_ONCE StackTraceInitVar;              // offset: 0x170 (368)
  struct _RTL_HEAP_MEMORY_LIMIT_DATA CommitLimitData; // offset: 0x178 (376)
  VOID *FrontEndHeap;                                 // offset: 0x198 (408)
  USHORT FrontHeapLockCount;                          // offset: 0x1a0 (416)
  UCHAR FrontEndHeapType;                             // offset: 0x1a2 (418)
  UCHAR RequestedFrontEndHeapType;                    // offset: 0x1a3 (419)
  WCHAR *FrontEndHeapUsageData;                       // offset: 0x1a8 (424)
  USHORT FrontEndHeapMaximumIndex;                    // offset: 0x1b0 (432)
  volatile UCHAR FrontEndHeapStatusBitmap[129];       // offset: 0x1b2 (434)
  struct _HEAP_COUNTERS Counters;                     // offset: 0x238 (568)
  struct _HEAP_TUNING_PARAMETERS TuningParameters;    // offset: 0x2b0 (688)
};

// 0x40 (64) bytes
struct _RTL_CSPARSE_BITMAP {
  ULONGLONG *CommitBitmap;             // offset: 0x0 (0)
  ULONGLONG *UserBitmap;               // offset: 0x8 (8)
  ULONGLONG BitCount;                  // offset: 0x10 (16)
  ULONGLONG BitmapLock;                // offset: 0x18 (24)
  ULONGLONG DecommitPageIndex;         // offset: 0x20 (32)
  ULONGLONG RtlpCSparseBitmapWakeLock; // offset: 0x28 (40)
  UCHAR LockType;                      // offset: 0x30 (48)
  UCHAR AddressSpace;                  // offset: 0x31 (49)
  UCHAR MemType;                       // offset: 0x32 (50)
  UCHAR AllocAlignment;                // offset: 0x33 (51)
  ULONG CommitDirectoryMaxSize;        // offset: 0x34 (52)
  ULONGLONG CommitDirectory[1];        // offset: 0x38 (56)
};

// 0x50 (80) bytes
struct _RTLP_HP_ALLOC_TRACKER {
  ULONGLONG BaseAddress; // offset: 0x0 (0)
  union {
    struct _RTL_CSPARSE_BITMAP AllocTrackerBitmap; // offset: 0x8 (8)
    UCHAR AllocTrackerBitmapBuffer[72];            // offset: 0x8 (8)
  };
};

// 0x50 (80) bytes
struct _RTL_SPARSE_ARRAY {
  ULONGLONG ElementCount;            // offset: 0x0 (0)
  ULONG ElementSizeShift;            // offset: 0x8 (8)
  struct _RTL_CSPARSE_BITMAP Bitmap; // offset: 0x10 (16)
};

// 0x860 (2144) bytes
struct _HEAP_VAMGR_VASPACE {
  enum _RTLP_HP_ADDRESS_SPACE_TYPE AddressSpaceType; // offset: 0x0 (0)
  ULONGLONG BaseAddress;                             // offset: 0x8 (8)
  union {
    struct _RTL_SPARSE_ARRAY VaRangeArray; // offset: 0x10 (16)
    UCHAR VaRangeArrayBuffer[2128];        // offset: 0x10 (16)
  };
};

// 0x30 (48) bytes
struct _HEAP_VAMGR_ALLOCATOR {
  ULONGLONG TreeLock;                  // offset: 0x0 (0)
  struct _RTL_RB_TREE FreeRanges;      // offset: 0x8 (8)
  struct _HEAP_VAMGR_VASPACE *VaSpace; // offset: 0x18 (24)
  VOID *PartitionHandle;               // offset: 0x20 (32)
  USHORT ChunksPerRegion;              // offset: 0x28 (40)
  USHORT RefCount;                     // offset: 0x2a (42)
  UCHAR AllocatorIndex;                // offset: 0x2c (44)
  UCHAR NumaNode;                      // offset: 0x2d (45)
  UCHAR LockType : 1;                  // offset: 0x2e (46)
  UCHAR MemoryType : 2;                // offset: 0x2e (46)
  UCHAR ConstrainedVA : 1;             // offset: 0x2e (46)
  UCHAR AllowFreeHead : 1;             // offset: 0x2e (46)
  UCHAR Spare0 : 3;                    // offset: 0x2e (46)
  UCHAR Spare1;                        // offset: 0x2f (47)
};

// 0x3840 (14400) bytes
struct _HEAP_VAMGR_CTX {
  struct _HEAP_VAMGR_VASPACE VaSpace;           // offset: 0x0 (0)
  ULONGLONG AllocatorLock;                      // offset: 0x860 (2144)
  ULONG AllocatorCount;                         // offset: 0x868 (2152)
  struct _HEAP_VAMGR_ALLOCATOR Allocators[255]; // offset: 0x870 (2160)
};

// 0x1f0 (496) bytes
struct _HAL_INTEL_ENLIGHTENMENT_INFORMATION {
  ULONG Enlightenments;                         // offset: 0x0 (0)
  ULONG HypervisorConnected;                    // offset: 0x4 (4)
  VOID (*EndOfInterrupt)();                     // offset: 0x8 (8)
  VOID (*ApicWriteIcr)(ULONG arg1, ULONG arg2); // offset: 0x10 (16)
  ULONG Reserved0;                              // offset: 0x18 (24)
  ULONG SpinCountMask;                          // offset: 0x1c (28)
  VOID (*LongSpinWait)(ULONG arg1);             // offset: 0x20 (32)
  ULONGLONG (*GetReferenceTime)();              // offset: 0x28 (40)
  LONG (*SetSystemSleepProperty)
  (ULONG arg1, UCHAR arg2, UCHAR arg3); // offset: 0x30 (48)
  LONG (*EnterSleepState)(ULONG arg1);  // offset: 0x38 (56)
  LONG (*NotifyDebugDeviceAvailable)(); // offset: 0x40 (64)
  LONG (*MapDeviceInterrupt)
  (ULONGLONG arg1, VOID *arg2, struct _GROUP_AFFINITY *arg3,
   VOID *arg4);                                             // offset: 0x48 (72)
  LONG (*UnmapDeviceInterrupt)(ULONGLONG arg1, VOID *arg2); // offset: 0x50 (80)
  LONG (*RetargetDeviceInterrupt)
  (ULONGLONG arg1, VOID *arg2, VOID *arg3, struct _GROUP_AFFINITY *arg4,
   VOID *arg5); // offset: 0x58 (88)
  LONG (*SetHpetConfig)
  (union _LARGE_INTEGER arg1, ULONG arg2, ULONGLONG arg3, UCHAR arg4,
   VOID *arg5);                // offset: 0x60 (96)
  LONG (*NotifyHpetEnabled)(); // offset: 0x68 (104)
  LONG (*QueryAssociatedProcessors)
  (ULONG arg1, ULONG *arg2, ULONG *arg3); // offset: 0x70 (112)
  LONG (*ReadMultipleMsr)
  (ULONG arg1, ULONG arg2, ULONG *arg3, ULONGLONG *arg4); // offset: 0x78 (120)
  LONG (*WriteMultipleMsr)
  (ULONG arg1, ULONG arg2, ULONG *arg3, ULONGLONG *arg4); // offset: 0x80 (128)
  LONG (*ReadCpuid)
  (ULONG arg1, ULONG arg2, ULONG *arg3, ULONG *arg4, ULONG *arg5,
   ULONG *arg6);                             // offset: 0x88 (136)
  LONG (*LpWritebackInvalidate)(ULONG arg1); // offset: 0x90 (144)
  LONG (*GetMachineCheckContext)
  (ULONG arg1, ULONG *arg2, ULONGLONG *arg3, ULONG *arg4); // offset: 0x98 (152)
  LONG (*SuspendPartition)(ULONGLONG arg1);                // offset: 0xa0 (160)
  LONG (*ResumePartition)(ULONGLONG arg1);                 // offset: 0xa8 (168)
  LONG (*SetSystemMachineCheckProperty)(VOID *arg1);       // offset: 0xb0 (176)
  LONG (*WheaErrorNotification)
  (struct _WHEA_RECOVERY_CONTEXT *arg1, UCHAR arg2,
   UCHAR arg3);                                      // offset: 0xb8 (184)
  ULONG (*GetProcessorIndexFromVpIndex)(ULONG arg1); // offset: 0xc0 (192)
  LONG (*SyntheticClusterIpi)
  (struct _KAFFINITY_EX *arg1, ULONG arg2);              // offset: 0xc8 (200)
  UCHAR (*VpStartEnabled)();                             // offset: 0xd0 (208)
  LONG (*StartVirtualProcessor)(ULONG arg1, VOID *arg2); // offset: 0xd8 (216)
  LONG (*GetVpIndexFromApicId)(ULONG arg1, ULONG *arg2); // offset: 0xe0 (224)
  LONG (*IumAccessPciDevice)
  (UCHAR arg1, ULONG arg2, ULONG arg3, ULONG arg4, ULONG arg5, ULONG arg6,
   ULONG arg7, VOID *arg8); // offset: 0xe8 (232)
  ULONGLONG (*IumEfiRuntimeService)
  (ULONG arg1, VOID *arg2, ULONGLONG arg3,
   ULONGLONG *arg4); // offset: 0xf0 (240)
  VOID (*SvmGetSystemCapabilities)
  (struct _HAL_HV_SVM_SYSTEM_CAPABILITIES *arg1); // offset: 0xf8 (248)
  LONG (*SvmGetDeviceCapabilities)
  (ULONG arg1,
   struct _HAL_HV_SVM_DEVICE_CAPABILITIES *arg2);      // offset: 0x100 (256)
  LONG (*SvmCreatePasidSpace)(ULONG arg1, ULONG arg2); // offset: 0x108 (264)
  LONG (*SvmSetPasidAddressSpace)
  (ULONG arg1, ULONG arg2, ULONGLONG arg3); // offset: 0x110 (272)
  VOID (*SvmFlushPasid)
  (ULONG arg1, ULONG arg2, ULONG arg3,
   struct _KTB_FLUSH_VA *arg4); // offset: 0x118 (280)
  LONG (*SvmAttachPasidSpace)
  (ULONG arg1, ULONG arg2, ULONG arg3, ULONG arg4); // offset: 0x120 (288)
  LONG (*SvmDetachPasidSpace)(ULONG arg1);          // offset: 0x128 (296)
  LONG (*SvmEnablePasid)(ULONG arg1, ULONG arg2);   // offset: 0x130 (304)
  LONG (*SvmDisablePasid)(ULONG arg1, ULONG arg2);  // offset: 0x138 (312)
  LONG (*SvmAcknowledgePageRequest)
  (ULONG arg1, VOID *arg2, ULONG *arg3); // offset: 0x140 (320)
  LONG (*SvmCreatePrQueue)
  (ULONG arg1, ULONG arg2, union _LARGE_INTEGER arg3, ULONG arg4,
   ULONG arg5);                                        // offset: 0x148 (328)
  LONG (*SvmDeletePrQueue)(ULONG arg1);                // offset: 0x150 (336)
  LONG (*SvmClearPrqStalled)(ULONG arg1);              // offset: 0x158 (344)
  LONG (*SvmSetDeviceEnabled)(ULONG arg1, UCHAR arg2); // offset: 0x160 (352)
  LONG (*HvDebuggerPowerHandler)(UCHAR arg1);          // offset: 0x168 (360)
  LONG (*SetQpcBias)(ULONGLONG arg1);                  // offset: 0x170 (368)
  ULONGLONG (*GetQpcBias)();                           // offset: 0x178 (376)
  LONG (*RegisterDeviceId)
  (struct _EXT_IOMMU_DEVICE_ID *arg1, ULONGLONG arg2); // offset: 0x180 (384)
  LONG (*UnregisterDeviceId)(ULONGLONG arg1);          // offset: 0x188 (392)
  LONG (*AllocateDeviceDomain)
  (struct _HAL_HV_DMA_DOMAIN_INFO *arg1); // offset: 0x190 (400)
  LONG (*AttachDeviceDomain)
  (struct _EXT_IOMMU_DEVICE_ID *arg1,
   struct _HAL_HV_DMA_DOMAIN_INFO *arg2);     // offset: 0x198 (408)
  LONG (*DetachDeviceDomain)(ULONGLONG arg1); // offset: 0x1a0 (416)
  LONG (*DeleteDeviceDomain)
  (struct _HAL_HV_DMA_DOMAIN_INFO *arg1); // offset: 0x1a8 (424)
  LONG (*MapDeviceLogicalRange)
  (struct _HAL_HV_DMA_DOMAIN_INFO *arg1, ULONG arg2, ULONGLONG arg3,
   ULONGLONG *arg4, ULONGLONG *arg5, UCHAR arg6); // offset: 0x1b0 (432)
  LONG (*UnmapDeviceLogicalRange)
  (struct _HAL_HV_DMA_DOMAIN_INFO *arg1, ULONGLONG arg2,
   ULONGLONG *arg3); // offset: 0x1b8 (440)
  LONG (*MapDeviceSparsePages)
  (struct _HAL_HV_DMA_DOMAIN_INFO *arg1, ULONG arg2, ULONGLONG *arg3,
   ULONGLONG *arg4); // offset: 0x1c0 (448)
  LONG (*UnmapDeviceSparsePages)
  (struct _HAL_HV_DMA_DOMAIN_INFO *arg1, ULONGLONG *arg2,
   ULONGLONG *arg3);                               // offset: 0x1c8 (456)
  LONG (*GetDmaGuardEnabled)(UCHAR *arg1);         // offset: 0x1d0 (464)
  LONG (*UpdateMicrocode)(VOID *arg1, ULONG arg2); // offset: 0x1d8 (472)
  LONG (*GetSintMessage)(UCHAR arg1, VOID **arg2); // offset: 0x1e0 (480)
  LONG (*SetRootFaultReportingReady)();            // offset: 0x1e8 (488)
};

// 0xb8 (184) bytes
struct _INTERRUPT_FUNCTION_TABLE {
  LONG (*InitializeLocalUnit)
  (VOID *arg1, ULONG arg2, ULONG arg3, ULONG arg4, ULONG arg5,
   ULONG *arg6);                               // offset: 0x0 (0)
  LONG (*InitializeIoUnit)(VOID *arg1);        // offset: 0x8 (8)
  VOID (*SetPriority)(VOID *arg1, ULONG arg2); // offset: 0x10 (16)
  ULONG (*GetLocalUnitError)(VOID *arg1);      // offset: 0x18 (24)
  VOID (*ClearLocalUnitError)(VOID *arg1);     // offset: 0x20 (32)
  LONG (*GetLogicalId)
  (VOID *arg1, struct _INTERRUPT_TARGET *arg2); // offset: 0x28 (40)
  LONG (*SetLogicalId)
  (VOID *arg1, struct _INTERRUPT_TARGET *arg2); // offset: 0x30 (48)
  enum _INTERRUPT_RESULT (*AcceptAndGetSource)(
      VOID *arg1, LONG *arg2, ULONG *arg3); // offset: 0x38 (56)
  VOID (*EndOfInterrupt)(VOID *arg1);       // offset: 0x40 (64)
  VOID (*FastEndOfInterrupt)();             // offset: 0x48 (72)
  LONG (*SetLineState)
  (VOID *arg1, struct _INTERRUPT_LINE *arg2,
   struct _INTERRUPT_LINE_STATE *arg3); // offset: 0x50 (80)
  LONG (*RequestInterrupt)
  (VOID *arg1, struct _INTERRUPT_LINE *arg2, struct _INTERRUPT_TARGET *arg3,
   ULONG arg4, struct _INTERRUPT_LINE *arg5); // offset: 0x58 (88)
  LONG (*StartProcessor)
  (VOID *arg1, ULONG arg2, VOID *arg3, ULONG arg4); // offset: 0x60 (96)
  LONG (*GenerateMessage)
  (VOID *arg1, struct _INTERRUPT_LINE_STATE *arg2, ULONGLONG *arg3,
   ULONGLONG *arg4); // offset: 0x68 (104)
  LONG (*ConvertId)
  (VOID *arg1, ULONG *arg2, struct _INTERRUPT_TARGET *arg3,
   UCHAR arg4);                                          // offset: 0x70 (112)
  LONG (*SaveLocalInterrupts)(VOID *arg1, VOID *arg2);   // offset: 0x78 (120)
  LONG (*ReplayLocalInterrupts)(VOID *arg1, VOID *arg2); // offset: 0x80 (128)
  LONG (*DeinitializeLocalUnit)(VOID *arg1);             // offset: 0x88 (136)
  LONG (*DeinitializeIoUnit)(VOID *arg1);                // offset: 0x90 (144)
  enum _INTERRUPT_RESULT (*QueryAndGetSource)(
      VOID *arg1, LONG *arg2, ULONG *arg3, UCHAR *arg4); // offset: 0x98 (152)
  VOID (*DeactivateInterrupt)(VOID *arg1, ULONG arg2);   // offset: 0xa0 (160)
  VOID (*DirectedEndOfInterrupt)
  (VOID *arg1, ULONG arg2, ULONG arg3); // offset: 0xa8 (168)
  LONG (*QueryLocalUnitInfo)
  (VOID *arg1, ULONG arg2, ULONG *arg3, ULONG *arg4,
   enum _KINTERRUPT_MODE *arg5,
   enum _KINTERRUPT_MODE *arg6); // offset: 0xb0 (176)
};

// 0x160 (352) bytes
struct _REGISTERED_INTERRUPT_CONTROLLER {
  struct _LIST_ENTRY ListEntry;                   // offset: 0x0 (0)
  VOID *InternalData;                             // offset: 0x10 (16)
  ULONG InternalDataSize;                         // offset: 0x18 (24)
  struct _INTERRUPT_FUNCTION_TABLE FunctionTable; // offset: 0x20 (32)
  enum _KNOWN_CONTROLLER_TYPE KnownType;          // offset: 0xd8 (216)
  ULONG Capabilities;                             // offset: 0xdc (220)
  ULONG Flags;                                    // offset: 0xe0 (224)
  ULONG MaxPriority;                              // offset: 0xe4 (228)
  ULONG UnitId;                                   // offset: 0xe8 (232)
  struct _LIST_ENTRY LinesHead;                   // offset: 0xf0 (240)
  struct _LIST_ENTRY OutputLinesHead;             // offset: 0x100 (256)
  LONG MinLine;                                   // offset: 0x110 (272)
  LONG MaxLine;                                   // offset: 0x114 (276)
  ULONG MaxClusterSize;                           // offset: 0x118 (280)
  ULONG MaxClusters;                              // offset: 0x11c (284)
  ULONG InterruptReplayDataSize;                  // offset: 0x120 (288)
  enum _INTERRUPT_PROBLEM Problem;                // offset: 0x124 (292)
  LONG ProblemStatus;                             // offset: 0x128 (296)
  const CHAR *ProblemSourceFile;                  // offset: 0x130 (304)
  ULONG ProblemSourceLine;                        // offset: 0x138 (312)
  ULONG CustomProblem;                            // offset: 0x13c (316)
  LONG CustomProblemStatus;                       // offset: 0x140 (320)
  struct _UNICODE_STRING ResourceId;              // offset: 0x148 (328)
  struct POHANDLE__ *PowerHandle;                 // offset: 0x158 (344)
};

// 0x30 (48) bytes
struct _PROC_FEEDBACK_COUNTER {
  union {
    VOID (*InstantaneousRead)(ULONGLONG arg1, ULONG *arg2); // offset: 0x0 (0)
    VOID (*DifferentialRead)
    (ULONGLONG arg1, UCHAR arg2, ULONGLONG *arg3,
     ULONGLONG *arg4); // offset: 0x0 (0)
  };
  ULONGLONG LastActualCount;    // offset: 0x8 (8)
  ULONGLONG LastReferenceCount; // offset: 0x10 (16)
  ULONG CachedValue;            // offset: 0x18 (24)
  UCHAR Affinitized;            // offset: 0x20 (32)
  UCHAR Differential;           // offset: 0x21 (33)
  UCHAR DiscardIdleTime;        // offset: 0x22 (34)
  UCHAR Scaling;                // offset: 0x23 (35)
  ULONGLONG Context;            // offset: 0x28 (40)
};

// 0x50 (80) bytes
struct _POP_FX_DRIVER_CALLBACKS {
  VOID (*ComponentActive)(VOID *arg1, ULONG arg2); // offset: 0x0 (0)
  VOID (*ComponentIdle)(VOID *arg1, ULONG arg2);   // offset: 0x8 (8)
  VOID (*ComponentIdleState)
  (VOID *arg1, ULONG arg2, ULONG arg3);       // offset: 0x10 (16)
  VOID (*DevicePowerRequired)(VOID *arg1);    // offset: 0x18 (24)
  VOID (*DevicePowerNotRequired)(VOID *arg1); // offset: 0x20 (32)
  LONG (*PowerControl)
  (VOID *arg1, struct _GUID *arg2, VOID *arg3, ULONGLONG arg4, VOID *arg5,
   ULONGLONG arg6, ULONGLONG *arg7); // offset: 0x28 (40)
  VOID (*ComponentCriticalTransition)
  (VOID *arg1, ULONG arg2, UCHAR arg3); // offset: 0x30 (48)
  VOID (*DripsWatchdogCallback)
  (VOID *arg1, struct _DEVICE_OBJECT *arg2, ULONG arg3);   // offset: 0x38 (56)
  VOID (*DirectedPowerUpCallback)(VOID *arg1, ULONG arg2); // offset: 0x40 (64)
  VOID (*DirectedPowerDownCallback)
  (VOID *arg1, ULONG arg2); // offset: 0x48 (72)
};

// 0x300 (768) bytes
struct _PROC_PERF_DOMAIN {
  struct _LIST_ENTRY Link;                                // offset: 0x0 (0)
  struct _PROC_PERF_CHECK_CONTEXT *Master;                // offset: 0x10 (16)
  struct _KAFFINITY_EX Members;                           // offset: 0x18 (24)
  ULONGLONG DomainContext;                                // offset: 0xc0 (192)
  ULONG ProcessorCount;                                   // offset: 0xc8 (200)
  UCHAR EfficiencyClass;                                  // offset: 0xcc (204)
  UCHAR NominalPerformanceClass;                          // offset: 0xcd (205)
  UCHAR HighestPerformanceClass;                          // offset: 0xce (206)
  enum _PROCESSOR_PRESENCE Presence;                      // offset: 0xd0 (208)
  struct _PROC_PERF_CONSTRAINT *Processors;               // offset: 0xd8 (216)
  VOID (*GetFFHThrottleState)(ULONGLONG *arg1);           // offset: 0xe0 (224)
  VOID (*TimeWindowHandler)(ULONGLONG arg1, ULONG arg2);  // offset: 0xe8 (232)
  VOID (*BoostPolicyHandler)(ULONGLONG arg1, ULONG arg2); // offset: 0xf0 (240)
  VOID (*BoostModeHandler)(ULONGLONG arg1, ULONG arg2);   // offset: 0xf8 (248)
  VOID (*AutonomousActivityWindowHandler)
  (ULONGLONG arg1, ULONG arg2); // offset: 0x100 (256)
  VOID (*AutonomousModeHandler)
  (ULONGLONG arg1, ULONG arg2);                // offset: 0x108 (264)
  VOID (*ReinitializeHandler)(ULONGLONG arg1); // offset: 0x110 (272)
  ULONG (*PerfSelectionHandler)
  (ULONGLONG arg1, ULONG arg2, ULONG arg3, ULONG arg4, ULONG arg5, ULONG arg6,
   ULONG arg7, ULONG *arg8, ULONGLONG *arg9); // offset: 0x118 (280)
  VOID (*PerfControlHandler)
  (ULONGLONG arg1, struct _PERF_CONTROL_STATE_SELECTION *arg2, UCHAR arg3,
   UCHAR arg4); // offset: 0x120 (288)
  VOID (*PerfControlHandlerHidden)
  (ULONGLONG arg1, struct _PERF_CONTROL_STATE_SELECTION *arg2, UCHAR arg3,
   UCHAR arg4); // offset: 0x128 (296)
  VOID (*DomainPerfControlHandler)
  (ULONGLONG arg1, struct _PERF_CONTROL_STATE_SELECTION *arg2, UCHAR arg3,
   UCHAR arg4);                                         // offset: 0x130 (304)
  ULONG MaxFrequency;                                   // offset: 0x138 (312)
  ULONG NominalFrequency;                               // offset: 0x13c (316)
  ULONG MaxPercent;                                     // offset: 0x140 (320)
  ULONG MinPerfPercent;                                 // offset: 0x144 (324)
  ULONG MinThrottlePercent;                             // offset: 0x148 (328)
  ULONG AdvertizedMaximumFrequency;                     // offset: 0x14c (332)
  ULONGLONG MinimumRelativePerformance;                 // offset: 0x150 (336)
  ULONGLONG NominalRelativePerformance;                 // offset: 0x158 (344)
  UCHAR NominalRelativePerformancePercent;              // offset: 0x160 (352)
  UCHAR Coordination;                                   // offset: 0x161 (353)
  UCHAR HardPlatformCap;                                // offset: 0x162 (354)
  UCHAR AffinitizeControl;                              // offset: 0x163 (355)
  UCHAR EfficientThrottle;                              // offset: 0x164 (356)
  UCHAR AllowSchedulerDirectedPerfStates;               // offset: 0x165 (357)
  UCHAR InitiateAllProcessors;                          // offset: 0x166 (358)
  UCHAR AutonomousMode;                                 // offset: 0x167 (359)
  UCHAR ProvideGuidance;                                // offset: 0x168 (360)
  ULONG DesiredPercent;                                 // offset: 0x16c (364)
  ULONG GuaranteedPercent;                              // offset: 0x170 (368)
  UCHAR EngageResponsivenessOverrides;                  // offset: 0x174 (372)
  struct _PROC_PERF_QOS_CLASS_POLICY QosPolicies[5];    // offset: 0x178 (376)
  ULONG QosDisableReasons[5];                           // offset: 0x204 (516)
  USHORT QosEquivalencyMasks[5];                        // offset: 0x218 (536)
  UCHAR QosSupported;                                   // offset: 0x222 (546)
  volatile ULONG SelectionGeneration;                   // offset: 0x224 (548)
  struct _PERF_CONTROL_STATE_SELECTION QosSelection[5]; // offset: 0x228 (552)
  ULONGLONG PerfChangeTime;                             // offset: 0x2f0 (752)
  ULONG PerfChangeIntervalCount;                        // offset: 0x2f8 (760)
  UCHAR Force;                                          // offset: 0x2fc (764)
  UCHAR Update;                                         // offset: 0x2fd (765)
  UCHAR Apply;                                          // offset: 0x2fe (766)
};

// 0x40 (64) bytes
struct _PROC_PERF_CHECK_CONTEXT {
  struct _PROC_PERF_DOMAIN *Domain;         // offset: 0x0 (0)
  struct _PROC_PERF_CONSTRAINT *Constraint; // offset: 0x8 (8)
  struct _PROC_PERF_CHECK *PerfCheck;       // offset: 0x10 (16)
  struct _PROC_PERF_LOAD *Load;             // offset: 0x18 (24)
  struct _PROC_PERF_HISTORY *PerfHistory;   // offset: 0x20 (32)
  ULONG Utility;                            // offset: 0x28 (40)
  ULONG AffinitizedUtility;                 // offset: 0x2c (44)
  ULONG MediaUtility;                       // offset: 0x30 (48)
  USHORT LatestAffinitizedPercent;          // offset: 0x34 (52)
  USHORT AveragePerformancePercent;         // offset: 0x36 (54)
  ULONG RelativePerformance;                // offset: 0x38 (56)
  UCHAR NtProcessor;                        // offset: 0x3c (60)
};

// 0x440 (1088) bytes
struct _RTL_USER_PROCESS_PARAMETERS {
  ULONG MaximumLength;                                   // offset: 0x0 (0)
  ULONG Length;                                          // offset: 0x4 (4)
  ULONG Flags;                                           // offset: 0x8 (8)
  ULONG DebugFlags;                                      // offset: 0xc (12)
  VOID *ConsoleHandle;                                   // offset: 0x10 (16)
  ULONG ConsoleFlags;                                    // offset: 0x18 (24)
  VOID *StandardInput;                                   // offset: 0x20 (32)
  VOID *StandardOutput;                                  // offset: 0x28 (40)
  VOID *StandardError;                                   // offset: 0x30 (48)
  struct _CURDIR CurrentDirectory;                       // offset: 0x38 (56)
  struct _UNICODE_STRING DllPath;                        // offset: 0x50 (80)
  struct _UNICODE_STRING ImagePathName;                  // offset: 0x60 (96)
  struct _UNICODE_STRING CommandLine;                    // offset: 0x70 (112)
  VOID *Environment;                                     // offset: 0x80 (128)
  ULONG StartingX;                                       // offset: 0x88 (136)
  ULONG StartingY;                                       // offset: 0x8c (140)
  ULONG CountX;                                          // offset: 0x90 (144)
  ULONG CountY;                                          // offset: 0x94 (148)
  ULONG CountCharsX;                                     // offset: 0x98 (152)
  ULONG CountCharsY;                                     // offset: 0x9c (156)
  ULONG FillAttribute;                                   // offset: 0xa0 (160)
  ULONG WindowFlags;                                     // offset: 0xa4 (164)
  ULONG ShowWindowFlags;                                 // offset: 0xa8 (168)
  struct _UNICODE_STRING WindowTitle;                    // offset: 0xb0 (176)
  struct _UNICODE_STRING DesktopInfo;                    // offset: 0xc0 (192)
  struct _UNICODE_STRING ShellInfo;                      // offset: 0xd0 (208)
  struct _UNICODE_STRING RuntimeData;                    // offset: 0xe0 (224)
  struct _RTL_DRIVE_LETTER_CURDIR CurrentDirectores[32]; // offset: 0xf0 (240)
  ULONGLONG EnvironmentSize;                             // offset: 0x3f0 (1008)
  ULONGLONG EnvironmentVersion;                          // offset: 0x3f8 (1016)
  VOID *PackageDependencyData;                           // offset: 0x400 (1024)
  ULONG ProcessGroupId;                                  // offset: 0x408 (1032)
  ULONG LoaderThreads;                                   // offset: 0x40c (1036)
  struct _UNICODE_STRING RedirectionDllName;             // offset: 0x410 (1040)
  struct _UNICODE_STRING HeapPartitionName;              // offset: 0x420 (1056)
  ULONGLONG *DefaultThreadpoolCpuSetMasks;               // offset: 0x430 (1072)
  ULONG DefaultThreadpoolCpuSetMaskCount;                // offset: 0x438 (1080)
  ULONG DefaultThreadpoolThreadMaximum;                  // offset: 0x43c (1084)
};

// 0x10 (16) bytes
struct _RTL_BITMAP_EX {
  ULONGLONG SizeOfBitMap; // offset: 0x0 (0)
  ULONGLONG *Buffer;      // offset: 0x8 (8)
};

// 0x40 (64) bytes
struct _MI_SECTION_WOW_STATE {
  struct _RTL_BITMAP_EX ImageBitMap;          // offset: 0x0 (0)
  struct _MI_DLL_OVERFLOW_AREA OverflowArea;  // offset: 0x10 (16)
  struct _SECTION *CfgBitMapSection;          // offset: 0x30 (48)
  struct _CONTROL_AREA *CfgBitMapControlArea; // offset: 0x38 (56)
};

// 0x48 (72) bytes
struct _MI_DYNAMIC_BITMAP {
  struct _RTL_BITMAP_EX Bitmap; // offset: 0x0 (0)
  ULONGLONG MaximumSize;        // offset: 0x10 (16)
  ULONGLONG Hint;               // offset: 0x18 (24)
  VOID *BaseVa;                 // offset: 0x20 (32)
  ULONGLONG SizeTopDown;        // offset: 0x28 (40)
  ULONGLONG HintTopDown;        // offset: 0x30 (48)
  VOID *BaseVaTopDown;          // offset: 0x38 (56)
  ULONGLONG SpinLock;           // offset: 0x40 (64)
};

// 0x38 (56) bytes
struct _MI_SUB64K_FREE_RANGES {
  struct _RTL_BITMAP_EX BitMap; // offset: 0x0 (0)
  struct _LIST_ENTRY ListEntry; // offset: 0x10 (16)
  struct _MMVAD_SHORT *Vad;     // offset: 0x20 (32)
  ULONG SetBits;                // offset: 0x28 (40)
  ULONG FullSetBits;            // offset: 0x2c (44)
  ULONG SubListIndex : 2;       // offset: 0x30 (48)
  ULONG Hint : 30;              // offset: 0x30 (48)
};

// 0x40 (64) bytes
struct _MI_ULTRA_VA_CONTEXT {
  ULONGLONG Lock;                   // offset: 0x0 (0)
  VOID *ZeroMapping;                // offset: 0x8 (8)
  ULONGLONG AllocationHintBit;      // offset: 0x10 (16)
  struct _RTL_BITMAP_EX Bitmap[2];  // offset: 0x18 (24)
  volatile LONG ConcurrencyMaximum; // offset: 0x38 (56)
  volatile LONG ConcurrencyCount;   // offset: 0x3c (60)
};

// 0x78 (120) bytes
struct _MI_SHUTDOWN_STATE {
  UCHAR CrashDumpInitialized;             // offset: 0x0 (0)
  UCHAR ConnectedStandbyActive;           // offset: 0x1 (1)
  UCHAR ZeroPageFileAtShutdown;           // offset: 0x2 (2)
  ULONG SystemShutdown;                   // offset: 0x4 (4)
  LONG ShutdownFlushInProgress;           // offset: 0x8 (8)
  ULONG MirroringActive;                  // offset: 0xc (12)
  struct _MI_RESUME_WORKITEM ResumeItem;  // offset: 0x10 (16)
  struct _ETHREAD *MirrorHoldsPfn;        // offset: 0x48 (72)
  struct _RTL_BITMAP_EX MirrorBitMaps[2]; // offset: 0x50 (80)
  struct _MMPTE *CrashDumpPte;            // offset: 0x70 (112)
};

// 0x40 (64) bytes
struct _ETW_SILO_TRACING_BLOCK {
  struct _EX_FAST_REF *ProcessorBuffers; // offset: 0x0 (0)
  ULONGLONG *EventsLoggedCount;          // offset: 0x8 (8)
  LONGLONG *QpcDelta;                    // offset: 0x10 (16)
};

// 0x80 (128) bytes
struct _POP_PER_PROCESSOR_CONTEXT {
  UCHAR *UncompressedData;              // offset: 0x0 (0)
  VOID *MappingVa;                      // offset: 0x8 (8)
  VOID *XpressEncodeWorkspace;          // offset: 0x10 (16)
  UCHAR *CompressedDataBuffer;          // offset: 0x18 (24)
  ULONGLONG CopyTicks;                  // offset: 0x20 (32)
  ULONGLONG CompressTicks;              // offset: 0x28 (40)
  ULONGLONG BytesCopied;                // offset: 0x30 (48)
  ULONGLONG PagesProcessed;             // offset: 0x38 (56)
  ULONGLONG DecompressTicks;            // offset: 0x40 (64)
  ULONGLONG ResumeCopyTicks;            // offset: 0x48 (72)
  ULONGLONG SharedBufferTicks;          // offset: 0x50 (80)
  ULONGLONG DecompressTicksByMethod[2]; // offset: 0x58 (88)
  ULONGLONG DecompressSizeByMethod[2];  // offset: 0x68 (104)
  ULONG CompressCount;                  // offset: 0x78 (120)
  ULONG HuffCompressCount;              // offset: 0x7c (124)
};

// 0x20 (32) bytes
struct _VI_VERIFIER_ISSUE {
  ULONGLONG IssueType;     // offset: 0x0 (0)
  VOID *Address;           // offset: 0x8 (8)
  ULONGLONG Parameters[2]; // offset: 0x10 (16)
};

// 0x88 (136) bytes
struct _KTIMER2 {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 (0)
  union {
    struct _RTL_BALANCED_NODE RbNodes[2]; // offset: 0x18 (24)
    struct _LIST_ENTRY ListEntry;         // offset: 0x18 (24)
  };
  ULONGLONG DueTime[2];                                // offset: 0x48 (72)
  LONGLONG Period;                                     // offset: 0x58 (88)
  VOID (*Callback)(struct _KTIMER2 *arg1, VOID *arg2); // offset: 0x60 (96)
  VOID *CallbackContext;                               // offset: 0x68 (104)
  VOID (*DisableCallback)(VOID *arg1);                 // offset: 0x70 (112)
  VOID *DisableContext;                                // offset: 0x78 (120)
  UCHAR AbsoluteSystemTime;                            // offset: 0x80 (128)
  union {
    UCHAR TypeFlags; // offset: 0x81 (129)
    struct {
      UCHAR Unused : 1;         // offset: 0x81 (129)
      UCHAR IdleResilient : 1;  // offset: 0x81 (129)
      UCHAR HighResolution : 1; // offset: 0x81 (129)
      UCHAR NoWake : 1;         // offset: 0x81 (129)
      UCHAR PseudoHighRes : 1;  // offset: 0x81 (129)
      UCHAR Unused1 : 3;        // offset: 0x81 (129)
    };
  };
  UCHAR CollectionIndex[2]; // offset: 0x82 (130)
};

// 0x4c0 (1216) bytes
struct _MI_SYSTEM_VA_STATE {
  ULONGLONG SystemTablesLock;                             // offset: 0x0 (0)
  ULONGLONG AvailableSystemCacheVa;                       // offset: 0x8 (8)
  struct _MI_DYNAMIC_BITMAP DynamicBitMapKernelStacks;    // offset: 0x10 (16)
  struct _MI_DYNAMIC_BITMAP DynamicBitMapSystemPtes;      // offset: 0x58 (88)
  struct _MI_DYNAMIC_BITMAP DynamicBitMapDriverImages[2]; // offset: 0xa0 (160)
  struct _MI_DYNAMIC_BITMAP DynamicBitMapPagedPool;       // offset: 0x130 (304)
  struct _MI_DYNAMIC_BITMAP DynamicBitMapSystemCache;     // offset: 0x178 (376)
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapSecureNonPagedPool;            // offset: 0x1c0 (448)
  VOID *HalPrivateVaStart;                        // offset: 0x208 (520)
  ULONGLONG HalPrivateVaSize;                     // offset: 0x210 (528)
  ULONG SystemVaAssignment[8];                    // offset: 0x218 (536)
  ULONG SystemVaAssignmentHint;                   // offset: 0x238 (568)
  ULONG TopLevelPteLockBits[32];                  // offset: 0x23c (572)
  volatile LONG DeleteKvaLock;                    // offset: 0x2bc (700)
  struct _MI_WSLE *WsleArrays[8];                 // offset: 0x2c0 (704)
  VOID *PagableHyperSpace;                        // offset: 0x300 (768)
  VOID *HyperSpaceEnd;                            // offset: 0x308 (776)
  ULONGLONG PagableHyperSpaceBytes;               // offset: 0x310 (784)
  ULONGLONG PageTableCommitmentOffset[2];         // offset: 0x318 (792)
  struct _KEVENT FreeSystemCacheVa;               // offset: 0x328 (808)
  ULONGLONG SystemVaLock;                         // offset: 0x340 (832)
  ULONGLONG SystemCacheViewLock;                  // offset: 0x348 (840)
  struct _MMWSL_INSTANCE SystemWorkingSetList[8]; // offset: 0x350 (848)
  ULONGLONG SelfmapLock[4];                       // offset: 0x490 (1168)
};

// 0x20 (32) bytes
struct _HEAP_VAMGR_RANGE {
  union {
    struct _RTL_BALANCED_NODE RbNode; // offset: 0x0 (0)
    struct _SINGLE_LIST_ENTRY Next;   // offset: 0x0 (0)
    struct {
      UCHAR Allocated : 1;   // offset: 0x0 (0)
      UCHAR Internal : 1;    // offset: 0x0 (0)
      UCHAR Standalone : 1;  // offset: 0x0 (0)
      UCHAR Spare0 : 5;      // offset: 0x0 (0)
      UCHAR AllocatorIndex;  // offset: 0x1 (1)
      ULONGLONG OwnerCtx[2]; // offset: 0x8 (8)
    };
  };
  union {
    ULONGLONG SizeInChunks; // offset: 0x18 (24)
    struct {
      USHORT ChunkCount;     // offset: 0x18 (24)
      USHORT PrevChunkCount; // offset: 0x1a (26)
    };
    ULONGLONG Signature; // offset: 0x18 (24)
  };
};

// 0x20 (32) bytes
struct _KIST_LINK_FRAME {
  struct _KIST_BASE_FRAME *IstBaseFrame; // offset: 0x0 (0)
  ULONG Signature;                       // offset: 0x8 (8)
  ULONG Reserved0;                       // offset: 0xc (12)
  ULONGLONG Reserved[2];                 // offset: 0x10 (16)
};

// 0x30 (48) bytes
struct _KIST_BASE_FRAME {
  struct _KPCR *KernelGsBase;        // offset: 0x0 (0)
  struct _KIST_LINK_FRAME *IstStack; // offset: 0x8 (8)
  ULONGLONG PreviousGsBase;          // offset: 0x10 (16)
  ULONGLONG PreviousCr3;             // offset: 0x18 (24)
  ULONGLONG IstPad;                  // offset: 0x20 (32)
  ULONGLONG Reserved;                // offset: 0x28 (40)
};

// 0x430 (1072) bytes
struct _MI_FREE_LARGE_PAGES {
  ULONGLONG LargePageFreeCount[2];         // offset: 0x0 (0)
  ULONGLONG LargePageFreeCountHiLow[2][2]; // offset: 0x10 (16)
  ULONGLONG LargePagesCount[2][2][4][4];   // offset: 0x30 (48)
  struct _MI_FREE_LARGE_PAGE_LIST
      *LargePageEntries[2][2][4][4]; // offset: 0x230 (560)
};

// 0x10 (16) bytes
struct _MI_WRITE_MODES {
  ULONGLONG WriteType[2]; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _MI_WRITE_CALIBRATION {
  ULONG MaximumNumberProcessors;         // offset: 0x0 (0)
  enum _MI_WRITE_TYPES OptimalWriteType; // offset: 0x4 (4)
  ULONGLONG PerProcessorNumberOfBytes;   // offset: 0x8 (8)
  ULONG OptimalWriteProcessors[2];       // offset: 0x10 (16)
  struct _MI_WRITE_MODES *RawTimeStamps; // offset: 0x18 (24)
};

// 0xb0 (176) bytes
struct _MI_PARTITION_ZEROING {
  struct _KEVENT PageEvent;                          // offset: 0x0 (0)
  UCHAR ThreadPriorityStatic;                        // offset: 0x18 (24)
  UCHAR AdaptiveZeroingEnabled;                      // offset: 0x19 (25)
  LONG ZeroFreePageSlistMinimum;                     // offset: 0x1c (28)
  struct _WORK_QUEUE_ITEM RebalanceZeroFreeWorkItem; // offset: 0x20 (32)
  volatile LONG NodeCount;                           // offset: 0x40 (64)
  volatile LONG BackgroundZeroingDisabled;           // offset: 0x44 (68)
  struct _KGATE LargeBootZeroingComplete;            // offset: 0x48 (72)
  struct _MI_WRITE_CALIBRATION WriteCalibration;     // offset: 0x60 (96)
  UCHAR IpiCalibrationFailed;                        // offset: 0x80 (128)
  volatile LONG ActiveProcessorsForIpiCalibration;   // offset: 0x84 (132)
  volatile LONG NodesReadyForIpiCalibration;         // offset: 0x88 (136)
  struct _KEVENT ReleaseNodeZeroingThreads;          // offset: 0x90 (144)
  struct _MI_ZERO_THREAD_CONTEXT *ThreadContext;     // offset: 0xa8 (168)
};

// 0x10 (16) bytes
union __m128 {
  float m128_f32[4];     // offset: 0x0 (0)
  ULONGLONG m128_u64[2]; // offset: 0x0 (0)
  CHAR m128_i8[16];      // offset: 0x0 (0)
  SHORT m128_i16[8];     // offset: 0x0 (0)
  LONG m128_i32[4];      // offset: 0x0 (0)
  LONGLONG m128_i64[2];  // offset: 0x0 (0)
  UCHAR m128_u8[16];     // offset: 0x0 (0)
  USHORT m128_u16[8];    // offset: 0x0 (0)
  ULONG m128_u32[4];     // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _TRUSTLET_COLLABORATION_ID {
  ULONGLONG Value[2]; // offset: 0x0 (0)
};

// 0x10 (16) bytes
struct _TRUSTLET_MAILBOX_KEY {
  ULONGLONG SecretValue[2]; // offset: 0x0 (0)
};

// 0x10 (16) bytes
union _INVPCID_DESCRIPTOR {
  struct {
    union {
      struct {
        ULONGLONG Pcid : 12;     // offset: 0x0 (0)
        ULONGLONG Reserved : 52; // offset: 0x0 (0)
      };
      ULONGLONG EntirePcid; // offset: 0x0 (0)
    };
    ULONGLONG Virtual; // offset: 0x8 (8)
  } IndividualAddress; // offset: 0x0 (0)
  struct {
    union {
      struct {
        ULONGLONG Pcid : 12;     // offset: 0x0 (0)
        ULONGLONG Reserved : 52; // offset: 0x0 (0)
      };
      ULONGLONG EntirePcid; // offset: 0x0 (0)
    };
    ULONGLONG Reserved2; // offset: 0x8 (8)
  } SingleContext;       // offset: 0x0 (0)
  struct {
    ULONGLONG Reserved[2]; // offset: 0x0 (0)
  } AllContextAndGlobals;  // offset: 0x0 (0)
  struct {
    ULONGLONG Reserved[2]; // offset: 0x0 (0)
  } AllContext;            // offset: 0x0 (0)
};

// 0x720 (1824) bytes
struct _KUSER_SHARED_DATA {
  ULONG TickCountLowDeprecated;                // offset: 0x0 (0)
  ULONG TickCountMultiplier;                   // offset: 0x4 (4)
  volatile struct _KSYSTEM_TIME InterruptTime; // offset: 0x8 (8)
  volatile struct _KSYSTEM_TIME SystemTime;    // offset: 0x14 (20)
  volatile struct _KSYSTEM_TIME TimeZoneBias;  // offset: 0x20 (32)
  USHORT ImageNumberLow;                       // offset: 0x2c (44)
  USHORT ImageNumberHigh;                      // offset: 0x2e (46)
  WCHAR NtSystemRoot[260];                     // offset: 0x30 (48)
  ULONG MaxStackTraceDepth;                    // offset: 0x238 (568)
  ULONG CryptoExponent;                        // offset: 0x23c (572)
  ULONG TimeZoneId;                            // offset: 0x240 (576)
  ULONG LargePageMinimum;                      // offset: 0x244 (580)
  ULONG AitSamplingValue;                      // offset: 0x248 (584)
  ULONG AppCompatFlag;                         // offset: 0x24c (588)
  ULONGLONG RNGSeedVersion;                    // offset: 0x250 (592)
  ULONG GlobalValidationRunlevel;              // offset: 0x258 (600)
  volatile LONG TimeZoneBiasStamp;             // offset: 0x25c (604)
  ULONG NtBuildNumber;                         // offset: 0x260 (608)
  enum _NT_PRODUCT_TYPE NtProductType;         // offset: 0x264 (612)
  UCHAR ProductTypeIsValid;                    // offset: 0x268 (616)
  UCHAR Reserved0[1];                          // offset: 0x269 (617)
  USHORT NativeProcessorArchitecture;          // offset: 0x26a (618)
  ULONG NtMajorVersion;                        // offset: 0x26c (620)
  ULONG NtMinorVersion;                        // offset: 0x270 (624)
  UCHAR ProcessorFeatures[64];                 // offset: 0x274 (628)
  ULONG Reserved1;                             // offset: 0x2b4 (692)
  ULONG Reserved3;                             // offset: 0x2b8 (696)
  volatile ULONG TimeSlip;                     // offset: 0x2bc (700)
  enum _ALTERNATIVE_ARCHITECTURE_TYPE
      AlternativeArchitecture;               // offset: 0x2c0 (704)
  ULONG BootId;                              // offset: 0x2c4 (708)
  union _LARGE_INTEGER SystemExpirationDate; // offset: 0x2c8 (712)
  ULONG SuiteMask;                           // offset: 0x2d0 (720)
  UCHAR KdDebuggerEnabled;                   // offset: 0x2d4 (724)
  union {
    UCHAR MitigationPolicies; // offset: 0x2d5 (725)
    struct {
      UCHAR NXSupportPolicy : 2;             // offset: 0x2d5 (725)
      UCHAR SEHValidationPolicy : 2;         // offset: 0x2d5 (725)
      UCHAR CurDirDevicesSkippedForDlls : 2; // offset: 0x2d5 (725)
      UCHAR Reserved : 2;                    // offset: 0x2d5 (725)
    };
  };
  USHORT CyclesPerYield;             // offset: 0x2d6 (726)
  volatile ULONG ActiveConsoleId;    // offset: 0x2d8 (728)
  volatile ULONG DismountCount;      // offset: 0x2dc (732)
  ULONG ComPlusPackage;              // offset: 0x2e0 (736)
  ULONG LastSystemRITEventTickCount; // offset: 0x2e4 (740)
  ULONG NumberOfPhysicalPages;       // offset: 0x2e8 (744)
  UCHAR SafeBootMode;                // offset: 0x2ec (748)
  UCHAR VirtualizationFlags;         // offset: 0x2ed (749)
  UCHAR Reserved12[2];               // offset: 0x2ee (750)
  union {
    ULONG SharedDataFlags; // offset: 0x2f0 (752)
    struct {
      ULONG DbgErrorPortPresent : 1;       // offset: 0x2f0 (752)
      ULONG DbgElevationEnabled : 1;       // offset: 0x2f0 (752)
      ULONG DbgVirtEnabled : 1;            // offset: 0x2f0 (752)
      ULONG DbgInstallerDetectEnabled : 1; // offset: 0x2f0 (752)
      ULONG DbgLkgEnabled : 1;             // offset: 0x2f0 (752)
      ULONG DbgDynProcessorEnabled : 1;    // offset: 0x2f0 (752)
      ULONG DbgConsoleBrokerEnabled : 1;   // offset: 0x2f0 (752)
      ULONG DbgSecureBootEnabled : 1;      // offset: 0x2f0 (752)
      ULONG DbgMultiSessionSku : 1;        // offset: 0x2f0 (752)
      ULONG DbgMultiUsersInSessionSku : 1; // offset: 0x2f0 (752)
      ULONG DbgStateSeparationEnabled : 1; // offset: 0x2f0 (752)
      ULONG SpareBits : 21;                // offset: 0x2f0 (752)
    };
  };
  ULONG DataFlagsPad[1];        // offset: 0x2f4 (756)
  ULONGLONG TestRetInstruction; // offset: 0x2f8 (760)
  LONGLONG QpcFrequency;        // offset: 0x300 (768)
  ULONG SystemCall;             // offset: 0x308 (776)
  ULONG Reserved2;              // offset: 0x30c (780)
  ULONGLONG SystemCallPad[2];   // offset: 0x310 (784)
  union {
    volatile struct _KSYSTEM_TIME TickCount; // offset: 0x320 (800)
    volatile ULONGLONG TickCountQuad;        // offset: 0x320 (800)
    ULONG ReservedTickCountOverlay[3];       // offset: 0x320 (800)
  };
  ULONG TickCountPad[1];                      // offset: 0x32c (812)
  ULONG Cookie;                               // offset: 0x330 (816)
  ULONG CookiePad[1];                         // offset: 0x334 (820)
  LONGLONG ConsoleSessionForegroundProcessId; // offset: 0x338 (824)
  ULONGLONG TimeUpdateLock;                   // offset: 0x340 (832)
  ULONGLONG BaselineSystemTimeQpc;            // offset: 0x348 (840)
  ULONGLONG BaselineInterruptTimeQpc;         // offset: 0x350 (848)
  ULONGLONG QpcSystemTimeIncrement;           // offset: 0x358 (856)
  ULONGLONG QpcInterruptTimeIncrement;        // offset: 0x360 (864)
  UCHAR QpcSystemTimeIncrementShift;          // offset: 0x368 (872)
  UCHAR QpcInterruptTimeIncrementShift;       // offset: 0x369 (873)
  USHORT UnparkedProcessorCount;              // offset: 0x36a (874)
  ULONG EnclaveFeatureMask[4];                // offset: 0x36c (876)
  ULONG TelemetryCoverageRound;               // offset: 0x37c (892)
  USHORT UserModeGlobalLogger[16];            // offset: 0x380 (896)
  ULONG ImageFileExecutionOptions;            // offset: 0x3a0 (928)
  ULONG LangGenerationCount;                  // offset: 0x3a4 (932)
  ULONGLONG Reserved4;                        // offset: 0x3a8 (936)
  volatile ULONGLONG InterruptTimeBias;       // offset: 0x3b0 (944)
  volatile ULONGLONG QpcBias;                 // offset: 0x3b8 (952)
  ULONG ActiveProcessorCount;                 // offset: 0x3c0 (960)
  volatile UCHAR ActiveGroupCount;            // offset: 0x3c4 (964)
  UCHAR Reserved9;                            // offset: 0x3c5 (965)
  union {
    USHORT QpcData; // offset: 0x3c6 (966)
    struct {
      volatile UCHAR QpcBypassEnabled; // offset: 0x3c6 (966)
      UCHAR QpcShift;                  // offset: 0x3c7 (967)
    };
  };
  union _LARGE_INTEGER TimeZoneBiasEffectiveStart;      // offset: 0x3c8 (968)
  union _LARGE_INTEGER TimeZoneBiasEffectiveEnd;        // offset: 0x3d0 (976)
  struct _XSTATE_CONFIGURATION XState;                  // offset: 0x3d8 (984)
  struct _KSYSTEM_TIME FeatureConfigurationChangeStamp; // offset: 0x710 (1808)
  ULONG Spare;                                          // offset: 0x71c (1820)
};

// 0x30 (48) bytes
struct _MCUPDATE_INFO {
  struct _LIST_ENTRY List;    // offset: 0x0 (0)
  ULONG Status;               // offset: 0x10 (16)
  ULONGLONG Id;               // offset: 0x18 (24)
  ULONGLONG VendorScratch[2]; // offset: 0x20 (32)
};

// 0x700 (1792) bytes
struct _KPRCB {
  ULONG MxCsr;                    // offset: 0x0 (0)
  UCHAR LegacyNumber;             // offset: 0x4 (4)
  UCHAR ReservedMustBeZero;       // offset: 0x5 (5)
  UCHAR InterruptRequest;         // offset: 0x6 (6)
  UCHAR IdleHalt;                 // offset: 0x7 (7)
  struct _KTHREAD *CurrentThread; // offset: 0x8 (8)
  struct _KTHREAD *NextThread;    // offset: 0x10 (16)
  struct _KTHREAD *IdleThread;    // offset: 0x18 (24)
  UCHAR NestingLevel;             // offset: 0x20 (32)
  UCHAR ClockOwner;               // offset: 0x21 (33)
  union {
    UCHAR PendingTickFlags; // offset: 0x22 (34)
    struct {
      UCHAR PendingTick : 1;       // offset: 0x22 (34)
      UCHAR PendingBackupTick : 1; // offset: 0x22 (34)
    };
  };
  UCHAR IdleState;     // offset: 0x23 (35)
  ULONG Number;        // offset: 0x24 (36)
  ULONGLONG RspBase;   // offset: 0x28 (40)
  ULONGLONG PrcbLock;  // offset: 0x30 (48)
  CHAR *PriorityState; // offset: 0x38 (56)
  CHAR CpuType;        // offset: 0x40 (64)
  CHAR CpuID;          // offset: 0x41 (65)
  union {
    USHORT CpuStep; // offset: 0x42 (66)
    struct {
      UCHAR CpuStepping; // offset: 0x42 (66)
      UCHAR CpuModel;    // offset: 0x43 (67)
    };
  };
  ULONG MHz;                                          // offset: 0x44 (68)
  ULONGLONG HalReserved[8];                           // offset: 0x48 (72)
  USHORT MinorVersion;                                // offset: 0x88 (136)
  USHORT MajorVersion;                                // offset: 0x8a (138)
  UCHAR BuildType;                                    // offset: 0x8c (140)
  UCHAR CpuVendor;                                    // offset: 0x8d (141)
  UCHAR CoresPerPhysicalProcessor;                    // offset: 0x8e (142)
  UCHAR LogicalProcessorsPerCore;                     // offset: 0x8f (143)
  ULONGLONG TscFrequency;                             // offset: 0x90 (144)
  ULONGLONG PrcbPad04[5];                             // offset: 0x98 (152)
  struct _KNODE *ParentNode;                          // offset: 0xc0 (192)
  ULONGLONG GroupSetMember;                           // offset: 0xc8 (200)
  UCHAR Group;                                        // offset: 0xd0 (208)
  UCHAR GroupIndex;                                   // offset: 0xd1 (209)
  UCHAR PrcbPad05[2];                                 // offset: 0xd2 (210)
  ULONG InitialApicId;                                // offset: 0xd4 (212)
  ULONG ScbOffset;                                    // offset: 0xd8 (216)
  ULONG ApicMask;                                     // offset: 0xdc (220)
  VOID *AcpiReserved;                                 // offset: 0xe0 (224)
  ULONG CFlushSize;                                   // offset: 0xe8 (232)
  ULONGLONG PrcbPad11[2];                             // offset: 0xf0 (240)
  struct _KPROCESSOR_STATE ProcessorState;            // offset: 0x100 (256)
  struct _XSAVE_AREA_HEADER *ExtendedSupervisorState; // offset: 0x6c0 (1728)
  ULONG ProcessorSignature;                           // offset: 0x6c8 (1736)
  ULONG ProcessorFlags;                               // offset: 0x6cc (1740)
  ULONGLONG PrcbPad12a;                               // offset: 0x6d0 (1744)
  ULONGLONG PrcbPad12[3];                             // offset: 0x6d8 (1752)
};

// 0x178 (376) bytes
struct _KPCR {
  union {
    struct _NT_TIB NtTib; // offset: 0x0 (0)
    struct {
      union _KGDTENTRY64 *GdtBase;         // offset: 0x0 (0)
      struct _KTSS64 *TssBase;             // offset: 0x8 (8)
      ULONGLONG UserRsp;                   // offset: 0x10 (16)
      struct _KPCR *Self;                  // offset: 0x18 (24)
      struct _KPRCB *CurrentPrcb;          // offset: 0x20 (32)
      struct _KSPIN_LOCK_QUEUE *LockArray; // offset: 0x28 (40)
      VOID *Used_Self;                     // offset: 0x30 (48)
    };
  };
  union _KIDTENTRY64 *IdtBase;         // offset: 0x38 (56)
  ULONGLONG Unused[2];                 // offset: 0x40 (64)
  UCHAR Irql;                          // offset: 0x50 (80)
  UCHAR SecondLevelCacheAssociativity; // offset: 0x51 (81)
  UCHAR ObsoleteNumber;                // offset: 0x52 (82)
  UCHAR Fill0;                         // offset: 0x53 (83)
  ULONG Unused0[3];                    // offset: 0x54 (84)
  USHORT MajorVersion;                 // offset: 0x60 (96)
  USHORT MinorVersion;                 // offset: 0x62 (98)
  ULONG StallScaleFactor;              // offset: 0x64 (100)
  VOID *Unused1[3];                    // offset: 0x68 (104)
  ULONG KernelReserved[15];            // offset: 0x80 (128)
  ULONG SecondLevelCacheSize;          // offset: 0xbc (188)
  ULONG HalReserved[16];               // offset: 0xc0 (192)
  ULONG Unused2;                       // offset: 0x100 (256)
  VOID *KdVersionBlock;                // offset: 0x108 (264)
  VOID *Unused3;                       // offset: 0x110 (272)
  ULONG PcrAlign1[24];                 // offset: 0x118 (280)
};

// 0x18 (24) bytes
struct _EVENT_PAYLOAD_PREDICATE {
  USHORT FieldIndex;  // offset: 0x0 (0)
  USHORT CompareOp;   // offset: 0x2 (2)
  ULONGLONG Value[2]; // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _AGGREGATED_PAYLOAD_FILTER {
  USHORT MagicValue : 12;                            // offset: 0x0 (0)
  USHORT DescriptorVersion : 4;                      // offset: 0x0 (0)
  USHORT Size;                                       // offset: 0x2 (2)
  USHORT PredicateCount;                             // offset: 0x4 (4)
  USHORT Reserved;                                   // offset: 0x6 (6)
  ULONGLONG HashedEventIdBitmap;                     // offset: 0x8 (8)
  struct _GUID ProviderGuid;                         // offset: 0x10 (16)
  USHORT EachEventTableOffset;                       // offset: 0x20 (32)
  USHORT EachEventTableLength;                       // offset: 0x22 (34)
  USHORT PayloadDecoderTableOffset;                  // offset: 0x24 (36)
  USHORT PayloadDecoderTableLength;                  // offset: 0x26 (38)
  USHORT EventFilterTableOffset;                     // offset: 0x28 (40)
  USHORT EventFilterTableLength;                     // offset: 0x2a (42)
  USHORT UNICODEStringTableOffset;                   // offset: 0x2c (44)
  USHORT UNICODEStringTableLength;                   // offset: 0x2e (46)
  USHORT ANSIStringTableOffset;                      // offset: 0x30 (48)
  USHORT ANSIStringTableLength;                      // offset: 0x32 (50)
  struct _EVENT_PAYLOAD_PREDICATE PredicateTable[1]; // offset: 0x38 (56)
};

// 0x58 (88) bytes
struct _ETW_PAYLOAD_FILTER {
  LONG RefCount;                                   // offset: 0x0 (0)
  struct _AGGREGATED_PAYLOAD_FILTER PayloadFilter; // offset: 0x8 (8)
};

// 0x68 (104) bytes
struct _ETW_FILTER_HEADER {
  LONG FilterFlags;                                        // offset: 0x0 (0)
  struct _ETW_FILTER_PID *PidFilter;                       // offset: 0x8 (8)
  struct _ETW_FILTER_STRING_TOKEN *ExeFilter;              // offset: 0x10 (16)
  struct _ETW_FILTER_STRING_TOKEN *PkgIdFilter;            // offset: 0x18 (24)
  struct _ETW_FILTER_STRING_TOKEN *PkgAppIdFilter;         // offset: 0x20 (32)
  struct _ETW_FILTER_STRING_TOKEN *ContainerFilter;        // offset: 0x28 (40)
  struct _ETW_PERFECT_HASH_FUNCTION *StackWalkIdFilter;    // offset: 0x30 (48)
  struct _ETW_FILTER_EVENT_NAME_DATA *StackWalkNameFilter; // offset: 0x38 (56)
  struct _EVENT_FILTER_LEVEL_KW *StackWalkLevelKwFilter;   // offset: 0x40 (64)
  struct _ETW_PERFECT_HASH_FUNCTION *EventIdFilter;        // offset: 0x48 (72)
  struct _ETW_PAYLOAD_FILTER *PayloadFilter;               // offset: 0x50 (80)
  struct _EVENT_FILTER_HEADER *ProviderSideFilter;         // offset: 0x58 (88)
  struct _ETW_FILTER_EVENT_NAME_DATA *EventNameFilter;     // offset: 0x60 (96)
};

// 0x90 (144) bytes
struct _PROC_FEEDBACK {
  ULONGLONG Lock;                             // offset: 0x0 (0)
  ULONGLONG CyclesLast;                       // offset: 0x8 (8)
  ULONGLONG CyclesActive;                     // offset: 0x10 (16)
  struct _PROC_FEEDBACK_COUNTER *Counters[2]; // offset: 0x18 (24)
  ULONGLONG LastUpdateTime;                   // offset: 0x28 (40)
  ULONGLONG UnscaledTime;                     // offset: 0x30 (48)
  volatile LONGLONG UnaccountedTime;          // offset: 0x38 (56)
  ULONGLONG ScaledTime[2];                    // offset: 0x40 (64)
  ULONGLONG UnaccountedKernelTime;            // offset: 0x50 (80)
  ULONGLONG PerformanceScaledKernelTime;      // offset: 0x58 (88)
  ULONG UserTimeLast;                         // offset: 0x60 (96)
  ULONG KernelTimeLast;                       // offset: 0x64 (100)
  ULONGLONG IdleGenerationNumberLast;         // offset: 0x68 (104)
  ULONGLONG HvActiveTimeLast;                 // offset: 0x70 (112)
  ULONGLONG StallCyclesLast;                  // offset: 0x78 (120)
  ULONGLONG StallTime;                        // offset: 0x80 (128)
  UCHAR KernelTimesIndex;                     // offset: 0x88 (136)
  UCHAR CounterDiscardsIdleTime;              // offset: 0x89 (137)
};

// 0x18 (24) bytes
struct _KTIMER_TABLE_STATE {
  ULONGLONG LastTimerExpiration[2]; // offset: 0x0 (0)
  ULONG LastTimerHand[2];           // offset: 0x10 (16)
};

// 0x110 (272) bytes
struct _PROCESS_ENERGY_VALUES {
  ULONGLONG Cycles[4][2];      // offset: 0x0 (0)
  ULONGLONG DiskEnergy;        // offset: 0x40 (64)
  ULONGLONG NetworkTailEnergy; // offset: 0x48 (72)
  ULONGLONG MBBTailEnergy;     // offset: 0x50 (80)
  ULONGLONG NetworkTxRxBytes;  // offset: 0x58 (88)
  ULONGLONG MBBTxRxBytes;      // offset: 0x60 (96)
  union {
    union _ENERGY_STATE_DURATION Durations[3]; // offset: 0x68 (104)
    struct {
      union _ENERGY_STATE_DURATION ForegroundDuration;     // offset: 0x68 (104)
      union _ENERGY_STATE_DURATION DesktopVisibleDuration; // offset: 0x70 (112)
      union _ENERGY_STATE_DURATION PSMForegroundDuration;  // offset: 0x78 (120)
    };
  };
  ULONG CompositionRendered;          // offset: 0x80 (128)
  ULONG CompositionDirtyGenerated;    // offset: 0x84 (132)
  ULONG CompositionDirtyPropagated;   // offset: 0x88 (136)
  ULONG Reserved1;                    // offset: 0x8c (140)
  ULONGLONG AttributedCycles[4][2];   // offset: 0x90 (144)
  ULONGLONG WorkOnBehalfCycles[4][2]; // offset: 0xd0 (208)
};

// 0x1b0 (432) bytes
struct _PROCESS_EXTENDED_ENERGY_VALUES {
  struct _PROCESS_ENERGY_VALUES Base;                // offset: 0x0 (0)
  struct _PROCESS_ENERGY_VALUES_EXTENSION Extension; // offset: 0x110 (272)
};

// 0xc8 (200) bytes
struct _THREAD_ENERGY_VALUES {
  ULONGLONG Cycles[4][2];             // offset: 0x0 (0)
  ULONGLONG AttributedCycles[4][2];   // offset: 0x40 (64)
  ULONGLONG WorkOnBehalfCycles[4][2]; // offset: 0x80 (128)
  union _TIMELINE_BITMAP CpuTimeline; // offset: 0xc0 (192)
};

// 0x8 (8) bytes
struct _EX_RUNDOWN_REF {
  union {
    ULONGLONG Count; // offset: 0x0 (0)
    VOID *Ptr;       // offset: 0x0 (0)
  };
};

// 0x18 (24) bytes
struct _EX_RUNDOWN_REF_CACHE_AWARE {
  struct _EX_RUNDOWN_REF *RunRefs; // offset: 0x0 (0)
  VOID *PoolToFree;                // offset: 0x8 (8)
  ULONG RunRefSize;                // offset: 0x10 (16)
  ULONG Number;                    // offset: 0x14 (20)
};

// 0x38 (56) bytes
struct _PS_IO_CONTROL_ENTRY {
  union {
    struct _RTL_BALANCED_NODE VolumeTreeNode; // offset: 0x0 (0)
    struct {
      struct _LIST_ENTRY FreeListEntry; // offset: 0x0 (0)
      ULONGLONG ReservedForParentValue; // offset: 0x10 (16)
    };
  };
  ULONGLONG VolumeKey;            // offset: 0x18 (24)
  struct _EX_RUNDOWN_REF Rundown; // offset: 0x20 (32)
  VOID *IoControl;                // offset: 0x28 (40)
  VOID *VolumeIoAttribution;      // offset: 0x30 (48)
};

// 0x8 (8) bytes
struct _EX_PUSH_LOCK {
  union {
    struct {
      ULONGLONG Locked : 1;         // offset: 0x0 (0)
      ULONGLONG Waiting : 1;        // offset: 0x0 (0)
      ULONGLONG Waking : 1;         // offset: 0x0 (0)
      ULONGLONG MultipleShared : 1; // offset: 0x0 (0)
      ULONGLONG Shared : 60;        // offset: 0x0 (0)
    };
    ULONGLONG Value; // offset: 0x0 (0)
    VOID *Ptr;       // offset: 0x0 (0)
  };
};

// 0x30 (48) bytes
struct _MAPPED_FILE_SEGMENT {
  struct _CONTROL_AREA *ControlArea;  // offset: 0x0 (0)
  ULONG TotalNumberOfPtes;            // offset: 0x8 (8)
  struct _SEGMENT_FLAGS SegmentFlags; // offset: 0xc (12)
  ULONGLONG NumberOfCommittedPages;   // offset: 0x10 (16)
  ULONGLONG SizeOfSegment;            // offset: 0x18 (24)
  union {
    struct _MMEXTEND_INFO *ExtendInfo; // offset: 0x20 (32)
    VOID *BasedAddress;                // offset: 0x20 (32)
  };
  struct _EX_PUSH_LOCK SegmentLock; // offset: 0x28 (40)
};

// 0x28 (40) bytes
struct _SEP_LOWBOX_NUMBER_MAPPING {
  struct _EX_PUSH_LOCK Lock;                 // offset: 0x0 (0)
  struct _RTL_BITMAP Bitmap;                 // offset: 0x8 (8)
  struct _RTL_DYNAMIC_HASH_TABLE *HashTable; // offset: 0x18 (24)
  UCHAR Active;                              // offset: 0x20 (32)
};

// 0x40 (64) bytes
struct _SESSION_LOWBOX_MAP {
  struct _LIST_ENTRY ListEntry;                // offset: 0x0 (0)
  ULONG SessionId;                             // offset: 0x10 (16)
  struct _SEP_LOWBOX_NUMBER_MAPPING LowboxMap; // offset: 0x18 (24)
};

// 0x60 (96) bytes
struct _PNP_DEVICE_ACTION_ENTRY {
  struct _LIST_ENTRY ListEntry;                // offset: 0x0 (0)
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x10 (16)
  enum _PNP_DEVICE_ACTION_REQUEST RequestType; // offset: 0x18 (24)
  UCHAR ReorderingBarrier;                     // offset: 0x1c (28)
  ULONGLONG RequestArgument;                   // offset: 0x20 (32)
  struct _KEVENT *CompletionEvent;             // offset: 0x28 (40)
  LONG *CompletionStatus;                      // offset: 0x30 (48)
  struct _GUID ActivityId;                     // offset: 0x38 (56)
  LONG RefCount;                               // offset: 0x48 (72)
  UCHAR Dequeued;                              // offset: 0x4c (76)
  struct _EX_PUSH_LOCK CancelLock;             // offset: 0x50 (80)
  UCHAR CancelRequested;                       // offset: 0x58 (88)
};

// 0x28 (40) bytes
struct _RTL_ATOM_TABLE {
  ULONG Signature;                          // offset: 0x0 (0)
  volatile LONG ReferenceCount;             // offset: 0x4 (4)
  struct _EX_PUSH_LOCK PushLock;            // offset: 0x8 (8)
  struct _HANDLE_TABLE *ExHandleTable;      // offset: 0x10 (16)
  ULONG Flags;                              // offset: 0x18 (24)
  ULONG NumberOfBuckets;                    // offset: 0x1c (28)
  struct _RTL_ATOM_TABLE_ENTRY *Buckets[1]; // offset: 0x20 (32)
};

// 0x48 (72) bytes
struct _MI_ENCLAVE_STATE {
  struct _RTL_AVL_TREE EnclaveRegions;           // offset: 0x0 (0)
  VOID *EnclaveMetadataPage;                     // offset: 0x8 (8)
  struct _RTL_BITMAP *EnclaveMetadataBitMap;     // offset: 0x10 (16)
  struct _EX_PUSH_LOCK EnclaveMetadataEntryLock; // offset: 0x18 (24)
  volatile LONG EnclaveMetadataPageLock;         // offset: 0x20 (32)
  struct _LIST_ENTRY EnclaveList;                // offset: 0x28 (40)
  struct _EX_PUSH_LOCK EnclaveListLock;          // offset: 0x38 (56)
  struct _EX_RUNDOWN_REF ShutdownRundown;        // offset: 0x40 (64)
};

// 0xa8 (168) bytes
struct _MI_SYSTEM_IMAGE_STATE {
  struct _LIST_ENTRY FixupList;                 // offset: 0x0 (0)
  struct _EX_PUSH_LOCK LoadLock;                // offset: 0x10 (16)
  struct _ETHREAD *LoadLockOwner;               // offset: 0x18 (24)
  ULONG LoadLockCount;                          // offset: 0x20 (32)
  volatile LONG FixupLock;                      // offset: 0x24 (36)
  UCHAR FirstLoadEver;                          // offset: 0x28 (40)
  UCHAR LargePageAll;                           // offset: 0x29 (41)
  ULONGLONG LastPage;                           // offset: 0x30 (48)
  struct _LIST_ENTRY LargePageList;             // offset: 0x38 (56)
  struct _LIST_ENTRY StrongCodeLoadFailureList; // offset: 0x48 (72)
  struct _KLDR_DATA_TABLE_ENTRY *SystemBase[1]; // offset: 0x58 (88)
  struct _KLDR_DATA_TABLE_ENTRY *BeingDeleted;  // offset: 0x60 (96)
  struct _EX_PUSH_LOCK MappingRangesPushLock;   // offset: 0x68 (104)
  struct _MI_DRIVER_VA *MappingRanges[2];       // offset: 0x70 (112)
  ULONGLONG PageCount;                          // offset: 0x80 (128)
  struct _MM_SYSTEM_PAGE_COUNTS PageCounts;     // offset: 0x88 (136)
  struct _EX_PUSH_LOCK CollidedLock;            // offset: 0x98 (152)
  struct _RTL_AVL_TREE ImageTree;               // offset: 0xa0 (160)
};

// 0x38 (56) bytes
struct _OBJECT_HEADER {
  LONGLONG PointerCount; // offset: 0x0 (0)
  union {
    LONGLONG HandleCount; // offset: 0x8 (8)
    VOID *NextToFree;     // offset: 0x8 (8)
  };
  struct _EX_PUSH_LOCK Lock; // offset: 0x10 (16)
  UCHAR TypeIndex;           // offset: 0x18 (24)
  union {
    UCHAR TraceFlags; // offset: 0x19 (25)
    struct {
      UCHAR DbgRefTrace : 1;       // offset: 0x19 (25)
      UCHAR DbgTracePermanent : 1; // offset: 0x19 (25)
    };
  };
  UCHAR InfoMask; // offset: 0x1a (26)
  union {
    UCHAR Flags; // offset: 0x1b (27)
    struct {
      UCHAR NewObject : 1;            // offset: 0x1b (27)
      UCHAR KernelObject : 1;         // offset: 0x1b (27)
      UCHAR KernelOnlyAccess : 1;     // offset: 0x1b (27)
      UCHAR ExclusiveObject : 1;      // offset: 0x1b (27)
      UCHAR PermanentObject : 1;      // offset: 0x1b (27)
      UCHAR DefaultSecurityQuota : 1; // offset: 0x1b (27)
      UCHAR SingleHandleEntry : 1;    // offset: 0x1b (27)
      UCHAR DeletedInline : 1;        // offset: 0x1b (27)
    };
  };
  ULONG Reserved; // offset: 0x1c (28)
  union {
    struct _OBJECT_CREATE_INFORMATION *ObjectCreateInfo; // offset: 0x20 (32)
    VOID *QuotaBlockCharged;                             // offset: 0x20 (32)
  };
  VOID *SecurityDescriptor; // offset: 0x28 (40)
  struct _QUAD Body;        // offset: 0x30 (48)
};

// 0x28 (40) bytes
struct _OBJECT_REF_INFO {
  struct _OBJECT_HEADER *ObjectHeader;        // offset: 0x0 (0)
  VOID *NextRef;                              // offset: 0x8 (8)
  UCHAR ImageFileName[16];                    // offset: 0x10 (16)
  USHORT NextPos;                             // offset: 0x20 (32)
  USHORT MaxStacks;                           // offset: 0x22 (34)
  struct _OBJECT_REF_STACK_INFO StackInfo[0]; // offset: 0x24 (36)
};

// 0x110 (272) bytes
struct _DUMMY_FILE_OBJECT {
  struct _OBJECT_HEADER ObjectHeader; // offset: 0x0 (0)
  CHAR FileObjectBody[216];           // offset: 0x38 (56)
};

// 0xd8 (216) bytes
struct _OPEN_PACKET {
  SHORT Type;                      // offset: 0x0 (0)
  SHORT Size;                      // offset: 0x2 (2)
  struct _FILE_OBJECT *FileObject; // offset: 0x8 (8)
  LONG FinalStatus;                // offset: 0x10 (16)
  ULONGLONG Information;           // offset: 0x18 (24)
  ULONG ParseCheck;                // offset: 0x20 (32)
  union {
    struct _FILE_OBJECT *RelatedFileObject;        // offset: 0x28 (40)
    struct _DEVICE_OBJECT *ReferencedDeviceObject; // offset: 0x28 (40)
  };
  struct _OBJECT_ATTRIBUTES *OriginalAttributes;    // offset: 0x30 (48)
  union _LARGE_INTEGER AllocationSize;              // offset: 0x38 (56)
  ULONG CreateOptions;                              // offset: 0x40 (64)
  USHORT FileAttributes;                            // offset: 0x44 (68)
  USHORT ShareAccess;                               // offset: 0x46 (70)
  VOID *EaBuffer;                                   // offset: 0x48 (72)
  ULONG EaLength;                                   // offset: 0x50 (80)
  ULONG Options;                                    // offset: 0x54 (84)
  ULONG Disposition;                                // offset: 0x58 (88)
  struct _FILE_BASIC_INFORMATION *BasicInformation; // offset: 0x60 (96)
  struct _FILE_NETWORK_OPEN_INFORMATION
      *NetworkInformation;                              // offset: 0x68 (104)
  VOID *FileInformation;                                // offset: 0x70 (112)
  enum _CREATE_FILE_TYPE CreateFileType;                // offset: 0x78 (120)
  VOID *MailslotOrPipeParameters;                       // offset: 0x80 (128)
  UCHAR Override;                                       // offset: 0x88 (136)
  UCHAR QueryOnly;                                      // offset: 0x89 (137)
  UCHAR DeleteOnly;                                     // offset: 0x8a (138)
  UCHAR FullAttributes;                                 // offset: 0x8b (139)
  struct _DUMMY_FILE_OBJECT *LocalFileObject;           // offset: 0x90 (144)
  ULONG InternalFlags;                                  // offset: 0x98 (152)
  CHAR AccessMode;                                      // offset: 0x9c (156)
  struct _IO_DRIVER_CREATE_CONTEXT DriverCreateContext; // offset: 0xa0 (160)
  enum _FILE_INFORMATION_CLASS FileInformationClass;    // offset: 0xc8 (200)
  ULONG FileInformationLength;                          // offset: 0xcc (204)
  UCHAR FilterQuery;                                    // offset: 0xd0 (208)
};

// 0x18 (24) bytes
struct _ALPC_HANDLE_TABLE {
  struct _ALPC_HANDLE_ENTRY *Handles; // offset: 0x0 (0)
  ULONG TotalHandles;                 // offset: 0x8 (8)
  ULONG Flags;                        // offset: 0xc (12)
  struct _EX_PUSH_LOCK Lock;          // offset: 0x10 (16)
};

// 0x30 (48) bytes
struct _BLOB {
  union {
    struct _LIST_ENTRY ResourceList;   // offset: 0x0 (0)
    struct _SLIST_ENTRY FreeListEntry; // offset: 0x0 (0)
  };
  union {
    struct {
      UCHAR ReferenceCache : 1; // offset: 0x0 (0)
      UCHAR Lookaside : 1;      // offset: 0x0 (0)
      UCHAR Initializing : 1;   // offset: 0x0 (0)
      UCHAR Deleted : 1;        // offset: 0x0 (0)
    } s1;                       // offset: 0x10 (16)
    UCHAR Flags;                // offset: 0x10 (16)

  } u1;                      // offset: 0x10 (16)
  UCHAR ResourceId;          // offset: 0x11 (17)
  SHORT CachedReferences;    // offset: 0x12 (18)
  LONGLONG ReferenceCount;   // offset: 0x18 (24)
  struct _EX_PUSH_LOCK Lock; // offset: 0x20 (32)
};

// 0x18 (24) bytes
struct _CM_KEY_HASH_TABLE_ENTRY {
  struct _EX_PUSH_LOCK Lock;  // offset: 0x0 (0)
  struct _KTHREAD *Owner;     // offset: 0x8 (8)
  struct _CM_KEY_HASH *Entry; // offset: 0x10 (16)
};

// 0x12e8 (4840) bytes
struct _CMHIVE {
  struct _HHIVE Hive;                                 // offset: 0x0 (0)
  VOID *FileHandles[6];                               // offset: 0x600 (1536)
  struct _LIST_ENTRY NotifyList;                      // offset: 0x630 (1584)
  struct _LIST_ENTRY HiveList;                        // offset: 0x640 (1600)
  struct _LIST_ENTRY PreloadedHiveList;               // offset: 0x650 (1616)
  struct _EX_RUNDOWN_REF HiveRundown;                 // offset: 0x660 (1632)
  struct _CM_KEY_HASH_TABLE_ENTRY *KcbCacheTable;     // offset: 0x668 (1640)
  ULONG KcbCacheTableSize;                            // offset: 0x670 (1648)
  struct _CM_KEY_HASH_TABLE_ENTRY *DeletedKcbTable;   // offset: 0x678 (1656)
  ULONG DeletedKcbTableSize;                          // offset: 0x680 (1664)
  ULONG Identity;                                     // offset: 0x684 (1668)
  struct _CMSI_RW_LOCK HiveLock;                      // offset: 0x688 (1672)
  struct _RTL_BITMAP FlushDirtyVector;                // offset: 0x690 (1680)
  ULONG FlushDirtyVectorSize;                         // offset: 0x6a0 (1696)
  struct CMP_OFFSET_ARRAY *FlushLogEntryOffsetArray;  // offset: 0x6a8 (1704)
  ULONG FlushLogEntryOffsetArrayCount;                // offset: 0x6b0 (1712)
  ULONG FlushLogEntrySize;                            // offset: 0x6b4 (1716)
  ULONG FlushHiveTruncated;                           // offset: 0x6b8 (1720)
  UCHAR FlushBaseBlockDirty;                          // offset: 0x6bc (1724)
  struct _RTL_BITMAP CapturedUnreconciledVector;      // offset: 0x6c0 (1728)
  ULONG CapturedUnreconciledVectorSize;               // offset: 0x6d0 (1744)
  struct CMP_OFFSET_ARRAY *UnreconciledOffsetArray;   // offset: 0x6d8 (1752)
  ULONG UnreconciledOffsetArrayCount;                 // offset: 0x6e0 (1760)
  struct _HBASE_BLOCK *UnreconciledBaseBlock;         // offset: 0x6e8 (1768)
  struct _EX_PUSH_LOCK SecurityLock;                  // offset: 0x6f0 (1776)
  ULONG LastShrinkHiveSize;                           // offset: 0x6f8 (1784)
  union _LARGE_INTEGER ActualFileSize;                // offset: 0x700 (1792)
  union _LARGE_INTEGER LogFileSizes[2];               // offset: 0x708 (1800)
  struct _UNICODE_STRING FileFullPath;                // offset: 0x718 (1816)
  struct _UNICODE_STRING FileUserName;                // offset: 0x728 (1832)
  struct _UNICODE_STRING HiveRootPath;                // offset: 0x738 (1848)
  ULONG SecurityCount;                                // offset: 0x748 (1864)
  ULONG SecurityCacheSize;                            // offset: 0x74c (1868)
  LONG SecurityHitHint;                               // offset: 0x750 (1872)
  struct _CM_KEY_SECURITY_CACHE_ENTRY *SecurityCache; // offset: 0x758 (1880)
  struct _LIST_ENTRY SecurityHash[64];                // offset: 0x760 (1888)
  ULONG UnloadEventCount;                             // offset: 0xb60 (2912)
  struct _KEVENT **UnloadEventArray;                  // offset: 0xb68 (2920)
  struct _CM_KEY_CONTROL_BLOCK *RootKcb;              // offset: 0xb70 (2928)
  UCHAR Frozen;                                       // offset: 0xb78 (2936)
  struct _CM_WORKITEM *UnloadWorkItem;                // offset: 0xb80 (2944)
  struct _CM_WORKITEM UnloadWorkItemHolder;           // offset: 0xb88 (2952)
  struct _CM_DIRTY_VECTOR_LOG DirtyVectorLog;         // offset: 0xbb0 (2992)
  ULONG Flags;                                        // offset: 0x1038 (4152)
  struct _LIST_ENTRY TrustClassEntry;                 // offset: 0x1040 (4160)
  ULONGLONG DirtyTime;                                // offset: 0x1050 (4176)
  ULONGLONG UnreconciledTime;                         // offset: 0x1058 (4184)
  struct _CM_RM *CmRm;                                // offset: 0x1060 (4192)
  ULONG CmRmInitFailPoint;                            // offset: 0x1068 (4200)
  LONG CmRmInitFailStatus;                            // offset: 0x106c (4204)
  struct _KTHREAD *CreatorOwner;                      // offset: 0x1070 (4208)
  struct _KTHREAD *RundownThread;                     // offset: 0x1078 (4216)
  union _LARGE_INTEGER LastWriteTime;                 // offset: 0x1080 (4224)
  struct _HIVE_WRITE_WAIT_QUEUE FlushQueue;           // offset: 0x1088 (4232)
  struct _HIVE_WRITE_WAIT_QUEUE ReconcileQueue;       // offset: 0x1098 (4248)
  union {
    ULONG FlushFlags; // offset: 0x10a8 (4264)
    struct {
      ULONG PrimaryFilePurged : 1; // offset: 0x10a8 (4264)
      ULONG DiskFileBad : 1;       // offset: 0x10a8 (4264)
    };
  };
  ULONG PrimaryFileSizeBeforeLastFlush;         // offset: 0x10ac (4268)
  volatile LONG ReferenceCount;                 // offset: 0x10b0 (4272)
  LONG UnloadHistoryIndex;                      // offset: 0x10b4 (4276)
  ULONG UnloadHistory[128];                     // offset: 0x10b8 (4280)
  ULONG BootStart;                              // offset: 0x12b8 (4792)
  ULONG UnaccessedStart;                        // offset: 0x12bc (4796)
  ULONG UnaccessedEnd;                          // offset: 0x12c0 (4800)
  ULONG LoadedKeyCount;                         // offset: 0x12c4 (4804)
  volatile ULONG HandleClosePending;            // offset: 0x12c8 (4808)
  struct _EX_PUSH_LOCK HandleClosePendingEvent; // offset: 0x12d0 (4816)
  UCHAR FinalFlushSucceeded;                    // offset: 0x12d8 (4824)
  struct _CMP_VOLUME_CONTEXT *VolumeContext;    // offset: 0x12e0 (4832)
};

// 0xc8 (200) bytes
struct _HIVE_LIST_ENTRY {
  WCHAR *FileName;                           // offset: 0x0 (0)
  WCHAR *BaseName;                           // offset: 0x8 (8)
  WCHAR *RegRootName;                        // offset: 0x10 (16)
  struct _CMHIVE *CmHive;                    // offset: 0x18 (24)
  ULONG HHiveFlags;                          // offset: 0x20 (32)
  ULONG CmHiveFlags;                         // offset: 0x24 (36)
  ULONG CmKcbCacheSize;                      // offset: 0x28 (40)
  struct _CMHIVE *CmHive2;                   // offset: 0x30 (48)
  UCHAR HiveMounted;                         // offset: 0x38 (56)
  UCHAR ThreadFinished;                      // offset: 0x39 (57)
  UCHAR ThreadStarted;                       // offset: 0x3a (58)
  UCHAR Allocate;                            // offset: 0x3b (59)
  UCHAR WinPERequired;                       // offset: 0x3c (60)
  struct _KEVENT StartEvent;                 // offset: 0x40 (64)
  struct _KEVENT FinishedEvent;              // offset: 0x58 (88)
  struct _KEVENT MountLock;                  // offset: 0x70 (112)
  struct _EX_PUSH_LOCK MountCallbackLock;    // offset: 0x88 (136)
  struct _EX_PUSH_LOCK CallbackListLock;     // offset: 0x90 (144)
  struct _LIST_ENTRY CallbackListHead;       // offset: 0x98 (152)
  struct _WORK_QUEUE_ITEM *CallbackWorkItem; // offset: 0xa8 (168)
  volatile LONG CallbackWorkItemBusy;        // offset: 0xb0 (176)
  struct _UNICODE_STRING FilePath;           // offset: 0xb8 (184)
};

// 0x88 (136) bytes
struct _CM_RM {
  struct _LIST_ENTRY RmListEntry;         // offset: 0x0 (0)
  struct _LIST_ENTRY TransactionListHead; // offset: 0x10 (16)
  VOID *TmHandle;                         // offset: 0x20 (32)
  VOID *Tm;                               // offset: 0x28 (40)
  VOID *RmHandle;                         // offset: 0x30 (48)
  VOID *KtmRm;                            // offset: 0x38 (56)
  ULONG RefCount;                         // offset: 0x40 (64)
  ULONG ContainerNum;                     // offset: 0x44 (68)
  ULONGLONG ContainerSize;                // offset: 0x48 (72)
  struct _CMHIVE *CmHive;                 // offset: 0x50 (80)
  VOID *LogFileObject;                    // offset: 0x58 (88)
  VOID *MarshallingContext;               // offset: 0x60 (96)
  ULONG RmFlags;                          // offset: 0x68 (104)
  LONG LogStartStatus1;                   // offset: 0x6c (108)
  LONG LogStartStatus2;                   // offset: 0x70 (112)
  ULONGLONG BaseLsn;                      // offset: 0x78 (120)
  struct _ERESOURCE *RmLock;              // offset: 0x80 (128)
};

// 0xb8 (184) bytes
struct _CM_TRANS {
  struct _LIST_ENTRY TransactionListEntry; // offset: 0x0 (0)
  struct _LIST_ENTRY KCBUoWListHead;       // offset: 0x10 (16)
  struct _LIST_ENTRY LazyCommitListEntry;  // offset: 0x20 (32)
  union {
    struct {
      ULONG Prepared : 1;          // offset: 0x30 (48)
      ULONG Aborted : 1;           // offset: 0x30 (48)
      ULONG Committed : 1;         // offset: 0x30 (48)
      ULONG Initializing : 1;      // offset: 0x30 (48)
      ULONG Invalid : 1;           // offset: 0x30 (48)
      ULONG UseReservation : 1;    // offset: 0x30 (48)
      ULONG TmCallbacksActive : 1; // offset: 0x30 (48)
      ULONG LightWeight : 1;       // offset: 0x30 (48)
      ULONG Freed1 : 1;            // offset: 0x30 (48)
      ULONG Freed2 : 1;            // offset: 0x30 (48)
      ULONG Spare1 : 2;            // offset: 0x30 (48)
      ULONG Freed : 1;             // offset: 0x30 (48)
      ULONG Spare : 19;            // offset: 0x30 (48)
    };
    ULONG TransState; // offset: 0x30 (48)
  };
  union _CM_TRANS_PTR Trans;                // offset: 0x38 (56)
  struct _CM_RM *CmRm;                      // offset: 0x40 (64)
  struct _KENLISTMENT *KtmEnlistmentObject; // offset: 0x48 (72)
  VOID *KtmEnlistmentHandle;                // offset: 0x50 (80)
  struct _GUID KtmUow;                      // offset: 0x58 (88)
  ULONGLONG StartLsn;                       // offset: 0x68 (104)
  ULONG HiveCount;                          // offset: 0x70 (112)
  struct _CMHIVE *HiveArray[8];             // offset: 0x78 (120)
};

// 0x78 (120) bytes
struct _CM_KCB_UOW {
  struct _LIST_ENTRY TransactionListEntry;       // offset: 0x0 (0)
  struct _CM_INTENT_LOCK *KCBLock;               // offset: 0x10 (16)
  struct _CM_INTENT_LOCK *KeyLock;               // offset: 0x18 (24)
  struct _LIST_ENTRY KCBListEntry;               // offset: 0x20 (32)
  struct _CM_KEY_CONTROL_BLOCK *KeyControlBlock; // offset: 0x30 (48)
  struct _CM_TRANS *Transaction;                 // offset: 0x38 (56)
  ULONG UoWState;                                // offset: 0x40 (64)
  enum UoWActionType ActionType;                 // offset: 0x44 (68)
  enum HSTORAGE_TYPE StorageType;                // offset: 0x48 (72)
  struct _CM_KCB_UOW *ParentUoW;                 // offset: 0x50 (80)
  union {
    struct _CM_KEY_CONTROL_BLOCK *ChildKCB; // offset: 0x58 (88)
    ULONG VolatileKeyCell;                  // offset: 0x58 (88)
    struct {
      ULONG OldValueCell; // offset: 0x58 (88)
      ULONG NewValueCell; // offset: 0x5c (92)
    };
    ULONG UserFlags;                    // offset: 0x58 (88)
    union _LARGE_INTEGER LastWriteTime; // offset: 0x58 (88)
    struct {
      struct _CM_KEY_SECURITY_CACHE *TxCachedSecurity; // offset: 0x58 (88)
      ULONG TxSecurityCell;                            // offset: 0x60 (96)
    };
    struct {
      struct _CM_KEY_CONTROL_BLOCK *OldChildKCB; // offset: 0x58 (88)
      struct _CM_KEY_CONTROL_BLOCK *NewChildKCB; // offset: 0x60 (96)
    };
    struct {
      struct _CM_KEY_CONTROL_BLOCK *OtherChildKCB; // offset: 0x58 (88)
      ULONG ThisVolatileKeyCell;                   // offset: 0x60 (96)
    };
  };
  union {
    VOID *PrepareDataPointer;                              // offset: 0x68 (104)
    struct _CM_UOW_SET_SD_DATA *SecurityData;              // offset: 0x68 (104)
    struct _CM_UOW_KEY_STATE_MODIFICATION *ModifyKeysData; // offset: 0x68 (104)
    struct _CM_UOW_SET_VALUE_LIST_DATA *SetValueData;      // offset: 0x68 (104)
  };
  union {
    struct _CM_UOW_SET_VALUE_KEY_DATA *ValueData; // offset: 0x70 (112)
    struct _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT
        *DiscardReplaceContext; // offset: 0x70 (112)
  };
};

// 0x138 (312) bytes
struct _CM_KEY_CONTROL_BLOCK {
  ULONGLONG RefCount;       // offset: 0x0 (0)
  ULONG ExtFlags : 16;      // offset: 0x8 (8)
  ULONG Freed : 1;          // offset: 0x8 (8)
  ULONG Discarded : 1;      // offset: 0x8 (8)
  ULONG HiveUnloaded : 1;   // offset: 0x8 (8)
  ULONG Decommissioned : 1; // offset: 0x8 (8)
  ULONG SpareExtFlag : 1;   // offset: 0x8 (8)
  ULONG TotalLevels : 10;   // offset: 0x8 (8)
  union {
    struct _CM_KEY_HASH KeyHash; // offset: 0x10 (16)
    struct {
      struct _CM_PATH_HASH ConvKey;  // offset: 0x10 (16)
      struct _CM_KEY_HASH *NextHash; // offset: 0x18 (24)
      struct _HHIVE *KeyHive;        // offset: 0x20 (32)
      ULONG KeyCell;                 // offset: 0x28 (40)
    };
  };
  struct _EX_PUSH_LOCK KcbPushlock; // offset: 0x30 (48)
  union {
    struct _KTHREAD *Owner; // offset: 0x38 (56)
    LONG SharedCount;       // offset: 0x38 (56)
  };
  UCHAR DelayedDeref : 1;                        // offset: 0x40 (64)
  UCHAR DelayedClose : 1;                        // offset: 0x40 (64)
  UCHAR Parking : 1;                             // offset: 0x40 (64)
  UCHAR LayerSemantics;                          // offset: 0x41 (65)
  SHORT LayerHeight;                             // offset: 0x42 (66)
  ULONG Spare1;                                  // offset: 0x44 (68)
  struct _CM_KEY_CONTROL_BLOCK *ParentKcb;       // offset: 0x48 (72)
  struct _CM_NAME_CONTROL_BLOCK *NameBlock;      // offset: 0x50 (80)
  struct _CM_KEY_SECURITY_CACHE *CachedSecurity; // offset: 0x58 (88)
  struct _CHILD_LIST ValueList;                  // offset: 0x60 (96)
  struct _CM_KEY_CONTROL_BLOCK *LinkTarget;      // offset: 0x68 (104)
  union {
    struct _CM_INDEX_HINT_BLOCK *IndexHint; // offset: 0x70 (112)
    ULONG HashKey;                          // offset: 0x70 (112)
    ULONG SubKeyCount;                      // offset: 0x70 (112)
  };
  union {
    struct _LIST_ENTRY KeyBodyListHead; // offset: 0x78 (120)
    struct _LIST_ENTRY ClonedListEntry; // offset: 0x78 (120)
  };
  struct _CM_KEY_BODY *KeyBodyArray[4];  // offset: 0x88 (136)
  union _LARGE_INTEGER KcbLastWriteTime; // offset: 0xa8 (168)
  USHORT KcbMaxNameLen;                  // offset: 0xb0 (176)
  USHORT KcbMaxValueNameLen;             // offset: 0xb2 (178)
  ULONG KcbMaxValueDataLen;              // offset: 0xb4 (180)
  ULONG KcbUserFlags : 4;                // offset: 0xb8 (184)
  ULONG KcbVirtControlFlags : 4;         // offset: 0xb8 (184)
  ULONG KcbDebug : 8;                    // offset: 0xb8 (184)
  ULONG Flags : 16;                      // offset: 0xb8 (184)
  ULONG Spare3;                          // offset: 0xbc (188)
  struct _CM_KCB_LAYER_INFO *LayerInfo;  // offset: 0xc0 (192)
  CHAR *RealKeyName;                     // offset: 0xc8 (200)
  struct _LIST_ENTRY KCBUoWListHead;     // offset: 0xd0 (208)
  union {
    struct _LIST_ENTRY DelayQueueEntry; // offset: 0xe0 (224)
    volatile UCHAR *Stolen;             // offset: 0xe0 (224)
  };
  struct _CM_TRANS *TransKCBOwner;       // offset: 0xf0 (240)
  struct _CM_INTENT_LOCK KCBLock;        // offset: 0xf8 (248)
  struct _CM_INTENT_LOCK KeyLock;        // offset: 0x108 (264)
  struct _CHILD_LIST TransValueCache;    // offset: 0x118 (280)
  struct _CM_TRANS *TransValueListOwner; // offset: 0x120 (288)
  union {
    struct _UNICODE_STRING *FullKCBName; // offset: 0x128 (296)
    struct {
      ULONGLONG FullKCBNameStale : 1; // offset: 0x128 (296)
      ULONGLONG Reserved : 63;        // offset: 0x128 (296)
    };
  };
  ULONGLONG SequenceNumber; // offset: 0x130 (304)
};

// 0x40 (64) bytes
struct _MMVAD_SHORT {
  union {
    struct {
      struct _MMVAD_SHORT *NextVad; // offset: 0x0 (0)
      VOID *ExtraCreateInfo;        // offset: 0x8 (8)
    };
    struct _RTL_BALANCED_NODE VadNode; // offset: 0x0 (0)
  };
  ULONG StartingVpn;             // offset: 0x18 (24)
  ULONG EndingVpn;               // offset: 0x1c (28)
  UCHAR StartingVpnHigh;         // offset: 0x20 (32)
  UCHAR EndingVpnHigh;           // offset: 0x21 (33)
  UCHAR CommitChargeHigh;        // offset: 0x22 (34)
  UCHAR SpareNT64VadUChar;       // offset: 0x23 (35)
  LONG ReferenceCount;           // offset: 0x24 (36)
  struct _EX_PUSH_LOCK PushLock; // offset: 0x28 (40)
  union {
    ULONG LongFlags;                                // offset: 0x30 (48)
    struct _MMVAD_FLAGS VadFlags;                   // offset: 0x30 (48)
    struct _MM_PRIVATE_VAD_FLAGS PrivateVadFlags;   // offset: 0x30 (48)
    struct _MM_GRAPHICS_VAD_FLAGS GraphicsVadFlags; // offset: 0x30 (48)
    struct _MM_SHARED_VAD_FLAGS SharedVadFlags;     // offset: 0x30 (48)
    volatile ULONG VolatileVadLong;                 // offset: 0x30 (48)

  } u; // offset: 0x30 (48)
  union {
    ULONG LongFlags1;               // offset: 0x34 (52)
    struct _MMVAD_FLAGS1 VadFlags1; // offset: 0x34 (52)

  } u1;                                  // offset: 0x34 (52)
  struct _MI_VAD_EVENT_BLOCK *EventList; // offset: 0x38 (56)
};

// 0x48 (72) bytes
struct _SEGMENT {
  struct _CONTROL_AREA *ControlArea;  // offset: 0x0 (0)
  ULONG TotalNumberOfPtes;            // offset: 0x8 (8)
  struct _SEGMENT_FLAGS SegmentFlags; // offset: 0xc (12)
  ULONGLONG NumberOfCommittedPages;   // offset: 0x10 (16)
  ULONGLONG SizeOfSegment;            // offset: 0x18 (24)
  union {
    struct _MMEXTEND_INFO *ExtendInfo; // offset: 0x20 (32)
    VOID *BasedAddress;                // offset: 0x20 (32)
  };
  struct _EX_PUSH_LOCK SegmentLock; // offset: 0x28 (40)
  union {
    ULONGLONG ImageCommitment; // offset: 0x30 (48)
    ULONG CreatingProcessId;   // offset: 0x30 (48)

  } u1; // offset: 0x30 (48)
  union {
    struct _MI_SECTION_IMAGE_INFORMATION *ImageInformation; // offset: 0x38 (56)
    VOID *FirstMappedVa;                                    // offset: 0x38 (56)

  } u2;                        // offset: 0x38 (56)
  struct _MMPTE *PrototypePte; // offset: 0x40 (64)
};

// 0x80 (128) bytes
struct _CONTROL_AREA {
  struct _SEGMENT *Segment; // offset: 0x0 (0)
  union {
    struct _LIST_ENTRY ListHead; // offset: 0x8 (8)
    VOID *AweContext;            // offset: 0x8 (8)
  };
  ULONGLONG NumberOfSectionReferences; // offset: 0x18 (24)
  ULONGLONG NumberOfPfnReferences;     // offset: 0x20 (32)
  ULONGLONG NumberOfMappedViews;       // offset: 0x28 (40)
  ULONGLONG NumberOfUserReferences;    // offset: 0x30 (48)
  union {
    ULONG LongFlags;               // offset: 0x38 (56)
    struct _MMSECTION_FLAGS Flags; // offset: 0x38 (56)

  } u; // offset: 0x38 (56)
  union {
    ULONG LongFlags;                // offset: 0x3c (60)
    struct _MMSECTION_FLAGS2 Flags; // offset: 0x3c (60)

  } u1;                                         // offset: 0x3c (60)
  struct _EX_FAST_REF FilePointer;              // offset: 0x40 (64)
  volatile LONG ControlAreaLock;                // offset: 0x48 (72)
  ULONG ModifiedWriteCount;                     // offset: 0x4c (76)
  struct _MI_CONTROL_AREA_WAIT_BLOCK *WaitList; // offset: 0x50 (80)
  union {
    struct {
      union {
        ULONG NumberOfSystemCacheViews; // offset: 0x0 (0)
        ULONG ImageRelocationStartBit;  // offset: 0x0 (0)
      };
      union {
        volatile LONG WritableUserReferences; // offset: 0x4 (4)
        struct {
          ULONG ImageRelocationSizeIn64k : 16; // offset: 0x4 (4)
          ULONG SystemImage : 1;               // offset: 0x4 (4)
          ULONG CantMove : 1;                  // offset: 0x4 (4)
          ULONG StrongCode : 2;                // offset: 0x4 (4)
          ULONG BitMap : 2;                    // offset: 0x4 (4)
          ULONG ImageActive : 1;               // offset: 0x4 (4)
          ULONG ImageBaseOkToReuse : 1;        // offset: 0x4 (4)
        };
      };
      union {
        ULONG FlushInProgressCount;                       // offset: 0x8 (8)
        ULONG NumberOfSubsections;                        // offset: 0x8 (8)
        struct _MI_IMAGE_SECURITY_REFERENCE *SeImageStub; // offset: 0x8 (8)
      };
    } e2; // offset: 0x58 (88)

  } u2;                                // offset: 0x58 (88)
  struct _EX_PUSH_LOCK FileObjectLock; // offset: 0x68 (104)
  volatile ULONGLONG LockedPages;      // offset: 0x70 (112)
  union {
    ULONGLONG IoAttributionContext : 61; // offset: 0x78 (120)
    ULONGLONG Spare : 3;                 // offset: 0x78 (120)
    ULONGLONG ImageCrossPartitionCharge; // offset: 0x78 (120)
    ULONGLONG CommittedPageCount : 36;   // offset: 0x78 (120)

  } u3; // offset: 0x78 (120)
};

// 0x340 (832) bytes
struct _MI_SECTION_STATE {
  volatile LONG SectionObjectPointersLock;         // offset: 0x0 (0)
  struct _RTL_AVL_TREE SectionBasedRoot;           // offset: 0x8 (8)
  struct _EX_PUSH_LOCK SectionBasedLock;           // offset: 0x10 (16)
  volatile ULONGLONG UnusedSegmentPagedPool;       // offset: 0x18 (24)
  ULONG DataSectionProtectionMask;                 // offset: 0x20 (32)
  VOID *HighSectionBase;                           // offset: 0x28 (40)
  struct _MSUBSECTION PhysicalSubsection;          // offset: 0x30 (48)
  struct _CONTROL_AREA PhysicalControlArea;        // offset: 0xc0 (192)
  struct _MMPFNLIST PurgingExtentPages;            // offset: 0x140 (320)
  struct _MMPFN *DanglingExtentPages;              // offset: 0x168 (360)
  struct _WORK_QUEUE_ITEM DanglingExtentsWorkItem; // offset: 0x170 (368)
  struct _MI_EXTENT_DELETION_WAIT_BLOCK
      DanglingExtentsDeletionWaitList;               // offset: 0x190 (400)
  UCHAR FileOnlyMemoryPfnsCreated;                   // offset: 0x1b0 (432)
  UCHAR DanglingExtentsWorkerActive;                 // offset: 0x1b1 (433)
  UCHAR PurgingExtentsNeedWatchdog;                  // offset: 0x1b2 (434)
  struct _RTL_AVL_TREE PrototypePtesTree;            // offset: 0x1b8 (440)
  volatile LONG PrototypePtesTreeSpinLock;           // offset: 0x1c0 (448)
  struct _EX_PUSH_LOCK RelocateBitmapsLock;          // offset: 0x1c8 (456)
  struct _RTL_BITMAP_EX ImageBitMapNative;           // offset: 0x1d0 (464)
  ULONGLONG ImageBiasNative;                         // offset: 0x1e0 (480)
  struct _MI_DLL_OVERFLOW_AREA OverflowArea;         // offset: 0x1e8 (488)
  struct _MI_SECTION_WOW_STATE Wow[1];               // offset: 0x208 (520)
  ULONGLONG ImageBiasWow;                            // offset: 0x248 (584)
  struct _RTL_BITMAP_EX ImageBitMapWowScratch;       // offset: 0x250 (592)
  struct _RTL_BITMAP_EX ImageBitMap64Low;            // offset: 0x260 (608)
  ULONGLONG ImageBias64Low;                          // offset: 0x270 (624)
  VOID *ApiSetSection;                               // offset: 0x278 (632)
  VOID *ApiSetSchema;                                // offset: 0x280 (640)
  ULONGLONG ApiSetSchemaSize;                        // offset: 0x288 (648)
  ULONG LostDataFiles;                               // offset: 0x290 (656)
  ULONG LostDataPages;                               // offset: 0x294 (660)
  ULONG ImageFailureReason;                          // offset: 0x298 (664)
  struct _SECTION *CfgBitMapSection;                 // offset: 0x2a0 (672)
  struct _CONTROL_AREA *CfgBitMapControlArea;        // offset: 0x2a8 (680)
  struct _RTL_BITMAP_EX KernelCfgBitMap;             // offset: 0x2b0 (688)
  struct _EX_PUSH_LOCK KernelCfgBitMapLock;          // offset: 0x2c0 (704)
  ULONG ImageCfgFailure;                             // offset: 0x2c8 (712)
  ULONG RetpolineReservePages;                       // offset: 0x2cc (716)
  struct _MDL *RetpolineStubMdl;                     // offset: 0x2d0 (720)
  struct _RTL_BITMAP_EX KernelRetpolineBitMap;       // offset: 0x2d8 (728)
  struct _RTL_RETPOLINE_ROUTINES *RetpolineRoutines; // offset: 0x2e8 (744)
  struct _MMPTE *RetpolineRevertPte;                 // offset: 0x2f0 (752)
  struct _LIST_ENTRY NonRetpolineImageLoadList;      // offset: 0x2f8 (760)
  ULONG RetpolineStubPages;                          // offset: 0x308 (776)
  LONG RetpolineBootStatus;                          // offset: 0x30c (780)
  ULONG ImageBreakpointEnabled;                      // offset: 0x310 (784)
  ULONG ImageBreakpointChecksum;                     // offset: 0x314 (788)
  ULONG ImageBreakpointSize;                         // offset: 0x318 (792)
  volatile LONG ImageValidationFailed;               // offset: 0x31c (796)
  struct _RTL_AVL_TREE ImageExtentTree;              // offset: 0x320 (800)
  struct _EX_PUSH_LOCK ImageExtentTreeLock;          // offset: 0x328 (808)
  ULONG HotPatchReserveSize;                         // offset: 0x330 (816)
};

// 0x11c0 (4544) bytes
struct _MI_NODE_INFORMATION {
  struct _MI_FREE_LARGE_PAGES FreeLargePages[3]; // offset: 0x0 (0)
  struct _MI_REBUILD_LARGE_PAGE_TIMER
      LargePageRebuildTimer;                     // offset: 0xc90 (3216)
  struct _MMPFNLIST_SHORT StandbyPageList[4][8]; // offset: 0xcb8 (3256)
  struct _RTL_BITMAP FreePageListHeadsBitmap[2]; // offset: 0xfc0 (4032)
  ULONG FreePageListHeadsBitmapBuffer[16];       // offset: 0xfe0 (4064)
  volatile ULONGLONG FreeCount[2];               // offset: 0x1020 (4128)
  ULONGLONG TotalPages[4];                       // offset: 0x1030 (4144)
  ULONGLONG TotalPagesEntireNode;                // offset: 0x1050 (4176)
  ULONG CurrentHugeRangeColor;                   // offset: 0x1058 (4184)
  ULONGLONG HugeIoRangeFreeCount[2];             // offset: 0x1060 (4192)
  ULONG MmShiftedColor;                          // offset: 0x1070 (4208)
  ULONG Color;                                   // offset: 0x1074 (4212)
  volatile ULONGLONG ChannelFreeCount[4][2];     // offset: 0x1078 (4216)
  struct {
    ULONG ChannelsHotCold : 1;   // offset: 0x0 (0)
    ULONG Spare : 31;            // offset: 0x0 (0)
  } Flags;                       // offset: 0x10b8 (4280)
  ULONG LargeListMoveInProgress; // offset: 0x10bc (4284)
  struct _MI_LARGE_PAGE_LISTS_CHANGING
      *LargeListWaiters;                         // offset: 0x10c0 (4288)
  struct _EX_PUSH_LOCK NodeLock;                 // offset: 0x10c8 (4296)
  ULONGLONG ZeroThreadHugeMapLock;               // offset: 0x10d0 (4304)
  UCHAR ChannelStatus;                           // offset: 0x10d8 (4312)
  UCHAR ChannelOrdering[4];                      // offset: 0x10d9 (4313)
  UCHAR LockedChannelOrdering[4];                // offset: 0x10dd (4317)
  UCHAR PowerAttribute[4];                       // offset: 0x10e1 (4321)
  ULONGLONG LargePageLock;                       // offset: 0x10e8 (4328)
  struct _MI_PAGE_COLORS PageColorTable;         // offset: 0x10f0 (4336)
  ULONGLONG NumberOfPagesGoingBad;               // offset: 0x1100 (4352)
  struct _MI_WRITE_CALIBRATION WriteCalibration; // offset: 0x1108 (4360)
  VOID *BootZeroContext;                         // offset: 0x1128 (4392)
  VOID *BootZeroPageTimesPerProcessor;           // offset: 0x1130 (4400)
  VOID *ZeroingVaBase;                           // offset: 0x1138 (4408)
  ULONGLONG TotalBytesToZero;                    // offset: 0x1140 (4416)
  ULONGLONG PerProcessorNumberOfBytesToZero;     // offset: 0x1148 (4424)
  VOID *ZeroingContext;                          // offset: 0x1150 (4432)
  volatile ULONG ZeroingProcessorCount;          // offset: 0x1158 (4440)
  volatile LONG ZeroHand;                        // offset: 0x115c (4444)
  volatile LONG FinishedProcessors;              // offset: 0x1160 (4448)
  ULONGLONG CyclesToZeroOneLargePage;            // offset: 0x1168 (4456)
  ULONGLONG *ScaledCyclesToZeroOneLargePage;     // offset: 0x1170 (4464)
  struct _GROUP_AFFINITY GroupAffinity;          // offset: 0x1178 (4472)
  USHORT ProcessorCount;                         // offset: 0x1188 (4488)
  UCHAR BackgroundZeroingActive;                 // offset: 0x118a (4490)
  struct _PHYSICAL_MEMORY_DESCRIPTOR
      *ZeroingPhysicalMemoryBlock; // offset: 0x1190 (4496)
};

// 0x2c0 (704) bytes
struct _MI_PARTITION_MODWRITES {
  struct _MMPAGE_FILE_EXPANSION AttemptForCantExtend;     // offset: 0x0 (0)
  struct _MMPAGE_FILE_EXPANSION PageFileContract;         // offset: 0x58 (88)
  ULONGLONG NumberOfMappedMdls;                           // offset: 0xb0 (176)
  volatile LONG NumberOfMappedMdlsInUse;                  // offset: 0xb8 (184)
  ULONG NumberOfMappedMdlsInUsePeak;                      // offset: 0xbc (188)
  struct _MMMOD_WRITER_LISTHEAD MappedFileHeader;         // offset: 0xc0 (192)
  UCHAR NeedMappedMdl;                                    // offset: 0xe8 (232)
  UCHAR NeedPageFileMdl;                                  // offset: 0xe9 (233)
  UCHAR ModwriterActive;                                  // offset: 0xea (234)
  UCHAR TransitionInserted;                               // offset: 0xeb (235)
  LONG LastModifiedWriteError;                            // offset: 0xec (236)
  LONG LastMappedWriteError;                              // offset: 0xf0 (240)
  volatile ULONG MappedFileWriteSucceeded;                // offset: 0xf4 (244)
  ULONG MappedWriteBurstCount;                            // offset: 0xf8 (248)
  ULONG LowPriorityModWritesOutstanding;                  // offset: 0xfc (252)
  struct _KEVENT BoostModWriteIoPriorityEvent;            // offset: 0x100 (256)
  LONG ModifiedWriterThreadPriority;                      // offset: 0x118 (280)
  ULONGLONG ModifiedPagesLowPriorityGoal;                 // offset: 0x120 (288)
  struct _KEVENT ModifiedPageWriterEvent;                 // offset: 0x128 (296)
  struct _KEVENT ModifiedWriterExitedEvent;               // offset: 0x140 (320)
  volatile LONG WriteAllPagefilePages;                    // offset: 0x158 (344)
  volatile LONG WriteAllMappedPages;                      // offset: 0x15c (348)
  struct _KEVENT MappedPageWriterEvent;                   // offset: 0x160 (352)
  struct _MI_MODWRITE_DATA ModWriteData;                  // offset: 0x178 (376)
  struct _KEVENT RescanPageFilesEvent;                    // offset: 0x1b8 (440)
  struct _MMMOD_WRITER_LISTHEAD PagingFileHeader;         // offset: 0x1d0 (464)
  struct _ETHREAD *ModifiedPageWriterThread;              // offset: 0x1f8 (504)
  struct _EX_RUNDOWN_REF ModifiedPageWriterRundown;       // offset: 0x200 (512)
  struct _WORK_QUEUE_ITEM PagefileScanWorkItem;           // offset: 0x208 (520)
  ULONG PagefileScanCount;                                // offset: 0x228 (552)
  volatile LONG ClusterRestrictionLock;                   // offset: 0x22c (556)
  struct _MI_RESTRICTED_MODWRITES ClusterRestrictions[2]; // offset: 0x230 (560)
  struct _KEVENT NotifyStoreMemoryConditions;             // offset: 0x238 (568)
  volatile UCHAR DelayMappedWrite;                        // offset: 0x250 (592)
  volatile ULONG PagefileReservationsEnabled;             // offset: 0x254 (596)
  struct _EX_PUSH_LOCK PageFileCreationLock;              // offset: 0x258 (600)
  struct _WORK_QUEUE_ITEM TrimPagefileWorkItem;           // offset: 0x260 (608)
  ULONGLONG LastTrimPagefileTime;                         // offset: 0x280 (640)
  struct _WORK_QUEUE_ITEM WsSwapPagefileContractWorkItem; // offset: 0x288 (648)
  volatile LONG WsSwapPageFileContractionInProgress;      // offset: 0x2a8 (680)
  struct _EX_PUSH_LOCK WorkingSetSwapLock;                // offset: 0x2b0 (688)
  volatile LONG WorkingSetInswapLock;                     // offset: 0x2b8 (696)
};

// 0x1b8 (440) bytes
struct _MI_PARTITION_CORE {
  USHORT PartitionId; // offset: 0x0 (0)
  union {
    ULONG LongFlags;                  // offset: 0x4 (4)
    struct _MI_PARTITION_FLAGS Flags; // offset: 0x4 (4)

  } u;                                                // offset: 0x4 (4)
  ULONG Signature;                                    // offset: 0x8 (8)
  UCHAR MemoryConfigurationChanged;                   // offset: 0xc (12)
  struct _MI_NODE_INFORMATION *NodeInformation;       // offset: 0x10 (16)
  struct _RTL_AVL_TREE PageRoot;                      // offset: 0x18 (24)
  struct _PHYSICAL_MEMORY_DESCRIPTOR *MemoryNodeRuns; // offset: 0x20 (32)
  ULONGLONG MemoryBlockReferences;                    // offset: 0x28 (40)
  struct _WORK_QUEUE_ITEM PfnUnmapWorkItem;           // offset: 0x30 (48)
  ULONGLONG PfnUnmapCount;                            // offset: 0x50 (80)
  VOID *PfnUnmapWaitList;                             // offset: 0x58 (88)
  struct _PHYSICAL_MEMORY_DESCRIPTOR *MemoryRuns;     // offset: 0x60 (96)
  struct _KEVENT ExitEvent;                           // offset: 0x68 (104)
  VOID *SystemThreadHandles[6];                       // offset: 0x80 (128)
  struct _EPARTITION *PartitionObject;                // offset: 0xb0 (176)
  struct _EX_PUSH_LOCK PartitionSystemThreadsLock;    // offset: 0xb8 (184)
  struct _EX_PUSH_LOCK DynamicMemoryPushLock;         // offset: 0xc0 (192)
  volatile LONG DynamicMemoryLock;                    // offset: 0xc8 (200)
  UCHAR PfnUnmapActive;                               // offset: 0xcc (204)
  struct _KEVENT TemporaryMemoryEvent;                // offset: 0xd0 (208)
  VOID *RootDirectory;                                // offset: 0xe8 (232)
  VOID *KernelObjectsDirectory;                       // offset: 0xf0 (240)
  struct _KEVENT *MemoryEvents[11];                   // offset: 0xf8 (248)
  VOID *MemoryEventHandles[11];                       // offset: 0x150 (336)
  ULONGLONG TotalHugeIoRanges;                        // offset: 0x1a8 (424)
  ULONGLONG NonChargedSecurePages;                    // offset: 0x1b0 (432)
};

// 0x10 (16) bytes
struct _EX_PUSH_LOCK_AUTO_EXPAND {
  struct _EX_PUSH_LOCK LocalLock;               // offset: 0x0 (0)
  struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE State; // offset: 0x8 (8)
  ULONG Stats;                                  // offset: 0xc (12)
};

// 0x68 (104) bytes
struct _FSRTL_ADVANCED_FCB_HEADER {
  SHORT NodeTypeCode;                   // offset: 0x0 (0)
  SHORT NodeByteSize;                   // offset: 0x2 (2)
  UCHAR Flags;                          // offset: 0x4 (4)
  UCHAR IsFastIoPossible;               // offset: 0x5 (5)
  UCHAR Flags2;                         // offset: 0x6 (6)
  UCHAR Reserved : 4;                   // offset: 0x7 (7)
  UCHAR Version : 4;                    // offset: 0x7 (7)
  struct _ERESOURCE *Resource;          // offset: 0x8 (8)
  struct _ERESOURCE *PagingIoResource;  // offset: 0x10 (16)
  union _LARGE_INTEGER AllocationSize;  // offset: 0x18 (24)
  union _LARGE_INTEGER FileSize;        // offset: 0x20 (32)
  union _LARGE_INTEGER ValidDataLength; // offset: 0x28 (40)
  struct _FAST_MUTEX *FastMutex;        // offset: 0x30 (48)
  struct _LIST_ENTRY FilterContexts;    // offset: 0x38 (56)
  struct _EX_PUSH_LOCK PushLock;        // offset: 0x48 (72)
  VOID **FileContextSupportPointer;     // offset: 0x50 (80)
  union {
    VOID *Oplock;            // offset: 0x58 (88)
    VOID *ReservedForRemote; // offset: 0x58 (88)
  };
  VOID *ReservedContext; // offset: 0x60 (96)
};

// 0x280 (640) bytes
struct _ADAPTER_OBJECT {
  struct _HALP_DMA_ADAPTER_OBJECT AdapterObject;         // offset: 0x0 (0)
  struct _HALP_DMA_MASTER_ADAPTER_OBJECT *MasterAdapter; // offset: 0x98 (152)
  struct _LIST_ENTRY WaitQueueEntry;                     // offset: 0xa0 (160)
  union {
    struct _KDEVICE_QUEUE ChannelWaitQueue; // offset: 0xb0 (176)
    struct {
      ULONGLONG ResourceWaitLock;                  // offset: 0xb0 (176)
      struct _LIST_ENTRY ResourceWaitQueue;        // offset: 0xb8 (184)
      struct _LIST_ENTRY ChannelResourceWaitQueue; // offset: 0xc8 (200)
    };
  };
  UCHAR ResourceQueueBusy;                              // offset: 0xd8 (216)
  ULONG MapRegistersPerChannel;                         // offset: 0xe0 (224)
  VOID *MapRegisterBase;                                // offset: 0xe8 (232)
  ULONG NumberOfMapRegisters;                           // offset: 0xf0 (240)
  ULONG MaxTransferLength;                              // offset: 0xf4 (244)
  VOID *CrashDumpRegisterBase[2];                       // offset: 0xf8 (248)
  ULONG NumberOfCrashDumpRegisters[2];                  // offset: 0x108 (264)
  ULONG CrashDumpRegisterRefCount[2];                   // offset: 0x110 (272)
  struct _LIST_ENTRY AdapterCrashDumpList;              // offset: 0x118 (280)
  struct _MDL *MapRegisterMdl;                          // offset: 0x128 (296)
  ULONGLONG MapRegisterMdlLock;                         // offset: 0x130 (304)
  struct _EX_PUSH_LOCK ExpiredLock;                     // offset: 0x138 (312)
  VOID *AllocationHandle;                               // offset: 0x140 (320)
  VOID *VirtualAddress;                                 // offset: 0x148 (328)
  UCHAR IsAllocationMdlBased;                           // offset: 0x150 (336)
  UCHAR NoLocalPool;                                    // offset: 0x151 (337)
  UCHAR ExpiredFlag;                                    // offset: 0x152 (338)
  struct _WAIT_CONTEXT_BLOCK *CurrentWcb;               // offset: 0x158 (344)
  struct _DMA_TRANSFER_CONTEXT *CurrentTransferContext; // offset: 0x160 (352)
  struct _HALP_DMA_CONTROLLER *DmaController;           // offset: 0x168 (360)
  ULONG Controller;                                     // offset: 0x170 (368)
  ULONG ChannelNumber;                                  // offset: 0x174 (372)
  ULONG RequestLine;                                    // offset: 0x178 (376)
  ULONG RequestedChannelCount;                          // offset: 0x17c (380)
  ULONG AllocatedChannelCount;                          // offset: 0x180 (384)
  ULONG AllocatedChannels[8];                           // offset: 0x184 (388)
  VOID *ChannelAdapter;                                 // offset: 0x1a8 (424)
  UCHAR NeedsMapRegisters;                              // offset: 0x1b0 (432)
  UCHAR MasterDevice;                                   // offset: 0x1b1 (433)
  UCHAR ScatterGather;                                  // offset: 0x1b2 (434)
  UCHAR AutoInitialize;                                 // offset: 0x1b3 (435)
  UCHAR IgnoreCount;                                    // offset: 0x1b4 (436)
  UCHAR CacheCoherent;                                  // offset: 0x1b5 (437)
  union {
    struct {
      UCHAR Dma32BitAddresses; // offset: 0x1b8 (440)
      UCHAR Dma64BitAddresses; // offset: 0x1b9 (441)
    };
    ULONG DmaAddressWidth; // offset: 0x1b8 (440)
  };
  enum _DMA_WIDTH DmaPortWidth;                     // offset: 0x1bc (444)
  union _LARGE_INTEGER DeviceAddress;               // offset: 0x1c0 (448)
  struct _LIST_ENTRY AdapterList;                   // offset: 0x1c8 (456)
  struct _WORK_QUEUE_ITEM WorkItem;                 // offset: 0x1d8 (472)
  struct _HALP_DMA_DOMAIN_OBJECT *DomainPointer;    // offset: 0x1f8 (504)
  enum _EXT_IOMMU_TRANSLATION_TYPE TranslationType; // offset: 0x200 (512)
  UCHAR AdapterInUse;                               // offset: 0x204 (516)
  struct _DEVICE_OBJECT *DeviceObject;              // offset: 0x208 (520)
  struct _EXT_IOMMU_DEVICE_ID *DeviceId;            // offset: 0x210 (528)
  VOID *IommuDevice;                                // offset: 0x218 (536)
  struct _MDL *ScatterGatherMdl;                    // offset: 0x220 (544)
  ULONGLONG LowMemoryLogicalAddressBase;            // offset: 0x228 (552)
  ULONGLONG LowMemoryLogicalAddressQueueLock;       // offset: 0x230 (560)
  struct _LIST_ENTRY LowMemoryLogicalAddressQueue;  // offset: 0x238 (568)
  UCHAR LowMemoryLogicalAddressQueueInUse;          // offset: 0x248 (584)
  struct _HALP_EMERGENCY_LA_QUEUE_ENTRY
      LowMemoryLogicalAddressQueueEntry; // offset: 0x250 (592)
  enum _HALP_DMA_ADAPTER_ALLOCATION_STATE
      AllocationState;                             // offset: 0x268 (616)
  ULONG ScatterGatherBufferLength;                 // offset: 0x26c (620)
  struct _SCATTER_GATHER_LIST ScatterGatherBuffer; // offset: 0x270 (624)
};

// 0x108 (264) bytes
struct _DUMP_INITIALIZATION_CONTEXT {
  ULONG Length;                                    // offset: 0x0 (0)
  ULONG Reserved;                                  // offset: 0x4 (4)
  VOID *MemoryBlock;                               // offset: 0x8 (8)
  VOID *CommonBuffer[2];                           // offset: 0x10 (16)
  union _LARGE_INTEGER PhysicalAddress[2];         // offset: 0x20 (32)
  VOID (*StallRoutine)(ULONG arg1);                // offset: 0x30 (48)
  UCHAR (*OpenRoutine)(union _LARGE_INTEGER arg1); // offset: 0x38 (56)
  LONG (*WriteRoutine)
  (union _LARGE_INTEGER *arg1, struct _MDL *arg2); // offset: 0x40 (64)
  VOID (*FinishRoutine)();                         // offset: 0x48 (72)
  struct _ADAPTER_OBJECT *AdapterObject;           // offset: 0x50 (80)
  VOID *MappedRegisterBase;                        // offset: 0x58 (88)
  VOID *PortConfiguration;                         // offset: 0x60 (96)
  UCHAR CrashDump;                                 // offset: 0x68 (104)
  UCHAR MarkMemoryOnly;                            // offset: 0x69 (105)
  UCHAR HiberResume;                               // offset: 0x6a (106)
  UCHAR Reserved1;                                 // offset: 0x6b (107)
  ULONG MaximumTransferSize;                       // offset: 0x6c (108)
  ULONG CommonBufferSize;                          // offset: 0x70 (112)
  VOID *TargetAddress;                             // offset: 0x78 (120)
  LONG (*WritePendingRoutine)
  (LONG arg1, union _LARGE_INTEGER *arg2, struct _MDL *arg3,
   VOID *arg4);         // offset: 0x80 (128)
  ULONG PartitionStyle; // offset: 0x88 (136)
  union {
    struct {
      ULONG Signature; // offset: 0x0 (0)
      ULONG CheckSum;  // offset: 0x4 (4)
    } Mbr;             // offset: 0x8c (140)
    struct {
      struct _GUID DiskId; // offset: 0x0 (0)
    } Gpt;                 // offset: 0x8c (140)

  } DiskInfo; // offset: 0x8c (140)
  LONG (*ReadRoutine)
  (LONG arg1, union _LARGE_INTEGER *arg2,
   struct _MDL *arg3); // offset: 0xa0 (160)
  LONG (*GetDriveTelemetryRoutine)
  (ULONG arg1, ULONG arg2, VOID *arg3, ULONG arg4); // offset: 0xa8 (168)
  ULONG LogSectionTruncateSize;                     // offset: 0xb0 (176)
  ULONG Parameters[16];                             // offset: 0xb4 (180)
  VOID (*GetTransferSizesRoutine)
  (ULONG *arg1, ULONG *arg2); // offset: 0xf8 (248)
  VOID (*DumpNotifyRoutine)
  (enum _DUMP_EVENTS arg1, VOID *arg2, ULONG arg3); // offset: 0x100 (256)
};

// 0x178 (376) bytes
struct _DUMP_STACK_CONTEXT {
  struct _DUMP_INITIALIZATION_CONTEXT Init; // offset: 0x0 (0)
  union _LARGE_INTEGER PartitionOffset;     // offset: 0x108 (264)
  union {
    VOID *DumpPointers; // offset: 0x110 (272)
    VOID *StorageInfo;  // offset: 0x110 (272)
  };
  UCHAR UseStorageInfo;                           // offset: 0x118 (280)
  ULONG PointersLength;                           // offset: 0x11c (284)
  WCHAR *ModulePrefix;                            // offset: 0x120 (288)
  struct _LIST_ENTRY DriverList;                  // offset: 0x128 (296)
  struct _STRING InitMsg;                         // offset: 0x138 (312)
  struct _STRING ProgMsg;                         // offset: 0x148 (328)
  struct _STRING DoneMsg;                         // offset: 0x158 (344)
  VOID *FileObject;                               // offset: 0x168 (360)
  enum _DEVICE_USAGE_NOTIFICATION_TYPE UsageType; // offset: 0x170 (368)
};

// 0x1c8 (456) bytes
struct _POP_HIBER_CONTEXT {
  UCHAR Reset;                               // offset: 0x0 (0)
  UCHAR HiberFlags;                          // offset: 0x1 (1)
  UCHAR WroteHiberFile;                      // offset: 0x2 (2)
  UCHAR KernelPhaseVerificationActive;       // offset: 0x3 (3)
  volatile UCHAR InitializationFinished;     // offset: 0x4 (4)
  volatile LONG NextTableLockHeld;           // offset: 0x8 (8)
  volatile LONG BootPhaseFinishedBarrier;    // offset: 0xc (12)
  volatile LONG KernelResumeFinishedBarrier; // offset: 0x10 (16)
  volatile LONG HvCaptureReadyBarrier;       // offset: 0x14 (20)
  volatile LONG HvCaptureCompletedBarrier;   // offset: 0x18 (24)
  UCHAR MapFrozen;                           // offset: 0x1c (28)
  union {
    struct _RTL_BITMAP DiscardMap;     // offset: 0x20 (32)
    struct _RTL_BITMAP KernelPhaseMap; // offset: 0x20 (32)
  };
  struct _RTL_BITMAP BootPhaseMap;                     // offset: 0x30 (48)
  struct _LIST_ENTRY ClonedRanges;                     // offset: 0x40 (64)
  ULONG ClonedRangeCount;                              // offset: 0x50 (80)
  ULONGLONG ClonedPageCount;                           // offset: 0x58 (88)
  struct _RTL_BITMAP *CurrentMap;                      // offset: 0x60 (96)
  struct _LIST_ENTRY *NextCloneRange;                  // offset: 0x68 (104)
  ULONGLONG NextPreserve;                              // offset: 0x70 (112)
  struct _MDL *LoaderMdl;                              // offset: 0x78 (120)
  struct _MDL *AllocatedMdl;                           // offset: 0x80 (128)
  ULONGLONG PagesOut;                                  // offset: 0x88 (136)
  VOID *IoPages;                                       // offset: 0x90 (144)
  ULONG IoPagesCount;                                  // offset: 0x98 (152)
  VOID *CurrentMcb;                                    // offset: 0xa0 (160)
  struct _DUMP_STACK_CONTEXT *DumpStack;               // offset: 0xa8 (168)
  struct _KPROCESSOR_STATE *WakeState;                 // offset: 0xb0 (176)
  ULONG IoProgress;                                    // offset: 0xb8 (184)
  LONG Status;                                         // offset: 0xbc (188)
  ULONG GraphicsProc;                                  // offset: 0xc0 (192)
  struct PO_MEMORY_IMAGE *MemoryImage;                 // offset: 0xc8 (200)
  ULONG *PerformanceStats;                             // offset: 0xd0 (208)
  struct _MDL *BootLoaderLogMdl;                       // offset: 0xd8 (216)
  struct _MDL *FirmwareRuntimeInformationMdl;          // offset: 0xe0 (224)
  VOID *FirmwareRuntimeInformationVa;                  // offset: 0xe8 (232)
  VOID *ResumeContext;                                 // offset: 0xf0 (240)
  ULONG ResumeContextPages;                            // offset: 0xf8 (248)
  ULONG SecurePages;                                   // offset: 0xfc (252)
  ULONG ProcessorCount;                                // offset: 0x100 (256)
  struct _POP_PER_PROCESSOR_CONTEXT *ProcessorContext; // offset: 0x108 (264)
  CHAR *ProdConsBuffer;                                // offset: 0x110 (272)
  ULONG ProdConsSize;                                  // offset: 0x118 (280)
  ULONG MaxDataPages;                                  // offset: 0x11c (284)
  VOID *ExtraBuffer;                                   // offset: 0x120 (288)
  ULONGLONG ExtraBufferSize;                           // offset: 0x128 (296)
  VOID *ExtraMapVa;                                    // offset: 0x130 (304)
  ULONGLONG BitlockerKeyPFN;                           // offset: 0x138 (312)
  struct _POP_IO_INFO IoInfo;                          // offset: 0x140 (320)
  WCHAR *IoChecksums;                                  // offset: 0x1b0 (432)
  ULONGLONG IoChecksumsSize;                           // offset: 0x1b8 (440)
  ULONG HardwareConfigurationSignature;                // offset: 0x1c0 (448)
  UCHAR IumEnabled;                                    // offset: 0x1c4 (452)
  UCHAR SecureBoot;                                    // offset: 0x1c5 (453)
};

// 0xa0 (160) bytes
struct _HALP_DMA_CHANNEL {
  ULONG ChannelNumber; // offset: 0x0 (0)
  UCHAR Initialized;   // offset: 0x4 (4)
  UCHAR Busy;          // offset: 0x5 (5)
  UCHAR Complete;      // offset: 0x6 (6)
  VOID (*CurrentCompletionRoutine)
  (struct _DMA_ADAPTER *arg1, struct _DEVICE_OBJECT *arg2, VOID *arg3,
   enum DMA_COMPLETION_STATUS arg4);               // offset: 0x8 (8)
  VOID *CurrentCompletionContext;                  // offset: 0x10 (16)
  struct _ADAPTER_OBJECT *CurrentChildAdapter;     // offset: 0x18 (24)
  enum _DMA_INTERRUPT_TYPE CurrentInterruptType;   // offset: 0x20 (32)
  struct _KDPC Dpc;                                // offset: 0x28 (40)
  UCHAR GeneratesInterrupt;                        // offset: 0x68 (104)
  LONG Gsi;                                        // offset: 0x6c (108)
  enum _KINTERRUPT_POLARITY InterruptPolarity;     // offset: 0x70 (112)
  enum _KINTERRUPT_MODE InterruptMode;             // offset: 0x74 (116)
  ULONG CommonBufferLength;                        // offset: 0x78 (120)
  VOID *CommonBufferVirtualAddress;                // offset: 0x80 (128)
  union _LARGE_INTEGER CommonBufferLogicalAddress; // offset: 0x88 (136)
  struct _LIST_ENTRY AdapterQueue;                 // offset: 0x90 (144)
};

// 0xe0 (224) bytes
struct _HALP_DMA_CONTROLLER {
  struct _LIST_ENTRY Controllers;              // offset: 0x0 (0)
  struct _LIST_ENTRY AdapterList;              // offset: 0x10 (16)
  ULONG ControllerId;                          // offset: 0x20 (32)
  ULONG MinimumRequestLine;                    // offset: 0x24 (36)
  ULONG MaximumRequestLine;                    // offset: 0x28 (40)
  ULONG ChannelCount;                          // offset: 0x2c (44)
  ULONG ScatterGatherLimit;                    // offset: 0x30 (48)
  struct _HALP_DMA_CHANNEL *Channels;          // offset: 0x38 (56)
  VOID *ExtensionData;                         // offset: 0x40 (64)
  UCHAR CacheCoherent;                         // offset: 0x48 (72)
  ULONG DmaAddressWidth;                       // offset: 0x4c (76)
  struct _DMA_FUNCTION_TABLE Operations;       // offset: 0x50 (80)
  ULONG SupportedPortWidths;                   // offset: 0xa0 (160)
  ULONG MinimumTransferUnit;                   // offset: 0xa4 (164)
  ULONGLONG Lock;                              // offset: 0xa8 (168)
  UCHAR Irql;                                  // offset: 0xb0 (176)
  UCHAR GeneratesInterrupt;                    // offset: 0xb1 (177)
  LONG Gsi;                                    // offset: 0xb4 (180)
  enum _KINTERRUPT_POLARITY InterruptPolarity; // offset: 0xb8 (184)
  enum _KINTERRUPT_MODE InterruptMode;         // offset: 0xbc (188)
  struct _UNICODE_STRING ResourceId;           // offset: 0xc0 (192)
  struct POHANDLE__ *PowerHandle;              // offset: 0xd0 (208)
  UCHAR PowerActive;                           // offset: 0xd8 (216)
};

// 0x88 (136) bytes
struct _HALP_DMA_DOMAIN_OBJECT {
  struct _LIST_ENTRY ListEntry;                     // offset: 0x0 (0)
  union _LARGE_INTEGER MaximumPhysicalAddress;      // offset: 0x10 (16)
  union _LARGE_INTEGER BoundaryAddressMultiple;     // offset: 0x18 (24)
  UCHAR CacheCoherent;                              // offset: 0x20 (32)
  UCHAR FirmwareReserved;                           // offset: 0x21 (33)
  VOID *IommuDomainPointer;                         // offset: 0x28 (40)
  VOID *LaState;                                    // offset: 0x30 (48)
  ULONGLONG LaStateLock;                            // offset: 0x38 (56)
  enum _EXT_IOMMU_TRANSLATION_TYPE TranslationType; // offset: 0x40 (64)
  struct _ADAPTER_OBJECT *OwningAdapter;            // offset: 0x48 (72)
  struct _RTL_RB_TREE CommonBufferRoot;             // offset: 0x50 (80)
  ULONGLONG CommonBufferTreeLock;                   // offset: 0x60 (96)
  struct _LIST_ENTRY VectorCommonBufferListHead;    // offset: 0x68 (104)
  ULONGLONG VectorCommonBufferLock;                 // offset: 0x78 (120)
  ULONG DomainRefCount;                             // offset: 0x80 (128)
};

// 0x10 (16) bytes
struct _POP_RW_LOCK {
  struct _EX_PUSH_LOCK Lock; // offset: 0x0 (0)
  struct _KTHREAD *Thread;   // offset: 0x8 (8)
};

// 0x420 (1056) bytes
struct _POP_THERMAL_ZONE {
  union {
    struct _POP_POLICY_DEVICE PolicyDevice; // offset: 0x0 (0)
    struct {
      struct _LIST_ENTRY Link;                  // offset: 0x0 (0)
      enum POWER_POLICY_DEVICE_TYPE DeviceType; // offset: 0x10 (16)
      VOID *Notification;                       // offset: 0x18 (24)
      struct _UNICODE_STRING Name;              // offset: 0x20 (32)
      struct _DEVICE_OBJECT *Device;            // offset: 0x30 (48)
      struct _IRP *Irp;                         // offset: 0x38 (56)
    };
  };
  UCHAR State;                                            // offset: 0x40 (64)
  UCHAR Flags;                                            // offset: 0x41 (65)
  UCHAR Removing;                                         // offset: 0x42 (66)
  UCHAR Mode;                                             // offset: 0x43 (67)
  UCHAR PendingMode;                                      // offset: 0x44 (68)
  UCHAR ActivePoint;                                      // offset: 0x45 (69)
  UCHAR PendingActivePoint;                               // offset: 0x46 (70)
  UCHAR Critical;                                         // offset: 0x47 (71)
  UCHAR ThermalStandby;                                   // offset: 0x48 (72)
  UCHAR OverThrottled;                                    // offset: 0x49 (73)
  LONG HighPrecisionThrottle;                             // offset: 0x4c (76)
  LONG Throttle;                                          // offset: 0x50 (80)
  LONG PendingThrottle;                                   // offset: 0x54 (84)
  ULONG ThrottleReasons;                                  // offset: 0x58 (88)
  ULONGLONG LastPassiveTime;                              // offset: 0x60 (96)
  ULONG SampleRate;                                       // offset: 0x68 (104)
  ULONG LastTemp;                                         // offset: 0x6c (108)
  struct _THERMAL_INFORMATION_EX Info;                    // offset: 0x70 (112)
  struct _THERMAL_POLICY Policy;                          // offset: 0xcc (204)
  UCHAR PolicyDriver;                                     // offset: 0xe4 (228)
  ULONG PollingRate;                                      // offset: 0xe8 (232)
  ULONGLONG LastTemperatureTime;                          // offset: 0xf0 (240)
  ULONGLONG LastActiveStartTime;                          // offset: 0xf8 (248)
  ULONGLONG LastPassiveStartTime;                         // offset: 0x100 (256)
  struct _WORK_QUEUE_ITEM WorkItem;                       // offset: 0x108 (264)
  struct _KTIMER2 ZoneUpdateTimer;                        // offset: 0x128 (296)
  struct _POP_RW_LOCK Lock;                               // offset: 0x1b0 (432)
  struct _KEVENT ZoneStopped;                             // offset: 0x1c0 (448)
  struct _KEVENT TemperatureUpdated;                      // offset: 0x1d8 (472)
  ULONG InstanceId;                                       // offset: 0x1f0 (496)
  struct _POP_THERMAL_TELEMETRY_TRACKER TelemetryTracker; // offset: 0x1f8 (504)
  struct _UNICODE_STRING Description; // offset: 0x410 (1040)
};

// 0x90 (144) bytes
struct _POP_COOLING_EXTENSION {
  struct _LIST_ENTRY Link;                     // offset: 0x0 (0)
  struct _LIST_ENTRY RequestListHead;          // offset: 0x10 (16)
  struct _POP_RW_LOCK Lock;                    // offset: 0x20 (32)
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x30 (48)
  VOID *NotificationEntry;                     // offset: 0x38 (56)
  UCHAR Enabled;                               // offset: 0x40 (64)
  UCHAR ActiveEngaged;                         // offset: 0x41 (65)
  UCHAR ThrottleLimit;                         // offset: 0x42 (66)
  UCHAR UpdatingToCurrent;                     // offset: 0x43 (67)
  struct _KEVENT *RemovalFlushEvent;           // offset: 0x48 (72)
  struct _KEVENT *PnpFlushEvent;               // offset: 0x50 (80)
  struct _THERMAL_COOLING_INTERFACE Interface; // offset: 0x58 (88)
};

// 0x60 (96) bytes
struct _DEVICE_OBJECT_POWER_EXTENSION {
  volatile ULONG IdleCount;                        // offset: 0x0 (0)
  volatile ULONG BusyCount;                        // offset: 0x4 (4)
  volatile ULONG BusyReference;                    // offset: 0x8 (8)
  ULONG TotalBusyCount;                            // offset: 0xc (12)
  ULONG ConservationIdleTime;                      // offset: 0x10 (16)
  ULONG PerformanceIdleTime;                       // offset: 0x14 (20)
  struct _DEVICE_OBJECT *DeviceObject;             // offset: 0x18 (24)
  struct _LIST_ENTRY IdleList;                     // offset: 0x20 (32)
  enum _POP_DEVICE_IDLE_TYPE IdleType;             // offset: 0x30 (48)
  enum _DEVICE_POWER_STATE IdleState;              // offset: 0x34 (52)
  enum _DEVICE_POWER_STATE CurrentState;           // offset: 0x38 (56)
  struct _POP_COOLING_EXTENSION *CoolingExtension; // offset: 0x40 (64)
  struct _LIST_ENTRY Volume;                       // offset: 0x48 (72)
  union {
    struct {
      ULONG IdleTime;    // offset: 0x0 (0)
      ULONG NonIdleTime; // offset: 0x4 (4)
    } Disk;              // offset: 0x58 (88)

  } Specific; // offset: 0x58 (88)
};

// 0x70 (112) bytes
struct _DEVOBJ_EXTENSION {
  SHORT Type;                                  // offset: 0x0 (0)
  USHORT Size;                                 // offset: 0x2 (2)
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x8 (8)
  ULONG PowerFlags;                            // offset: 0x10 (16)
  struct _DEVICE_OBJECT_POWER_EXTENSION *Dope; // offset: 0x18 (24)
  ULONG ExtensionFlags;                        // offset: 0x20 (32)
  VOID *DeviceNode;                            // offset: 0x28 (40)
  struct _DEVICE_OBJECT *AttachedTo;           // offset: 0x30 (48)
  LONG StartIoCount;                           // offset: 0x38 (56)
  LONG StartIoKey;                             // offset: 0x3c (60)
  ULONG StartIoFlags;                          // offset: 0x40 (64)
  struct _VPB *Vpb;                            // offset: 0x48 (72)
  VOID *DependencyNode;                        // offset: 0x50 (80)
  VOID *InterruptContext;                      // offset: 0x58 (88)
  LONG InterruptCount;                         // offset: 0x60 (96)
  VOID *VerifierContext;                       // offset: 0x68 (104)
};

// 0x158 (344) bytes
struct _OBJECT_DIRECTORY {
  struct _OBJECT_DIRECTORY_ENTRY *HashBuckets[37]; // offset: 0x0 (0)
  struct _EX_PUSH_LOCK Lock;                       // offset: 0x128 (296)
  struct _DEVICE_MAP *DeviceMap;                   // offset: 0x130 (304)
  struct _OBJECT_DIRECTORY *ShadowDirectory;       // offset: 0x138 (312)
  VOID *NamespaceEntry;                            // offset: 0x140 (320)
  VOID *SessionObject;                             // offset: 0x148 (328)
  ULONG Flags;                                     // offset: 0x150 (336)
  ULONG SessionId;                                 // offset: 0x154 (340)
};

// 0x38 (56) bytes
struct _ETW_HASH_BUCKET {
  struct _LIST_ENTRY ListHead[3];  // offset: 0x0 (0)
  struct _EX_PUSH_LOCK BucketLock; // offset: 0x30 (48)
};

// 0x20 (32) bytes
struct _OB_HANDLE_REVOCATION_BLOCK {
  struct _LIST_ENTRY RevocationInfos; // offset: 0x0 (0)
  struct _EX_PUSH_LOCK Lock;          // offset: 0x10 (16)
  struct _EX_RUNDOWN_REF Rundown;     // offset: 0x18 (24)
};

// 0x20 (32) bytes
struct _HANDLE_REVOCATION_INFO {
  struct _LIST_ENTRY ListEntry;                        // offset: 0x0 (0)
  struct _OB_HANDLE_REVOCATION_BLOCK *RevocationBlock; // offset: 0x10 (16)
  UCHAR AllowHandleRevocation;                         // offset: 0x18 (24)
  UCHAR Padding1[3];                                   // offset: 0x19 (25)
  UCHAR Padding2[4];                                   // offset: 0x1c (28)
};

// 0x30 (48) bytes
struct _OBJECT_FOOTER {
  struct _HANDLE_REVOCATION_INFO HandleRevocationInfo; // offset: 0x0 (0)
  struct _OB_EXTENDED_USER_INFO ExtendedUserInfo;      // offset: 0x20 (32)
};

// 0x10 (16) bytes
struct _OBJECT_HEADER_EXTENDED_INFO {
  struct _OBJECT_FOOTER *Footer; // offset: 0x0 (0)
  ULONGLONG Reserved;            // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _SEP_CACHED_HANDLES_TABLE {
  struct _EX_PUSH_LOCK Lock;                 // offset: 0x0 (0)
  struct _RTL_DYNAMIC_HASH_TABLE *HashTable; // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _ETW_PRIV_HANDLE_DEMUX_TABLE {
  struct _RTL_RB_TREE Tree;  // offset: 0x0 (0)
  struct _EX_PUSH_LOCK Lock; // offset: 0x10 (16)
  USHORT SequenceNumber;     // offset: 0x18 (24)
};

// 0x1a8 (424) bytes
struct _ETW_GUID_ENTRY {
  struct _LIST_ENTRY GuidList;     // offset: 0x0 (0)
  struct _LIST_ENTRY SiloGuidList; // offset: 0x10 (16)
  volatile LONGLONG RefCount;      // offset: 0x20 (32)
  struct _GUID Guid;               // offset: 0x28 (40)
  struct _LIST_ENTRY RegListHead;  // offset: 0x38 (56)
  VOID *SecurityDescriptor;        // offset: 0x48 (72)
  union {
    struct _ETW_LAST_ENABLE_INFO LastEnable; // offset: 0x50 (80)
    ULONGLONG MatchId;                       // offset: 0x50 (80)
  };
  struct _TRACE_ENABLE_INFO ProviderEnableInfo; // offset: 0x60 (96)
  struct _TRACE_ENABLE_INFO EnableInfo[8];      // offset: 0x80 (128)
  struct _ETW_FILTER_HEADER *FilterData;        // offset: 0x180 (384)
  struct _ETW_SILODRIVERSTATE *SiloState;       // offset: 0x188 (392)
  struct _ETW_GUID_ENTRY *HostEntry;            // offset: 0x190 (400)
  struct _EX_PUSH_LOCK Lock;                    // offset: 0x198 (408)
  struct _ETHREAD *LockOwner;                   // offset: 0x1a0 (416)
};

// 0xc0 (192) bytes
struct _SEP_LOGON_SESSION_REFERENCES {
  struct _SEP_LOGON_SESSION_REFERENCES *Next;          // offset: 0x0 (0)
  struct _LUID LogonId;                                // offset: 0x8 (8)
  struct _LUID BuddyLogonId;                           // offset: 0x10 (16)
  LONGLONG ReferenceCount;                             // offset: 0x18 (24)
  ULONG Flags;                                         // offset: 0x20 (32)
  struct _DEVICE_MAP *pDeviceMap;                      // offset: 0x28 (40)
  VOID *Token;                                         // offset: 0x30 (48)
  struct _UNICODE_STRING AccountName;                  // offset: 0x38 (56)
  struct _UNICODE_STRING AuthorityName;                // offset: 0x48 (72)
  struct _SEP_CACHED_HANDLES_TABLE CachedHandlesTable; // offset: 0x58 (88)
  struct _EX_PUSH_LOCK SharedDataLock;                 // offset: 0x68 (104)
  struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION
      *SharedClaimAttributes;                         // offset: 0x70 (112)
  struct _SEP_SID_VALUES_BLOCK *SharedSidValues;      // offset: 0x78 (120)
  struct _OB_HANDLE_REVOCATION_BLOCK RevocationBlock; // offset: 0x80 (128)
  struct _EJOB *ServerSilo;                           // offset: 0xa0 (160)
  struct _LUID SiblingAuthId;                         // offset: 0xa8 (168)
  struct _LIST_ENTRY TokenList;                       // offset: 0xb0 (176)
};

// 0x8 (8) bytes
struct _WNF_LOCK {
  struct _EX_PUSH_LOCK PushLock; // offset: 0x0 (0)
};

// 0x18 (24) bytes
struct _WNF_SCOPE_MAP_ENTRY {
  struct _WNF_LOCK MapEntryLock;   // offset: 0x0 (0)
  struct _LIST_ENTRY MapEntryHead; // offset: 0x8 (8)
};

// 0x50 (80) bytes
struct _WNF_SCOPE_INSTANCE {
  struct _WNF_NODE_HEADER Header;       // offset: 0x0 (0)
  struct _EX_RUNDOWN_REF RunRef;        // offset: 0x8 (8)
  enum _WNF_DATA_SCOPE DataScope;       // offset: 0x10 (16)
  ULONG InstanceIdSize;                 // offset: 0x14 (20)
  VOID *InstanceIdData;                 // offset: 0x18 (24)
  struct _LIST_ENTRY ResolverListEntry; // offset: 0x20 (32)
  struct _WNF_LOCK NameSetLock;         // offset: 0x30 (48)
  struct _RTL_AVL_TREE NameSet;         // offset: 0x38 (56)
  VOID *PermanentDataStore;             // offset: 0x40 (64)
  VOID *VolatilePermanentDataStore;     // offset: 0x48 (72)
};

// 0xb0 (176) bytes
struct _WNF_SCOPE_MAP {
  struct _WNF_NODE_HEADER Header;                           // offset: 0x0 (0)
  struct _WNF_SCOPE_INSTANCE *SystemScopeInstance;          // offset: 0x8 (8)
  struct _WNF_SCOPE_INSTANCE *MachineScopeInstance;         // offset: 0x10 (16)
  struct _WNF_SCOPE_INSTANCE *PhysicalMachineScopeInstance; // offset: 0x18 (24)
  struct _WNF_SCOPE_MAP_ENTRY ByDataScope[6];               // offset: 0x20 (32)
};

// 0x38 (56) bytes
struct _WNF_SILODRIVERSTATE {
  struct _WNF_SCOPE_MAP *ScopeMap;                   // offset: 0x0 (0)
  VOID *volatile PermanentNameStoreRootKey;          // offset: 0x8 (8)
  VOID *volatile PersistentNameStoreRootKey;         // offset: 0x10 (16)
  volatile LONGLONG PermanentNameSequenceNumber;     // offset: 0x18 (24)
  struct _WNF_LOCK PermanentNameSequenceNumberLock;  // offset: 0x20 (32)
  volatile LONGLONG PermanentNameSequenceNumberPool; // offset: 0x28 (40)
  volatile LONGLONG RuntimeNameSequenceNumber;       // offset: 0x30 (48)
};

// 0x260 (608) bytes
struct _OBJECT_NAMESPACE_LOOKUPTABLE {
  struct _LIST_ENTRY HashBuckets[37]; // offset: 0x0 (0)
  struct _EX_PUSH_LOCK Lock;          // offset: 0x250 (592)
  ULONG NumberOfPrivateSpaces;        // offset: 0x258 (600)
};

// 0x2e0 (736) bytes
struct _OBP_SILODRIVERSTATE {
  struct _DEVICE_MAP *SystemDeviceMap;                      // offset: 0x0 (0)
  struct _OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState; // offset: 0x8 (8)
  struct _EX_PUSH_LOCK DeviceMapLock; // offset: 0x78 (120)
  struct _OBJECT_NAMESPACE_LOOKUPTABLE
      PrivateNamespaceLookupTable; // offset: 0x80 (128)
};

// 0x40 (64) bytes
struct _HANDLE_TABLE_FREE_LIST {
  struct _EX_PUSH_LOCK FreeListLock;               // offset: 0x0 (0)
  union _HANDLE_TABLE_ENTRY *FirstFreeHandleEntry; // offset: 0x8 (8)
  union _HANDLE_TABLE_ENTRY *LastFreeHandleEntry;  // offset: 0x10 (16)
  LONG HandleCount;                                // offset: 0x18 (24)
  ULONG HighWaterMark;                             // offset: 0x1c (28)
};

// 0x60 (96) bytes
struct _MI_SYSTEM_PTE_TYPE {
  struct _RTL_BITMAP_EX Bitmap;   // offset: 0x0 (0)
  struct _MMPTE *BasePte;         // offset: 0x10 (16)
  ULONG Flags;                    // offset: 0x18 (24)
  enum _MI_SYSTEM_VA_TYPE VaType; // offset: 0x1c (28)
  ULONG *FailureCount;            // offset: 0x20 (32)
  ULONG PteFailures;              // offset: 0x28 (40)
  union {
    ULONGLONG SpinLock;                   // offset: 0x30 (48)
    struct _EX_PUSH_LOCK *GlobalPushLock; // offset: 0x30 (48)
  };
  volatile ULONGLONG TotalSystemPtes;     // offset: 0x38 (56)
  ULONGLONG Hint;                         // offset: 0x40 (64)
  ULONGLONG LowestBitEverAllocated;       // offset: 0x48 (72)
  struct _MI_CACHED_PTES *CachedPtes;     // offset: 0x50 (80)
  volatile ULONGLONG TotalFreeSystemPtes; // offset: 0x58 (88)
};

// 0x20 (32) bytes
struct _MMSESSION {
  struct _EX_PUSH_LOCK SystemSpaceViewLock;         // offset: 0x0 (0)
  struct _EX_PUSH_LOCK *SystemSpaceViewLockPointer; // offset: 0x8 (8)
  struct _RTL_AVL_TREE ViewRoot;                    // offset: 0x10 (16)
  ULONG ViewCount;                                  // offset: 0x18 (24)
  ULONG BitmapFailures;                             // offset: 0x1c (28)
};

// 0x18 (24) bytes
struct _MM_PAGED_POOL_INFO {
  struct _EX_PUSH_LOCK Lock;    // offset: 0x0 (0)
  ULONGLONG MaximumSize;        // offset: 0x8 (8)
  ULONGLONG AllocatedPagedPool; // offset: 0x10 (16)
};

// 0xcc0 (3264) bytes
struct _MI_VISIBLE_STATE {
  struct _LIST_ENTRY SessionWsList;                    // offset: 0x0 (0)
  struct _RTL_BITMAP *SessionIdBitmap;                 // offset: 0x10 (16)
  struct _MM_PAGED_POOL_INFO PagedPoolInfo;            // offset: 0x18 (24)
  ULONGLONG MaximumNonPagedPoolInPages;                // offset: 0x30 (48)
  ULONGLONG SizeOfPagedPoolInPages;                    // offset: 0x38 (56)
  struct _MI_SYSTEM_PTE_TYPE SystemPteInfo;            // offset: 0x40 (64)
  volatile ULONGLONG NonPagedPoolCommit;               // offset: 0xa0 (160)
  volatile ULONGLONG SmallNonPagedPtesCommit;          // offset: 0xa8 (168)
  volatile ULONGLONG BootCommit;                       // offset: 0xb0 (176)
  volatile ULONGLONG MdlPagesAllocated;                // offset: 0xb8 (184)
  volatile ULONGLONG SystemPageTableCommit;            // offset: 0xc0 (192)
  volatile ULONGLONG ProcessCommit;                    // offset: 0xc8 (200)
  volatile LONG DriverCommit;                          // offset: 0xd0 (208)
  UCHAR PagingLevels;                                  // offset: 0xd4 (212)
  volatile ULONGLONG PfnDatabaseCommit;                // offset: 0xd8 (216)
  struct _MMSUPPORT_FULL SystemWs[6];                  // offset: 0x100 (256)
  struct _MMSUPPORT_SHARED SystemCacheShared;          // offset: 0x880 (2176)
  struct _MMSUPPORT_AGGREGATION AggregateSystemWs[1];  // offset: 0x900 (2304)
  ULONG MapCacheFailures;                              // offset: 0x920 (2336)
  ULONGLONG PagefileHashPages;                         // offset: 0x928 (2344)
  struct _SYSPTES_HEADER PteHeader;                    // offset: 0x930 (2352)
  ULONGLONG SystemVaTypeCount[16];                     // offset: 0xa48 (2632)
  UCHAR SystemVaType[256];                             // offset: 0xac8 (2760)
  struct _MI_SYSTEM_VA_ASSIGNMENT SystemVaRegions[13]; // offset: 0xbc8 (3016)
};

// 0x5000 (20480) bytes
struct _MM_SESSION_SPACE {
  volatile LONG ReferenceCount; // offset: 0x0 (0)
  union {
    ULONG LongFlags;                      // offset: 0x4 (4)
    struct _MM_SESSION_SPACE_FLAGS Flags; // offset: 0x4 (4)

  } u;                                              // offset: 0x4 (4)
  ULONG SessionId;                                  // offset: 0x8 (8)
  volatile LONG ProcessReferenceToSession;          // offset: 0xc (12)
  struct _LIST_ENTRY ProcessList;                   // offset: 0x10 (16)
  ULONGLONG SessionPageDirectoryIndex;              // offset: 0x20 (32)
  volatile ULONGLONG NonPagablePages;               // offset: 0x28 (40)
  volatile ULONGLONG CommittedPages;                // offset: 0x30 (48)
  VOID *PagedPoolStart;                             // offset: 0x38 (56)
  VOID *PagedPoolEnd;                               // offset: 0x40 (64)
  VOID *SessionObject;                              // offset: 0x48 (72)
  VOID *SessionObjectHandle;                        // offset: 0x50 (80)
  struct _RTL_AVL_TREE ImageTree;                   // offset: 0x58 (88)
  ULONG LocaleId;                                   // offset: 0x60 (96)
  ULONG AttachCount;                                // offset: 0x64 (100)
  struct _KGATE AttachGate;                         // offset: 0x68 (104)
  struct _LIST_ENTRY WsListEntry;                   // offset: 0x80 (128)
  struct _RTL_BALANCED_NODE WsTreeEntry;            // offset: 0x90 (144)
  struct _MM_PAGED_POOL_INFO PagedPoolInfo;         // offset: 0xa8 (168)
  struct _MMSESSION Session;                        // offset: 0xc0 (192)
  ULONGLONG CombineDomain;                          // offset: 0xe0 (224)
  struct _MMSUPPORT_FULL Vm;                        // offset: 0x100 (256)
  struct _MMWSL_INSTANCE WorkingSetList;            // offset: 0x240 (576)
  struct _MMSUPPORT_AGGREGATION AggregateSessionWs; // offset: 0x280 (640)
  VOID *HeapState;                                  // offset: 0x2a0 (672)
  struct _MI_SESSION_DRIVER_UNLOAD DriverUnload;    // offset: 0x2a8 (680)
  ULONG TopLevelPteLockBits[32];                    // offset: 0x2b0 (688)
  struct _MMPTE PageDirectory;                      // offset: 0x330 (816)
  struct _EX_PUSH_LOCK SessionVaLock;               // offset: 0x338 (824)
  struct _RTL_BITMAP_EX DynamicVaBitMap;            // offset: 0x340 (832)
  ULONGLONG DynamicVaHint;                          // offset: 0x350 (848)
  struct _EX_PUSH_LOCK SessionPteLock;              // offset: 0x358 (856)
  LONG PoolBigEntriesInUse;                         // offset: 0x360 (864)
  volatile LONG PagedPoolPdeCount;                  // offset: 0x364 (868)
  ULONG DynamicSessionPdeCount;                     // offset: 0x368 (872)
  struct _MI_SYSTEM_PTE_TYPE SystemPteInfo;         // offset: 0x370 (880)
  VOID *PoolTrackTableExpansion;                    // offset: 0x3d0 (976)
  ULONGLONG PoolTrackTableExpansionSize;            // offset: 0x3d8 (984)
  VOID *PoolTrackBigPages;                          // offset: 0x3e0 (992)
  ULONGLONG PoolTrackBigPagesSize;                  // offset: 0x3e8 (1000)
  struct _RTL_AVL_TREE PermittedFaultsTree;         // offset: 0x3f0 (1008)
  enum _IO_SESSION_STATE IoState;                   // offset: 0x3f8 (1016)
  ULONG IoStateSequence;                            // offset: 0x3fc (1020)
  struct _KEVENT IoNotificationEvent;               // offset: 0x400 (1024)
  struct _EJOB *ServerSilo;                         // offset: 0x418 (1048)
  ULONGLONG CreateTime;                             // offset: 0x420 (1056)
  UCHAR PoolTags[16384];                            // offset: 0x1000 (4096)
};

// 0x10 (16) bytes
struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES {
  struct _RTL_AVL_TREE Tree; // offset: 0x0 (0)
  struct _EX_PUSH_LOCK Lock; // offset: 0x8 (8)
};

// 0x20 (32) bytes
struct _ALPC_PROCESS_CONTEXT {
  struct _EX_PUSH_LOCK Lock;              // offset: 0x0 (0)
  struct _LIST_ENTRY ViewListHead;        // offset: 0x8 (8)
  volatile ULONGLONG PagedPoolQuotaCache; // offset: 0x18 (24)
};

// 0x438 (1080) bytes
struct _KPROCESS {
  struct _DISPATCHER_HEADER Header;               // offset: 0x0 (0)
  struct _LIST_ENTRY ProfileListHead;             // offset: 0x18 (24)
  ULONGLONG DirectoryTableBase;                   // offset: 0x28 (40)
  struct _LIST_ENTRY ThreadListHead;              // offset: 0x30 (48)
  ULONG ProcessLock;                              // offset: 0x40 (64)
  ULONG ProcessTimerDelay;                        // offset: 0x44 (68)
  ULONGLONG DeepFreezeStartTime;                  // offset: 0x48 (72)
  struct _KAFFINITY_EX Affinity;                  // offset: 0x50 (80)
  ULONGLONG AffinityPadding[12];                  // offset: 0xf8 (248)
  struct _LIST_ENTRY ReadyListHead;               // offset: 0x158 (344)
  struct _SINGLE_LIST_ENTRY SwapListEntry;        // offset: 0x168 (360)
  volatile struct _KAFFINITY_EX ActiveProcessors; // offset: 0x170 (368)
  ULONGLONG ActiveProcessorsPadding[12];          // offset: 0x218 (536)
  union {
    struct {
      ULONG AutoAlignment : 1;         // offset: 0x278 (632)
      ULONG DisableBoost : 1;          // offset: 0x278 (632)
      ULONG DisableQuantum : 1;        // offset: 0x278 (632)
      ULONG DeepFreeze : 1;            // offset: 0x278 (632)
      ULONG TimerVirtualization : 1;   // offset: 0x278 (632)
      ULONG CheckStackExtents : 1;     // offset: 0x278 (632)
      ULONG CacheIsolationEnabled : 1; // offset: 0x278 (632)
      ULONG PpmPolicy : 3;             // offset: 0x278 (632)
      ULONG VaSpaceDeleted : 1;        // offset: 0x278 (632)
      ULONG ReservedFlags : 21;        // offset: 0x278 (632)
    };
    volatile LONG ProcessFlags; // offset: 0x278 (632)
  };
  ULONG ActiveGroupsMask;                     // offset: 0x27c (636)
  CHAR BasePriority;                          // offset: 0x280 (640)
  CHAR QuantumReset;                          // offset: 0x281 (641)
  CHAR Visited;                               // offset: 0x282 (642)
  union _KEXECUTE_OPTIONS Flags;              // offset: 0x283 (643)
  USHORT ThreadSeed[20];                      // offset: 0x284 (644)
  USHORT ThreadSeedPadding[12];               // offset: 0x2ac (684)
  USHORT IdealProcessor[20];                  // offset: 0x2c4 (708)
  USHORT IdealProcessorPadding[12];           // offset: 0x2ec (748)
  USHORT IdealNode[20];                       // offset: 0x304 (772)
  USHORT IdealNodePadding[12];                // offset: 0x32c (812)
  USHORT IdealGlobalNode;                     // offset: 0x344 (836)
  USHORT Spare1;                              // offset: 0x346 (838)
  union _KSTACK_COUNT volatile StackCount;    // offset: 0x348 (840)
  struct _LIST_ENTRY ProcessListEntry;        // offset: 0x350 (848)
  ULONGLONG CycleTime;                        // offset: 0x360 (864)
  ULONGLONG ContextSwitches;                  // offset: 0x368 (872)
  struct _KSCHEDULING_GROUP *SchedulingGroup; // offset: 0x370 (880)
  ULONG FreezeCount;                          // offset: 0x378 (888)
  ULONG KernelTime;                           // offset: 0x37c (892)
  ULONG UserTime;                             // offset: 0x380 (896)
  ULONG ReadyTime;                            // offset: 0x384 (900)
  ULONGLONG UserDirectoryTableBase;           // offset: 0x388 (904)
  UCHAR AddressPolicy;                        // offset: 0x390 (912)
  UCHAR Spare2[71];                           // offset: 0x391 (913)
  VOID *InstrumentationCallback;              // offset: 0x3d8 (984)
  union {
    ULONGLONG SecureHandle; // offset: 0x3e0 (992)
    struct {
      ULONGLONG SecureProcess : 1; // offset: 0x0 (0)
      ULONGLONG Unused : 1;        // offset: 0x0 (0)
    } Flags;                       // offset: 0x3e0 (992)

  } SecureState;            // offset: 0x3e0 (992)
  ULONGLONG KernelWaitTime; // offset: 0x3e8 (1000)
  ULONGLONG UserWaitTime;   // offset: 0x3f0 (1008)
  ULONGLONG EndPadding[8];  // offset: 0x3f8 (1016)
};

// 0xe0 (224) bytes
struct _FAST_IO_DISPATCH {
  ULONG SizeOfFastIoDispatch; // offset: 0x0 (0)
  UCHAR (*FastIoCheckIfPossible)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, ULONG arg3,
   UCHAR arg4, ULONG arg5, UCHAR arg6, struct _IO_STATUS_BLOCK *arg7,
   struct _DEVICE_OBJECT *arg8); // offset: 0x8 (8)
  UCHAR (*FastIoRead)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, ULONG arg3,
   UCHAR arg4, ULONG arg5, VOID *arg6, struct _IO_STATUS_BLOCK *arg7,
   struct _DEVICE_OBJECT *arg8); // offset: 0x10 (16)
  UCHAR (*FastIoWrite)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, ULONG arg3,
   UCHAR arg4, ULONG arg5, VOID *arg6, struct _IO_STATUS_BLOCK *arg7,
   struct _DEVICE_OBJECT *arg8); // offset: 0x18 (24)
  UCHAR (*FastIoQueryBasicInfo)
  (struct _FILE_OBJECT *arg1, UCHAR arg2, struct _FILE_BASIC_INFORMATION *arg3,
   struct _IO_STATUS_BLOCK *arg4,
   struct _DEVICE_OBJECT *arg5); // offset: 0x20 (32)
  UCHAR (*FastIoQueryStandardInfo)
  (struct _FILE_OBJECT *arg1, UCHAR arg2,
   struct _FILE_STANDARD_INFORMATION *arg3, struct _IO_STATUS_BLOCK *arg4,
   struct _DEVICE_OBJECT *arg5); // offset: 0x28 (40)
  UCHAR (*FastIoLock)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2,
   union _LARGE_INTEGER *arg3, struct _KPROCESS *arg4, ULONG arg5, UCHAR arg6,
   UCHAR arg7, struct _IO_STATUS_BLOCK *arg8,
   struct _DEVICE_OBJECT *arg9); // offset: 0x30 (48)
  UCHAR (*FastIoUnlockSingle)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2,
   union _LARGE_INTEGER *arg3, struct _KPROCESS *arg4, ULONG arg5,
   struct _IO_STATUS_BLOCK *arg6,
   struct _DEVICE_OBJECT *arg7); // offset: 0x38 (56)
  UCHAR (*FastIoUnlockAll)
  (struct _FILE_OBJECT *arg1, struct _KPROCESS *arg2,
   struct _IO_STATUS_BLOCK *arg3,
   struct _DEVICE_OBJECT *arg4); // offset: 0x40 (64)
  UCHAR (*FastIoUnlockAllByKey)
  (struct _FILE_OBJECT *arg1, VOID *arg2, ULONG arg3,
   struct _IO_STATUS_BLOCK *arg4,
   struct _DEVICE_OBJECT *arg5); // offset: 0x48 (72)
  UCHAR (*FastIoDeviceControl)
  (struct _FILE_OBJECT *arg1, UCHAR arg2, VOID *arg3, ULONG arg4, VOID *arg5,
   ULONG arg6, ULONG arg7, struct _IO_STATUS_BLOCK *arg8,
   struct _DEVICE_OBJECT *arg9); // offset: 0x50 (80)
  VOID (*AcquireFileForNtCreateSection)
  (struct _FILE_OBJECT *arg1); // offset: 0x58 (88)
  VOID (*ReleaseFileForNtCreateSection)
  (struct _FILE_OBJECT *arg1); // offset: 0x60 (96)
  VOID (*FastIoDetachDevice)
  (struct _DEVICE_OBJECT *arg1,
   struct _DEVICE_OBJECT *arg2); // offset: 0x68 (104)
  UCHAR (*FastIoQueryNetworkOpenInfo)
  (struct _FILE_OBJECT *arg1, UCHAR arg2,
   struct _FILE_NETWORK_OPEN_INFORMATION *arg3, struct _IO_STATUS_BLOCK *arg4,
   struct _DEVICE_OBJECT *arg5); // offset: 0x70 (112)
  LONG (*AcquireForModWrite)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2,
   struct _ERESOURCE **arg3, struct _DEVICE_OBJECT *arg4); // offset: 0x78 (120)
  UCHAR (*MdlRead)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, ULONG arg3,
   ULONG arg4, struct _MDL **arg5, struct _IO_STATUS_BLOCK *arg6,
   struct _DEVICE_OBJECT *arg7); // offset: 0x80 (128)
  UCHAR (*MdlReadComplete)
  (struct _FILE_OBJECT *arg1, struct _MDL *arg2,
   struct _DEVICE_OBJECT *arg3); // offset: 0x88 (136)
  UCHAR (*PrepareMdlWrite)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, ULONG arg3,
   ULONG arg4, struct _MDL **arg5, struct _IO_STATUS_BLOCK *arg6,
   struct _DEVICE_OBJECT *arg7); // offset: 0x90 (144)
  UCHAR (*MdlWriteComplete)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, struct _MDL *arg3,
   struct _DEVICE_OBJECT *arg4); // offset: 0x98 (152)
  UCHAR (*FastIoReadCompressed)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, ULONG arg3,
   ULONG arg4, VOID *arg5, struct _MDL **arg6, struct _IO_STATUS_BLOCK *arg7,
   struct _COMPRESSED_DATA_INFO *arg8, ULONG arg9,
   struct _DEVICE_OBJECT *arg10); // offset: 0xa0 (160)
  UCHAR (*FastIoWriteCompressed)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, ULONG arg3,
   ULONG arg4, VOID *arg5, struct _MDL **arg6, struct _IO_STATUS_BLOCK *arg7,
   struct _COMPRESSED_DATA_INFO *arg8, ULONG arg9,
   struct _DEVICE_OBJECT *arg10); // offset: 0xa8 (168)
  UCHAR (*MdlReadCompleteCompressed)
  (struct _FILE_OBJECT *arg1, struct _MDL *arg2,
   struct _DEVICE_OBJECT *arg3); // offset: 0xb0 (176)
  UCHAR (*MdlWriteCompleteCompressed)
  (struct _FILE_OBJECT *arg1, union _LARGE_INTEGER *arg2, struct _MDL *arg3,
   struct _DEVICE_OBJECT *arg4); // offset: 0xb8 (184)
  UCHAR (*FastIoQueryOpen)
  (struct _IRP *arg1, struct _FILE_NETWORK_OPEN_INFORMATION *arg2,
   struct _DEVICE_OBJECT *arg3); // offset: 0xc0 (192)
  LONG (*ReleaseForModWrite)
  (struct _FILE_OBJECT *arg1, struct _ERESOURCE *arg2,
   struct _DEVICE_OBJECT *arg3); // offset: 0xc8 (200)
  LONG (*AcquireForCcFlush)
  (struct _FILE_OBJECT *arg1,
   struct _DEVICE_OBJECT *arg2); // offset: 0xd0 (208)
  LONG (*ReleaseForCcFlush)
  (struct _FILE_OBJECT *arg1,
   struct _DEVICE_OBJECT *arg2); // offset: 0xd8 (216)
};

// 0x30 (48) bytes
struct _KAPC_STATE {
  struct _LIST_ENTRY ApcListHead[2]; // offset: 0x0 (0)
  struct _KPROCESS *Process;         // offset: 0x20 (32)
  union {
    UCHAR InProgressFlags; // offset: 0x28 (40)
    struct {
      UCHAR KernelApcInProgress : 1;  // offset: 0x28 (40)
      UCHAR SpecialApcInProgress : 1; // offset: 0x28 (40)
    };
  };
  UCHAR KernelApcPending; // offset: 0x29 (41)
  union {
    UCHAR UserApcPendingAll; // offset: 0x2a (42)
    struct {
      UCHAR SpecialUserApcPending : 1; // offset: 0x2a (42)
      UCHAR UserApcPending : 1;        // offset: 0x2a (42)
    };
  };
};

// 0x10 (16) bytes
union _SLIST_HEADER {
  struct {
    ULONGLONG Alignment; // offset: 0x0 (0)
    ULONGLONG Region;    // offset: 0x8 (8)
  };
  struct {
    ULONGLONG Depth : 16;     // offset: 0x0 (0)
    ULONGLONG Sequence : 48;  // offset: 0x0 (0)
    ULONGLONG Reserved : 4;   // offset: 0x8 (8)
    ULONGLONG NextEntry : 60; // offset: 0x8 (8)
  } HeaderX64;                // offset: 0x0 (0)
};

// 0x60 (96) bytes
struct _PF_KERNEL_GLOBALS {
  ULONGLONG AccessBufferAgeThreshold;     // offset: 0x0 (0)
  struct _EX_RUNDOWN_REF AccessBufferRef; // offset: 0x8 (8)
  struct _KEVENT AccessBufferExistsEvent; // offset: 0x10 (16)
  ULONG AccessBufferMax;                  // offset: 0x28 (40)
  union _SLIST_HEADER AccessBufferList;   // offset: 0x40 (64)
  LONG StreamSequenceNumber;              // offset: 0x50 (80)
  ULONG Flags;                            // offset: 0x54 (84)
  LONG ScenarioPrefetchCount;             // offset: 0x58 (88)
};

// 0x40 (64) bytes
struct _MI_ALIGNED_SLIST {
  union _SLIST_HEADER SList; // offset: 0x0 (0)
};

// 0x200 (512) bytes
struct _MI_ULTRA_MDL_NODE {
  struct _MI_ALIGNED_SLIST UltraMdlMaps[8]; // offset: 0x0 (0)
};

// 0x20 (32) bytes
struct _CACHED_KSTACK_LIST {
  union _SLIST_HEADER SListHead; // offset: 0x0 (0)
  LONG MinimumFree;              // offset: 0x10 (16)
  ULONG Misses;                  // offset: 0x14 (20)
  ULONG MissesLast;              // offset: 0x18 (24)
  ULONG AllStacksInUse;          // offset: 0x1c (28)
};

// 0xb0 (176) bytes
struct _MI_SYSTEM_NODE_INFORMATION {
  struct _CACHED_KSTACK_LIST CachedKernelStacks[2];    // offset: 0x0 (0)
  struct _MI_DYNAMIC_BITMAP DynamicBitMapNonPagedPool; // offset: 0x40 (64)
  ULONGLONG CachedNonPagedPoolCount;                   // offset: 0x88 (136)
  ULONGLONG NonPagedPoolSpinLock;                      // offset: 0x90 (144)
  struct _MMPFN *CachedNonPagedPool;                   // offset: 0x98 (152)
  VOID *NonPagedPoolFirstVa;                           // offset: 0xa0 (160)
  VOID *NonPagedPoolLastVa;                            // offset: 0xa8 (168)
};

// 0x1c0 (448) bytes
struct _MI_HARDWARE_STATE {
  ULONG NodeMask;                               // offset: 0x0 (0)
  ULONG NumaHintIndex;                          // offset: 0x4 (4)
  ULONG NumaLastRangeIndexInclusive;            // offset: 0x8 (8)
  UCHAR NodeShift;                              // offset: 0xc (12)
  UCHAR ChannelShift;                           // offset: 0xd (13)
  ULONG ChannelHintIndex;                       // offset: 0x10 (16)
  ULONG ChannelLastRangeIndexInclusive;         // offset: 0x14 (20)
  struct _MI_NODE_NUMBER_ZERO_BASED *NodeGraph; // offset: 0x18 (24)
  struct _MI_SYSTEM_NODE_INFORMATION
      *SystemNodeInformation;                             // offset: 0x20 (32)
  struct _HAL_NODE_RANGE TemporaryNumaRanges[2];          // offset: 0x28 (40)
  struct _HAL_NODE_RANGE *NumaMemoryRanges;               // offset: 0x48 (72)
  struct _HAL_CHANNEL_MEMORY_RANGES *ChannelMemoryRanges; // offset: 0x50 (80)
  ULONG SecondLevelCacheSize;                             // offset: 0x58 (88)
  ULONG FirstLevelCacheSize;                              // offset: 0x5c (92)
  ULONG PhysicalAddressBits;                              // offset: 0x60 (96)
  ULONG LogicalProcessorsPerCore;                         // offset: 0x64 (100)
  UCHAR ProcessorCachesFlushedOnPowerLoss;                // offset: 0x68 (104)
  ULONGLONG TotalPagesAllowed;                            // offset: 0x70 (112)
  ULONG SecondaryColorMask;                               // offset: 0x78 (120)
  ULONG SecondaryColors;                                  // offset: 0x7c (124)
  ULONG FlushTbForAttributeChange;                        // offset: 0x80 (128)
  ULONG FlushCacheForAttributeChange;                     // offset: 0x84 (132)
  ULONG FlushCacheForPageAttributeChange;                 // offset: 0x88 (136)
  ULONG CacheFlushPromoteThreshold;                       // offset: 0x8c (140)
  union _LARGE_INTEGER PerformanceCounterFrequency;       // offset: 0x90 (144)
  ULONGLONG InvalidPteMask;                               // offset: 0xc0 (192)
  ULONG LargePageColors[3];                               // offset: 0x100 (256)
  ULONGLONG FlushTbThreshold;                             // offset: 0x110 (272)
  enum _MI_PFN_CACHE_ATTRIBUTE
      OptimalZeroingAttribute[4][4];             // offset: 0x118 (280)
  UCHAR AttributeChangeRequiresReZero;           // offset: 0x158 (344)
  struct _MI_ZERO_COST_COUNTS ZeroCostCounts[2]; // offset: 0x160 (352)
  ULONGLONG VsmKernelPageCount;                  // offset: 0x180 (384)
};

// 0x130 (304) bytes
struct _VF_TARGET_VERIFIED_DRIVER_DATA {
  struct _VF_SUSPECT_DRIVER_ENTRY *SuspectDriverEntry; // offset: 0x0 (0)
  VOID *WMICallback;                                   // offset: 0x8 (8)
  struct _LIST_ENTRY EtwHandlesListHead;               // offset: 0x10 (16)
  union {
    struct {
      ULONG MissedEtwRegistration : 1; // offset: 0x0 (0)
      ULONG IsBootDriver : 1;          // offset: 0x0 (0)
      ULONG Spare : 30;                // offset: 0x0 (0)
    } Flags;                           // offset: 0x20 (32)
    ULONG Whole;                       // offset: 0x20 (32)

  } u1;                                          // offset: 0x20 (32)
  ULONGLONG Signature;                           // offset: 0x28 (40)
  UCHAR SeSigningLevel;                          // offset: 0x30 (48)
  union _SLIST_HEADER PoolPageHeaders;           // offset: 0x40 (64)
  union _SLIST_HEADER PoolTrackers;              // offset: 0x50 (80)
  VOID **DifPluginData;                          // offset: 0x60 (96)
  volatile ULONG CurrentPagedPoolAllocations;    // offset: 0x68 (104)
  volatile ULONG CurrentNonPagedPoolAllocations; // offset: 0x6c (108)
  ULONG PeakPagedPoolAllocations;                // offset: 0x70 (112)
  ULONG PeakNonPagedPoolAllocations;             // offset: 0x74 (116)
  volatile ULONGLONG PagedBytes;                 // offset: 0x78 (120)
  volatile ULONGLONG NonPagedBytes;              // offset: 0x80 (128)
  ULONGLONG PeakPagedBytes;                      // offset: 0x88 (136)
  ULONGLONG PeakNonPagedBytes;                   // offset: 0x90 (144)
  ULONG RaiseIrqls;                              // offset: 0x98 (152)
  ULONG AcquireSpinLocks;                        // offset: 0x9c (156)
  ULONG SynchronizeExecutions;                   // offset: 0xa0 (160)
  ULONG AllocationsWithNoTag;                    // offset: 0xa4 (164)
  ULONG AllocationsFailed;                       // offset: 0xa8 (168)
  ULONG AllocationsFailedDeliberately;           // offset: 0xac (172)
  ULONGLONG LockedBytes;                         // offset: 0xb0 (176)
  ULONGLONG PeakLockedBytes;                     // offset: 0xb8 (184)
  ULONGLONG MappedLockedBytes;                   // offset: 0xc0 (192)
  ULONGLONG PeakMappedLockedBytes;               // offset: 0xc8 (200)
  ULONGLONG MappedIoSpaceBytes;                  // offset: 0xd0 (208)
  ULONGLONG PeakMappedIoSpaceBytes;              // offset: 0xd8 (216)
  ULONGLONG PagesForMdlBytes;                    // offset: 0xe0 (224)
  ULONGLONG PeakPagesForMdlBytes;                // offset: 0xe8 (232)
  ULONGLONG ContiguousMemoryBytes;               // offset: 0xf0 (240)
  ULONGLONG PeakContiguousMemoryBytes;           // offset: 0xf8 (248)
  struct _LIST_ENTRY ContiguousMemoryListHead;   // offset: 0x100 (256)
  volatile ULONG ExecutePoolTypes;               // offset: 0x110 (272)
  volatile ULONG ExecutePageProtections;         // offset: 0x114 (276)
  volatile ULONG ExecutePageMappings;            // offset: 0x118 (280)
  volatile ULONG ExecuteWriteSections;           // offset: 0x11c (284)
  volatile ULONG SectionAlignmentFailures;       // offset: 0x120 (288)
  volatile ULONG IATInExecutableSection;         // offset: 0x124 (292)
};

// 0x40 (64) bytes
struct _VF_TARGET_DRIVER {
  struct _VF_AVL_TREE_NODE_EX TreeNode; // offset: 0x0 (0)
  union {
    struct _VF_TARGET_ALL_SHARED_EXPORT_THUNKS
        AllSharedExportThunks; // offset: 0x18 (24)
    struct {
      ULONG SnapSharedExportsFailed : 1; // offset: 0x0 (0)
      ULONG Spare : 31;                  // offset: 0x0 (0)
    } Flags;                             // offset: 0x18 (24)

  } u1;                                                 // offset: 0x18 (24)
  struct _VF_TARGET_VERIFIED_DRIVER_DATA *VerifiedData; // offset: 0x38 (56)
};

// 0x40 (64) bytes
struct _RTL_LOOKASIDE {
  union _SLIST_HEADER ListHead; // offset: 0x0 (0)
  USHORT Depth;                 // offset: 0x10 (16)
  USHORT MaximumDepth;          // offset: 0x12 (18)
  ULONG TotalAllocates;         // offset: 0x14 (20)
  ULONG AllocateMisses;         // offset: 0x18 (24)
  ULONG TotalFrees;             // offset: 0x1c (28)
  ULONG FreeMisses;             // offset: 0x20 (32)
  ULONG LastTotalAllocates;     // offset: 0x24 (36)
  ULONG LastAllocateMisses;     // offset: 0x28 (40)
  ULONG LastTotalFrees;         // offset: 0x2c (44)
};

// 0x1040 (4160) bytes
struct _RTL_DYNAMIC_LOOKASIDE {
  ULONGLONG EnabledBucketBitmap;     // offset: 0x0 (0)
  ULONG BucketCount;                 // offset: 0x8 (8)
  ULONG ActiveBucketCount;           // offset: 0xc (12)
  struct _RTL_LOOKASIDE Buckets[64]; // offset: 0x40 (64)
};

// 0x10 (16) bytes
struct _HEAP_VS_DELAY_FREE_CONTEXT {
  union _SLIST_HEADER ListHead; // offset: 0x0 (0)
};

// 0xc0 (192) bytes
struct _HEAP_VS_CONTEXT {
  ULONGLONG Lock;                                      // offset: 0x0 (0)
  enum _RTLP_HP_LOCK_TYPE LockType;                    // offset: 0x8 (8)
  struct _RTL_RB_TREE FreeChunkTree;                   // offset: 0x10 (16)
  struct _LIST_ENTRY SubsegmentList;                   // offset: 0x20 (32)
  ULONGLONG TotalCommittedUnits;                       // offset: 0x30 (48)
  ULONGLONG FreeCommittedUnits;                        // offset: 0x38 (56)
  struct _HEAP_VS_DELAY_FREE_CONTEXT DelayFreeContext; // offset: 0x40 (64)
  VOID *BackendCtx;                                    // offset: 0x80 (128)
  struct _HEAP_SUBALLOCATOR_CALLBACKS Callbacks;       // offset: 0x88 (136)
  struct _RTL_HP_VS_CONFIG Config;                     // offset: 0xb0 (176)
  ULONG Flags;                                         // offset: 0xb4 (180)
};

// 0x800 (2048) bytes
struct _SEGMENT_HEAP {
  struct RTL_HP_ENV_HANDLE EnvHandle; // offset: 0x0 (0)
  ULONG Signature;                    // offset: 0x10 (16)
  ULONG GlobalFlags;                  // offset: 0x14 (20)
  ULONG Interceptor;                  // offset: 0x18 (24)
  USHORT ProcessHeapListIndex;        // offset: 0x1c (28)
  USHORT AllocatedFromMetadata : 1;   // offset: 0x1e (30)
  union {
    struct _RTL_HEAP_MEMORY_LIMIT_DATA CommitLimitData; // offset: 0x20 (32)
    struct {
      ULONGLONG ReservedMustBeZero1; // offset: 0x20 (32)
      VOID *UserContext;             // offset: 0x28 (40)
      ULONGLONG ReservedMustBeZero2; // offset: 0x30 (48)
      VOID *Spare;                   // offset: 0x38 (56)
    };
  };
  ULONGLONG LargeMetadataLock;                // offset: 0x40 (64)
  struct _RTL_RB_TREE LargeAllocMetadata;     // offset: 0x48 (72)
  volatile ULONGLONG LargeReservedPages;      // offset: 0x58 (88)
  volatile ULONGLONG LargeCommittedPages;     // offset: 0x60 (96)
  union _RTL_RUN_ONCE StackTraceInitVar;      // offset: 0x68 (104)
  struct _HEAP_RUNTIME_MEMORY_STATS MemStats; // offset: 0x80 (128)
  USHORT GlobalLockCount;                     // offset: 0xd8 (216)
  ULONG GlobalLockOwner;                      // offset: 0xdc (220)
  ULONGLONG ContextExtendLock;                // offset: 0xe0 (224)
  UCHAR *AllocatedBase;                       // offset: 0xe8 (232)
  UCHAR *UncommittedBase;                     // offset: 0xf0 (240)
  UCHAR *ReservedLimit;                       // offset: 0xf8 (248)
  struct _HEAP_SEG_CONTEXT SegContexts[2];    // offset: 0x100 (256)
  struct _HEAP_VS_CONTEXT VsContext;          // offset: 0x280 (640)
  struct _HEAP_LFH_CONTEXT LfhContext;        // offset: 0x340 (832)
};

// 0x20c0 (8384) bytes
struct _EX_HEAP_POOL_NODE {
  struct _SEGMENT_HEAP *Heaps[4];              // offset: 0x0 (0)
  struct _RTL_DYNAMIC_LOOKASIDE Lookasides[2]; // offset: 0x40 (64)
};

// 0x10 (16) bytes
struct _RTLP_HP_METADATA_HEAP_CTX {
  struct _SEGMENT_HEAP *Heap;   // offset: 0x0 (0)
  union _RTL_RUN_ONCE InitOnce; // offset: 0x8 (8)
};

// 0x38d0 (14544) bytes
struct _RTLP_HP_HEAP_MANAGER {
  struct _RTLP_HP_HEAP_GLOBALS *Globals;              // offset: 0x0 (0)
  struct _RTLP_HP_ALLOC_TRACKER AllocTracker;         // offset: 0x8 (8)
  struct _HEAP_VAMGR_CTX VaMgr;                       // offset: 0x58 (88)
  struct _RTLP_HP_METADATA_HEAP_CTX MetadataHeaps[3]; // offset: 0x3898 (14488)
  struct _RTL_HP_SUB_ALLOCATOR_CONFIGS
      SubAllocConfigs; // offset: 0x38c8 (14536)
};

// 0x86940 (551232) bytes
struct _EX_POOL_HEAP_MANAGER_STATE {
  struct _RTLP_HP_HEAP_MANAGER HeapManager; // offset: 0x0 (0)
  ULONG NumberOfPools;                      // offset: 0x38d0 (14544)
  struct _EX_HEAP_POOL_NODE PoolNode[64];   // offset: 0x3900 (14592)
  struct _SEGMENT_HEAP *SpecialHeaps[4];    // offset: 0x86900 (551168)
};

// 0x38f0 (14576) bytes
struct _EX_HEAP_SESSION_STATE {
  struct _RTLP_HP_HEAP_MANAGER HeapManager; // offset: 0x0 (0)
  struct RTL_HP_ENV_HANDLE PagedEnv;        // offset: 0x38d0 (14544)
  struct _SEGMENT_HEAP *PagedHeap;          // offset: 0x38e0 (14560)
  struct _SEGMENT_HEAP *SpecialPoolHeap;    // offset: 0x38e8 (14568)
};

// 0xfc0 (4032) bytes
struct _MI_PARTITION_PAGE_LISTS {
  struct _MMPFNLIST *FreePagesByColor[2];                // offset: 0x0 (0)
  struct _MMPFNLIST ZeroedPageListHead;                  // offset: 0x40 (64)
  struct _MMPFNLIST FreePageListHead;                    // offset: 0x80 (128)
  struct _MMPFNLIST StandbyPageListHead;                 // offset: 0xc0 (192)
  struct _MMPFNLIST StandbyPageListByPriority[8];        // offset: 0x100 (256)
  struct _MMPFNLIST ModifiedPageListNoReservation;       // offset: 0x240 (576)
  struct _MMPFNLIST ModifiedPageListByReservation[16];   // offset: 0x280 (640)
  struct _MMPFNLIST MappedPageListHead[16];              // offset: 0x500 (1280)
  struct _MMPFNLIST BadPageListHead;                     // offset: 0x780 (1920)
  struct _MMPFNLIST EnclavePageListHead;                 // offset: 0x7c0 (1984)
  union _SLIST_HEADER *FreePageSlist[2];                 // offset: 0x7e8 (2024)
  struct _MMPFNLIST *PageLocationList[8];                // offset: 0x7f8 (2040)
  volatile ULONG StandbyRepurposedByPriority[8];         // offset: 0x838 (2104)
  volatile ULONGLONG TransitionSharedPages;              // offset: 0x880 (2176)
  ULONGLONG TransitionSharedPagesPeak[6];                // offset: 0x888 (2184)
  struct _KEVENT MappedPageListHeadEvent[16];            // offset: 0x8b8 (2232)
  struct _MI_DECAY_TIMER_LINK DecayClusterTimerHeads[4]; // offset: 0xa38 (2616)
  ULONG DecayHand;                                       // offset: 0xa58 (2648)
  UCHAR StandbyListDiscard;                              // offset: 0xa5c (2652)
  UCHAR FreeListDiscard;                                 // offset: 0xa5d (2653)
  UCHAR PfnBitMapsReady;                                 // offset: 0xa5e (2654)
  ULONGLONG LastDecayHandUpdateTime;                     // offset: 0xa60 (2656)
  struct _MI_LDW_WORK_CONTEXT LastChanceLdwContext;      // offset: 0xa68 (2664)
  struct _RTL_AVL_TREE HugePfnBadPages;                  // offset: 0xaa0 (2720)
  ULONGLONG AvailableEventsLock;                         // offset: 0xac0 (2752)
  struct _MI_AVAILABLE_PAGE_WAIT_STATES
      AvailablePageWaitStates[3];                       // offset: 0xac8 (2760)
  VOID *MirrorListLocks;                                // offset: 0xb28 (2856)
  volatile ULONGLONG TransitionPrivatePages;            // offset: 0xb40 (2880)
  struct _RTL_BITMAP_EX LargePfnBitMap[2];              // offset: 0xb48 (2888)
  struct _MI_FREE_LARGE_PAGE_LIST *LargePageListHeads;  // offset: 0xb68 (2920)
  UCHAR *MediumPagesOnFreeZeroList;                     // offset: 0xb70 (2928)
  struct _RTL_BITMAP_EX LargePageRebuildCandidates;     // offset: 0xb78 (2936)
  WCHAR *LargePagesOnFreeZeroList;                      // offset: 0xb88 (2952)
  volatile LONG HugePageRebuildCandidatesExist;         // offset: 0xb90 (2960)
  struct _KEVENT LargePageCandidatesExistEvent;         // offset: 0xb98 (2968)
  ULONGLONG LowMemoryThreshold;                         // offset: 0xbb0 (2992)
  ULONGLONG HighMemoryThreshold;                        // offset: 0xbb8 (3000)
  struct _MI_SLAB_ALLOCATOR_CONTEXT SlabContexts[2][4]; // offset: 0xbc0 (3008)
  struct _RTL_BITMAP_EX SlabPfnBitMap;                  // offset: 0xf80 (3968)
  VOID *HugePfnLists;                                   // offset: 0xf90 (3984)
  ULONGLONG AvailableHugeIoRanges;                      // offset: 0xf98 (3992)
};

// 0x80 (128) bytes
struct _ETW_STACK_TRACE_BLOCK {
  union _LARGE_INTEGER RelatedTimestamp; // offset: 0x0 (0)
  struct _ETHREAD *Thread;               // offset: 0x8 (8)
  struct _KDPC StackWalkDpc;             // offset: 0x10 (16)
  union _SLIST_HEADER ApcListHead;       // offset: 0x50 (80)
  struct _ETW_APC_ENTRY *ApcEntry;       // offset: 0x60 (96)
  ULONG ApcEntryCount;                   // offset: 0x68 (104)
  LONG Flags;                            // offset: 0x6c (108)
  LONG ApcCount;                         // offset: 0x70 (112)
  LONG MaxApcCount;                      // offset: 0x74 (116)
};

// 0x80 (128) bytes
struct _GENERAL_LOOKASIDE {
  union {
    union _SLIST_HEADER ListHead;             // offset: 0x0 (0)
    struct _SINGLE_LIST_ENTRY SingleListHead; // offset: 0x0 (0)
  };
  USHORT Depth;         // offset: 0x10 (16)
  USHORT MaximumDepth;  // offset: 0x12 (18)
  ULONG TotalAllocates; // offset: 0x14 (20)
  union {
    ULONG AllocateMisses; // offset: 0x18 (24)
    ULONG AllocateHits;   // offset: 0x18 (24)
  };
  ULONG TotalFrees; // offset: 0x1c (28)
  union {
    ULONG FreeMisses; // offset: 0x20 (32)
    ULONG FreeHits;   // offset: 0x20 (32)
  };
  enum _POOL_TYPE Type; // offset: 0x24 (36)
  ULONG Tag;            // offset: 0x28 (40)
  ULONG Size;           // offset: 0x2c (44)
  union {
    VOID *(*AllocateEx)(enum _POOL_TYPE arg1, ULONGLONG arg2, ULONG arg3,
                        struct _LOOKASIDE_LIST_EX *arg4); // offset: 0x30 (48)
    VOID *(*Allocate)(enum _POOL_TYPE arg1, ULONGLONG arg2,
                      ULONG arg3); // offset: 0x30 (48)
  };
  union {
    VOID (*FreeEx)
    (VOID *arg1, struct _LOOKASIDE_LIST_EX *arg2); // offset: 0x38 (56)
    VOID (*Free)(VOID *arg1);                      // offset: 0x38 (56)
  };
  struct _LIST_ENTRY ListEntry; // offset: 0x40 (64)
  ULONG LastTotalAllocates;     // offset: 0x50 (80)
  union {
    ULONG LastAllocateMisses; // offset: 0x54 (84)
    ULONG LastAllocateHits;   // offset: 0x54 (84)
  };
  ULONG Future[2]; // offset: 0x58 (88)
};

// 0x10 (16) bytes
struct _PP_LOOKASIDE_LIST {
  struct _GENERAL_LOOKASIDE *P; // offset: 0x0 (0)
  struct _GENERAL_LOOKASIDE *L; // offset: 0x8 (8)
};

// 0x80 (128) bytes
struct _PAGED_LOOKASIDE_LIST {
  struct _GENERAL_LOOKASIDE L; // offset: 0x0 (0)
};

// 0x80 (128) bytes
struct _NPAGED_LOOKASIDE_LIST {
  struct _GENERAL_LOOKASIDE L; // offset: 0x0 (0)
};

// 0x200 (512) bytes
struct _MI_SYSTEM_PTE_STATE {
  struct _NPAGED_LOOKASIDE_LIST MdlTrackerLookaside; // offset: 0x0 (0)
  union _SLIST_HEADER DeadPteTrackerSListHead;       // offset: 0x80 (128)
  ULONGLONG PteTrackerLock;                          // offset: 0x90 (144)
  struct _RTL_BITMAP_EX PteTrackingBitmap;           // offset: 0x98 (152)
  struct _MI_CACHED_PTES *CachedPteHeads;            // offset: 0xa8 (168)
  struct _MI_CACHED_PTES *CachedKernelStackPteHeads; // offset: 0xb0 (176)
  struct _MI_SYSTEM_PTE_TYPE SystemViewPteInfo;      // offset: 0xb8 (184)
  struct _MI_SYSTEM_PTE_TYPE KernelStackPteInfo;     // offset: 0x118 (280)
  ULONG StackGrowthFailures;                         // offset: 0x178 (376)
  UCHAR KernelStackPages;                            // offset: 0x17c (380)
  UCHAR TrackPtesAborted;                            // offset: 0x17d (381)
  UCHAR AdjustCounter;                               // offset: 0x17e (382)
  volatile LONG ReservedMappingLock;                 // offset: 0x180 (384)
  struct _RTL_AVL_TREE ReservedMappingTree;          // offset: 0x188 (392)
  struct _MMPFN *ReservedMappingPageTablePfns;       // offset: 0x190 (400)
  struct _RTL_AVL_TREE OutswappedKernelStackRoot;    // offset: 0x198 (408)
  volatile LONG OutswappedKernelStackLock;           // offset: 0x1a0 (416)
  struct _MMPTE *BreakMakePte;                       // offset: 0x1a8 (424)
  struct _MI_ULTRA_VA_CONTEXT UltraSpaceContext;     // offset: 0x1b0 (432)
  ULONG NumberOfUltraMdlMaps;                        // offset: 0x1f0 (496)
  struct _MI_ULTRA_MDL_NODE *UltraMdlNodeMappings;   // offset: 0x1f8 (504)
};

// 0x60 (96) bytes
struct _GENERAL_LOOKASIDE_POOL {
  union {
    union _SLIST_HEADER ListHead;             // offset: 0x0 (0)
    struct _SINGLE_LIST_ENTRY SingleListHead; // offset: 0x0 (0)
  };
  USHORT Depth;         // offset: 0x10 (16)
  USHORT MaximumDepth;  // offset: 0x12 (18)
  ULONG TotalAllocates; // offset: 0x14 (20)
  union {
    ULONG AllocateMisses; // offset: 0x18 (24)
    ULONG AllocateHits;   // offset: 0x18 (24)
  };
  ULONG TotalFrees; // offset: 0x1c (28)
  union {
    ULONG FreeMisses; // offset: 0x20 (32)
    ULONG FreeHits;   // offset: 0x20 (32)
  };
  enum _POOL_TYPE Type; // offset: 0x24 (36)
  ULONG Tag;            // offset: 0x28 (40)
  ULONG Size;           // offset: 0x2c (44)
  union {
    VOID *(*AllocateEx)(enum _POOL_TYPE arg1, ULONGLONG arg2, ULONG arg3,
                        struct _LOOKASIDE_LIST_EX *arg4); // offset: 0x30 (48)
    VOID *(*Allocate)(enum _POOL_TYPE arg1, ULONGLONG arg2,
                      ULONG arg3); // offset: 0x30 (48)
  };
  union {
    VOID (*FreeEx)
    (VOID *arg1, struct _LOOKASIDE_LIST_EX *arg2); // offset: 0x38 (56)
    VOID (*Free)(VOID *arg1);                      // offset: 0x38 (56)
  };
  struct _LIST_ENTRY ListEntry; // offset: 0x40 (64)
  ULONG LastTotalAllocates;     // offset: 0x50 (80)
  union {
    ULONG LastAllocateMisses; // offset: 0x54 (84)
    ULONG LastAllocateHits;   // offset: 0x54 (84)
  };
  ULONG Future[2]; // offset: 0x58 (88)
};

// 0x60 (96) bytes
struct _LOOKASIDE_LIST_EX {
  struct _GENERAL_LOOKASIDE_POOL L; // offset: 0x0 (0)
};

// 0x480 (1152) bytes
struct _PEB32 {
  UCHAR InheritedAddressSpace;    // offset: 0x0 (0)
  UCHAR ReadImageFileExecOptions; // offset: 0x1 (1)
  UCHAR BeingDebugged;            // offset: 0x2 (2)
  union {
    UCHAR BitField; // offset: 0x3 (3)
    struct {
      UCHAR ImageUsesLargePages : 1;          // offset: 0x3 (3)
      UCHAR IsProtectedProcess : 1;           // offset: 0x3 (3)
      UCHAR IsImageDynamicallyRelocated : 1;  // offset: 0x3 (3)
      UCHAR SkipPatchingUser32Forwarders : 1; // offset: 0x3 (3)
      UCHAR IsPackagedProcess : 1;            // offset: 0x3 (3)
      UCHAR IsAppContainer : 1;               // offset: 0x3 (3)
      UCHAR IsProtectedProcessLight : 1;      // offset: 0x3 (3)
      UCHAR IsLongPathAwareProcess : 1;       // offset: 0x3 (3)
    };
  };
  ULONG Mutant;            // offset: 0x4 (4)
  ULONG ImageBaseAddress;  // offset: 0x8 (8)
  ULONG Ldr;               // offset: 0xc (12)
  ULONG ProcessParameters; // offset: 0x10 (16)
  ULONG SubSystemData;     // offset: 0x14 (20)
  ULONG ProcessHeap;       // offset: 0x18 (24)
  ULONG FastPebLock;       // offset: 0x1c (28)
  ULONG AtlThunkSListPtr;  // offset: 0x20 (32)
  ULONG IFEOKey;           // offset: 0x24 (36)
  union {
    ULONG CrossProcessFlags; // offset: 0x28 (40)
    struct {
      ULONG ProcessInJob : 1;               // offset: 0x28 (40)
      ULONG ProcessInitializing : 1;        // offset: 0x28 (40)
      ULONG ProcessUsingVEH : 1;            // offset: 0x28 (40)
      ULONG ProcessUsingVCH : 1;            // offset: 0x28 (40)
      ULONG ProcessUsingFTH : 1;            // offset: 0x28 (40)
      ULONG ProcessPreviouslyThrottled : 1; // offset: 0x28 (40)
      ULONG ProcessCurrentlyThrottled : 1;  // offset: 0x28 (40)
      ULONG ProcessImagesHotPatched : 1;    // offset: 0x28 (40)
      ULONG ReservedBits0 : 24;             // offset: 0x28 (40)
    };
  };
  union {
    ULONG KernelCallbackTable; // offset: 0x2c (44)
    ULONG UserSharedInfoPtr;   // offset: 0x2c (44)
  };
  ULONG SystemReserved;                        // offset: 0x30 (48)
  ULONG AtlThunkSListPtr32;                    // offset: 0x34 (52)
  ULONG ApiSetMap;                             // offset: 0x38 (56)
  ULONG TlsExpansionCounter;                   // offset: 0x3c (60)
  ULONG TlsBitmap;                             // offset: 0x40 (64)
  ULONG TlsBitmapBits[2];                      // offset: 0x44 (68)
  ULONG ReadOnlySharedMemoryBase;              // offset: 0x4c (76)
  ULONG SharedData;                            // offset: 0x50 (80)
  ULONG ReadOnlyStaticServerData;              // offset: 0x54 (84)
  ULONG AnsiCodePageData;                      // offset: 0x58 (88)
  ULONG OemCodePageData;                       // offset: 0x5c (92)
  ULONG UnicodeCaseTableData;                  // offset: 0x60 (96)
  ULONG NumberOfProcessors;                    // offset: 0x64 (100)
  ULONG NtGlobalFlag;                          // offset: 0x68 (104)
  union _LARGE_INTEGER CriticalSectionTimeout; // offset: 0x70 (112)
  ULONG HeapSegmentReserve;                    // offset: 0x78 (120)
  ULONG HeapSegmentCommit;                     // offset: 0x7c (124)
  ULONG HeapDeCommitTotalFreeThreshold;        // offset: 0x80 (128)
  ULONG HeapDeCommitFreeBlockThreshold;        // offset: 0x84 (132)
  ULONG NumberOfHeaps;                         // offset: 0x88 (136)
  ULONG MaximumNumberOfHeaps;                  // offset: 0x8c (140)
  ULONG ProcessHeaps;                          // offset: 0x90 (144)
  ULONG GdiSharedHandleTable;                  // offset: 0x94 (148)
  ULONG ProcessStarterHelper;                  // offset: 0x98 (152)
  ULONG GdiDCAttributeList;                    // offset: 0x9c (156)
  ULONG LoaderLock;                            // offset: 0xa0 (160)
  ULONG OSMajorVersion;                        // offset: 0xa4 (164)
  ULONG OSMinorVersion;                        // offset: 0xa8 (168)
  USHORT OSBuildNumber;                        // offset: 0xac (172)
  USHORT OSCSDVersion;                         // offset: 0xae (174)
  ULONG OSPlatformId;                          // offset: 0xb0 (176)
  ULONG ImageSubsystem;                        // offset: 0xb4 (180)
  ULONG ImageSubsystemMajorVersion;            // offset: 0xb8 (184)
  ULONG ImageSubsystemMinorVersion;            // offset: 0xbc (188)
  ULONG ActiveProcessAffinityMask;             // offset: 0xc0 (192)
  ULONG GdiHandleBuffer[34];                   // offset: 0xc4 (196)
  ULONG PostProcessInitRoutine;                // offset: 0x14c (332)
  ULONG TlsExpansionBitmap;                    // offset: 0x150 (336)
  ULONG TlsExpansionBitmapBits[32];            // offset: 0x154 (340)
  ULONG SessionId;                             // offset: 0x1d4 (468)
  union _ULARGE_INTEGER AppCompatFlags;        // offset: 0x1d8 (472)
  union _ULARGE_INTEGER AppCompatFlagsUser;    // offset: 0x1e0 (480)
  ULONG pShimData;                             // offset: 0x1e8 (488)
  ULONG AppCompatInfo;                         // offset: 0x1ec (492)
  struct _STRING32 CSDVersion;                 // offset: 0x1f0 (496)
  ULONG ActivationContextData;                 // offset: 0x1f8 (504)
  ULONG ProcessAssemblyStorageMap;             // offset: 0x1fc (508)
  ULONG SystemDefaultActivationContextData;    // offset: 0x200 (512)
  ULONG SystemAssemblyStorageMap;              // offset: 0x204 (516)
  ULONG MinimumStackCommit;                    // offset: 0x208 (520)
  ULONG SparePointers[4];                      // offset: 0x20c (524)
  ULONG SpareUlongs[5];                        // offset: 0x21c (540)
  ULONG WerRegistrationData;                   // offset: 0x230 (560)
  ULONG WerShipAssertPtr;                      // offset: 0x234 (564)
  ULONG pUnused;                               // offset: 0x238 (568)
  ULONG pImageHeaderHash;                      // offset: 0x23c (572)
  union {
    ULONG TracingFlags; // offset: 0x240 (576)
    struct {
      ULONG HeapTracingEnabled : 1;      // offset: 0x240 (576)
      ULONG CritSecTracingEnabled : 1;   // offset: 0x240 (576)
      ULONG LibLoaderTracingEnabled : 1; // offset: 0x240 (576)
      ULONG SpareTracingBits : 29;       // offset: 0x240 (576)
    };
  };
  ULONGLONG CsrServerReadOnlySharedMemoryBase;  // offset: 0x248 (584)
  ULONG TppWorkerpListLock;                     // offset: 0x250 (592)
  struct LIST_ENTRY32 TppWorkerpList;           // offset: 0x254 (596)
  ULONG WaitOnAddressHashTable[128];            // offset: 0x25c (604)
  ULONG TelemetryCoverageHeader;                // offset: 0x45c (1116)
  ULONG CloudFileFlags;                         // offset: 0x460 (1120)
  ULONG CloudFileDiagFlags;                     // offset: 0x464 (1124)
  CHAR PlaceholderCompatibilityMode;            // offset: 0x468 (1128)
  CHAR PlaceholderCompatibilityModeReserved[7]; // offset: 0x469 (1129)
  ULONG LeapSecondData;                         // offset: 0x470 (1136)
  union {
    ULONG LeapSecondFlags; // offset: 0x474 (1140)
    struct {
      ULONG SixtySecondEnabled : 1; // offset: 0x474 (1140)
      ULONG Reserved : 31;          // offset: 0x474 (1140)
    };
  };
  ULONG NtGlobalFlag2; // offset: 0x478 (1144)
};

// 0x20 (32) bytes
struct _KTIMER_TABLE_ENTRY {
  ULONGLONG Lock;             // offset: 0x0 (0)
  struct _LIST_ENTRY Entry;   // offset: 0x8 (8)
  union _ULARGE_INTEGER Time; // offset: 0x18 (24)
};

// 0x40 (64) bytes
struct _KTIMER {
  struct _DISPATCHER_HEADER Header;  // offset: 0x0 (0)
  union _ULARGE_INTEGER DueTime;     // offset: 0x18 (24)
  struct _LIST_ENTRY TimerListEntry; // offset: 0x20 (32)
  struct _KDPC *Dpc;                 // offset: 0x30 (48)
  USHORT Processor;                  // offset: 0x38 (56)
  USHORT TimerType;                  // offset: 0x3a (58)
  ULONG Period;                      // offset: 0x3c (60)
};

// 0x118 (280) bytes
struct _EX_WORK_QUEUE_MANAGER {
  struct _EX_PARTITION *Partition; // offset: 0x0 (0)
  struct _ENODE *Node;             // offset: 0x8 (8)
  struct _KEVENT Event;            // offset: 0x10 (16)
  struct _KTIMER DeadlockTimer;    // offset: 0x28 (40)
  struct _KEVENT ReaperEvent;      // offset: 0x68 (104)
  struct _KTIMER2 ReaperTimer;     // offset: 0x80 (128)
  VOID *ThreadHandle;              // offset: 0x108 (264)
  volatile ULONG ExitThread;       // offset: 0x110 (272)
  USHORT ThreadSeed;               // offset: 0x114 (276)
};

// 0x20 (32) bytes
struct _EX_PARTITION {
  struct _EPARTITION *PartitionObject;               // offset: 0x0 (0)
  struct _EX_WORK_QUEUE **volatile *WorkQueues;      // offset: 0x8 (8)
  struct _EX_WORK_QUEUE_MANAGER **WorkQueueManagers; // offset: 0x10 (16)
  volatile LONG QueueAllocationMask;                 // offset: 0x18 (24)
};

// 0x88 (136) bytes
struct _LAZY_WRITER {
  struct _KDPC ScanDpc;             // offset: 0x0 (0)
  struct _KTIMER ScanTimer;         // offset: 0x40 (64)
  UCHAR ScanActive;                 // offset: 0x80 (128)
  UCHAR OtherWork;                  // offset: 0x81 (129)
  UCHAR PendingTeardownScan;        // offset: 0x82 (130)
  UCHAR PendingPeriodicScan;        // offset: 0x83 (131)
  UCHAR PendingLowMemoryScan;       // offset: 0x84 (132)
  UCHAR PendingPowerScan;           // offset: 0x85 (133)
  UCHAR PendingCoalescingFlushScan; // offset: 0x86 (134)
};

// 0x440 (1088) bytes
struct _CC_PARTITION {
  SHORT NodeTypeCode;                                      // offset: 0x0 (0)
  SHORT NodeByteSize;                                      // offset: 0x2 (2)
  struct _EPARTITION *PartitionObject;                     // offset: 0x8 (8)
  struct _LIST_ENTRY CleanSharedCacheMapList;              // offset: 0x10 (16)
  struct _LIST_ENTRY CleanSharedCacheMapWithLogHandleList; // offset: 0x20 (32)
  struct _SHARED_CACHE_MAP_LIST_CURSOR
      DirtySharedCacheMapList;                             // offset: 0x30 (48)
  struct _SHARED_CACHE_MAP_LIST_CURSOR LazyWriteCursor;    // offset: 0x48 (72)
  struct _LIST_ENTRY DirtySharedCacheMapWithLogHandleList; // offset: 0x60 (96)
  ULONGLONG PrivateLock;                                   // offset: 0x80 (128)
  ULONG ConsecutiveWorklessLazyScanCount;                  // offset: 0x88 (136)
  UCHAR ForcedDisableLazywriteScan;                        // offset: 0x8c (140)
  ULONGLONG WorkQueueLock;                                 // offset: 0xc0 (192)
  ULONG NumberWorkerThreads;                               // offset: 0xc8 (200)
  ULONG NumberActiveWorkerThreads;                         // offset: 0xcc (204)
  struct _LIST_ENTRY IdleWorkerThreadList;                 // offset: 0xd0 (208)
  struct _LIST_ENTRY FastTeardownWorkQueue;                // offset: 0xe0 (224)
  struct _LIST_ENTRY ExpressWorkQueue;                     // offset: 0xf0 (240)
  struct _LIST_ENTRY RegularWorkQueue;                 // offset: 0x100 (256)
  struct _LIST_ENTRY PostTickWorkQueue;                // offset: 0x110 (272)
  struct _LIST_ENTRY CleanCachemapUninitWorkQueue;     // offset: 0x120 (288)
  struct _LIST_ENTRY IdleExtraWriteBehindThreadList;   // offset: 0x130 (304)
  ULONG ActiveExtraWriteBehindThreads;                 // offset: 0x140 (320)
  ULONG MaxExtraWriteBehindThreads;                    // offset: 0x144 (324)
  struct _LIST_ENTRY IdleCacheMapUninitThreadList;     // offset: 0x148 (328)
  ULONG ActiveCacheMapUninitThreads;                   // offset: 0x158 (344)
  ULONG MaxCacheMapUninitThreads;                      // offset: 0x15c (348)
  UCHAR QueueThrottle;                                 // offset: 0x160 (352)
  ULONG PostTickWorkItemCount;                         // offset: 0x164 (356)
  ULONG ThreadsActiveBeforeThrottle;                   // offset: 0x168 (360)
  ULONG ExtraWBThreadsActiveBeforeThrottle;            // offset: 0x16c (364)
  ULONG ExecutingWriteBehindWorkItems;                 // offset: 0x170 (368)
  ULONG ExecutingHighPriorityWorkItem;                 // offset: 0x174 (372)
  struct _KEVENT LowMemoryEvent;                       // offset: 0x178 (376)
  struct _KEVENT PowerEvent;                           // offset: 0x190 (400)
  struct _KEVENT PeriodicEvent;                        // offset: 0x1a8 (424)
  struct _KEVENT WaitingForTeardownEvent;              // offset: 0x1c0 (448)
  struct _KEVENT CoalescingFlushEvent;                 // offset: 0x1d8 (472)
  ULONG PagesYetToWrite;                               // offset: 0x1f0 (496)
  struct _LAZY_WRITER LazyWriter;                      // offset: 0x1f8 (504)
  struct _DIRTY_PAGE_STATISTICS DirtyPageStatistics;   // offset: 0x280 (640)
  struct _DIRTY_PAGE_THRESHOLDS DirtyPageThresholds;   // offset: 0x298 (664)
  struct _WRITE_BEHIND_THROUGHPUT *ThroughputStats;    // offset: 0x2d0 (720)
  LONG ThroughputTrend;                                // offset: 0x2d8 (728)
  ULONGLONG AverageAvailablePages;                     // offset: 0x2e0 (736)
  ULONGLONG AverageDirtyPages;                         // offset: 0x2e8 (744)
  ULONGLONG PagesSkippedDueToHotSpot;                  // offset: 0x2f0 (752)
  union _LARGE_INTEGER PrevRegularQueueItemRunTime;    // offset: 0x2f8 (760)
  union _LARGE_INTEGER PrevExtraWBThreadCheckTime;     // offset: 0x300 (768)
  UCHAR AddExtraWriteBehindThreads;                    // offset: 0x308 (776)
  UCHAR RemoveExtraThreadPending;                      // offset: 0x309 (777)
  struct _LIST_ENTRY DeferredWrites;                   // offset: 0x310 (784)
  ULONGLONG DeferredWriteSpinLock;                     // offset: 0x340 (832)
  struct _LIST_ENTRY *IdleAsyncReadWorkerThreadList;   // offset: 0x348 (840)
  ULONG *NumberActiveAsyncReadWorkerThreads;           // offset: 0x350 (848)
  ULONG *NumberActiveCompleteAsyncReadWorkItems;       // offset: 0x358 (856)
  struct _LIST_ENTRY *AsyncReadWorkQueue;              // offset: 0x360 (864)
  struct _LIST_ENTRY *AsyncReadCompletionWorkQueue;    // offset: 0x368 (872)
  struct _KEVENT *NewAsyncReadRequestEvent;            // offset: 0x370 (880)
  struct _ASYNC_READ_THREAD_STATS *ReaderThreadsStats; // offset: 0x378 (888)
  struct _EX_PUSH_LOCK AsyncReadWorkQueueLock;         // offset: 0x380 (896)
  struct _LIST_ENTRY VacbFreeHighPriorityList;         // offset: 0x388 (904)
  ULONG NumberOfFreeHighPriorityVacbs;                 // offset: 0x398 (920)
  struct _ETHREAD *LowPriWorkerThread;                 // offset: 0x3a0 (928)
  struct _SHARED_CACHE_MAP *LowPriSharedCacheMap;      // offset: 0x3a8 (936)
  LONG LowPriOldCpuPriority;                           // offset: 0x3b0 (944)
  enum _IO_PRIORITY_HINT LowPriOldIoPriority;          // offset: 0x3b4 (948)
  struct _EX_PUSH_LOCK LowPriorityWorkerThreadLock;    // offset: 0x3b8 (952)
  ULONG MaxNumberOfWriteBehindThreads;                 // offset: 0x3c0 (960)
  UCHAR CoalescingState;                               // offset: 0x3c4 (964)
  UCHAR ActivePartition;                               // offset: 0x3c5 (965)
  UCHAR RundownPhase;                                  // offset: 0x3c6 (966)
  LONGLONG RefCount;                                   // offset: 0x3c8 (968)
  struct _KEVENT ExitEvent;                            // offset: 0x3d0 (976)
  struct _KEVENT FinalDereferenceEvent;                // offset: 0x3e8 (1000)
  VOID *LazyWriteScanThreadHandle;                     // offset: 0x400 (1024)
};

// 0x60 (96) bytes
struct _DEFERRED_WRITE {
  SHORT NodeTypeCode;                          // offset: 0x0 (0)
  SHORT NodeByteSize;                          // offset: 0x2 (2)
  struct _FILE_OBJECT *FileObject;             // offset: 0x8 (8)
  ULONG BytesToWrite;                          // offset: 0x10 (16)
  struct _LIST_ENTRY DeferredWriteLinks;       // offset: 0x18 (24)
  struct _KEVENT *Event;                       // offset: 0x28 (40)
  VOID (*PostRoutine)(VOID *arg1, VOID *arg2); // offset: 0x30 (48)
  VOID *Context1;                              // offset: 0x38 (56)
  VOID *Context2;                              // offset: 0x40 (64)
  struct _CC_PARTITION *Partition;             // offset: 0x48 (72)
  UCHAR SoftThrottle;                          // offset: 0x50 (80)
  union _LARGE_INTEGER TimeAdded;              // offset: 0x58 (88)
};

// 0x228 (552) bytes
struct _SHARED_CACHE_MAP {
  SHORT NodeTypeCode;                         // offset: 0x0 (0)
  SHORT NodeByteSize;                         // offset: 0x2 (2)
  ULONG OpenCount;                            // offset: 0x4 (4)
  union _LARGE_INTEGER FileSize;              // offset: 0x8 (8)
  struct _LIST_ENTRY BcbList;                 // offset: 0x10 (16)
  union _LARGE_INTEGER SectionSize;           // offset: 0x20 (32)
  union _LARGE_INTEGER ValidDataLength;       // offset: 0x28 (40)
  union _LARGE_INTEGER ValidDataGoal;         // offset: 0x30 (48)
  struct _VACB *InitialVacbs[4];              // offset: 0x38 (56)
  struct _VACB **Vacbs;                       // offset: 0x58 (88)
  struct _EX_FAST_REF FileObjectFastRef;      // offset: 0x60 (96)
  struct _EX_PUSH_LOCK VacbLock;              // offset: 0x68 (104)
  ULONG DirtyPages;                           // offset: 0x70 (112)
  struct _LIST_ENTRY LoggedStreamLinks;       // offset: 0x78 (120)
  struct _LIST_ENTRY SharedCacheMapLinks;     // offset: 0x88 (136)
  ULONG Flags;                                // offset: 0x98 (152)
  LONG Status;                                // offset: 0x9c (156)
  struct _MBCB *Mbcb;                         // offset: 0xa0 (160)
  VOID *Section;                              // offset: 0xa8 (168)
  struct _KEVENT *CreateEvent;                // offset: 0xb0 (176)
  struct _KEVENT *WaitOnActiveCount;          // offset: 0xb8 (184)
  ULONG PagesToWrite;                         // offset: 0xc0 (192)
  LONGLONG BeyondLastFlush;                   // offset: 0xc8 (200)
  struct _CACHE_MANAGER_CALLBACKS *Callbacks; // offset: 0xd0 (208)
  VOID *LazyWriteContext;                     // offset: 0xd8 (216)
  struct _LIST_ENTRY PrivateList;             // offset: 0xe0 (224)
  union {
    struct _LOGGED_STREAM_CALLBACK_V1 V1; // offset: 0xf0 (240)
    struct _LOGGED_STREAM_CALLBACK_V2 V2; // offset: 0xf0 (240)
  };
  union _LARGE_INTEGER LargestLSN;                     // offset: 0x100 (256)
  ULONG DirtyPageThreshold;                            // offset: 0x108 (264)
  ULONG LazyWritePassCount;                            // offset: 0x10c (268)
  struct _CACHE_UNINITIALIZE_EVENT *UninitializeEvent; // offset: 0x110 (272)
  struct _FAST_MUTEX BcbLock;                          // offset: 0x118 (280)
  union _LARGE_INTEGER LastUnmapBehindOffset;          // offset: 0x150 (336)
  struct _KEVENT Event;                                // offset: 0x158 (344)
  union _LARGE_INTEGER HighWaterMappingOffset;         // offset: 0x170 (368)
  struct _PRIVATE_CACHE_MAP PrivateCacheMap;           // offset: 0x178 (376)
  VOID *WriteBehindWorkQueueEntry;                     // offset: 0x1f0 (496)
  struct _VOLUME_CACHE_MAP *VolumeCacheMap;            // offset: 0x1f8 (504)
  ULONG ProcImagePathHash;                             // offset: 0x200 (512)
  ULONG WritesInProgress;                              // offset: 0x204 (516)
  ULONG AsyncReadRequestCount;                         // offset: 0x208 (520)
  struct _CC_PARTITION *Partition;                     // offset: 0x210 (528)
  ULONG InternalRefCount;                              // offset: 0x218 (536)
  ULONG NumMappedVacb;                                 // offset: 0x21c (540)
  ULONG NumActiveVacb;                                 // offset: 0x220 (544)
};

// 0x2d8 (728) bytes
struct _KTRANSACTION {
  struct _KEVENT OutcomeEvent;                          // offset: 0x0 (0)
  ULONG cookie;                                         // offset: 0x18 (24)
  struct _KMUTANT Mutex;                                // offset: 0x20 (32)
  struct _KTRANSACTION *TreeTx;                         // offset: 0x58 (88)
  struct _KTMOBJECT_NAMESPACE_LINK GlobalNamespaceLink; // offset: 0x60 (96)
  struct _KTMOBJECT_NAMESPACE_LINK TmNamespaceLink;     // offset: 0x88 (136)
  struct _GUID UOW;                                     // offset: 0xb0 (176)
  enum _KTRANSACTION_STATE State;                       // offset: 0xc0 (192)
  ULONG Flags;                                          // offset: 0xc4 (196)
  struct _LIST_ENTRY EnlistmentHead;                    // offset: 0xc8 (200)
  ULONG EnlistmentCount;                                // offset: 0xd8 (216)
  ULONG RecoverableEnlistmentCount;                     // offset: 0xdc (220)
  ULONG PrePrepareRequiredEnlistmentCount;              // offset: 0xe0 (224)
  ULONG PrepareRequiredEnlistmentCount;                 // offset: 0xe4 (228)
  ULONG OutcomeRequiredEnlistmentCount;                 // offset: 0xe8 (232)
  ULONG PendingResponses;                               // offset: 0xec (236)
  struct _KENLISTMENT *SuperiorEnlistment;              // offset: 0xf0 (240)
  union _CLS_LSN LastLsn;                               // offset: 0xf8 (248)
  struct _LIST_ENTRY PromotedEntry;                     // offset: 0x100 (256)
  struct _KTRANSACTION *PromoterTransaction;            // offset: 0x110 (272)
  VOID *PromotePropagation;                             // offset: 0x118 (280)
  ULONG IsolationLevel;                                 // offset: 0x120 (288)
  ULONG IsolationFlags;                                 // offset: 0x124 (292)
  union _LARGE_INTEGER Timeout;                         // offset: 0x128 (296)
  struct _UNICODE_STRING Description;                   // offset: 0x130 (304)
  struct _KTHREAD *RollbackThread;                      // offset: 0x140 (320)
  struct _WORK_QUEUE_ITEM RollbackWorkItem;             // offset: 0x148 (328)
  struct _KDPC RollbackDpc;                             // offset: 0x168 (360)
  struct _KTIMER RollbackTimer;                         // offset: 0x1a8 (424)
  struct _LIST_ENTRY LsnOrderedEntry;                   // offset: 0x1e8 (488)
  enum _KTRANSACTION_OUTCOME Outcome;                   // offset: 0x1f8 (504)
  struct _KTM *Tm;                                      // offset: 0x200 (512)
  LONGLONG CommitReservation;                           // offset: 0x208 (520)
  struct _KTRANSACTION_HISTORY TransactionHistory[10];  // offset: 0x210 (528)
  ULONG TransactionHistoryCount;                        // offset: 0x260 (608)
  VOID *DTCPrivateInformation;                          // offset: 0x268 (616)
  ULONG DTCPrivateInformationLength;                    // offset: 0x270 (624)
  struct _KMUTANT DTCPrivateInformationMutex;           // offset: 0x278 (632)
  VOID *PromotedTxSelfHandle;                           // offset: 0x2b0 (688)
  ULONG PendingPromotionCount;                          // offset: 0x2b8 (696)
  struct _KEVENT PromotionCompletedEvent;               // offset: 0x2c0 (704)
};

// 0x340 (832) bytes
struct _MI_PARTITION_SEGMENTS {
  volatile LONG SegmentListLock;                      // offset: 0x0 (0)
  ULONG DeleteOnCloseCount;                           // offset: 0x4 (4)
  volatile LONGLONG FsControlAreaCount;               // offset: 0x8 (8)
  volatile LONGLONG PfControlAreaCount;               // offset: 0x10 (16)
  volatile LONGLONG CloneHeaderCount;                 // offset: 0x18 (24)
  struct _KEVENT DeleteSubsectionCleanup;             // offset: 0x20 (32)
  struct _KEVENT UnusedSegmentCleanup;                // offset: 0x38 (56)
  ULONGLONG SubsectionDeletePtes;                     // offset: 0x50 (80)
  struct _MMPAGE_FILE_EXPANSION AttemptForCantExtend; // offset: 0x58 (88)
  struct _MMDEREFERENCE_SEGMENT_HEADER
      DereferenceSegmentHeader;                        // offset: 0xb0 (176)
  struct _LIST_ENTRY DeleteOnCloseList;                // offset: 0x100 (256)
  struct _KTIMER DeleteOnCloseTimer;                   // offset: 0x110 (272)
  UCHAR DeleteOnCloseTimerActive;                      // offset: 0x150 (336)
  UCHAR SegmentDereferenceThreadExists;                // offset: 0x151 (337)
  VOID *SegmentDereferenceActiveControlArea;           // offset: 0x158 (344)
  ULONGLONG UnusedSegmentPagedPool;                    // offset: 0x160 (352)
  struct _LIST_ENTRY UnusedSegmentList;                // offset: 0x168 (360)
  struct _LIST_ENTRY UnusedSubsectionList;             // offset: 0x178 (376)
  struct _LIST_ENTRY DeleteSubsectionList;             // offset: 0x188 (392)
  struct _KEVENT ControlAreaDeleteEvent;               // offset: 0x198 (408)
  struct _SINGLE_LIST_ENTRY ControlAreaDeleteList;     // offset: 0x1b0 (432)
  struct _MI_PTE_CHAIN_HEAD FreeSystemCache;           // offset: 0x1b8 (440)
  struct _KEVENT CloneDereferenceEvent;                // offset: 0x1d0 (464)
  union _SLIST_HEADER CloneProtosSListHead;            // offset: 0x1f0 (496)
  struct _EX_PUSH_LOCK SystemCacheInitLock;            // offset: 0x200 (512)
  ULONG PagefileExtensionWaiters;                      // offset: 0x208 (520)
  ULONG PagefileExtensionRequests;                     // offset: 0x20c (524)
  struct _KEVENT PagefileExtensionWaitEvent;           // offset: 0x210 (528)
  struct _MI_CROSS_PARTITION_CHARGES SharedCharges[7]; // offset: 0x228 (552)
  struct _KEVENT *SharedChargesDrainEvent;             // offset: 0x308 (776)
  struct _KEVENT *ControlAreasDrainEvent;              // offset: 0x310 (784)
  struct _KEVENT *CloneHeaderDrainEvent;               // offset: 0x318 (792)
  struct _EX_RUNDOWN_REF_CACHE_AWARE
      *ProbeRundownReference; // offset: 0x320 (800)
};

// 0xb0 (176) bytes
struct _POP_FX_WORK_ORDER_WATCHDOG_INFO {
  struct _LIST_ENTRY Link;                       // offset: 0x0 (0)
  struct _KTIMER Timer;                          // offset: 0x10 (16)
  struct _KDPC Dpc;                              // offset: 0x50 (80)
  struct _POP_FX_WORK_ORDER *WorkOrder;          // offset: 0x90 (144)
  struct _PEP_WORK_INFORMATION *CurrentWorkInfo; // offset: 0x98 (152)
  ULONGLONG WatchdogStart;                       // offset: 0xa0 (160)
  struct _KTHREAD *WorkerThread;                 // offset: 0xa8 (168)
};

// 0x4218 (16920) bytes
struct _KTIMER_TABLE {
  struct _KTIMER *TimerExpiry[64];                 // offset: 0x0 (0)
  struct _KTIMER_TABLE_ENTRY TimerEntries[2][256]; // offset: 0x200 (512)
  struct _KTIMER_TABLE_STATE TableState;           // offset: 0x4200 (16896)
};

// 0xa0 (160) bytes
struct _TIMEZONE_CHANGE_EVENT {
  struct _KDPC Dpc;                 // offset: 0x0 (0)
  struct _KTIMER Timer;             // offset: 0x40 (64)
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x80 (128)
};

// 0x3f0 (1008) bytes
struct _EX_TIMEZONE_STATE {
  struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION
      TimeZoneInformation;                              // offset: 0x0 (0)
  ULONG CurrentTimeZoneId;                              // offset: 0x1b0 (432)
  LONG LastTimeZoneBias;                                // offset: 0x1b4 (436)
  union _LARGE_INTEGER TimeZoneBias;                    // offset: 0x1b8 (440)
  struct _TIMEZONE_CHANGE_EVENT TimeZone;               // offset: 0x1c0 (448)
  struct _TIMEZONE_CHANGE_EVENT Century;                // offset: 0x260 (608)
  struct _TIMEZONE_CHANGE_EVENT NextYear;               // offset: 0x300 (768)
  LONG OkToTimeZoneRefresh;                             // offset: 0x3a0 (928)
  union _LARGE_INTEGER NextCenturyTimeInUTC;            // offset: 0x3a8 (936)
  struct _TIME_FIELDS NextCenturyTimeFieldsInLocalTime; // offset: 0x3b0 (944)
  union _LARGE_INTEGER NextYearTimeInUTC;               // offset: 0x3c0 (960)
  struct _TIME_FIELDS NextYearTimeFieldsInLocalTime;    // offset: 0x3c8 (968)
  SHORT LastDynamicTimeZoneYear;                        // offset: 0x3d8 (984)
  union _LARGE_INTEGER NextSystemCutoverInUTC;          // offset: 0x3e0 (992)
  ULONG RefreshFailures;                                // offset: 0x3e8 (1000)
};

// 0x7c8 (1992) bytes
struct _PEB {
  UCHAR InheritedAddressSpace;    // offset: 0x0 (0)
  UCHAR ReadImageFileExecOptions; // offset: 0x1 (1)
  UCHAR BeingDebugged;            // offset: 0x2 (2)
  union {
    UCHAR BitField; // offset: 0x3 (3)
    struct {
      UCHAR ImageUsesLargePages : 1;          // offset: 0x3 (3)
      UCHAR IsProtectedProcess : 1;           // offset: 0x3 (3)
      UCHAR IsImageDynamicallyRelocated : 1;  // offset: 0x3 (3)
      UCHAR SkipPatchingUser32Forwarders : 1; // offset: 0x3 (3)
      UCHAR IsPackagedProcess : 1;            // offset: 0x3 (3)
      UCHAR IsAppContainer : 1;               // offset: 0x3 (3)
      UCHAR IsProtectedProcessLight : 1;      // offset: 0x3 (3)
      UCHAR IsLongPathAwareProcess : 1;       // offset: 0x3 (3)
    };
  };
  UCHAR Padding0[4];                                      // offset: 0x4 (4)
  VOID *Mutant;                                           // offset: 0x8 (8)
  VOID *ImageBaseAddress;                                 // offset: 0x10 (16)
  struct _PEB_LDR_DATA *Ldr;                              // offset: 0x18 (24)
  struct _RTL_USER_PROCESS_PARAMETERS *ProcessParameters; // offset: 0x20 (32)
  VOID *SubSystemData;                                    // offset: 0x28 (40)
  VOID *ProcessHeap;                                      // offset: 0x30 (48)
  struct _RTL_CRITICAL_SECTION *FastPebLock;              // offset: 0x38 (56)
  union _SLIST_HEADER *volatile AtlThunkSListPtr;         // offset: 0x40 (64)
  VOID *IFEOKey;                                          // offset: 0x48 (72)
  union {
    ULONG CrossProcessFlags; // offset: 0x50 (80)
    struct {
      ULONG ProcessInJob : 1;               // offset: 0x50 (80)
      ULONG ProcessInitializing : 1;        // offset: 0x50 (80)
      ULONG ProcessUsingVEH : 1;            // offset: 0x50 (80)
      ULONG ProcessUsingVCH : 1;            // offset: 0x50 (80)
      ULONG ProcessUsingFTH : 1;            // offset: 0x50 (80)
      ULONG ProcessPreviouslyThrottled : 1; // offset: 0x50 (80)
      ULONG ProcessCurrentlyThrottled : 1;  // offset: 0x50 (80)
      ULONG ProcessImagesHotPatched : 1;    // offset: 0x50 (80)
      ULONG ReservedBits0 : 24;             // offset: 0x50 (80)
    };
  };
  UCHAR Padding1[4]; // offset: 0x54 (84)
  union {
    VOID *KernelCallbackTable; // offset: 0x58 (88)
    VOID *UserSharedInfoPtr;   // offset: 0x58 (88)
  };
  ULONG SystemReserved;                                   // offset: 0x60 (96)
  ULONG AtlThunkSListPtr32;                               // offset: 0x64 (100)
  VOID *ApiSetMap;                                        // offset: 0x68 (104)
  ULONG TlsExpansionCounter;                              // offset: 0x70 (112)
  UCHAR Padding2[4];                                      // offset: 0x74 (116)
  VOID *TlsBitmap;                                        // offset: 0x78 (120)
  ULONG TlsBitmapBits[2];                                 // offset: 0x80 (128)
  VOID *ReadOnlySharedMemoryBase;                         // offset: 0x88 (136)
  VOID *SharedData;                                       // offset: 0x90 (144)
  VOID **ReadOnlyStaticServerData;                        // offset: 0x98 (152)
  VOID *AnsiCodePageData;                                 // offset: 0xa0 (160)
  VOID *OemCodePageData;                                  // offset: 0xa8 (168)
  VOID *UnicodeCaseTableData;                             // offset: 0xb0 (176)
  ULONG NumberOfProcessors;                               // offset: 0xb8 (184)
  ULONG NtGlobalFlag;                                     // offset: 0xbc (188)
  union _LARGE_INTEGER CriticalSectionTimeout;            // offset: 0xc0 (192)
  ULONGLONG HeapSegmentReserve;                           // offset: 0xc8 (200)
  ULONGLONG HeapSegmentCommit;                            // offset: 0xd0 (208)
  ULONGLONG HeapDeCommitTotalFreeThreshold;               // offset: 0xd8 (216)
  ULONGLONG HeapDeCommitFreeBlockThreshold;               // offset: 0xe0 (224)
  ULONG NumberOfHeaps;                                    // offset: 0xe8 (232)
  ULONG MaximumNumberOfHeaps;                             // offset: 0xec (236)
  VOID **ProcessHeaps;                                    // offset: 0xf0 (240)
  VOID *GdiSharedHandleTable;                             // offset: 0xf8 (248)
  VOID *ProcessStarterHelper;                             // offset: 0x100 (256)
  ULONG GdiDCAttributeList;                               // offset: 0x108 (264)
  UCHAR Padding3[4];                                      // offset: 0x10c (268)
  struct _RTL_CRITICAL_SECTION *LoaderLock;               // offset: 0x110 (272)
  ULONG OSMajorVersion;                                   // offset: 0x118 (280)
  ULONG OSMinorVersion;                                   // offset: 0x11c (284)
  USHORT OSBuildNumber;                                   // offset: 0x120 (288)
  USHORT OSCSDVersion;                                    // offset: 0x122 (290)
  ULONG OSPlatformId;                                     // offset: 0x124 (292)
  ULONG ImageSubsystem;                                   // offset: 0x128 (296)
  ULONG ImageSubsystemMajorVersion;                       // offset: 0x12c (300)
  ULONG ImageSubsystemMinorVersion;                       // offset: 0x130 (304)
  UCHAR Padding4[4];                                      // offset: 0x134 (308)
  ULONGLONG ActiveProcessAffinityMask;                    // offset: 0x138 (312)
  ULONG GdiHandleBuffer[60];                              // offset: 0x140 (320)
  VOID (*PostProcessInitRoutine)();                       // offset: 0x230 (560)
  VOID *TlsExpansionBitmap;                               // offset: 0x238 (568)
  ULONG TlsExpansionBitmapBits[32];                       // offset: 0x240 (576)
  ULONG SessionId;                                        // offset: 0x2c0 (704)
  UCHAR Padding5[4];                                      // offset: 0x2c4 (708)
  union _ULARGE_INTEGER AppCompatFlags;                   // offset: 0x2c8 (712)
  union _ULARGE_INTEGER AppCompatFlagsUser;               // offset: 0x2d0 (720)
  VOID *pShimData;                                        // offset: 0x2d8 (728)
  VOID *AppCompatInfo;                                    // offset: 0x2e0 (736)
  struct _UNICODE_STRING CSDVersion;                      // offset: 0x2e8 (744)
  struct _ACTIVATION_CONTEXT_DATA *ActivationContextData; // offset: 0x2f8 (760)
  struct _ASSEMBLY_STORAGE_MAP
      *ProcessAssemblyStorageMap; // offset: 0x300 (768)
  struct _ACTIVATION_CONTEXT_DATA
      *SystemDefaultActivationContextData;                // offset: 0x308 (776)
  struct _ASSEMBLY_STORAGE_MAP *SystemAssemblyStorageMap; // offset: 0x310 (784)
  ULONGLONG MinimumStackCommit;                           // offset: 0x318 (792)
  VOID *SparePointers[4];                                 // offset: 0x320 (800)
  ULONG SpareUlongs[5];                                   // offset: 0x340 (832)
  VOID *WerRegistrationData;                              // offset: 0x358 (856)
  VOID *WerShipAssertPtr;                                 // offset: 0x360 (864)
  VOID *pUnused;                                          // offset: 0x368 (872)
  VOID *pImageHeaderHash;                                 // offset: 0x370 (880)
  union {
    ULONG TracingFlags; // offset: 0x378 (888)
    struct {
      ULONG HeapTracingEnabled : 1;      // offset: 0x378 (888)
      ULONG CritSecTracingEnabled : 1;   // offset: 0x378 (888)
      ULONG LibLoaderTracingEnabled : 1; // offset: 0x378 (888)
      ULONG SpareTracingBits : 29;       // offset: 0x378 (888)
    };
  };
  UCHAR Padding6[4];                            // offset: 0x37c (892)
  ULONGLONG CsrServerReadOnlySharedMemoryBase;  // offset: 0x380 (896)
  ULONGLONG TppWorkerpListLock;                 // offset: 0x388 (904)
  struct _LIST_ENTRY TppWorkerpList;            // offset: 0x390 (912)
  VOID *WaitOnAddressHashTable[128];            // offset: 0x3a0 (928)
  VOID *TelemetryCoverageHeader;                // offset: 0x7a0 (1952)
  ULONG CloudFileFlags;                         // offset: 0x7a8 (1960)
  ULONG CloudFileDiagFlags;                     // offset: 0x7ac (1964)
  CHAR PlaceholderCompatibilityMode;            // offset: 0x7b0 (1968)
  CHAR PlaceholderCompatibilityModeReserved[7]; // offset: 0x7b1 (1969)
  struct _LEAP_SECOND_DATA *LeapSecondData;     // offset: 0x7b8 (1976)
  union {
    ULONG LeapSecondFlags; // offset: 0x7c0 (1984)
    struct {
      ULONG SixtySecondEnabled : 1; // offset: 0x7c0 (1984)
      ULONG Reserved : 31;          // offset: 0x7c0 (1984)
    };
  };
  ULONG NtGlobalFlag2; // offset: 0x7c4 (1988)
};

// 0x1838 (6200) bytes
struct _TEB {
  struct _NT_TIB NtTib;                              // offset: 0x0 (0)
  VOID *EnvironmentPointer;                          // offset: 0x38 (56)
  struct _CLIENT_ID ClientId;                        // offset: 0x40 (64)
  VOID *ActiveRpcHandle;                             // offset: 0x50 (80)
  VOID *ThreadLocalStoragePointer;                   // offset: 0x58 (88)
  struct _PEB *ProcessEnvironmentBlock;              // offset: 0x60 (96)
  ULONG LastErrorValue;                              // offset: 0x68 (104)
  ULONG CountOfOwnedCriticalSections;                // offset: 0x6c (108)
  VOID *CsrClientThread;                             // offset: 0x70 (112)
  VOID *Win32ThreadInfo;                             // offset: 0x78 (120)
  ULONG User32Reserved[26];                          // offset: 0x80 (128)
  ULONG UserReserved[5];                             // offset: 0xe8 (232)
  VOID *WOW32Reserved;                               // offset: 0x100 (256)
  ULONG CurrentLocale;                               // offset: 0x108 (264)
  ULONG FpSoftwareStatusRegister;                    // offset: 0x10c (268)
  VOID *ReservedForDebuggerInstrumentation[16];      // offset: 0x110 (272)
  VOID *SystemReserved1[30];                         // offset: 0x190 (400)
  CHAR PlaceholderCompatibilityMode;                 // offset: 0x280 (640)
  UCHAR PlaceholderHydrationAlwaysExplicit;          // offset: 0x281 (641)
  CHAR PlaceholderReserved[10];                      // offset: 0x282 (642)
  ULONG ProxiedProcessId;                            // offset: 0x28c (652)
  struct _ACTIVATION_CONTEXT_STACK _ActivationStack; // offset: 0x290 (656)
  UCHAR WorkingOnBehalfTicket[8];                    // offset: 0x2b8 (696)
  LONG ExceptionCode;                                // offset: 0x2c0 (704)
  UCHAR Padding0[4];                                 // offset: 0x2c4 (708)
  struct _ACTIVATION_CONTEXT_STACK
      *ActivationContextStackPointer;          // offset: 0x2c8 (712)
  ULONGLONG InstrumentationCallbackSp;         // offset: 0x2d0 (720)
  ULONGLONG InstrumentationCallbackPreviousPc; // offset: 0x2d8 (728)
  ULONGLONG InstrumentationCallbackPreviousSp; // offset: 0x2e0 (736)
  ULONG TxFsContext;                           // offset: 0x2e8 (744)
  UCHAR InstrumentationCallbackDisabled;       // offset: 0x2ec (748)
  UCHAR UnalignedLoadStoreExceptions;          // offset: 0x2ed (749)
  UCHAR Padding1[2];                           // offset: 0x2ee (750)
  struct _GDI_TEB_BATCH GdiTebBatch;           // offset: 0x2f0 (752)
  struct _CLIENT_ID RealClientId;              // offset: 0x7d8 (2008)
  VOID *GdiCachedProcessHandle;                // offset: 0x7e8 (2024)
  ULONG GdiClientPID;                          // offset: 0x7f0 (2032)
  ULONG GdiClientTID;                          // offset: 0x7f4 (2036)
  VOID *GdiThreadLocalInfo;                    // offset: 0x7f8 (2040)
  ULONGLONG Win32ClientInfo[62];               // offset: 0x800 (2048)
  VOID *glDispatchTable[233];                  // offset: 0x9f0 (2544)
  ULONGLONG glReserved1[29];                   // offset: 0x1138 (4408)
  VOID *glReserved2;                           // offset: 0x1220 (4640)
  VOID *glSectionInfo;                         // offset: 0x1228 (4648)
  VOID *glSection;                             // offset: 0x1230 (4656)
  VOID *glTable;                               // offset: 0x1238 (4664)
  VOID *glCurrentRC;                           // offset: 0x1240 (4672)
  VOID *glContext;                             // offset: 0x1248 (4680)
  ULONG LastStatusValue;                       // offset: 0x1250 (4688)
  UCHAR Padding2[4];                           // offset: 0x1254 (4692)
  struct _UNICODE_STRING StaticUnicodeString;  // offset: 0x1258 (4696)
  WCHAR StaticUnicodeBuffer[261];              // offset: 0x1268 (4712)
  UCHAR Padding3[6];                           // offset: 0x1472 (5234)
  VOID *DeallocationStack;                     // offset: 0x1478 (5240)
  VOID *TlsSlots[64];                          // offset: 0x1480 (5248)
  struct _LIST_ENTRY TlsLinks;                 // offset: 0x1680 (5760)
  VOID *Vdm;                                   // offset: 0x1690 (5776)
  VOID *ReservedForNtRpc;                      // offset: 0x1698 (5784)
  VOID *DbgSsReserved[2];                      // offset: 0x16a0 (5792)
  ULONG HardErrorMode;                         // offset: 0x16b0 (5808)
  UCHAR Padding4[4];                           // offset: 0x16b4 (5812)
  VOID *Instrumentation[11];                   // offset: 0x16b8 (5816)
  struct _GUID ActivityId;                     // offset: 0x1710 (5904)
  VOID *SubProcessTag;                         // offset: 0x1720 (5920)
  VOID *PerflibData;                           // offset: 0x1728 (5928)
  VOID *EtwTraceData;                          // offset: 0x1730 (5936)
  VOID *WinSockData;                           // offset: 0x1738 (5944)
  ULONG GdiBatchCount;                         // offset: 0x1740 (5952)
  union {
    struct _PROCESSOR_NUMBER CurrentIdealProcessor; // offset: 0x1744 (5956)
    ULONG IdealProcessorValue;                      // offset: 0x1744 (5956)
    struct {
      UCHAR ReservedPad0;   // offset: 0x1744 (5956)
      UCHAR ReservedPad1;   // offset: 0x1745 (5957)
      UCHAR ReservedPad2;   // offset: 0x1746 (5958)
      UCHAR IdealProcessor; // offset: 0x1747 (5959)
    };
  };
  ULONG GuaranteedStackBytes;            // offset: 0x1748 (5960)
  UCHAR Padding5[4];                     // offset: 0x174c (5964)
  VOID *ReservedForPerf;                 // offset: 0x1750 (5968)
  VOID *ReservedForOle;                  // offset: 0x1758 (5976)
  ULONG WaitingOnLoaderLock;             // offset: 0x1760 (5984)
  UCHAR Padding6[4];                     // offset: 0x1764 (5988)
  VOID *SavedPriorityState;              // offset: 0x1768 (5992)
  ULONGLONG ReservedForCodeCoverage;     // offset: 0x1770 (6000)
  VOID *ThreadPoolData;                  // offset: 0x1778 (6008)
  VOID **TlsExpansionSlots;              // offset: 0x1780 (6016)
  VOID *DeallocationBStore;              // offset: 0x1788 (6024)
  VOID *BStoreLimit;                     // offset: 0x1790 (6032)
  ULONG MuiGeneration;                   // offset: 0x1798 (6040)
  ULONG IsImpersonating;                 // offset: 0x179c (6044)
  VOID *NlsCache;                        // offset: 0x17a0 (6048)
  VOID *pShimData;                       // offset: 0x17a8 (6056)
  ULONG HeapData;                        // offset: 0x17b0 (6064)
  UCHAR Padding7[4];                     // offset: 0x17b4 (6068)
  VOID *CurrentTransactionHandle;        // offset: 0x17b8 (6072)
  struct _TEB_ACTIVE_FRAME *ActiveFrame; // offset: 0x17c0 (6080)
  VOID *FlsData;                         // offset: 0x17c8 (6088)
  VOID *PreferredLanguages;              // offset: 0x17d0 (6096)
  VOID *UserPrefLanguages;               // offset: 0x17d8 (6104)
  VOID *MergedPrefLanguages;             // offset: 0x17e0 (6112)
  ULONG MuiImpersonation;                // offset: 0x17e8 (6120)
  union {
    volatile USHORT CrossTebFlags; // offset: 0x17ec (6124)
    USHORT SpareCrossTebBits : 16; // offset: 0x17ec (6124)
  };
  union {
    USHORT SameTebFlags; // offset: 0x17ee (6126)
    struct {
      USHORT SafeThunkCall : 1;        // offset: 0x17ee (6126)
      USHORT InDebugPrint : 1;         // offset: 0x17ee (6126)
      USHORT HasFiberData : 1;         // offset: 0x17ee (6126)
      USHORT SkipThreadAttach : 1;     // offset: 0x17ee (6126)
      USHORT WerInShipAssertCode : 1;  // offset: 0x17ee (6126)
      USHORT RanProcessInit : 1;       // offset: 0x17ee (6126)
      USHORT ClonedThread : 1;         // offset: 0x17ee (6126)
      USHORT SuppressDebugMsg : 1;     // offset: 0x17ee (6126)
      USHORT DisableUserStackWalk : 1; // offset: 0x17ee (6126)
      USHORT RtlExceptionAttached : 1; // offset: 0x17ee (6126)
      USHORT InitialThread : 1;        // offset: 0x17ee (6126)
      USHORT SessionAware : 1;         // offset: 0x17ee (6126)
      USHORT LoadOwner : 1;            // offset: 0x17ee (6126)
      USHORT LoaderWorker : 1;         // offset: 0x17ee (6126)
      USHORT SkipLoaderInit : 1;       // offset: 0x17ee (6126)
      USHORT SpareSameTebBits : 1;     // offset: 0x17ee (6126)
    };
  };
  VOID *TxnScopeEnterCallback;       // offset: 0x17f0 (6128)
  VOID *TxnScopeExitCallback;        // offset: 0x17f8 (6136)
  VOID *TxnScopeContext;             // offset: 0x1800 (6144)
  ULONG LockCount;                   // offset: 0x1808 (6152)
  LONG WowTebOffset;                 // offset: 0x180c (6156)
  VOID *ResourceRetValue;            // offset: 0x1810 (6160)
  VOID *ReservedForWdf;              // offset: 0x1818 (6168)
  ULONGLONG ReservedForCrt;          // offset: 0x1820 (6176)
  struct _GUID EffectiveContainerId; // offset: 0x1828 (6184)
};

// 0xa40 (2624) bytes
struct _EPROCESS {
  struct _KPROCESS Pcb;                  // offset: 0x0 (0)
  struct _EX_PUSH_LOCK ProcessLock;      // offset: 0x438 (1080)
  VOID *UniqueProcessId;                 // offset: 0x440 (1088)
  struct _LIST_ENTRY ActiveProcessLinks; // offset: 0x448 (1096)
  struct _EX_RUNDOWN_REF RundownProtect; // offset: 0x458 (1112)
  union {
    ULONG Flags2; // offset: 0x460 (1120)
    struct {
      ULONG JobNotReallyActive : 1;              // offset: 0x460 (1120)
      ULONG AccountingFolded : 1;                // offset: 0x460 (1120)
      ULONG NewProcessReported : 1;              // offset: 0x460 (1120)
      ULONG ExitProcessReported : 1;             // offset: 0x460 (1120)
      ULONG ReportCommitChanges : 1;             // offset: 0x460 (1120)
      ULONG LastReportMemory : 1;                // offset: 0x460 (1120)
      ULONG ForceWakeCharge : 1;                 // offset: 0x460 (1120)
      ULONG CrossSessionCreate : 1;              // offset: 0x460 (1120)
      ULONG NeedsHandleRundown : 1;              // offset: 0x460 (1120)
      ULONG RefTraceEnabled : 1;                 // offset: 0x460 (1120)
      ULONG PicoCreated : 1;                     // offset: 0x460 (1120)
      ULONG EmptyJobEvaluated : 1;               // offset: 0x460 (1120)
      ULONG DefaultPagePriority : 3;             // offset: 0x460 (1120)
      ULONG PrimaryTokenFrozen : 1;              // offset: 0x460 (1120)
      ULONG ProcessVerifierTarget : 1;           // offset: 0x460 (1120)
      ULONG RestrictSetThreadContext : 1;        // offset: 0x460 (1120)
      ULONG AffinityPermanent : 1;               // offset: 0x460 (1120)
      ULONG AffinityUpdateEnable : 1;            // offset: 0x460 (1120)
      ULONG PropagateNode : 1;                   // offset: 0x460 (1120)
      ULONG ExplicitAffinity : 1;                // offset: 0x460 (1120)
      ULONG ProcessExecutionState : 2;           // offset: 0x460 (1120)
      ULONG EnableReadVmLogging : 1;             // offset: 0x460 (1120)
      ULONG EnableWriteVmLogging : 1;            // offset: 0x460 (1120)
      ULONG FatalAccessTerminationRequested : 1; // offset: 0x460 (1120)
      ULONG DisableSystemAllowedCpuSet : 1;      // offset: 0x460 (1120)
      ULONG ProcessStateChangeRequest : 2;       // offset: 0x460 (1120)
      ULONG ProcessStateChangeInProgress : 1;    // offset: 0x460 (1120)
      ULONG InPrivate : 1;                       // offset: 0x460 (1120)
    };
  };
  union {
    ULONG Flags; // offset: 0x464 (1124)
    struct {
      ULONG CreateReported : 1;               // offset: 0x464 (1124)
      ULONG NoDebugInherit : 1;               // offset: 0x464 (1124)
      ULONG ProcessExiting : 1;               // offset: 0x464 (1124)
      ULONG ProcessDelete : 1;                // offset: 0x464 (1124)
      ULONG ManageExecutableMemoryWrites : 1; // offset: 0x464 (1124)
      ULONG VmDeleted : 1;                    // offset: 0x464 (1124)
      ULONG OutswapEnabled : 1;               // offset: 0x464 (1124)
      ULONG Outswapped : 1;                   // offset: 0x464 (1124)
      ULONG FailFastOnCommitFail : 1;         // offset: 0x464 (1124)
      ULONG Wow64VaSpace4Gb : 1;              // offset: 0x464 (1124)
      ULONG AddressSpaceInitialized : 2;      // offset: 0x464 (1124)
      ULONG SetTimerResolution : 1;           // offset: 0x464 (1124)
      ULONG BreakOnTermination : 1;           // offset: 0x464 (1124)
      ULONG DeprioritizeViews : 1;            // offset: 0x464 (1124)
      ULONG WriteWatch : 1;                   // offset: 0x464 (1124)
      ULONG ProcessInSession : 1;             // offset: 0x464 (1124)
      ULONG OverrideAddressSpace : 1;         // offset: 0x464 (1124)
      ULONG HasAddressSpace : 1;              // offset: 0x464 (1124)
      ULONG LaunchPrefetched : 1;             // offset: 0x464 (1124)
      ULONG Background : 1;                   // offset: 0x464 (1124)
      ULONG VmTopDown : 1;                    // offset: 0x464 (1124)
      ULONG ImageNotifyDone : 1;              // offset: 0x464 (1124)
      ULONG PdeUpdateNeeded : 1;              // offset: 0x464 (1124)
      ULONG VdmAllowed : 1;                   // offset: 0x464 (1124)
      ULONG ProcessRundown : 1;               // offset: 0x464 (1124)
      ULONG ProcessInserted : 1;              // offset: 0x464 (1124)
      ULONG DefaultIoPriority : 3;            // offset: 0x464 (1124)
      ULONG ProcessSelfDelete : 1;            // offset: 0x464 (1124)
      ULONG SetTimerResolutionLink : 1;       // offset: 0x464 (1124)
    };
  };
  union _LARGE_INTEGER CreateTime;        // offset: 0x468 (1128)
  ULONGLONG ProcessQuotaUsage[2];         // offset: 0x470 (1136)
  ULONGLONG ProcessQuotaPeak[2];          // offset: 0x480 (1152)
  ULONGLONG PeakVirtualSize;              // offset: 0x490 (1168)
  ULONGLONG VirtualSize;                  // offset: 0x498 (1176)
  struct _LIST_ENTRY SessionProcessLinks; // offset: 0x4a0 (1184)
  union {
    VOID *ExceptionPortData;          // offset: 0x4b0 (1200)
    ULONGLONG ExceptionPortValue;     // offset: 0x4b0 (1200)
    ULONGLONG ExceptionPortState : 3; // offset: 0x4b0 (1200)
  };
  struct _EX_FAST_REF Token;                    // offset: 0x4b8 (1208)
  ULONGLONG MmReserved;                         // offset: 0x4c0 (1216)
  struct _EX_PUSH_LOCK AddressCreationLock;     // offset: 0x4c8 (1224)
  struct _EX_PUSH_LOCK PageTableCommitmentLock; // offset: 0x4d0 (1232)
  struct _ETHREAD *RotateInProgress;            // offset: 0x4d8 (1240)
  struct _ETHREAD *ForkInProgress;              // offset: 0x4e0 (1248)
  struct _EJOB *volatile CommitChargeJob;       // offset: 0x4e8 (1256)
  struct _RTL_AVL_TREE CloneRoot;               // offset: 0x4f0 (1264)
  volatile ULONGLONG NumberOfPrivatePages;      // offset: 0x4f8 (1272)
  volatile ULONGLONG NumberOfLockedPages;       // offset: 0x500 (1280)
  VOID *Win32Process;                           // offset: 0x508 (1288)
  struct _EJOB *volatile Job;                   // offset: 0x510 (1296)
  VOID *SectionObject;                          // offset: 0x518 (1304)
  VOID *SectionBaseAddress;                     // offset: 0x520 (1312)
  ULONG Cookie;                                 // offset: 0x528 (1320)
  struct _PAGEFAULT_HISTORY *WorkingSetWatch;   // offset: 0x530 (1328)
  VOID *Win32WindowStation;                     // offset: 0x538 (1336)
  VOID *InheritedFromUniqueProcessId;           // offset: 0x540 (1344)
  volatile ULONGLONG OwnerProcessId;            // offset: 0x548 (1352)
  struct _PEB *Peb;                             // offset: 0x550 (1360)
  struct _MM_SESSION_SPACE *Session;            // offset: 0x558 (1368)
  VOID *Spare1;                                 // offset: 0x560 (1376)
  struct _EPROCESS_QUOTA_BLOCK *QuotaBlock;     // offset: 0x568 (1384)
  struct _HANDLE_TABLE *ObjectTable;            // offset: 0x570 (1392)
  VOID *DebugPort;                              // offset: 0x578 (1400)
  struct _EWOW64PROCESS *WoW64Process;          // offset: 0x580 (1408)
  VOID *DeviceMap;                              // offset: 0x588 (1416)
  VOID *EtwDataSource;                          // offset: 0x590 (1424)
  ULONGLONG PageDirectoryPte;                   // offset: 0x598 (1432)
  struct _FILE_OBJECT *ImageFilePointer;        // offset: 0x5a0 (1440)
  UCHAR ImageFileName[15];                      // offset: 0x5a8 (1448)
  UCHAR PriorityClass;                          // offset: 0x5b7 (1463)
  VOID *SecurityPort;                           // offset: 0x5b8 (1464)
  struct _SE_AUDIT_PROCESS_CREATION_INFO
      SeAuditProcessCreationInfo;           // offset: 0x5c0 (1472)
  struct _LIST_ENTRY JobLinks;              // offset: 0x5c8 (1480)
  VOID *HighestUserAddress;                 // offset: 0x5d8 (1496)
  struct _LIST_ENTRY ThreadListHead;        // offset: 0x5e0 (1504)
  volatile ULONG ActiveThreads;             // offset: 0x5f0 (1520)
  ULONG ImagePathHash;                      // offset: 0x5f4 (1524)
  ULONG DefaultHardErrorProcessing;         // offset: 0x5f8 (1528)
  LONG LastThreadExitStatus;                // offset: 0x5fc (1532)
  struct _EX_FAST_REF PrefetchTrace;        // offset: 0x600 (1536)
  VOID *LockedPagesList;                    // offset: 0x608 (1544)
  union _LARGE_INTEGER ReadOperationCount;  // offset: 0x610 (1552)
  union _LARGE_INTEGER WriteOperationCount; // offset: 0x618 (1560)
  union _LARGE_INTEGER OtherOperationCount; // offset: 0x620 (1568)
  union _LARGE_INTEGER ReadTransferCount;   // offset: 0x628 (1576)
  union _LARGE_INTEGER WriteTransferCount;  // offset: 0x630 (1584)
  union _LARGE_INTEGER OtherTransferCount;  // offset: 0x638 (1592)
  ULONGLONG CommitChargeLimit;              // offset: 0x640 (1600)
  volatile ULONGLONG CommitCharge;          // offset: 0x648 (1608)
  volatile ULONGLONG CommitChargePeak;      // offset: 0x650 (1616)
  struct _MMSUPPORT_FULL Vm;                // offset: 0x680 (1664)
  struct _LIST_ENTRY MmProcessLinks;        // offset: 0x7c0 (1984)
  ULONG ModifiedPageCount;                  // offset: 0x7d0 (2000)
  LONG ExitStatus;                          // offset: 0x7d4 (2004)
  struct _RTL_AVL_TREE VadRoot;             // offset: 0x7d8 (2008)
  VOID *VadHint;                            // offset: 0x7e0 (2016)
  ULONGLONG VadCount;                       // offset: 0x7e8 (2024)
  volatile ULONGLONG VadPhysicalPages;      // offset: 0x7f0 (2032)
  ULONGLONG VadPhysicalPagesLimit;          // offset: 0x7f8 (2040)
  struct _ALPC_PROCESS_CONTEXT AlpcContext; // offset: 0x800 (2048)
  struct _LIST_ENTRY TimerResolutionLink;   // offset: 0x820 (2080)
  struct _PO_DIAG_STACK_RECORD
      *TimerResolutionStackRecord; // offset: 0x830 (2096)
  ULONG RequestedTimerResolution;  // offset: 0x838 (2104)
  ULONG SmallestTimerResolution;   // offset: 0x83c (2108)
  union _LARGE_INTEGER ExitTime;   // offset: 0x840 (2112)
  struct _INVERTED_FUNCTION_TABLE
      *InvertedFunctionTable;                     // offset: 0x848 (2120)
  struct _EX_PUSH_LOCK InvertedFunctionTableLock; // offset: 0x850 (2128)
  ULONG ActiveThreadsHighWatermark;               // offset: 0x858 (2136)
  ULONG LargePrivateVadCount;                     // offset: 0x85c (2140)
  struct _EX_PUSH_LOCK ThreadListLock;            // offset: 0x860 (2144)
  VOID *WnfContext;                               // offset: 0x868 (2152)
  struct _EJOB *ServerSilo;                       // offset: 0x870 (2160)
  UCHAR SignatureLevel;                           // offset: 0x878 (2168)
  UCHAR SectionSignatureLevel;                    // offset: 0x879 (2169)
  struct _PS_PROTECTION Protection;               // offset: 0x87a (2170)
  UCHAR HangCount : 3;                            // offset: 0x87b (2171)
  UCHAR GhostCount : 3;                           // offset: 0x87b (2171)
  UCHAR PrefilterException : 1;                   // offset: 0x87b (2171)
  union {
    ULONG Flags3; // offset: 0x87c (2172)
    struct {
      ULONG Minimal : 1;                           // offset: 0x87c (2172)
      ULONG ReplacingPageRoot : 1;                 // offset: 0x87c (2172)
      ULONG Crashed : 1;                           // offset: 0x87c (2172)
      ULONG JobVadsAreTracked : 1;                 // offset: 0x87c (2172)
      ULONG VadTrackingDisabled : 1;               // offset: 0x87c (2172)
      ULONG AuxiliaryProcess : 1;                  // offset: 0x87c (2172)
      ULONG SubsystemProcess : 1;                  // offset: 0x87c (2172)
      ULONG IndirectCpuSets : 1;                   // offset: 0x87c (2172)
      ULONG RelinquishedCommit : 1;                // offset: 0x87c (2172)
      ULONG HighGraphicsPriority : 1;              // offset: 0x87c (2172)
      ULONG CommitFailLogged : 1;                  // offset: 0x87c (2172)
      ULONG ReserveFailLogged : 1;                 // offset: 0x87c (2172)
      ULONG SystemProcess : 1;                     // offset: 0x87c (2172)
      ULONG HideImageBaseAddresses : 1;            // offset: 0x87c (2172)
      ULONG AddressPolicyFrozen : 1;               // offset: 0x87c (2172)
      ULONG ProcessFirstResume : 1;                // offset: 0x87c (2172)
      ULONG ForegroundExternal : 1;                // offset: 0x87c (2172)
      ULONG ForegroundSystem : 1;                  // offset: 0x87c (2172)
      ULONG HighMemoryPriority : 1;                // offset: 0x87c (2172)
      ULONG EnableProcessSuspendResumeLogging : 1; // offset: 0x87c (2172)
      ULONG EnableThreadSuspendResumeLogging : 1;  // offset: 0x87c (2172)
      ULONG SecurityDomainChanged : 1;             // offset: 0x87c (2172)
      ULONG SecurityFreezeComplete : 1;            // offset: 0x87c (2172)
      ULONG VmProcessorHost : 1;                   // offset: 0x87c (2172)
      ULONG VmProcessorHostTransition : 1;         // offset: 0x87c (2172)
      ULONG AltSyscall : 1;                        // offset: 0x87c (2172)
      ULONG TimerResolutionIgnore : 1;             // offset: 0x87c (2172)
      ULONG DisallowUserTerminate : 1;             // offset: 0x87c (2172)
    };
  };
  LONG DeviceAsid;                                  // offset: 0x880 (2176)
  VOID *SvmData;                                    // offset: 0x888 (2184)
  struct _EX_PUSH_LOCK SvmProcessLock;              // offset: 0x890 (2192)
  ULONGLONG SvmLock;                                // offset: 0x898 (2200)
  struct _LIST_ENTRY SvmProcessDeviceListHead;      // offset: 0x8a0 (2208)
  ULONGLONG LastFreezeInterruptTime;                // offset: 0x8b0 (2224)
  struct _PROCESS_DISK_COUNTERS *DiskCounters;      // offset: 0x8b8 (2232)
  VOID *PicoContext;                                // offset: 0x8c0 (2240)
  VOID *EnclaveTable;                               // offset: 0x8c8 (2248)
  ULONGLONG EnclaveNumber;                          // offset: 0x8d0 (2256)
  struct _EX_PUSH_LOCK EnclaveLock;                 // offset: 0x8d8 (2264)
  ULONG HighPriorityFaultsAllowed;                  // offset: 0x8e0 (2272)
  struct _PO_PROCESS_ENERGY_CONTEXT *EnergyContext; // offset: 0x8e8 (2280)
  VOID *VmContext;                                  // offset: 0x8f0 (2288)
  ULONGLONG SequenceNumber;                         // offset: 0x8f8 (2296)
  ULONGLONG CreateInterruptTime;                    // offset: 0x900 (2304)
  ULONGLONG CreateUnbiasedInterruptTime;            // offset: 0x908 (2312)
  ULONGLONG TotalUnbiasedFrozenTime;                // offset: 0x910 (2320)
  ULONGLONG LastAppStateUpdateTime;                 // offset: 0x918 (2328)
  ULONGLONG LastAppStateUptime : 61;                // offset: 0x920 (2336)
  ULONGLONG LastAppState : 3;                       // offset: 0x920 (2336)
  volatile ULONGLONG SharedCommitCharge;            // offset: 0x928 (2344)
  struct _EX_PUSH_LOCK SharedCommitLock;            // offset: 0x930 (2352)
  struct _LIST_ENTRY SharedCommitLinks;             // offset: 0x938 (2360)
  union {
    struct {
      ULONGLONG AllowedCpuSets; // offset: 0x948 (2376)
      ULONGLONG DefaultCpuSets; // offset: 0x950 (2384)
    };
    struct {
      ULONGLONG *AllowedCpuSetsIndirect; // offset: 0x948 (2376)
      ULONGLONG *DefaultCpuSetsIndirect; // offset: 0x950 (2384)
    };
  };
  VOID *DiskIoAttribution; // offset: 0x958 (2392)
  VOID *DxgProcess;        // offset: 0x960 (2400)
  ULONG Win32KFilterSet;   // offset: 0x968 (2408)
  union _PS_INTERLOCKED_TIMER_DELAY_VALUES volatile ProcessTimerDelay; // offset:
                                                                       // 0x970
                                                                       // (2416)
  volatile ULONG KTimerSets;               // offset: 0x978 (2424)
  volatile ULONG KTimer2Sets;              // offset: 0x97c (2428)
  volatile ULONG ThreadTimerSets;          // offset: 0x980 (2432)
  ULONGLONG VirtualTimerListLock;          // offset: 0x988 (2440)
  struct _LIST_ENTRY VirtualTimerListHead; // offset: 0x990 (2448)
  union {
    struct _WNF_STATE_NAME WakeChannel;           // offset: 0x9a0 (2464)
    struct _PS_PROCESS_WAKE_INFORMATION WakeInfo; // offset: 0x9a0 (2464)
  };
  union {
    ULONG MitigationFlags; // offset: 0x9d0 (2512)
    struct {
      ULONG ControlFlowGuardEnabled : 1;                  // offset: 0x0 (0)
      ULONG ControlFlowGuardExportSuppressionEnabled : 1; // offset: 0x0 (0)
      ULONG ControlFlowGuardStrict : 1;                   // offset: 0x0 (0)
      ULONG DisallowStrippedImages : 1;                   // offset: 0x0 (0)
      ULONG ForceRelocateImages : 1;                      // offset: 0x0 (0)
      ULONG HighEntropyASLREnabled : 1;                   // offset: 0x0 (0)
      ULONG StackRandomizationDisabled : 1;               // offset: 0x0 (0)
      ULONG ExtensionPointDisable : 1;                    // offset: 0x0 (0)
      ULONG DisableDynamicCode : 1;                       // offset: 0x0 (0)
      ULONG DisableDynamicCodeAllowOptOut : 1;            // offset: 0x0 (0)
      ULONG DisableDynamicCodeAllowRemoteDowngrade : 1;   // offset: 0x0 (0)
      ULONG AuditDisableDynamicCode : 1;                  // offset: 0x0 (0)
      ULONG DisallowWin32kSystemCalls : 1;                // offset: 0x0 (0)
      ULONG AuditDisallowWin32kSystemCalls : 1;           // offset: 0x0 (0)
      ULONG EnableFilteredWin32kAPIs : 1;                 // offset: 0x0 (0)
      ULONG AuditFilteredWin32kAPIs : 1;                  // offset: 0x0 (0)
      ULONG DisableNonSystemFonts : 1;                    // offset: 0x0 (0)
      ULONG AuditNonSystemFontLoading : 1;                // offset: 0x0 (0)
      ULONG PreferSystem32Images : 1;                     // offset: 0x0 (0)
      ULONG ProhibitRemoteImageMap : 1;                   // offset: 0x0 (0)
      ULONG AuditProhibitRemoteImageMap : 1;              // offset: 0x0 (0)
      ULONG ProhibitLowILImageMap : 1;                    // offset: 0x0 (0)
      ULONG AuditProhibitLowILImageMap : 1;               // offset: 0x0 (0)
      ULONG SignatureMitigationOptIn : 1;                 // offset: 0x0 (0)
      ULONG AuditBlockNonMicrosoftBinaries : 1;           // offset: 0x0 (0)
      ULONG AuditBlockNonMicrosoftBinariesAllowStore : 1; // offset: 0x0 (0)
      ULONG LoaderIntegrityContinuityEnabled : 1;         // offset: 0x0 (0)
      ULONG AuditLoaderIntegrityContinuity : 1;           // offset: 0x0 (0)
      ULONG EnableModuleTamperingProtection : 1;          // offset: 0x0 (0)
      ULONG EnableModuleTamperingProtectionNoInherit : 1; // offset: 0x0 (0)
      ULONG RestrictIndirectBranchPrediction : 1;         // offset: 0x0 (0)
      ULONG IsolateSecurityDomain : 1;                    // offset: 0x0 (0)
    } MitigationFlagsValues; // offset: 0x9d0 (2512)
  };
  union {
    ULONG MitigationFlags2; // offset: 0x9d4 (2516)
    struct {
      ULONG EnableExportAddressFilter : 1;                // offset: 0x0 (0)
      ULONG AuditExportAddressFilter : 1;                 // offset: 0x0 (0)
      ULONG EnableExportAddressFilterPlus : 1;            // offset: 0x0 (0)
      ULONG AuditExportAddressFilterPlus : 1;             // offset: 0x0 (0)
      ULONG EnableRopStackPivot : 1;                      // offset: 0x0 (0)
      ULONG AuditRopStackPivot : 1;                       // offset: 0x0 (0)
      ULONG EnableRopCallerCheck : 1;                     // offset: 0x0 (0)
      ULONG AuditRopCallerCheck : 1;                      // offset: 0x0 (0)
      ULONG EnableRopSimExec : 1;                         // offset: 0x0 (0)
      ULONG AuditRopSimExec : 1;                          // offset: 0x0 (0)
      ULONG EnableImportAddressFilter : 1;                // offset: 0x0 (0)
      ULONG AuditImportAddressFilter : 1;                 // offset: 0x0 (0)
      ULONG DisablePageCombine : 1;                       // offset: 0x0 (0)
      ULONG SpeculativeStoreBypassDisable : 1;            // offset: 0x0 (0)
      ULONG CetUserShadowStacks : 1;                      // offset: 0x0 (0)
      ULONG AuditCetUserShadowStacks : 1;                 // offset: 0x0 (0)
      ULONG AuditCetUserShadowStacksLogged : 1;           // offset: 0x0 (0)
      ULONG UserCetSetContextIpValidation : 1;            // offset: 0x0 (0)
      ULONG AuditUserCetSetContextIpValidation : 1;       // offset: 0x0 (0)
      ULONG AuditUserCetSetContextIpValidationLogged : 1; // offset: 0x0 (0)
      ULONG CetUserShadowStacksStrictMode : 1;            // offset: 0x0 (0)
      ULONG BlockNonCetBinaries : 1;                      // offset: 0x0 (0)
      ULONG BlockNonCetBinariesNonEhcont : 1;             // offset: 0x0 (0)
      ULONG AuditBlockNonCetBinaries : 1;                 // offset: 0x0 (0)
      ULONG AuditBlockNonCetBinariesLogged : 1;           // offset: 0x0 (0)
      ULONG Reserved1 : 1;                                // offset: 0x0 (0)
      ULONG Reserved2 : 1;                                // offset: 0x0 (0)
      ULONG Reserved3 : 1;                                // offset: 0x0 (0)
      ULONG Reserved4 : 1;                                // offset: 0x0 (0)
      ULONG Reserved5 : 1;                                // offset: 0x0 (0)
      ULONG CetDynamicApisOutOfProcOnly : 1;              // offset: 0x0 (0)
      ULONG UserCetSetContextIpValidationRelaxedMode : 1; // offset: 0x0 (0)
    } MitigationFlags2Values; // offset: 0x9d4 (2516)
  };
  VOID *PartitionObject;                                 // offset: 0x9d8 (2520)
  ULONGLONG SecurityDomain;                              // offset: 0x9e0 (2528)
  ULONGLONG ParentSecurityDomain;                        // offset: 0x9e8 (2536)
  VOID *CoverageSamplerContext;                          // offset: 0x9f0 (2544)
  VOID *MmHotPatchContext;                               // offset: 0x9f8 (2552)
  struct _RTL_AVL_TREE DynamicEHContinuationTargetsTree; // offset: 0xa00 (2560)
  struct _EX_PUSH_LOCK DynamicEHContinuationTargetsLock; // offset: 0xa08 (2568)
  struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES
      DynamicEnforcedCetCompatibleRanges; // offset: 0xa10 (2576)
  ULONG DisabledComponentFlags;           // offset: 0xa20 (2592)
};

// 0x48 (72) bytes
struct _RH_OP_CONTEXT {
  struct _LIST_ENTRY Links;                     // offset: 0x0 (0)
  struct _IRP *OplockRequestIrp;                // offset: 0x10 (16)
  struct _FILE_OBJECT *OplockRequestFileObject; // offset: 0x18 (24)
  struct _EPROCESS *OplockRequestProcess;       // offset: 0x20 (32)
  struct _ETHREAD *OplockOwnerThread;           // offset: 0x28 (40)
  ULONG Flags;                                  // offset: 0x30 (48)
  struct _LIST_ENTRY AtomicLinks;               // offset: 0x38 (56)
};

// 0xa0 (160) bytes
struct _NONOPAQUE_OPLOCK {
  struct _IRP *IrpExclusiveOplock;             // offset: 0x0 (0)
  struct _FILE_OBJECT *FileObject;             // offset: 0x8 (8)
  struct _EPROCESS *ExclusiveOplockOwner;      // offset: 0x10 (16)
  struct _ETHREAD *ExclusiveOplockOwnerThread; // offset: 0x18 (24)
  UCHAR WaiterPriority;                        // offset: 0x20 (32)
  struct _LIST_ENTRY IrpOplocksR;              // offset: 0x28 (40)
  struct _LIST_ENTRY IrpOplocksRH;             // offset: 0x38 (56)
  struct _LIST_ENTRY RHBreakQueue;             // offset: 0x48 (72)
  struct _LIST_ENTRY WaitingIrps;              // offset: 0x58 (88)
  struct _LIST_ENTRY DelayAckFileObjectQueue;  // offset: 0x68 (104)
  struct _LIST_ENTRY AtomicQueue;              // offset: 0x78 (120)
  struct _GUID *DeleterParentKey;              // offset: 0x88 (136)
  ULONG OplockState;                           // offset: 0x90 (144)
  struct _FAST_MUTEX *FastMutex;               // offset: 0x98 (152)
};

// 0x10 (16) bytes
struct _POOL_HEADER {
  union {
    struct {
      USHORT PreviousSize : 8; // offset: 0x0 (0)
      USHORT PoolIndex : 8;    // offset: 0x0 (0)
      USHORT BlockSize : 8;    // offset: 0x2 (2)
      USHORT PoolType : 8;     // offset: 0x2 (2)
    };
    ULONG Ulong1; // offset: 0x0 (0)
  };
  ULONG PoolTag; // offset: 0x4 (4)
  union {
    struct _EPROCESS *ProcessBilled; // offset: 0x8 (8)
    struct {
      USHORT AllocatorBackTraceIndex; // offset: 0x8 (8)
      USHORT PoolTagHash;             // offset: 0xa (10)
    };
  };
};

// 0x88 (136) bytes
struct _MMVAD {
  struct _MMVAD_SHORT Core; // offset: 0x0 (0)
  union {
    ULONG LongFlags2;                        // offset: 0x40 (64)
    volatile struct _MMVAD_FLAGS2 VadFlags2; // offset: 0x40 (64)

  } u2;                             // offset: 0x40 (64)
  struct _SUBSECTION *Subsection;   // offset: 0x48 (72)
  struct _MMPTE *FirstPrototypePte; // offset: 0x50 (80)
  struct _MMPTE *LastContiguousPte; // offset: 0x58 (88)
  struct _LIST_ENTRY ViewLinks;     // offset: 0x60 (96)
  struct _EPROCESS *VadsProcess;    // offset: 0x70 (112)
  union {
    struct _MI_VAD_SEQUENTIAL_INFO SequentialVa; // offset: 0x78 (120)
    struct _MMEXTEND_INFO *ExtendedInfo;         // offset: 0x78 (120)

  } u4;                            // offset: 0x78 (120)
  struct _FILE_OBJECT *FileObject; // offset: 0x80 (128)
};

// 0x48 (72) bytes
struct _POP_SHUTDOWN_BUG_CHECK {
  struct _ETHREAD *InitiatingThread;   // offset: 0x0 (0)
  struct _EPROCESS *InitiatingProcess; // offset: 0x8 (8)
  VOID *ThreadId;                      // offset: 0x10 (16)
  VOID *ProcessId;                     // offset: 0x18 (24)
  ULONG Code;                          // offset: 0x20 (32)
  ULONGLONG Parameter1;                // offset: 0x28 (40)
  ULONGLONG Parameter2;                // offset: 0x30 (48)
  ULONGLONG Parameter3;                // offset: 0x38 (56)
  ULONGLONG Parameter4;                // offset: 0x40 (64)
};

// 0x1c8 (456) bytes
struct _POP_POWER_ACTION {
  UCHAR Updates;                                   // offset: 0x0 (0)
  UCHAR State;                                     // offset: 0x1 (1)
  UCHAR Shutdown;                                  // offset: 0x2 (2)
  enum POWER_ACTION Action;                        // offset: 0x4 (4)
  enum _SYSTEM_POWER_STATE LightestState;          // offset: 0x8 (8)
  ULONG Flags;                                     // offset: 0xc (12)
  LONG Status;                                     // offset: 0x10 (16)
  enum POWER_POLICY_DEVICE_TYPE DeviceType;        // offset: 0x14 (20)
  ULONG DeviceTypeFlags;                           // offset: 0x18 (24)
  UCHAR IrpMinor;                                  // offset: 0x1c (28)
  UCHAR Waking;                                    // offset: 0x1d (29)
  enum _SYSTEM_POWER_STATE SystemState;            // offset: 0x20 (32)
  enum _SYSTEM_POWER_STATE NextSystemState;        // offset: 0x24 (36)
  enum _SYSTEM_POWER_STATE EffectiveSystemState;   // offset: 0x28 (40)
  enum _SYSTEM_POWER_STATE CurrentSystemState;     // offset: 0x2c (44)
  struct _POP_SHUTDOWN_BUG_CHECK *ShutdownBugCode; // offset: 0x30 (48)
  struct _POP_DEVICE_SYS_STATE *DevState;          // offset: 0x38 (56)
  struct _POP_HIBER_CONTEXT *HiberContext;         // offset: 0x40 (64)
  ULONGLONG WakeTime;                              // offset: 0x48 (72)
  ULONGLONG SleepTime;                             // offset: 0x50 (80)
  ULONGLONG WakeFirstUnattendedTime;               // offset: 0x58 (88)
  enum SYSTEM_POWER_CONDITION WakeAlarmSignaled;   // offset: 0x60 (96)
  struct {
    ULONGLONG RequestedTime;                             // offset: 0x0 (0)
    ULONGLONG ProgrammedTime;                            // offset: 0x8 (8)
    struct _DIAGNOSTIC_BUFFER *TimerInfo;                // offset: 0x10 (16)
  } WakeAlarm[3];                                        // offset: 0x68 (104)
  UCHAR WakeAlarmPaused;                                 // offset: 0xb0 (176)
  ULONGLONG WakeAlarmLastTime;                           // offset: 0xb8 (184)
  ULONGLONG DozeDeferralStartTime;                       // offset: 0xc0 (192)
  struct SYSTEM_POWER_CAPABILITIES FilteredCapabilities; // offset: 0xc8 (200)
  ULONGLONG WatchdogLock;                                // offset: 0x118 (280)
  struct _KDPC WatchdogDpc;                              // offset: 0x120 (288)
  struct _KTIMER WatchdogTimer;                          // offset: 0x160 (352)
  UCHAR WatchdogInitialized;                             // offset: 0x1a0 (416)
  enum _POP_POWER_ACTION_WATCHDOG_STATE WatchdogState;   // offset: 0x1a4 (420)
  ULONGLONG WatchdogStartTime;                           // offset: 0x1a8 (424)
  struct _KTHREAD *ActionWorkerThread;                   // offset: 0x1b0 (432)
  struct _KTHREAD *PromoteActionWorkerThread;            // offset: 0x1b8 (440)
  struct _KTHREAD *UnlockAfterSleepWorkerThread;         // offset: 0x1c0 (448)
};

// 0x100 (256) bytes
struct _LPCP_PORT_OBJECT {
  struct _LPCP_PORT_OBJECT *ConnectionPort;        // offset: 0x0 (0)
  struct _LPCP_PORT_OBJECT *ConnectedPort;         // offset: 0x8 (8)
  struct _LPCP_PORT_QUEUE MsgQueue;                // offset: 0x10 (16)
  struct _CLIENT_ID Creator;                       // offset: 0x30 (48)
  VOID *ClientSectionBase;                         // offset: 0x40 (64)
  VOID *ServerSectionBase;                         // offset: 0x48 (72)
  VOID *PortContext;                               // offset: 0x50 (80)
  struct _ETHREAD *ClientThread;                   // offset: 0x58 (88)
  struct _SECURITY_QUALITY_OF_SERVICE SecurityQos; // offset: 0x60 (96)
  struct _SECURITY_CLIENT_CONTEXT StaticSecurity;  // offset: 0x70 (112)
  struct _LIST_ENTRY LpcReplyChainHead;            // offset: 0xb8 (184)
  struct _LIST_ENTRY LpcDataInfoChainHead;         // offset: 0xc8 (200)
  union {
    struct _EPROCESS *ServerProcess;  // offset: 0xd8 (216)
    struct _EPROCESS *MappingProcess; // offset: 0xd8 (216)
  };
  USHORT MaxMessageLength;        // offset: 0xe0 (224)
  USHORT MaxConnectionInfoLength; // offset: 0xe2 (226)
  ULONG Flags;                    // offset: 0xe4 (228)
  struct _KEVENT WaitEvent;       // offset: 0xe8 (232)
};

// 0x20 (32) bytes
struct _DIAGNOSTIC_CONTEXT {
  enum _REQUESTER_TYPE CallerType; // offset: 0x0 (0)
  union {
    struct {
      struct _EPROCESS *Process; // offset: 0x8 (8)
      ULONG ServiceTag;          // offset: 0x10 (16)
    };
    struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 (8)
  };
  ULONGLONG ReasonSize; // offset: 0x18 (24)
};

// 0x138 (312) bytes
struct _ETIMER {
  struct _KTIMER KeTimer;                  // offset: 0x0 (0)
  ULONGLONG Lock;                          // offset: 0x40 (64)
  struct _KAPC TimerApc;                   // offset: 0x48 (72)
  struct _KDPC TimerDpc;                   // offset: 0xa0 (160)
  struct _LIST_ENTRY ActiveTimerListEntry; // offset: 0xe0 (224)
  ULONG Period;                            // offset: 0xf0 (240)
  union {
    CHAR TimerFlags; // offset: 0xf4 (244)
    struct {
      UCHAR ApcAssociated : 1; // offset: 0xf4 (244)
      UCHAR FlushDpcs : 1;     // offset: 0xf4 (244)
      UCHAR Paused : 1;        // offset: 0xf4 (244)
      UCHAR Spare1 : 5;        // offset: 0xf4 (244)
    };
  };
  UCHAR DueTimeType;                               // offset: 0xf5 (245)
  USHORT Spare2;                                   // offset: 0xf6 (246)
  struct _DIAGNOSTIC_CONTEXT *volatile WakeReason; // offset: 0xf8 (248)
  struct _LIST_ENTRY WakeTimerListEntry;           // offset: 0x100 (256)
  VOID *VirtualizedTimerCookie;                    // offset: 0x110 (272)
  struct _LIST_ENTRY VirtualizedTimerLinks;        // offset: 0x118 (280)
  ULONGLONG DueTime;                               // offset: 0x128 (296)
  ULONG CoalescingWindow;                          // offset: 0x130 (304)
};

// 0x70 (112) bytes
struct _ETW_REG_ENTRY {
  struct _LIST_ENTRY RegList;         // offset: 0x0 (0)
  struct _LIST_ENTRY GroupRegList;    // offset: 0x10 (16)
  struct _ETW_GUID_ENTRY *GuidEntry;  // offset: 0x20 (32)
  struct _ETW_GUID_ENTRY *GroupEntry; // offset: 0x28 (40)
  union {
    struct _ETW_REPLY_QUEUE *ReplyQueue;   // offset: 0x30 (48)
    struct _ETW_QUEUE_ENTRY *ReplySlot[4]; // offset: 0x30 (48)
    struct {
      VOID *Caller;    // offset: 0x30 (48)
      ULONG SessionId; // offset: 0x38 (56)
    };
  };
  union {
    struct _EPROCESS *Process; // offset: 0x50 (80)
    VOID *CallbackContext;     // offset: 0x50 (80)
  };
  VOID *Callback; // offset: 0x58 (88)
  USHORT Index;   // offset: 0x60 (96)
  union {
    USHORT Flags; // offset: 0x62 (98)
    struct {
      USHORT DbgKernelRegistration : 1;       // offset: 0x62 (98)
      USHORT DbgUserRegistration : 1;         // offset: 0x62 (98)
      USHORT DbgReplyRegistration : 1;        // offset: 0x62 (98)
      USHORT DbgClassicRegistration : 1;      // offset: 0x62 (98)
      USHORT DbgSessionSpaceRegistration : 1; // offset: 0x62 (98)
      USHORT DbgModernRegistration : 1;       // offset: 0x62 (98)
      USHORT DbgClosed : 1;                   // offset: 0x62 (98)
      USHORT DbgInserted : 1;                 // offset: 0x62 (98)
      USHORT DbgWow64 : 1;                    // offset: 0x62 (98)
      USHORT DbgUseDescriptorType : 1;        // offset: 0x62 (98)
      USHORT DbgDropProviderTraits : 1;       // offset: 0x62 (98)
    };
  };
  UCHAR EnableMask;                    // offset: 0x64 (100)
  UCHAR GroupEnableMask;               // offset: 0x65 (101)
  UCHAR HostEnableMask;                // offset: 0x66 (102)
  UCHAR HostGroupEnableMask;           // offset: 0x67 (103)
  struct _ETW_PROVIDER_TRAITS *Traits; // offset: 0x68 (104)
};

// 0x38 (56) bytes
struct _ETW_QUEUE_ENTRY {
  struct _LIST_ENTRY ListEntry;                // offset: 0x0 (0)
  struct _ETWP_NOTIFICATION_HEADER *DataBlock; // offset: 0x10 (16)
  struct _ETW_REG_ENTRY *RegEntry;             // offset: 0x18 (24)
  struct _ETW_REG_ENTRY *ReplyObject;          // offset: 0x20 (32)
  VOID *WakeReference;                         // offset: 0x28 (40)
  USHORT RegIndex;                             // offset: 0x30 (48)
  USHORT ReplyIndex;                           // offset: 0x32 (50)
  ULONG Flags;                                 // offset: 0x34 (52)
};

// 0x28 (40) bytes
struct _MI_REVERSE_VIEW_MAP {
  struct _LIST_ENTRY ViewLinks; // offset: 0x0 (0)
  union {
    VOID *SystemCacheVa;           // offset: 0x10 (16)
    VOID *SessionViewVa;           // offset: 0x10 (16)
    struct _EPROCESS *VadsProcess; // offset: 0x10 (16)
    ULONGLONG Type : 2;            // offset: 0x10 (16)
  };
  union {
    struct _SUBSECTION *Subsection; // offset: 0x18 (24)
    ULONGLONG SubsectionType : 1;   // offset: 0x18 (24)
  };
  union {
    struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES
        SystemCacheAttributes; // offset: 0x20 (32)
    ULONGLONG SectionOffset;   // offset: 0x20 (32)
  };
};

// 0x10a8 (4264) bytes
struct _MI_SESSION_STATE {
  struct _MMSESSION SystemSession;                         // offset: 0x0 (0)
  UCHAR CodePageEdited;                                    // offset: 0x20 (32)
  ULONGLONG *DynamicVaBitBuffer;                           // offset: 0x28 (40)
  ULONGLONG DynamicVaBitBufferPages;                       // offset: 0x30 (48)
  VOID *DynamicVaStart;                                    // offset: 0x38 (56)
  VOID *ImageVaStart;                                      // offset: 0x40 (64)
  struct _MI_HUGE_SYSTEM_VIEW_HEAD SystemViewBuckets[256]; // offset: 0x48 (72)
  ULONG *DynamicPtesBitBuffer;            // offset: 0x1048 (4168)
  struct _EX_PUSH_LOCK IdLock;            // offset: 0x1050 (4176)
  struct _EPROCESS *LeaderProcess;        // offset: 0x1058 (4184)
  struct _EX_PUSH_LOCK InitializeLock;    // offset: 0x1060 (4192)
  struct _MMWSL_INSTANCE *WorkingSetList; // offset: 0x1068 (4200)
  VOID *SessionBase;                      // offset: 0x1070 (4208)
  VOID *SessionCore;                      // offset: 0x1078 (4216)
  struct _RTL_AVL_TREE SessionIdNodes;    // offset: 0x1080 (4224)
  struct _KEVENT DeleteInProgressEvent;   // offset: 0x1088 (4232)
  ULONG DeleteInProgressCount;            // offset: 0x10a0 (4256)
};

// 0x90 (144) bytes
struct _LOCK_TRACKER {
  struct _RTL_BALANCED_NODE LockTrackerNode; // offset: 0x0 (0)
  struct _MDL *Mdl;                          // offset: 0x18 (24)
  VOID *StartVa;                             // offset: 0x20 (32)
  ULONGLONG Count;                           // offset: 0x28 (40)
  ULONG Offset;                              // offset: 0x30 (48)
  ULONG Length;                              // offset: 0x34 (52)
  ULONG Who;                                 // offset: 0x38 (56)
  ULONG Hash;                                // offset: 0x3c (60)
  ULONGLONG Page;                            // offset: 0x40 (64)
  VOID *StackTrace[8];                       // offset: 0x48 (72)
  struct _EPROCESS *Process;                 // offset: 0x88 (136)
};

// 0x88 (136) bytes
struct _WNF_PROCESS_CONTEXT {
  struct _WNF_NODE_HEADER Header;                 // offset: 0x0 (0)
  struct _EPROCESS *Process;                      // offset: 0x8 (8)
  struct _LIST_ENTRY WnfProcessesListEntry;       // offset: 0x10 (16)
  VOID *ImplicitScopeInstances[3];                // offset: 0x20 (32)
  struct _WNF_LOCK TemporaryNamesListLock;        // offset: 0x38 (56)
  struct _LIST_ENTRY TemporaryNamesListHead;      // offset: 0x40 (64)
  struct _WNF_LOCK ProcessSubscriptionListLock;   // offset: 0x50 (80)
  struct _LIST_ENTRY ProcessSubscriptionListHead; // offset: 0x58 (88)
  struct _WNF_LOCK DeliveryPendingListLock;       // offset: 0x68 (104)
  struct _LIST_ENTRY DeliveryPendingListHead;     // offset: 0x70 (112)
  struct _KEVENT *NotificationEvent;              // offset: 0x80 (128)
};

// 0xa8 (168) bytes
struct _WNF_NAME_INSTANCE {
  struct _WNF_NODE_HEADER Header;                    // offset: 0x0 (0)
  struct _EX_RUNDOWN_REF RunRef;                     // offset: 0x8 (8)
  struct _RTL_BALANCED_NODE TreeLinks;               // offset: 0x10 (16)
  struct _WNF_STATE_NAME_STRUCT StateName;           // offset: 0x28 (40)
  struct _WNF_SCOPE_INSTANCE *ScopeInstance;         // offset: 0x30 (48)
  struct _WNF_STATE_NAME_REGISTRATION StateNameInfo; // offset: 0x38 (56)
  struct _WNF_LOCK StateDataLock;                    // offset: 0x50 (80)
  struct _WNF_STATE_DATA *StateData;                 // offset: 0x58 (88)
  ULONG CurrentChangeStamp;                          // offset: 0x60 (96)
  VOID *PermanentDataStore;                          // offset: 0x68 (104)
  struct _WNF_LOCK StateSubscriptionListLock;        // offset: 0x70 (112)
  struct _LIST_ENTRY StateSubscriptionListHead;      // offset: 0x78 (120)
  struct _LIST_ENTRY TemporaryNameListEntry;         // offset: 0x88 (136)
  struct _EPROCESS *CreatorProcess;                  // offset: 0x98 (152)
  LONG DataSubscribersCount;                         // offset: 0xa0 (160)
  LONG CurrentDeliveryCount;                         // offset: 0xa4 (164)
};

// 0x88 (136) bytes
struct _WNF_SUBSCRIPTION {
  struct _WNF_NODE_HEADER Header;                  // offset: 0x0 (0)
  struct _EX_RUNDOWN_REF RunRef;                   // offset: 0x8 (8)
  ULONGLONG SubscriptionId;                        // offset: 0x10 (16)
  struct _LIST_ENTRY ProcessSubscriptionListEntry; // offset: 0x18 (24)
  struct _EPROCESS *Process;                       // offset: 0x28 (40)
  struct _WNF_NAME_INSTANCE *NameInstance;         // offset: 0x30 (48)
  struct _WNF_STATE_NAME_STRUCT StateName;         // offset: 0x38 (56)
  struct _LIST_ENTRY StateSubscriptionListEntry;   // offset: 0x40 (64)
  ULONGLONG CallbackRoutine;                       // offset: 0x50 (80)
  VOID *CallbackContext;                           // offset: 0x58 (88)
  ULONG CurrentChangeStamp;                        // offset: 0x60 (96)
  ULONG SubscribedEventSet;                        // offset: 0x64 (100)
  struct _LIST_ENTRY PendingSubscriptionListEntry; // offset: 0x68 (104)
  enum _WNF_SUBSCRIPTION_STATE SubscriptionState;  // offset: 0x78 (120)
  ULONG SignaledEventSet;                          // offset: 0x7c (124)
  ULONG InDeliveryEventSet;                        // offset: 0x80 (128)
};

// 0x10 (16) bytes
struct _OBJECT_HANDLE_COUNT_ENTRY {
  struct _EPROCESS *Process; // offset: 0x0 (0)
  ULONG HandleCount : 24;    // offset: 0x8 (8)
  ULONG LockCount : 8;       // offset: 0x8 (8)
};

// 0x18 (24) bytes
struct _OBJECT_HANDLE_COUNT_DATABASE {
  ULONG CountEntries;                                      // offset: 0x0 (0)
  struct _OBJECT_HANDLE_COUNT_ENTRY HandleCountEntries[1]; // offset: 0x8 (8)
};

// 0x10 (16) bytes
struct _OBJECT_HEADER_HANDLE_INFO {
  union {
    struct _OBJECT_HANDLE_COUNT_DATABASE
        *HandleCountDataBase;                      // offset: 0x0 (0)
    struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // offset: 0x0 (0)
  };
};

// 0x10 (16) bytes
struct _OBJECT_HEADER_PROCESS_INFO {
  struct _EPROCESS *ExclusiveProcess; // offset: 0x0 (0)
  ULONGLONG Reserved;                 // offset: 0x8 (8)
};

// 0x78 (120) bytes
struct _OBJECT_TYPE_INITIALIZER {
  USHORT Length; // offset: 0x0 (0)
  union {
    USHORT ObjectTypeFlags; // offset: 0x2 (2)
    struct {
      UCHAR CaseInsensitive : 1;         // offset: 0x2 (2)
      UCHAR UnnamedObjectsOnly : 1;      // offset: 0x2 (2)
      UCHAR UseDefaultObject : 1;        // offset: 0x2 (2)
      UCHAR SecurityRequired : 1;        // offset: 0x2 (2)
      UCHAR MaintainHandleCount : 1;     // offset: 0x2 (2)
      UCHAR MaintainTypeList : 1;        // offset: 0x2 (2)
      UCHAR SupportsObjectCallbacks : 1; // offset: 0x2 (2)
      UCHAR CacheAligned : 1;            // offset: 0x2 (2)
      UCHAR UseExtendedParameters : 1;   // offset: 0x3 (3)
      UCHAR Reserved : 7;                // offset: 0x3 (3)
    };
  };
  ULONG ObjectTypeCode;                   // offset: 0x4 (4)
  ULONG InvalidAttributes;                // offset: 0x8 (8)
  struct _GENERIC_MAPPING GenericMapping; // offset: 0xc (12)
  ULONG ValidAccessMask;                  // offset: 0x1c (28)
  ULONG RetainAccess;                     // offset: 0x20 (32)
  enum _POOL_TYPE PoolType;               // offset: 0x24 (36)
  ULONG DefaultPagedPoolCharge;           // offset: 0x28 (40)
  ULONG DefaultNonPagedPoolCharge;        // offset: 0x2c (44)
  VOID (*DumpProcedure)
  (VOID *arg1, struct _OBJECT_DUMP_CONTROL *arg2); // offset: 0x30 (48)
  LONG (*OpenProcedure)
  (enum _OB_OPEN_REASON arg1, CHAR arg2, struct _EPROCESS *arg3, VOID *arg4,
   ULONG *arg5, ULONG arg6); // offset: 0x38 (56)
  VOID (*CloseProcedure)
  (struct _EPROCESS *arg1, VOID *arg2, ULONGLONG arg3,
   ULONGLONG arg4);                    // offset: 0x40 (64)
  VOID (*DeleteProcedure)(VOID *arg1); // offset: 0x48 (72)
  union {
    LONG (*ParseProcedure)
    (VOID *arg1, VOID *arg2, struct _ACCESS_STATE *arg3, CHAR arg4, ULONG arg5,
     struct _UNICODE_STRING *arg6, struct _UNICODE_STRING *arg7, VOID *arg8,
     struct _SECURITY_QUALITY_OF_SERVICE *arg9,
     VOID **arg10); // offset: 0x50 (80)
    LONG (*ParseProcedureEx)
    (VOID *arg1, VOID *arg2, struct _ACCESS_STATE *arg3, CHAR arg4, ULONG arg5,
     struct _UNICODE_STRING *arg6, struct _UNICODE_STRING *arg7, VOID *arg8,
     struct _SECURITY_QUALITY_OF_SERVICE *arg9,
     struct _OB_EXTENDED_PARSE_PARAMETERS *arg10,
     VOID **arg11); // offset: 0x50 (80)
  };
  LONG (*SecurityProcedure)
  (VOID *arg1, enum _SECURITY_OPERATION_CODE arg2, ULONG *arg3, VOID *arg4,
   ULONG *arg5, VOID **arg6, enum _POOL_TYPE arg7,
   struct _GENERIC_MAPPING *arg8, CHAR arg9); // offset: 0x58 (88)
  LONG (*QueryNameProcedure)
  (VOID *arg1, UCHAR arg2, struct _OBJECT_NAME_INFORMATION *arg3, ULONG arg4,
   ULONG *arg5, CHAR arg6); // offset: 0x60 (96)
  UCHAR (*OkayToCloseProcedure)
  (struct _EPROCESS *arg1, VOID *arg2, VOID *arg3,
   CHAR arg4);                    // offset: 0x68 (104)
  ULONG WaitObjectFlagMask;       // offset: 0x70 (112)
  USHORT WaitObjectFlagOffset;    // offset: 0x74 (116)
  USHORT WaitObjectPointerOffset; // offset: 0x76 (118)
};

// 0xd8 (216) bytes
struct _OBJECT_TYPE {
  struct _LIST_ENTRY TypeList;              // offset: 0x0 (0)
  struct _UNICODE_STRING Name;              // offset: 0x10 (16)
  VOID *DefaultObject;                      // offset: 0x20 (32)
  UCHAR Index;                              // offset: 0x28 (40)
  ULONG TotalNumberOfObjects;               // offset: 0x2c (44)
  ULONG TotalNumberOfHandles;               // offset: 0x30 (48)
  ULONG HighWaterNumberOfObjects;           // offset: 0x34 (52)
  ULONG HighWaterNumberOfHandles;           // offset: 0x38 (56)
  struct _OBJECT_TYPE_INITIALIZER TypeInfo; // offset: 0x40 (64)
  struct _EX_PUSH_LOCK TypeLock;            // offset: 0xb8 (184)
  ULONG Key;                                // offset: 0xc0 (192)
  struct _LIST_ENTRY CallbackList;          // offset: 0xc8 (200)
};

// 0x28 (40) bytes
struct _OB_DUPLICATE_OBJECT_STATE {
  struct _EPROCESS *SourceProcess;            // offset: 0x0 (0)
  VOID *SourceHandle;                         // offset: 0x8 (8)
  VOID *Object;                               // offset: 0x10 (16)
  ULONG TargetAccess;                         // offset: 0x18 (24)
  struct _HANDLE_TABLE_ENTRY_INFO ObjectInfo; // offset: 0x1c (28)
  ULONG HandleAttributes;                     // offset: 0x24 (36)
};

// 0x30 (48) bytes
struct _KALPC_HANDLE_DATA {
  ULONG ObjectType;                                   // offset: 0x0 (0)
  ULONG Count;                                        // offset: 0x4 (4)
  struct _OB_DUPLICATE_OBJECT_STATE DuplicateContext; // offset: 0x8 (8)
};

// 0x70 (112) bytes
struct _KALPC_SECURITY_DATA {
  struct _ALPC_HANDLE_TABLE *HandleTable;          // offset: 0x0 (0)
  VOID *ContextHandle;                             // offset: 0x8 (8)
  struct _EPROCESS *OwningProcess;                 // offset: 0x10 (16)
  struct _ALPC_PORT *OwnerPort;                    // offset: 0x18 (24)
  struct _SECURITY_CLIENT_CONTEXT DynamicSecurity; // offset: 0x20 (32)
  union {
    struct {
      ULONG Revoked : 1;      // offset: 0x0 (0)
      ULONG Impersonated : 1; // offset: 0x0 (0)
    } s1;                     // offset: 0x68 (104)

  } u1; // offset: 0x68 (104)
};

// 0x48 (72) bytes
struct _KALPC_MESSAGE_ATTRIBUTES {
  VOID *ClientContext;                                // offset: 0x0 (0)
  VOID *ServerContext;                                // offset: 0x8 (8)
  VOID *PortContext;                                  // offset: 0x10 (16)
  VOID *CancelPortContext;                            // offset: 0x18 (24)
  struct _KALPC_SECURITY_DATA *SecurityData;          // offset: 0x20 (32)
  struct _KALPC_VIEW *View;                           // offset: 0x28 (40)
  struct _KALPC_HANDLE_DATA *HandleData;              // offset: 0x30 (48)
  union _KALPC_DIRECT_EVENT DirectEvent;              // offset: 0x38 (56)
  struct _KALPC_WORK_ON_BEHALF_DATA WorkOnBehalfData; // offset: 0x40 (64)
};

// 0x118 (280) bytes
struct _KALPC_MESSAGE {
  struct _LIST_ENTRY Entry;       // offset: 0x0 (0)
  struct _ALPC_PORT *PortQueue;   // offset: 0x10 (16)
  struct _ALPC_PORT *OwnerPort;   // offset: 0x18 (24)
  struct _ETHREAD *WaitingThread; // offset: 0x20 (32)
  union {
    struct {
      ULONG QueueType : 3;              // offset: 0x0 (0)
      ULONG QueuePortType : 4;          // offset: 0x0 (0)
      ULONG Canceled : 1;               // offset: 0x0 (0)
      ULONG Ready : 1;                  // offset: 0x0 (0)
      ULONG ReleaseMessage : 1;         // offset: 0x0 (0)
      ULONG SharedQuota : 1;            // offset: 0x0 (0)
      ULONG ReplyWaitReply : 1;         // offset: 0x0 (0)
      ULONG OwnerPortReference : 1;     // offset: 0x0 (0)
      ULONG ReceiverReference : 1;      // offset: 0x0 (0)
      ULONG ViewAttributeRetrieved : 1; // offset: 0x0 (0)
      ULONG InDispatch : 1;             // offset: 0x0 (0)
    } s1;                               // offset: 0x28 (40)
    ULONG State;                        // offset: 0x28 (40)

  } u1;            // offset: 0x28 (40)
  LONG SequenceNo; // offset: 0x2c (44)
  union {
    struct _EPROCESS *QuotaProcess; // offset: 0x30 (48)
    VOID *QuotaBlock;               // offset: 0x30 (48)
  };
  struct _ALPC_PORT *CancelSequencePort;              // offset: 0x38 (56)
  struct _ALPC_PORT *CancelQueuePort;                 // offset: 0x40 (64)
  LONG CancelSequenceNo;                              // offset: 0x48 (72)
  struct _LIST_ENTRY CancelListEntry;                 // offset: 0x50 (80)
  struct _KALPC_RESERVE *Reserve;                     // offset: 0x60 (96)
  struct _KALPC_MESSAGE_ATTRIBUTES MessageAttributes; // offset: 0x68 (104)
  VOID *DataUserVa;                                   // offset: 0xb0 (176)
  struct _ALPC_COMMUNICATION_INFO *CommunicationInfo; // offset: 0xb8 (184)
  struct _ALPC_PORT *ConnectionPort;                  // offset: 0xc0 (192)
  struct _ETHREAD *ServerThread;                      // offset: 0xc8 (200)
  VOID *WakeReference;                                // offset: 0xd0 (208)
  VOID *WakeReference2;                               // offset: 0xd8 (216)
  VOID *ExtensionBuffer;                              // offset: 0xe0 (224)
  ULONGLONG ExtensionBufferSize;                      // offset: 0xe8 (232)
  struct _PORT_MESSAGE PortMessage;                   // offset: 0xf0 (240)
};

// 0x40 (64) bytes
struct _ALPC_DISPATCH_CONTEXT {
  struct _ALPC_PORT *PortObject;                      // offset: 0x0 (0)
  struct _KALPC_MESSAGE *Message;                     // offset: 0x8 (8)
  struct _ALPC_COMMUNICATION_INFO *CommunicationInfo; // offset: 0x10 (16)
  struct _ETHREAD *TargetThread;                      // offset: 0x18 (24)
  struct _ALPC_PORT *TargetPort;                      // offset: 0x20 (32)
  union _KALPC_DIRECT_EVENT DirectEvent;              // offset: 0x28 (40)
  ULONG Flags;                                        // offset: 0x30 (48)
  USHORT TotalLength;                                 // offset: 0x34 (52)
  USHORT Type;                                        // offset: 0x36 (54)
  USHORT DataInfoOffset;                              // offset: 0x38 (56)
  UCHAR SignalCompletion;                             // offset: 0x3a (58)
  UCHAR PostedToCompletionList;                       // offset: 0x3b (59)
};

// 0x30 (48) bytes
struct _KALPC_RESERVE {
  struct _ALPC_PORT *OwnerPort;           // offset: 0x0 (0)
  struct _ALPC_HANDLE_TABLE *HandleTable; // offset: 0x8 (8)
  VOID *Handle;                           // offset: 0x10 (16)
  struct _KALPC_MESSAGE *Message;         // offset: 0x18 (24)
  ULONGLONG Size;                         // offset: 0x20 (32)
  LONG Active;                            // offset: 0x28 (40)
};

// 0x48 (72) bytes
struct _ALPC_COMMUNICATION_INFO {
  struct _ALPC_PORT *ConnectionPort;          // offset: 0x0 (0)
  struct _ALPC_PORT *ServerCommunicationPort; // offset: 0x8 (8)
  struct _ALPC_PORT *ClientCommunicationPort; // offset: 0x10 (16)
  struct _LIST_ENTRY CommunicationList;       // offset: 0x18 (24)
  struct _ALPC_HANDLE_TABLE HandleTable;      // offset: 0x28 (40)
  struct _KALPC_MESSAGE *CloseMessage;        // offset: 0x40 (64)
};

// 0xa0 (160) bytes
struct _ALPC_COMPLETION_LIST {
  struct _LIST_ENTRY Entry;                    // offset: 0x0 (0)
  struct _EPROCESS *OwnerProcess;              // offset: 0x10 (16)
  struct _EX_PUSH_LOCK CompletionListLock;     // offset: 0x18 (24)
  struct _MDL *Mdl;                            // offset: 0x20 (32)
  VOID *UserVa;                                // offset: 0x28 (40)
  VOID *UserLimit;                             // offset: 0x30 (48)
  VOID *DataUserVa;                            // offset: 0x38 (56)
  VOID *SystemVa;                              // offset: 0x40 (64)
  ULONGLONG TotalSize;                         // offset: 0x48 (72)
  struct _ALPC_COMPLETION_LIST_HEADER *Header; // offset: 0x50 (80)
  VOID *List;                                  // offset: 0x58 (88)
  ULONGLONG ListSize;                          // offset: 0x60 (96)
  VOID *Bitmap;                                // offset: 0x68 (104)
  ULONGLONG BitmapSize;                        // offset: 0x70 (112)
  VOID *Data;                                  // offset: 0x78 (120)
  ULONGLONG DataSize;                          // offset: 0x80 (128)
  ULONG BitmapLimit;                           // offset: 0x88 (136)
  ULONG BitmapNextHint;                        // offset: 0x8c (140)
  ULONG ConcurrencyCount;                      // offset: 0x90 (144)
  ULONG AttributeFlags;                        // offset: 0x94 (148)
  ULONG AttributeSize;                         // offset: 0x98 (152)
};

// 0x1d8 (472) bytes
struct _ALPC_PORT {
  struct _LIST_ENTRY PortListEntry;                   // offset: 0x0 (0)
  struct _ALPC_COMMUNICATION_INFO *CommunicationInfo; // offset: 0x10 (16)
  struct _EPROCESS *OwnerProcess;                     // offset: 0x18 (24)
  VOID *CompletionPort;                               // offset: 0x20 (32)
  VOID *CompletionKey;                                // offset: 0x28 (40)
  struct _ALPC_COMPLETION_PACKET_LOOKASIDE
      *CompletionPacketLookaside;                 // offset: 0x30 (48)
  VOID *PortContext;                              // offset: 0x38 (56)
  struct _SECURITY_CLIENT_CONTEXT StaticSecurity; // offset: 0x40 (64)
  struct _EX_PUSH_LOCK IncomingQueueLock;         // offset: 0x88 (136)
  struct _LIST_ENTRY MainQueue;                   // offset: 0x90 (144)
  struct _LIST_ENTRY LargeMessageQueue;           // offset: 0xa0 (160)
  struct _EX_PUSH_LOCK PendingQueueLock;          // offset: 0xb0 (176)
  struct _LIST_ENTRY PendingQueue;                // offset: 0xb8 (184)
  struct _EX_PUSH_LOCK DirectQueueLock;           // offset: 0xc8 (200)
  struct _LIST_ENTRY DirectQueue;                 // offset: 0xd0 (208)
  struct _EX_PUSH_LOCK WaitQueueLock;             // offset: 0xe0 (224)
  struct _LIST_ENTRY WaitQueue;                   // offset: 0xe8 (232)
  union {
    struct _KSEMAPHORE *Semaphore; // offset: 0xf8 (248)
    struct _KEVENT *DummyEvent;    // offset: 0xf8 (248)
  };
  struct _ALPC_PORT_ATTRIBUTES PortAttributes;  // offset: 0x100 (256)
  struct _EX_PUSH_LOCK ResourceListLock;        // offset: 0x148 (328)
  struct _LIST_ENTRY ResourceListHead;          // offset: 0x150 (336)
  struct _EX_PUSH_LOCK PortObjectLock;          // offset: 0x160 (352)
  struct _ALPC_COMPLETION_LIST *CompletionList; // offset: 0x168 (360)
  struct _CALLBACK_OBJECT *CallbackObject;      // offset: 0x170 (368)
  VOID *CallbackContext;                        // offset: 0x178 (376)
  struct _LIST_ENTRY CanceledQueue;             // offset: 0x180 (384)
  LONG SequenceNo;                              // offset: 0x190 (400)
  LONG ReferenceNo;                             // offset: 0x194 (404)
  struct _PALPC_PORT_REFERENCE_WAIT_BLOCK
      *ReferenceNoWait; // offset: 0x198 (408)
  union {
    struct {
      ULONG Initialized : 1;          // offset: 0x0 (0)
      ULONG Type : 2;                 // offset: 0x0 (0)
      ULONG ConnectionPending : 1;    // offset: 0x0 (0)
      ULONG ConnectionRefused : 1;    // offset: 0x0 (0)
      ULONG Disconnected : 1;         // offset: 0x0 (0)
      ULONG Closed : 1;               // offset: 0x0 (0)
      ULONG NoFlushOnClose : 1;       // offset: 0x0 (0)
      ULONG ReturnExtendedInfo : 1;   // offset: 0x0 (0)
      ULONG Waitable : 1;             // offset: 0x0 (0)
      ULONG DynamicSecurity : 1;      // offset: 0x0 (0)
      ULONG Wow64CompletionList : 1;  // offset: 0x0 (0)
      ULONG Lpc : 1;                  // offset: 0x0 (0)
      ULONG LpcToLpc : 1;             // offset: 0x0 (0)
      ULONG HasCompletionList : 1;    // offset: 0x0 (0)
      ULONG HadCompletionList : 1;    // offset: 0x0 (0)
      ULONG EnableCompletionList : 1; // offset: 0x0 (0)
    } s1;                             // offset: 0x1a0 (416)
    ULONG State;                      // offset: 0x1a0 (416)

  } u1;                                  // offset: 0x1a0 (416)
  struct _ALPC_PORT *TargetQueuePort;    // offset: 0x1a8 (424)
  struct _ALPC_PORT *TargetSequencePort; // offset: 0x1b0 (432)
  struct _KALPC_MESSAGE *CachedMessage;  // offset: 0x1b8 (440)
  ULONG MainQueueLength;                 // offset: 0x1c0 (448)
  ULONG LargeMessageQueueLength;         // offset: 0x1c4 (452)
  ULONG PendingQueueLength;              // offset: 0x1c8 (456)
  ULONG DirectQueueLength;               // offset: 0x1cc (460)
  ULONG CanceledQueueLength;             // offset: 0x1d0 (464)
  ULONG WaitQueueLength;                 // offset: 0x1d4 (468)
};

// 0x48 (72) bytes
struct _KALPC_SECTION {
  VOID *SectionObject;                    // offset: 0x0 (0)
  ULONGLONG Size;                         // offset: 0x8 (8)
  struct _ALPC_HANDLE_TABLE *HandleTable; // offset: 0x10 (16)
  VOID *SectionHandle;                    // offset: 0x18 (24)
  struct _EPROCESS *OwnerProcess;         // offset: 0x20 (32)
  struct _ALPC_PORT *OwnerPort;           // offset: 0x28 (40)
  union {
    struct {
      ULONG Internal : 1; // offset: 0x0 (0)
      ULONG Secure : 1;   // offset: 0x0 (0)
    } s1;                 // offset: 0x30 (48)

  } u1;                              // offset: 0x30 (48)
  ULONG NumberOfRegions;             // offset: 0x34 (52)
  struct _LIST_ENTRY RegionListHead; // offset: 0x38 (56)
};

// 0x58 (88) bytes
struct _KALPC_REGION {
  struct _LIST_ENTRY RegionListEntry; // offset: 0x0 (0)
  struct _KALPC_SECTION *Section;     // offset: 0x10 (16)
  ULONGLONG Offset;                   // offset: 0x18 (24)
  ULONGLONG Size;                     // offset: 0x20 (32)
  ULONGLONG ViewSize;                 // offset: 0x28 (40)
  union {
    struct {
      ULONG Secure : 1; // offset: 0x0 (0)
    } s1;               // offset: 0x30 (48)

  } u1;                              // offset: 0x30 (48)
  ULONG NumberOfViews;               // offset: 0x34 (52)
  struct _LIST_ENTRY ViewListHead;   // offset: 0x38 (56)
  struct _KALPC_VIEW *ReadOnlyView;  // offset: 0x48 (72)
  struct _KALPC_VIEW *ReadWriteView; // offset: 0x50 (80)
};

// 0x60 (96) bytes
struct _KALPC_VIEW {
  struct _LIST_ENTRY ViewListEntry; // offset: 0x0 (0)
  struct _KALPC_REGION *Region;     // offset: 0x10 (16)
  struct _ALPC_PORT *OwnerPort;     // offset: 0x18 (24)
  struct _EPROCESS *OwnerProcess;   // offset: 0x20 (32)
  VOID *Address;                    // offset: 0x28 (40)
  ULONGLONG Size;                   // offset: 0x30 (48)
  VOID *SecureViewHandle;           // offset: 0x38 (56)
  VOID *WriteAccessHandle;          // offset: 0x40 (64)
  union {
    struct {
      ULONG WriteAccess : 1; // offset: 0x0 (0)
      ULONG AutoRelease : 1; // offset: 0x0 (0)
      ULONG ForceUnlink : 1; // offset: 0x0 (0)
      ULONG SystemSpace : 1; // offset: 0x0 (0)
    } s1;                    // offset: 0x48 (72)

  } u1;                                    // offset: 0x48 (72)
  ULONG NumberOfOwnerMessages;             // offset: 0x4c (76)
  struct _LIST_ENTRY ProcessViewListEntry; // offset: 0x50 (80)
};

// 0x88 (136) bytes
struct _WORK_QUEUE_ENTRY {
  struct _LIST_ENTRY WorkQueueLinks; // offset: 0x0 (0)
  union {
    struct {
      struct _FILE_OBJECT *FileObject; // offset: 0x0 (0)
      VOID *DiskIoAttribution;         // offset: 0x8 (8)
    } Read;                            // offset: 0x10 (16)
    struct {
      struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x0 (0)
    } Write;                                    // offset: 0x10 (16)
    struct {
      struct _KEVENT *Event; // offset: 0x0 (0)
    } Event;                 // offset: 0x10 (16)
    struct {
      ULONG Reason; // offset: 0x0 (0)
    } Notification; // offset: 0x10 (16)
    struct {
      struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x0 (0)
      struct _IO_STATUS_BLOCK *IoStatus;        // offset: 0x8 (8)
      struct _KEVENT CallerWaitEvent;           // offset: 0x10 (16)
      UCHAR IsLowPriWriteBehind;                // offset: 0x28 (40)
    } LowPriWrite;                              // offset: 0x10 (16)
    struct {
      struct _SHARED_CACHE_MAP *SharedCacheMap;       // offset: 0x0 (0)
      union _LARGE_INTEGER FileOffset;                // offset: 0x8 (8)
      struct _FILE_OBJECT *FileObject;                // offset: 0x10 (16)
      ULONG Length;                                   // offset: 0x18 (24)
      struct _SINGLE_LIST_ENTRY *PrefetchList;        // offset: 0x20 (32)
      ULONG PrefetchPagePriority;                     // offset: 0x28 (40)
      struct _MDL *Mdl;                               // offset: 0x30 (48)
      struct _IO_STATUS_BLOCK *IoStatusBlock;         // offset: 0x38 (56)
      struct _CC_ASYNC_READ_CONTEXT *CallbackContext; // offset: 0x40 (64)
      struct _EPROCESS *OriginatingProcess;           // offset: 0x48 (72)
      struct _ETHREAD *IoIssuerThread;                // offset: 0x50 (80)
      VOID *DiskIoAttribution;                        // offset: 0x58 (88)
      CHAR RequestorMode;                             // offset: 0x60 (96)
      ULONG NestingLevel;                             // offset: 0x64 (100)
    } AsyncRead;                                      // offset: 0x10 (16)

  } Parameters;                    // offset: 0x10 (16)
  UCHAR Function;                  // offset: 0x78 (120)
  struct _CC_PARTITION *Partition; // offset: 0x80 (128)
};

// 0x28 (40) bytes
struct _KRESOURCEMANAGER_COMPLETION_BINDING {
  struct _LIST_ENTRY NotificationListHead; // offset: 0x0 (0)
  VOID *Port;                              // offset: 0x10 (16)
  ULONGLONG Key;                           // offset: 0x18 (24)
  struct _EPROCESS *BindingProcess;        // offset: 0x20 (32)
};

// 0x250 (592) bytes
struct _KRESOURCEMANAGER {
  struct _KEVENT NotificationAvailable;           // offset: 0x0 (0)
  ULONG cookie;                                   // offset: 0x18 (24)
  enum _KRESOURCEMANAGER_STATE State;             // offset: 0x1c (28)
  ULONG Flags;                                    // offset: 0x20 (32)
  struct _KMUTANT Mutex;                          // offset: 0x28 (40)
  struct _KTMOBJECT_NAMESPACE_LINK NamespaceLink; // offset: 0x60 (96)
  struct _GUID RmId;                              // offset: 0x88 (136)
  struct _KQUEUE NotificationQueue;               // offset: 0x98 (152)
  struct _KMUTANT NotificationMutex;              // offset: 0xd8 (216)
  struct _LIST_ENTRY EnlistmentHead;              // offset: 0x110 (272)
  ULONG EnlistmentCount;                          // offset: 0x120 (288)
  LONG (*NotificationRoutine)
  (struct _KENLISTMENT *arg1, VOID *arg2, VOID *arg3, ULONG arg4,
   union _LARGE_INTEGER *arg5, ULONG arg6, VOID *arg7); // offset: 0x128 (296)
  VOID *Key;                                            // offset: 0x130 (304)
  struct _LIST_ENTRY ProtocolListHead;                  // offset: 0x138 (312)
  struct _LIST_ENTRY PendingPropReqListHead;            // offset: 0x148 (328)
  struct _LIST_ENTRY CRMListEntry;                      // offset: 0x158 (344)
  struct _KTM *Tm;                                      // offset: 0x168 (360)
  struct _UNICODE_STRING Description;                   // offset: 0x170 (368)
  struct _KTMOBJECT_NAMESPACE Enlistments;              // offset: 0x180 (384)
  struct _KRESOURCEMANAGER_COMPLETION_BINDING
      CompletionBinding; // offset: 0x228 (552)
};

// 0x3c0 (960) bytes
struct _KTM {
  ULONG cookie;                                     // offset: 0x0 (0)
  struct _KMUTANT Mutex;                            // offset: 0x8 (8)
  enum KTM_STATE State;                             // offset: 0x40 (64)
  struct _KTMOBJECT_NAMESPACE_LINK NamespaceLink;   // offset: 0x48 (72)
  struct _GUID TmIdentity;                          // offset: 0x70 (112)
  ULONG Flags;                                      // offset: 0x80 (128)
  ULONG VolatileFlags;                              // offset: 0x84 (132)
  struct _UNICODE_STRING LogFileName;               // offset: 0x88 (136)
  struct _FILE_OBJECT *LogFileObject;               // offset: 0x98 (152)
  VOID *MarshallingContext;                         // offset: 0xa0 (160)
  VOID *LogManagementContext;                       // offset: 0xa8 (168)
  struct _KTMOBJECT_NAMESPACE Transactions;         // offset: 0xb0 (176)
  struct _KTMOBJECT_NAMESPACE ResourceManagers;     // offset: 0x158 (344)
  struct _KMUTANT LsnOrderedMutex;                  // offset: 0x200 (512)
  struct _LIST_ENTRY LsnOrderedList;                // offset: 0x238 (568)
  union _LARGE_INTEGER CommitVirtualClock;          // offset: 0x248 (584)
  struct _FAST_MUTEX CommitVirtualClockMutex;       // offset: 0x250 (592)
  union _CLS_LSN BaseLsn;                           // offset: 0x288 (648)
  union _CLS_LSN CurrentReadLsn;                    // offset: 0x290 (656)
  union _CLS_LSN LastRecoveredLsn;                  // offset: 0x298 (664)
  VOID *TmRmHandle;                                 // offset: 0x2a0 (672)
  struct _KRESOURCEMANAGER *TmRm;                   // offset: 0x2a8 (680)
  struct _KEVENT LogFullNotifyEvent;                // offset: 0x2b0 (688)
  struct _WORK_QUEUE_ITEM CheckpointWorkItem;       // offset: 0x2c8 (712)
  union _CLS_LSN CheckpointTargetLsn;               // offset: 0x2e8 (744)
  struct _WORK_QUEUE_ITEM LogFullCompletedWorkItem; // offset: 0x2f0 (752)
  struct _ERESOURCE LogWriteResource;               // offset: 0x310 (784)
  ULONG LogFlags;                                   // offset: 0x378 (888)
  LONG LogFullStatus;                               // offset: 0x37c (892)
  LONG RecoveryStatus;                              // offset: 0x380 (896)
  union _CLS_LSN LastCheckBaseLsn;                  // offset: 0x388 (904)
  struct _LIST_ENTRY RestartOrderedList;            // offset: 0x390 (912)
  struct _WORK_QUEUE_ITEM OfflineWorkItem;          // offset: 0x3a0 (928)
};

// 0x1e0 (480) bytes
struct _KENLISTMENT {
  ULONG cookie;                                      // offset: 0x0 (0)
  struct _KTMOBJECT_NAMESPACE_LINK NamespaceLink;    // offset: 0x8 (8)
  struct _GUID EnlistmentId;                         // offset: 0x30 (48)
  struct _KMUTANT Mutex;                             // offset: 0x40 (64)
  struct _LIST_ENTRY NextSameTx;                     // offset: 0x78 (120)
  struct _LIST_ENTRY NextSameRm;                     // offset: 0x88 (136)
  struct _KRESOURCEMANAGER *ResourceManager;         // offset: 0x98 (152)
  struct _KTRANSACTION *Transaction;                 // offset: 0xa0 (160)
  enum _KENLISTMENT_STATE State;                     // offset: 0xa8 (168)
  ULONG Flags;                                       // offset: 0xac (172)
  ULONG NotificationMask;                            // offset: 0xb0 (176)
  VOID *Key;                                         // offset: 0xb8 (184)
  ULONG KeyRefCount;                                 // offset: 0xc0 (192)
  VOID *RecoveryInformation;                         // offset: 0xc8 (200)
  ULONG RecoveryInformationLength;                   // offset: 0xd0 (208)
  VOID *DynamicNameInformation;                      // offset: 0xd8 (216)
  ULONG DynamicNameInformationLength;                // offset: 0xe0 (224)
  struct _KTMNOTIFICATION_PACKET *FinalNotification; // offset: 0xe8 (232)
  struct _KENLISTMENT *SupSubEnlistment;             // offset: 0xf0 (240)
  VOID *SupSubEnlHandle;                             // offset: 0xf8 (248)
  VOID *SubordinateTxHandle;                         // offset: 0x100 (256)
  struct _GUID CrmEnlistmentEnId;                    // offset: 0x108 (264)
  struct _GUID CrmEnlistmentTmId;                    // offset: 0x118 (280)
  struct _GUID CrmEnlistmentRmId;                    // offset: 0x128 (296)
  ULONG NextHistory;                                 // offset: 0x138 (312)
  struct _KENLISTMENT_HISTORY History[20];           // offset: 0x13c (316)
};

// 0x90 (144) bytes
struct _MI_PARTITION_STORES {
  union {
    LONG FlushCompleting : 1;  // offset: 0x0 (0)
    LONG FlushInProgress : 31; // offset: 0x0 (0)
    volatile LONG Long;        // offset: 0x0 (0)

  } WriteAllStoreHintedPages;                    // offset: 0x0 (0)
  ULONG VirtualPageFileNumber;                   // offset: 0x4 (4)
  ULONG Registered;                              // offset: 0x8 (8)
  ULONG ReadClusterSizeMax;                      // offset: 0xc (12)
  ULONG EvictFlushRequestCount;                  // offset: 0x10 (16)
  ULONG ModifiedWriteDisableCount;               // offset: 0x14 (20)
  ULONG WriteIssueFailures;                      // offset: 0x18 (24)
  ULONG WritesOutstanding;                       // offset: 0x1c (28)
  volatile LONG EvictFlushLock;                  // offset: 0x20 (32)
  struct _ETHREAD *EvictionThread;               // offset: 0x28 (40)
  struct _KEVENT EvictEvent;                     // offset: 0x30 (48)
  union _SLIST_HEADER WriteSupportSListHead;     // offset: 0x50 (80)
  struct _KEVENT EvictFlushCompleteEvent;        // offset: 0x60 (96)
  struct _RTL_BITMAP *ModifiedWriteFailedBitmap; // offset: 0x78 (120)
  struct _EPROCESS *StoreProcess;                // offset: 0x80 (128)
  ULONG DeleteStoredPages;                       // offset: 0x88 (136)
};

// 0x48 (72) bytes
struct _MM_PAGE_ACCESS_INFO_HEADER {
  struct _SINGLE_LIST_ENTRY Link; // offset: 0x0 (0)
  enum _MM_PAGE_ACCESS_TYPE Type; // offset: 0x8 (8)
  union {
    ULONG EmptySequenceNumber; // offset: 0xc (12)
    ULONG CurrentFileIndex;    // offset: 0xc (12)
  };
  ULONGLONG CreateTime; // offset: 0x10 (16)
  union {
    ULONGLONG EmptyTime;                    // offset: 0x18 (24)
    struct _MM_PAGE_ACCESS_INFO *TempEntry; // offset: 0x18 (24)
  };
  union {
    struct {
      struct _MM_PAGE_ACCESS_INFO *PageEntry; // offset: 0x20 (32)
      ULONGLONG *FileEntry;                   // offset: 0x28 (40)
      ULONGLONG *FirstFileEntry;              // offset: 0x30 (48)
      struct _EPROCESS *Process;              // offset: 0x38 (56)
      ULONG SessionId;                        // offset: 0x40 (64)
    };
    struct {
      ULONGLONG *PageFrameEntry;     // offset: 0x20 (32)
      ULONGLONG *LastPageFrameEntry; // offset: 0x28 (40)
    };
  };
};

// 0x90 (144) bytes
struct _MI_STANDBY_STATE {
  ULONGLONG FirstDecayPage;                            // offset: 0x0 (0)
  union _SLIST_HEADER PfnDecayFreeSList;               // offset: 0x10 (16)
  struct _MM_PAGE_ACCESS_INFO_HEADER *PfnRepurposeLog; // offset: 0x20 (32)
  struct _KDPC AllocatePfnRepurposeDpc;                // offset: 0x28 (40)
  union _SLIST_HEADER PageHeatListSlist;               // offset: 0x70 (112)
  volatile LONG PageHeatListDisableAllocation;         // offset: 0x80 (128)
};

// 0x80 (128) bytes
struct _MI_ACCESS_LOG_STATE {
  struct _MM_PAGE_ACCESS_INFO_HEADER *volatile CcAccessLog; // offset: 0x0 (0)
  struct _WORK_QUEUE_ITEM DisableAccessLogging;             // offset: 0x8 (8)
  ULONG Enabled;                                            // offset: 0x28 (40)
  ULONG MinLoggingPriority;                                 // offset: 0x2c (44)
  ULONGLONG AccessLoggingLock;                              // offset: 0x40 (64)
};

// 0x80 (128) bytes
struct _EPARTITION {
  VOID *MmPartition;                        // offset: 0x0 (0)
  VOID *CcPartition;                        // offset: 0x8 (8)
  VOID *ExPartition;                        // offset: 0x10 (16)
  LONGLONG HardReferenceCount;              // offset: 0x18 (24)
  LONGLONG OpenHandleCount;                 // offset: 0x20 (32)
  struct _LIST_ENTRY ActivePartitionLinks;  // offset: 0x28 (40)
  struct _EPARTITION *ParentPartition;      // offset: 0x38 (56)
  struct _WORK_QUEUE_ITEM TeardownWorkItem; // offset: 0x40 (64)
  struct _EX_PUSH_LOCK TeardownLock;        // offset: 0x60 (96)
  struct _EPROCESS *SystemProcess;          // offset: 0x68 (104)
  VOID *SystemProcessHandle;                // offset: 0x70 (112)
  union {
    ULONG PartitionFlags;    // offset: 0x78 (120)
    ULONG PairedWithJob : 1; // offset: 0x78 (120)
  };
};

// 0xa0 (160) bytes
struct _ETW_REALTIME_CONSUMER {
  struct _LIST_ENTRY Links;                      // offset: 0x0 (0)
  VOID *ProcessHandle;                           // offset: 0x10 (16)
  struct _EPROCESS *ProcessObject;               // offset: 0x18 (24)
  VOID *NextNotDelivered;                        // offset: 0x20 (32)
  VOID *RealtimeConnectContext;                  // offset: 0x28 (40)
  struct _KEVENT *DisconnectEvent;               // offset: 0x30 (48)
  struct _KEVENT *DataAvailableEvent;            // offset: 0x38 (56)
  ULONG *UserBufferCount;                        // offset: 0x40 (64)
  struct _SINGLE_LIST_ENTRY *UserBufferListHead; // offset: 0x48 (72)
  ULONG BuffersLost;                             // offset: 0x50 (80)
  ULONG EmptyBuffersCount;                       // offset: 0x54 (84)
  USHORT LoggerId;                               // offset: 0x58 (88)
  union {
    UCHAR Flags; // offset: 0x5a (90)
    struct {
      UCHAR ShutDownRequested : 1; // offset: 0x5a (90)
      UCHAR NewBuffersLost : 1;    // offset: 0x5a (90)
      UCHAR Disconnected : 1;      // offset: 0x5a (90)
      UCHAR Notified : 1;          // offset: 0x5a (90)
      UCHAR Wow : 1;               // offset: 0x5a (90)
    };
  };
  struct _RTL_BITMAP ReservedBufferSpaceBitMap; // offset: 0x60 (96)
  UCHAR *ReservedBufferSpace;                   // offset: 0x70 (112)
  ULONG ReservedBufferSpaceSize;                // offset: 0x78 (120)
  ULONG UserPagesAllocated;                     // offset: 0x7c (124)
  ULONG UserPagesReused;                        // offset: 0x80 (128)
  ULONG *EventsLostCount;                       // offset: 0x88 (136)
  ULONG *BuffersLostCount;                      // offset: 0x90 (144)
  struct _ETW_SILODRIVERSTATE *SiloState;       // offset: 0x98 (152)
};

// 0x550 (1360) bytes
struct _WMI_LOGGER_CONTEXT {
  ULONG LoggerId;                                      // offset: 0x0 (0)
  ULONG BufferSize;                                    // offset: 0x4 (4)
  ULONG MaximumEventSize;                              // offset: 0x8 (8)
  ULONG LoggerMode;                                    // offset: 0xc (12)
  LONG AcceptNewEvents;                                // offset: 0x10 (16)
  ULONG EventMarker[2];                                // offset: 0x14 (20)
  ULONG ErrorMarker;                                   // offset: 0x1c (28)
  ULONG SizeMask;                                      // offset: 0x20 (32)
  ULONGLONG GetCpuClock;                               // offset: 0x28 (40)
  struct _ETHREAD *LoggerThread;                       // offset: 0x30 (48)
  LONG LoggerStatus;                                   // offset: 0x38 (56)
  ULONG FailureReason;                                 // offset: 0x3c (60)
  struct _ETW_BUFFER_QUEUE BufferQueue;                // offset: 0x40 (64)
  struct _ETW_BUFFER_QUEUE OverflowQueue;              // offset: 0x50 (80)
  struct _LIST_ENTRY GlobalList;                       // offset: 0x60 (96)
  struct _LIST_ENTRY DebugIdTrackingList;              // offset: 0x70 (112)
  struct _ETW_DECODE_CONTROL_ENTRY *DecodeControlList; // offset: 0x80 (128)
  ULONG DecodeControlCount;                            // offset: 0x88 (136)
  union {
    struct _WMI_BUFFER_HEADER *BatchedBufferList; // offset: 0x90 (144)
    struct _EX_FAST_REF CurrentBuffer;            // offset: 0x90 (144)
  };
  struct _UNICODE_STRING LoggerName;                 // offset: 0x98 (152)
  struct _UNICODE_STRING LogFileName;                // offset: 0xa8 (168)
  struct _UNICODE_STRING LogFilePattern;             // offset: 0xb8 (184)
  struct _UNICODE_STRING NewLogFileName;             // offset: 0xc8 (200)
  ULONG ClockType;                                   // offset: 0xd8 (216)
  ULONG LastFlushedBuffer;                           // offset: 0xdc (220)
  ULONG FlushTimer;                                  // offset: 0xe0 (224)
  ULONG FlushThreshold;                              // offset: 0xe4 (228)
  union _LARGE_INTEGER ByteOffset;                   // offset: 0xe8 (232)
  ULONG MinimumBuffers;                              // offset: 0xf0 (240)
  volatile LONG BuffersAvailable;                    // offset: 0xf4 (244)
  volatile LONG NumberOfBuffers;                     // offset: 0xf8 (248)
  ULONG MaximumBuffers;                              // offset: 0xfc (252)
  volatile ULONG EventsLost;                         // offset: 0x100 (256)
  volatile LONG PeakBuffersCount;                    // offset: 0x104 (260)
  ULONG BuffersWritten;                              // offset: 0x108 (264)
  ULONG LogBuffersLost;                              // offset: 0x10c (268)
  ULONG RealTimeBuffersDelivered;                    // offset: 0x110 (272)
  ULONG RealTimeBuffersLost;                         // offset: 0x114 (276)
  LONG *SequencePtr;                                 // offset: 0x118 (280)
  ULONG LocalSequence;                               // offset: 0x120 (288)
  struct _GUID InstanceGuid;                         // offset: 0x124 (292)
  ULONG MaximumFileSize;                             // offset: 0x134 (308)
  LONG FileCounter;                                  // offset: 0x138 (312)
  enum _POOL_TYPE PoolType;                          // offset: 0x13c (316)
  struct _ETW_REF_CLOCK ReferenceTime;               // offset: 0x140 (320)
  LONG CollectionOn;                                 // offset: 0x150 (336)
  ULONG ProviderInfoSize;                            // offset: 0x154 (340)
  struct _LIST_ENTRY Consumers;                      // offset: 0x158 (344)
  ULONG NumConsumers;                                // offset: 0x168 (360)
  struct _ETW_REALTIME_CONSUMER *TransitionConsumer; // offset: 0x170 (368)
  VOID *RealtimeLogfileHandle;                       // offset: 0x178 (376)
  struct _UNICODE_STRING RealtimeLogfileName;        // offset: 0x180 (384)
  union _LARGE_INTEGER RealtimeWriteOffset;          // offset: 0x190 (400)
  union _LARGE_INTEGER RealtimeReadOffset;           // offset: 0x198 (408)
  union _LARGE_INTEGER RealtimeLogfileSize;          // offset: 0x1a0 (416)
  ULONGLONG RealtimeLogfileUsage;                    // offset: 0x1a8 (424)
  ULONGLONG RealtimeMaximumFileSize;                 // offset: 0x1b0 (432)
  ULONG RealtimeBuffersSaved;                        // offset: 0x1b8 (440)
  struct _ETW_REF_CLOCK RealtimeReferenceTime;       // offset: 0x1c0 (448)
  enum _ETW_RT_EVENT_LOSS NewRTEventsLost;           // offset: 0x1d0 (464)
  struct _KEVENT LoggerEvent;                        // offset: 0x1d8 (472)
  struct _KEVENT FlushEvent;                         // offset: 0x1f0 (496)
  struct _KTIMER FlushTimeOutTimer;                  // offset: 0x208 (520)
  struct _KDPC LoggerDpc;                            // offset: 0x248 (584)
  struct _KMUTANT LoggerMutex;                       // offset: 0x288 (648)
  struct _EX_PUSH_LOCK LoggerLock;                   // offset: 0x2c0 (704)
  union {
    ULONGLONG BufferListSpinLock;            // offset: 0x2c8 (712)
    struct _EX_PUSH_LOCK BufferListPushLock; // offset: 0x2c8 (712)
  };
  struct _SECURITY_CLIENT_CONTEXT ClientSecurityContext; // offset: 0x2d0 (720)
  struct _TOKEN_ACCESS_INFORMATION
      *TokenAccessInformation;            // offset: 0x318 (792)
  struct _EX_FAST_REF SecurityDescriptor; // offset: 0x320 (800)
  union _LARGE_INTEGER StartTime;         // offset: 0x328 (808)
  VOID *LogFileHandle;                    // offset: 0x330 (816)
  LONGLONG BufferSequenceNumber;          // offset: 0x338 (824)
  union {
    ULONG Flags; // offset: 0x340 (832)
    struct {
      ULONG Persistent : 1;                  // offset: 0x340 (832)
      ULONG AutoLogger : 1;                  // offset: 0x340 (832)
      ULONG FsReady : 1;                     // offset: 0x340 (832)
      ULONG RealTime : 1;                    // offset: 0x340 (832)
      ULONG Wow : 1;                         // offset: 0x340 (832)
      ULONG KernelTrace : 1;                 // offset: 0x340 (832)
      ULONG NoMoreEnable : 1;                // offset: 0x340 (832)
      ULONG StackTracing : 1;                // offset: 0x340 (832)
      ULONG ErrorLogged : 1;                 // offset: 0x340 (832)
      ULONG RealtimeLoggerContextFreed : 1;  // offset: 0x340 (832)
      ULONG PebsTracing : 1;                 // offset: 0x340 (832)
      ULONG PmcCounters : 1;                 // offset: 0x340 (832)
      ULONG PageAlignBuffers : 1;            // offset: 0x340 (832)
      ULONG StackLookasideListAllocated : 1; // offset: 0x340 (832)
      ULONG SecurityTrace : 1;               // offset: 0x340 (832)
      ULONG LastBranchTracing : 1;           // offset: 0x340 (832)
      ULONG SystemLoggerIndex : 8;           // offset: 0x340 (832)
      ULONG StackCaching : 1;                // offset: 0x340 (832)
      ULONG ProviderTracking : 1;            // offset: 0x340 (832)
      ULONG ProcessorTrace : 1;              // offset: 0x340 (832)
      ULONG QpcDeltaTracking : 1;            // offset: 0x340 (832)
      ULONG MarkerBufferSaved : 1;           // offset: 0x340 (832)
      ULONG LargeMdlPages : 1;               // offset: 0x340 (832)
      ULONG ExcludeKernelStack : 1;          // offset: 0x340 (832)
      ULONG SpareFlags2 : 1;                 // offset: 0x340 (832)
    };
  };
  union {
    volatile ULONG RequestFlag; // offset: 0x344 (836)
    struct {
      ULONG DbgRequestNewFile : 1;            // offset: 0x344 (836)
      ULONG DbgRequestUpdateFile : 1;         // offset: 0x344 (836)
      ULONG DbgRequestFlush : 1;              // offset: 0x344 (836)
      ULONG DbgRequestDisableRealtime : 1;    // offset: 0x344 (836)
      ULONG DbgRequestDisconnectConsumer : 1; // offset: 0x344 (836)
      ULONG DbgRequestConnectConsumer : 1;    // offset: 0x344 (836)
      ULONG DbgRequestNotifyConsumer : 1;     // offset: 0x344 (836)
      ULONG DbgRequestUpdateHeader : 1;       // offset: 0x344 (836)
      ULONG DbgRequestDeferredFlush : 1;      // offset: 0x344 (836)
      ULONG DbgRequestDeferredFlushTimer : 1; // offset: 0x344 (836)
      ULONG DbgRequestFlushTimer : 1;         // offset: 0x344 (836)
      ULONG DbgRequestUpdateDebugger : 1;     // offset: 0x344 (836)
      ULONG DbgSpareRequestFlags : 20;        // offset: 0x344 (836)
    };
  };
  struct _ETW_STACK_TRACE_BLOCK StackTraceBlock; // offset: 0x350 (848)
  struct _RTL_BITMAP HookIdMap;                  // offset: 0x3d0 (976)
  struct _ETW_STACK_CACHE *StackCache;           // offset: 0x3e0 (992)
  struct _ETW_PMC_SUPPORT *PmcData;              // offset: 0x3e8 (1000)
  struct _ETW_LBR_SUPPORT *LbrData;              // offset: 0x3f0 (1008)
  struct _ETW_IPT_SUPPORT *IptData;              // offset: 0x3f8 (1016)
  struct _LIST_ENTRY BinaryTrackingList;         // offset: 0x400 (1024)
  struct _WMI_BUFFER_HEADER **ScratchArray;      // offset: 0x410 (1040)
  struct _DISALLOWED_GUIDS DisallowedGuids;      // offset: 0x418 (1048)
  LONGLONG RelativeTimerDueTime;                 // offset: 0x428 (1064)
  struct _PERIODIC_CAPTURE_STATE_GUIDS
      PeriodicCaptureStateGuids;               // offset: 0x430 (1072)
  struct _EX_TIMER *PeriodicCaptureStateTimer; // offset: 0x440 (1088)
  enum _ETW_PERIODIC_TIMER_STATE
      PeriodicCaptureStateTimerState;                   // offset: 0x448 (1096)
  struct _ETW_SOFT_RESTART_CONTEXT *SoftRestartContext; // offset: 0x450 (1104)
  struct _ETW_SILODRIVERSTATE *SiloState;               // offset: 0x458 (1112)
  struct _WORK_QUEUE_ITEM CompressionWorkItem;          // offset: 0x460 (1120)
  LONG CompressionWorkItemState;                        // offset: 0x480 (1152)
  struct _EX_PUSH_LOCK CompressionLock;                 // offset: 0x488 (1160)
  struct _WMI_BUFFER_HEADER *CompressionTarget;         // offset: 0x490 (1168)
  VOID *CompressionWorkspace;                           // offset: 0x498 (1176)
  LONG CompressionOn;                                   // offset: 0x4a0 (1184)
  ULONG CompressionRatioGuess;                          // offset: 0x4a4 (1188)
  ULONG PartialBufferCompressionLevel;                  // offset: 0x4a8 (1192)
  enum ETW_COMPRESSION_RESUMPTION_MODE
      CompressionResumptionMode;                       // offset: 0x4ac (1196)
  struct _SINGLE_LIST_ENTRY PlaceholderList;           // offset: 0x4b0 (1200)
  struct _KDPC CompressionDpc;                         // offset: 0x4b8 (1208)
  union _LARGE_INTEGER LastBufferSwitchTime;           // offset: 0x4f8 (1272)
  union _LARGE_INTEGER BufferWriteDuration;            // offset: 0x500 (1280)
  union _LARGE_INTEGER BufferCompressDuration;         // offset: 0x508 (1288)
  LONGLONG ReferenceQpcDelta;                          // offset: 0x510 (1296)
  struct _ETW_EVENT_CALLBACK_CONTEXT *CallbackContext; // offset: 0x518 (1304)
  union _LARGE_INTEGER *LastDroppedTime;               // offset: 0x520 (1312)
  union _LARGE_INTEGER *FlushingLastDroppedTime;       // offset: 0x528 (1320)
  LONGLONG FlushingSequenceNumber;                     // offset: 0x530 (1328)
  struct _ETW_PARTITION_CONTEXT PartitionContext;      // offset: 0x538 (1336)
  struct _MDL *BufferMdl;                              // offset: 0x540 (1344)
};

// 0x150 (336) bytes
struct _DRIVER_OBJECT {
  SHORT Type;                                // offset: 0x0 (0)
  SHORT Size;                                // offset: 0x2 (2)
  struct _DEVICE_OBJECT *DeviceObject;       // offset: 0x8 (8)
  ULONG Flags;                               // offset: 0x10 (16)
  VOID *DriverStart;                         // offset: 0x18 (24)
  ULONG DriverSize;                          // offset: 0x20 (32)
  VOID *DriverSection;                       // offset: 0x28 (40)
  struct _DRIVER_EXTENSION *DriverExtension; // offset: 0x30 (48)
  struct _UNICODE_STRING DriverName;         // offset: 0x38 (56)
  struct _UNICODE_STRING *HardwareDatabase;  // offset: 0x48 (72)
  struct _FAST_IO_DISPATCH *FastIoDispatch;  // offset: 0x50 (80)
  LONG (*DriverInit)
  (struct _DRIVER_OBJECT *arg1,
   struct _UNICODE_STRING *arg2); // offset: 0x58 (88)
  VOID (*DriverStartIo)
  (struct _DEVICE_OBJECT *arg1, struct _IRP *arg2);  // offset: 0x60 (96)
  VOID (*DriverUnload)(struct _DRIVER_OBJECT *arg1); // offset: 0x68 (104)
  LONG (*MajorFunction[28])
  (struct _DEVICE_OBJECT *arg1, struct _IRP *arg2); // offset: 0x70 (112)
};

// 0xb0 (176) bytes
struct _BUS_HANDLER {
  ULONG Version;                          // offset: 0x0 (0)
  enum _INTERFACE_TYPE InterfaceType;     // offset: 0x4 (4)
  enum _BUS_DATA_TYPE ConfigurationType;  // offset: 0x8 (8)
  ULONG BusNumber;                        // offset: 0xc (12)
  struct _DEVICE_OBJECT *DeviceObject;    // offset: 0x10 (16)
  struct _BUS_HANDLER *ParentHandler;     // offset: 0x18 (24)
  VOID *BusData;                          // offset: 0x20 (32)
  ULONG DeviceControlExtensionSize;       // offset: 0x28 (40)
  struct _SUPPORTED_RANGES *BusAddresses; // offset: 0x30 (48)
  ULONG Reserved[4];                      // offset: 0x38 (56)
  ULONG (*GetBusData)
  (struct _BUS_HANDLER *arg1, struct _BUS_HANDLER *arg2, ULONG arg3, VOID *arg4,
   ULONG arg5, ULONG arg6); // offset: 0x48 (72)
  ULONG (*SetBusData)
  (struct _BUS_HANDLER *arg1, struct _BUS_HANDLER *arg2, ULONG arg3, VOID *arg4,
   ULONG arg5, ULONG arg6); // offset: 0x50 (80)
  LONG (*AdjustResourceList)
  (struct _BUS_HANDLER *arg1, struct _BUS_HANDLER *arg2,
   struct _IO_RESOURCE_REQUIREMENTS_LIST **arg3); // offset: 0x58 (88)
  LONG (*AssignSlotResources)
  (struct _BUS_HANDLER *arg1, struct _BUS_HANDLER *arg2,
   struct _UNICODE_STRING *arg3, struct _UNICODE_STRING *arg4,
   struct _DRIVER_OBJECT *arg5, struct _DEVICE_OBJECT *arg6, ULONG arg7,
   struct _CM_RESOURCE_LIST **arg8); // offset: 0x60 (96)
  UCHAR (*TranslateBusAddress)
  (struct _BUS_HANDLER *arg1, struct _BUS_HANDLER *arg2,
   union _LARGE_INTEGER arg3, ULONG *arg4,
   union _LARGE_INTEGER *arg5); // offset: 0x68 (104)
  VOID *Spare1;                 // offset: 0x70 (112)
  VOID *Spare2;                 // offset: 0x78 (120)
  VOID *Spare3;                 // offset: 0x80 (128)
  VOID *Spare4;                 // offset: 0x88 (136)
  VOID *Spare5;                 // offset: 0x90 (144)
  VOID *Spare6;                 // offset: 0x98 (152)
  VOID *Spare7;                 // offset: 0xa0 (160)
  VOID *Spare8;                 // offset: 0xa8 (168)
};

// 0x4b0 (1200) bytes
struct HAL_PRIVATE_DISPATCH {
  ULONG Version; // offset: 0x0 (0)
  struct _BUS_HANDLER *(*HalHandlerForBus)(enum _INTERFACE_TYPE arg1,
                                           ULONG arg2); // offset: 0x8 (8)
  struct _BUS_HANDLER *(*HalHandlerForConfigSpace)(
      enum _BUS_DATA_TYPE arg1, ULONG arg2); // offset: 0x10 (16)
  VOID (*HalLocateHiberRanges)(VOID *arg1);  // offset: 0x18 (24)
  LONG (*HalRegisterBusHandler)
  (enum _INTERFACE_TYPE arg1, enum _BUS_DATA_TYPE arg2, ULONG arg3,
   enum _INTERFACE_TYPE arg4, ULONG arg5, ULONG arg6,
   LONG (*arg7)(struct _BUS_HANDLER *arg1),
   struct _BUS_HANDLER **arg8);                            // offset: 0x20 (32)
  VOID (*HalSetWakeEnable)(UCHAR arg1);                    // offset: 0x28 (40)
  LONG (*HalSetWakeAlarm)(ULONGLONG arg1, ULONGLONG arg2); // offset: 0x30 (48)
  UCHAR (*HalPciTranslateBusAddress)
  (enum _INTERFACE_TYPE arg1, ULONG arg2, union _LARGE_INTEGER arg3,
   ULONG *arg4, union _LARGE_INTEGER *arg5); // offset: 0x38 (56)
  LONG (*HalPciAssignSlotResources)
  (struct _UNICODE_STRING *arg1, struct _UNICODE_STRING *arg2,
   struct _DRIVER_OBJECT *arg3, struct _DEVICE_OBJECT *arg4,
   enum _INTERFACE_TYPE arg5, ULONG arg6, ULONG arg7,
   struct _CM_RESOURCE_LIST **arg8); // offset: 0x40 (64)
  VOID (*HalHaltSystem)();           // offset: 0x48 (72)
  UCHAR (*HalFindBusAddressTranslation)
  (union _LARGE_INTEGER arg1, ULONG *arg2, union _LARGE_INTEGER *arg3,
   ULONGLONG *arg4, UCHAR arg5); // offset: 0x50 (80)
  UCHAR (*HalResetDisplay)();    // offset: 0x58 (88)
  LONG (*HalAllocateMapRegisters)
  (struct _ADAPTER_OBJECT *arg1, ULONG arg2, ULONG arg3,
   struct _MAP_REGISTER_ENTRY *arg4); // offset: 0x60 (96)
  LONG (*KdSetupPciDeviceForDebugging)
  (VOID *arg1, struct _DEBUG_DEVICE_DESCRIPTOR *arg2); // offset: 0x68 (104)
  LONG (*KdReleasePciDeviceForDebugging)
  (struct _DEBUG_DEVICE_DESCRIPTOR *arg1); // offset: 0x70 (112)
  VOID *(*KdGetAcpiTablePhase0)(struct _LOADER_PARAMETER_BLOCK *arg1,
                                ULONG arg2); // offset: 0x78 (120)
  VOID (*KdCheckPowerButton)();              // offset: 0x80 (128)
  UCHAR (*HalVectorToIDTEntry)(ULONG arg1);  // offset: 0x88 (136)
  VOID *(*KdMapPhysicalMemory64)(union _LARGE_INTEGER arg1, ULONG arg2,
                                 UCHAR arg3); // offset: 0x90 (144)
  VOID (*KdUnmapVirtualAddress)
  (VOID *arg1, ULONG arg2, UCHAR arg3); // offset: 0x98 (152)
  ULONG (*KdGetPciDataByOffset)
  (ULONG arg1, ULONG arg2, VOID *arg3, ULONG arg4,
   ULONG arg5); // offset: 0xa0 (160)
  ULONG (*KdSetPciDataByOffset)
  (ULONG arg1, ULONG arg2, VOID *arg3, ULONG arg4,
   ULONG arg5); // offset: 0xa8 (168)
  ULONG (*HalGetInterruptVectorOverride)
  (enum _INTERFACE_TYPE arg1, ULONG arg2, ULONG arg3, ULONG arg4, UCHAR *arg5,
   ULONGLONG *arg6); // offset: 0xb0 (176)
  LONG (*HalGetVectorInputOverride)
  (ULONG arg1, struct _GROUP_AFFINITY *arg2, ULONG *arg3,
   enum _KINTERRUPT_POLARITY *arg4,
   struct _INTERRUPT_REMAPPING_INFO *arg5); // offset: 0xb8 (184)
  LONG (*HalLoadMicrocode)(VOID *arg1);     // offset: 0xc0 (192)
  LONG (*HalUnloadMicrocode)();             // offset: 0xc8 (200)
  LONG (*HalPostMicrocodeUpdate)();         // offset: 0xd0 (208)
  LONG (*HalAllocateMessageTargetOverride)
  (struct _DEVICE_OBJECT *arg1, struct _GROUP_AFFINITY *arg2, ULONG arg3,
   enum _KINTERRUPT_MODE arg4, UCHAR arg5, ULONG *arg6, UCHAR *arg7,
   ULONG *arg8); // offset: 0xd8 (216)
  VOID (*HalFreeMessageTargetOverride)
  (struct _DEVICE_OBJECT *arg1, ULONG arg2,
   struct _GROUP_AFFINITY *arg3); // offset: 0xe0 (224)
  LONG (*HalDpReplaceBegin)
  (struct _HAL_DP_REPLACE_PARAMETERS *arg1, VOID **arg2); // offset: 0xe8 (232)
  VOID (*HalDpReplaceTarget)(VOID *arg1);                 // offset: 0xf0 (240)
  LONG (*HalDpReplaceControl)(ULONG arg1, VOID *arg2);    // offset: 0xf8 (248)
  VOID (*HalDpReplaceEnd)(VOID *arg1);                    // offset: 0x100 (256)
  VOID (*HalPrepareForBugcheck)(ULONG arg1);              // offset: 0x108 (264)
  UCHAR (*HalQueryWakeTime)
  (ULONGLONG *arg1, ULONGLONG *arg2); // offset: 0x110 (272)
  VOID (*HalReportIdleStateUsage)
  (UCHAR arg1, struct _KAFFINITY_EX *arg2);               // offset: 0x118 (280)
  VOID (*HalTscSynchronization)(UCHAR arg1, ULONG *arg2); // offset: 0x120 (288)
  LONG (*HalWheaInitProcessorGenericSection)
  (struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR *arg1,
   struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION *arg2); // offset: 0x128 (296)
  VOID (*HalStopLegacyUsbInterrupts)
  (enum _SYSTEM_POWER_STATE arg1); // offset: 0x130 (304)
  LONG (*HalReadWheaPhysicalMemory)
  (union _LARGE_INTEGER arg1, ULONG arg2, VOID *arg3); // offset: 0x138 (312)
  LONG (*HalWriteWheaPhysicalMemory)
  (union _LARGE_INTEGER arg1, ULONG arg2, VOID *arg3); // offset: 0x140 (320)
  LONG (*HalDpMaskLevelTriggeredInterrupts)();         // offset: 0x148 (328)
  LONG (*HalDpUnmaskLevelTriggeredInterrupts)();       // offset: 0x150 (336)
  LONG (*HalDpGetInterruptReplayState)
  (VOID *arg1, VOID **arg2);                 // offset: 0x158 (344)
  LONG (*HalDpReplayInterrupts)(VOID *arg1); // offset: 0x160 (352)
  UCHAR (*HalQueryIoPortAccessSupported)();  // offset: 0x168 (360)
  LONG (*KdSetupIntegratedDeviceForDebugging)
  (VOID *arg1, struct _DEBUG_DEVICE_DESCRIPTOR *arg2); // offset: 0x170 (368)
  LONG (*KdReleaseIntegratedDeviceForDebugging)
  (struct _DEBUG_DEVICE_DESCRIPTOR *arg1); // offset: 0x178 (376)
  VOID (*HalGetEnlightenmentInformation)
  (struct _HAL_INTEL_ENLIGHTENMENT_INFORMATION *arg1); // offset: 0x180 (384)
  VOID *(*HalAllocateEarlyPages)(struct _LOADER_PARAMETER_BLOCK *arg1,
                                 ULONG arg2, ULONGLONG *arg3,
                                 ULONG arg4); // offset: 0x188 (392)
  VOID *(*HalMapEarlyPages)(ULONGLONG arg1, ULONG arg2,
                            ULONG arg3); // offset: 0x190 (400)
  VOID *Dummy1;                          // offset: 0x198 (408)
  VOID *Dummy2;                          // offset: 0x1a0 (416)
  VOID (*HalNotifyProcessorFreeze)
  (UCHAR arg1, UCHAR arg2);                       // offset: 0x1a8 (424)
  LONG (*HalPrepareProcessorForIdle)(ULONG arg1); // offset: 0x1b0 (432)
  VOID (*HalRegisterLogRoutine)
  (struct _HAL_LOG_REGISTER_CONTEXT *arg1);   // offset: 0x1b8 (440)
  VOID (*HalResumeProcessorFromIdle)();       // offset: 0x1c0 (448)
  VOID *Dummy;                                // offset: 0x1c8 (456)
  ULONG (*HalVectorToIDTEntryEx)(ULONG arg1); // offset: 0x1d0 (464)
  LONG (*HalSecondaryInterruptQueryPrimaryInformation)
  (struct _INTERRUPT_VECTOR_DATA *arg1, ULONG *arg2); // offset: 0x1d8 (472)
  LONG (*HalMaskInterrupt)(ULONG arg1, ULONG arg2);   // offset: 0x1e0 (480)
  LONG (*HalUnmaskInterrupt)(ULONG arg1, ULONG arg2); // offset: 0x1e8 (488)
  UCHAR (*HalIsInterruptTypeSecondary)
  (ULONG arg1, ULONG arg2); // offset: 0x1f0 (496)
  LONG (*HalAllocateGsivForSecondaryInterrupt)
  (CHAR *arg1, USHORT arg2, ULONG *arg3); // offset: 0x1f8 (504)
  LONG (*HalAddInterruptRemapping)
  (ULONG arg1, ULONG arg2, struct _PCI_BUSMASTER_DESCRIPTOR *arg3, UCHAR arg4,
   struct _INTERRUPT_VECTOR_DATA *arg5, ULONG arg6); // offset: 0x200 (512)
  VOID (*HalRemoveInterruptRemapping)
  (ULONG arg1, ULONG arg2, struct _PCI_BUSMASTER_DESCRIPTOR *arg3, UCHAR arg4,
   struct _INTERRUPT_VECTOR_DATA *arg5, ULONG arg6); // offset: 0x208 (520)
  VOID (*HalSaveAndDisableHvEnlightenment)();        // offset: 0x210 (528)
  VOID (*HalRestoreHvEnlightenment)();               // offset: 0x218 (536)
  VOID (*HalFlushIoBuffersExternalCache)
  (struct _MDL *arg1, UCHAR arg2);           // offset: 0x220 (544)
  VOID (*HalFlushExternalCache)(UCHAR arg1); // offset: 0x228 (552)
  LONG (*HalPciEarlyRestore)
  (enum _SYSTEM_POWER_STATE arg1); // offset: 0x230 (560)
  LONG (*HalGetProcessorId)
  (ULONG arg1, ULONG *arg2, ULONG *arg3); // offset: 0x238 (568)
  LONG (*HalAllocatePmcCounterSet)
  (ULONG arg1, enum _KPROFILE_SOURCE *arg2, ULONG arg3,
   struct _HAL_PMC_COUNTERS **arg4); // offset: 0x240 (576)
  VOID (*HalCollectPmcCounters)
  (struct _HAL_PMC_COUNTERS *arg1, ULONGLONG *arg2); // offset: 0x248 (584)
  VOID (*HalFreePmcCounterSet)
  (struct _HAL_PMC_COUNTERS *arg1); // offset: 0x250 (592)
  LONG (*HalProcessorHalt)
  (ULONG arg1, VOID *arg2, LONG (*arg3)(VOID *arg1)); // offset: 0x258 (600)
  ULONGLONG (*HalTimerQueryCycleCounter)
  (ULONGLONG *arg1);              // offset: 0x260 (608)
  VOID *Dummy3;                   // offset: 0x268 (616)
  VOID (*HalPciMarkHiberPhase)(); // offset: 0x270 (624)
  LONG (*HalQueryProcessorRestartEntryPoint)
  (union _LARGE_INTEGER *arg1);            // offset: 0x278 (632)
  LONG (*HalRequestInterrupt)(ULONG arg1); // offset: 0x280 (640)
  LONG (*HalEnumerateUnmaskedInterrupts)
  (UCHAR (*arg1)(VOID *arg1, struct _HAL_UNMASKED_INTERRUPT_INFORMATION *arg2),
   VOID *arg2,
   struct _HAL_UNMASKED_INTERRUPT_INFORMATION *arg3); // offset: 0x288 (648)
  VOID (*HalFlushAndInvalidatePageExternalCache)
  (union _LARGE_INTEGER arg1); // offset: 0x290 (656)
  LONG (*KdEnumerateDebuggingDevices)
  (VOID *arg1, struct _DEBUG_DEVICE_DESCRIPTOR *arg2,
   enum KD_CALLBACK_ACTION (*arg3)(
       struct _DEBUG_DEVICE_DESCRIPTOR *arg1)); // offset: 0x298 (664)
  VOID (*HalFlushIoRectangleExternalCache)
  (struct _MDL *arg1, ULONG arg2, ULONG arg3, ULONG arg4, ULONG arg5,
   UCHAR arg6);                             // offset: 0x2a0 (672)
  VOID (*HalPowerEarlyRestore)(ULONG arg1); // offset: 0x2a8 (680)
  LONG (*HalQueryCapsuleCapabilities)
  (VOID *arg1, ULONG arg2, ULONGLONG *arg3, ULONG *arg4); // offset: 0x2b0 (688)
  LONG (*HalUpdateCapsule)
  (VOID *arg1, ULONG arg2, union _LARGE_INTEGER arg3); // offset: 0x2b8 (696)
  UCHAR (*HalPciMultiStageResumeCapable)();            // offset: 0x2c0 (704)
  VOID (*HalDmaFreeCrashDumpRegisters)(ULONG arg1);    // offset: 0x2c8 (712)
  UCHAR (*HalAcpiAoacCapable)();                       // offset: 0x2d0 (720)
  LONG (*HalInterruptSetDestination)
  (struct _INTERRUPT_VECTOR_DATA *arg1, struct _GROUP_AFFINITY *arg2,
   ULONG *arg3); // offset: 0x2d8 (728)
  VOID (*HalGetClockConfiguration)
  (struct _HAL_CLOCK_TIMER_CONFIGURATION *arg1); // offset: 0x2e0 (736)
  VOID (*HalClockTimerActivate)(UCHAR arg1);     // offset: 0x2e8 (744)
  VOID (*HalClockTimerInitialize)();             // offset: 0x2f0 (752)
  VOID (*HalClockTimerStop)();                   // offset: 0x2f8 (760)
  LONG (*HalClockTimerArm)
  (enum _HAL_CLOCK_TIMER_MODE arg1, ULONGLONG arg2,
   ULONGLONG *arg3);                            // offset: 0x300 (768)
  UCHAR (*HalTimerOnlyClockInterruptPending)(); // offset: 0x308 (776)
  VOID *(*HalAcpiGetMultiNode)();               // offset: 0x310 (784)
  VOID (*)
  (ULONG arg1, volatile LONG *arg2) (*HalPowerSetRebootHandler)(
      VOID (*arg1)(ULONG arg1, volatile LONG *arg2)); // offset: 0x318 (792)
  VOID (*HalIommuRegisterDispatchTable)
  (struct _HAL_IOMMU_DISPATCH *arg1);                     // offset: 0x320 (800)
  VOID (*HalTimerWatchdogStart)();                        // offset: 0x328 (808)
  VOID (*HalTimerWatchdogResetCountdown)();               // offset: 0x330 (816)
  VOID (*HalTimerWatchdogStop)();                         // offset: 0x338 (824)
  UCHAR (*HalTimerWatchdogGeneratedLastReset)();          // offset: 0x340 (832)
  LONG (*HalTimerWatchdogTriggerSystemReset)(UCHAR arg1); // offset: 0x348 (840)
  LONG (*HalInterruptVectorDataToGsiv)
  (struct _INTERRUPT_VECTOR_DATA *arg1, ULONG *arg2); // offset: 0x350 (848)
  LONG (*HalInterruptGetHighestPriorityInterrupt)
  (ULONG *arg1, UCHAR *arg2);         // offset: 0x358 (856)
  LONG (*HalProcessorOn)(ULONG arg1); // offset: 0x360 (864)
  LONG (*HalProcessorOff)();          // offset: 0x368 (872)
  LONG (*HalProcessorFreeze)();       // offset: 0x370 (880)
  LONG (*HalDmaLinkDeviceObjectByToken)
  (ULONGLONG arg1, struct _DEVICE_OBJECT *arg2);   // offset: 0x378 (888)
  LONG (*HalDmaCheckAdapterToken)(ULONGLONG arg1); // offset: 0x380 (896)
  VOID *Dummy4;                                    // offset: 0x388 (904)
  LONG (*HalTimerConvertPerformanceCounterToAuxiliaryCounter)
  (ULONGLONG arg1, ULONGLONG *arg2, ULONGLONG *arg3); // offset: 0x390 (912)
  LONG (*HalTimerConvertAuxiliaryCounterToPerformanceCounter)
  (ULONGLONG arg1, ULONGLONG *arg2, ULONGLONG *arg3); // offset: 0x398 (920)
  LONG (*HalTimerQueryAuxiliaryCounterFrequency)
  (ULONGLONG *arg1); // offset: 0x3a0 (928)
  LONG (*HalConnectThermalInterrupt)
  (UCHAR (*arg1)(struct _KINTERRUPT *arg1, VOID *arg2)); // offset: 0x3a8 (936)
  UCHAR (*HalIsEFIRuntimeActive)();                      // offset: 0x3b0 (944)
  UCHAR (*HalTimerQueryAndResetRtcErrors)(UCHAR arg1);   // offset: 0x3b8 (952)
  VOID (*HalAcpiLateRestore)();                          // offset: 0x3c0 (960)
  LONG (*KdWatchdogDelayExpiration)(ULONGLONG *arg1);    // offset: 0x3c8 (968)
  LONG (*HalGetProcessorStats)
  (enum _HAL_PROCESSOR_STAT_TYPE arg1, ULONG arg2, ULONG arg3,
   ULONGLONG *arg4);                                     // offset: 0x3d0 (976)
  ULONGLONG (*HalTimerWatchdogQueryDueTime)(UCHAR arg1); // offset: 0x3d8 (984)
  LONG (*HalConnectSyntheticInterrupt)
  (UCHAR (*arg1)(struct _KINTERRUPT *arg1, VOID *arg2)); // offset: 0x3e0 (992)
  VOID (*HalPreprocessNmi)(ULONG arg1);                  // offset: 0x3e8 (1000)
  LONG (*HalEnumerateEnvironmentVariablesWithFilter)
  (ULONG arg1, UCHAR (*arg2)(struct _GUID *arg1, const WCHAR *arg2), VOID *arg3,
   ULONG *arg4); // offset: 0x3f0 (1008)
  LONG (*HalCaptureLastBranchRecordStack)
  (ULONG arg1, struct _HAL_LBR_ENTRY *arg2,
   ULONG *arg3);                            // offset: 0x3f8 (1016)
  UCHAR (*HalClearLastBranchRecordStack)(); // offset: 0x400 (1024)
  LONG (*HalConfigureLastBranchRecord)
  (ULONG arg1, ULONG arg2); // offset: 0x408 (1032)
  UCHAR (*HalGetLastBranchInformation)
  (ULONG *arg1, ULONG *arg2);                    // offset: 0x410 (1040)
  VOID (*HalResumeLastBranchRecord)(UCHAR arg1); // offset: 0x418 (1048)
  LONG (*HalStartLastBranchRecord)
  (ULONG arg1, ULONG *arg2);                   // offset: 0x420 (1056)
  LONG (*HalStopLastBranchRecord)(ULONG arg1); // offset: 0x428 (1064)
  LONG (*HalIommuBlockDevice)(VOID *arg1);     // offset: 0x430 (1072)
  LONG (*HalIommuUnblockDevice)
  (struct _EXT_IOMMU_DEVICE_ID *arg1, VOID **arg2); // offset: 0x438 (1080)
  LONG (*HalGetIommuInterface)
  (ULONG arg1, struct _DMA_IOMMU_INTERFACE *arg2); // offset: 0x440 (1088)
  LONG (*HalRequestGenericErrorRecovery)
  (VOID *arg1, ULONG *arg2); // offset: 0x448 (1096)
  LONG (*HalTimerQueryHostPerformanceCounter)
  (ULONGLONG *arg1); // offset: 0x450 (1104)
  LONG (*HalTopologyQueryProcessorRelationships)
  (ULONG arg1, ULONG arg2, UCHAR *arg3, UCHAR *arg4, UCHAR *arg5, ULONG *arg6,
   ULONG *arg7);                                   // offset: 0x458 (1112)
  VOID (*HalInitPlatformDebugTriggers)();          // offset: 0x460 (1120)
  VOID (*HalRunPlatformDebugTriggers)(UCHAR arg1); // offset: 0x468 (1128)
  VOID *(*HalTimerGetReferencePage)();             // offset: 0x470 (1136)
  LONG (*HalGetHiddenProcessorPowerInterface)
  (struct _HIDDEN_PROCESSOR_POWER_INTERFACE *arg1);    // offset: 0x478 (1144)
  ULONG (*HalGetHiddenProcessorPackageId)(ULONG arg1); // offset: 0x480 (1152)
  ULONG (*HalGetHiddenPackageProcessorCount)
  (ULONG arg1); // offset: 0x488 (1160)
  LONG (*HalGetHiddenProcessorApicIdByIndex)
  (ULONG arg1, ULONG *arg2); // offset: 0x490 (1168)
  LONG (*HalRegisterHiddenProcessorIdleState)
  (ULONG arg1, ULONGLONG arg2); // offset: 0x498 (1176)
  VOID (*HalIommuReportIommuFault)
  (ULONGLONG arg1, struct _FAULT_INFORMATION *arg2); // offset: 0x4a0 (1184)
  UCHAR (*HalIommuDmaRemappingCapable)
  (struct _EXT_IOMMU_DEVICE_ID *arg1, ULONG *arg2); // offset: 0x4a8 (1192)
};

// 0x58 (88) bytes
struct _SECONDARY_INTERRUPT_PROVIDER_INTERFACE {
  USHORT Size;                         // offset: 0x0 (0)
  USHORT Version;                      // offset: 0x2 (2)
  VOID *Context;                       // offset: 0x8 (8)
  ULONG GsivBase;                      // offset: 0x10 (16)
  USHORT GsivSize;                     // offset: 0x14 (20)
  struct _DRIVER_OBJECT *DriverObject; // offset: 0x18 (24)
  VOID *Reserved1;                     // offset: 0x20 (32)
  VOID *Reserved2;                     // offset: 0x28 (40)
  VOID *Reserved3;                     // offset: 0x30 (48)
  VOID *Reserved4;                     // offset: 0x38 (56)
  VOID *Reserved5;                     // offset: 0x40 (64)
  VOID *Reserved6;                     // offset: 0x48 (72)
  VOID *Reserved7;                     // offset: 0x50 (80)
};

// 0xb0 (176) bytes
struct _SECONDARY_IC_LIST_ENTRY {
  struct _LIST_ENTRY ListEntry;                             // offset: 0x0 (0)
  ULONG GsivBase;                                           // offset: 0x10 (16)
  ULONG GsivSize;                                           // offset: 0x14 (20)
  struct _SECONDARY_INTERRUPT_PROVIDER_INTERFACE Interface; // offset: 0x18 (24)
  volatile LONG BusyCount;                         // offset: 0x70 (112)
  volatile LONG ExclusiveWaiterCount;              // offset: 0x74 (116)
  struct _KEVENT NotificationEvent;                // offset: 0x78 (120)
  struct _LIST_ENTRY SignalListEntry;              // offset: 0x90 (144)
  struct _SECONDARY_INTERRUPT_LINE_STATE State[1]; // offset: 0xa0 (160)
};

// 0x100 (256) bytes
struct _VF_DRIVER_IO_CALLBACKS {
  LONG (*DriverInit)
  (struct _DRIVER_OBJECT *arg1,
   struct _UNICODE_STRING *arg2); // offset: 0x0 (0)
  VOID (*DriverStartIo)
  (struct _DEVICE_OBJECT *arg1, struct _IRP *arg2);  // offset: 0x8 (8)
  VOID (*DriverUnload)(struct _DRIVER_OBJECT *arg1); // offset: 0x10 (16)
  LONG (*AddDevice)
  (struct _DRIVER_OBJECT *arg1,
   struct _DEVICE_OBJECT *arg2); // offset: 0x18 (24)
  LONG (*MajorFunction[28])
  (struct _DEVICE_OBJECT *arg1, struct _IRP *arg2); // offset: 0x20 (32)
};

// 0x28 (40) bytes
struct _DRIVER_EXTENSION {
  struct _DRIVER_OBJECT *DriverObject; // offset: 0x0 (0)
  LONG (*AddDevice)
  (struct _DRIVER_OBJECT *arg1, struct _DEVICE_OBJECT *arg2); // offset: 0x8 (8)
  ULONG Count;                           // offset: 0x10 (16)
  struct _UNICODE_STRING ServiceKeyName; // offset: 0x18 (24)
};

// 0x4b8 (1208) bytes
struct _POP_FX_DEVICE {
  struct _LIST_ENTRY Link;                       // offset: 0x0 (0)
  struct _IRP *Irp;                              // offset: 0x10 (16)
  struct _POP_IRP_DATA *IrpData;                 // offset: 0x18 (24)
  union _POP_FX_DEVICE_STATUS volatile Status;   // offset: 0x20 (32)
  volatile LONG PowerReqCall;                    // offset: 0x24 (36)
  volatile LONG PowerNotReqCall;                 // offset: 0x28 (40)
  struct _DEVICE_NODE *DevNode;                  // offset: 0x30 (48)
  struct PEPHANDLE__ *DpmContext;                // offset: 0x38 (56)
  struct _POP_FX_PLUGIN *Plugin;                 // offset: 0x40 (64)
  struct PEPHANDLE__ *PluginHandle;              // offset: 0x48 (72)
  struct _POP_FX_PLUGIN *AcpiPlugin;             // offset: 0x50 (80)
  struct PEPHANDLE__ *AcpiPluginHandle;          // offset: 0x58 (88)
  struct _DEVICE_OBJECT *DeviceObject;           // offset: 0x60 (96)
  struct _DEVICE_OBJECT *TargetDevice;           // offset: 0x68 (104)
  struct _POP_FX_DRIVER_CALLBACKS Callbacks;     // offset: 0x70 (112)
  VOID *DriverContext;                           // offset: 0xc0 (192)
  struct _LIST_ENTRY AcpiLink;                   // offset: 0xc8 (200)
  struct _UNICODE_STRING DeviceId;               // offset: 0xd8 (216)
  volatile LONG CommonReferenceFlags;            // offset: 0xe8 (232)
  struct _IO_REMOVE_LOCK RemoveLock;             // offset: 0xf0 (240)
  struct _IO_REMOVE_LOCK AcpiRemoveLock;         // offset: 0x110 (272)
  struct _POP_FX_WORK_ORDER WorkOrder;           // offset: 0x130 (304)
  ULONGLONG IdleLock;                            // offset: 0x168 (360)
  struct _KTIMER IdleTimer;                      // offset: 0x170 (368)
  struct _KDPC IdleDpc;                          // offset: 0x1b0 (432)
  ULONGLONG IdleTimeout;                         // offset: 0x1f0 (496)
  ULONGLONG IdleStamp;                           // offset: 0x1f8 (504)
  struct _DEVICE_OBJECT *NextIrpDeviceObject[2]; // offset: 0x200 (512)
  union _POWER_STATE NextIrpPowerState[2];       // offset: 0x210 (528)
  VOID (*NextIrpCallerCompletion[2])
  (struct _DEVICE_OBJECT *arg1, UCHAR arg2, union _POWER_STATE arg3, VOID *arg4,
   struct _IO_STATUS_BLOCK *arg5); // offset: 0x218 (536)
  VOID *NextIrpCallerContext[2];   // offset: 0x228 (552)
  struct _KEVENT IrpCompleteEvent; // offset: 0x238 (568)
  UCHAR (*PowerOnDumpDeviceCallback)
  (struct _PEP_CRASHDUMP_INFORMATION *arg1);        // offset: 0x250 (592)
  struct _POP_FX_ACCOUNTING Accounting;             // offset: 0x258 (600)
  volatile ULONG Flags;                             // offset: 0x338 (824)
  ULONG ComponentCount;                             // offset: 0x33c (828)
  struct _POP_FX_COMPONENT **Components;            // offset: 0x340 (832)
  ULONG LogEntries;                                 // offset: 0x348 (840)
  struct _POP_FX_LOG_ENTRY *Log;                    // offset: 0x350 (848)
  volatile LONG LogIndex;                           // offset: 0x358 (856)
  struct _DRIVER_OBJECT *DripsWatchdogDriverObject; // offset: 0x360 (864)
  struct _POP_FX_DRIPS_WATCHDOG_CONTEXT
      DripsWatchdogContext;                    // offset: 0x368 (872)
  ULONG DirectedTimeout;                       // offset: 0x390 (912)
  struct _POP_FX_WORK_ORDER DirectedWorkOrder; // offset: 0x398 (920)
  struct _POP_FX_WORK_ORDER_WATCHDOG_INFO
      DirectedWorkWatchdogInfo;              // offset: 0x3d0 (976)
  ULONGLONG DirectedLock;                    // offset: 0x480 (1152)
  volatile LONG DirectedTransitionCallCount; // offset: 0x488 (1160)
  struct _POP_FX_DEVICE_DIRECTED_TRANSITION_STATE
      DirectedTransitionState;                    // offset: 0x490 (1168)
  struct _POP_DEVICE_POWER_PROFILE *PowerProfile; // offset: 0x4a0 (1184)
  struct _UNICODE_STRING FriendlyName;            // offset: 0x4a8 (1192)
};

// 0x1b8 (440) bytes
struct _POP_FX_COMPONENT {
  struct _GUID Id;                                   // offset: 0x0 (0)
  ULONG Index;                                       // offset: 0x10 (16)
  struct _POP_FX_WORK_ORDER WorkOrder;               // offset: 0x18 (24)
  struct _POP_FX_DEVICE *Device;                     // offset: 0x50 (80)
  union _POP_FX_COMPONENT_FLAGS volatile Flags;      // offset: 0x58 (88)
  volatile LONG Resident;                            // offset: 0x60 (96)
  struct _KEVENT ActiveEvent;                        // offset: 0x68 (104)
  ULONGLONG IdleLock;                                // offset: 0x80 (128)
  volatile LONG IdleConditionComplete;               // offset: 0x88 (136)
  volatile LONG IdleStateComplete;                   // offset: 0x8c (140)
  ULONGLONG IdleStamp;                               // offset: 0x90 (144)
  volatile ULONG CurrentIdleState;                   // offset: 0x98 (152)
  ULONG IdleStateCount;                              // offset: 0x9c (156)
  struct _POP_FX_IDLE_STATE *IdleStates;             // offset: 0xa0 (160)
  ULONG DeepestWakeableIdleState;                    // offset: 0xa8 (168)
  ULONG ProviderCount;                               // offset: 0xac (172)
  struct _POP_FX_PROVIDER *Providers;                // offset: 0xb0 (176)
  ULONG IdleProviderCount;                           // offset: 0xb8 (184)
  ULONG DependentCount;                              // offset: 0xbc (188)
  struct _POP_FX_DEPENDENT *Dependents;              // offset: 0xc0 (192)
  struct _POP_FX_ACCOUNTING Accounting;              // offset: 0xc8 (200)
  struct _POP_FX_PERF_INFO *Performance;             // offset: 0x1a8 (424)
  struct _POP_COMPONENT_POWER_PROFILE *PowerProfile; // offset: 0x1b0 (432)
};

// 0xa0 (160) bytes
struct _POP_FX_PERF_INFO {
  struct _POP_FX_COMPONENT *Component; // offset: 0x0 (0)
  struct _KEVENT CompletedEvent;       // offset: 0x8 (8)
  VOID (*ComponentPerfState)
  (VOID *arg1, ULONG arg2, UCHAR arg3, VOID *arg4); // offset: 0x20 (32)
  union _POP_FX_PERF_FLAGS volatile Flags;          // offset: 0x28 (40)
  struct _PO_FX_PERF_STATE_CHANGE *LastChange;      // offset: 0x30 (48)
  ULONG LastChangeCount;                            // offset: 0x38 (56)
  ULONGLONG LastChangeStamp;                        // offset: 0x40 (64)
  UCHAR LastChangeNominal;                          // offset: 0x48 (72)
  UCHAR PepRegistered;                              // offset: 0x49 (73)
  UCHAR QueryOnIdleStates;                          // offset: 0x4a (74)
  VOID *volatile RequestDriverContext;              // offset: 0x50 (80)
  struct _POP_FX_WORK_ORDER WorkOrder;              // offset: 0x58 (88)
  ULONG SetsCount;                                  // offset: 0x90 (144)
  struct _POP_FX_PERF_SET *Sets;                    // offset: 0x98 (152)
};

// 0x58 (88) bytes
struct _POP_DEVICE_POWER_PROFILE {
  struct _UNICODE_STRING DeviceId;                  // offset: 0x0 (0)
  struct _POP_POWER_PLANE *PowerPlane;              // offset: 0x10 (16)
  struct _POP_FX_DEVICE *FxDevice;                  // offset: 0x18 (24)
  LONG PowerDrawMw;                                 // offset: 0x20 (32)
  struct _PO_POWER_PLANE_PROFILE DxPower[4];        // offset: 0x24 (36)
  ULONGLONG ComponentCount;                         // offset: 0x48 (72)
  struct _POP_COMPONENT_POWER_PROFILE **Components; // offset: 0x50 (80)
};

// 0x310 (784) bytes
struct _DEVICE_NODE {
  struct _DEVICE_NODE *Sibling;                     // offset: 0x0 (0)
  struct _DEVICE_NODE *Child;                       // offset: 0x8 (8)
  struct _DEVICE_NODE *Parent;                      // offset: 0x10 (16)
  struct _DEVICE_NODE *LastChild;                   // offset: 0x18 (24)
  struct _DEVICE_OBJECT *PhysicalDeviceObject;      // offset: 0x20 (32)
  struct _UNICODE_STRING InstancePath;              // offset: 0x28 (40)
  struct _UNICODE_STRING ServiceName;               // offset: 0x38 (56)
  struct _IRP *PendingIrp;                          // offset: 0x48 (72)
  struct _POP_FX_DEVICE *FxDevice;                  // offset: 0x50 (80)
  volatile LONG FxDeviceLock;                       // offset: 0x58 (88)
  struct _KEVENT FxRemoveEvent;                     // offset: 0x60 (96)
  volatile LONG FxActivationCount;                  // offset: 0x78 (120)
  volatile LONG FxSleepCount;                       // offset: 0x7c (124)
  struct _UNICODE_STRING UniqueId;                  // offset: 0x80 (128)
  struct _POP_FX_PLUGIN *Plugin;                    // offset: 0x90 (144)
  ULONG Level;                                      // offset: 0x98 (152)
  union _POWER_STATE CurrentPowerState;             // offset: 0x9c (156)
  struct _PO_DEVICE_NOTIFY Notify;                  // offset: 0xa0 (160)
  struct _PO_IRP_MANAGER PoIrpManager;              // offset: 0x108 (264)
  volatile LONG PowerFlags;                         // offset: 0x128 (296)
  enum _PNP_DEVNODE_STATE State;                    // offset: 0x12c (300)
  enum _PNP_DEVNODE_STATE PreviousState;            // offset: 0x130 (304)
  enum _PNP_DEVNODE_STATE StateHistory[20];         // offset: 0x134 (308)
  ULONG StateHistoryEntry;                          // offset: 0x184 (388)
  LONG CompletionStatus;                            // offset: 0x188 (392)
  ULONG Flags;                                      // offset: 0x18c (396)
  ULONG UserFlags;                                  // offset: 0x190 (400)
  ULONG Problem;                                    // offset: 0x194 (404)
  LONG ProblemStatus;                               // offset: 0x198 (408)
  struct _CM_RESOURCE_LIST *ResourceList;           // offset: 0x1a0 (416)
  struct _CM_RESOURCE_LIST *ResourceListTranslated; // offset: 0x1a8 (424)
  struct _DEVICE_OBJECT *DuplicatePDO;              // offset: 0x1b0 (432)
  struct _IO_RESOURCE_REQUIREMENTS_LIST
      *ResourceRequirements;               // offset: 0x1b8 (440)
  enum _INTERFACE_TYPE InterfaceType;      // offset: 0x1c0 (448)
  ULONG BusNumber;                         // offset: 0x1c4 (452)
  enum _INTERFACE_TYPE ChildInterfaceType; // offset: 0x1c8 (456)
  ULONG ChildBusNumber;                    // offset: 0x1cc (460)
  USHORT ChildBusTypeIndex;                // offset: 0x1d0 (464)
  UCHAR RemovalPolicy;                     // offset: 0x1d2 (466)
  UCHAR HardwareRemovalPolicy;             // offset: 0x1d3 (467)
  struct _LIST_ENTRY TargetDeviceNotify;   // offset: 0x1d8 (472)
  struct _LIST_ENTRY DeviceArbiterList;    // offset: 0x1e8 (488)
  struct _LIST_ENTRY DeviceTranslatorList; // offset: 0x1f8 (504)
  USHORT NoTranslatorMask;                 // offset: 0x208 (520)
  USHORT QueryTranslatorMask;              // offset: 0x20a (522)
  USHORT NoArbiterMask;                    // offset: 0x20c (524)
  USHORT QueryArbiterMask;                 // offset: 0x20e (526)
  union {
    struct _DEVICE_NODE *LegacyDeviceNode;            // offset: 0x210 (528)
    struct _DEVICE_RELATIONS *PendingDeviceRelations; // offset: 0x210 (528)
    VOID *Information;                                // offset: 0x210 (528)

  } OverUsed1; // offset: 0x210 (528)
  union {
    struct _DEVICE_NODE *NextResourceDeviceNode; // offset: 0x218 (536)

  } OverUsed2;                                       // offset: 0x218 (536)
  struct _CM_RESOURCE_LIST *BootResources;           // offset: 0x220 (544)
  struct _CM_RESOURCE_LIST *BootResourcesTranslated; // offset: 0x228 (552)
  ULONG CapabilityFlags;                             // offset: 0x230 (560)
  struct {
    enum PROFILE_STATUS DockStatus;           // offset: 0x0 (0)
    struct _LIST_ENTRY ListEntry;             // offset: 0x8 (8)
    WCHAR *SerialNumber;                      // offset: 0x18 (24)
  } DockInfo;                                 // offset: 0x238 (568)
  ULONG DisableableDepends;                   // offset: 0x258 (600)
  struct _LIST_ENTRY PendedSetInterfaceState; // offset: 0x260 (608)
  struct _LIST_ENTRY LegacyBusListEntry;      // offset: 0x270 (624)
  ULONG DriverUnloadRetryCount;               // offset: 0x280 (640)
  struct _DEVICE_NODE *PreviousParent;        // offset: 0x288 (648)
  LONG DeletedChildren;                       // offset: 0x290 (656)
  ULONG NumaNodeIndex;                        // offset: 0x294 (660)
  struct _GUID ContainerID;                   // offset: 0x298 (664)
  UCHAR OverrideFlags;                        // offset: 0x2a8 (680)
  ULONG DeviceIdsHash;                        // offset: 0x2ac (684)
  UCHAR RequiresUnloadedDriver;               // offset: 0x2b0 (688)
  struct _PENDING_RELATIONS_LIST_ENTRY
      *PendingEjectRelations;                            // offset: 0x2b8 (696)
  ULONG StateFlags;                                      // offset: 0x2c0 (704)
  struct _PNP_REBALANCE_TRACE_CONTEXT *RebalanceContext; // offset: 0x2c8 (712)
  struct _DEVICE_NODE_IOMMU_EXTENSION *IommuExtension;   // offset: 0x2d0 (720)
  struct _PO_DIRECTED_DRIPS_STATE DirectedDripsState;    // offset: 0x2d8 (728)
};

// 0x100 (256) bytes
struct _POP_IRP_DATA {
  struct _LIST_ENTRY Link;               // offset: 0x0 (0)
  struct _IRP *Irp;                      // offset: 0x10 (16)
  struct _DEVICE_OBJECT *Pdo;            // offset: 0x18 (24)
  struct _DEVICE_OBJECT *TargetDevice;   // offset: 0x20 (32)
  struct _DEVICE_OBJECT *CurrentDevice;  // offset: 0x28 (40)
  ULONGLONG WatchdogStart;               // offset: 0x30 (48)
  struct _KTIMER WatchdogTimer;          // offset: 0x38 (56)
  struct _KDPC WatchdogDpc;              // offset: 0x78 (120)
  UCHAR MinorFunction;                   // offset: 0xb8 (184)
  enum _POWER_STATE_TYPE PowerStateType; // offset: 0xbc (188)
  union _POWER_STATE PowerState;         // offset: 0xc0 (192)
  UCHAR WatchdogEnabled;                 // offset: 0xc4 (196)
  struct _POP_FX_DEVICE *FxDevice;       // offset: 0xc8 (200)
  UCHAR SystemTransition;                // offset: 0xd0 (208)
  UCHAR NotifyPEP;                       // offset: 0xd1 (209)
  LONG IrpSequenceID;                    // offset: 0xd4 (212)
  union {
    struct {
      VOID (*CallerCompletion)
      (struct _DEVICE_OBJECT *arg1, UCHAR arg2, union _POWER_STATE arg3,
       VOID *arg4, struct _IO_STATUS_BLOCK *arg5); // offset: 0x0 (0)
      VOID *CallerContext;                         // offset: 0x8 (8)
      struct _DEVICE_OBJECT *CallerDevice;         // offset: 0x10 (16)
      UCHAR SystemWake;                            // offset: 0x18 (24)
    } Device;                                      // offset: 0xd8 (216)
    struct {
      struct _PO_DEVICE_NOTIFY *NotifyDevice; // offset: 0x0 (0)
      UCHAR FxDeviceActivated;                // offset: 0x8 (8)
    } System;                                 // offset: 0xd8 (216)
  };
  enum _POP_PEP_NOTIFY_DEVICE_DSTATE_REASON DStateReason; // offset: 0xf8 (248)
};

// 0x200 (512) bytes
struct _PROCESSOR_POWER_STATE {
  struct _PPM_IDLE_STATES *IdleStates;          // offset: 0x0 (0)
  struct _PROC_IDLE_ACCOUNTING *IdleAccounting; // offset: 0x8 (8)
  ULONGLONG IdleTimeLast;                       // offset: 0x10 (16)
  ULONGLONG IdleTimeTotal;                      // offset: 0x18 (24)
  volatile ULONGLONG IdleTimeEntry;             // offset: 0x20 (32)
  ULONGLONG IdleTimeExpiration;                 // offset: 0x28 (40)
  UCHAR NonInterruptibleTransition;             // offset: 0x30 (48)
  UCHAR PepWokenTransition;                     // offset: 0x31 (49)
  UCHAR HvTargetState;                          // offset: 0x32 (50)
  UCHAR SoftParked;                             // offset: 0x33 (51)
  ULONG TargetIdleState;                        // offset: 0x34 (52)
  struct _PROC_IDLE_POLICY IdlePolicy;          // offset: 0x38 (56)
  union _PPM_IDLE_SYNCHRONIZATION_STATE volatile Synchronization; // offset:
                                                                  // 0x40 (64)
  struct _PROC_FEEDBACK PerfFeedback;     // offset: 0x48 (72)
  enum _PROC_HYPERVISOR_STATE Hypervisor; // offset: 0xd8 (216)
  ULONG LastSysTime;                      // offset: 0xdc (220)
  ULONGLONG WmiDispatchPtr;               // offset: 0xe0 (224)
  LONG WmiInterfaceEnabled;               // offset: 0xe8 (232)
  struct _PPM_FFH_THROTTLE_STATE_INFO
      FFHThrottleStateInfo;                             // offset: 0xf0 (240)
  struct _KDPC PerfActionDpc;                           // offset: 0x110 (272)
  volatile LONG PerfActionMask;                         // offset: 0x150 (336)
  struct _PROC_IDLE_SNAP HvIdleCheck;                   // offset: 0x158 (344)
  struct _PROC_PERF_CHECK_CONTEXT CheckContext;         // offset: 0x168 (360)
  struct _PPM_CONCURRENCY_ACCOUNTING *Concurrency;      // offset: 0x1a8 (424)
  struct _PPM_CONCURRENCY_ACCOUNTING *ClassConcurrency; // offset: 0x1b0 (432)
  UCHAR ArchitecturalEfficiencyClass;                   // offset: 0x1b8 (440)
  UCHAR PerformanceSchedulingClass;                     // offset: 0x1b9 (441)
  UCHAR EfficiencySchedulingClass;                      // offset: 0x1ba (442)
  UCHAR Unused;                                         // offset: 0x1bb (443)
  UCHAR Parked;                                         // offset: 0x1bc (444)
  UCHAR LongPriorQosPeriod;                             // offset: 0x1bd (445)
  union {
    ULONGLONG SnapTimeLast;   // offset: 0x1c0 (448)
    ULONGLONG EnergyConsumed; // offset: 0x1c0 (448)
  };
  ULONGLONG ActiveTime;                    // offset: 0x1c8 (456)
  ULONGLONG TotalTime;                     // offset: 0x1d0 (464)
  struct _POP_FX_DEVICE *FxDevice;         // offset: 0x1d8 (472)
  ULONGLONG LastQosTranstionTsc;           // offset: 0x1e0 (480)
  ULONGLONG QosTransitionHysteresis;       // offset: 0x1e8 (488)
  enum _KHETERO_CPU_QOS RequestedQosClass; // offset: 0x1f0 (496)
  enum _KHETERO_CPU_QOS ResolvedQosClass;  // offset: 0x1f4 (500)
  USHORT QosEquivalencyMask;               // offset: 0x1f8 (504)
  USHORT HwFeedbackTableIndex;             // offset: 0x1fa (506)
  UCHAR HwFeedbackParkHint;                // offset: 0x1fc (508)
  UCHAR HwFeedbackPerformanceClass;        // offset: 0x1fd (509)
  UCHAR HwFeedbackEfficiencyClass;         // offset: 0x1fe (510)
  UCHAR HeteroCoreType;                    // offset: 0x1ff (511)
};

// 0x430 (1072) bytes
struct _KTHREAD {
  struct _DISPATCHER_HEADER Header;                    // offset: 0x0 (0)
  VOID *SListFaultAddress;                             // offset: 0x18 (24)
  ULONGLONG QuantumTarget;                             // offset: 0x20 (32)
  VOID *InitialStack;                                  // offset: 0x28 (40)
  VOID *volatile StackLimit;                           // offset: 0x30 (48)
  VOID *StackBase;                                     // offset: 0x38 (56)
  ULONGLONG ThreadLock;                                // offset: 0x40 (64)
  volatile ULONGLONG CycleTime;                        // offset: 0x48 (72)
  ULONG CurrentRunTime;                                // offset: 0x50 (80)
  ULONG ExpectedRunTime;                               // offset: 0x54 (84)
  VOID *KernelStack;                                   // offset: 0x58 (88)
  struct _XSAVE_FORMAT *StateSaveArea;                 // offset: 0x60 (96)
  struct _KSCHEDULING_GROUP *volatile SchedulingGroup; // offset: 0x68 (104)
  union _KWAIT_STATUS_REGISTER WaitRegister;           // offset: 0x70 (112)
  volatile UCHAR Running;                              // offset: 0x71 (113)
  UCHAR Alerted[2];                                    // offset: 0x72 (114)
  union {
    struct {
      ULONG AutoBoostActive : 1;         // offset: 0x74 (116)
      ULONG ReadyTransition : 1;         // offset: 0x74 (116)
      ULONG WaitNext : 1;                // offset: 0x74 (116)
      ULONG SystemAffinityActive : 1;    // offset: 0x74 (116)
      ULONG Alertable : 1;               // offset: 0x74 (116)
      ULONG UserStackWalkActive : 1;     // offset: 0x74 (116)
      ULONG ApcInterruptRequest : 1;     // offset: 0x74 (116)
      ULONG QuantumEndMigrate : 1;       // offset: 0x74 (116)
      ULONG UmsDirectedSwitchEnable : 1; // offset: 0x74 (116)
      ULONG TimerActive : 1;             // offset: 0x74 (116)
      ULONG SystemThread : 1;            // offset: 0x74 (116)
      ULONG ProcessDetachActive : 1;     // offset: 0x74 (116)
      ULONG CalloutActive : 1;           // offset: 0x74 (116)
      ULONG ScbReadyQueue : 1;           // offset: 0x74 (116)
      ULONG ApcQueueable : 1;            // offset: 0x74 (116)
      ULONG ReservedStackInUse : 1;      // offset: 0x74 (116)
      ULONG UmsPerformingSyscall : 1;    // offset: 0x74 (116)
      ULONG TimerSuspended : 1;          // offset: 0x74 (116)
      ULONG SuspendedWaitMode : 1;       // offset: 0x74 (116)
      ULONG SuspendSchedulerApcWait : 1; // offset: 0x74 (116)
      ULONG CetUserShadowStack : 1;      // offset: 0x74 (116)
      ULONG BypassProcessFreeze : 1;     // offset: 0x74 (116)
      ULONG Reserved : 10;               // offset: 0x74 (116)
    };
    LONG MiscFlags; // offset: 0x74 (116)
  };
  union {
    struct {
      ULONG ThreadFlagsSpare : 2;             // offset: 0x78 (120)
      ULONG AutoAlignment : 1;                // offset: 0x78 (120)
      ULONG DisableBoost : 1;                 // offset: 0x78 (120)
      ULONG AlertedByThreadId : 1;            // offset: 0x78 (120)
      ULONG QuantumDonation : 1;              // offset: 0x78 (120)
      ULONG EnableStackSwap : 1;              // offset: 0x78 (120)
      ULONG GuiThread : 1;                    // offset: 0x78 (120)
      ULONG DisableQuantum : 1;               // offset: 0x78 (120)
      ULONG ChargeOnlySchedulingGroup : 1;    // offset: 0x78 (120)
      ULONG DeferPreemption : 1;              // offset: 0x78 (120)
      ULONG QueueDeferPreemption : 1;         // offset: 0x78 (120)
      ULONG ForceDeferSchedule : 1;           // offset: 0x78 (120)
      ULONG SharedReadyQueueAffinity : 1;     // offset: 0x78 (120)
      ULONG FreezeCount : 1;                  // offset: 0x78 (120)
      ULONG TerminationApcRequest : 1;        // offset: 0x78 (120)
      ULONG AutoBoostEntriesExhausted : 1;    // offset: 0x78 (120)
      ULONG KernelStackResident : 1;          // offset: 0x78 (120)
      ULONG TerminateRequestReason : 2;       // offset: 0x78 (120)
      ULONG ProcessStackCountDecremented : 1; // offset: 0x78 (120)
      ULONG RestrictedGuiThread : 1;          // offset: 0x78 (120)
      ULONG VpBackingThread : 1;              // offset: 0x78 (120)
      ULONG ThreadFlagsSpare2 : 1;            // offset: 0x78 (120)
      ULONG EtwStackTraceApcInserted : 8;     // offset: 0x78 (120)
    };
    volatile LONG ThreadFlags; // offset: 0x78 (120)
  };
  volatile UCHAR Tag;                      // offset: 0x7c (124)
  UCHAR SystemHeteroCpuPolicy;             // offset: 0x7d (125)
  UCHAR UserHeteroCpuPolicy : 7;           // offset: 0x7e (126)
  UCHAR ExplicitSystemHeteroCpuPolicy : 1; // offset: 0x7e (126)
  union {
    struct {
      UCHAR RunningNonRetpolineCode : 1; // offset: 0x7f (127)
      UCHAR SpecCtrlSpare : 7;           // offset: 0x7f (127)
    };
    UCHAR SpecCtrl; // offset: 0x7f (127)
  };
  ULONG SystemCallNumber;         // offset: 0x80 (128)
  ULONG ReadyTime;                // offset: 0x84 (132)
  VOID *FirstArgument;            // offset: 0x88 (136)
  struct _KTRAP_FRAME *TrapFrame; // offset: 0x90 (144)
  union {
    struct _KAPC_STATE ApcState; // offset: 0x98 (152)
    struct {
      UCHAR ApcStateFill[43];   // offset: 0x98 (152)
      CHAR Priority;            // offset: 0xc3 (195)
      ULONG UserIdealProcessor; // offset: 0xc4 (196)
    };
  };
  volatile LONGLONG WaitStatus;       // offset: 0xc8 (200)
  struct _KWAIT_BLOCK *WaitBlockList; // offset: 0xd0 (208)
  union {
    struct _LIST_ENTRY WaitListEntry;        // offset: 0xd8 (216)
    struct _SINGLE_LIST_ENTRY SwapListEntry; // offset: 0xd8 (216)
  };
  struct _DISPATCHER_HEADER *volatile Queue; // offset: 0xe8 (232)
  VOID *Teb;                                 // offset: 0xf0 (240)
  ULONGLONG RelativeTimerBias;               // offset: 0xf8 (248)
  struct _KTIMER Timer;                      // offset: 0x100 (256)
  union {
    struct _KWAIT_BLOCK WaitBlock[4]; // offset: 0x140 (320)
    struct {
      UCHAR WaitBlockFill4[20]; // offset: 0x140 (320)
      ULONG ContextSwitches;    // offset: 0x154 (340)
    };
    struct {
      UCHAR WaitBlockFill5[68]; // offset: 0x140 (320)
      volatile UCHAR State;     // offset: 0x184 (388)
      CHAR Spare13;             // offset: 0x185 (389)
      UCHAR WaitIrql;           // offset: 0x186 (390)
      CHAR WaitMode;            // offset: 0x187 (391)
    };
    struct {
      UCHAR WaitBlockFill6[116]; // offset: 0x140 (320)
      ULONG WaitTime;            // offset: 0x1b4 (436)
    };
    struct {
      UCHAR WaitBlockFill7[164]; // offset: 0x140 (320)
      union {
        struct {
          SHORT KernelApcDisable;  // offset: 0x1e4 (484)
          SHORT SpecialApcDisable; // offset: 0x1e6 (486)
        };
        ULONG CombinedApcDisable; // offset: 0x1e4 (484)
      };
    };
    struct {
      UCHAR WaitBlockFill8[40];                 // offset: 0x140 (320)
      struct _KTHREAD_COUNTERS *ThreadCounters; // offset: 0x168 (360)
    };
    struct {
      UCHAR WaitBlockFill9[88];        // offset: 0x140 (320)
      struct _XSTATE_SAVE *XStateSave; // offset: 0x198 (408)
    };
    struct {
      UCHAR WaitBlockFill10[136]; // offset: 0x140 (320)
      VOID *volatile Win32Thread; // offset: 0x1c8 (456)
    };
    struct {
      UCHAR WaitBlockFill11[176];                // offset: 0x140 (320)
      struct _UMS_CONTROL_BLOCK *Ucb;            // offset: 0x1f0 (496)
      struct _KUMS_CONTEXT_HEADER *volatile Uch; // offset: 0x1f8 (504)
    };
  };
  union {
    volatile LONG ThreadFlags2; // offset: 0x200 (512)
    struct {
      ULONG BamQosLevel : 8;           // offset: 0x200 (512)
      ULONG ThreadFlags2Reserved : 24; // offset: 0x200 (512)
    };
  };
  ULONG Spare21;                     // offset: 0x204 (516)
  struct _LIST_ENTRY QueueListEntry; // offset: 0x208 (520)
  union {
    volatile ULONG NextProcessor; // offset: 0x218 (536)
    struct {
      ULONG NextProcessorNumber : 31; // offset: 0x218 (536)
      ULONG SharedReadyQueue : 1;     // offset: 0x218 (536)
    };
  };
  LONG QueuePriority;        // offset: 0x21c (540)
  struct _KPROCESS *Process; // offset: 0x220 (544)
  union {
    struct _GROUP_AFFINITY UserAffinity; // offset: 0x228 (552)
    struct {
      UCHAR UserAffinityFill[10]; // offset: 0x228 (552)
      CHAR PreviousMode;          // offset: 0x232 (562)
      CHAR BasePriority;          // offset: 0x233 (563)
      union {
        CHAR PriorityDecrement; // offset: 0x234 (564)
        struct {
          UCHAR ForegroundBoost : 4; // offset: 0x234 (564)
          UCHAR UnusualBoost : 4;    // offset: 0x234 (564)
        };
      };
      UCHAR Preempted;      // offset: 0x235 (565)
      UCHAR AdjustReason;   // offset: 0x236 (566)
      CHAR AdjustIncrement; // offset: 0x237 (567)
    };
  };
  ULONGLONG AffinityVersion; // offset: 0x238 (568)
  union {
    struct _GROUP_AFFINITY Affinity; // offset: 0x240 (576)
    struct {
      UCHAR AffinityFill[10]; // offset: 0x240 (576)
      UCHAR ApcStateIndex;    // offset: 0x24a (586)
      UCHAR WaitBlockCount;   // offset: 0x24b (587)
      ULONG IdealProcessor;   // offset: 0x24c (588)
    };
  };
  ULONGLONG NpxState; // offset: 0x250 (592)
  union {
    struct _KAPC_STATE SavedApcState; // offset: 0x258 (600)
    struct {
      UCHAR SavedApcStateFill[43]; // offset: 0x258 (600)
      UCHAR WaitReason;            // offset: 0x283 (643)
      CHAR SuspendCount;           // offset: 0x284 (644)
      CHAR Saturation;             // offset: 0x285 (645)
      USHORT SListFaultCount;      // offset: 0x286 (646)
    };
  };
  union {
    struct _KAPC SchedulerApc; // offset: 0x288 (648)
    struct {
      UCHAR SchedulerApcFill0[1]; // offset: 0x288 (648)
      UCHAR ResourceIndex;        // offset: 0x289 (649)
    };
    struct {
      UCHAR SchedulerApcFill1[3]; // offset: 0x288 (648)
      UCHAR QuantumReset;         // offset: 0x28b (651)
    };
    struct {
      UCHAR SchedulerApcFill2[4]; // offset: 0x288 (648)
      ULONG KernelTime;           // offset: 0x28c (652)
    };
    struct {
      UCHAR SchedulerApcFill3[64];      // offset: 0x288 (648)
      struct _KPRCB *volatile WaitPrcb; // offset: 0x2c8 (712)
    };
    struct {
      UCHAR SchedulerApcFill4[72]; // offset: 0x288 (648)
      VOID *LegoData;              // offset: 0x2d0 (720)
    };
    struct {
      UCHAR SchedulerApcFill5[83]; // offset: 0x288 (648)
      UCHAR CallbackNestingLevel;  // offset: 0x2db (731)
      ULONG UserTime;              // offset: 0x2dc (732)
    };
  };
  struct _KEVENT SuspendEvent;                    // offset: 0x2e0 (736)
  struct _LIST_ENTRY ThreadListEntry;             // offset: 0x2f8 (760)
  struct _LIST_ENTRY MutantListHead;              // offset: 0x308 (776)
  UCHAR AbEntrySummary;                           // offset: 0x318 (792)
  UCHAR AbWaitEntryCount;                         // offset: 0x319 (793)
  UCHAR AbAllocationRegionCount;                  // offset: 0x31a (794)
  CHAR SystemPriority;                            // offset: 0x31b (795)
  ULONG SecureThreadCookie;                       // offset: 0x31c (796)
  struct _KLOCK_ENTRY *LockEntries;               // offset: 0x320 (800)
  struct _SINGLE_LIST_ENTRY PropagateBoostsEntry; // offset: 0x328 (808)
  struct _SINGLE_LIST_ENTRY IoSelfBoostsEntry;    // offset: 0x330 (816)
  UCHAR PriorityFloorCounts[16];                  // offset: 0x338 (824)
  UCHAR PriorityFloorCountsReserved[16];          // offset: 0x348 (840)
  ULONG PriorityFloorSummary;                     // offset: 0x358 (856)
  volatile LONG AbCompletedIoBoostCount;          // offset: 0x35c (860)
  volatile LONG AbCompletedIoQoSBoostCount;       // offset: 0x360 (864)
  volatile SHORT KeReferenceCount;                // offset: 0x364 (868)
  UCHAR AbOrphanedEntrySummary;                   // offset: 0x366 (870)
  UCHAR AbOwnedEntryCount;                        // offset: 0x367 (871)
  ULONG ForegroundLossTime;                       // offset: 0x368 (872)
  union {
    struct _LIST_ENTRY GlobalForegroundListEntry; // offset: 0x370 (880)
    struct {
      struct _SINGLE_LIST_ENTRY
          ForegroundDpcStackListEntry;  // offset: 0x370 (880)
      ULONGLONG InGlobalForegroundList; // offset: 0x378 (888)
    };
  };
  LONGLONG ReadOperationCount;     // offset: 0x380 (896)
  LONGLONG WriteOperationCount;    // offset: 0x388 (904)
  LONGLONG OtherOperationCount;    // offset: 0x390 (912)
  LONGLONG ReadTransferCount;      // offset: 0x398 (920)
  LONGLONG WriteTransferCount;     // offset: 0x3a0 (928)
  LONGLONG OtherTransferCount;     // offset: 0x3a8 (936)
  struct _KSCB *QueuedScb;         // offset: 0x3b0 (944)
  volatile ULONG ThreadTimerDelay; // offset: 0x3b8 (952)
  union {
    volatile LONG ThreadFlags3; // offset: 0x3bc (956)
    struct {
      ULONG ThreadFlags3Reserved : 8;   // offset: 0x3bc (956)
      ULONG PpmPolicy : 2;              // offset: 0x3bc (956)
      ULONG ThreadFlags3Reserved2 : 22; // offset: 0x3bc (956)
    };
  };
  ULONGLONG TracingPrivate[1];          // offset: 0x3c0 (960)
  VOID *SchedulerAssist;                // offset: 0x3c8 (968)
  VOID *volatile AbWaitObject;          // offset: 0x3d0 (976)
  ULONG ReservedPreviousReadyTimeValue; // offset: 0x3d8 (984)
  ULONGLONG KernelWaitTime;             // offset: 0x3e0 (992)
  ULONGLONG UserWaitTime;               // offset: 0x3e8 (1000)
  union {
    struct _LIST_ENTRY
        GlobalUpdateVpThreadPriorityListEntry; // offset: 0x3f0 (1008)
    struct {
      struct _SINGLE_LIST_ENTRY
          UpdateVpThreadPriorityDpcStackListEntry;  // offset: 0x3f0 (1008)
      ULONGLONG InGlobalUpdateVpThreadPriorityList; // offset: 0x3f8 (1016)
    };
  };
  LONG SchedulerAssistPriorityFloor; // offset: 0x400 (1024)
  ULONG Spare28;                     // offset: 0x404 (1028)
  ULONGLONG EndPadding[5];           // offset: 0x408 (1032)
};

// 0x120 (288) bytes
struct _KINTERRUPT {
  SHORT Type;                            // offset: 0x0 (0)
  SHORT Size;                            // offset: 0x2 (2)
  struct _LIST_ENTRY InterruptListEntry; // offset: 0x8 (8)
  UCHAR (*ServiceRoutine)
  (struct _KINTERRUPT *arg1, VOID *arg2); // offset: 0x18 (24)
  UCHAR (*MessageServiceRoutine)
  (struct _KINTERRUPT *arg1, VOID *arg2, ULONG arg3); // offset: 0x20 (32)
  ULONG MessageIndex;                                 // offset: 0x28 (40)
  VOID *ServiceContext;                               // offset: 0x30 (48)
  ULONGLONG SpinLock;                                 // offset: 0x38 (56)
  ULONG TickCount;                                    // offset: 0x40 (64)
  ULONGLONG *ActualLock;                              // offset: 0x48 (72)
  VOID (*DispatchAddress)();                          // offset: 0x50 (80)
  ULONG Vector;                                       // offset: 0x58 (88)
  UCHAR Irql;                                         // offset: 0x5c (92)
  UCHAR SynchronizeIrql;                              // offset: 0x5d (93)
  UCHAR FloatingSave;                                 // offset: 0x5e (94)
  UCHAR Connected;                                    // offset: 0x5f (95)
  ULONG Number;                                       // offset: 0x60 (96)
  UCHAR ShareVector;                                  // offset: 0x64 (100)
  UCHAR EmulateActiveBoth;                            // offset: 0x65 (101)
  USHORT ActiveCount;                                 // offset: 0x66 (102)
  LONG InternalState;                                 // offset: 0x68 (104)
  enum _KINTERRUPT_MODE Mode;                         // offset: 0x6c (108)
  enum _KINTERRUPT_POLARITY Polarity;                 // offset: 0x70 (112)
  ULONG ServiceCount;                                 // offset: 0x74 (116)
  ULONG DispatchCount;                                // offset: 0x78 (120)
  struct _KEVENT *PassiveEvent;                       // offset: 0x80 (128)
  struct _KTRAP_FRAME *TrapFrame;                     // offset: 0x88 (136)
  VOID *DisconnectData;                               // offset: 0x90 (144)
  struct _KTHREAD *volatile ServiceThread;            // offset: 0x98 (152)
  struct _INTERRUPT_CONNECTION_DATA *ConnectionData;  // offset: 0xa0 (160)
  VOID *IntTrackEntry;                                // offset: 0xa8 (168)
  struct _ISRDPCSTATS IsrDpcStats;                    // offset: 0xb0 (176)
  VOID *RedirectObject;                               // offset: 0x110 (272)
  VOID *PhysicalDeviceObject;                         // offset: 0x118 (280)
};

// 0x30 (48) bytes
struct _KSECONDARY_IDT_ENTRY {
  ULONGLONG SpinLock;                // offset: 0x0 (0)
  struct _KEVENT ConnectLock;        // offset: 0x8 (8)
  UCHAR LineMasked;                  // offset: 0x20 (32)
  struct _KINTERRUPT *InterruptList; // offset: 0x28 (40)
};

// 0x898 (2200) bytes
struct _ETHREAD {
  struct _KTHREAD Tcb;             // offset: 0x0 (0)
  union _LARGE_INTEGER CreateTime; // offset: 0x430 (1072)
  union {
    union _LARGE_INTEGER ExitTime;     // offset: 0x438 (1080)
    struct _LIST_ENTRY KeyedWaitChain; // offset: 0x438 (1080)
  };
  union {
    struct _LIST_ENTRY PostBlockList; // offset: 0x448 (1096)
    struct {
      VOID *ForwardLinkShadow; // offset: 0x448 (1096)
      VOID *StartAddress;      // offset: 0x450 (1104)
    };
  };
  union {
    struct _TERMINATION_PORT *TerminationPort; // offset: 0x458 (1112)
    struct _ETHREAD *ReaperLink;               // offset: 0x458 (1112)
    VOID *KeyedWaitValue;                      // offset: 0x458 (1112)
  };
  ULONGLONG ActiveTimerListLock;          // offset: 0x460 (1120)
  struct _LIST_ENTRY ActiveTimerListHead; // offset: 0x468 (1128)
  struct _CLIENT_ID Cid;                  // offset: 0x478 (1144)
  union {
    struct _KSEMAPHORE KeyedWaitSemaphore; // offset: 0x488 (1160)
    struct _KSEMAPHORE AlpcWaitSemaphore;  // offset: 0x488 (1160)
  };
  union _PS_CLIENT_SECURITY_CONTEXT ClientSecurity; // offset: 0x4a8 (1192)
  struct _LIST_ENTRY IrpList;                       // offset: 0x4b0 (1200)
  ULONGLONG TopLevelIrp;                            // offset: 0x4c0 (1216)
  struct _DEVICE_OBJECT *DeviceToVerify;            // offset: 0x4c8 (1224)
  VOID *Win32StartAddress;                          // offset: 0x4d0 (1232)
  VOID *ChargeOnlySession;                          // offset: 0x4d8 (1240)
  VOID *LegacyPowerObject;                          // offset: 0x4e0 (1248)
  struct _LIST_ENTRY ThreadListEntry;               // offset: 0x4e8 (1256)
  struct _EX_RUNDOWN_REF RundownProtect;            // offset: 0x4f8 (1272)
  struct _EX_PUSH_LOCK ThreadLock;                  // offset: 0x500 (1280)
  ULONG ReadClusterSize;                            // offset: 0x508 (1288)
  volatile LONG MmLockOrdering;                     // offset: 0x50c (1292)
  union {
    ULONG CrossThreadFlags; // offset: 0x510 (1296)
    struct {
      ULONG Terminated : 1;               // offset: 0x510 (1296)
      ULONG ThreadInserted : 1;           // offset: 0x510 (1296)
      ULONG HideFromDebugger : 1;         // offset: 0x510 (1296)
      ULONG ActiveImpersonationInfo : 1;  // offset: 0x510 (1296)
      ULONG HardErrorsAreDisabled : 1;    // offset: 0x510 (1296)
      ULONG BreakOnTermination : 1;       // offset: 0x510 (1296)
      ULONG SkipCreationMsg : 1;          // offset: 0x510 (1296)
      ULONG SkipTerminationMsg : 1;       // offset: 0x510 (1296)
      ULONG CopyTokenOnOpen : 1;          // offset: 0x510 (1296)
      ULONG ThreadIoPriority : 3;         // offset: 0x510 (1296)
      ULONG ThreadPagePriority : 3;       // offset: 0x510 (1296)
      ULONG RundownFail : 1;              // offset: 0x510 (1296)
      ULONG UmsForceQueueTermination : 1; // offset: 0x510 (1296)
      ULONG IndirectCpuSets : 1;          // offset: 0x510 (1296)
      ULONG DisableDynamicCodeOptOut : 1; // offset: 0x510 (1296)
      ULONG ExplicitCaseSensitivity : 1;  // offset: 0x510 (1296)
      ULONG PicoNotifyExit : 1;           // offset: 0x510 (1296)
      ULONG DbgWerUserReportActive : 1;   // offset: 0x510 (1296)
      ULONG ForcedSelfTrimActive : 1;     // offset: 0x510 (1296)
      ULONG SamplingCoverage : 1;         // offset: 0x510 (1296)
      ULONG ReservedCrossThreadFlags : 8; // offset: 0x510 (1296)
    };
  };
  union {
    ULONG SameThreadPassiveFlags; // offset: 0x514 (1300)
    struct {
      ULONG ActiveExWorker : 1;                  // offset: 0x514 (1300)
      ULONG MemoryMaker : 1;                     // offset: 0x514 (1300)
      ULONG StoreLockThread : 2;                 // offset: 0x514 (1300)
      ULONG ClonedThread : 1;                    // offset: 0x514 (1300)
      ULONG KeyedEventInUse : 1;                 // offset: 0x514 (1300)
      ULONG SelfTerminate : 1;                   // offset: 0x514 (1300)
      ULONG RespectIoPriority : 1;               // offset: 0x514 (1300)
      ULONG ActivePageLists : 1;                 // offset: 0x514 (1300)
      ULONG SecureContext : 1;                   // offset: 0x514 (1300)
      ULONG ZeroPageThread : 1;                  // offset: 0x514 (1300)
      ULONG WorkloadClass : 1;                   // offset: 0x514 (1300)
      ULONG ReservedSameThreadPassiveFlags : 20; // offset: 0x514 (1300)
    };
  };
  union {
    ULONG SameThreadApcFlags; // offset: 0x518 (1304)
    struct {
      UCHAR OwnsProcessAddressSpaceExclusive : 1;    // offset: 0x518 (1304)
      UCHAR OwnsProcessAddressSpaceShared : 1;       // offset: 0x518 (1304)
      UCHAR HardFaultBehavior : 1;                   // offset: 0x518 (1304)
      volatile UCHAR StartAddressInvalid : 1;        // offset: 0x518 (1304)
      UCHAR EtwCalloutActive : 1;                    // offset: 0x518 (1304)
      UCHAR SuppressSymbolLoad : 1;                  // offset: 0x518 (1304)
      UCHAR Prefetching : 1;                         // offset: 0x518 (1304)
      UCHAR OwnsVadExclusive : 1;                    // offset: 0x518 (1304)
      UCHAR SystemPagePriorityActive : 1;            // offset: 0x519 (1305)
      UCHAR SystemPagePriority : 3;                  // offset: 0x519 (1305)
      UCHAR AllowUserWritesToExecutableMemory : 1;   // offset: 0x519 (1305)
      UCHAR AllowKernelWritesToExecutableMemory : 1; // offset: 0x519 (1305)
      UCHAR OwnsVadShared : 1;                       // offset: 0x519 (1305)
    };
  };
  UCHAR CacheManagerActive;          // offset: 0x51c (1308)
  UCHAR DisablePageFaultClustering;  // offset: 0x51d (1309)
  UCHAR ActiveFaultCount;            // offset: 0x51e (1310)
  UCHAR LockOrderState;              // offset: 0x51f (1311)
  ULONG PerformanceCountLowReserved; // offset: 0x520 (1312)
  LONG PerformanceCountHighReserved; // offset: 0x524 (1316)
  ULONGLONG AlpcMessageId;           // offset: 0x528 (1320)
  union {
    VOID *AlpcMessage;             // offset: 0x530 (1328)
    ULONG AlpcReceiveAttributeSet; // offset: 0x530 (1328)
  };
  struct _LIST_ENTRY AlpcWaitListEntry;             // offset: 0x538 (1336)
  LONG ExitStatus;                                  // offset: 0x548 (1352)
  ULONG CacheManagerCount;                          // offset: 0x54c (1356)
  ULONG IoBoostCount;                               // offset: 0x550 (1360)
  ULONG IoQoSBoostCount;                            // offset: 0x554 (1364)
  ULONG IoQoSThrottleCount;                         // offset: 0x558 (1368)
  ULONG KernelStackReference;                       // offset: 0x55c (1372)
  struct _LIST_ENTRY BoostList;                     // offset: 0x560 (1376)
  struct _LIST_ENTRY DeboostList;                   // offset: 0x570 (1392)
  ULONGLONG BoostListLock;                          // offset: 0x580 (1408)
  ULONGLONG IrpListLock;                            // offset: 0x588 (1416)
  VOID *ReservedForSynchTracking;                   // offset: 0x590 (1424)
  struct _SINGLE_LIST_ENTRY CmCallbackListHead;     // offset: 0x598 (1432)
  struct _GUID *ActivityId;                         // offset: 0x5a0 (1440)
  struct _SINGLE_LIST_ENTRY SeLearningModeListHead; // offset: 0x5a8 (1448)
  VOID *VerifierContext;                            // offset: 0x5b0 (1456)
  VOID *AdjustedClientToken;                        // offset: 0x5b8 (1464)
  VOID *WorkOnBehalfThread;                         // offset: 0x5c0 (1472)
  struct _PS_PROPERTY_SET PropertySet;              // offset: 0x5c8 (1480)
  VOID *PicoContext;                                // offset: 0x5e0 (1504)
  ULONGLONG UserFsBase;                             // offset: 0x5e8 (1512)
  ULONGLONG UserGsBase;                             // offset: 0x5f0 (1520)
  struct _THREAD_ENERGY_VALUES *EnergyValues;       // offset: 0x5f8 (1528)
  union {
    ULONGLONG SelectedCpuSets;          // offset: 0x600 (1536)
    ULONGLONG *SelectedCpuSetsIndirect; // offset: 0x600 (1536)
  };
  struct _EJOB *Silo;                            // offset: 0x608 (1544)
  struct _UNICODE_STRING *ThreadName;            // offset: 0x610 (1552)
  struct _CONTEXT *SetContextState;              // offset: 0x618 (1560)
  ULONG LastExpectedRunTime;                     // offset: 0x620 (1568)
  ULONG HeapData;                                // offset: 0x624 (1572)
  struct _LIST_ENTRY OwnerEntryListHead;         // offset: 0x628 (1576)
  ULONGLONG DisownedOwnerEntryListLock;          // offset: 0x638 (1592)
  struct _LIST_ENTRY DisownedOwnerEntryListHead; // offset: 0x640 (1600)
  struct _KLOCK_ENTRY LockEntries[6];            // offset: 0x650 (1616)
  VOID *CmDbgInfo;                               // offset: 0x890 (2192)
};

// 0x150 (336) bytes
struct _DEVICE_OBJECT {
  SHORT Type;                            // offset: 0x0 (0)
  USHORT Size;                           // offset: 0x2 (2)
  LONG ReferenceCount;                   // offset: 0x4 (4)
  struct _DRIVER_OBJECT *DriverObject;   // offset: 0x8 (8)
  struct _DEVICE_OBJECT *NextDevice;     // offset: 0x10 (16)
  struct _DEVICE_OBJECT *AttachedDevice; // offset: 0x18 (24)
  struct _IRP *CurrentIrp;               // offset: 0x20 (32)
  struct _IO_TIMER *Timer;               // offset: 0x28 (40)
  ULONG Flags;                           // offset: 0x30 (48)
  ULONG Characteristics;                 // offset: 0x34 (52)
  struct _VPB *Vpb;                      // offset: 0x38 (56)
  VOID *DeviceExtension;                 // offset: 0x40 (64)
  ULONG DeviceType;                      // offset: 0x48 (72)
  CHAR StackSize;                        // offset: 0x4c (76)
  union {
    struct _LIST_ENTRY ListEntry;   // offset: 0x50 (80)
    struct _WAIT_CONTEXT_BLOCK Wcb; // offset: 0x50 (80)

  } Queue;                                         // offset: 0x50 (80)
  ULONG AlignmentRequirement;                      // offset: 0x98 (152)
  struct _KDEVICE_QUEUE DeviceQueue;               // offset: 0xa0 (160)
  struct _KDPC Dpc;                                // offset: 0xc8 (200)
  ULONG ActiveThreadCount;                         // offset: 0x108 (264)
  VOID *SecurityDescriptor;                        // offset: 0x110 (272)
  struct _KEVENT DeviceLock;                       // offset: 0x118 (280)
  USHORT SectorSize;                               // offset: 0x130 (304)
  USHORT Spare1;                                   // offset: 0x132 (306)
  struct _DEVOBJ_EXTENSION *DeviceObjectExtension; // offset: 0x138 (312)
  VOID *Reserved;                                  // offset: 0x140 (320)
};

// 0x20 (32) bytes
struct _DBGK_SILOSTATE {
  struct _EX_PUSH_LOCK ErrorPortLock;       // offset: 0x0 (0)
  struct _DBGKP_ERROR_PORT *ErrorPort;      // offset: 0x8 (8)
  struct _EPROCESS *ErrorProcess;           // offset: 0x10 (16)
  struct _KEVENT *ErrorPortRegisteredEvent; // offset: 0x18 (24)
};

// 0x498 (1176) bytes
struct _ESERVERSILO_GLOBALS {
  struct _OBP_SILODRIVERSTATE ObSiloState;            // offset: 0x0 (0)
  struct _SEP_SILOSTATE SeSiloState;                  // offset: 0x2e0 (736)
  struct _SEP_RM_LSA_CONNECTION_STATE SeRmSiloState;  // offset: 0x310 (784)
  struct _ETW_SILODRIVERSTATE *EtwSiloState;          // offset: 0x360 (864)
  struct _EPROCESS *MiSessionLeaderProcess;           // offset: 0x368 (872)
  struct _EPROCESS *ExpDefaultErrorPortProcess;       // offset: 0x370 (880)
  VOID *ExpDefaultErrorPort;                          // offset: 0x378 (888)
  ULONG HardErrorState;                               // offset: 0x380 (896)
  struct _EXP_LICENSE_STATE *ExpLicenseState;         // offset: 0x388 (904)
  struct _WNF_SILODRIVERSTATE WnfSiloState;           // offset: 0x390 (912)
  struct _DBGK_SILOSTATE DbgkSiloState;               // offset: 0x3c8 (968)
  struct _UNICODE_STRING PsProtectedCurrentDirectory; // offset: 0x3e8 (1000)
  struct _UNICODE_STRING PsProtectedEnvironment;      // offset: 0x3f8 (1016)
  VOID *ApiSetSection;                                // offset: 0x408 (1032)
  VOID *ApiSetSchema;                                 // offset: 0x410 (1040)
  UCHAR OneCoreForwardersEnabled;                     // offset: 0x418 (1048)
  UCHAR TzVirtualizationSupported;                    // offset: 0x419 (1049)
  struct _EX_TIMEZONE_STATE *ExTimeZoneState;         // offset: 0x420 (1056)
  struct _UNICODE_STRING NtSystemRoot;                // offset: 0x428 (1064)
  struct _UNICODE_STRING SiloRootDirectoryName;       // offset: 0x438 (1080)
  struct _PSP_STORAGE *Storage;                       // offset: 0x448 (1096)
  enum _SERVERSILO_STATE State;                       // offset: 0x450 (1104)
  LONG ExitStatus;                                    // offset: 0x454 (1108)
  struct _KEVENT *DeleteEvent;                        // offset: 0x458 (1112)
  struct _SILO_USER_SHARED_DATA *UserSharedData;      // offset: 0x460 (1120)
  VOID *UserSharedSection;                            // offset: 0x468 (1128)
  struct _WORK_QUEUE_ITEM TerminateWorkItem;          // offset: 0x470 (1136)
  UCHAR IsDownlevelContainer;                         // offset: 0x490 (1168)
};

// 0x1220 (4640) bytes
struct _ETW_SILODRIVERSTATE {
  struct _EJOB *Silo;                                     // offset: 0x0 (0)
  struct _ESERVERSILO_GLOBALS *SiloGlobals;               // offset: 0x8 (8)
  ULONG MaxLoggers;                                       // offset: 0x10 (16)
  struct _ETW_GUID_ENTRY EtwpSecurityProviderGuidEntry;   // offset: 0x18 (24)
  struct _EX_RUNDOWN_REF_CACHE_AWARE **EtwpLoggerRundown; // offset: 0x1c0 (448)
  struct _WMI_LOGGER_CONTEXT **EtwpLoggerContext;         // offset: 0x1c8 (456)
  struct _ETW_HASH_BUCKET EtwpGuidHashTable[64];          // offset: 0x1d0 (464)
  USHORT EtwpSecurityLoggers[8];        // offset: 0xfd0 (4048)
  UCHAR EtwpSecurityProviderEnableMask; // offset: 0xfe0 (4064)
  LONG EtwpShutdownInProgress;          // offset: 0xfe4 (4068)
  ULONG EtwpSecurityProviderPID;        // offset: 0xfe8 (4072)
  struct _ETW_PRIV_HANDLE_DEMUX_TABLE
      PrivHandleDemuxTable;                        // offset: 0xff0 (4080)
  struct _ETW_COUNTERS EtwpCounters;               // offset: 0x1010 (4112)
  union _LARGE_INTEGER LogfileBytesWritten;        // offset: 0x1020 (4128)
  struct _ETW_SILO_TRACING_BLOCK *ProcessorBlocks; // offset: 0x1028 (4136)
  struct _EX_WNF_SUBSCRIPTION
      *ContainerRestoreWnfSubscription;   // offset: 0x1030 (4144)
  struct _GUID PartitionId;               // offset: 0x1038 (4152)
  struct _GUID ParentId;                  // offset: 0x1048 (4168)
  union _LARGE_INTEGER QpcOffsetFromRoot; // offset: 0x1058 (4184)
  CHAR *PartitionName;                    // offset: 0x1060 (4192)
  USHORT PartitionNameSize;               // offset: 0x1068 (4200)
  USHORT UnusedPadding;                   // offset: 0x106a (4202)
  ULONG PartitionType;                    // offset: 0x106c (4204)
  struct _ETW_SYSTEM_LOGGER_SETTINGS
      SystemLoggerSettings;            // offset: 0x1070 (4208)
  struct _KMUTANT EtwpStartTraceMutex; // offset: 0x11e8 (4584)
};

// 0x640 (1600) bytes
struct _EJOB {
  struct _KEVENT Event;                                  // offset: 0x0 (0)
  struct _LIST_ENTRY JobLinks;                           // offset: 0x18 (24)
  struct _LIST_ENTRY ProcessListHead;                    // offset: 0x28 (40)
  struct _ERESOURCE JobLock;                             // offset: 0x38 (56)
  union _LARGE_INTEGER TotalUserTime;                    // offset: 0xa0 (160)
  union _LARGE_INTEGER TotalKernelTime;                  // offset: 0xa8 (168)
  union _LARGE_INTEGER TotalCycleTime;                   // offset: 0xb0 (176)
  union _LARGE_INTEGER ThisPeriodTotalUserTime;          // offset: 0xb8 (184)
  union _LARGE_INTEGER ThisPeriodTotalKernelTime;        // offset: 0xc0 (192)
  ULONGLONG TotalContextSwitches;                        // offset: 0xc8 (200)
  ULONG TotalPageFaultCount;                             // offset: 0xd0 (208)
  ULONG TotalProcesses;                                  // offset: 0xd4 (212)
  ULONG ActiveProcesses;                                 // offset: 0xd8 (216)
  ULONG TotalTerminatedProcesses;                        // offset: 0xdc (220)
  union _LARGE_INTEGER PerProcessUserTimeLimit;          // offset: 0xe0 (224)
  union _LARGE_INTEGER PerJobUserTimeLimit;              // offset: 0xe8 (232)
  ULONGLONG MinimumWorkingSetSize;                       // offset: 0xf0 (240)
  ULONGLONG MaximumWorkingSetSize;                       // offset: 0xf8 (248)
  ULONG LimitFlags;                                      // offset: 0x100 (256)
  ULONG ActiveProcessLimit;                              // offset: 0x104 (260)
  struct _KAFFINITY_EX Affinity;                         // offset: 0x108 (264)
  struct _JOB_ACCESS_STATE *AccessState;                 // offset: 0x1b0 (432)
  VOID *AccessStateQuotaReference;                       // offset: 0x1b8 (440)
  ULONG UIRestrictionsClass;                             // offset: 0x1c0 (448)
  ULONG EndOfJobTimeAction;                              // offset: 0x1c4 (452)
  VOID *CompletionPort;                                  // offset: 0x1c8 (456)
  VOID *CompletionKey;                                   // offset: 0x1d0 (464)
  ULONGLONG CompletionCount;                             // offset: 0x1d8 (472)
  ULONG SessionId;                                       // offset: 0x1e0 (480)
  ULONG SchedulingClass;                                 // offset: 0x1e4 (484)
  ULONGLONG ReadOperationCount;                          // offset: 0x1e8 (488)
  ULONGLONG WriteOperationCount;                         // offset: 0x1f0 (496)
  ULONGLONG OtherOperationCount;                         // offset: 0x1f8 (504)
  ULONGLONG ReadTransferCount;                           // offset: 0x200 (512)
  ULONGLONG WriteTransferCount;                          // offset: 0x208 (520)
  ULONGLONG OtherTransferCount;                          // offset: 0x210 (528)
  struct _PROCESS_DISK_COUNTERS DiskIoInfo;              // offset: 0x218 (536)
  ULONGLONG ProcessMemoryLimit;                          // offset: 0x240 (576)
  ULONGLONG JobMemoryLimit;                              // offset: 0x248 (584)
  ULONGLONG JobTotalMemoryLimit;                         // offset: 0x250 (592)
  ULONGLONG PeakProcessMemoryUsed;                       // offset: 0x258 (600)
  ULONGLONG PeakJobMemoryUsed;                           // offset: 0x260 (608)
  struct _KAFFINITY_EX EffectiveAffinity;                // offset: 0x268 (616)
  union _LARGE_INTEGER EffectivePerProcessUserTimeLimit; // offset: 0x310 (784)
  ULONGLONG EffectiveMinimumWorkingSetSize;              // offset: 0x318 (792)
  ULONGLONG EffectiveMaximumWorkingSetSize;              // offset: 0x320 (800)
  ULONGLONG EffectiveProcessMemoryLimit;                 // offset: 0x328 (808)
  struct _EJOB *EffectiveProcessMemoryLimitJob;          // offset: 0x330 (816)
  struct _EJOB *EffectivePerProcessUserTimeLimitJob;     // offset: 0x338 (824)
  struct _EJOB *EffectiveNetIoRateLimitJob;              // offset: 0x340 (832)
  struct _EJOB *EffectiveHeapAttributionJob;             // offset: 0x348 (840)
  ULONG EffectiveLimitFlags;                             // offset: 0x350 (848)
  ULONG EffectiveSchedulingClass;                        // offset: 0x354 (852)
  ULONG EffectiveFreezeCount;                            // offset: 0x358 (856)
  ULONG EffectiveBackgroundCount;                        // offset: 0x35c (860)
  ULONG EffectiveSwapCount;                              // offset: 0x360 (864)
  ULONG EffectiveNotificationLimitCount;                 // offset: 0x364 (868)
  UCHAR EffectivePriorityClass;                          // offset: 0x368 (872)
  UCHAR PriorityClass;                                   // offset: 0x369 (873)
  UCHAR NestingDepth;                                    // offset: 0x36a (874)
  UCHAR Reserved1[1];                                    // offset: 0x36b (875)
  ULONG CompletionFilter;                                // offset: 0x36c (876)
  union {
    struct _WNF_STATE_NAME WakeChannel;       // offset: 0x370 (880)
    struct _PS_JOB_WAKE_INFORMATION WakeInfo; // offset: 0x370 (880)
  };
  struct _JOBOBJECT_WAKE_FILTER WakeFilter;               // offset: 0x3b8 (952)
  ULONG LowEdgeLatchFilter;                               // offset: 0x3c0 (960)
  struct _EJOB *NotificationLink;                         // offset: 0x3c8 (968)
  ULONGLONG CurrentJobMemoryUsed;                         // offset: 0x3d0 (976)
  struct _JOB_NOTIFICATION_INFORMATION *NotificationInfo; // offset: 0x3d8 (984)
  VOID *NotificationInfoQuotaReference;                   // offset: 0x3e0 (992)
  struct _IO_MINI_COMPLETION_PACKET_USER
      *NotificationPacket;                      // offset: 0x3e8 (1000)
  struct _JOB_CPU_RATE_CONTROL *CpuRateControl; // offset: 0x3f0 (1008)
  VOID *EffectiveSchedulingGroup;               // offset: 0x3f8 (1016)
  ULONGLONG ReadyTime;                          // offset: 0x400 (1024)
  struct _EX_PUSH_LOCK MemoryLimitsLock;        // offset: 0x408 (1032)
  struct _LIST_ENTRY SiblingJobLinks;           // offset: 0x410 (1040)
  struct _LIST_ENTRY ChildJobListHead;          // offset: 0x420 (1056)
  struct _EJOB *ParentJob;                      // offset: 0x430 (1072)
  struct _EJOB *volatile RootJob;               // offset: 0x438 (1080)
  struct _LIST_ENTRY IteratorListHead;          // offset: 0x440 (1088)
  ULONGLONG AncestorCount;                      // offset: 0x450 (1104)
  union {
    struct _EJOB **Ancestors; // offset: 0x458 (1112)
    VOID *SessionObject;      // offset: 0x458 (1112)
  };
  struct _EPROCESS_VALUES Accounting;             // offset: 0x460 (1120)
  ULONG ShadowActiveProcessCount;                 // offset: 0x4c8 (1224)
  ULONG ActiveAuxiliaryProcessCount;              // offset: 0x4cc (1228)
  ULONG SequenceNumber;                           // offset: 0x4d0 (1232)
  ULONG JobId;                                    // offset: 0x4d4 (1236)
  struct _GUID ContainerId;                       // offset: 0x4d8 (1240)
  struct _GUID ContainerTelemetryId;              // offset: 0x4e8 (1256)
  struct _ESERVERSILO_GLOBALS *ServerSiloGlobals; // offset: 0x4f8 (1272)
  struct _PS_PROPERTY_SET PropertySet;            // offset: 0x500 (1280)
  struct _PSP_STORAGE *Storage;                   // offset: 0x518 (1304)
  struct _JOB_NET_RATE_CONTROL *NetRateControl;   // offset: 0x520 (1312)
  union {
    ULONG JobFlags; // offset: 0x528 (1320)
    struct {
      ULONG CloseDone : 1;                     // offset: 0x528 (1320)
      ULONG MultiGroup : 1;                    // offset: 0x528 (1320)
      ULONG OutstandingNotification : 1;       // offset: 0x528 (1320)
      ULONG NotificationInProgress : 1;        // offset: 0x528 (1320)
      ULONG UILimits : 1;                      // offset: 0x528 (1320)
      ULONG CpuRateControlActive : 1;          // offset: 0x528 (1320)
      ULONG OwnCpuRateControl : 1;             // offset: 0x528 (1320)
      ULONG Terminating : 1;                   // offset: 0x528 (1320)
      ULONG WorkingSetLock : 1;                // offset: 0x528 (1320)
      ULONG JobFrozen : 1;                     // offset: 0x528 (1320)
      ULONG Background : 1;                    // offset: 0x528 (1320)
      ULONG WakeNotificationAllocated : 1;     // offset: 0x528 (1320)
      ULONG WakeNotificationEnabled : 1;       // offset: 0x528 (1320)
      ULONG WakeNotificationPending : 1;       // offset: 0x528 (1320)
      ULONG LimitNotificationRequired : 1;     // offset: 0x528 (1320)
      ULONG ZeroCountNotificationRequired : 1; // offset: 0x528 (1320)
      ULONG CycleTimeNotificationRequired : 1; // offset: 0x528 (1320)
      ULONG CycleTimeNotificationPending : 1;  // offset: 0x528 (1320)
      ULONG TimersVirtualized : 1;             // offset: 0x528 (1320)
      ULONG JobSwapped : 1;                    // offset: 0x528 (1320)
      ULONG ViolationDetected : 1;             // offset: 0x528 (1320)
      ULONG EmptyJobNotified : 1;              // offset: 0x528 (1320)
      ULONG NoSystemCharge : 1;                // offset: 0x528 (1320)
      ULONG DropNoWakeCharges : 1;             // offset: 0x528 (1320)
      ULONG NoWakeChargePolicyDecided : 1;     // offset: 0x528 (1320)
      ULONG NetRateControlActive : 1;          // offset: 0x528 (1320)
      ULONG OwnNetRateControl : 1;             // offset: 0x528 (1320)
      ULONG IoRateControlActive : 1;           // offset: 0x528 (1320)
      ULONG OwnIoRateControl : 1;              // offset: 0x528 (1320)
      ULONG DisallowNewProcesses : 1;          // offset: 0x528 (1320)
      ULONG Silo : 1;                          // offset: 0x528 (1320)
      ULONG ContainerTelemetryIdSet : 1;       // offset: 0x528 (1320)
    };
  };
  union {
    ULONG JobFlags2; // offset: 0x52c (1324)
    struct {
      ULONG ParentLocked : 1;                            // offset: 0x52c (1324)
      ULONG EnableUsermodeSiloThreadImpersonation : 1;   // offset: 0x52c (1324)
      ULONG DisallowUsermodeSiloThreadImpersonation : 1; // offset: 0x52c (1324)
    };
  };
  struct _PROCESS_EXTENDED_ENERGY_VALUES *EnergyValues; // offset: 0x530 (1328)
  volatile ULONGLONG SharedCommitCharge;                // offset: 0x538 (1336)
  ULONG DiskIoAttributionUserRefCount;                  // offset: 0x540 (1344)
  ULONG DiskIoAttributionRefCount;                      // offset: 0x544 (1348)
  union {
    VOID *DiskIoAttributionContext;          // offset: 0x548 (1352)
    struct _EJOB *DiskIoAttributionOwnerJob; // offset: 0x548 (1352)
  };
  struct _JOB_RATE_CONTROL_HEADER IoRateControlHeader; // offset: 0x550 (1360)
  struct _PS_IO_CONTROL_ENTRY GlobalIoControl;         // offset: 0x578 (1400)
  volatile LONG IoControlStateLock;                    // offset: 0x5b0 (1456)
  struct _RTL_RB_TREE VolumeIoControlTree;             // offset: 0x5b8 (1464)
  ULONGLONG IoRateOverQuotaHistory;                    // offset: 0x5c8 (1480)
  ULONG IoRateCurrentGeneration;                       // offset: 0x5d0 (1488)
  ULONG IoRateLastQueryGeneration;                     // offset: 0x5d4 (1492)
  ULONG IoRateGenerationLength;                        // offset: 0x5d8 (1496)
  ULONG IoRateOverQuotaNotifySequenceId;               // offset: 0x5dc (1500)
  ULONGLONG LastThrottledIoTime;                       // offset: 0x5e0 (1504)
  struct _EX_PUSH_LOCK IoControlLock;                  // offset: 0x5e8 (1512)
  LONGLONG SiloHardReferenceCount;                     // offset: 0x5f0 (1520)
  struct _WORK_QUEUE_ITEM RundownWorkItem;             // offset: 0x5f8 (1528)
  VOID *PartitionObject;                               // offset: 0x618 (1560)
  struct _EJOB *PartitionOwnerJob;                     // offset: 0x620 (1568)
  union _JOBOBJECT_ENERGY_TRACKING_STATE
      EnergyTrackingState;  // offset: 0x628 (1576)
  ULONGLONG KernelWaitTime; // offset: 0x630 (1584)
  ULONGLONG UserWaitTime;   // offset: 0x638 (1592)
};

// 0x80 (128) bytes
struct _HANDLE_TABLE {
  ULONG NextHandleNeedingPool;        // offset: 0x0 (0)
  LONG ExtraInfoPages;                // offset: 0x4 (4)
  volatile ULONGLONG TableCode;       // offset: 0x8 (8)
  struct _EPROCESS *QuotaProcess;     // offset: 0x10 (16)
  struct _LIST_ENTRY HandleTableList; // offset: 0x18 (24)
  ULONG UniqueProcessId;              // offset: 0x28 (40)
  union {
    ULONG Flags; // offset: 0x2c (44)
    struct {
      UCHAR StrictFIFO : 1;                           // offset: 0x2c (44)
      UCHAR EnableHandleExceptions : 1;               // offset: 0x2c (44)
      UCHAR Rundown : 1;                              // offset: 0x2c (44)
      UCHAR Duplicated : 1;                           // offset: 0x2c (44)
      UCHAR RaiseUMExceptionOnInvalidHandleClose : 1; // offset: 0x2c (44)
    };
  };
  struct _EX_PUSH_LOCK HandleContentionEvent; // offset: 0x30 (48)
  struct _EX_PUSH_LOCK HandleTableLock;       // offset: 0x38 (56)
  union {
    struct _HANDLE_TABLE_FREE_LIST FreeLists[1]; // offset: 0x40 (64)
    struct {
      UCHAR ActualEntry[32];                      // offset: 0x40 (64)
      struct _HANDLE_TRACE_DEBUG_INFO *DebugInfo; // offset: 0x60 (96)
    };
  };
};

// 0x30 (48) bytes
struct _MDL {
  struct _MDL *Next;                // offset: 0x0 (0)
  SHORT Size;                       // offset: 0x8 (8)
  SHORT MdlFlags;                   // offset: 0xa (10)
  USHORT AllocationProcessorNumber; // offset: 0xc (12)
  USHORT Reserved;                  // offset: 0xe (14)
  struct _EPROCESS *Process;        // offset: 0x10 (16)
  VOID *MappedSystemVa;             // offset: 0x18 (24)
  VOID *StartVa;                    // offset: 0x20 (32)
  ULONG ByteCount;                  // offset: 0x28 (40)
  ULONG ByteOffset;                 // offset: 0x2c (44)
};

// 0x78 (120) bytes
struct _MI_PAGEFILE_TRACES {
  LONG Status;                                  // offset: 0x0 (0)
  USHORT PartitionId;                           // offset: 0x4 (4)
  UCHAR Priority;                               // offset: 0x6 (6)
  UCHAR IrpPriority;                            // offset: 0x7 (7)
  UCHAR ReservationWrite;                       // offset: 0x8 (8)
  union _LARGE_INTEGER CurrentTime;             // offset: 0x10 (16)
  ULONGLONG AvailablePages;                     // offset: 0x18 (24)
  ULONGLONG ModifiedPagesTotal;                 // offset: 0x20 (32)
  ULONGLONG ModifiedPagefilePages;              // offset: 0x28 (40)
  ULONGLONG ModifiedNoWritePages;               // offset: 0x30 (48)
  ULONGLONG ModifiedPagefileNoReservationPages; // offset: 0x38 (56)
  struct {
    struct _MDL Mdl;   // offset: 0x0 (0)
    ULONGLONG Page[1]; // offset: 0x30 (48)
  } MdlHack;           // offset: 0x40 (64)
};

// 0x1200 (4608) bytes
struct _MI_VISIBLE_PARTITION {
  ULONGLONG LowestPhysicalPage;                       // offset: 0x0 (0)
  ULONGLONG HighestPhysicalPage;                      // offset: 0x8 (8)
  ULONGLONG NumberOfPhysicalPages;                    // offset: 0x10 (16)
  volatile ULONG NumberOfPagingFiles;                 // offset: 0x18 (24)
  UCHAR SystemCacheInitialized;                       // offset: 0x1c (28)
  struct _MMPAGING_FILE *PagingFile[16];              // offset: 0x20 (32)
  volatile ULONGLONG AvailablePages;                  // offset: 0xc0 (192)
  volatile ULONGLONG ResidentAvailablePages;          // offset: 0x100 (256)
  struct _MMSUPPORT_INSTANCE PartitionWs[1];          // offset: 0x140 (320)
  struct _MMWSL_INSTANCE PartitionWorkingSetLists[1]; // offset: 0x200 (512)
  volatile ULONGLONG TotalCommittedPages;             // offset: 0x228 (552)
  struct _MMPFNLIST ModifiedPageListHead;             // offset: 0x240 (576)
  struct _MMPFNLIST ModifiedNoWritePageListHead;      // offset: 0x280 (640)
  ULONGLONG TotalCommitLimit;                         // offset: 0x2a8 (680)
  ULONGLONG TotalPagesForPagingFile;                  // offset: 0x2b0 (688)
  ULONGLONG VadPhysicalPages;                         // offset: 0x2b8 (696)
  ULONGLONG ProcessLockedFilePages;                   // offset: 0x2c0 (704)
  volatile ULONGLONG SharedCommit;                    // offset: 0x2c8 (712)
  ULONGLONG SlabAllocatorPages;                       // offset: 0x2d0 (720)
  ULONG ChargeCommitmentFailures[4];                  // offset: 0x2d8 (728)
  volatile LONG PageFileTraceIndex;                   // offset: 0x2e8 (744)
  struct _MI_PAGEFILE_TRACES PageFileTraces[32];      // offset: 0x2f0 (752)
};

// 0x2d00 (11520) bytes
struct _MI_PARTITION {
  struct _MI_PARTITION_CORE Core;                // offset: 0x0 (0)
  struct _MI_PARTITION_MODWRITES Modwriter;      // offset: 0x1b8 (440)
  struct _MI_PARTITION_STORES Store;             // offset: 0x480 (1152)
  struct _MI_PARTITION_SEGMENTS Segments;        // offset: 0x540 (1344)
  struct _MI_PARTITION_PAGE_LISTS PageLists;     // offset: 0x880 (2176)
  struct _MI_PARTITION_COMMIT Commit;            // offset: 0x1840 (6208)
  struct _MI_PARTITION_ZEROING Zeroing;          // offset: 0x1880 (6272)
  struct _MI_PAGE_COMBINING_SUPPORT PageCombine; // offset: 0x1930 (6448)
  VOID *WorkingSetControl;                       // offset: 0x1ac0 (6848)
  struct _MMWORKING_SET_EXPANSION_HEAD
      WorkingSetExpansionHead;     // offset: 0x1ac8 (6856)
  ULONG SessionDetachTimeStamp;    // offset: 0x1ad8 (6872)
  struct _MI_VISIBLE_PARTITION Vp; // offset: 0x1b00 (6912)
};

// 0xc0 (192) bytes
struct _MI_PARTITION_STATE {
  ULONGLONG PartitionLock;                        // offset: 0x0 (0)
  struct _EX_PUSH_LOCK PartitionIdLock;           // offset: 0x8 (8)
  ULONGLONG InitialPartitionIdBits;               // offset: 0x10 (16)
  struct _LIST_ENTRY PartitionList;               // offset: 0x18 (24)
  struct _RTL_BITMAP *PartitionIdBitmap;          // offset: 0x28 (40)
  struct _RTL_BITMAP InitialPartitionIdBitmap;    // offset: 0x30 (48)
  struct _MI_PARTITION *TempPartitionPointers[1]; // offset: 0x40 (64)
  struct _MI_PARTITION **Partition;               // offset: 0x48 (72)
  ULONGLONG TotalPagesInChildPartitions;          // offset: 0x50 (80)
  ULONG CrossPartitionDenials;                    // offset: 0x58 (88)
  UCHAR MultiplePartitionsExist;                  // offset: 0x5c (92)
  struct _RTL_BITMAP_EX HugeIoPfnBitMap;          // offset: 0x60 (96)
  struct _MI_HUGE_PFN *HugePfnDatabase;           // offset: 0x70 (112)
  ULONGLONG HugeRangesLock;                       // offset: 0x80 (128)
};

// 0x120 (288) bytes
struct _MMPAGING_FILE {
  ULONGLONG Size;                                // offset: 0x0 (0)
  ULONGLONG MaximumSize;                         // offset: 0x8 (8)
  ULONGLONG MinimumSize;                         // offset: 0x10 (16)
  ULONGLONG FreeSpace;                           // offset: 0x18 (24)
  ULONGLONG PeakUsage;                           // offset: 0x20 (32)
  ULONGLONG HighestPage;                         // offset: 0x28 (40)
  ULONGLONG FreeReservationSpace;                // offset: 0x30 (48)
  struct _FILE_OBJECT *File;                     // offset: 0x38 (56)
  struct _MMMOD_WRITER_MDL_ENTRY **Entry;        // offset: 0x40 (64)
  ULONG NumberOfModWriterEntries;                // offset: 0x48 (72)
  union _SLIST_HEADER PfnsToFree;                // offset: 0x50 (80)
  struct _UNICODE_STRING PageFileName;           // offset: 0x60 (96)
  struct _MI_PAGING_FILE_SPACE_BITMAPS *Bitmaps; // offset: 0x70 (112)
  ULONG AllocationBitmapHint;                    // offset: 0x78 (120)
  ULONG LargestAllocationCluster;                // offset: 0x7c (124)
  ULONG RefreshAllocationCluster;                // offset: 0x80 (128)
  ULONG LastRefreshAllocationCluster;            // offset: 0x84 (132)
  ULONG ReservedClusterSizeAggregate;            // offset: 0x88 (136)
  ULONG MaximumRunLengthInBitmaps;               // offset: 0x8c (140)
  struct _RTL_RB_TREE BitmapsCacheLengthTree;    // offset: 0x90 (144)
  struct _RTL_RB_TREE BitmapsCacheLocationTree;  // offset: 0xa0 (160)
  struct _LIST_ENTRY BitmapsCacheFreeList;       // offset: 0xb0 (176)
  struct _MI_PAGEFILE_BITMAPS_CACHE_ENTRY
      *BitmapsCacheEntries; // offset: 0xc0 (192)
  union {
    ULONG ToBeEvictedCount; // offset: 0xc8 (200)
    ULONG HybridPriority;   // offset: 0xc8 (200)
  };
  USHORT PageFileNumber : 4;                // offset: 0xcc (204)
  USHORT WsSwapPagefile : 1;                // offset: 0xcc (204)
  USHORT NoReservations : 1;                // offset: 0xcc (204)
  USHORT VirtualStorePagefile : 1;          // offset: 0xcc (204)
  USHORT SwapSupported : 1;                 // offset: 0xcc (204)
  USHORT NodeInserted : 1;                  // offset: 0xcc (204)
  USHORT StackNotified : 1;                 // offset: 0xcc (204)
  USHORT BackedBySCM : 1;                   // offset: 0xcc (204)
  USHORT SpecialPurposeMemory : 1;          // offset: 0xcc (204)
  USHORT Spare0 : 3;                        // offset: 0xcc (204)
  UCHAR AdriftMdls : 1;                     // offset: 0xce (206)
  UCHAR Spare1 : 7;                         // offset: 0xce (206)
  UCHAR IgnoreReservations : 1;             // offset: 0xcf (207)
  UCHAR Spare2 : 7;                         // offset: 0xcf (207)
  ULONG PageHashPages;                      // offset: 0xd0 (208)
  ULONG PageHashPagesPeak;                  // offset: 0xd4 (212)
  ULONG *PageHash;                          // offset: 0xd8 (216)
  VOID *FileHandle;                         // offset: 0xe0 (224)
  volatile LONG SpinLock;                   // offset: 0xe8 (232)
  struct _RTL_AVL_TREE FlowThroughReadRoot; // offset: 0xf0 (240)
  struct _MI_PARTITION *Partition;          // offset: 0xf8 (248)
  struct _RTL_BALANCED_NODE FileObjectNode; // offset: 0x100 (256)
};

// 0x38 (56) bytes
struct _MMINPAGE_SUPPORT_FLOW_THROUGH {
  ULONGLONG Page[1];                              // offset: 0x0 (0)
  struct _MMINPAGE_SUPPORT *InitialInPageSupport; // offset: 0x8 (8)
  struct _MMPAGING_FILE *PagingFile;              // offset: 0x10 (16)
  ULONGLONG PageFileOffset;                       // offset: 0x18 (24)
  struct _RTL_BALANCED_NODE Node;                 // offset: 0x20 (32)
};

// 0x1c0 (448) bytes
struct _MMINPAGE_SUPPORT {
  union {
    struct _LIST_ENTRY ListEntry;   // offset: 0x0 (0)
    struct _SLIST_ENTRY SListEntry; // offset: 0x0 (0)
  };
  struct _LIST_ENTRY ListHead;      // offset: 0x10 (16)
  struct _KEVENT Event;             // offset: 0x20 (32)
  struct _KEVENT CollidedEvent;     // offset: 0x38 (56)
  struct _IO_STATUS_BLOCK IoStatus; // offset: 0x50 (80)
  union _LARGE_INTEGER ReadOffset;  // offset: 0x60 (96)
  union {
    struct _KAPC_STATE ApcState;                // offset: 0x68 (104)
    struct _MI_HARD_FAULT_STATE HardFaultState; // offset: 0x68 (104)

  } u2;                          // offset: 0x68 (104)
  struct _ETHREAD *Thread;       // offset: 0x98 (152)
  struct _MMPFN *LockedProtoPfn; // offset: 0xa0 (160)
  struct _MMPTE PteContents;     // offset: 0xa8 (168)
  volatile LONG WaitCount;       // offset: 0xb0 (176)
  volatile LONG InjectRetry;     // offset: 0xb4 (180)
  ULONG ByteCount;               // offset: 0xb8 (184)
  union {
    ULONG ImagePteOffset; // offset: 0xbc (188)
    ULONG TossPage;       // offset: 0xbc (188)

  } u3; // offset: 0xbc (188)
  union {
    struct _MMINPAGE_FLAGS e1; // offset: 0xc0 (192)
    ULONG LongFlags;           // offset: 0xc0 (192)

  } u1; // offset: 0xc0 (192)
  union {
    struct _FILE_OBJECT *FilePointer;  // offset: 0xc8 (200)
    struct _MMPAGING_FILE *PagingFile; // offset: 0xc8 (200)
  };
  union {
    struct _CONTROL_AREA *ControlArea; // offset: 0xd0 (208)
    struct _SUBSECTION *Subsection;    // offset: 0xd0 (208)
  };
  VOID *Autoboost;              // offset: 0xd8 (216)
  VOID *FaultingAddress;        // offset: 0xe0 (224)
  struct _MMPTE *PointerPte;    // offset: 0xe8 (232)
  struct _MMPTE *BasePte;       // offset: 0xf0 (240)
  struct _MMPFN *Pfn;           // offset: 0xf8 (248)
  struct _MDL *PrefetchMdl;     // offset: 0x100 (256)
  volatile LONGLONG ProbeCount; // offset: 0x108 (264)
  struct _MDL Mdl;              // offset: 0x110 (272)
  union {
    ULONGLONG Page[16];                                // offset: 0x140 (320)
    struct _MMINPAGE_SUPPORT_FLOW_THROUGH FlowThrough; // offset: 0x140 (320)
  };
};

// 0xb0 (176) bytes
struct _MI_PAGING_IO_STATE {
  struct _RTL_AVL_TREE PageFileHead;                     // offset: 0x0 (0)
  volatile LONG PageFileHeadSpinLock;                    // offset: 0x8 (8)
  LONG PrefetchSeekThreshold;                            // offset: 0xc (12)
  ULONG InPageSinglePages;                               // offset: 0x10 (16)
  union _SLIST_HEADER InPageSupportSListHead[2];         // offset: 0x20 (32)
  union _SLIST_HEADER ReservedInPageSupportSListHead[2]; // offset: 0x40 (64)
  UCHAR InPageSupportSListMinimum[2];                    // offset: 0x60 (96)
  struct _MMINPAGE_SUPPORT *FirstReservedInPageBlock[2]; // offset: 0x68 (104)
  struct _MMINPAGE_SUPPORT *LastReservedInPageBlock[2];  // offset: 0x78 (120)
  struct _MMPTE *ReservedPtes;                           // offset: 0x88 (136)
  ULONGLONG ReservedPtesLock;                            // offset: 0x90 (144)
  ULONG ReservedPtesBitBuffer;                           // offset: 0x98 (152)
  volatile LONG DelayPageFaults;                         // offset: 0x9c (156)
  ULONG FileCompressionBoundary;                         // offset: 0xa0 (160)
  UCHAR MdlsAdjusted;                                    // offset: 0xa4 (164)
};

// 0x32c0 (12992) bytes
struct _MI_SYSTEM_INFORMATION {
  struct _MI_POOL_STATE Pools;                // offset: 0x0 (0)
  struct _MI_SECTION_STATE Sections;          // offset: 0xc0 (192)
  struct _MI_SYSTEM_IMAGE_STATE SystemImages; // offset: 0x400 (1024)
  struct _MI_SESSION_STATE Sessions;          // offset: 0x4a8 (1192)
  struct _MI_PROCESS_STATE Processes;         // offset: 0x1550 (5456)
  struct _MI_HARDWARE_STATE Hardware;         // offset: 0x15c0 (5568)
  struct _MI_SYSTEM_VA_STATE SystemVa;        // offset: 0x1780 (6016)
  struct _MI_COMBINE_STATE PageCombines;      // offset: 0x1c40 (7232)
  struct _MI_PAGELIST_STATE PageLists;        // offset: 0x1c60 (7264)
  struct _MI_PARTITION_STATE Partitions;      // offset: 0x1d00 (7424)
  struct _MI_SHUTDOWN_STATE Shutdowns;        // offset: 0x1dc0 (7616)
  struct _MI_ERROR_STATE Errors;              // offset: 0x1e38 (7736)
  struct _MI_ACCESS_LOG_STATE AccessLog;      // offset: 0x1f00 (7936)
  struct _MI_DEBUGGER_STATE Debugger;         // offset: 0x1f80 (8064)
  struct _MI_STANDBY_STATE Standby;           // offset: 0x20a0 (8352)
  struct _MI_SYSTEM_PTE_STATE SystemPtes;     // offset: 0x2140 (8512)
  struct _MI_IO_PAGE_STATE IoPages;           // offset: 0x2340 (9024)
  struct _MI_PAGING_IO_STATE PagingIo;        // offset: 0x23b0 (9136)
  struct _MI_COMMON_PAGE_STATE CommonPages;   // offset: 0x2460 (9312)
  struct _MI_SYSTEM_TRIM_STATE Trims;         // offset: 0x2540 (9536)
  struct _MI_ENCLAVE_STATE Enclaves;          // offset: 0x2580 (9600)
  ULONGLONG Cookie;                           // offset: 0x25c8 (9672)
  VOID *volatile *BootRegistryRuns;           // offset: 0x25d0 (9680)
  volatile LONG ZeroingDisabled;              // offset: 0x25d8 (9688)
  UCHAR FullyInitialized;                     // offset: 0x25dc (9692)
  UCHAR SafeBooted;                           // offset: 0x25dd (9693)
  struct _tlgProvider_t *TraceLogging;        // offset: 0x25e0 (9696)
  struct _MI_VISIBLE_STATE Vs;                // offset: 0x2600 (9728)
};

// 0x48 (72) bytes
struct _MI_VAD_EVENT_BLOCK {
  struct _MI_VAD_EVENT_BLOCK *Next; // offset: 0x0 (0)
  union {
    struct _KGATE Gate;                      // offset: 0x8 (8)
    struct _MMADDRESS_LIST SecureInfo;       // offset: 0x8 (8)
    struct _RTL_BITMAP_EX BitMap;            // offset: 0x8 (8)
    struct _MMINPAGE_SUPPORT *InPageSupport; // offset: 0x8 (8)
    struct _MI_LARGEPAGE_VAD_INFO LargePage; // offset: 0x8 (8)
    struct _MI_PHYSICAL_VIEW AweView;        // offset: 0x8 (8)
    struct _ETHREAD *CreatingThread;         // offset: 0x8 (8)
    struct _MI_SUB64K_FREE_RANGES PebTeb;    // offset: 0x8 (8)
    struct _MMVAD_SHORT *PlaceholderVad;     // offset: 0x8 (8)
  };
  ULONG WaitReason; // offset: 0x40 (64)
};

// 0x108 (264) bytes
struct _MMMOD_WRITER_MDL_ENTRY {
  struct _LIST_ENTRY Links; // offset: 0x0 (0)
  union {
    struct _IO_STATUS_BLOCK IoStatus; // offset: 0x10 (16)

  } u;                                  // offset: 0x10 (16)
  struct _IRP *Irp;                     // offset: 0x20 (32)
  struct _MODWRITER_FLAGS u1;           // offset: 0x28 (40)
  ULONG StoreWriteRefCount;             // offset: 0x2c (44)
  struct _KAPC StoreWriteCompletionApc; // offset: 0x30 (48)
  ULONG ByteCount;                      // offset: 0x88 (136)
  ULONG ChargedPages;                   // offset: 0x8c (140)
  struct _MMPAGING_FILE *PagingFile;    // offset: 0x90 (144)
  struct _FILE_OBJECT *File;            // offset: 0x98 (152)
  struct _CONTROL_AREA *ControlArea;    // offset: 0xa0 (160)
  struct _ERESOURCE *FileResource;      // offset: 0xa8 (168)
  union _LARGE_INTEGER WriteOffset;     // offset: 0xb0 (176)
  union _LARGE_INTEGER IssueTime;       // offset: 0xb8 (184)
  struct _MI_PARTITION *Partition;      // offset: 0xc0 (192)
  struct _MDL *PointerMdl;              // offset: 0xc8 (200)
  struct _MDL Mdl;                      // offset: 0xd0 (208)
  ULONGLONG Page[1];                    // offset: 0x100 (256)
};

// 0x58 (88) bytes
struct _MMPAGE_FILE_EXPANSION {
  struct _SEGMENT *Segment;           // offset: 0x0 (0)
  struct _LIST_ENTRY DereferenceList; // offset: 0x8 (8)
  struct _MI_PARTITION *Partition;    // offset: 0x18 (24)
  ULONGLONG RequestedExpansionSize;   // offset: 0x20 (32)
  ULONGLONG ActualExpansion;          // offset: 0x28 (40)
  struct _KEVENT Event;               // offset: 0x30 (48)
  volatile LONG InProgress;           // offset: 0x48 (72)
  union {
    ULONG LongFlags;                           // offset: 0x4c (76)
    struct _MMPAGE_FILE_EXPANSION_FLAGS Flags; // offset: 0x4c (76)

  } u1;                        // offset: 0x4c (76)
  VOID **volatile ActiveEntry; // offset: 0x50 (80)
};

// 0x20 (32) bytes
struct _MMCLONE_HEADER {
  ULONGLONG NumberOfPtes;                       // offset: 0x0 (0)
  volatile ULONGLONG NumberOfProcessReferences; // offset: 0x8 (8)
  struct _MMCLONE_BLOCK *ClonePtes;             // offset: 0x10 (16)
  struct _MI_PARTITION *Partition;              // offset: 0x18 (24)
};

// 0x70 (112) bytes
struct _MMCLONE_DESCRIPTOR {
  union {
    struct _RTL_BALANCED_NODE CloneNode; // offset: 0x0 (0)
    struct _MMCLONE_DESCRIPTOR *Next;    // offset: 0x0 (0)
  };
  struct _MMCLONE_BLOCK *StartingCloneBlock; // offset: 0x18 (24)
  struct _MMCLONE_BLOCK *EndingCloneBlock;   // offset: 0x20 (32)
  ULONGLONG NumberOfPtes;                    // offset: 0x28 (40)
  volatile ULONGLONG NumberOfReferences;     // offset: 0x30 (48)
  struct _MMCLONE_HEADER *CloneHeader;       // offset: 0x38 (56)
  ULONGLONG NonPagedPoolQuotaCharge;         // offset: 0x40 (64)
  struct _SLIST_ENTRY DeleteList;            // offset: 0x50 (80)
  ULONGLONG NestingLevel;                    // offset: 0x60 (96)
};

// 0x10 (16) bytes
struct LIST_ENTRY64 {
  ULONGLONG Flink; // offset: 0x0 (0)
  ULONGLONG Blink; // offset: 0x8 (8)
};

// 0x7c8 (1992) bytes
struct _PEB64 {
  UCHAR InheritedAddressSpace;    // offset: 0x0 (0)
  UCHAR ReadImageFileExecOptions; // offset: 0x1 (1)
  UCHAR BeingDebugged;            // offset: 0x2 (2)
  union {
    UCHAR BitField; // offset: 0x3 (3)
    struct {
      UCHAR ImageUsesLargePages : 1;          // offset: 0x3 (3)
      UCHAR IsProtectedProcess : 1;           // offset: 0x3 (3)
      UCHAR IsImageDynamicallyRelocated : 1;  // offset: 0x3 (3)
      UCHAR SkipPatchingUser32Forwarders : 1; // offset: 0x3 (3)
      UCHAR IsPackagedProcess : 1;            // offset: 0x3 (3)
      UCHAR IsAppContainer : 1;               // offset: 0x3 (3)
      UCHAR IsProtectedProcessLight : 1;      // offset: 0x3 (3)
      UCHAR IsLongPathAwareProcess : 1;       // offset: 0x3 (3)
    };
  };
  UCHAR Padding0[4];           // offset: 0x4 (4)
  ULONGLONG Mutant;            // offset: 0x8 (8)
  ULONGLONG ImageBaseAddress;  // offset: 0x10 (16)
  ULONGLONG Ldr;               // offset: 0x18 (24)
  ULONGLONG ProcessParameters; // offset: 0x20 (32)
  ULONGLONG SubSystemData;     // offset: 0x28 (40)
  ULONGLONG ProcessHeap;       // offset: 0x30 (48)
  ULONGLONG FastPebLock;       // offset: 0x38 (56)
  ULONGLONG AtlThunkSListPtr;  // offset: 0x40 (64)
  ULONGLONG IFEOKey;           // offset: 0x48 (72)
  union {
    ULONG CrossProcessFlags; // offset: 0x50 (80)
    struct {
      ULONG ProcessInJob : 1;               // offset: 0x50 (80)
      ULONG ProcessInitializing : 1;        // offset: 0x50 (80)
      ULONG ProcessUsingVEH : 1;            // offset: 0x50 (80)
      ULONG ProcessUsingVCH : 1;            // offset: 0x50 (80)
      ULONG ProcessUsingFTH : 1;            // offset: 0x50 (80)
      ULONG ProcessPreviouslyThrottled : 1; // offset: 0x50 (80)
      ULONG ProcessCurrentlyThrottled : 1;  // offset: 0x50 (80)
      ULONG ProcessImagesHotPatched : 1;    // offset: 0x50 (80)
      ULONG ReservedBits0 : 24;             // offset: 0x50 (80)
    };
  };
  UCHAR Padding1[4]; // offset: 0x54 (84)
  union {
    ULONGLONG KernelCallbackTable; // offset: 0x58 (88)
    ULONGLONG UserSharedInfoPtr;   // offset: 0x58 (88)
  };
  ULONG SystemReserved;                         // offset: 0x60 (96)
  ULONG AtlThunkSListPtr32;                     // offset: 0x64 (100)
  ULONGLONG ApiSetMap;                          // offset: 0x68 (104)
  ULONG TlsExpansionCounter;                    // offset: 0x70 (112)
  UCHAR Padding2[4];                            // offset: 0x74 (116)
  ULONGLONG TlsBitmap;                          // offset: 0x78 (120)
  ULONG TlsBitmapBits[2];                       // offset: 0x80 (128)
  ULONGLONG ReadOnlySharedMemoryBase;           // offset: 0x88 (136)
  ULONGLONG SharedData;                         // offset: 0x90 (144)
  ULONGLONG ReadOnlyStaticServerData;           // offset: 0x98 (152)
  ULONGLONG AnsiCodePageData;                   // offset: 0xa0 (160)
  ULONGLONG OemCodePageData;                    // offset: 0xa8 (168)
  ULONGLONG UnicodeCaseTableData;               // offset: 0xb0 (176)
  ULONG NumberOfProcessors;                     // offset: 0xb8 (184)
  ULONG NtGlobalFlag;                           // offset: 0xbc (188)
  union _LARGE_INTEGER CriticalSectionTimeout;  // offset: 0xc0 (192)
  ULONGLONG HeapSegmentReserve;                 // offset: 0xc8 (200)
  ULONGLONG HeapSegmentCommit;                  // offset: 0xd0 (208)
  ULONGLONG HeapDeCommitTotalFreeThreshold;     // offset: 0xd8 (216)
  ULONGLONG HeapDeCommitFreeBlockThreshold;     // offset: 0xe0 (224)
  ULONG NumberOfHeaps;                          // offset: 0xe8 (232)
  ULONG MaximumNumberOfHeaps;                   // offset: 0xec (236)
  ULONGLONG ProcessHeaps;                       // offset: 0xf0 (240)
  ULONGLONG GdiSharedHandleTable;               // offset: 0xf8 (248)
  ULONGLONG ProcessStarterHelper;               // offset: 0x100 (256)
  ULONG GdiDCAttributeList;                     // offset: 0x108 (264)
  UCHAR Padding3[4];                            // offset: 0x10c (268)
  ULONGLONG LoaderLock;                         // offset: 0x110 (272)
  ULONG OSMajorVersion;                         // offset: 0x118 (280)
  ULONG OSMinorVersion;                         // offset: 0x11c (284)
  USHORT OSBuildNumber;                         // offset: 0x120 (288)
  USHORT OSCSDVersion;                          // offset: 0x122 (290)
  ULONG OSPlatformId;                           // offset: 0x124 (292)
  ULONG ImageSubsystem;                         // offset: 0x128 (296)
  ULONG ImageSubsystemMajorVersion;             // offset: 0x12c (300)
  ULONG ImageSubsystemMinorVersion;             // offset: 0x130 (304)
  UCHAR Padding4[4];                            // offset: 0x134 (308)
  ULONGLONG ActiveProcessAffinityMask;          // offset: 0x138 (312)
  ULONG GdiHandleBuffer[60];                    // offset: 0x140 (320)
  ULONGLONG PostProcessInitRoutine;             // offset: 0x230 (560)
  ULONGLONG TlsExpansionBitmap;                 // offset: 0x238 (568)
  ULONG TlsExpansionBitmapBits[32];             // offset: 0x240 (576)
  ULONG SessionId;                              // offset: 0x2c0 (704)
  UCHAR Padding5[4];                            // offset: 0x2c4 (708)
  union _ULARGE_INTEGER AppCompatFlags;         // offset: 0x2c8 (712)
  union _ULARGE_INTEGER AppCompatFlagsUser;     // offset: 0x2d0 (720)
  ULONGLONG pShimData;                          // offset: 0x2d8 (728)
  ULONGLONG AppCompatInfo;                      // offset: 0x2e0 (736)
  struct _STRING64 CSDVersion;                  // offset: 0x2e8 (744)
  ULONGLONG ActivationContextData;              // offset: 0x2f8 (760)
  ULONGLONG ProcessAssemblyStorageMap;          // offset: 0x300 (768)
  ULONGLONG SystemDefaultActivationContextData; // offset: 0x308 (776)
  ULONGLONG SystemAssemblyStorageMap;           // offset: 0x310 (784)
  ULONGLONG MinimumStackCommit;                 // offset: 0x318 (792)
  ULONGLONG SparePointers[4];                   // offset: 0x320 (800)
  ULONG SpareUlongs[5];                         // offset: 0x340 (832)
  ULONGLONG WerRegistrationData;                // offset: 0x358 (856)
  ULONGLONG WerShipAssertPtr;                   // offset: 0x360 (864)
  ULONGLONG pUnused;                            // offset: 0x368 (872)
  ULONGLONG pImageHeaderHash;                   // offset: 0x370 (880)
  union {
    ULONG TracingFlags; // offset: 0x378 (888)
    struct {
      ULONG HeapTracingEnabled : 1;      // offset: 0x378 (888)
      ULONG CritSecTracingEnabled : 1;   // offset: 0x378 (888)
      ULONG LibLoaderTracingEnabled : 1; // offset: 0x378 (888)
      ULONG SpareTracingBits : 29;       // offset: 0x378 (888)
    };
  };
  UCHAR Padding6[4];                            // offset: 0x37c (892)
  ULONGLONG CsrServerReadOnlySharedMemoryBase;  // offset: 0x380 (896)
  ULONGLONG TppWorkerpListLock;                 // offset: 0x388 (904)
  struct LIST_ENTRY64 TppWorkerpList;           // offset: 0x390 (912)
  ULONGLONG WaitOnAddressHashTable[128];        // offset: 0x3a0 (928)
  ULONGLONG TelemetryCoverageHeader;            // offset: 0x7a0 (1952)
  ULONG CloudFileFlags;                         // offset: 0x7a8 (1960)
  ULONG CloudFileDiagFlags;                     // offset: 0x7ac (1964)
  CHAR PlaceholderCompatibilityMode;            // offset: 0x7b0 (1968)
  CHAR PlaceholderCompatibilityModeReserved[7]; // offset: 0x7b1 (1969)
  ULONGLONG LeapSecondData;                     // offset: 0x7b8 (1976)
  union {
    ULONG LeapSecondFlags; // offset: 0x7c0 (1984)
    struct {
      ULONG SixtySecondEnabled : 1; // offset: 0x7c0 (1984)
      ULONG Reserved : 31;          // offset: 0x7c0 (1984)
    };
  };
  ULONG NtGlobalFlag2; // offset: 0x7c4 (1988)
};

// 0x28 (40) bytes
struct _ACTIVATION_CONTEXT_STACK64 {
  ULONGLONG ActiveFrame;              // offset: 0x0 (0)
  struct LIST_ENTRY64 FrameListCache; // offset: 0x8 (8)
  ULONG Flags;                        // offset: 0x18 (24)
  ULONG NextCookieSequenceNumber;     // offset: 0x1c (28)
  ULONG StackId;                      // offset: 0x20 (32)
};

// 0x1838 (6200) bytes
struct _TEB64 {
  struct _NT_TIB64 NtTib;                              // offset: 0x0 (0)
  ULONGLONG EnvironmentPointer;                        // offset: 0x38 (56)
  struct _CLIENT_ID64 ClientId;                        // offset: 0x40 (64)
  ULONGLONG ActiveRpcHandle;                           // offset: 0x50 (80)
  ULONGLONG ThreadLocalStoragePointer;                 // offset: 0x58 (88)
  ULONGLONG ProcessEnvironmentBlock;                   // offset: 0x60 (96)
  ULONG LastErrorValue;                                // offset: 0x68 (104)
  ULONG CountOfOwnedCriticalSections;                  // offset: 0x6c (108)
  ULONGLONG CsrClientThread;                           // offset: 0x70 (112)
  ULONGLONG Win32ThreadInfo;                           // offset: 0x78 (120)
  ULONG User32Reserved[26];                            // offset: 0x80 (128)
  ULONG UserReserved[5];                               // offset: 0xe8 (232)
  ULONGLONG WOW32Reserved;                             // offset: 0x100 (256)
  ULONG CurrentLocale;                                 // offset: 0x108 (264)
  ULONG FpSoftwareStatusRegister;                      // offset: 0x10c (268)
  ULONGLONG ReservedForDebuggerInstrumentation[16];    // offset: 0x110 (272)
  ULONGLONG SystemReserved1[30];                       // offset: 0x190 (400)
  CHAR PlaceholderCompatibilityMode;                   // offset: 0x280 (640)
  UCHAR PlaceholderHydrationAlwaysExplicit;            // offset: 0x281 (641)
  CHAR PlaceholderReserved[10];                        // offset: 0x282 (642)
  ULONG ProxiedProcessId;                              // offset: 0x28c (652)
  struct _ACTIVATION_CONTEXT_STACK64 _ActivationStack; // offset: 0x290 (656)
  UCHAR WorkingOnBehalfTicket[8];                      // offset: 0x2b8 (696)
  LONG ExceptionCode;                                  // offset: 0x2c0 (704)
  UCHAR Padding0[4];                                   // offset: 0x2c4 (708)
  ULONGLONG ActivationContextStackPointer;             // offset: 0x2c8 (712)
  ULONGLONG InstrumentationCallbackSp;                 // offset: 0x2d0 (720)
  ULONGLONG InstrumentationCallbackPreviousPc;         // offset: 0x2d8 (728)
  ULONGLONG InstrumentationCallbackPreviousSp;         // offset: 0x2e0 (736)
  ULONG TxFsContext;                                   // offset: 0x2e8 (744)
  UCHAR InstrumentationCallbackDisabled;               // offset: 0x2ec (748)
  UCHAR UnalignedLoadStoreExceptions;                  // offset: 0x2ed (749)
  UCHAR Padding1[2];                                   // offset: 0x2ee (750)
  struct _GDI_TEB_BATCH64 GdiTebBatch;                 // offset: 0x2f0 (752)
  struct _CLIENT_ID64 RealClientId;                    // offset: 0x7d8 (2008)
  ULONGLONG GdiCachedProcessHandle;                    // offset: 0x7e8 (2024)
  ULONG GdiClientPID;                                  // offset: 0x7f0 (2032)
  ULONG GdiClientTID;                                  // offset: 0x7f4 (2036)
  ULONGLONG GdiThreadLocalInfo;                        // offset: 0x7f8 (2040)
  ULONGLONG Win32ClientInfo[62];                       // offset: 0x800 (2048)
  ULONGLONG glDispatchTable[233];                      // offset: 0x9f0 (2544)
  ULONGLONG glReserved1[29];                           // offset: 0x1138 (4408)
  ULONGLONG glReserved2;                               // offset: 0x1220 (4640)
  ULONGLONG glSectionInfo;                             // offset: 0x1228 (4648)
  ULONGLONG glSection;                                 // offset: 0x1230 (4656)
  ULONGLONG glTable;                                   // offset: 0x1238 (4664)
  ULONGLONG glCurrentRC;                               // offset: 0x1240 (4672)
  ULONGLONG glContext;                                 // offset: 0x1248 (4680)
  ULONG LastStatusValue;                               // offset: 0x1250 (4688)
  UCHAR Padding2[4];                                   // offset: 0x1254 (4692)
  struct _STRING64 StaticUnicodeString;                // offset: 0x1258 (4696)
  WCHAR StaticUnicodeBuffer[261];                      // offset: 0x1268 (4712)
  UCHAR Padding3[6];                                   // offset: 0x1472 (5234)
  ULONGLONG DeallocationStack;                         // offset: 0x1478 (5240)
  ULONGLONG TlsSlots[64];                              // offset: 0x1480 (5248)
  struct LIST_ENTRY64 TlsLinks;                        // offset: 0x1680 (5760)
  ULONGLONG Vdm;                                       // offset: 0x1690 (5776)
  ULONGLONG ReservedForNtRpc;                          // offset: 0x1698 (5784)
  ULONGLONG DbgSsReserved[2];                          // offset: 0x16a0 (5792)
  ULONG HardErrorMode;                                 // offset: 0x16b0 (5808)
  UCHAR Padding4[4];                                   // offset: 0x16b4 (5812)
  ULONGLONG Instrumentation[11];                       // offset: 0x16b8 (5816)
  struct _GUID ActivityId;                             // offset: 0x1710 (5904)
  ULONGLONG SubProcessTag;                             // offset: 0x1720 (5920)
  ULONGLONG PerflibData;                               // offset: 0x1728 (5928)
  ULONGLONG EtwTraceData;                              // offset: 0x1730 (5936)
  ULONGLONG WinSockData;                               // offset: 0x1738 (5944)
  ULONG GdiBatchCount;                                 // offset: 0x1740 (5952)
  union {
    struct _PROCESSOR_NUMBER CurrentIdealProcessor; // offset: 0x1744 (5956)
    ULONG IdealProcessorValue;                      // offset: 0x1744 (5956)
    struct {
      UCHAR ReservedPad0;   // offset: 0x1744 (5956)
      UCHAR ReservedPad1;   // offset: 0x1745 (5957)
      UCHAR ReservedPad2;   // offset: 0x1746 (5958)
      UCHAR IdealProcessor; // offset: 0x1747 (5959)
    };
  };
  ULONG GuaranteedStackBytes;         // offset: 0x1748 (5960)
  UCHAR Padding5[4];                  // offset: 0x174c (5964)
  ULONGLONG ReservedForPerf;          // offset: 0x1750 (5968)
  ULONGLONG ReservedForOle;           // offset: 0x1758 (5976)
  ULONG WaitingOnLoaderLock;          // offset: 0x1760 (5984)
  UCHAR Padding6[4];                  // offset: 0x1764 (5988)
  ULONGLONG SavedPriorityState;       // offset: 0x1768 (5992)
  ULONGLONG ReservedForCodeCoverage;  // offset: 0x1770 (6000)
  ULONGLONG ThreadPoolData;           // offset: 0x1778 (6008)
  ULONGLONG TlsExpansionSlots;        // offset: 0x1780 (6016)
  ULONGLONG DeallocationBStore;       // offset: 0x1788 (6024)
  ULONGLONG BStoreLimit;              // offset: 0x1790 (6032)
  ULONG MuiGeneration;                // offset: 0x1798 (6040)
  ULONG IsImpersonating;              // offset: 0x179c (6044)
  ULONGLONG NlsCache;                 // offset: 0x17a0 (6048)
  ULONGLONG pShimData;                // offset: 0x17a8 (6056)
  ULONG HeapData;                     // offset: 0x17b0 (6064)
  UCHAR Padding7[4];                  // offset: 0x17b4 (6068)
  ULONGLONG CurrentTransactionHandle; // offset: 0x17b8 (6072)
  ULONGLONG ActiveFrame;              // offset: 0x17c0 (6080)
  ULONGLONG FlsData;                  // offset: 0x17c8 (6088)
  ULONGLONG PreferredLanguages;       // offset: 0x17d0 (6096)
  ULONGLONG UserPrefLanguages;        // offset: 0x17d8 (6104)
  ULONGLONG MergedPrefLanguages;      // offset: 0x17e0 (6112)
  ULONG MuiImpersonation;             // offset: 0x17e8 (6120)
  union {
    volatile USHORT CrossTebFlags; // offset: 0x17ec (6124)
    USHORT SpareCrossTebBits : 16; // offset: 0x17ec (6124)
  };
  union {
    USHORT SameTebFlags; // offset: 0x17ee (6126)
    struct {
      USHORT SafeThunkCall : 1;        // offset: 0x17ee (6126)
      USHORT InDebugPrint : 1;         // offset: 0x17ee (6126)
      USHORT HasFiberData : 1;         // offset: 0x17ee (6126)
      USHORT SkipThreadAttach : 1;     // offset: 0x17ee (6126)
      USHORT WerInShipAssertCode : 1;  // offset: 0x17ee (6126)
      USHORT RanProcessInit : 1;       // offset: 0x17ee (6126)
      USHORT ClonedThread : 1;         // offset: 0x17ee (6126)
      USHORT SuppressDebugMsg : 1;     // offset: 0x17ee (6126)
      USHORT DisableUserStackWalk : 1; // offset: 0x17ee (6126)
      USHORT RtlExceptionAttached : 1; // offset: 0x17ee (6126)
      USHORT InitialThread : 1;        // offset: 0x17ee (6126)
      USHORT SessionAware : 1;         // offset: 0x17ee (6126)
      USHORT LoadOwner : 1;            // offset: 0x17ee (6126)
      USHORT LoaderWorker : 1;         // offset: 0x17ee (6126)
      USHORT SkipLoaderInit : 1;       // offset: 0x17ee (6126)
      USHORT SpareSameTebBits : 1;     // offset: 0x17ee (6126)
    };
  };
  ULONGLONG TxnScopeEnterCallback;   // offset: 0x17f0 (6128)
  ULONGLONG TxnScopeExitCallback;    // offset: 0x17f8 (6136)
  ULONGLONG TxnScopeContext;         // offset: 0x1800 (6144)
  ULONG LockCount;                   // offset: 0x1808 (6152)
  LONG WowTebOffset;                 // offset: 0x180c (6156)
  ULONGLONG ResourceRetValue;        // offset: 0x1810 (6160)
  ULONGLONG ReservedForWdf;          // offset: 0x1818 (6168)
  ULONGLONG ReservedForCrt;          // offset: 0x1820 (6176)
  struct _GUID EffectiveContainerId; // offset: 0x1828 (6184)
};
