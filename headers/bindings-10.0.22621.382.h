// 0x0 bytes (sizeof)
typedef struct _LDRP_LOAD_CONTEXT {
} _LDRP_LOAD_CONTEXT;

// 0x0 bytes (sizeof)
typedef struct _VERIFIER_SHARED_EXPORT_THUNK {
} _VERIFIER_SHARED_EXPORT_THUNK;

// 0x18 bytes (sizeof)
typedef struct _VF_TARGET_ALL_SHARED_EXPORT_THUNKS {
  struct _VERIFIER_SHARED_EXPORT_THUNK
      *SharedExportThunks; // offset: 0x0 ordinal: 0x0
  struct _VERIFIER_SHARED_EXPORT_THUNK
      *PoolSharedExportThunks; // offset: 0x8 ordinal: 0x1
  struct _VERIFIER_SHARED_EXPORT_THUNK
      *XdvSharedExportThunks; // offset: 0x10 ordinal: 0x2
} _VF_TARGET_ALL_SHARED_EXPORT_THUNKS;

// 0x0 bytes (sizeof)
typedef struct _ACTIVATION_CONTEXT_DATA {
} _ACTIVATION_CONTEXT_DATA;

// 0x0 bytes (sizeof)
typedef struct _CALLBACK_OBJECT {
} _CALLBACK_OBJECT;

// 0x8 bytes (sizeof)
typedef struct __anon_2713 {
  struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x0 ordinal: 0x0
} __anon_2713;

typedef unsigned char UCHAR;

typedef unsigned long long ULONGLONG;

typedef void VOID;

// 0x0 bytes (sizeof)
typedef struct _PCW_INSTANCE {
} _PCW_INSTANCE;

// 0x0 bytes (sizeof)
typedef struct _PCW_REGISTRATION {
} _PCW_REGISTRATION;

// 0x0 bytes (sizeof)
typedef struct _PCW_BUFFER {
} _PCW_BUFFER;

// 0x0 bytes (sizeof)
typedef struct _KTMNOTIFICATION_PACKET {
} _KTMNOTIFICATION_PACKET;

// 0x0 bytes (sizeof)
typedef struct _MI_SLAB_ALLOCATOR_ENTRY {
} _MI_SLAB_ALLOCATOR_ENTRY;

typedef char CHAR;

typedef unsigned int HRESULT;

typedef unsigned short USHORT;

// 0x10 bytes (sizeof)
typedef struct _SLIST_ENTRY {
  struct _SLIST_ENTRY *Next; // offset: 0x0 ordinal: 0x0
} _SLIST_ENTRY;

// 0x0 bytes (sizeof)
typedef struct _CHPEV2_CPUAREA_INFO {
} _CHPEV2_CPUAREA_INFO;

// 0x0 bytes (sizeof)
typedef struct _TP_CALLBACK_INSTANCE {
} _TP_CALLBACK_INSTANCE;

// 0x0 bytes (sizeof)
typedef struct _ACTIVATION_CONTEXT {
} _ACTIVATION_CONTEXT;

// 0x0 bytes (sizeof)
typedef struct _TP_CLEANUP_GROUP {
} _TP_CLEANUP_GROUP;

// 0x0 bytes (sizeof)
typedef struct _TP_POOL {
} _TP_POOL;

// 0x0 bytes (sizeof)
typedef struct _DMAR_PAGE_TABLE_STATE {
} _DMAR_PAGE_TABLE_STATE;

// 0x8 bytes (sizeof)
typedef struct _EXT_IOMMU_DEVICE_ID_ACPI {
  CHAR *ObjectName; // offset: 0x0 ordinal: 0x0
} _EXT_IOMMU_DEVICE_ID_ACPI;

typedef unsigned short WCHAR;

// 0x18 bytes (sizeof)
typedef struct _RTL_SPLAY_LINKS {
  struct _RTL_SPLAY_LINKS *Parent;     // offset: 0x0 ordinal: 0x0
  struct _RTL_SPLAY_LINKS *LeftChild;  // offset: 0x8 ordinal: 0x1
  struct _RTL_SPLAY_LINKS *RightChild; // offset: 0x10 ordinal: 0x2
} _RTL_SPLAY_LINKS;

// 0x0 bytes (sizeof)
typedef struct _HAL_PMC_COUNTERS {
} _HAL_PMC_COUNTERS;

// 0x0 bytes (sizeof)
typedef struct _SCSI_REQUEST_BLOCK {
} _SCSI_REQUEST_BLOCK;

// 0x0 bytes (sizeof)
typedef struct _EX_TIMER {
} _EX_TIMER;

// 0x8 bytes (sizeof)
typedef struct __anon_1007 {
  struct _SCSI_REQUEST_BLOCK *Srb; // offset: 0x0 ordinal: 0x0
} __anon_1007;

// 0x0 bytes (sizeof)
typedef struct _DEVICE_NODE_IOMMU_EXTENSION {
} _DEVICE_NODE_IOMMU_EXTENSION;

// 0x0 bytes (sizeof)
typedef struct _ETW_EVENT_CALLBACK_CONTEXT {
} _ETW_EVENT_CALLBACK_CONTEXT;

// 0x0 bytes (sizeof)
typedef struct _ETW_SOFT_RESTART_CONTEXT {
} _ETW_SOFT_RESTART_CONTEXT;

// 0x0 bytes (sizeof)
typedef struct _ETW_STACK_CACHE {
} _ETW_STACK_CACHE;

// 0x0 bytes (sizeof)
typedef struct _ETW_PERFECT_HASH_FUNCTION {
} _ETW_PERFECT_HASH_FUNCTION;

typedef unsigned long ULONG;

// 0x8 bytes (sizeof)
typedef struct _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI {
  ULONG InputMappingBase; // offset: 0x0 ordinal: 0x0
  ULONG MappingsCount;    // offset: 0x4 ordinal: 0x1
} _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI;

// 0xc bytes (sizeof)
typedef struct _RTL_FEATURE_CONFIGURATION {
  ULONG FeatureId;               // offset: 0x0 ordinal: 0x0
  ULONG Priority : 4;            // offset: 0x4 ordinal: 0x1
  ULONG EnabledState : 2;        // offset: 0x4 ordinal: 0x2
  ULONG IsWexpConfiguration : 1; // offset: 0x4 ordinal: 0x3
  ULONG HasSubscriptions : 1;    // offset: 0x4 ordinal: 0x4
  ULONG Variant : 6;             // offset: 0x4 ordinal: 0x5
  ULONG VariantPayloadKind : 2;  // offset: 0x4 ordinal: 0x6
  ULONG VariantPayload;          // offset: 0x8 ordinal: 0x7
} _RTL_FEATURE_CONFIGURATION;

// 0x4 bytes (sizeof)
typedef union wil_details_RecordedState {
  ULONG exchange;                               // offset: 0x0 ordinal: 0x0
  ULONG recordedDeviceUsage : 1;                // offset: 0x0 ordinal: 0x1
  ULONG recordedDevicePotential : 1;            // offset: 0x0 ordinal: 0x2
  ULONG recordedDeviceOpportunity : 1;          // offset: 0x0 ordinal: 0x3
  ULONG recordedDevicePotentialOpportunity : 1; // offset: 0x0 ordinal: 0x4
  ULONG recordedVariantDeviceUsage : 1;         // offset: 0x0 ordinal: 0x5
  ULONG recordedVariant : 6;                    // offset: 0x0 ordinal: 0x6
  ULONG unused : 21;                            // offset: 0x0 ordinal: 0x7
} wil_details_RecordedState;

// 0x4 bytes (sizeof)
typedef union wil_details_ReportedState {
  ULONG exchange;                                // offset: 0x0 ordinal: 0x0
  ULONG queuedForReporting : 1;                  // offset: 0x0 ordinal: 0x1
  ULONG reportedDeviceUsage : 1;                 // offset: 0x0 ordinal: 0x2
  ULONG reportedDevicePotential : 1;             // offset: 0x0 ordinal: 0x3
  ULONG reportedDeviceOpportunity : 1;           // offset: 0x0 ordinal: 0x4
  ULONG reportedDevicePotentialOpportunity : 1;  // offset: 0x0 ordinal: 0x5
  ULONG usageCount : 9;                          // offset: 0x0 ordinal: 0x6
  ULONG usageCountRepresentsPotential : 1;       // offset: 0x0 ordinal: 0x7
  ULONG opportunityCount : 7;                    // offset: 0x0 ordinal: 0x8
  ULONG opportunityCountRepresentsPotential : 1; // offset: 0x0 ordinal: 0x9
  ULONG unused : 9;                              // offset: 0x0 ordinal: 0xa
} wil_details_ReportedState;

// 0x8 bytes (sizeof)
typedef struct wil_details_FeatureReportingCache {
  union wil_details_ReportedState reported; // offset: 0x0 ordinal: 0x0
  union wil_details_RecordedState recorded; // offset: 0x4 ordinal: 0x1
} wil_details_FeatureReportingCache;

// 0x4 bytes (sizeof)
typedef union _EXT_IOMMU_CREATE_DEVICE_FLAGS {
  ULONG AsUINT32;        // offset: 0x0 ordinal: 0x0
  ULONG WildCard : 1;    // offset: 0x0 ordinal: 0x1
  ULONG ForceCreate : 1; // offset: 0x0 ordinal: 0x2
  ULONG LiveTraffic : 1; // offset: 0x0 ordinal: 0x3
  ULONG Reserved : 29;   // offset: 0x0 ordinal: 0x4
} _EXT_IOMMU_CREATE_DEVICE_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _EXT_IOMMU_DEVICE_ID_GIC {
  ULONG LineNumber; // offset: 0x0 ordinal: 0x0
} _EXT_IOMMU_DEVICE_ID_GIC;

// 0x4 bytes (sizeof)
typedef struct __anon_1442 {
  ULONG RecoveryAttempted : 1; // offset: 0x0 ordinal: 0x0
  ULONG HvHandled : 1;         // offset: 0x0 ordinal: 0x1
  ULONG Reserved : 30;         // offset: 0x0 ordinal: 0x2
} __anon_1442;

// 0x4 bytes (sizeof)
typedef struct __anon_1441 {
  ULONG NotSupported : 1;             // offset: 0x0 ordinal: 0x0
  ULONG Overflow : 1;                 // offset: 0x0 ordinal: 0x1
  ULONG ContextCorrupt : 1;           // offset: 0x0 ordinal: 0x2
  ULONG RestartIpErrorIpNotValid : 1; // offset: 0x0 ordinal: 0x3
  ULONG NoRecoveryContext : 1;        // offset: 0x0 ordinal: 0x4
  ULONG MiscOrAddrNotValid : 1;       // offset: 0x0 ordinal: 0x5
  ULONG InvalidAddressMode : 1;       // offset: 0x0 ordinal: 0x6
  ULONG HighIrql : 1;                 // offset: 0x0 ordinal: 0x7
  ULONG InterruptsDisabled : 1;       // offset: 0x0 ordinal: 0x8
  ULONG SwapBusy : 1;                 // offset: 0x0 ordinal: 0x9
  ULONG StackOverflow : 1;            // offset: 0x0 ordinal: 0xa
  ULONG Reserved : 21;                // offset: 0x0 ordinal: 0xb
} __anon_1441;

// 0x8 bytes (sizeof)
typedef struct IORING_REGISTERED_BUFFER {
  ULONG BufferIndex; // offset: 0x0 ordinal: 0x0
  ULONG Offset;      // offset: 0x4 ordinal: 0x1
} IORING_REGISTERED_BUFFER;

// 0x8 bytes (sizeof)
typedef struct _ETW_PARTITION_CONTEXT {
  struct _EPARTITION *Partition; // offset: 0x0 ordinal: 0x0
} _ETW_PARTITION_CONTEXT;

// 0x8 bytes (sizeof)
typedef union __anon_871 {
  struct _DEVICE_NODE *NextResourceDeviceNode; // offset: 0x0 ordinal: 0x0
} __anon_871;

// 0x0 bytes (sizeof)
typedef struct _EX_WNF_SUBSCRIPTION {
} _EX_WNF_SUBSCRIPTION;

// 0x0 bytes (sizeof)
typedef struct _DBGKP_ERROR_PORT {
} _DBGKP_ERROR_PORT;

// 0x0 bytes (sizeof)
typedef struct _CI_NGEN_PATHS {
} _CI_NGEN_PATHS;

// 0x0 bytes (sizeof)
typedef struct _NLS_STATE {
} _NLS_STATE;

// 0x0 bytes (sizeof)
typedef struct _EXP_LICENSE_STATE {
} _EXP_LICENSE_STATE;

// 0x10 bytes (sizeof)
typedef struct _PO_IRP_QUEUE {
  struct _IRP *CurrentIrp;     // offset: 0x0 ordinal: 0x0
  struct _IRP *PendingIrpList; // offset: 0x8 ordinal: 0x1
} _PO_IRP_QUEUE;

// 0x20 bytes (sizeof)
typedef struct _PO_IRP_MANAGER {
  struct _PO_IRP_QUEUE DeviceIrpQueue; // offset: 0x0 ordinal: 0x0
  struct _PO_IRP_QUEUE SystemIrpQueue; // offset: 0x10 ordinal: 0x1
} _PO_IRP_MANAGER;

typedef long LONG;

typedef enum _MEM_DEDICATED_ATTRIBUTE_TYPE {
  MemDedicatedAttributeReadBandwidth = 0,  // ordinal: 0x0
  MemDedicatedAttributeReadLatency = 1,    // ordinal: 0x1
  MemDedicatedAttributeWriteBandwidth = 2, // ordinal: 0x2
  MemDedicatedAttributeWriteLatency = 3,   // ordinal: 0x3
  MemDedicatedAttributeMax = 4,            // ordinal: 0x4
} _MEM_DEDICATED_ATTRIBUTE_TYPE;

typedef enum _MACHINE_CHECK_NESTING_LEVEL {
  McheckNormal = 0,        // ordinal: 0x0
  McheckNmi = 1,           // ordinal: 0x1
  McheckNestingLevels = 2, // ordinal: 0x2
} _MACHINE_CHECK_NESTING_LEVEL;

typedef enum _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS {
  JOBOBJECT_IO_PRIORITY_LIMIT_ENABLE = 1,      // ordinal: 0x0
  JOBOBJECT_IO_PRIORITY_LIMIT_VALID_FLAGS = 1, // ordinal: 0x1
} _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS;

typedef enum LSA_FOREST_TRUST_RECORD_TYPE {
  ForestTrustTopLevelName = 0,   // ordinal: 0x0
  ForestTrustTopLevelNameEx = 1, // ordinal: 0x1
  ForestTrustDomainInfo = 2,     // ordinal: 0x2
  ForestTrustBinaryInfo = 3,     // ordinal: 0x3
  ForestTrustScannerInfo = 4,    // ordinal: 0x4
  ForestTrustRecordTypeLast = 4, // ordinal: 0x5
} LSA_FOREST_TRUST_RECORD_TYPE;

typedef enum _CM_SHARE_DISPOSITION {
  CmResourceShareUndetermined = 0,    // ordinal: 0x0
  CmResourceShareDeviceExclusive = 1, // ordinal: 0x1
  CmResourceShareDriverExclusive = 2, // ordinal: 0x2
  CmResourceShareShared = 3,          // ordinal: 0x3
} _CM_SHARE_DISPOSITION;

typedef enum _CM_HIVE_CACHE_OPLOCK_FILE_TYPE {
  OplockOnPrimary = 0,   // ordinal: 0x0
  OplockOnLog1 = 1,      // ordinal: 0x1
  OplockOnLog2 = 2,      // ordinal: 0x2
  OplocksOnFilesMax = 3, // ordinal: 0x3
} _CM_HIVE_CACHE_OPLOCK_FILE_TYPE;

typedef enum _MI_AVAILABLE_PAGE_WAIT_TYPES {
  AvailablePagesWaitLow = 0,      // ordinal: 0x0
  AvailablePagesWaitHigh = 1,     // ordinal: 0x1
  AvailablePagesWaitVeryHigh = 2, // ordinal: 0x2
  AvailablePagesWaitMaximum = 3,  // ordinal: 0x3
} _MI_AVAILABLE_PAGE_WAIT_TYPES;

typedef enum _PO_MODERN_SLEEP_ACTION {
  PoModernSleepActionGlobalActivatorsVeto = 0,               // ordinal: 0x0
  PoModernSleepActionNonBlockingPhases = 1,                  // ordinal: 0x1
  PoModernSleepActionForceIdle = 2,                          // ordinal: 0x2
  PoModernSleepActionMinimalBlockingNotificationClients = 3, // ordinal: 0x3
  PoModernSleepActionMax = 4,                                // ordinal: 0x4
} _PO_MODERN_SLEEP_ACTION;

typedef enum _MI_MIRROR_BITMAP_TYPES {
  MirrorBitmapTypeNormal = 0,      // ordinal: 0x0
  MirrorBitmapTypeInterlocked = 1, // ordinal: 0x1
  MirrorBitmapTypeMaximum = 2,     // ordinal: 0x2
} _MI_MIRROR_BITMAP_TYPES;

typedef enum _KCONTINUE_TYPE {
  KCONTINUE_UNWIND = 0,   // ordinal: 0x0
  KCONTINUE_RESUME = 1,   // ordinal: 0x1
  KCONTINUE_LONGJUMP = 2, // ordinal: 0x2
  KCONTINUE_SET = 3,      // ordinal: 0x3
  KCONTINUE_LAST = 4,     // ordinal: 0x4
  KCONTINUE_INVALID = 4,  // ordinal: 0x5
} _KCONTINUE_TYPE;

typedef enum _MI_INPAGE_SUPPORT_TYPES {
  MiInPageSupportExpanded = 0, // ordinal: 0x0
  MiInPageSupportRegular = 1,  // ordinal: 0x1
  MiInPageSupportMaximum = 2,  // ordinal: 0x2
} _MI_INPAGE_SUPPORT_TYPES;

typedef enum SLEEPSTUDY_SPM_SCENARIO_CS_EXIT {
  SpmScenarioStopReasonUnspecified = 16,               // ordinal: 0x0
  SpmScenarioStopReasonCsExit = 17,                    // ordinal: 0x1
  SpmScenarioStopReasonInternalSegmentTransition = 18, // ordinal: 0x2
  SpmScenarioStopReasonMax = 19,                       // ordinal: 0x3
} SLEEPSTUDY_SPM_SCENARIO_CS_EXIT;

typedef enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
  JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 1,        // ordinal: 0x0
  JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 2, // ordinal: 0x1
  JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 4,      // ordinal: 0x2
  JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 7,   // ordinal: 0x3
} JOB_OBJECT_NET_RATE_CONTROL_FLAGS;

typedef enum PDC_ACTIVITY_TYPE {
  PdcNetwork = 0,         // ordinal: 0x0
  PdcSystem = 1,          // ordinal: 0x1
  PdcTimer = 2,           // ordinal: 0x2
  PdcAllNetworks = 3,     // ordinal: 0x3
  PdcAnyNetwork = 4,      // ordinal: 0x4
  PdcInvalidActivity = 5, // ordinal: 0x5
  PdcMaxActivity = 5,     // ordinal: 0x6
} PDC_ACTIVITY_TYPE;

typedef enum ReplacesCorHdrNumericDefines {
  COMIMAGE_FLAGS_ILONLY = 1,                      // ordinal: 0x0
  COMIMAGE_FLAGS_32BITREQUIRED = 2,               // ordinal: 0x1
  COMIMAGE_FLAGS_IL_LIBRARY = 4,                  // ordinal: 0x2
  COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,            // ordinal: 0x3
  COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,          // ordinal: 0x4
  COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,          // ordinal: 0x5
  COMIMAGE_FLAGS_32BITPREFERRED = 131072,         // ordinal: 0x6
  COR_VERSION_MAJOR_V2 = 2,                       // ordinal: 0x7
  COR_VERSION_MAJOR = 2,                          // ordinal: 0x8
  COR_VERSION_MINOR = 5,                          // ordinal: 0x9
  COR_DELETED_NAME_LENGTH = 8,                    // ordinal: 0xa
  COR_VTABLEGAP_NAME_LENGTH = 8,                  // ordinal: 0xb
  NATIVE_TYPE_MAX_CB = 1,                         // ordinal: 0xc
  COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,     // ordinal: 0xd
  IMAGE_COR_MIH_METHODRVA = 1,                    // ordinal: 0xe
  IMAGE_COR_MIH_EHRVA = 2,                        // ordinal: 0xf
  IMAGE_COR_MIH_BASICBLOCK = 8,                   // ordinal: 0x10
  COR_VTABLE_32BIT = 1,                           // ordinal: 0x11
  COR_VTABLE_64BIT = 2,                           // ordinal: 0x12
  COR_VTABLE_FROM_UNMANAGED = 4,                  // ordinal: 0x13
  COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8, // ordinal: 0x14
  COR_VTABLE_CALL_MOST_DERIVED = 16,              // ordinal: 0x15
  IMAGE_COR_EATJ_THUNK_SIZE = 32,                 // ordinal: 0x16
  MAX_CLASS_NAME = 1024,                          // ordinal: 0x17
  MAX_PACKAGE_NAME = 1024,                        // ordinal: 0x18
} ReplacesCorHdrNumericDefines;

typedef enum _VRF_TRIAGE_CONTEXT {
  VRF_TRIAGE_CONTEXT_NONE = 0,                 // ordinal: 0x0
  VRF_TRIAGE_CONTEXT_DEFAULT = 1,              // ordinal: 0x1
  VRF_TRIAGE_CONTEXT_DEVELOPMENT = 1,          // ordinal: 0x2
  VRF_TRIAGE_CONTEXT_CERTIFICATION = 2,        // ordinal: 0x3
  VRF_TRIAGE_CONTEXT_CERTIFICATION_STRICT = 3, // ordinal: 0x4
  VRF_TRIAGE_CONTEXT_FLIGHT_TARGETED = 4,      // ordinal: 0x5
  VRF_TRIAGE_CONTEXT_FLIGHT_DIAGNOSTICS = 5,   // ordinal: 0x6
  VRF_TRIAGE_CONTEXT_FLIGHT_MONITORING = 6,    // ordinal: 0x7
  NUM_VRF_TRIAGE_CONTEXTS = 7,                 // ordinal: 0x8
} _VRF_TRIAGE_CONTEXT;

typedef enum _PROCESS_TERMINATE_REQUEST_REASON {
  ProcessTerminateRequestReasonNone = 0,            // ordinal: 0x0
  ProcessTerminateCommitFail = 1,                   // ordinal: 0x1
  ProcessTerminateWriteToExecuteMemory = 2,         // ordinal: 0x2
  ProcessTerminateAttachedWriteToExecuteMemory = 3, // ordinal: 0x3
  ProcessTerminateRequestReasonMax = 4,             // ordinal: 0x4
} _PROCESS_TERMINATE_REQUEST_REASON;

typedef enum _SYSTEM_INFORMATION_CLASS {
  SystemBasicInformation = 0,                                  // ordinal: 0x0
  SystemProcessorInformation = 1,                              // ordinal: 0x1
  SystemPerformanceInformation = 2,                            // ordinal: 0x2
  SystemTimeOfDayInformation = 3,                              // ordinal: 0x3
  SystemPathInformation = 4,                                   // ordinal: 0x4
  SystemProcessInformation = 5,                                // ordinal: 0x5
  SystemCallCountInformation = 6,                              // ordinal: 0x6
  SystemDeviceInformation = 7,                                 // ordinal: 0x7
  SystemProcessorPerformanceInformation = 8,                   // ordinal: 0x8
  SystemFlagsInformation = 9,                                  // ordinal: 0x9
  SystemCallTimeInformation = 10,                              // ordinal: 0xa
  SystemModuleInformation = 11,                                // ordinal: 0xb
  SystemLocksInformation = 12,                                 // ordinal: 0xc
  SystemStackTraceInformation = 13,                            // ordinal: 0xd
  SystemPagedPoolInformation = 14,                             // ordinal: 0xe
  SystemNonPagedPoolInformation = 15,                          // ordinal: 0xf
  SystemHandleInformation = 16,                                // ordinal: 0x10
  SystemObjectInformation = 17,                                // ordinal: 0x11
  SystemPageFileInformation = 18,                              // ordinal: 0x12
  SystemVdmInstemulInformation = 19,                           // ordinal: 0x13
  SystemVdmBopInformation = 20,                                // ordinal: 0x14
  SystemFileCacheInformation = 21,                             // ordinal: 0x15
  SystemPoolTagInformation = 22,                               // ordinal: 0x16
  SystemInterruptInformation = 23,                             // ordinal: 0x17
  SystemDpcBehaviorInformation = 24,                           // ordinal: 0x18
  SystemFullMemoryInformation = 25,                            // ordinal: 0x19
  SystemLoadGdiDriverInformation = 26,                         // ordinal: 0x1a
  SystemUnloadGdiDriverInformation = 27,                       // ordinal: 0x1b
  SystemTimeAdjustmentInformation = 28,                        // ordinal: 0x1c
  SystemSummaryMemoryInformation = 29,                         // ordinal: 0x1d
  SystemMirrorMemoryInformation = 30,                          // ordinal: 0x1e
  SystemPerformanceTraceInformation = 31,                      // ordinal: 0x1f
  SystemObsolete0 = 32,                                        // ordinal: 0x20
  SystemExceptionInformation = 33,                             // ordinal: 0x21
  SystemCrashDumpStateInformation = 34,                        // ordinal: 0x22
  SystemKernelDebuggerInformation = 35,                        // ordinal: 0x23
  SystemContextSwitchInformation = 36,                         // ordinal: 0x24
  SystemRegistryQuotaInformation = 37,                         // ordinal: 0x25
  SystemExtendServiceTableInformation = 38,                    // ordinal: 0x26
  SystemPrioritySeperation = 39,                               // ordinal: 0x27
  SystemVerifierAddDriverInformation = 40,                     // ordinal: 0x28
  SystemVerifierRemoveDriverInformation = 41,                  // ordinal: 0x29
  SystemProcessorIdleInformation = 42,                         // ordinal: 0x2a
  SystemLegacyDriverInformation = 43,                          // ordinal: 0x2b
  SystemCurrentTimeZoneInformation = 44,                       // ordinal: 0x2c
  SystemLookasideInformation = 45,                             // ordinal: 0x2d
  SystemTimeSlipNotification = 46,                             // ordinal: 0x2e
  SystemSessionCreate = 47,                                    // ordinal: 0x2f
  SystemSessionDetach = 48,                                    // ordinal: 0x30
  SystemSessionInformation = 49,                               // ordinal: 0x31
  SystemRangeStartInformation = 50,                            // ordinal: 0x32
  SystemVerifierInformation = 51,                              // ordinal: 0x33
  SystemVerifierThunkExtend = 52,                              // ordinal: 0x34
  SystemSessionProcessInformation = 53,                        // ordinal: 0x35
  SystemLoadGdiDriverInSystemSpace = 54,                       // ordinal: 0x36
  SystemNumaProcessorMap = 55,                                 // ordinal: 0x37
  SystemPrefetcherInformation = 56,                            // ordinal: 0x38
  SystemExtendedProcessInformation = 57,                       // ordinal: 0x39
  SystemRecommendedSharedDataAlignment = 58,                   // ordinal: 0x3a
  SystemComPlusPackage = 59,                                   // ordinal: 0x3b
  SystemNumaAvailableMemory = 60,                              // ordinal: 0x3c
  SystemProcessorPowerInformation = 61,                        // ordinal: 0x3d
  SystemEmulationBasicInformation = 62,                        // ordinal: 0x3e
  SystemEmulationProcessorInformation = 63,                    // ordinal: 0x3f
  SystemExtendedHandleInformation = 64,                        // ordinal: 0x40
  SystemLostDelayedWriteInformation = 65,                      // ordinal: 0x41
  SystemBigPoolInformation = 66,                               // ordinal: 0x42
  SystemSessionPoolTagInformation = 67,                        // ordinal: 0x43
  SystemSessionMappedViewInformation = 68,                     // ordinal: 0x44
  SystemHotpatchInformation = 69,                              // ordinal: 0x45
  SystemObjectSecurityMode = 70,                               // ordinal: 0x46
  SystemWatchdogTimerHandler = 71,                             // ordinal: 0x47
  SystemWatchdogTimerInformation = 72,                         // ordinal: 0x48
  SystemLogicalProcessorInformation = 73,                      // ordinal: 0x49
  SystemWow64SharedInformationObsolete = 74,                   // ordinal: 0x4a
  SystemRegisterFirmwareTableInformationHandler = 75,          // ordinal: 0x4b
  SystemFirmwareTableInformation = 76,                         // ordinal: 0x4c
  SystemModuleInformationEx = 77,                              // ordinal: 0x4d
  SystemVerifierTriageInformation = 78,                        // ordinal: 0x4e
  SystemSuperfetchInformation = 79,                            // ordinal: 0x4f
  SystemMemoryListInformation = 80,                            // ordinal: 0x50
  SystemFileCacheInformationEx = 81,                           // ordinal: 0x51
  SystemThreadPriorityClientIdInformation = 82,                // ordinal: 0x52
  SystemProcessorIdleCycleTimeInformation = 83,                // ordinal: 0x53
  SystemVerifierCancellationInformation = 84,                  // ordinal: 0x54
  SystemProcessorPowerInformationEx = 85,                      // ordinal: 0x55
  SystemRefTraceInformation = 86,                              // ordinal: 0x56
  SystemSpecialPoolInformation = 87,                           // ordinal: 0x57
  SystemProcessIdInformation = 88,                             // ordinal: 0x58
  SystemErrorPortInformation = 89,                             // ordinal: 0x59
  SystemBootEnvironmentInformation = 90,                       // ordinal: 0x5a
  SystemHypervisorInformation = 91,                            // ordinal: 0x5b
  SystemVerifierInformationEx = 92,                            // ordinal: 0x5c
  SystemTimeZoneInformation = 93,                              // ordinal: 0x5d
  SystemImageFileExecutionOptionsInformation = 94,             // ordinal: 0x5e
  SystemCoverageInformation = 95,                              // ordinal: 0x5f
  SystemPrefetchPatchInformation = 96,                         // ordinal: 0x60
  SystemVerifierFaultsInformation = 97,                        // ordinal: 0x61
  SystemSystemPartitionInformation = 98,                       // ordinal: 0x62
  SystemSystemDiskInformation = 99,                            // ordinal: 0x63
  SystemProcessorPerformanceDistribution = 100,                // ordinal: 0x64
  SystemNumaProximityNodeInformation = 101,                    // ordinal: 0x65
  SystemDynamicTimeZoneInformation = 102,                      // ordinal: 0x66
  SystemCodeIntegrityInformation = 103,                        // ordinal: 0x67
  SystemProcessorMicrocodeUpdateInformation = 104,             // ordinal: 0x68
  SystemProcessorBrandString = 105,                            // ordinal: 0x69
  SystemVirtualAddressInformation = 106,                       // ordinal: 0x6a
  SystemLogicalProcessorAndGroupInformation = 107,             // ordinal: 0x6b
  SystemProcessorCycleTimeInformation = 108,                   // ordinal: 0x6c
  SystemStoreInformation = 109,                                // ordinal: 0x6d
  SystemRegistryAppendString = 110,                            // ordinal: 0x6e
  SystemAitSamplingValue = 111,                                // ordinal: 0x6f
  SystemVhdBootInformation = 112,                              // ordinal: 0x70
  SystemCpuQuotaInformation = 113,                             // ordinal: 0x71
  SystemNativeBasicInformation = 114,                          // ordinal: 0x72
  SystemErrorPortTimeouts = 115,                               // ordinal: 0x73
  SystemLowPriorityIoInformation = 116,                        // ordinal: 0x74
  SystemBootEntropyInformation = 117,                          // ordinal: 0x75
  SystemVerifierCountersInformation = 118,                     // ordinal: 0x76
  SystemPagedPoolInformationEx = 119,                          // ordinal: 0x77
  SystemSystemPtesInformationEx = 120,                         // ordinal: 0x78
  SystemNodeDistanceInformation = 121,                         // ordinal: 0x79
  SystemAcpiAuditInformation = 122,                            // ordinal: 0x7a
  SystemBasicPerformanceInformation = 123,                     // ordinal: 0x7b
  SystemQueryPerformanceCounterInformation = 124,              // ordinal: 0x7c
  SystemSessionBigPoolInformation = 125,                       // ordinal: 0x7d
  SystemBootGraphicsInformation = 126,                         // ordinal: 0x7e
  SystemScrubPhysicalMemoryInformation = 127,                  // ordinal: 0x7f
  SystemBadPageInformation = 128,                              // ordinal: 0x80
  SystemProcessorProfileControlArea = 129,                     // ordinal: 0x81
  SystemCombinePhysicalMemoryInformation = 130,                // ordinal: 0x82
  SystemEntropyInterruptTimingInformation = 131,               // ordinal: 0x83
  SystemConsoleInformation = 132,                              // ordinal: 0x84
  SystemPlatformBinaryInformation = 133,                       // ordinal: 0x85
  SystemPolicyInformation = 134,                               // ordinal: 0x86
  SystemHypervisorProcessorCountInformation = 135,             // ordinal: 0x87
  SystemDeviceDataInformation = 136,                           // ordinal: 0x88
  SystemDeviceDataEnumerationInformation = 137,                // ordinal: 0x89
  SystemMemoryTopologyInformation = 138,                       // ordinal: 0x8a
  SystemMemoryChannelInformation = 139,                        // ordinal: 0x8b
  SystemBootLogoInformation = 140,                             // ordinal: 0x8c
  SystemProcessorPerformanceInformationEx = 141,               // ordinal: 0x8d
  SystemCriticalProcessErrorLogInformation = 142,              // ordinal: 0x8e
  SystemSecureBootPolicyInformation = 143,                     // ordinal: 0x8f
  SystemPageFileInformationEx = 144,                           // ordinal: 0x90
  SystemSecureBootInformation = 145,                           // ordinal: 0x91
  SystemEntropyInterruptTimingRawInformation = 146,            // ordinal: 0x92
  SystemPortableWorkspaceEfiLauncherInformation = 147,         // ordinal: 0x93
  SystemFullProcessInformation = 148,                          // ordinal: 0x94
  SystemKernelDebuggerInformationEx = 149,                     // ordinal: 0x95
  SystemBootMetadataInformation = 150,                         // ordinal: 0x96
  SystemSoftRebootInformation = 151,                           // ordinal: 0x97
  SystemElamCertificateInformation = 152,                      // ordinal: 0x98
  SystemOfflineDumpConfigInformation = 153,                    // ordinal: 0x99
  SystemProcessorFeaturesInformation = 154,                    // ordinal: 0x9a
  SystemRegistryReconciliationInformation = 155,               // ordinal: 0x9b
  SystemEdidInformation = 156,                                 // ordinal: 0x9c
  SystemManufacturingInformation = 157,                        // ordinal: 0x9d
  SystemEnergyEstimationConfigInformation = 158,               // ordinal: 0x9e
  SystemHypervisorDetailInformation = 159,                     // ordinal: 0x9f
  SystemProcessorCycleStatsInformation = 160,                  // ordinal: 0xa0
  SystemVmGenerationCountInformation = 161,                    // ordinal: 0xa1
  SystemTrustedPlatformModuleInformation = 162,                // ordinal: 0xa2
  SystemKernelDebuggerFlags = 163,                             // ordinal: 0xa3
  SystemCodeIntegrityPolicyInformation = 164,                  // ordinal: 0xa4
  SystemIsolatedUserModeInformation = 165,                     // ordinal: 0xa5
  SystemHardwareSecurityTestInterfaceResultsInformation = 166, // ordinal: 0xa6
  SystemSingleModuleInformation = 167,                         // ordinal: 0xa7
  SystemAllowedCpuSetsInformation = 168,                       // ordinal: 0xa8
  SystemVsmProtectionInformation = 169,                        // ordinal: 0xa9
  SystemInterruptCpuSetsInformation = 170,                     // ordinal: 0xaa
  SystemSecureBootPolicyFullInformation = 171,                 // ordinal: 0xab
  SystemCodeIntegrityPolicyFullInformation = 172,              // ordinal: 0xac
  SystemAffinitizedInterruptProcessorInformation = 173,        // ordinal: 0xad
  SystemRootSiloInformation = 174,                             // ordinal: 0xae
  SystemCpuSetInformation = 175,                               // ordinal: 0xaf
  SystemCpuSetTagInformation = 176,                            // ordinal: 0xb0
  SystemWin32WerStartCallout = 177,                            // ordinal: 0xb1
  SystemSecureKernelProfileInformation = 178,                  // ordinal: 0xb2
  SystemCodeIntegrityPlatformManifestInformation = 179,        // ordinal: 0xb3
  SystemInterruptSteeringInformation = 180,                    // ordinal: 0xb4
  SystemSupportedProcessorArchitectures = 181,                 // ordinal: 0xb5
  SystemMemoryUsageInformation = 182,                          // ordinal: 0xb6
  SystemCodeIntegrityCertificateInformation = 183,             // ordinal: 0xb7
  SystemPhysicalMemoryInformation = 184,                       // ordinal: 0xb8
  SystemControlFlowTransition = 185,                           // ordinal: 0xb9
  SystemKernelDebuggingAllowed = 186,                          // ordinal: 0xba
  SystemActivityModerationExeState = 187,                      // ordinal: 0xbb
  SystemActivityModerationUserSettings = 188,                  // ordinal: 0xbc
  SystemCodeIntegrityPoliciesFullInformation = 189,            // ordinal: 0xbd
  SystemCodeIntegrityUnlockInformation = 190,                  // ordinal: 0xbe
  SystemIntegrityQuotaInformation = 191,                       // ordinal: 0xbf
  SystemFlushInformation = 192,                                // ordinal: 0xc0
  SystemProcessorIdleMaskInformation = 193,                    // ordinal: 0xc1
  SystemSecureDumpEncryptionInformation = 194,                 // ordinal: 0xc2
  SystemWriteConstraintInformation = 195,                      // ordinal: 0xc3
  SystemKernelVaShadowInformation = 196,                       // ordinal: 0xc4
  SystemHypervisorSharedPageInformation = 197,                 // ordinal: 0xc5
  SystemFirmwareBootPerformanceInformation = 198,              // ordinal: 0xc6
  SystemCodeIntegrityVerificationInformation = 199,            // ordinal: 0xc7
  SystemFirmwarePartitionInformation = 200,                    // ordinal: 0xc8
  SystemSpeculationControlInformation = 201,                   // ordinal: 0xc9
  SystemDmaGuardPolicyInformation = 202,                       // ordinal: 0xca
  SystemEnclaveLaunchControlInformation = 203,                 // ordinal: 0xcb
  SystemWorkloadAllowedCpuSetsInformation = 204,               // ordinal: 0xcc
  SystemCodeIntegrityUnlockModeInformation = 205,              // ordinal: 0xcd
  SystemLeapSecondInformation = 206,                           // ordinal: 0xce
  SystemFlags2Information = 207,                               // ordinal: 0xcf
  SystemSecurityModelInformation = 208,                        // ordinal: 0xd0
  SystemCodeIntegritySyntheticCacheInformation = 209,          // ordinal: 0xd1
  SystemFeatureConfigurationInformation = 210,                 // ordinal: 0xd2
  SystemFeatureConfigurationSectionInformation = 211,          // ordinal: 0xd3
  SystemFeatureUsageSubscriptionInformation = 212,             // ordinal: 0xd4
  SystemSecureSpeculationControlInformation = 213,             // ordinal: 0xd5
  SystemSpacesBootInformation = 214,                           // ordinal: 0xd6
  SystemFwRamdiskInformation = 215,                            // ordinal: 0xd7
  SystemWheaIpmiHardwareInformation = 216,                     // ordinal: 0xd8
  SystemDifSetRuleClassInformation = 217,                      // ordinal: 0xd9
  SystemDifClearRuleClassInformation = 218,                    // ordinal: 0xda
  SystemDifApplyPluginVerificationOnDriver = 219,              // ordinal: 0xdb
  SystemDifRemovePluginVerificationOnDriver = 220,             // ordinal: 0xdc
  SystemShadowStackInformation = 221,                          // ordinal: 0xdd
  SystemBuildVersionInformation = 222,                         // ordinal: 0xde
  SystemPoolLimitInformation = 223,                            // ordinal: 0xdf
  SystemCodeIntegrityAddDynamicStore = 224,                    // ordinal: 0xe0
  SystemCodeIntegrityClearDynamicStores = 225,                 // ordinal: 0xe1
  SystemDifPoolTrackingInformation = 226,                      // ordinal: 0xe2
  SystemPoolZeroingInformation = 227,                          // ordinal: 0xe3
  SystemDpcWatchdogInformation = 228,                          // ordinal: 0xe4
  SystemDpcWatchdogInformation2 = 229,                         // ordinal: 0xe5
  SystemSupportedProcessorArchitectures2 = 230,                // ordinal: 0xe6
  SystemSingleProcessorRelationshipInformation = 231,          // ordinal: 0xe7
  SystemXfgCheckFailureInformation = 232,                      // ordinal: 0xe8
  SystemIommuStateInformation = 233,                           // ordinal: 0xe9
  SystemHypervisorMinrootInformation = 234,                    // ordinal: 0xea
  SystemHypervisorBootPagesInformation = 235,                  // ordinal: 0xeb
  SystemPointerAuthInformation = 236,                          // ordinal: 0xec
  SystemSecureKernelDebuggerInformation = 237,                 // ordinal: 0xed
  SystemOriginalImageFeatureInformation = 238,                 // ordinal: 0xee
  MaxSystemInfoClass = 239,                                    // ordinal: 0xef
} _SYSTEM_INFORMATION_CLASS;

typedef enum _ConnectionResourceConsumerDesc {
  ConnectionResourceConsumerDescIsUndefined = 0, // ordinal: 0x0
  ConnectionResourceConsumerDescIsDevice = 1,    // ordinal: 0x1
  ConnectionResourceConsumerDescIsOpregion = 2,  // ordinal: 0x2
  ConnectionResourceConsumerDescMax = 3,         // ordinal: 0x3
} _ConnectionResourceConsumerDesc;

typedef enum _MI_VAD_ALLOCATION_CELL_TYPE {
  MiVadBottomUp = 0,              // ordinal: 0x0
  MiVadStackPebTeb = 1,           // ordinal: 0x1
  MiVadReserved64 = 2,            // ordinal: 0x2
  MiVadAllocationCellMaximum = 3, // ordinal: 0x3
} _MI_VAD_ALLOCATION_CELL_TYPE;

typedef enum _PPM_PERF_QOS_DISABLE_REASON {
  PpmPerfQosDisableInternal = 0,           // ordinal: 0x0
  PpmPerfQosDisableNoProfile = 1,          // ordinal: 0x1
  PpmPerfQosDisableNoPolicy = 2,           // ordinal: 0x2
  PpmPerfQosDisableInsufficientPolicy = 3, // ordinal: 0x3
  PpmPerfQosDisableMaxOverride = 4,        // ordinal: 0x4
  PpmPerfQosDisableLowLatency = 5,         // ordinal: 0x5
  PpmPerfQosDisableSmtScheduler = 6,       // ordinal: 0x6
  PpmPerfQosDisableNoHardwareSupport = 7,  // ordinal: 0x7
  PpmPerfQosDisableGroupPolicy = 8,        // ordinal: 0x8
  PpmPerfQosDisableMax = 9,                // ordinal: 0x9
} _PPM_PERF_QOS_DISABLE_REASON;

typedef enum _PS_ATTRIBUTE_NUM {
  PsAttributeParentProcess = 0,                 // ordinal: 0x0
  PsAttributeDebugObject = 1,                   // ordinal: 0x1
  PsAttributeToken = 2,                         // ordinal: 0x2
  PsAttributeClientId = 3,                      // ordinal: 0x3
  PsAttributeTebAddress = 4,                    // ordinal: 0x4
  PsAttributeImageName = 5,                     // ordinal: 0x5
  PsAttributeImageInfo = 6,                     // ordinal: 0x6
  PsAttributeMemoryReserve = 7,                 // ordinal: 0x7
  PsAttributePriorityClass = 8,                 // ordinal: 0x8
  PsAttributeErrorMode = 9,                     // ordinal: 0x9
  PsAttributeStdHandleInfo = 10,                // ordinal: 0xa
  PsAttributeHandleList = 11,                   // ordinal: 0xb
  PsAttributeGroupAffinity = 12,                // ordinal: 0xc
  PsAttributePreferredNode = 13,                // ordinal: 0xd
  PsAttributeIdealProcessor = 14,               // ordinal: 0xe
  PsAttributeUmsThread = 15,                    // ordinal: 0xf
  PsAttributeMitigationOptions = 16,            // ordinal: 0x10
  PsAttributeProtectionLevel = 17,              // ordinal: 0x11
  PsAttributeSecureProcess = 18,                // ordinal: 0x12
  PsAttributeJobList = 19,                      // ordinal: 0x13
  PsAttributeChildProcessPolicy = 20,           // ordinal: 0x14
  PsAttributeAllApplicationPackagesPolicy = 21, // ordinal: 0x15
  PsAttributeWin32kFilter = 22,                 // ordinal: 0x16
  PsAttributeSafeOpenPromptOriginClaim = 23,    // ordinal: 0x17
  PsAttributeBnoIsolation = 24,                 // ordinal: 0x18
  PsAttributeDesktopAppPolicy = 25,             // ordinal: 0x19
  PsAttributeChpe = 26,                         // ordinal: 0x1a
  PsAttributeMitigationAuditOptions = 27,       // ordinal: 0x1b
  PsAttributeMachineType = 28,                  // ordinal: 0x1c
  PsAttributeComponentFilter = 29,              // ordinal: 0x1d
  PsAttributeEnableOptionalXStateFeatures = 30, // ordinal: 0x1e
  PsAttributeMax = 31,                          // ordinal: 0x1f
} _PS_ATTRIBUTE_NUM;

typedef enum _SYSTEM_FEATURE_CONFIGURATION_SECTION_TYPE {
  SystemFeatureConfigurationSectionTypeBoot = 0,          // ordinal: 0x0
  SystemFeatureConfigurationSectionTypeRuntime = 1,       // ordinal: 0x1
  SystemFeatureConfigurationSectionTypeUsageTriggers = 2, // ordinal: 0x2
  SystemFeatureConfigurationSectionTypeCount = 3,         // ordinal: 0x3
} _SYSTEM_FEATURE_CONFIGURATION_SECTION_TYPE;

typedef enum _PO_S0_DISCONNECTED_REASON {
  PoS0DisconnectedReasonNone = 0,            // ordinal: 0x0
  PoS0DisconnectedReasonNonCompliantNic = 1, // ordinal: 0x1
  PoS0DisconnectedReasonSettingPolicy = 2,   // ordinal: 0x2
  PoS0DisconnectedReasonEnforceDsPolicy = 3, // ordinal: 0x3
  PoS0DisconnectedReasonCsChecksFailed = 4,  // ordinal: 0x4
  PoS0DisconnectedReasonOpportunisticDs = 5, // ordinal: 0x5
  PoS0DisconnectedReasonAdaptiveCs = 5,      // ordinal: 0x6
  PoS0DisconnectedReasonMaximum = 6,         // ordinal: 0x7
} _PO_S0_DISCONNECTED_REASON;

typedef enum _MI_RVA_LIST_FILTER_TYPE {
  MiRvaListFilterCfgValid = 0, // ordinal: 0x0
  MiRvaListFilterCfgFirst = 0, // ordinal: 0x1
  MiRvaListFilterCfgLast = 1,  // ordinal: 0x2
  MiRvaListFilterInvalid = 2,  // ordinal: 0x3
} _MI_RVA_LIST_FILTER_TYPE;

typedef enum _HV_EXT_EPF_MODE {
  HvExtEpfModeMin = 0, // ordinal: 0x0
  HvExtEpfModeNt = 0,  // ordinal: 0x1
  HvExtEpfModeMax = 1, // ordinal: 0x2
} _HV_EXT_EPF_MODE;

typedef enum _KTOPOLOGY_LEVEL {
  KTopologyLevelProcessor = 0, // ordinal: 0x0
  KTopologyLevelCore = 1,      // ordinal: 0x1
  KTopologyLevelModule = 2,    // ordinal: 0x2
  KTopologyLevelDie = 3,       // ordinal: 0x3
  KTopologyLevelPackage = 4,   // ordinal: 0x4
  KTopologyLevelCount = 5,     // ordinal: 0x5
} _KTOPOLOGY_LEVEL;

typedef enum _MI_CROSS_PARTITION_CHARGE_TYPE {
  MiCrossPartitionSectionResAvailCharge = 0,   // ordinal: 0x0
  MiCrossPartitionSectionCommitCharge = 1,     // ordinal: 0x1
  MiCrossPartitionLargePageResAvailCharge = 2, // ordinal: 0x2
  MiCrossPartitionLargePageCommitCharge = 3,   // ordinal: 0x3
  MiCrossPartitionSmallAweResAvailCharge = 4,  // ordinal: 0x4
  MiCrossPartitionSmallAweCommitCharge = 5,    // ordinal: 0x5
  MiCrossPartitionPageCloneResAvailCharge = 6, // ordinal: 0x6
  MiCrossPartitionAggregateResAvailCharge = 7, // ordinal: 0x7
  MiCrossPartitionAggregateCommitCharge = 8,   // ordinal: 0x8
  MiCrossPartitionMaximumCharge = 9,           // ordinal: 0x9
} _MI_CROSS_PARTITION_CHARGE_TYPE;

typedef enum _CM_HIVE_CACHE_OPLOCK_EVENT_TYPE {
  OplockEventOnPrimary = 0,           // ordinal: 0x0
  OplockEventOnLog1 = 1,              // ordinal: 0x1
  OplockEventOnLog2 = 2,              // ordinal: 0x2
  OplockBreakThreadKillEvent = 3,     // ordinal: 0x3
  OplockBreakThreadEndEvent = 4,      // ordinal: 0x4
  OplockBreakThreadSyncEvent = 5,     // ordinal: 0x5
  OplockBreakThreadWaitEventsMax = 4, // ordinal: 0x6
  OplockRelatedEventsMax = 6,         // ordinal: 0x7
} _CM_HIVE_CACHE_OPLOCK_EVENT_TYPE;

typedef enum _THREAD_WORKLOAD_CLASS {
  ThreadWorkloadClassDefault = 0,  // ordinal: 0x0
  ThreadWorkloadClassGraphics = 1, // ordinal: 0x1
  MaxThreadWorkloadClass = 2,      // ordinal: 0x2
} _THREAD_WORKLOAD_CLASS;

typedef enum _SYSTEM_POOL_LIMIT_MEM_TYPE {
  SysPlMemPaged = 0,    // ordinal: 0x0
  SysPlMemNonPaged = 1, // ordinal: 0x1
  SysPlMemTypeMax = 2,  // ordinal: 0x2
} _SYSTEM_POOL_LIMIT_MEM_TYPE;

typedef enum PDCCLIENTID {
  PDC_INVALID_CLIENT = 0,                             // ordinal: 0x0
  PDC_PLM_CLIENT = 1,                                 // ordinal: 0x1
  PDC_NQM_CLIENT = 2,                                 // ordinal: 0x2
  PDC_WNS_CLIENT = 3,                                 // ordinal: 0x3
  PDC_DAM_CLIENT = 4,                                 // ordinal: 0x4
  PDC_WCM_CLIENT = 5,                                 // ordinal: 0x5
  PDC_NCSI_CLIENT = 7,                                // ordinal: 0x6
  PDC_DHCP_CLIENT = 8,                                // ordinal: 0x7
  PDC_TCPIP_CLIENT = 9,                               // ordinal: 0x8
  PDC_WU_CLIENT = 11,                                 // ordinal: 0x9
  PDC_GP_CLIENT = 12,                                 // ordinal: 0xa
  PDC_NCA_CLIENT = 14,                                // ordinal: 0xb
  PDC_BI_CLIENT = 15,                                 // ordinal: 0xc
  PDC_MSCHED_CLIENT = 16,                             // ordinal: 0xd
  PDC_SUSPENDRESUME_CLIENT = 17,                      // ordinal: 0xe
  PDC_INTERNAL_CLIENT = 18,                           // ordinal: 0xf
  PDC_DEFAULT_KM_TEST_CLIENT_EXEMPTED = 19,           // ordinal: 0x10
  PDC_DEFAULT_UM_TEST_CLIENT_EXEMPTED = 20,           // ordinal: 0x11
  PDC_DAM_PHASE_TEST_CLIENT = 21,                     // ordinal: 0x12
  PDC_LOW_POWER_PHASE_TEST_CLIENT = 22,               // ordinal: 0x13
  PDC_RESILIENCY_NOTIFICATION_PHASE_TEST_CLIENT = 23, // ordinal: 0x14
  PDC_NQM_RESILIENCY_TEST_CLIENT = 24,                // ordinal: 0x15
  PDC_DAM_RESILIENCY_TEST_CLIENT = 25,                // ordinal: 0x16
  PDC_DAM_KM_TEST_CLIENT = 26,                        // ordinal: 0x17
  PDC_DAM_UM_TEST_CLIENT = 27,                        // ordinal: 0x18
  PDC_SINGLETON_TEST_CLIENT = 28,                     // ordinal: 0x19
  PDC_NETWORK_SERVICE_TEST_CLIENT = 29,               // ordinal: 0x1a
  PDC_NETWORK_SERVICE2_TEST_CLIENT = 30,              // ordinal: 0x1b
  PDC_SYSTEM_SERVICE_TEST_CLIENT = 31,                // ordinal: 0x1c
  PDC_ACTIV_NOTIF_DAM_RESIL_TEST_CLIENT = 32,         // ordinal: 0x1d
  PDC_ACTIV_NOTIF_NET_RESIL_TEST_CLIENT = 33,         // ordinal: 0x1e
  PDC_SHELL_CLIENT = 34,                              // ordinal: 0x1f
  PDC_MAINTENANCE_CLIENT = 35,                        // ordinal: 0x20
  PDC_SYNC_CLIENT = 36,                               // ordinal: 0x21
  PDC_IDM_CLIENT = 37,                                // ordinal: 0x22
  PDC_CORTANA_VOICE_ACTIVATION_CLIENT = 38,           // ordinal: 0x23
  PDC_TETHERING_CLIENT = 39,                          // ordinal: 0x24
  PDC_AUDIO_CLIENT = 40,                              // ordinal: 0x25
  PDC_LOCK_SCREEN = 41,                               // ordinal: 0x26
  PDC_LREC_CLIENT = 42,                               // ordinal: 0x27
  PDC_WP_BW_CLIENT = 43,                              // ordinal: 0x28
  PDC_WP_MEDIA_STREAMING_CLIENT = 44,                 // ordinal: 0x29
  PDC_WP_MAPS_CLIENT = 46,                            // ordinal: 0x2a
  PDC_WP_SYNC_CLIENT = 47,                            // ordinal: 0x2b
  PDC_SETTING_SYNC_CLIENT = 48,                       // ordinal: 0x2c
  PDC_WP_EDM_CLIENT = 49,                             // ordinal: 0x2d
  PDC_WP_WALLET_CLIENT = 50,                          // ordinal: 0x2e
  PDC_WP_LOCATION_CLIENT = 51,                        // ordinal: 0x2f
  PDC_WP_CM_CLIENT = 53,                              // ordinal: 0x30
  PDC_WP_DCP_CLIENT = 54,                             // ordinal: 0x31
  PDC_WP_WIFIAUTO_CLIENT = 55,                        // ordinal: 0x32
  PDC_BITLOCKER_CLIENT = 56,                          // ordinal: 0x33
  PDC_MDM_CERTINSTALLER_CLIENT = 57,                  // ordinal: 0x34
  PDC_WP_IM_CLIENT = 58,                              // ordinal: 0x35
  PDC_WP_MMS_CLIENT = 59,                             // ordinal: 0x36
  PDC_DEVICEENROLLER_CLIENT = 60,                     // ordinal: 0x37
  PDC_WP_WIFI_SCANNING_CLIENT = 61,                   // ordinal: 0x38
  PDC_WP_OMADM_CLIENT = 62,                           // ordinal: 0x39
  PDC_WP_TELEMETRY_CHECK_CLIENT = 63,                 // ordinal: 0x3a
  PDC_WP_DIS_CLIENT = 64,                             // ordinal: 0x3b
  PDC_BITS_CLIENT = 65,                               // ordinal: 0x3c
  PDC_WP_VOIP_EXECUTION_CLIENT = 66,                  // ordinal: 0x3d
  PDC_WP_RESERVED_CLIENT3 = 67,                       // ordinal: 0x3e
  PDC_SLEEP_STUDY_CLIENT = 68,                        // ordinal: 0x3f
  PDC_WP_AUTOTIMEUPDATE_CLIENT = 69,                  // ordinal: 0x40
  PDC_HYPERV_CLIENT = 70,                             // ordinal: 0x41
  PDC_KM_SIGNAL_CLIENT = 71,                          // ordinal: 0x42
  PDC_UM_SIGNAL_CLIENT = 72,                          // ordinal: 0x43
  PDC_DEVICE_HEALTH_ATTESTATION_CLIENT = 73,          // ordinal: 0x44
  PDC_XB_SYSTEM_CLIENT = 74,                          // ordinal: 0x45
  PDC_XB_HOST_CLIENT = 75,                            // ordinal: 0x46
  PDC_PRINT_JOB_MANAGER_CLIENT = 76,                  // ordinal: 0x47
  PDC_TELEMETRY_CLIENT = 77,                          // ordinal: 0x48
  PDC_ERROR_REPORTING_CLIENT = 78,                    // ordinal: 0x49
  PDC_XBOX_NTM = 79,                                  // ordinal: 0x4a
  PDC_CBE_CLIENT = 80,                                // ordinal: 0x4b
  PDC_FIND_MY_PHONE_CLIENT = 81,                      // ordinal: 0x4c
  PDC_COMMAND_CHANNEL_CLIENT = 82,                    // ordinal: 0x4d
  PDC_PPM_PROFILES_CLIENT = 83,                       // ordinal: 0x4e
  PDC_WIFI_CALLING_CLIENT = 84,                       // ordinal: 0x4f
  PDC_WU_REBOOT_CLIENT = 85,                          // ordinal: 0x50
  PDC_SYSMAIN_CLIENT = 86,                            // ordinal: 0x51
  PDC_XBOX_UPDATE_CLIENT = 87,                        // ordinal: 0x52
  PDC_CHAT_SERVICE_CLIENT = 88,                       // ordinal: 0x53
  PDC_FIND_MY_DEVICE_CLIENT = 89,                     // ordinal: 0x54
  PDC_NOTIFICATION_FORWARDING_AND_ACTION_CLIENT = 90, // ordinal: 0x55
  PDC_INSTALL_AGENT_CLIENT = 91,                      // ordinal: 0x56
  PDC_XBOX_WAKE_ON_VOICE = 92,                        // ordinal: 0x57
  PDC_PLM_AUDIO_CLIENT = 93,                          // ordinal: 0x58
  PDC_WP_BCKAUDIO_CLIENT = 94,                        // ordinal: 0x59
  PDC_WAKE_ON_LAN_CLIENT = 95,                        // ordinal: 0x5a
  PDC_WP_CLOUD_MESSAGING_CLIENT = 96,                 // ordinal: 0x5b
  PDC_DATA_MIGRATION_MANAGER = 97,                    // ordinal: 0x5c
  PDC_EVENT_SOUND_MANAGER_CLIENT = 98,                // ordinal: 0x5d
  PDC_WWAN_DORMANCY_HINT_CLIENT = 99,                 // ordinal: 0x5e
  PDC_HAM_CLIENT = 100,                               // ordinal: 0x5f
  PDC_FILESHARINGSERVER_CLIENT = 101,                 // ordinal: 0x60
  PDC_DIRECTED_DRIPS_TASK_CLIENT = 102,               // ordinal: 0x61
  PDC_DIRECTED_DRIPS_LPE_CLIENT = 103,                // ordinal: 0x62
  PDC_DIRECTED_DRIPS_PLM_CLIENT = 104,                // ordinal: 0x63
  PDC_HTTPSDATASOURCE_CLIENT = 105,                   // ordinal: 0x64
  PDC_TERMINALSERVER_CONNECTION_CLIENT = 106,         // ordinal: 0x65
  PDC_TERMINALSERVER_SESSION_CLIENT = 107,            // ordinal: 0x66
  PDC_ANYNETWORK_RESILIENCY_CLIENT = 108,             // ordinal: 0x67
  PDC_XBOX_NUI_CLIENT = 110,                          // ordinal: 0x68
  PDC_WIFI_CALLING_IMS_CLIENT = 111,                  // ordinal: 0x69
  PDC_SLEEPSTUDY_HELPER_USER_CLIENT = 112,            // ordinal: 0x6a
  PDC_SLEEPSTUDY_HELPER_KERNEL_CLIENT = 113,          // ordinal: 0x6b
  PDC_CONTAINER_MANAGER_CLIENT = 114,                 // ordinal: 0x6c
  PDC_UPDATE_ORCHESTRATOR_CLIENT = 115,               // ordinal: 0x6d
  PDC_UPDATE_UX_CLIENT = 116,                         // ordinal: 0x6e
  PDC_HOT_KEY_MANAGER_CLIENT = 117,                   // ordinal: 0x6f
  PDC_SERVICING_PLATFORM = 118,                       // ordinal: 0x70
  PDC_TNC_CLIENT = 119,                               // ordinal: 0x71
  PDC_USER_SHUTDOWN_CLIENT = 120,                     // ordinal: 0x72
  PDC_KERNEL_PLUG_AND_PLAY = 121,                     // ordinal: 0x73
  PDC_NUMBER_OF_CLIENTS = 122,                        // ordinal: 0x74
} PDCCLIENTID;

typedef enum _MI_WRITE_TYPES {
  WriteTypeCached = 0,      // ordinal: 0x0
  WriteTypeNonTemporal = 1, // ordinal: 0x1
  WriteTypeMaximum = 2,     // ordinal: 0x2
} _MI_WRITE_TYPES;

typedef enum _PERFINFO_MM_STAT {
  PerfInfoMMStatNotUsed = 0,              // ordinal: 0x0
  PerfInfoMMStatAggregatePageCombine = 1, // ordinal: 0x1
  PerfInfoMMStatIterationPageCombine = 2, // ordinal: 0x2
  PerfInfoMMStatMax = 3,                  // ordinal: 0x3
} _PERFINFO_MM_STAT;

typedef enum _KERNEL_SHADOW_STACK_TYPE {
  KernelShadowStackTypeUserThread = 0,               // ordinal: 0x0
  KernelShadowStackTypeKernelThread = 1,             // ordinal: 0x1
  KernelShadowStackTypeRstorssp = 2,                 // ordinal: 0x2
  KernelShadowStackTypeSetssbsy = 3,                 // ordinal: 0x3
  KernelShadowStackTypeSetssbsyForSystemStartup = 4, // ordinal: 0x4
  KernelShadowStackTypeMax = 5,                      // ordinal: 0x5
} _KERNEL_SHADOW_STACK_TYPE;

typedef enum _KISOLATION_WIDTH {
  KiIsolationWidthLogicalProcessor = 0, // ordinal: 0x0
  KiIsolationWidthCore = 1,             // ordinal: 0x1
  KiIsolationWidthMax = 2,              // ordinal: 0x2
} _KISOLATION_WIDTH;

typedef enum _MI_PARTITION_THREAD {
  MiZeroPageThreadSlot = 0,             // ordinal: 0x0
  MiRebuildLargePagesThreadSlot = 1,    // ordinal: 0x1
  MiPartitionWorkingSetManagerSlot = 2, // ordinal: 0x2
  MiDereferenceSegmentThreadSlot = 3,   // ordinal: 0x3
  MiModifiedPageWriterSlot = 4,         // ordinal: 0x4
  MiMappedPageWriterSlot = 5,           // ordinal: 0x5
  MiNumberOfPartitionThreads = 6,       // ordinal: 0x6
} _MI_PARTITION_THREAD;

typedef enum _TRACE_INFORMATION_CLASS {
  TraceIdClass = 0,                    // ordinal: 0x0
  TraceHandleClass = 1,                // ordinal: 0x1
  TraceEnableFlagsClass = 2,           // ordinal: 0x2
  TraceEnableLevelClass = 3,           // ordinal: 0x3
  GlobalLoggerHandleClass = 4,         // ordinal: 0x4
  EventLoggerHandleClass = 5,          // ordinal: 0x5
  AllLoggerHandlesClass = 6,           // ordinal: 0x6
  TraceHandleByNameClass = 7,          // ordinal: 0x7
  LoggerEventsLostClass = 8,           // ordinal: 0x8
  TraceSessionSettingsClass = 9,       // ordinal: 0x9
  LoggerEventsLoggedClass = 10,        // ordinal: 0xa
  DiskIoNotifyRoutinesClass = 11,      // ordinal: 0xb
  TraceInformationClassReserved1 = 12, // ordinal: 0xc
  AllPossibleNotifyRoutinesClass = 12, // ordinal: 0xd
  FltIoNotifyRoutinesClass = 13,       // ordinal: 0xe
  TraceInformationClassReserved2 = 14, // ordinal: 0xf
  WdfNotifyRoutinesClass = 15,         // ordinal: 0x10
  MaxTraceInformationClass = 16,       // ordinal: 0x11
} _TRACE_INFORMATION_CLASS;

typedef enum _MI_IO_PFN_TYPE {
  MiIoPfnProbes = 0,      // ordinal: 0x0
  MiIoPfnMaps = 1,        // ordinal: 0x1
  MiMaximumIoPfnType = 2, // ordinal: 0x2
} _MI_IO_PFN_TYPE;

typedef enum TlgOut_t {
  TlgOutNULL = 0,                  // ordinal: 0x0
  TlgOutNOPRINT = 1,               // ordinal: 0x1
  TlgOutSTRING = 2,                // ordinal: 0x2
  TlgOutBOOLEAN = 3,               // ordinal: 0x3
  TlgOutHEX = 4,                   // ordinal: 0x4
  TlgOutPID = 5,                   // ordinal: 0x5
  TlgOutTID = 6,                   // ordinal: 0x6
  TlgOutPORT = 7,                  // ordinal: 0x7
  TlgOutIPV4 = 8,                  // ordinal: 0x8
  TlgOutIPV6 = 9,                  // ordinal: 0x9
  TlgOutSOCKETADDRESS = 10,        // ordinal: 0xa
  TlgOutXML = 11,                  // ordinal: 0xb
  TlgOutJSON = 12,                 // ordinal: 0xc
  TlgOutWIN32ERROR = 13,           // ordinal: 0xd
  TlgOutNTSTATUS = 14,             // ordinal: 0xe
  TlgOutHRESULT = 15,              // ordinal: 0xf
  TlgOutFILETIME = 16,             // ordinal: 0x10
  TlgOutSIGNED = 17,               // ordinal: 0x11
  TlgOutUNSIGNED = 18,             // ordinal: 0x12
  TlgOutUTF8 = 35,                 // ordinal: 0x13
  TlgOutPKCS7_WITH_TYPE_INFO = 36, // ordinal: 0x14
  TlgOutCODE_POINTER = 37,         // ordinal: 0x15
  TlgOutDATETIME_UTC = 38,         // ordinal: 0x16
  _TlgOutMax = 39,                 // ordinal: 0x17
  _TlgOutChain = 128,              // ordinal: 0x18
  _TlgOutTypeMask = 127,           // ordinal: 0x19
} TlgOut_t;

typedef enum _INVPCID_TYPE {
  InvpcidIndividualAddress = 0,    // ordinal: 0x0
  InvpcidSingleContext = 1,        // ordinal: 0x1
  InvpcidAllContextAndGlobals = 2, // ordinal: 0x2
  InvpcidAllContext = 3,           // ordinal: 0x3
} _INVPCID_TYPE;

typedef enum _ADD_DRIVER_STAGE {
  ClassConfigFilters = 0, // ordinal: 0x0
  LowerDeviceFilters = 1, // ordinal: 0x1
  LowerClassFilters = 2,  // ordinal: 0x2
  DeviceService = 3,      // ordinal: 0x3
  UpperDeviceFilters = 4, // ordinal: 0x4
  UpperClassFilters = 5,  // ordinal: 0x5
  MaximumAddStage = 6,    // ordinal: 0x6
} _ADD_DRIVER_STAGE;

typedef enum _KPROCESS_STATE {
  ProcessInMemory = 0,      // ordinal: 0x0
  ProcessOutOfMemory = 1,   // ordinal: 0x1
  ProcessInTransition = 2,  // ordinal: 0x2
  ProcessOutTransition = 3, // ordinal: 0x3
  ProcessInSwap = 4,        // ordinal: 0x4
  ProcessOutSwap = 5,       // ordinal: 0x5
  ProcessRetryOutSwap = 6,  // ordinal: 0x6
  ProcessAllSwapStates = 7, // ordinal: 0x7
} _KPROCESS_STATE;

typedef enum _MI_VAD_64K_TYPES {
  MiVad64KPrivate = 0, // ordinal: 0x0
  MiVad64KShared = 1,  // ordinal: 0x1
  MiVad64KTypes = 2,   // ordinal: 0x2
} _MI_VAD_64K_TYPES;

typedef enum _PO_CS_DEVICE_NOTIFICATION_TYPE {
  PoCsDeviceNotificationStorage = 0,  // ordinal: 0x0
  PoCsDeviceNotificationWiFi = 1,     // ordinal: 0x1
  PoCsDeviceNotificationMbn = 2,      // ordinal: 0x2
  PoCsDeviceNotificationAudio = 3,    // ordinal: 0x3
  PoCsDeviceNotificationEthernet = 4, // ordinal: 0x4
  PoCsDeviceNotificationMaximum = 5,  // ordinal: 0x5
} _PO_CS_DEVICE_NOTIFICATION_TYPE;

typedef enum _POLICY_AUDIT_EVENT_TYPE {
  AuditCategorySystem = 0,                 // ordinal: 0x0
  AuditCategoryLogon = 1,                  // ordinal: 0x1
  AuditCategoryObjectAccess = 2,           // ordinal: 0x2
  AuditCategoryPrivilegeUse = 3,           // ordinal: 0x3
  AuditCategoryDetailedTracking = 4,       // ordinal: 0x4
  AuditCategoryPolicyChange = 5,           // ordinal: 0x5
  AuditCategoryAccountManagement = 6,      // ordinal: 0x6
  AuditCategoryDirectoryServiceAccess = 7, // ordinal: 0x7
  AuditCategoryAccountLogon = 8,           // ordinal: 0x8
} _POLICY_AUDIT_EVENT_TYPE;

typedef enum _MI_ASSIGNED_REGION_TYPES {
  AssignedRegionPfnDatabase = 0,         // ordinal: 0x0
  AssignedRegionNonPagedPool = 1,        // ordinal: 0x1
  AssignedRegionPagedPool = 2,           // ordinal: 0x2
  AssignedRegionSystemCache = 3,         // ordinal: 0x3
  AssignedRegionSystemPtes = 4,          // ordinal: 0x4
  AssignedRegionKasan = 5,               // ordinal: 0x5
  AssignedRegionUltraZero = 6,           // ordinal: 0x6
  AssignedRegionCfg = 7,                 // ordinal: 0x7
  AssignedRegionHyperSpace = 8,          // ordinal: 0x8
  AssignedRegionKernelStacks = 9,        // ordinal: 0x9
  AssignedRegionPageTables = 10,         // ordinal: 0xa
  AssignedRegionSession = 11,            // ordinal: 0xb
  AssignedRegionSecureNonPagedPool = 12, // ordinal: 0xc
  AssignedRegionKernelShadowStacks = 13, // ordinal: 0xd
  AssignedRegionSystemImages = 14,       // ordinal: 0xe
  AssignedRegionMaximum = 15,            // ordinal: 0xf
} _MI_ASSIGNED_REGION_TYPES;

typedef enum _MI_SUBVAD_LISTS {
  MiSubVadPebTebAny = 0, // ordinal: 0x0
  MiSubVadMaximum = 1,   // ordinal: 0x1
} _MI_SUBVAD_LISTS;

typedef enum _KWAIT_STATE {
  WaitInProgress = 0,        // ordinal: 0x0
  WaitCommitted = 1,         // ordinal: 0x1
  WaitAborted = 2,           // ordinal: 0x2
  WaitSuspendInProgress = 3, // ordinal: 0x3
  WaitSuspended = 4,         // ordinal: 0x4
  WaitResumeInProgress = 5,  // ordinal: 0x5
  WaitResumeAborted = 6,     // ordinal: 0x6
  WaitFirstSuspendState = 3, // ordinal: 0x7
  WaitLastSuspendState = 6,  // ordinal: 0x8
  MaximumWaitState = 7,      // ordinal: 0x9
} _KWAIT_STATE;

typedef enum _KI_CALLBACK {
  KiCallbackNmi = 0,   // ordinal: 0x0
  KiCallbackBound = 1, // ordinal: 0x1
  KiCallbackSx = 2,    // ordinal: 0x2
  KiCallbackCount = 3, // ordinal: 0x3
  KiFirstCallback = 0, // ordinal: 0x4
} _KI_CALLBACK;

typedef enum _POP_DEEP_SLEEP_DISENGAGE_REASON {
  PopDeepSleepDisengageReasonInactive = 0,                // ordinal: 0x0
  PopDeepSleepDisengageReasonNonAoAc = 1,                 // ordinal: 0x1
  PopDeepSleepDisengageReasonPendingIrps = 2,             // ordinal: 0x2
  PopDeepSleepDisengageReasonPowerSettings = 3,           // ordinal: 0x3
  PopDeepSleepDisengageReasonDozeS4WorkerQueued = 4,      // ordinal: 0x4
  PopDeepSleepDisengageReasonSystemPowerTransition = 5,   // ordinal: 0x5
  PopDeepSleepDisengageReasonDeviceBlockingDrips = 6,     // ordinal: 0x6
  PopDeepSleepDisengageReasonAcpi = 7,                    // ordinal: 0x7
  PopDeepSleepDisengageReasonDirectedDripsTransition = 8, // ordinal: 0x8
  PopDeepSleepDisengageReasonPepPreVeto = 9,              // ordinal: 0x9
  PopDeepSleepDisengageReasonThermal = 10,                // ordinal: 0xa
  PopDeepSleepDisengageReasonMax = 11,                    // ordinal: 0xb
} _POP_DEEP_SLEEP_DISENGAGE_REASON;

typedef enum _ETW_GUID_TYPE {
  EtwTraceGuidType = 0,        // ordinal: 0x0
  EtwNotificationGuidType = 1, // ordinal: 0x1
  EtwGroupGuidType = 2,        // ordinal: 0x2
  EtwGuidTypeMax = 3,          // ordinal: 0x3
} _ETW_GUID_TYPE;

typedef enum _MI_KSTACK_TYPE {
  MiRegularKstack = 0,     // ordinal: 0x0
  MiShortLivedKstack = 1,  // ordinal: 0x1
  MiXStateStateKstack = 2, // ordinal: 0x2
  MiMaximumKstack = 3,     // ordinal: 0x3
} _MI_KSTACK_TYPE;

typedef enum _WOW64_SHARED_INFORMATION {
  SharedNtdll32LdrInitializeThunk = 0,                  // ordinal: 0x0
  SharedNtdll32KiUserExceptionDispatcher = 1,           // ordinal: 0x1
  SharedNtdll32KiUserApcDispatcher = 2,                 // ordinal: 0x2
  SharedNtdll32KiUserCallbackDispatcher = 3,            // ordinal: 0x3
  SharedNtdll32RtlUserThreadStart = 4,                  // ordinal: 0x4
  SharedNtdll32pQueryProcessDebugInformationRemote = 5, // ordinal: 0x5
  SharedNtdll32BaseAddress = 6,                         // ordinal: 0x6
  SharedNtdll32LdrSystemDllInitBlock = 7,               // ordinal: 0x7
  SharedNtdll32RtlpFreezeTimeBias = 8,                  // ordinal: 0x8
  Wow64SharedPageEntriesCount = 9,                      // ordinal: 0x9
} _WOW64_SHARED_INFORMATION;

typedef enum _PO_HIBER_FORCE_DISABLE_REASON {
  PoHiberForceDisableReasonPolicy = 0,      // ordinal: 0x0
  PoHiberForceDisableReasonGuardedHost = 1, // ordinal: 0x1
  PoHiberForceDisableReasonMax = 2,         // ordinal: 0x2
} _PO_HIBER_FORCE_DISABLE_REASON;

typedef enum _SYSTEM_PROCESS_CLASSIFICATION {
  SystemProcessClassificationNormal = 0,         // ordinal: 0x0
  SystemProcessClassificationSystem = 1,         // ordinal: 0x1
  SystemProcessClassificationSecureSystem = 2,   // ordinal: 0x2
  SystemProcessClassificationMemCompression = 3, // ordinal: 0x3
  SystemProcessClassificationRegistry = 4,       // ordinal: 0x4
  SystemProcessClassificationMaximum = 5,        // ordinal: 0x5
} _SYSTEM_PROCESS_CLASSIFICATION;

typedef enum _KTHREAD_CORE_ISOLATION_REASON {
  KThreadCoreIsolationReasonSimulation = 0,       // ordinal: 0x0
  KThreadCoreIsolationReasonMitigationPolicy = 1, // ordinal: 0x1
  KThreadCoreIsolationReasonMax = 2,              // ordinal: 0x2
} _KTHREAD_CORE_ISOLATION_REASON;

typedef enum _KTHREAD_STATE {
  Initialized = 0,             // ordinal: 0x0
  Ready = 1,                   // ordinal: 0x1
  Running = 2,                 // ordinal: 0x2
  Standby = 3,                 // ordinal: 0x3
  Terminated = 4,              // ordinal: 0x4
  Waiting = 5,                 // ordinal: 0x5
  Transition = 6,              // ordinal: 0x6
  DeferredReady = 7,           // ordinal: 0x7
  GateWaitObsolete = 8,        // ordinal: 0x8
  WaitingForProcessInSwap = 9, // ordinal: 0x9
} _KTHREAD_STATE;

typedef enum _TlgBlob_t {
  _TlgBlobNone = 0,      // ordinal: 0x0
  _TlgBlobEnd = 1,       // ordinal: 0x1
  _TlgBlobProvider = 2,  // ordinal: 0x2
  _TlgBlobEvent3 = 3,    // ordinal: 0x3
  _TlgBlobProvider3 = 4, // ordinal: 0x4
  _TlgBlobEvent2 = 5,    // ordinal: 0x5
  _TlgBlobEvent4 = 6,    // ordinal: 0x6
  _TlgBlobMax = 7,       // ordinal: 0x7
} _TlgBlob_t;

typedef enum _MI_SHARED_USER_PAGE_TYPES {
  MiSharedUserPageKernel = 0,     // ordinal: 0x0
  MiSharedUserPageHypervisor = 1, // ordinal: 0x1
  MiSharedUserPageMaximum = 2,    // ordinal: 0x2
} _MI_SHARED_USER_PAGE_TYPES;

typedef enum _KPROCESS_PPM_POLICY {
  ProcessPpmDefault = 0,         // ordinal: 0x0
  ProcessPpmThrottle = 1,        // ordinal: 0x1
  ProcessPpmSemiThrottle = 2,    // ordinal: 0x2
  ProcessPpmNoThrottle = 3,      // ordinal: 0x3
  ProcessPpmWindowMinimized = 4, // ordinal: 0x4
  ProcessPpmWindowOccluded = 5,  // ordinal: 0x5
  ProcessPpmWindowVisible = 6,   // ordinal: 0x6
  ProcessPpmWindowInFocus = 7,   // ordinal: 0x7
  ProcessPpmMaximumThrottle = 8, // ordinal: 0x8
  MaxProcessPpmPolicy = 9,       // ordinal: 0x9
} _KPROCESS_PPM_POLICY;

typedef enum _KTHREAD_PPM_POLICY {
  ThreadPpmDefault = 0,         // ordinal: 0x0
  ThreadPpmThrottle = 1,        // ordinal: 0x1
  ThreadPpmSemiThrottle = 2,    // ordinal: 0x2
  ThreadPpmNoThrottle = 3,      // ordinal: 0x3
  ThreadPpmMaximumThrottle = 4, // ordinal: 0x4
  MaxThreadPpmPolicy = 5,       // ordinal: 0x5
} _KTHREAD_PPM_POLICY;

typedef enum PS_CREATE_STATE {
  PsCreateInitialState = 0,        // ordinal: 0x0
  PsCreateFailOnFileOpen = 1,      // ordinal: 0x1
  PsCreateFailOnSectionCreate = 2, // ordinal: 0x2
  PsCreateFailExeFormat = 3,       // ordinal: 0x3
  PsCreateFailMachineMismatch = 4, // ordinal: 0x4
  PsCreateFailExeName = 5,         // ordinal: 0x5
  PsCreateSuccess = 6,             // ordinal: 0x6
  PsCreateMaximumStates = 7,       // ordinal: 0x7
} PS_CREATE_STATE;

typedef enum _MI_DYNAMICBASE_BITMAP {
  DynamicBaseBitMapNative = 0,     // ordinal: 0x0
  DynamicBaseBitMap64Low = 1,      // ordinal: 0x1
  DynamicBaseBitMap64LowWow = 2,   // ordinal: 0x2
  DynamicBaseBitMap32WowFirst = 3, // ordinal: 0x3
  DynamicBaseBitMap32WowLast = 3,  // ordinal: 0x4
  DynamicBaseBitMapInvalid = 4,    // ordinal: 0x5
  DynamicBaseBitMapMax = 4,        // ordinal: 0x6
} _MI_DYNAMICBASE_BITMAP;

typedef enum _POP_SYSTEM_IDLE_EVENT_TYPE {
  PopSystemIdleEventTypeMonitorOffUserInput = 0,          // ordinal: 0x0
  PopSystemIdleEventTypeMonitorOnUserInput = 1,           // ordinal: 0x1
  PopSystemIdleEventTypeUserPresence = 2,                 // ordinal: 0x2
  PopSystemIdleEventTypeResumeFromSxSystemPowerState = 3, // ordinal: 0x3
  PopSystemIdleEventTypeMax = 4,                          // ordinal: 0x4
  PopSystemIdleEventTypeInvalid = 4,                      // ordinal: 0x5
} _POP_SYSTEM_IDLE_EVENT_TYPE;

typedef enum _POP_FX_WORK_POOL_QUEUE {
  PopFxWorkPoolQueueEmergency = 0, // ordinal: 0x0
  PopFxWorkPoolQueuePlugin = 1,    // ordinal: 0x1
  PopFxWorkPoolQueueMax = 2,       // ordinal: 0x2
} _POP_FX_WORK_POOL_QUEUE;

typedef enum _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS {
  JOBOBJECT_PAGE_PRIORITY_LIMIT_ENABLE = 1,      // ordinal: 0x0
  JOBOBJECT_PAGE_PRIORITY_LIMIT_VALID_FLAGS = 1, // ordinal: 0x1
} _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS;

typedef enum _WORKING_SET_TYPE {
  WorkingSetTypeUser = 0,           // ordinal: 0x0
  WorkingSetTypeSession = 1,        // ordinal: 0x1
  WorkingSetTypeSystemTypes = 2,    // ordinal: 0x2
  WorkingSetTypeSystemCache = 2,    // ordinal: 0x3
  WorkingSetTypePagedPool = 3,      // ordinal: 0x4
  WorkingSetTypeSystemViews = 4,    // ordinal: 0x5
  WorkingSetTypePagableMaximum = 4, // ordinal: 0x6
  WorkingSetTypeSystemPtes = 5,     // ordinal: 0x7
  WorkingSetTypeKernelStacks = 6,   // ordinal: 0x8
  WorkingSetTypeNonPagedPool = 7,   // ordinal: 0x9
  WorkingSetTypeMaximum = 8,        // ordinal: 0xa
} _WORKING_SET_TYPE;

typedef enum _PS_PROTECTED_SIGNER {
  PsProtectedSignerNone = 0,         // ordinal: 0x0
  PsProtectedSignerAuthenticode = 1, // ordinal: 0x1
  PsProtectedSignerCodeGen = 2,      // ordinal: 0x2
  PsProtectedSignerAntimalware = 3,  // ordinal: 0x3
  PsProtectedSignerLsa = 4,          // ordinal: 0x4
  PsProtectedSignerWindows = 5,      // ordinal: 0x5
  PsProtectedSignerWinTcb = 6,       // ordinal: 0x6
  PsProtectedSignerWinSystem = 7,    // ordinal: 0x7
  PsProtectedSignerApp = 8,          // ordinal: 0x8
  PsProtectedSignerMax = 9,          // ordinal: 0x9
} _PS_PROTECTED_SIGNER;

typedef enum _MI_MEMORY_HIGHLOW {
  MiMemoryHigh = 0,    // ordinal: 0x0
  MiMemoryLow = 1,     // ordinal: 0x1
  MiMemoryHighLow = 2, // ordinal: 0x2
} _MI_MEMORY_HIGHLOW;

typedef enum FEATURE_ENABLED_STATE {
  FEATURE_ENABLED_STATE_DEFAULT = 0,                // ordinal: 0x0
  FEATURE_ENABLED_STATE_DISABLED = 1,               // ordinal: 0x1
  FEATURE_ENABLED_STATE_ENABLED = 2,                // ordinal: 0x2
  FEATURE_ENABLED_STATE_HAS_NOTIFICATION = 128,     // ordinal: 0x3
  FEATURE_ENABLED_STATE_IS_WEXP_CONFIGURATION = 64, // ordinal: 0x4
} FEATURE_ENABLED_STATE;

typedef enum _MI_STORE_VIRTUAL_PAGEFILE_VALUE {
  MiStoreVirtualPagefileValueInvalid = 0, // ordinal: 0x0
  MiStoreVirtualPagefileValueStart = 2,   // ordinal: 0x1
  MiStoreVirtualPagefileSwap = 2,         // ordinal: 0x2
  MiStoreVirtualPagefileCompress = 3,     // ordinal: 0x3
  MiStoreVirtualPagefileNoCompress = 4,   // ordinal: 0x4
  MiStoreVirtualPagefileMax = 5,          // ordinal: 0x5
} _MI_STORE_VIRTUAL_PAGEFILE_VALUE;

typedef enum _REFS_STREAM_SNAPSHOT_OPERATION {
  REFS_STREAM_SNAPSHOT_OPERATION_INVALID = 0,            // ordinal: 0x0
  REFS_STREAM_SNAPSHOT_OPERATION_CREATE = 1,             // ordinal: 0x1
  REFS_STREAM_SNAPSHOT_OPERATION_LIST = 2,               // ordinal: 0x2
  REFS_STREAM_SNAPSHOT_OPERATION_QUERY_DELTAS = 3,       // ordinal: 0x3
  REFS_STREAM_SNAPSHOT_OPERATION_REVERT = 4,             // ordinal: 0x4
  REFS_STREAM_SNAPSHOT_OPERATION_SET_SHADOW_BTREE = 5,   // ordinal: 0x5
  REFS_STREAM_SNAPSHOT_OPERATION_CLEAR_SHADOW_BTREE = 6, // ordinal: 0x6
  REFS_STREAM_SNAPSHOT_OPERATION_MAX = 6,                // ordinal: 0x7
} _REFS_STREAM_SNAPSHOT_OPERATION;

typedef enum _PERFINFO_KERNELMEMORY_USAGE_TYPE {
  PerfInfoMemUsagePfnMetadata = 0, // ordinal: 0x0
  PerfInfoMemUsageMax = 1,         // ordinal: 0x1
} _PERFINFO_KERNELMEMORY_USAGE_TYPE;

typedef enum _RTL_FEATURE_CONFIGURATION_PRIORITY {
  FeatureConfigurationPriorityImageDefault = 0,   // ordinal: 0x0
  FeatureConfigurationPriorityEnrollment = 2,     // ordinal: 0x1
  FeatureConfigurationPriorityService = 4,        // ordinal: 0x2
  FeatureConfigurationPriorityUser = 8,           // ordinal: 0x3
  FeatureConfigurationPriorityUserPolicy = 10,    // ordinal: 0x4
  FeatureConfigurationPriorityTest = 12,          // ordinal: 0x5
  FeatureConfigurationPriorityImageOverride = 15, // ordinal: 0x6
  FeatureConfigurationPriorityMax = 15,           // ordinal: 0x7
} _RTL_FEATURE_CONFIGURATION_PRIORITY;

typedef enum _HEAP_SEGMGR_LARGE_PAGE_POLICY {
  HeapSegMgrNoLargePages = 0,       // ordinal: 0x0
  HeapSegMgrEnableLargePages = 1,   // ordinal: 0x1
  HeapSegMgrNormalPolicy = 1,       // ordinal: 0x2
  HeapSegMgrForceSmall = 2,         // ordinal: 0x3
  HeapSegMgrForceLarge = 3,         // ordinal: 0x4
  HeapSegMgrForceRandom = 4,        // ordinal: 0x5
  HeapSegMgrLargePagePolicyMax = 5, // ordinal: 0x6
} _HEAP_SEGMGR_LARGE_PAGE_POLICY;

typedef enum _PS_RESOURCE_TYPE {
  PsResourceNonPagedPool = 0, // ordinal: 0x0
  PsResourcePagedPool = 1,    // ordinal: 0x1
  PsResourcePageFile = 2,     // ordinal: 0x2
  PsResourceWorkingSet = 3,   // ordinal: 0x3
  PsResourceMax = 4,          // ordinal: 0x4
} _PS_RESOURCE_TYPE;

typedef enum _PROCESS_VA_TYPE {
  ProcessVAImage = 0,   // ordinal: 0x0
  ProcessVASection = 1, // ordinal: 0x1
  ProcessVAPrivate = 2, // ordinal: 0x2
  ProcessVAMax = 3,     // ordinal: 0x3
} _PROCESS_VA_TYPE;

typedef enum _MI_CFG_BITMAP_TYPE {
  CfgBitMapNative = 0, // ordinal: 0x0
  CfgBitMapWow64 = 1,  // ordinal: 0x1
  CfgBitMapMax = 2,    // ordinal: 0x2
} _MI_CFG_BITMAP_TYPE;

typedef enum _PS_PROTECTED_TYPE {
  PsProtectedTypeNone = 0,           // ordinal: 0x0
  PsProtectedTypeProtectedLight = 1, // ordinal: 0x1
  PsProtectedTypeProtected = 2,      // ordinal: 0x2
  PsProtectedTypeMax = 3,            // ordinal: 0x3
} _PS_PROTECTED_TYPE;

typedef enum _SKSERVICE {
  SECURESERVICE_NONE = 0,                                     // ordinal: 0x0
  SECURESERVICE_PHASE4_INIT = 1,                              // ordinal: 0x1
  SECURESERVICE_START_PROCESSOR = 2,                          // ordinal: 0x2
  SECURESERVICE_FINISH_START_PROCESSOR = 3,                   // ordinal: 0x3
  SECURESERVICE_REGISTER_SYSTEM_DLLS = 4,                     // ordinal: 0x4
  SECURESERVICE_REGISTER_SYSTEM_PROCESS = 5,                  // ordinal: 0x5
  SECURESERVICE_CREATE_PROCESS = 6,                           // ordinal: 0x6
  SECURESERVICE_INITIALIZE_PROCESS = 7,                       // ordinal: 0x7
  SECURESERVICE_CREATE_THREAD = 8,                            // ordinal: 0x8
  SECURESERVICE_REQUEST_THREAD_EXIT = 9,                      // ordinal: 0x9
  SECURESERVICE_TERMINATE_THREAD = 10,                        // ordinal: 0xa
  SECURESERVICE_RUNDOWN_PROCESS = 11,                         // ordinal: 0xb
  SECURESERVICE_DEBUG_PROCESS = 12,                           // ordinal: 0xc
  SECURESERVICE_GET_TEB_ADDRESS = 13,                         // ordinal: 0xd
  SECURESERVICE_GET_CONTEXT = 14,                             // ordinal: 0xe
  SECURESERVICE_SET_CONTEXT = 15,                             // ordinal: 0xf
  SECURESERVICE_SEND_ATTACH_NOTIFICATIONS = 16,               // ordinal: 0x10
  SECURESERVICE_GET_ETW_DEBUG_ID = 17,                        // ordinal: 0x11
  SECURESERVICE_GET_ON_DEMAND_DEBUG_CHALLENGE = 18,           // ordinal: 0x12
  SECURESERVICE_ENABLE_ON_DEMAND_DEBUG_WITH_RESPONSE = 19,    // ordinal: 0x13
  SECURESERVICE_RETRIEVE_MAILBOX = 20,                        // ordinal: 0x14
  SECURESERVICE_IS_TRUSTLET_RUNNING = 21,                     // ordinal: 0x15
  SECURESERVICE_CREATE_SECURE_ALLOCATION = 22,                // ordinal: 0x16
  SECURESERVICE_FILL_SECURE_ALLOCATION = 23,                  // ordinal: 0x17
  SECURESERVICE_MAKE_CODE_CATALOG = 24,                       // ordinal: 0x18
  SECURESERVICE_CREATE_SECURE_IMAGE = 25,                     // ordinal: 0x19
  SECURESERVICE_FINALIZE_SECURE_IMAGE_HASH = 26,              // ordinal: 0x1a
  SECURESERVICE_FINISH_SECURE_IMAGE_VALIDATION = 27,          // ordinal: 0x1b
  SECURESERVICE_PREPARE_IMAGE_RELOCATIONS = 28,               // ordinal: 0x1c
  SECURESERVICE_RELOCATE_IMAGE = 29,                          // ordinal: 0x1d
  SECURESERVICE_CLOSE_SECURE_HANDLE = 30,                     // ordinal: 0x1e
  SECURESERVICE_VALIDATE_DYNAMIC_CODE = 31,                   // ordinal: 0x1f
  SECURESERVICE_TRANSFER_IMAGE_VERSION_RESOURCE = 32,         // ordinal: 0x20
  SECURESERVICE_SET_CODE_INTEGRITY_POLICY = 33,               // ordinal: 0x21
  SECURESERVICE_EXCHANGE_ENTROPY = 34,                        // ordinal: 0x22
  SECURESERVICE_IS_ENCRYPTION_KEY_AVAILABLE = 35,             // ordinal: 0x23
  SECURESERVICE_ALLOCATE_HIBERNATE_RESOURCES = 36,            // ordinal: 0x24
  SECURESERVICE_FREE_HIBERNATE_RESOURCES = 37,                // ordinal: 0x25
  SECURESERVICE_CONFIGURE_DYNAMIC_MEMORY = 38,                // ordinal: 0x26
  SECURESERVICE_DEBUG_PROTECT_MEMORY = 39,                    // ordinal: 0x27
  SECURESERVICE_DEBUG_READ_WRITE_MEMORY = 40,                 // ordinal: 0x28
  SECURESERVICE_QUERY_VIRTUAL_MEMORY = 41,                    // ordinal: 0x29
  SECURESERVICE_CAPTURE_IMAGE_IAT = 42,                       // ordinal: 0x2a
  SECURESERVICE_FREE_IMAGE_IAT = 43,                          // ordinal: 0x2b
  SECURESERVICE_APPLY_FIXUPS = 44,                            // ordinal: 0x2c
  SECURESERVICE_MARK_IMAGE_PROTECTED = 45,                    // ordinal: 0x2d
  SECURESERVICE_CREATE_ENCLAVE = 46,                          // ordinal: 0x2e
  SECURESERVICE_LOAD_ENCLAVE_DATA = 47,                       // ordinal: 0x2f
  SECURESERVICE_LOAD_ENCLAVE_MODULE = 48,                     // ordinal: 0x30
  SECURESERVICE_INITIALIZE_ENCLAVE = 49,                      // ordinal: 0x31
  SECURESERVICE_TERMINATE_ENCLAVE = 50,                       // ordinal: 0x32
  SECURESERVICE_DELETE_ENCLAVE = 51,                          // ordinal: 0x33
  SECURESERVICE_CONNECT_SW_INTERRUPT = 52,                    // ordinal: 0x34
  SECURESERVICE_RELAX_HYPERGUARD_QUOTA = 53,                  // ordinal: 0x35
  SECURESERVICE_REGISTER_BOOT_DRIVERS = 54,                   // ordinal: 0x36
  SECURESERVICE_LIVEDUMP_QUERY_SECONDARYDATA_SIZE = 55,       // ordinal: 0x37
  SECURESERVICE_LIVEDUMP_START = 56,                          // ordinal: 0x38
  SECURESERVICE_LIVEDUMP_ADD_BUFFER = 57,                     // ordinal: 0x39
  SECURESERVICE_LIVEDUMP_SETUP_BUFFER = 58,                   // ordinal: 0x3a
  SECURESERVICE_LIVEDUMP_FINALIZE = 59,                       // ordinal: 0x3b
  SECURESERVICE_LIVEDUMP_ABORT = 60,                          // ordinal: 0x3c
  SECURESERVICE_LIVEDUMP_CAPTURE_PROCESS = 61,                // ordinal: 0x3d
  SECURESERVICE_NOTIFY_POWER_STATE = 62,                      // ordinal: 0x3e
  SECURESERVICE_QUERY_PROFILE_INFORMATION = 63,               // ordinal: 0x3f
  SECURESERVICE_UPDATE_FREEZE_BIAS = 64,                      // ordinal: 0x40
  SECURESERVICE_CREATE_SECURE_SECTION = 65,                   // ordinal: 0x41
  SECURESERVICE_DELETE_SECURE_SECTION = 66,                   // ordinal: 0x42
  SECURESERVICE_QUERY_SECURE_DEVICE = 67,                     // ordinal: 0x43
  SECURESERVICE_UNPROTECT_SECURE_DEVICE = 68,                 // ordinal: 0x44
  SECURESERVICE_DETERMINE_HOT_PATCH_TYPE = 69,                // ordinal: 0x45
  SECURESERVICE_OBTAIN_PATCH_UNDO_TABLE_SIZE = 70,            // ordinal: 0x46
  SECURESERVICE_OBTAIN_PATCH_UNDO_TABLE = 71,                 // ordinal: 0x47
  SECURESERVICE_APPLY_HOT_PATCH = 72,                         // ordinal: 0x48
  SECURESERVICE_REVERT_HOT_PATCH = 73,                        // ordinal: 0x49
  SECURESERVICE_PREPARE_DRIVER_FOR_PATCH = 74,                // ordinal: 0x4a
  SECURESERVICE_PROVISION_DUMP_KEYS = 75,                     // ordinal: 0x4b
  SECURESERVICE_CAPTURE_PGO_DATA = 76,                        // ordinal: 0x4c
  SECURESERVICE_START_PROFILE = 77,                           // ordinal: 0x4d
  SECURESERVICE_STOP_PROFILE = 78,                            // ordinal: 0x4e
  SECURESERVICE_SECURE_POOL_CREATE = 79,                      // ordinal: 0x4f
  SECURESERVICE_SECURE_POOL_DESTROY = 80,                     // ordinal: 0x50
  SECURESERVICE_SECURE_POOL_ALLOCATE = 81,                    // ordinal: 0x51
  SECURESERVICE_SECURE_POOL_FREE = 82,                        // ordinal: 0x52
  SECURESERVICE_SECURE_POOL_UPDATE = 83,                      // ordinal: 0x53
  SECURESERVICE_SET_TRACEPOINT = 84,                          // ordinal: 0x54
  SECURESERVICE_TRANSFORM_DUMP_KEY = 85,                      // ordinal: 0x55
  SECURESERVICE_PUBLISH_SYSCALL_PROVIDER_SERVICE_TABLES = 86, // ordinal: 0x56
  SECURESERVICE_REVOKE_SYSCALL_PROVIDER_SERVICE_TABLES = 87,  // ordinal: 0x57
  SECURESERVICE_NO_TRACING_FIRST = 191,                       // ordinal: 0x58
  SECURESERVICE_GET_PEB_ADDRESS = 192,                        // ordinal: 0x59
  SECURESERVICE_VALIDATE_SECURE_IMAGE_PAGES = 193,            // ordinal: 0x5a
  SECURESERVICE_PRE_INIT_FIRST = 207,                         // ordinal: 0x5b
  SECURESERVICE_PHASE3_INIT = 208,                            // ordinal: 0x5c
  SECURESERVICE_PERIODIC = 209,                               // ordinal: 0x5d
  SECURESERVICE_WORK_QUEUE = 210,                             // ordinal: 0x5e
  SECURESERVICE_RESERVE_PROTECTED_PAGES = 211,                // ordinal: 0x5f
  SECURESERVICE_APPLY_DYNAMIC_RELOCATIONS = 212,              // ordinal: 0x60
  SECURESERVICE_ETW_ENABLE_CALLBACK = 213,                    // ordinal: 0x61
  SECURESERVICE_INITIALIZE_SECURE_POOL = 214,                 // ordinal: 0x62
  SECURESERVICE_INITIALIZE_KERNEL_CFG = 215,                  // ordinal: 0x63
  SECURESERVICE_LOAD_DRIVER = 216,                            // ordinal: 0x64
  SECURESERVICE_UNLOAD_DRIVER = 217,                          // ordinal: 0x65
  SECURESERVICE_ENABLE_CFG_TARGET = 218,                      // ordinal: 0x66
  SECURESERVICE_COMPLETE_SLAB_CONFIGURATION = 219,            // ordinal: 0x67
  SECURESERVICE_REAPPLY_BOOT_DRIVER_PATCH = 220,              // ordinal: 0x68
  SECURESERVICE_INITIALIZE_RETPOLINE = 221,                   // ordinal: 0x69
  SECURESERVICE_PERFORM_RETPOLINE_RELOCATIONS = 222,          // ordinal: 0x6a
  SECURESERVICE_UPDATE_IMPORT_RELOCATIONS = 223,              // ordinal: 0x6b
  SECURESERVICE_REAPPLY_IMPORT_RELOCATIONS = 224,             // ordinal: 0x6c
  SECURESERVICE_INIT_FUNCTION_OVERRIDES = 225,                // ordinal: 0x6d
  SECURESERVICE_PERFORM_DRIVER_FUNCTION_OVERRIDES = 226,      // ordinal: 0x6e
  SECURESERVICE_ALLOCATE_SHADOW_STACK = 227,                  // ordinal: 0x6f
  SECURESERVICE_FREE_SHADOW_STACK = 228,                      // ordinal: 0x70
  SECURESERVICE_RESET_SHADOW_STACK = 229,                     // ordinal: 0x71
  SECURESERVICE_REGISTER_SYSCALL_PROVIDER_SERVICE_TABLE_MD =
      230,                                                // ordinal: 0x72
  SECURESERVICE_INITIALIZE_SYSCALL_PROVIDERS = 231,       // ordinal: 0x73
  SECURESERVICE_DISPATCH_LEVEL_FIRST = 239,               // ordinal: 0x74
  SECURESERVICE_FLUSH_ADDRESS_SPACE = 240,                // ordinal: 0x75
  SECURESERVICE_FAST_FLUSH_RANGE_LIST = 241,              // ordinal: 0x76
  SECURESERVICE_SLOW_FLUSH_RANGE_LIST = 242,              // ordinal: 0x77
  SECURESERVICE_REMOVE_PROTECTED_PAGE = 243,              // ordinal: 0x78
  SECURESERVICE_COPY_PROTECTED_PAGE = 244,                // ordinal: 0x79
  SECURESERVICE_REGISTER_PROTECTED_PAGE = 245,            // ordinal: 0x7a
  SECURESERVICE_DISAMBIGUATE_PROTECTED_PAGE = 246,        // ordinal: 0x7b
  SECURESERVICE_MAKE_PROTECTED_PAGE_WRITABLE = 247,       // ordinal: 0x7c
  SECURESERVICE_MAKE_PROTECTED_PAGE_EXECUTABLE = 248,     // ordinal: 0x7d
  SECURESERVICE_QUERY_STRONG_CODE_FEATURES = 249,         // ordinal: 0x7e
  SECURESERVICE_INVOKE_EFI_RUNTIME_SERVICE = 250,         // ordinal: 0x7f
  SECURESERVICE_LIVEDUMP_COLLECT_LIVE_DUMP = 251,         // ordinal: 0x80
  SECURESERVICE_REGISTER_LOG_PAGES = 252,                 // ordinal: 0x81
  SECURESERVICE_RECLAIM_PARTITION_PAGES = 253,            // ordinal: 0x82
  SECURESERVICE_BIND_NT_KERNEL_IMPORTS = 254,             // ordinal: 0x83
  SECURESERVICE_SET_PLACEHOLDER_PAGES = 255,              // ordinal: 0x84
  SECURESERVICE_QUERY_SPECULATION_CONTROL_FEATURES = 256, // ordinal: 0x85
  SECURESERVICE_PROTECT_KERNEL_DATA_PAGE = 257,           // ordinal: 0x86
  SECURESERVICE_VERIFY_PAGE = 258,                        // ordinal: 0x87
  SECURESERVICE_PREPARE_FOR_HIBERNATION = 259,            // ordinal: 0x88
  SECURESERVICE_PREPARE_FOR_CRASHDUMP = 260,              // ordinal: 0x89
  SECURESERVICE_REPORT_BUGCHECK_PROGRESS = 261,           // ordinal: 0x8a
  SECURESERVICE_SHUTDOWN = 262,                           // ordinal: 0x8b
  SECURESERVICE_QUERY_SECURE_PCI_INFO = 263,              // ordinal: 0x8c
  SECURESERVICE_ACCESS_PCI_DEVICE = 264,                  // ordinal: 0x8d
  SECURESERVICE_QUERY_SECURE_PCI_BOOT_CONFIG = 265,       // ordinal: 0x8e
  SECURESERVICE_REINITIALIZE_DEBUGGER_TRANSPORT = 266,    // ordinal: 0x8f
  SECURESERVICE_KSR_CALL = 267,                           // ordinal: 0x90
  SECURESERVICE_SVC_CALL = 268,                           // ordinal: 0x91
  SECURESERVICE_SHADOW_STACK_ASSIST = 269,                // ordinal: 0x92
  SECURESERVICE_BUGCHECK = 1792,                          // ordinal: 0x93
  SECURESERVICE_LIMITED_MODE_SERVICE_START = 2048,        // ordinal: 0x94
} _SKSERVICE;

typedef enum _KTIMER2_COLLECTION_INDEX {
  KTimer2CollectionNoWake = 0,       // ordinal: 0x0
  KTimer2CollectionHr = 1,           // ordinal: 0x1
  KTimer2CollectionPseudoHr = 2,     // ordinal: 0x2
  KTimer2CollectionFinite = 3,       // ordinal: 0x3
  KTimer2CollectionIr = 4,           // ordinal: 0x4
  KTimer2CollectionNotInserted = 16, // ordinal: 0x5
  KTimer2CollectionInvalid = 21,     // ordinal: 0x6
  KTimer2CollectionOptional = 32,    // ordinal: 0x7
  KTimer2CollectionMin = 0,          // ordinal: 0x8
  KTimer2CollectionMax = 5,          // ordinal: 0x9
  KTimer2CollectionNode1 = 2,        // ordinal: 0xa
} _KTIMER2_COLLECTION_INDEX;

typedef enum _MI_WORKING_SET_TYPE {
  MiWorkingSetTypeSystemCache = 0,      // ordinal: 0x0
  MiWorkingSetTypeSystemViews = 1,      // ordinal: 0x1
  MiWorkingSetTypePartitionMaximum = 1, // ordinal: 0x2
  MiWorkingSetTypePagedPool = 2,        // ordinal: 0x3
  MiWorkingSetTypePagableMaximum = 2,   // ordinal: 0x4
  MiWorkingSetTypeSystemPtes = 3,       // ordinal: 0x5
  MiWorkingSetTypeKernelStacks = 4,     // ordinal: 0x6
  MiWorkingSetTypeNonPagedPool = 5,     // ordinal: 0x7
  MiWorkingSetTypeMaximum = 6,          // ordinal: 0x8
} _MI_WORKING_SET_TYPE;

typedef enum _KSOFTWARE_INTERRUPT_TARGET {
  KSoftwareInterruptTargetNone = 0,               // ordinal: 0x0
  KSoftwareInterruptTargetSingleProcessor = 1,    // ordinal: 0x1
  KSoftwareInterruptTargetMultipleProcessors = 2, // ordinal: 0x2
  KSoftwareInterruptTargetMax = 3,                // ordinal: 0x3
} _KSOFTWARE_INTERRUPT_TARGET;

typedef enum _FAN_NOISE_ZONES_ {
  FanNoiseZoneLow = 0,        // ordinal: 0x0
  FanNoiseZoneMedium = 1,     // ordinal: 0x1
  FanNoiseZoneMediumHigh = 2, // ordinal: 0x2
  FanNoiseZoneHigh = 3,       // ordinal: 0x3
  FanNoiseZoneLast = 3,       // ordinal: 0x4
  FanNoiseZoneMax = 4,        // ordinal: 0x5
} _FAN_NOISE_ZONES_;

typedef enum _POWER_INFORMATION_LEVEL_INTERNAL_TTMTCAPI {
  PowerInformationInternalTtmFirst = 4096,           // ordinal: 0x0
  PowerInternalTtmOpenTerminal = 4096,               // ordinal: 0x1
  PowerInternalTtmCreateTerminal = 4097,             // ordinal: 0x2
  PowerInternalTtmEvacuateDevices = 4098,            // ordinal: 0x3
  PowerInternalTtmCreateTerminalEventQueue = 4099,   // ordinal: 0x4
  PowerInternalTtmGetTerminalEvent = 4100,           // ordinal: 0x5
  PowerInternalTtmSetDefaultDeviceAssignment = 4101, // ordinal: 0x6
  PowerInternalTtmAssignDevice = 4102,               // ordinal: 0x7
  PowerInternalTtmSetDisplayState = 4103,            // ordinal: 0x8
  PowerInternalTtmSetDisplayTimeouts = 4104,         // ordinal: 0x9
  PowerInternalTtmSetDisplayPowerRequest = 4105,     // ordinal: 0xa
  PowerInternalTtmSetInputWakeCapability = 4106,     // ordinal: 0xb
  PowerInformationInternalTtmLast = 4106,            // ordinal: 0xc
} _POWER_INFORMATION_LEVEL_INTERNAL_TTMTCAPI;

typedef enum _MI_ENCLAVE_TYPE {
  MiEnclaveNone = 0,     // ordinal: 0x0
  MiEnclaveHardware = 1, // ordinal: 0x1
  MiEnclaveVsm = 2,      // ordinal: 0x2
  MiEnclaveMax = 3,      // ordinal: 0x3
} _MI_ENCLAVE_TYPE;

typedef enum _KTHREAD_TAG {
  KThreadTagNone = 0,           // ordinal: 0x0
  KThreadTagMediaBuffering = 1, // ordinal: 0x1
  KThreadTagDeadline = 2,       // ordinal: 0x2
  KThreadTagMediaOther = 3,     // ordinal: 0x3
  KThreadTagMax = 4,            // ordinal: 0x4
} _KTHREAD_TAG;

typedef enum _REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS {
  REFS_SET_VOLUME_COMPRESSION_INFO_FLAG_COMPRESS_SYNC = 1, // ordinal: 0x0
  REFS_SET_VOLUME_COMPRESSION_INFO_FLAG_MAX = 1,           // ordinal: 0x1
} _REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS;

typedef enum _KHETERO_RUNNING_TYPE {
  KHeteroShortRunning = 0,   // ordinal: 0x0
  KHeteroLongRunning = 1,    // ordinal: 0x1
  KHeteroRunningTypeMax = 2, // ordinal: 0x2
} _KHETERO_RUNNING_TYPE;

typedef enum wil_FeatureStage {
  wil_FeatureStage_AlwaysDisabled = 0,    // ordinal: 0x0
  wil_FeatureStage_DisabledByDefault = 1, // ordinal: 0x1
  wil_FeatureStage_EnabledByDefault = 2,  // ordinal: 0x2
  wil_FeatureStage_AlwaysEnabled = 3,     // ordinal: 0x3
} wil_FeatureStage;

typedef enum _RTL_MEMORY_TYPE {
  MemoryTypePaged = 0,     // ordinal: 0x0
  MemoryTypeNonPaged = 1,  // ordinal: 0x1
  MemoryType64KPage = 2,   // ordinal: 0x2
  MemoryTypeLargePage = 3, // ordinal: 0x3
  MemoryTypeHugePage = 4,  // ordinal: 0x4
  MemoryTypeCustom = 5,    // ordinal: 0x5
  MemoryTypeMax = 6,       // ordinal: 0x6
} _RTL_MEMORY_TYPE;

typedef enum _PS_WAKE_REASON {
  PsWakeReasonUser = 0,              // ordinal: 0x0
  PsWakeReasonExecutionRequired = 1, // ordinal: 0x1
  PsWakeReasonKernel = 2,            // ordinal: 0x2
  PsWakeReasonInstrumentation = 3,   // ordinal: 0x3
  PsWakeReasonPreserveProcess = 4,   // ordinal: 0x4
  PsWakeReasonActivityReference = 5, // ordinal: 0x5
  PsWakeReasonWorkOnBehalf = 6,      // ordinal: 0x6
  PsMaxWakeReasons = 7,              // ordinal: 0x7
} _PS_WAKE_REASON;

typedef enum _MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE {
  MemoryNotContiguous = 0,               // ordinal: 0x0
  MemoryAlignedAndContiguous = 1,        // ordinal: 0x1
  MemoryNotResident = 2,                 // ordinal: 0x2
  MemoryNotEligibleToMakeContiguous = 3, // ordinal: 0x3
  MemoryContiguityStateMax = 4,          // ordinal: 0x4
} _MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE;

typedef enum _PS_STD_HANDLE_STATE {
  PsNeverDuplicate = 0,     // ordinal: 0x0
  PsRequestDuplicate = 1,   // ordinal: 0x1
  PsAlwaysDuplicate = 2,    // ordinal: 0x2
  PsMaxStdHandleStates = 3, // ordinal: 0x3
} _PS_STD_HANDLE_STATE;

typedef enum _POWER_INFORMATION_LEVEL_INTERNAL {
  PowerInternalAcpiInterfaceRegister = 0,                    // ordinal: 0x0
  PowerInternalS0LowPowerIdleInfo = 1,                       // ordinal: 0x1
  PowerInternalReapplyBrightnessSettings = 2,                // ordinal: 0x2
  PowerInternalUserAbsencePrediction = 3,                    // ordinal: 0x3
  PowerInternalUserAbsencePredictionCapability = 4,          // ordinal: 0x4
  PowerInternalPoProcessorLatencyHint = 5,                   // ordinal: 0x5
  PowerInternalStandbyNetworkRequest = 6,                    // ordinal: 0x6
  PowerInternalDirtyTransitionInformation = 7,               // ordinal: 0x7
  PowerInternalSetBackgroundTaskState = 8,                   // ordinal: 0x8
  PowerInternalReservedDoNotUseEnum9 = 9,                    // ordinal: 0x9
  PowerInternalReservedDoNotUseEnum10 = 10,                  // ordinal: 0xa
  PowerInternalReservedDoNotUseEnum11 = 11,                  // ordinal: 0xb
  PowerInternalReservedDoNotUseEnum12 = 12,                  // ordinal: 0xc
  PowerInternalReservedDoNotUseEnum13 = 13,                  // ordinal: 0xd
  PowerInternalReservedDoNotUseEnum14 = 14,                  // ordinal: 0xe
  PowerInternalReservedDoNotUseEnum15 = 15,                  // ordinal: 0xf
  PowerInternalReservedDoNotUseEnum16 = 16,                  // ordinal: 0x10
  PowerInternalReservedDoNotUseEnum17 = 17,                  // ordinal: 0x11
  PowerInternalBootSessionStandbyActivationInformation = 18, // ordinal: 0x12
  PowerInternalSessionPowerState = 19,                       // ordinal: 0x13
  PowerInternalSessionTerminalInput = 20,                    // ordinal: 0x14
  PowerInternalSetWatchdog = 21,                             // ordinal: 0x15
  PowerInternalPhysicalPowerButtonPressInfoAtBoot = 22,      // ordinal: 0x16
  PowerInternalExternalMonitorConnected = 23,                // ordinal: 0x17
  PowerInternalHighPrecisionBrightnessSettings = 24,         // ordinal: 0x18
  PowerInternalWinrtScreenToggle = 25,                       // ordinal: 0x19
  PowerInternalPpmQosDisable = 26,                           // ordinal: 0x1a
  PowerInternalTransitionCheckpoint = 27,                    // ordinal: 0x1b
  PowerInternalInputControllerState = 28,                    // ordinal: 0x1c
  PowerInternalFirmwareResetReason = 29,                     // ordinal: 0x1d
  PowerInternalPpmSchedulerQosSupport = 30,                  // ordinal: 0x1e
  PowerInternalBootStatGet = 31,                             // ordinal: 0x1f
  PowerInternalBootStatSet = 32,                             // ordinal: 0x20
  PowerInternalCallHasNotReturnedWatchdog = 33,              // ordinal: 0x21
  PowerInternalBootStatCheckIntegrity = 34,                  // ordinal: 0x22
  PowerInternalBootStatRestoreDefaults = 35,                 // ordinal: 0x23
  PowerInternalHostEsStateUpdate = 36,                       // ordinal: 0x24
  PowerInternalGetPowerActionState = 37,                     // ordinal: 0x25
  PowerInternalBootStatUnlock = 38,                          // ordinal: 0x26
  PowerInternalWakeOnVoiceState = 39,                        // ordinal: 0x27
  PowerInternalDeepSleepBlock = 40,                          // ordinal: 0x28
  PowerInternalIsPoFxDevice = 41,                            // ordinal: 0x29
  PowerInternalPowerTransitionExtensionAtBoot = 42,          // ordinal: 0x2a
  PowerInternalProcessorBrandedFrequency = 43,               // ordinal: 0x2b
  PowerInternalTimeBrokerExpirationReason = 44,              // ordinal: 0x2c
  PowerInternalNotifyUserShutdownStatus = 45,                // ordinal: 0x2d
  PowerInternalPowerRequestTerminalCoreWindow = 46,          // ordinal: 0x2e
  PowerInternalProcessorIdleVeto = 47,                       // ordinal: 0x2f
  PowerInternalPlatformIdleVeto = 48,                        // ordinal: 0x30
  PowerInternalIsLongPowerButtonBugcheckEnabled = 49,        // ordinal: 0x31
  PowerInternalAutoChkCausedReboot = 50,                     // ordinal: 0x32
  PowerInternalSetWakeAlarmOverride = 51,                    // ordinal: 0x33
  PowerInternalDirectedFxAddTestDevice = 53,                 // ordinal: 0x34
  PowerInternalDirectedFxRemoveTestDevice = 54,              // ordinal: 0x35
  PowerInternalDirectedFxSetMode = 56,                       // ordinal: 0x36
  PowerInternalRegisterPowerPlane = 57,                      // ordinal: 0x37
  PowerInternalSetDirectedDripsFlags = 58,                   // ordinal: 0x38
  PowerInternalClearDirectedDripsFlags = 59,                 // ordinal: 0x39
  PowerInternalRetrieveHiberFileResumeContext = 60,          // ordinal: 0x3a
  PowerInternalReadHiberFilePage = 61,                       // ordinal: 0x3b
  PowerInternalLastBootSucceeded = 62,                       // ordinal: 0x3c
  PowerInternalQuerySleepStudyHelperRoutineBlock = 63,       // ordinal: 0x3d
  PowerInternalDirectedDripsQueryCapabilities = 64,          // ordinal: 0x3e
  PowerInternalClearConstraints = 65,                        // ordinal: 0x3f
  PowerInternalSoftParkVelocityEnabled = 66,                 // ordinal: 0x40
  PowerInternalQueryIntelPepCapabilities = 67,               // ordinal: 0x41
  PowerInternalGetSystemIdleLoopEnablement = 68,             // ordinal: 0x42
  PowerInternalGetVmPerfControlSupport = 69,                 // ordinal: 0x43
  PowerInternalGetVmPerfControlConfig = 70,                  // ordinal: 0x44
  PowerInternalSleepDetailedDiagUpdate = 71,                 // ordinal: 0x45
  PowerInternalProcessorClassFrequencyBandsStats = 72,       // ordinal: 0x46
  PowerInternalHostGlobalUserPresenceStateUpdate = 73,       // ordinal: 0x47
  PowerInternalCpuNodeIdleIntervalStats = 74,                // ordinal: 0x48
  PowerInternalClassIdleIntervalStats = 75,                  // ordinal: 0x49
  PowerInternalCpuNodeConcurrencyStats = 76,                 // ordinal: 0x4a
  PowerInternalClassConcurrencyStats = 77,                   // ordinal: 0x4b
  PowerInternalQueryProcMeasurementCapabilities = 78,        // ordinal: 0x4c
  PowerInternalQueryProcMeasurementValues = 79,              // ordinal: 0x4d
  PowerInternalPrepareForSystemInitiatedReboot = 80,         // ordinal: 0x4e
  PowerInternalGetAdaptiveSessionState = 81,                 // ordinal: 0x4f
  PowerInternalSetConsoleLockedState = 82,                   // ordinal: 0x50
  PowerInternalOverrideSystemInitiatedRebootState = 83,      // ordinal: 0x51
  PowerInternalFanImpactStats = 84,                          // ordinal: 0x52
  PowerInternalFanRpmBuckets = 85,                           // ordinal: 0x53
  PowerInternalPowerBootAppDiagInfo = 86,                    // ordinal: 0x54
  PowerInternalUnregisterShutdownNotification = 87,          // ordinal: 0x55
  PowerInternalManageTransitionStateRecord = 88,             // ordinal: 0x56
  PowerInternalGetAcpiTimeAndAlarmCapabilities = 89,         // ordinal: 0x57
  PowerInternalSuspendResumeRequest = 90,                    // ordinal: 0x58
  PowerInformationInternalMaximum = 91,                      // ordinal: 0x59
} _POWER_INFORMATION_LEVEL_INTERNAL;

typedef enum _BUGCHECK_RECOVERY_LOG_EVENT {
  RecoveryEventStart = 0,                  // ordinal: 0x0
  RecoveryEventPhase1Status = 1,           // ordinal: 0x1
  RecoveryEventPhase2Status = 2,           // ordinal: 0x2
  RecoveryEventMultipleBugcheckStatus = 3, // ordinal: 0x3
  RecoveryEventMax = 4,                    // ordinal: 0x4
} _BUGCHECK_RECOVERY_LOG_EVENT;

typedef enum TlgIn_t {
  TlgInNULL = 0,                  // ordinal: 0x0
  TlgInUNICODESTRING = 1,         // ordinal: 0x1
  TlgInANSISTRING = 2,            // ordinal: 0x2
  TlgInINT8 = 3,                  // ordinal: 0x3
  TlgInUINT8 = 4,                 // ordinal: 0x4
  TlgInINT16 = 5,                 // ordinal: 0x5
  TlgInUINT16 = 6,                // ordinal: 0x6
  TlgInINT32 = 7,                 // ordinal: 0x7
  TlgInUINT32 = 8,                // ordinal: 0x8
  TlgInINT64 = 9,                 // ordinal: 0x9
  TlgInUINT64 = 10,               // ordinal: 0xa
  TlgInFLOAT = 11,                // ordinal: 0xb
  TlgInDOUBLE = 12,               // ordinal: 0xc
  TlgInBOOL32 = 13,               // ordinal: 0xd
  TlgInBINARY = 14,               // ordinal: 0xe
  TlgInGUID = 15,                 // ordinal: 0xf
  _TlgInPOINTER_unsupported = 16, // ordinal: 0x10
  TlgInFILETIME = 17,             // ordinal: 0x11
  TlgInSYSTEMTIME = 18,           // ordinal: 0x12
  TlgInSID = 19,                  // ordinal: 0x13
  TlgInHEXINT32 = 20,             // ordinal: 0x14
  TlgInHEXINT64 = 21,             // ordinal: 0x15
  TlgInCOUNTEDSTRING = 22,        // ordinal: 0x16
  TlgInCOUNTEDANSISTRING = 23,    // ordinal: 0x17
  _TlgInSTRUCT = 24,              // ordinal: 0x18
  TlgInCOUNTEDBINARY = 25,        // ordinal: 0x19
  _TlgInMax = 26,                 // ordinal: 0x1a
  TlgInINTPTR = 9,                // ordinal: 0x1b
  TlgInUINTPTR = 10,              // ordinal: 0x1c
  TlgInPOINTER = 21,              // ordinal: 0x1d
  TlgInLONG = 7,                  // ordinal: 0x1e
  TlgInULONG = 8,                 // ordinal: 0x1f
  TlgInHEXLONG = 20,              // ordinal: 0x20
  _TlgInCcount = 32,              // ordinal: 0x21
  TlgInVcount = 64,               // ordinal: 0x22
  _TlgInChain = 128,              // ordinal: 0x23
  _TlgInCustom = 96,              // ordinal: 0x24
  _TlgInTypeMask = 31,            // ordinal: 0x25
  _TlgInCountMask = 96,           // ordinal: 0x26
  _TlgInFlagMask = 224,           // ordinal: 0x27
} TlgIn_t;

typedef enum PDC_RESOURCE {
  PdcResourceSystemForeground = 0,      // ordinal: 0x0
  PdcResourceUniversalApplications = 1, // ordinal: 0x1
  PdcResourceWin32 = 2,                 // ordinal: 0x2
  PdcResourceNetwork = 3,               // ordinal: 0x3
  PdcResourceSystemBackground = 4,      // ordinal: 0x4
  PdcResourceMin = 0,                   // ordinal: 0x5
  PdcResourceMax = 4,                   // ordinal: 0x6
} PDC_RESOURCE;

typedef enum _POP_SLEEP_CHECKPOINT_STATUS {
  PopSleepCheckpointStatusDisabled = 0,                  // ordinal: 0x0
  PopSleepCheckpointStatusEnabledDueToDirtyShutdown = 1, // ordinal: 0x1
  PopSleepCheckpointStatusEnabledManually = 4,           // ordinal: 0x2
  PopSleepCheckpointStatusEnabledExperiment = 4,         // ordinal: 0x3
  PopSleepCheckpointStatusEnabledMax = 7,                // ordinal: 0x4
  PopSleepCheckpointStatusFailedNotEfiSystem = 8,        // ordinal: 0x5
  PopSleepCheckpointStatusFailedInsufficientSpace = 9,   // ordinal: 0x6
  PopSleepCheckpointStatusFailedTooSlow = 10,            // ordinal: 0x7
  PopSleepCheckpointStatusFailedOtherError = 15,         // ordinal: 0x8
  PopSleepCheckpointStatusMax = 15,                      // ordinal: 0x9
} _POP_SLEEP_CHECKPOINT_STATUS;

typedef enum _KOBJECTS {
  EventNotificationObject = 0,      // ordinal: 0x0
  EventSynchronizationObject = 1,   // ordinal: 0x1
  MutantObject = 2,                 // ordinal: 0x2
  ProcessObject = 3,                // ordinal: 0x3
  QueueObject = 4,                  // ordinal: 0x4
  SemaphoreObject = 5,              // ordinal: 0x5
  ThreadObject = 6,                 // ordinal: 0x6
  GateObject = 7,                   // ordinal: 0x7
  TimerNotificationObject = 8,      // ordinal: 0x8
  TimerSynchronizationObject = 9,   // ordinal: 0x9
  Spare2Object = 10,                // ordinal: 0xa
  Spare3Object = 11,                // ordinal: 0xb
  Spare4Object = 12,                // ordinal: 0xc
  Spare5Object = 13,                // ordinal: 0xd
  Spare6Object = 14,                // ordinal: 0xe
  Spare7Object = 15,                // ordinal: 0xf
  Spare8Object = 16,                // ordinal: 0x10
  ProfileCallbackObject = 17,       // ordinal: 0x11
  ApcObject = 18,                   // ordinal: 0x12
  DpcObject = 19,                   // ordinal: 0x13
  DeviceQueueObject = 20,           // ordinal: 0x14
  PriQueueObject = 21,              // ordinal: 0x15
  InterruptObject = 22,             // ordinal: 0x16
  ProfileObject = 23,               // ordinal: 0x17
  Timer2NotificationObject = 24,    // ordinal: 0x18
  Timer2SynchronizationObject = 25, // ordinal: 0x19
  ThreadedDpcObject = 26,           // ordinal: 0x1a
  MaximumKernelObject = 27,         // ordinal: 0x1b
} _KOBJECTS;

typedef enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
  JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 1,                        // ordinal: 0x0
  JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 2,             // ordinal: 0x1
  JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 4,         // ordinal: 0x2
  JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 8, // ordinal: 0x3
  JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = 15,                  // ordinal: 0x4
} JOB_OBJECT_IO_RATE_CONTROL_FLAGS;

typedef enum _MI_MEMORY_EVENT_TYPES {
  LowPagedPoolEvent = 0,          // ordinal: 0x0
  HighPagedPoolEvent = 1,         // ordinal: 0x1
  LowNonPagedPoolEvent = 2,       // ordinal: 0x2
  HighNonPagedPoolEvent = 3,      // ordinal: 0x3
  LowAvailablePagesEvent = 4,     // ordinal: 0x4
  HighAvailablePagesEvent = 5,    // ordinal: 0x5
  LowCommitEvent = 6,             // ordinal: 0x6
  HighCommitEvent = 7,            // ordinal: 0x7
  MaximumCommitEvent = 8,         // ordinal: 0x8
  BadMemoryDetectedEvent = 9,     // ordinal: 0x9
  PhysicalMemoryChangeEvent = 10, // ordinal: 0xa
  TotalNumberOfMemoryEvents = 11, // ordinal: 0xb
} _MI_MEMORY_EVENT_TYPES;

typedef enum _VRF_RULE_CLASS_ID {
  DifPluginSpecialPool = 0,              // ordinal: 0x0
  DifPluginIrqlRuleClass = 1,            // ordinal: 0x1
  VrfAllocationFailuresRuleClass = 2,    // ordinal: 0x2
  DifPluginPoolTracking = 3,             // ordinal: 0x3
  DifPluginIoRuleClass = 4,              // ordinal: 0x4
  DifPluginDeadlock = 5,                 // ordinal: 0x5
  VrfEnhancedIORuleClass = 6,            // ordinal: 0x6
  DifPluginDmaRuleClass = 7,             // ordinal: 0x7
  DifPluginSecurity = 8,                 // ordinal: 0x8
  VrfForcePendingIORequestRuleClass = 9, // ordinal: 0x9
  VrfIRPTrackingRuleClass = 10,          // ordinal: 0xa
  DifPluginMiscellaneous = 11,           // ordinal: 0xb
  VrfMoreDebuggingRuleClass = 12,        // ordinal: 0xc
  VrfMDLInvariantStackRuleClass = 13,    // ordinal: 0xd
  VrfMDLInvariantDriverRuleClass = 14,   // ordinal: 0xe
  DifPluginPowerDelayFuzzing = 15,       // ordinal: 0xf
  VrfPortMiniportRuleClass = 16,         // ordinal: 0x10
  DifPluginDdiStandard = 17,             // ordinal: 0x11
  DifPluginAutoFail = 18,                // ordinal: 0x12
  DifPluginDdiStateful = 19,             // ordinal: 0x13
  VrfRuleClassBase = 20,                 // ordinal: 0x14
  VrfNdisWifiRuleClass = 21,             // ordinal: 0x15
  DifPluginDriverLogging = 22,           // ordinal: 0x16
  DifPluginSyncDelayFuzzing = 23,        // ordinal: 0x17
  VrfVMSwitchingRuleClass = 24,          // ordinal: 0x18
  VrfCodeIntegrityRuleClass = 25,        // ordinal: 0x19
  VrfBelow4GBAllocationRuleClass = 26,   // ordinal: 0x1a
  VrfProcessorBranchTraceRuleClass = 27, // ordinal: 0x1b
  VrfAdvancedMMRuleClass = 28,           // ordinal: 0x1c
  VrfExtendingXDVTimeLimit = 29,         // ordinal: 0x1d
  VrfSystemBIOSRuleClass = 30,           // ordinal: 0x1e
  VrfHardwareRuleClass = 31,             // ordinal: 0x1f
  DifPluginDriverIsolation = 32,         // ordinal: 0x20
  DifPluginWdfRuleClass = 33,            // ordinal: 0x21
  DifPluginDdiMoreirql = 34,             // ordinal: 0x22
  DifPluginMode = 35,                    // ordinal: 0x23
  ReservedForDVRF36 = 36,                // ordinal: 0x24
  DifPluginTest = 37,                    // ordinal: 0x25
  DifPluginInfoDisclosureIRPRule = 38,   // ordinal: 0x26
  DifPluginLwSP = 39,                    // ordinal: 0x27
  DifPluginAvxCorruption = 40,           // ordinal: 0x28
  DifPluginAccessModeMismatch = 41,      // ordinal: 0x29
  ReservedForDVRF42 = 42,                // ordinal: 0x2a
  ReservedForDVRF43 = 43,                // ordinal: 0x2b
  ReservedForDVRF44 = 44,                // ordinal: 0x2c
  ReservedForDVRF45 = 45,                // ordinal: 0x2d
  ReservedForDVRF46 = 46,                // ordinal: 0x2e
  ReservedForDVRF47 = 47,                // ordinal: 0x2f
  ReservedForDVRF48 = 48,                // ordinal: 0x30
  ReservedForDVRF49 = 49,                // ordinal: 0x31
  ReservedForDVRF50 = 50,                // ordinal: 0x32
  ReservedForDVRF51 = 51,                // ordinal: 0x33
  ReservedForDVRF52 = 52,                // ordinal: 0x34
  ReservedForDVRF53 = 53,                // ordinal: 0x35
  ReservedForDVRF54 = 54,                // ordinal: 0x36
  ReservedForDVRF55 = 55,                // ordinal: 0x37
  ReservedForDVRF56 = 56,                // ordinal: 0x38
  ReservedForDVRF57 = 57,                // ordinal: 0x39
  ReservedForDVRF58 = 58,                // ordinal: 0x3a
  ReservedForDVRF59 = 59,                // ordinal: 0x3b
  ReservedForDVRF60 = 60,                // ordinal: 0x3c
  ReservedForDVRF61 = 61,                // ordinal: 0x3d
  ReservedForDVRF62 = 62,                // ordinal: 0x3e
  ReservedForDVRF63 = 63,                // ordinal: 0x3f
  VrfRuleClassSizeMax = 64,              // ordinal: 0x40
} _VRF_RULE_CLASS_ID;

typedef enum _FREQUENCY_QOS_BUCKET {
  FrequencyQosBucketHigh = 0,  // ordinal: 0x0
  FrequencyQosBucketLow = 1,   // ordinal: 0x1
  FrequencyQosBucketTotal = 2, // ordinal: 0x2
  FrequencyQosBucketMax = 3,   // ordinal: 0x3
} _FREQUENCY_QOS_BUCKET;

typedef enum _MI_FILE_EXTENT_TYPES {
  MiExtentCopyImage = 0,   // ordinal: 0x0
  MiExtentCopyData = 1,    // ordinal: 0x1
  MiExtentCopyMaximum = 2, // ordinal: 0x2
} _MI_FILE_EXTENT_TYPES;

typedef enum _MI_PAGELIST_LOCK_TYPES {
  MiPageListPreviousGlobal = 0, // ordinal: 0x0
  MiPageListNextGlobal = 1,     // ordinal: 0x1
  MiPageListPreviousNode = 2,   // ordinal: 0x2
  MiPageListNextNode = 3,       // ordinal: 0x3
  MiPageListPageMaximum = 4,    // ordinal: 0x4
} _MI_PAGELIST_LOCK_TYPES;

typedef enum PDC_CS_PHASE {
  PdcNoCsPhase = 0,                   // ordinal: 0x0
  PdcConnectionPhase = 1,             // ordinal: 0x1
  PdcShellPhase = 2,                  // ordinal: 0x2
  PdcPlmPhase = 3,                    // ordinal: 0x3
  PdcMaintenancePhase = 4,            // ordinal: 0x4
  PdcDamPhase = 5,                    // ordinal: 0x5
  PdcLowPowerPhase = 6,               // ordinal: 0x6
  PdcResiliencyNotificationPhase = 7, // ordinal: 0x7
  PdcResiliencyPhase = 8,             // ordinal: 0x8
  PdcInvalidPhase = 9,                // ordinal: 0x9
  PdcMaxPhase = 9,                    // ordinal: 0xa
} PDC_CS_PHASE;

typedef enum _POP_SLEEP_CHECKPOINT {
  PopSleepCheckpointInvalid = 0,                             // ordinal: 0x0
  PopSleepCheckpointPowerTransitionStart = 1,                // ordinal: 0x1
  PopSleepCheckpointSuspendAppsBefore = 2,                   // ordinal: 0x2
  PopSleepCheckpointSuspendAppsAfter = 3,                    // ordinal: 0x3
  PopSleepCheckpointSuspendServicesBefore = 4,               // ordinal: 0x4
  PopSleepCheckpointSuspendServicesAfter = 5,                // ordinal: 0x5
  PopSleepCheckpointNotifySuperfetchBefore = 6,              // ordinal: 0x6
  PopSleepCheckpointNotifySuperfetchAfter = 7,               // ordinal: 0x7
  PopSleepCheckpointNotifyCallbacksBefore = 8,               // ordinal: 0x8
  PopSleepCheckpointNotifyCallbacksAfter = 9,                // ordinal: 0x9
  PopSleepCheckpointSleepTransactionCommitted = 10,          // ordinal: 0xa
  PopSleepCheckpointQueryDriversBefore = 11,                 // ordinal: 0xb
  PopSleepCheckpointQueryDriversAfter = 12,                  // ordinal: 0xc
  PopSleepCheckpointAllocatingHiberContext = 13,             // ordinal: 0xd
  PopSleepCheckpointSuspendDriversBefore = 14,               // ordinal: 0xe
  PopSleepCheckpointPreSleepNotification = 16,               // ordinal: 0xf
  PopSleepCheckpointInterruptsDisabledBegin = 17,            // ordinal: 0x10
  PopSleepCheckpointInvokeHandlerBefore = 18,                // ordinal: 0x11
  PopSleepCheckpointSaveHiberContextBegin = 19,              // ordinal: 0x12
  PopSleepCheckpointInitializeDumpStackFailed = 20,          // ordinal: 0x13
  PopSleepCheckpointHiberWriteFailed = 21,                   // ordinal: 0x14
  PopSleepCheckpointHiberFileTooSmall = 22,                  // ordinal: 0x15
  PopSleepCheckpointSaveHiberContextFailed = 23,             // ordinal: 0x16
  PopSleepCheckpointSaveHiberContextEnd = 24,                // ordinal: 0x17
  PopSleepCheckpointHiberKernelHandoff = 25,                 // ordinal: 0x18
  PopSleepCheckpointInvokeHandlerAfter = 26,                 // ordinal: 0x19
  PopSleepCheckpointReadHiberfileBefore = 27,                // ordinal: 0x1a
  PopSleepCheckpointInitializeDumpStackForReadFailed = 28,   // ordinal: 0x1b
  PopSleepCheckpointHiberReadFailed = 29,                    // ordinal: 0x1c
  PopSleepCheckpointChecksumFailure = 30,                    // ordinal: 0x1d
  PopSleepCheckpointDecompressionFailed = 31,                // ordinal: 0x1e
  PopSleepCheckpointReadHiberfileAfter = 32,                 // ordinal: 0x1f
  PopSleepCheckpointInterruptsDisabledEnd = 33,              // ordinal: 0x20
  PopSleepCheckpointWakeDriversAfter = 36,                   // ordinal: 0x21
  PopSleepCheckpointResumeAppsBefore = 37,                   // ordinal: 0x22
  PopSleepCheckpointResumeAppsAfter = 38,                    // ordinal: 0x23
  PopSleepCheckpointResumeServicesBefore = 39,               // ordinal: 0x24
  PopSleepCheckpointResumeServicesAfter = 40,                // ordinal: 0x25
  PopSleepCheckpointPowerTransitionEnd = 41,                 // ordinal: 0x26
  PopSleepCheckpointAllocatingHiberContextNoFileObject = 42, // ordinal: 0x27
  PopSleepCheckpointAllocatingHiberContextGetDumpStackFailed =
      43, // ordinal: 0x28
  PopSleepCheckpointAllocatingHiberContextLoadResumeContextFailed =
      44,                                                     // ordinal: 0x29
  PopSleepCheckpointAllocatingHiberContextBcdOpenFailed = 45, // ordinal: 0x2a
  PopSleepCheckpointAllocatingHiberContextEstablishResumeObjectFailed =
      46, // ordinal: 0x2b
  PopSleepCheckpointAllocatingHiberContextSetPendingResumeFailed =
      47, // ordinal: 0x2c
  PopSleepCheckpointAllocatingHiberContextAllocateIoPagesPagesFailed =
      48, // ordinal: 0x2d
  PopSleepCheckpointAllocatingHiberContextAdapterBuffersInvalid1 =
      49, // ordinal: 0x2e
  PopSleepCheckpointAllocatingHiberContextAllocateDumpPagesFailed =
      50, // ordinal: 0x2f
  PopSleepCheckpointAllocatingHiberContextAdapterBuffersInvalid2 =
      51, // ordinal: 0x30
  PopSleepCheckpointAllocatingHiberContextUnHibernatedMdlFailed =
      52, // ordinal: 0x31
  PopSleepCheckpointAllocatingHiberContextSecureResourcesFailed =
      53,                                    // ordinal: 0x32
  PopSleepCheckpointPrepareSleepBefore = 54, // ordinal: 0x33
  PopSleepCheckpointPrepareSleepAfter = 55,  // ordinal: 0x34
  PopSleepCheckpointBootstatAvailable = 56,  // ordinal: 0x35
  PopSleepCheckpointMax = 57,                // ordinal: 0x36
} _POP_SLEEP_CHECKPOINT;

typedef enum _MI_ALTERNATE_LOCK_VA_TYPE {
  AlternateLockVaTypeSystemPtes = 0,   // ordinal: 0x0
  AlternateLockVaTypeNonPagedPool = 1, // ordinal: 0x1
  AlternateLockVaTypeUser = 2,         // ordinal: 0x2
  AlternateLockVaTypeSystem = 3,       // ordinal: 0x3
  AlternateLockVaTypeMaximum = 4,      // ordinal: 0x4
} _MI_ALTERNATE_LOCK_VA_TYPE;

typedef enum _KWAIT_BLOCK_STATE {
  WaitBlockBypassStart = 0,           // ordinal: 0x0
  WaitBlockBypassComplete = 1,        // ordinal: 0x1
  WaitBlockSuspendBypassStart = 2,    // ordinal: 0x2
  WaitBlockSuspendBypassComplete = 3, // ordinal: 0x3
  WaitBlockActive = 4,                // ordinal: 0x4
  WaitBlockInactive = 5,              // ordinal: 0x5
  WaitBlockSuspended = 6,             // ordinal: 0x6
  WaitBlockAllStates = 7,             // ordinal: 0x7
} _KWAIT_BLOCK_STATE;

typedef enum _MI_ENGINE_TYPE {
  MiEngineAccelerator = 0,   // ordinal: 0x0
  MiEngineFastProcessor = 1, // ordinal: 0x1
  MiEngineSlowProcessor = 2, // ordinal: 0x2
  MiEngineMaximumTypes = 3,  // ordinal: 0x3
} _MI_ENGINE_TYPE;

typedef enum _OBP_LOOKUP_DIR_ENTRY_FLAGS {
  OBP_LOOKUP_SEARCH_SHADOW = 1,     // ordinal: 0x0
  OBP_LOOKUP_IS_SANDBOXED = 2,      // ordinal: 0x1
  OBP_LOOKUP_IS_NOT_SANDBOXED = 4,  // ordinal: 0x2
  OBP_LOOKUP_SANDBOX_COMPUTED = 6,  // ordinal: 0x3
  OBP_LOOKUP_CASE_INSENSITIVE = 64, // ordinal: 0x4
} _OBP_LOOKUP_DIR_ENTRY_FLAGS;

typedef enum _DEVPROP_OPERATOR {
  DEVPROP_OPERATOR_MODIFIER_NOT = 65536,               // ordinal: 0x0
  DEVPROP_OPERATOR_MODIFIER_IGNORE_CASE = 131072,      // ordinal: 0x1
  DEVPROP_OPERATOR_NONE = 0,                           // ordinal: 0x2
  DEVPROP_OPERATOR_EXISTS = 1,                         // ordinal: 0x3
  DEVPROP_OPERATOR_NOT_EXISTS = 65537,                 // ordinal: 0x4
  DEVPROP_OPERATOR_EQUALS = 2,                         // ordinal: 0x5
  DEVPROP_OPERATOR_NOT_EQUALS = 65538,                 // ordinal: 0x6
  DEVPROP_OPERATOR_GREATER_THAN = 3,                   // ordinal: 0x7
  DEVPROP_OPERATOR_LESS_THAN = 4,                      // ordinal: 0x8
  DEVPROP_OPERATOR_GREATER_THAN_EQUALS = 5,            // ordinal: 0x9
  DEVPROP_OPERATOR_LESS_THAN_EQUALS = 6,               // ordinal: 0xa
  DEVPROP_OPERATOR_EQUALS_IGNORE_CASE = 131074,        // ordinal: 0xb
  DEVPROP_OPERATOR_NOT_EQUALS_IGNORE_CASE = 196610,    // ordinal: 0xc
  DEVPROP_OPERATOR_BITWISE_AND = 7,                    // ordinal: 0xd
  DEVPROP_OPERATOR_BITWISE_OR = 8,                     // ordinal: 0xe
  DEVPROP_OPERATOR_BEGINS_WITH = 9,                    // ordinal: 0xf
  DEVPROP_OPERATOR_ENDS_WITH = 10,                     // ordinal: 0x10
  DEVPROP_OPERATOR_CONTAINS = 11,                      // ordinal: 0x11
  DEVPROP_OPERATOR_BEGINS_WITH_IGNORE_CASE = 131081,   // ordinal: 0x12
  DEVPROP_OPERATOR_ENDS_WITH_IGNORE_CASE = 131082,     // ordinal: 0x13
  DEVPROP_OPERATOR_CONTAINS_IGNORE_CASE = 131083,      // ordinal: 0x14
  DEVPROP_OPERATOR_LIST_CONTAINS = 4096,               // ordinal: 0x15
  DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH = 8192,    // ordinal: 0x16
  DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH = 12288,     // ordinal: 0x17
  DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS = 16384,      // ordinal: 0x18
  DEVPROP_OPERATOR_LIST_CONTAINS_IGNORE_CASE = 135168, // ordinal: 0x19
  DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE =
      139264,                                                   // ordinal: 0x1a
  DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH_IGNORE_CASE = 143360, // ordinal: 0x1b
  DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS_IGNORE_CASE = 147456,  // ordinal: 0x1c
  DEVPROP_OPERATOR_AND_OPEN = 1048576,                          // ordinal: 0x1d
  DEVPROP_OPERATOR_AND_CLOSE = 2097152,                         // ordinal: 0x1e
  DEVPROP_OPERATOR_OR_OPEN = 3145728,                           // ordinal: 0x1f
  DEVPROP_OPERATOR_OR_CLOSE = 4194304,                          // ordinal: 0x20
  DEVPROP_OPERATOR_NOT_OPEN = 5242880,                          // ordinal: 0x21
  DEVPROP_OPERATOR_NOT_CLOSE = 6291456,                         // ordinal: 0x22
  DEVPROP_OPERATOR_ARRAY_CONTAINS = 268435456,                  // ordinal: 0x23
  DEVPROP_OPERATOR_MASK_EVAL = 4095,                            // ordinal: 0x24
  DEVPROP_OPERATOR_MASK_LIST = 61440,                           // ordinal: 0x25
  DEVPROP_OPERATOR_MASK_MODIFIER = 983040,                      // ordinal: 0x26
  DEVPROP_OPERATOR_MASK_NOT_LOGICAL = -267386881,               // ordinal: 0x27
  DEVPROP_OPERATOR_MASK_LOGICAL = 267386880,                    // ordinal: 0x28
  DEVPROP_OPERATOR_MASK_ARRAY = -268435456,                     // ordinal: 0x29
} _DEVPROP_OPERATOR;

typedef enum _RTL_FEATURE_ENABLED_STATE_OPTIONS {
  FeatureEnabledStateOptionsNone = 0,       // ordinal: 0x0
  FeatureEnabledStateOptionsWexpConfig = 1, // ordinal: 0x1
} _RTL_FEATURE_ENABLED_STATE_OPTIONS;

typedef enum _EX_HEAP_TYPE {
  ExHeapTypeNonPagedMin = 0, // ordinal: 0x0
  ExHeapTypeNonPaged = 0,    // ordinal: 0x1
  ExHeapTypeNonPagedMax = 1, // ordinal: 0x2
  ExHeapTypeNonPagedNx = 1,  // ordinal: 0x3
  ExHeapTypePagedMin = 2,    // ordinal: 0x4
  ExHeapTypePaged = 2,       // ordinal: 0x5
  ExHeapTypePagedMax = 3,    // ordinal: 0x6
  ExHeapTypeMmSt = 3,        // ordinal: 0x7
  ExHeapTypeMax = 4,         // ordinal: 0x8
  ExHeapTypeSpecialMax = 4,  // ordinal: 0x9
} _EX_HEAP_TYPE;

typedef enum FEATURE_CHANGE_TIME {
  FEATURE_CHANGE_TIME_READ = 0,          // ordinal: 0x0
  FEATURE_CHANGE_TIME_MODULE_RELOAD = 1, // ordinal: 0x1
  FEATURE_CHANGE_TIME_SESSION = 2,       // ordinal: 0x2
  FEATURE_CHANGE_TIME_REBOOT = 3,        // ordinal: 0x3
  FEATURE_CHANGE_TIME_USER_FLAG = 128,   // ordinal: 0x4
} FEATURE_CHANGE_TIME;

typedef enum _POP_DIRECTED_DRIPS_PROBLEM_DEVICE_REASON {
  DirectedDripsProblemDeviceReasonSpecialDevice = 0,      // ordinal: 0x0
  DirectedDripsProblemDeviceReasonNoDfx = 1,              // ordinal: 0x1
  DirectedDripsProblemDeviceReasonNoPs4 = 2,              // ordinal: 0x2
  DirectedDripsProblemDeviceReasonNoPs4Root = 3,          // ordinal: 0x3
  DirectedDripsProblemDeviceReasonComponentContraint = 4, // ordinal: 0x4
  DirectedDripsProblemDeviceReasonDfxFailure = 5,         // ordinal: 0x5
  DirectedDripsProblemDeviceReasonPagingDevice = 6,       // ordinal: 0x6
  DirectedDripsProblemDeviceReasonDebuggingDevice = 7,    // ordinal: 0x7
  DirectedDripsProblemDeviceReasonDfxNotAllowed = 8,      // ordinal: 0x8
  DirectedDripsProblemDeviceReasonDfxOptOut = 9,          // ordinal: 0x9
  DirectedDripsProblemDeviceReasonMax = 10,               // ordinal: 0xa
} _POP_DIRECTED_DRIPS_PROBLEM_DEVICE_REASON;

typedef enum _PROCESS_SECTION_TYPE {
  ProcessSectionData = 0,           // ordinal: 0x0
  ProcessSectionImage = 1,          // ordinal: 0x1
  ProcessSectionImageNx = 2,        // ordinal: 0x2
  ProcessSectionPagefileBacked = 3, // ordinal: 0x3
  ProcessSectionMax = 4,            // ordinal: 0x4
} _PROCESS_SECTION_TYPE;

typedef enum _FILE_OBJECT_EXTENSION_TYPE {
  FoExtTypeTransactionParams = 0,   // ordinal: 0x0
  FoExtTypeInternal = 1,            // ordinal: 0x1
  FoExtTypeIosbRange = 2,           // ordinal: 0x2
  FoExtTypeGeneric = 3,             // ordinal: 0x3
  FoExtTypeSfio = 4,                // ordinal: 0x4
  FoExtTypeSymlink = 5,             // ordinal: 0x5
  FoExtTypeOplockKey = 6,           // ordinal: 0x6
  FoExtTypeSilo = 7,                // ordinal: 0x7
  FoExtTypeMemoryPartitionInfo = 8, // ordinal: 0x8
  FoExtTypeShadowFile = 9,          // ordinal: 0x9
  MaxFoExtTypes = 10,               // ordinal: 0xa
} _FILE_OBJECT_EXTENSION_TYPE;

typedef enum _KE_WAKE_SOURCE_TYPE {
  KeWakeSourceTypeSpuriousWake = 0,      // ordinal: 0x0
  KeWakeSourceTypeSpuriousClock = 1,     // ordinal: 0x1
  KeWakeSourceTypeSpuriousInterrupt = 2, // ordinal: 0x2
  KeWakeSourceTypeQueryFailure = 3,      // ordinal: 0x3
  KeWakeSourceTypeAccountingFailure = 4, // ordinal: 0x4
  KeWakeSourceTypeNonIrTimer = 5,        // ordinal: 0x5
  KeWakeSourceTypeDebugPoll = 6,         // ordinal: 0x6
  KeWakeSourceTypeClockWatchdog = 7,     // ordinal: 0x7
  KeWakeSourceTypeClockInternal = 8,     // ordinal: 0x8
  KeWakeSourceTypeClockNotOwner = 9,     // ordinal: 0x9
  KeWakeSourceTypeClockNotArmed = 10,    // ordinal: 0xa
  KeWakeSourceTypeExTimer = 11,          // ordinal: 0xb
  KeWakeSourceTypeStaticSourceMax = 11,  // ordinal: 0xc
  KeWakeSourceTypeInterrupt = 128,       // ordinal: 0xd
  KeWakeSourceTypeIRTimer = 129,         // ordinal: 0xe
  KeWakeSourceTypeMax = 130,             // ordinal: 0xf
} _KE_WAKE_SOURCE_TYPE;

typedef enum _OBJECT_INFORMATION_CLASS {
  ObjectBasicInformation = 0,         // ordinal: 0x0
  ObjectNameInformation = 1,          // ordinal: 0x1
  ObjectTypeInformation = 2,          // ordinal: 0x2
  ObjectTypesInformation = 3,         // ordinal: 0x3
  ObjectHandleFlagInformation = 4,    // ordinal: 0x4
  ObjectSessionInformation = 5,       // ordinal: 0x5
  ObjectSessionObjectInformation = 6, // ordinal: 0x6
  MaxObjectInfoClass = 7,             // ordinal: 0x7
} _OBJECT_INFORMATION_CLASS;

typedef enum _JOBOBJECTINFOCLASS {
  JobObjectBasicAccountingInformation = 1,         // ordinal: 0x0
  JobObjectBasicLimitInformation = 2,              // ordinal: 0x1
  JobObjectBasicProcessIdList = 3,                 // ordinal: 0x2
  JobObjectBasicUIRestrictions = 4,                // ordinal: 0x3
  JobObjectSecurityLimitInformation = 5,           // ordinal: 0x4
  JobObjectEndOfJobTimeInformation = 6,            // ordinal: 0x5
  JobObjectAssociateCompletionPortInformation = 7, // ordinal: 0x6
  JobObjectBasicAndIoAccountingInformation = 8,    // ordinal: 0x7
  JobObjectExtendedLimitInformation = 9,           // ordinal: 0x8
  JobObjectJobSetInformation = 10,                 // ordinal: 0x9
  JobObjectGroupInformation = 11,                  // ordinal: 0xa
  JobObjectNotificationLimitInformation = 12,      // ordinal: 0xb
  JobObjectLimitViolationInformation = 13,         // ordinal: 0xc
  JobObjectGroupInformationEx = 14,                // ordinal: 0xd
  JobObjectCpuRateControlInformation = 15,         // ordinal: 0xe
  JobObjectCompletionFilter = 16,                  // ordinal: 0xf
  JobObjectCompletionCounter = 17,                 // ordinal: 0x10
  JobObjectFreezeInformation = 18,                 // ordinal: 0x11
  JobObjectExtendedAccountingInformation = 19,     // ordinal: 0x12
  JobObjectWakeInformation = 20,                   // ordinal: 0x13
  JobObjectBackgroundInformation = 21,             // ordinal: 0x14
  JobObjectSchedulingRankBiasInformation = 22,     // ordinal: 0x15
  JobObjectTimerVirtualizationInformation = 23,    // ordinal: 0x16
  JobObjectCycleTimeNotification = 24,             // ordinal: 0x17
  JobObjectClearEvent = 25,                        // ordinal: 0x18
  JobObjectInterferenceInformation = 26,           // ordinal: 0x19
  JobObjectClearPeakJobMemoryUsed = 27,            // ordinal: 0x1a
  JobObjectMemoryUsageInformation = 28,            // ordinal: 0x1b
  JobObjectSharedCommit = 29,                      // ordinal: 0x1c
  JobObjectContainerId = 30,                       // ordinal: 0x1d
  JobObjectIoRateControlInformation = 31,          // ordinal: 0x1e
  JobObjectSiloRootDirectory = 37,                 // ordinal: 0x1f
  JobObjectServerSiloBasicInformation = 38,        // ordinal: 0x20
  JobObjectServerSiloUserSharedData = 39,          // ordinal: 0x21
  JobObjectServerSiloInitialize = 40,              // ordinal: 0x22
  JobObjectServerSiloRunningState = 41,            // ordinal: 0x23
  JobObjectIoAttribution = 42,                     // ordinal: 0x24
  JobObjectMemoryPartitionInformation = 43,        // ordinal: 0x25
  JobObjectContainerTelemetryId = 44,              // ordinal: 0x26
  JobObjectSiloSystemRoot = 45,                    // ordinal: 0x27
  JobObjectEnergyTrackingState = 46,               // ordinal: 0x28
  JobObjectThreadImpersonationInformation = 47,    // ordinal: 0x29
  JobObjectIoPriorityLimit = 48,                   // ordinal: 0x2a
  JobObjectPagePriorityLimit = 49,                 // ordinal: 0x2b
  JobObjectReserved1Information = 18,              // ordinal: 0x2c
  JobObjectReserved2Information = 19,              // ordinal: 0x2d
  JobObjectReserved3Information = 20,              // ordinal: 0x2e
  JobObjectReserved4Information = 21,              // ordinal: 0x2f
  JobObjectReserved5Information = 22,              // ordinal: 0x30
  JobObjectReserved6Information = 23,              // ordinal: 0x31
  JobObjectReserved7Information = 24,              // ordinal: 0x32
  JobObjectReserved8Information = 25,              // ordinal: 0x33
  JobObjectReserved9Information = 26,              // ordinal: 0x34
  JobObjectReserved10Information = 27,             // ordinal: 0x35
  JobObjectReserved11Information = 28,             // ordinal: 0x36
  JobObjectReserved12Information = 29,             // ordinal: 0x37
  JobObjectReserved13Information = 30,             // ordinal: 0x38
  JobObjectReserved14Information = 31,             // ordinal: 0x39
  JobObjectNetRateControlInformation = 32,         // ordinal: 0x3a
  JobObjectNotificationLimitInformation2 = 33,     // ordinal: 0x3b
  JobObjectLimitViolationInformation2 = 34,        // ordinal: 0x3c
  JobObjectCreateSilo = 35,                        // ordinal: 0x3d
  JobObjectSiloBasicInformation = 36,              // ordinal: 0x3e
  JobObjectReserved15Information = 37,             // ordinal: 0x3f
  JobObjectReserved16Information = 38,             // ordinal: 0x40
  JobObjectReserved17Information = 39,             // ordinal: 0x41
  JobObjectReserved18Information = 40,             // ordinal: 0x42
  JobObjectReserved19Information = 41,             // ordinal: 0x43
  JobObjectReserved20Information = 42,             // ordinal: 0x44
  JobObjectReserved21Information = 43,             // ordinal: 0x45
  JobObjectReserved22Information = 44,             // ordinal: 0x46
  JobObjectReserved23Information = 45,             // ordinal: 0x47
  JobObjectReserved24Information = 46,             // ordinal: 0x48
  JobObjectReserved25Information = 47,             // ordinal: 0x49
  JobObjectReserved26Information = 48,             // ordinal: 0x4a
  JobObjectReserved27Information = 49,             // ordinal: 0x4b
  MaxJobObjectInfoClass = 50,                      // ordinal: 0x4c
} _JOBOBJECTINFOCLASS;

typedef enum _IO_RATE_CONTROL_TYPE {
  IoRateControlTypeCapMin = 0,                         // ordinal: 0x0
  IoRateControlTypeIopsCap = 0,                        // ordinal: 0x1
  IoRateControlTypeBandwidthCap = 1,                   // ordinal: 0x2
  IoRateControlTypeTimePercentCap = 2,                 // ordinal: 0x3
  IoRateControlTypeCapMax = 2,                         // ordinal: 0x4
  IoRateControlTypeReservationMin = 3,                 // ordinal: 0x5
  IoRateControlTypeIopsReservation = 3,                // ordinal: 0x6
  IoRateControlTypeBandwidthReservation = 4,           // ordinal: 0x7
  IoRateControlTypeTimePercentReservation = 5,         // ordinal: 0x8
  IoRateControlTypeReservationMax = 5,                 // ordinal: 0x9
  IoRateControlTypeCriticalReservationMin = 6,         // ordinal: 0xa
  IoRateControlTypeIopsCriticalReservation = 6,        // ordinal: 0xb
  IoRateControlTypeBandwidthCriticalReservation = 7,   // ordinal: 0xc
  IoRateControlTypeTimePercentCriticalReservation = 8, // ordinal: 0xd
  IoRateControlTypeCriticalReservationMax = 8,         // ordinal: 0xe
  IoRateControlTypeSoftCapMin = 9,                     // ordinal: 0xf
  IoRateControlTypeIopsSoftCap = 9,                    // ordinal: 0x10
  IoRateControlTypeBandwidthSoftCap = 10,              // ordinal: 0x11
  IoRateControlTypeTimePercentSoftCap = 11,            // ordinal: 0x12
  IoRateControlTypeSoftCapMax = 11,                    // ordinal: 0x13
  IoRateControlTypeLimitExcessNotifyMin = 12,          // ordinal: 0x14
  IoRateControlTypeIopsLimitExcessNotify = 12,         // ordinal: 0x15
  IoRateControlTypeBandwidthLimitExcessNotify = 13,    // ordinal: 0x16
  IoRateControlTypeTimePercentLimitExcessNotify = 14,  // ordinal: 0x17
  IoRateControlTypeLimitExcessNotifyMax = 14,          // ordinal: 0x18
  IoRateControlTypeMax = 15,                           // ordinal: 0x19
} _IO_RATE_CONTROL_TYPE;

typedef enum _WNF_STATE_NAME_LIFETIME {
  WnfWellKnownStateName = 0,  // ordinal: 0x0
  WnfPermanentStateName = 1,  // ordinal: 0x1
  WnfPersistentStateName = 2, // ordinal: 0x2
  WnfTemporaryStateName = 3,  // ordinal: 0x3
} _WNF_STATE_NAME_LIFETIME;

typedef enum _TRANSFER_TYPE {
  ReadTransfer = 0,  // ordinal: 0x0
  WriteTransfer = 1, // ordinal: 0x1
  OtherTransfer = 2, // ordinal: 0x2
} _TRANSFER_TYPE;

typedef enum _LOCK_OPERATION {
  IoReadAccess = 0,   // ordinal: 0x0
  IoWriteAccess = 1,  // ordinal: 0x1
  IoModifyAccess = 2, // ordinal: 0x2
} _LOCK_OPERATION;

typedef enum EmptyCVariant_FeatureStaging_IoManager {
  CVariant_FeatureStaging_IoManager_Empty = 0, // ordinal: 0x0
} EmptyCVariant_FeatureStaging_IoManager;

typedef enum _KWAIT_REASON {
  Executive = 0,          // ordinal: 0x0
  FreePage = 1,           // ordinal: 0x1
  PageIn = 2,             // ordinal: 0x2
  PoolAllocation = 3,     // ordinal: 0x3
  DelayExecution = 4,     // ordinal: 0x4
  Suspended = 5,          // ordinal: 0x5
  UserRequest = 6,        // ordinal: 0x6
  WrExecutive = 7,        // ordinal: 0x7
  WrFreePage = 8,         // ordinal: 0x8
  WrPageIn = 9,           // ordinal: 0x9
  WrPoolAllocation = 10,  // ordinal: 0xa
  WrDelayExecution = 11,  // ordinal: 0xb
  WrSuspended = 12,       // ordinal: 0xc
  WrUserRequest = 13,     // ordinal: 0xd
  WrSpare0 = 14,          // ordinal: 0xe
  WrQueue = 15,           // ordinal: 0xf
  WrLpcReceive = 16,      // ordinal: 0x10
  WrLpcReply = 17,        // ordinal: 0x11
  WrVirtualMemory = 18,   // ordinal: 0x12
  WrPageOut = 19,         // ordinal: 0x13
  WrRendezvous = 20,      // ordinal: 0x14
  WrKeyedEvent = 21,      // ordinal: 0x15
  WrTerminated = 22,      // ordinal: 0x16
  WrProcessInSwap = 23,   // ordinal: 0x17
  WrCpuRateControl = 24,  // ordinal: 0x18
  WrCalloutStack = 25,    // ordinal: 0x19
  WrKernel = 26,          // ordinal: 0x1a
  WrResource = 27,        // ordinal: 0x1b
  WrPushLock = 28,        // ordinal: 0x1c
  WrMutex = 29,           // ordinal: 0x1d
  WrQuantumEnd = 30,      // ordinal: 0x1e
  WrDispatchInt = 31,     // ordinal: 0x1f
  WrPreempted = 32,       // ordinal: 0x20
  WrYieldExecution = 33,  // ordinal: 0x21
  WrFastMutex = 34,       // ordinal: 0x22
  WrGuardedMutex = 35,    // ordinal: 0x23
  WrRundown = 36,         // ordinal: 0x24
  WrAlertByThreadId = 37, // ordinal: 0x25
  WrDeferredPreempt = 38, // ordinal: 0x26
  WrPhysicalFault = 39,   // ordinal: 0x27
  WrIoRing = 40,          // ordinal: 0x28
  WrMdlCache = 41,        // ordinal: 0x29
  MaximumWaitReason = 42, // ordinal: 0x2a
} _KWAIT_REASON;

typedef enum _RTLP_HP_MEMORY_TYPE {
  HeapMemoryPaged = 0,      // ordinal: 0x0
  HeapMemoryNonPaged = 1,   // ordinal: 0x1
  HeapMemory64KPage = 2,    // ordinal: 0x2
  HeapMemoryLargePage = 3,  // ordinal: 0x3
  HeapMemoryHugePage = 4,   // ordinal: 0x4
  HeapMemoryTypeCustom = 5, // ordinal: 0x5
  HeapMemoryTypeMax = 6,    // ordinal: 0x6
} _RTLP_HP_MEMORY_TYPE;

typedef enum _RTLP_HP_ALLOCATOR {
  RtlpHpSegmentSm = 0,     // ordinal: 0x0
  RtlpHpSegmentLg = 1,     // ordinal: 0x1
  RtlpHpSegmentTypes = 2,  // ordinal: 0x2
  RtlpHpHugeAllocator = 2, // ordinal: 0x3
  RtlpHpAllocatorMax = 3,  // ordinal: 0x4
} _RTLP_HP_ALLOCATOR;

typedef enum _HEAP_SEG_RANGE_TYPE {
  HeapSegRangeUser = 0,     // ordinal: 0x0
  HeapSegRangeInternal = 1, // ordinal: 0x1
  HeapSegRangeLFH = 2,      // ordinal: 0x2
  HeapSegRangeVS = 3,       // ordinal: 0x3
  HeapSegRangeTypeMax = 3,  // ordinal: 0x4
} _HEAP_SEG_RANGE_TYPE;

typedef enum _HEAP_LFH_LOCKMODE {
  HeapLockNotHeld = 0,   // ordinal: 0x0
  HeapLockShared = 1,    // ordinal: 0x1
  HeapLockExclusive = 2, // ordinal: 0x2
} _HEAP_LFH_LOCKMODE;

typedef enum RTLP_CSPARSE_BITMAP_STATE {
  CommitBitmapInvalid = 0, // ordinal: 0x0
  UserBitmapInvalid = 1,   // ordinal: 0x1
  UserBitmapValid = 2,     // ordinal: 0x2
} RTLP_CSPARSE_BITMAP_STATE;

typedef enum EmptyCVariant_FeatureStaging_Updated_MSRC_GlobalSettings {
  CVariant_FeatureStaging_Updated_MSRC_GlobalSettings_Empty = 0, // ordinal: 0x0
} EmptyCVariant_FeatureStaging_Updated_MSRC_GlobalSettings;

typedef enum EmptyCVariant_FeatureStaging_kernelcachemanager {
  CVariant_FeatureStaging_kernelcachemanager_Empty = 0, // ordinal: 0x0
} EmptyCVariant_FeatureStaging_kernelcachemanager;

typedef enum _POWER_REQUEST_TYPE_INTERNAL {
  PowerRequestDisplayRequiredInternal = 0,   // ordinal: 0x0
  PowerRequestSystemRequiredInternal = 1,    // ordinal: 0x1
  PowerRequestAwayModeRequiredInternal = 2,  // ordinal: 0x2
  PowerRequestExecutionRequiredInternal = 3, // ordinal: 0x3
  PowerRequestPerfBoostRequiredInternal = 4, // ordinal: 0x4
  PowerRequestActiveLockScreenInternal = 5,  // ordinal: 0x5
  PowerRequestInternalInvalid = 6,           // ordinal: 0x6
} _POWER_REQUEST_TYPE_INTERNAL;

typedef enum _POWER_REQUEST_TYPE {
  PowerRequestDisplayRequired = 0,   // ordinal: 0x0
  PowerRequestSystemRequired = 1,    // ordinal: 0x1
  PowerRequestAwayModeRequired = 2,  // ordinal: 0x2
  PowerRequestExecutionRequired = 3, // ordinal: 0x3
} _POWER_REQUEST_TYPE;

typedef enum _CMP_FAILURE_INJECTION_POINT {
  CmpFailurePointPoolAllocation = 0,                    // ordinal: 0x0
  CmpFailurePointFileWrite = 1,                         // ordinal: 0x1
  CmpFailurePointFileRead = 2,                          // ordinal: 0x2
  CmpFailurePointFlush = 3,                             // ordinal: 0x3
  CmpFailurePointFlushAndPurge = 4,                     // ordinal: 0x4
  CmpFailurePointForceLargeBin = 5,                     // ordinal: 0x5
  CmpFailurePointDontFixAlignment = 6,                  // ordinal: 0x6
  CmpFailurePointAllocateCell = 7,                      // ordinal: 0x7
  CmpFailurePointMarkDirty = 8,                         // ordinal: 0x8
  CmpFailurePointForceMultiLevelMap = 9,                // ordinal: 0x9
  CmpFailurePointAllocateContiguousLogEntry = 10,       // ordinal: 0xa
  CmpFailurePointAllocateKcb = 11,                      // ordinal: 0xb
  CmpFailurePointCreateKeyBody = 12,                    // ordinal: 0xc
  CmpFailurePointForceFreeKcb = 13,                     // ordinal: 0xd
  CmpFailurePointKcbLockUpgrade = 14,                   // ordinal: 0xe
  CmpFailurePointKcbLockUpgradeDelay = 15,              // ordinal: 0xf
  CmpFailurePointKeyEnumResumeContextVerification = 16, // ordinal: 0x10
  CmpFailurePointKeyEnumForceRetry = 17,                // ordinal: 0x11
  CmpFailurePointForceReorganization = 18,              // ordinal: 0x12
  CmpFailurePointForceLazyCOWByPolicy = 19,             // ordinal: 0x13
  CmpFailurePointForceBugcheckRecoveryEnabled = 20,     // ordinal: 0x14
  CmpFailurePointCreateHiveCacheEntry = 21,             // ordinal: 0x15
  CmpFailurePointClaimHiveCacheEntry = 22,              // ordinal: 0x16
  CmpFailurePointSubscribePnpNotifications = 23,        // ordinal: 0x17
  CmpFailurePointCreateOplockMonitoringThread = 24,     // ordinal: 0x18
  CmpFailurePointOpenHiveFile = 25,                     // ordinal: 0x19
  CmpFailurePointRequestOplockOnPrimary = 26,           // ordinal: 0x1a
  CmpFailurePointRequestOplockOnLog1 = 27,              // ordinal: 0x1b
  CmpFailurePointRequestOplockOnLog2 = 28,              // ordinal: 0x1c
  CmpFailurePointCreateHive = 29,                       // ordinal: 0x1d
  CmpFailureInjectionPointCount = 30,                   // ordinal: 0x1e
} _CMP_FAILURE_INJECTION_POINT;

typedef enum _CMP_COPY_TYPE {
  Copy = 0,  // ordinal: 0x0
  Sync = 1,  // ordinal: 0x1
  Merge = 2, // ordinal: 0x2
} _CMP_COPY_TYPE;

typedef enum EmptyCVariant_FeatureStaging_Boot {
  CVariant_FeatureStaging_Boot_Empty = 0, // ordinal: 0x0
} EmptyCVariant_FeatureStaging_Boot;

typedef enum EmptyCVariant_FeatureStaging_MemoryManager {
  CVariant_FeatureStaging_MemoryManager_Empty = 0, // ordinal: 0x0
} EmptyCVariant_FeatureStaging_MemoryManager;

typedef enum EmptyCVariant_FeatureStaging_xfg {
  CVariant_FeatureStaging_xfg_Empty = 0, // ordinal: 0x0
} EmptyCVariant_FeatureStaging_xfg;

typedef enum EmptyCVariant_FeatureStaging_Poncherello {
  CVariant_FeatureStaging_Poncherello_Empty = 0, // ordinal: 0x0
} EmptyCVariant_FeatureStaging_Poncherello;

typedef enum wil_UsageReportingMode {
  wil_UsageReportingMode_Default = 0,           // ordinal: 0x0
  wil_UsageReportingMode_SuppressPotential = 1, // ordinal: 0x1
  wil_UsageReportingMode_SuppressImplicit = 2,  // ordinal: 0x2
} wil_UsageReportingMode;

typedef enum _RTL_FEATURE_CONFIGURATION_TYPE {
  RtlFeatureConfigurationBoot = 0,    // ordinal: 0x0
  RtlFeatureConfigurationRuntime = 1, // ordinal: 0x1
  RtlFeatureConfigurationCount = 2,   // ordinal: 0x2
} _RTL_FEATURE_CONFIGURATION_TYPE;

typedef enum wil_FeatureChangeTime {
  wil_FeatureChangeTime_OnRead = 0,    // ordinal: 0x0
  wil_FeatureChangeTime_OnReload = 1,  // ordinal: 0x1
  wil_FeatureChangeTime_OnSession = 2, // ordinal: 0x2
  wil_FeatureChangeTime_OnReboot = 3,  // ordinal: 0x3
} wil_FeatureChangeTime;

typedef enum wil_FeatureStore {
  wil_FeatureStore_Machine = 0, // ordinal: 0x0
  wil_FeatureStore_User = 1,    // ordinal: 0x1
  wil_FeatureStore_All = 2,     // ordinal: 0x2
} wil_FeatureStore;

typedef enum wil_VariantReportingKind {
  wil_VariantReportingKind_None = 0,        // ordinal: 0x0
  wil_VariantReportingKind_UniqueUsage = 1, // ordinal: 0x1
  wil_VariantReportingKind_DeviceUsage = 2, // ordinal: 0x2
} wil_VariantReportingKind;

typedef enum wil_ReportingKind {
  wil_ReportingKind_None = 0,              // ordinal: 0x0
  wil_ReportingKind_UniqueUsage = 1,       // ordinal: 0x1
  wil_ReportingKind_UniqueOpportunity = 2, // ordinal: 0x2
  wil_ReportingKind_DeviceUsage = 3,       // ordinal: 0x3
  wil_ReportingKind_DeviceOpportunity = 4, // ordinal: 0x4
  wil_ReportingKind_TotalDuration = 5,     // ordinal: 0x5
  wil_ReportingKind_PausedDuration = 6,    // ordinal: 0x6
} wil_ReportingKind;

typedef enum wil_details_ServiceReportingKind {
  wil_details_ServiceReportingKind_UniqueUsage = 0,          // ordinal: 0x0
  wil_details_ServiceReportingKind_UniqueOpportunity = 1,    // ordinal: 0x1
  wil_details_ServiceReportingKind_DeviceUsage = 2,          // ordinal: 0x2
  wil_details_ServiceReportingKind_DeviceOpportunity = 3,    // ordinal: 0x3
  wil_details_ServiceReportingKind_PotentialUniqueUsage = 4, // ordinal: 0x4
  wil_details_ServiceReportingKind_PotentialUniqueOpportunity =
      5,                                                     // ordinal: 0x5
  wil_details_ServiceReportingKind_PotentialDeviceUsage = 6, // ordinal: 0x6
  wil_details_ServiceReportingKind_PotentialDeviceOpportunity =
      7,                                                        // ordinal: 0x7
  wil_details_ServiceReportingKind_EnabledTotalDuration = 8,    // ordinal: 0x8
  wil_details_ServiceReportingKind_EnabledPausedDuration = 9,   // ordinal: 0x9
  wil_details_ServiceReportingKind_DisabledTotalDuration = 10,  // ordinal: 0xa
  wil_details_ServiceReportingKind_DisabledPausedDuration = 11, // ordinal: 0xb
  wil_details_ServiceReportingKind_CustomEnabledBase = 100,     // ordinal: 0xc
  wil_details_ServiceReportingKind_CustomDisabledBase = 150,    // ordinal: 0xd
  wil_details_ServiceReportingKind_Store = 254,                 // ordinal: 0xe
  wil_details_ServiceReportingKind_None = 255,                  // ordinal: 0xf
  wil_details_ServiceReportingKind_VariantDevicePotentialBase =
      256, // ordinal: 0x10
  wil_details_ServiceReportingKind_VariantDeviceUsageBase =
      320, // ordinal: 0x11
  wil_details_ServiceReportingKind_VariantUniquePotentialBase =
      384, // ordinal: 0x12
  wil_details_ServiceReportingKind_VariantUniqueUsageBase =
      448, // ordinal: 0x13
} wil_details_ServiceReportingKind;

typedef enum EmptyCVariant_ExpiredFeature {
  CVariant_ExpiredFeature_Empty = 0, // ordinal: 0x0
} EmptyCVariant_ExpiredFeature;

typedef enum _EVENT_INFO_CLASS {
  EventProviderBinaryTrackInfo = 0,   // ordinal: 0x0
  EventProviderSetReserved1 = 1,      // ordinal: 0x1
  EventProviderSetTraits = 2,         // ordinal: 0x2
  EventProviderUseDescriptorType = 3, // ordinal: 0x3
  MaxEventInfo = 4,                   // ordinal: 0x4
} _EVENT_INFO_CLASS;

typedef enum _PF_FILE_ACCESS_TYPE {
  PfFileAccessTypeRead = 0,  // ordinal: 0x0
  PfFileAccessTypeWrite = 1, // ordinal: 0x1
  PfFileAccessTypeMax = 2,   // ordinal: 0x2
} _PF_FILE_ACCESS_TYPE;

typedef enum _EX_GEN_RANDOM_DOMAIN {
  ExGenRandomDomainKernel = 0,      // ordinal: 0x0
  ExGenRandomDomainFirst = 0,       // ordinal: 0x1
  ExGenRandomDomainUserVisible = 1, // ordinal: 0x2
  ExGenRandomDomainMax = 2,         // ordinal: 0x3
} _EX_GEN_RANDOM_DOMAIN;

typedef enum _PP_NPAGED_LOOKASIDE_NUMBER {
  LookasideSmallIrpList = 0,      // ordinal: 0x0
  LookasideMediumIrpList = 1,     // ordinal: 0x1
  LookasideLargeIrpList = 2,      // ordinal: 0x2
  LookasideMdlList = 3,           // ordinal: 0x3
  LookasideCreateInfoList = 4,    // ordinal: 0x4
  LookasideNameBufferList = 5,    // ordinal: 0x5
  LookasideTwilightList = 6,      // ordinal: 0x6
  LookasideCompletionList = 7,    // ordinal: 0x7
  LookasideScratchBufferList = 8, // ordinal: 0x8
  LookasideMaximumList = 9,       // ordinal: 0x9
} _PP_NPAGED_LOOKASIDE_NUMBER;

typedef enum _PS_MITIGATION_OPTION {
  PS_MITIGATION_OPTION_NX = 0,                               // ordinal: 0x0
  PS_MITIGATION_OPTION_SEHOP = 1,                            // ordinal: 0x1
  PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES = 2,            // ordinal: 0x2
  PS_MITIGATION_OPTION_HEAP_TERMINATE = 3,                   // ordinal: 0x3
  PS_MITIGATION_OPTION_BOTTOM_UP_ASLR = 4,                   // ordinal: 0x4
  PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR = 5,                // ordinal: 0x5
  PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS = 6,             // ordinal: 0x6
  PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE = 7,       // ordinal: 0x7
  PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE = 8,          // ordinal: 0x8
  PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE = 9,            // ordinal: 0x9
  PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD = 10,              // ordinal: 0xa
  PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES = 11,    // ordinal: 0xb
  PS_MITIGATION_OPTION_FONT_DISABLE = 12,                    // ordinal: 0xc
  PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE = 13,            // ordinal: 0xd
  PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL = 14,         // ordinal: 0xe
  PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32 = 15,      // ordinal: 0xf
  PS_MITIGATION_OPTION_RETURN_FLOW_GUARD = 16,               // ordinal: 0x10
  PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY = 17,     // ordinal: 0x11
  PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD = 18,       // ordinal: 0x12
  PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT = 19,     // ordinal: 0x13
  PS_MITIGATION_OPTION_ROP_STACKPIVOT = 20,                  // ordinal: 0x14
  PS_MITIGATION_OPTION_ROP_CALLER_CHECK = 21,                // ordinal: 0x15
  PS_MITIGATION_OPTION_ROP_SIMEXEC = 22,                     // ordinal: 0x16
  PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER = 23,           // ordinal: 0x17
  PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS = 24,      // ordinal: 0x18
  PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION = 25, // ordinal: 0x19
  PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER = 26,           // ordinal: 0x1a
  PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION = 27,     // ordinal: 0x1b
  PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION =
      28,                                                     // ordinal: 0x1c
  PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE = 29, // ordinal: 0x1d
  PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY =
      30,                                                       // ordinal: 0x1e
  PS_MITIGATION_OPTION_CET_USER_SHADOW_STACKS = 31,             // ordinal: 0x1f
  PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION = 32, // ordinal: 0x20
  PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES = 33,             // ordinal: 0x21
  PS_MITIGATION_OPTION_XTENDED_CONTROL_FLOW_GUARD = 34,         // ordinal: 0x22
  PS_MITIGATION_OPTION_POINTER_AUTH_USER_IP = 35,               // ordinal: 0x23
  PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY = 36,  // ordinal: 0x24
  PS_MITIGATION_OPTION_REDIRECTION_TRUST = 37,                  // ordinal: 0x25
  PS_MITIGATION_OPTION_RESTRICT_CORE_SHARING = 38,              // ordinal: 0x26
} _PS_MITIGATION_OPTION;

typedef enum SE_WS_APPX_SIGNATURE_ORIGIN {
  SE_WS_APPX_SIGNATURE_ORIGIN_NOT_VALIDATED = 0, // ordinal: 0x0
  SE_WS_APPX_SIGNATURE_ORIGIN_UNKNOWN = 1,       // ordinal: 0x1
  SE_WS_APPX_SIGNATURE_ORIGIN_APPSTORE = 2,      // ordinal: 0x2
  SE_WS_APPX_SIGNATURE_ORIGIN_WINDOWS = 3,       // ordinal: 0x3
  SE_WS_APPX_SIGNATURE_ORIGIN_ENTERPRISE = 4,    // ordinal: 0x4
} SE_WS_APPX_SIGNATURE_ORIGIN;

typedef enum _HV_SUBNODE_TYPE {
  HvSubnodeAny = 0,      // ordinal: 0x0
  HvSubnodeSocket = 1,   // ordinal: 0x1
  HvSubnodeAmdNode = 2,  // ordinal: 0x2
  HvSubnodeL3 = 3,       // ordinal: 0x3
  HvSubnodeCount = 4,    // ordinal: 0x4
  HvSubnodeInvalid = -1, // ordinal: 0x5
} _HV_SUBNODE_TYPE;

typedef enum _HAL_DMA_CRASH_DUMP_REGISTER_TYPE {
  HalDmaCrashDumpRegisterSet1 = 0,   // ordinal: 0x0
  HalDmaCrashDumpRegisterSet2 = 1,   // ordinal: 0x1
  HalDmaCrashDumpRegisterSetMax = 2, // ordinal: 0x2
} _HAL_DMA_CRASH_DUMP_REGISTER_TYPE;

typedef enum _USER_ACTIVITY_PRESENCE {
  PowerUserPresent = 0,    // ordinal: 0x0
  PowerUserNotPresent = 1, // ordinal: 0x1
  PowerUserInactive = 2,   // ordinal: 0x2
  PowerUserMaximum = 3,    // ordinal: 0x3
  PowerUserInvalid = 3,    // ordinal: 0x4
} _USER_ACTIVITY_PRESENCE;

typedef enum _HAL_INIT_PHASE {
  HalInitPhaseBspProcEarly = 0,                         // ordinal: 0x0
  HalInitPhaseBspProcEarlyMmReady = 1,                  // ordinal: 0x1
  HalInitPhaseBspProcEarlyTimerReady = 2,               // ordinal: 0x2
  HalInitPhaseBspProcEarlyEnd = 3,                      // ordinal: 0x3
  HalInitPhasePnProcEarly = 4,                          // ordinal: 0x4
  HalInitPhasePnProcEarlyInterruptsReady = 5,           // ordinal: 0x5
  HalInitPhasePnProcEarlyEnd = 6,                       // ordinal: 0x6
  HalInitPhaseBspSystemEarly = 7,                       // ordinal: 0x7
  HalInitPhaseBspSystemEarlyAcpiReady = 8,              // ordinal: 0x8
  HalInitPhaseBspSystemEarlyHalExtensionsReady = 9,     // ordinal: 0x9
  HalInitPhaseBspSystemEarlyInterruptsAlmostReady = 10, // ordinal: 0xa
  HalInitPhaseBspSystemEarlyIommusReady = 11,           // ordinal: 0xb
  HalInitPhaseBspSystemEarlyInterruptsReady = 12,       // ordinal: 0xc
  HalInitPhaseBspSystemEarlyDmaReady = 12,              // ordinal: 0xd
  HalInitPhaseBspSystemEarlyProcReady = 13,             // ordinal: 0xe
  HalInitPhaseBspSystemEarlyHwPerfCntReady = 14,        // ordinal: 0xf
  HalInitPhaseBspSystemEarlyAllocationDone = 15,        // ordinal: 0x10
  HalInitPhaseBspSystemEarlyEnd = 16,                   // ordinal: 0x11
  HalInitPhaseBspSystemLate = 17,                       // ordinal: 0x12
  HalInitPhaseBspSystemLateEnd = 18,                    // ordinal: 0x13
  HalInitPhasePnSystemLate = 19,                        // ordinal: 0x14
  HalInitPhasePnSystemLateEnd = 20,                     // ordinal: 0x15
  HalInitPhaseAllProcStartComplete = 21,                // ordinal: 0x16
  HalInitPhaseAllProcStartCompleteEnd = 22,             // ordinal: 0x17
  HalInitPhaseExPhase1Ready = 23,                       // ordinal: 0x18
  HalInitPhaseExPhase1ReadyEnd = 24,                    // ordinal: 0x19
  HalInitPhaseAcpiPdoStarted = 25,                      // ordinal: 0x1a
  HalInitPhaseAcpiPdoStartedEnd = 26,                   // ordinal: 0x1b
  HalInitPhaseReportResources = 27,                     // ordinal: 0x1c
  HalInitPhaseReportResourcesEnd = 28,                  // ordinal: 0x1d
  HalInitPhaseReportCoreSystemResources = 29,           // ordinal: 0x1e
  HalInitPhaseReportCoreSystemResourcesEnd = 30,        // ordinal: 0x1f
  HalInitPhaseLateSystemActions = 31,                   // ordinal: 0x20
  HalInitPhaseLateSystemActionsTelemetryReady = 32,     // ordinal: 0x21
  HalInitPhaseLateSystemActionsEnd = 33,                // ordinal: 0x22
} _HAL_INIT_PHASE;

typedef enum _INTERLOCKED_RESULT {
  ResultNegative = 1, // ordinal: 0x0
  ResultZero = 0,     // ordinal: 0x1
  ResultPositive = 2, // ordinal: 0x2
} _INTERLOCKED_RESULT;

typedef enum _MEMORY_CACHING_TYPE_ORIG {
  MmFrameBufferCached = 2, // ordinal: 0x0
} _MEMORY_CACHING_TYPE_ORIG;

typedef enum _MODE {
  KernelMode = 0,  // ordinal: 0x0
  UserMode = 1,    // ordinal: 0x1
  MaximumMode = 2, // ordinal: 0x2
} _MODE;

typedef enum _HALP_DMA_MAP_BUFFER_TYPE {
  HalpDmaContiguousMapBuffer = 0,    // ordinal: 0x0
  HalpDmaNonContiguousMapBuffer = 1, // ordinal: 0x1
  HalpDmaMaximumMapBufferType = 2,   // ordinal: 0x2
} _HALP_DMA_MAP_BUFFER_TYPE;

typedef enum _REG_NOTIFY_CLASS {
  RegNtDeleteKey = 0,                     // ordinal: 0x0
  RegNtPreDeleteKey = 0,                  // ordinal: 0x1
  RegNtSetValueKey = 1,                   // ordinal: 0x2
  RegNtPreSetValueKey = 1,                // ordinal: 0x3
  RegNtDeleteValueKey = 2,                // ordinal: 0x4
  RegNtPreDeleteValueKey = 2,             // ordinal: 0x5
  RegNtSetInformationKey = 3,             // ordinal: 0x6
  RegNtPreSetInformationKey = 3,          // ordinal: 0x7
  RegNtRenameKey = 4,                     // ordinal: 0x8
  RegNtPreRenameKey = 4,                  // ordinal: 0x9
  RegNtEnumerateKey = 5,                  // ordinal: 0xa
  RegNtPreEnumerateKey = 5,               // ordinal: 0xb
  RegNtEnumerateValueKey = 6,             // ordinal: 0xc
  RegNtPreEnumerateValueKey = 6,          // ordinal: 0xd
  RegNtQueryKey = 7,                      // ordinal: 0xe
  RegNtPreQueryKey = 7,                   // ordinal: 0xf
  RegNtQueryValueKey = 8,                 // ordinal: 0x10
  RegNtPreQueryValueKey = 8,              // ordinal: 0x11
  RegNtQueryMultipleValueKey = 9,         // ordinal: 0x12
  RegNtPreQueryMultipleValueKey = 9,      // ordinal: 0x13
  RegNtPreCreateKey = 10,                 // ordinal: 0x14
  RegNtPostCreateKey = 11,                // ordinal: 0x15
  RegNtPreOpenKey = 12,                   // ordinal: 0x16
  RegNtPostOpenKey = 13,                  // ordinal: 0x17
  RegNtKeyHandleClose = 14,               // ordinal: 0x18
  RegNtPreKeyHandleClose = 14,            // ordinal: 0x19
  RegNtPostDeleteKey = 15,                // ordinal: 0x1a
  RegNtPostSetValueKey = 16,              // ordinal: 0x1b
  RegNtPostDeleteValueKey = 17,           // ordinal: 0x1c
  RegNtPostSetInformationKey = 18,        // ordinal: 0x1d
  RegNtPostRenameKey = 19,                // ordinal: 0x1e
  RegNtPostEnumerateKey = 20,             // ordinal: 0x1f
  RegNtPostEnumerateValueKey = 21,        // ordinal: 0x20
  RegNtPostQueryKey = 22,                 // ordinal: 0x21
  RegNtPostQueryValueKey = 23,            // ordinal: 0x22
  RegNtPostQueryMultipleValueKey = 24,    // ordinal: 0x23
  RegNtPostKeyHandleClose = 25,           // ordinal: 0x24
  RegNtPreCreateKeyEx = 26,               // ordinal: 0x25
  RegNtPostCreateKeyEx = 27,              // ordinal: 0x26
  RegNtPreOpenKeyEx = 28,                 // ordinal: 0x27
  RegNtPostOpenKeyEx = 29,                // ordinal: 0x28
  RegNtPreFlushKey = 30,                  // ordinal: 0x29
  RegNtPostFlushKey = 31,                 // ordinal: 0x2a
  RegNtPreLoadKey = 32,                   // ordinal: 0x2b
  RegNtPostLoadKey = 33,                  // ordinal: 0x2c
  RegNtPreUnLoadKey = 34,                 // ordinal: 0x2d
  RegNtPostUnLoadKey = 35,                // ordinal: 0x2e
  RegNtPreQueryKeySecurity = 36,          // ordinal: 0x2f
  RegNtPostQueryKeySecurity = 37,         // ordinal: 0x30
  RegNtPreSetKeySecurity = 38,            // ordinal: 0x31
  RegNtPostSetKeySecurity = 39,           // ordinal: 0x32
  RegNtCallbackObjectContextCleanup = 40, // ordinal: 0x33
  RegNtPreRestoreKey = 41,                // ordinal: 0x34
  RegNtPostRestoreKey = 42,               // ordinal: 0x35
  RegNtPreSaveKey = 43,                   // ordinal: 0x36
  RegNtPostSaveKey = 44,                  // ordinal: 0x37
  RegNtPreReplaceKey = 45,                // ordinal: 0x38
  RegNtPostReplaceKey = 46,               // ordinal: 0x39
  RegNtPreQueryKeyName = 47,              // ordinal: 0x3a
  RegNtPostQueryKeyName = 48,             // ordinal: 0x3b
  RegNtPreSaveMergedKey = 49,             // ordinal: 0x3c
  RegNtPostSaveMergedKey = 50,            // ordinal: 0x3d
  MaxRegNtNotifyClass = 51,               // ordinal: 0x3e
} _REG_NOTIFY_CLASS;

typedef enum _MCA_AMD_BLOCK_TYPE {
  McaAMDBlockTypeLS = 0,       // ordinal: 0x0
  McaAMDBlockTypeIF = 1,       // ordinal: 0x1
  McaAMDBlockTypeL2 = 2,       // ordinal: 0x2
  McaAMDBlockTypeDE = 3,       // ordinal: 0x3
  McaAMDBlockTypeRAZ = 4,      // ordinal: 0x4
  McaAMDBlockTypeEX = 5,       // ordinal: 0x5
  McaAMDBlockTypeFP = 6,       // ordinal: 0x6
  McaAMDBlockTypeL3 = 7,       // ordinal: 0x7
  McaAMDBlockTypeUMC = 8,      // ordinal: 0x8
  McaAMDBlockTypeSMU = 9,      // ordinal: 0x9
  McaAMDBlockTypePSP = 10,     // ordinal: 0xa
  McaAMDBlockTypePB = 11,      // ordinal: 0xb
  McaAMDBlockTypeCS = 12,      // ordinal: 0xc
  McaAMDBlockTypePIE = 13,     // ordinal: 0xd
  McaAMDBlockTypeMP5 = 14,     // ordinal: 0xe
  McaAMDBlockTypeNBIO = 15,    // ordinal: 0xf
  McaAMDBlockTypePCIe = 16,    // ordinal: 0x10
  McaAMDBlockTypeUnknown = 17, // ordinal: 0x11
} _MCA_AMD_BLOCK_TYPE;

typedef enum _DEVICE_WAKE_DEPTH {
  DeviceWakeDepthNotWakeable = 0, // ordinal: 0x0
  DeviceWakeDepthD0 = 1,          // ordinal: 0x1
  DeviceWakeDepthD1 = 2,          // ordinal: 0x2
  DeviceWakeDepthD2 = 3,          // ordinal: 0x3
  DeviceWakeDepthD3hot = 4,       // ordinal: 0x4
  DeviceWakeDepthD3cold = 5,      // ordinal: 0x5
  DeviceWakeDepthMaximum = 6,     // ordinal: 0x6
} _DEVICE_WAKE_DEPTH;

typedef enum _DEVICE_POWER_STATE {
  PowerDeviceUnspecified = 0, // ordinal: 0x0
  PowerDeviceD0 = 1,          // ordinal: 0x1
  PowerDeviceD1 = 2,          // ordinal: 0x2
  PowerDeviceD2 = 3,          // ordinal: 0x3
  PowerDeviceD3 = 4,          // ordinal: 0x4
  PowerDeviceMaximum = 5,     // ordinal: 0x5
} _DEVICE_POWER_STATE;

typedef enum _EVENT_TYPE {
  NotificationEvent = 0,    // ordinal: 0x0
  SynchronizationEvent = 1, // ordinal: 0x1
} _EVENT_TYPE;

typedef enum _EX_POOL_PRIORITY {
  LowPoolPriority = 0,                        // ordinal: 0x0
  LowPoolPrioritySpecialPoolOverrun = 8,      // ordinal: 0x1
  LowPoolPrioritySpecialPoolUnderrun = 9,     // ordinal: 0x2
  NormalPoolPriority = 16,                    // ordinal: 0x3
  NormalPoolPrioritySpecialPoolOverrun = 24,  // ordinal: 0x4
  NormalPoolPrioritySpecialPoolUnderrun = 25, // ordinal: 0x5
  HighPoolPriority = 32,                      // ordinal: 0x6
  HighPoolPrioritySpecialPoolOverrun = 40,    // ordinal: 0x7
  HighPoolPrioritySpecialPoolUnderrun = 41,   // ordinal: 0x8
} _EX_POOL_PRIORITY;

typedef enum _LDR_DDAG_STATE {
  LdrModulesMerged = -5,                // ordinal: 0x0
  LdrModulesInitError = -4,             // ordinal: 0x1
  LdrModulesSnapError = -3,             // ordinal: 0x2
  LdrModulesUnloaded = -2,              // ordinal: 0x3
  LdrModulesUnloading = -1,             // ordinal: 0x4
  LdrModulesPlaceHolder = 0,            // ordinal: 0x5
  LdrModulesMapping = 1,                // ordinal: 0x6
  LdrModulesMapped = 2,                 // ordinal: 0x7
  LdrModulesWaitingForDependencies = 3, // ordinal: 0x8
  LdrModulesSnapping = 4,               // ordinal: 0x9
  LdrModulesSnapped = 5,                // ordinal: 0xa
  LdrModulesCondensed = 6,              // ordinal: 0xb
  LdrModulesReadyToInit = 7,            // ordinal: 0xc
  LdrModulesInitializing = 8,           // ordinal: 0xd
  LdrModulesReadyToRun = 9,             // ordinal: 0xe
} _LDR_DDAG_STATE;

typedef enum _LDR_HOT_PATCH_STATE {
  LdrHotPatchBaseImage = 0,      // ordinal: 0x0
  LdrHotPatchNotApplied = 1,     // ordinal: 0x1
  LdrHotPatchAppliedReverse = 2, // ordinal: 0x2
  LdrHotPatchAppliedForward = 3, // ordinal: 0x3
  LdrHotPatchFailedToPatch = 4,  // ordinal: 0x4
  LdrHotPatchStateMax = 5,       // ordinal: 0x5
} _LDR_HOT_PATCH_STATE;

typedef enum _LDR_DLL_LOAD_REASON {
  LoadReasonStaticDependency = 0,           // ordinal: 0x0
  LoadReasonStaticForwarderDependency = 1,  // ordinal: 0x1
  LoadReasonDynamicForwarderDependency = 2, // ordinal: 0x2
  LoadReasonDelayloadDependency = 3,        // ordinal: 0x3
  LoadReasonDynamicLoad = 4,                // ordinal: 0x4
  LoadReasonAsImageLoad = 5,                // ordinal: 0x5
  LoadReasonAsDataLoad = 6,                 // ordinal: 0x6
  LoadReasonEnclavePrimary = 7,             // ordinal: 0x7
  LoadReasonEnclaveDependency = 8,          // ordinal: 0x8
  LoadReasonPatchImage = 9,                 // ordinal: 0x9
  LoadReasonUnknown = -1,                   // ordinal: 0xa
} _LDR_DLL_LOAD_REASON;

typedef enum _KERNEL_STACK_LIMITS {
  BugcheckStackLimits = 0,     // ordinal: 0x0
  DPCStackLimits = 1,          // ordinal: 0x1
  ExpandedStackLimits = 2,     // ordinal: 0x2
  NormalStackLimits = 3,       // ordinal: 0x3
  Win32kStackLimits = 4,       // ordinal: 0x4
  SwapBusyStackLimits = 5,     // ordinal: 0x5
  IsrStackLimits = 6,          // ordinal: 0x6
  DebuggerStackLimits = 7,     // ordinal: 0x7
  NmiStackLimits = 8,          // ordinal: 0x8
  MachineCheckStackLimits = 9, // ordinal: 0x9
  ExceptionStackLimits = 10,   // ordinal: 0xa
  MaximumStackLimits = 11,     // ordinal: 0xb
} _KERNEL_STACK_LIMITS;

typedef enum _DUMP_EVENTS {
  DUMP_EVENT_NONE = 0,             // ordinal: 0x0
  DUMP_EVENT_HIBER_RESUME = 1,     // ordinal: 0x1
  DUMP_EVENT_HIBER_RESUME_END = 2, // ordinal: 0x2
} _DUMP_EVENTS;

typedef enum _POP_IO_STATUS {
  IoReady = 0,   // ordinal: 0x0
  IoPending = 1, // ordinal: 0x1
  IoDone = 2,    // ordinal: 0x2
} _POP_IO_STATUS;

typedef enum _POP_POWER_ACTION_WATCHDOG_STATE {
  PopPowerActionWatchdogStateDisabled = 0,      // ordinal: 0x0
  PopPowerActionWatchdogStateTransitioning = 1, // ordinal: 0x1
  PopPowerActionWatchdogStateResuming = 2,      // ordinal: 0x2
  PopPowerActionWatchdogStateMax = 3,           // ordinal: 0x3
} _POP_POWER_ACTION_WATCHDOG_STATE;

typedef enum SYSTEM_POWER_CONDITION {
  PoAc = 0,               // ordinal: 0x0
  PoDc = 1,               // ordinal: 0x1
  PoHot = 2,              // ordinal: 0x2
  PoConditionMaximum = 3, // ordinal: 0x3
} SYSTEM_POWER_CONDITION;

typedef enum _REQUESTER_TYPE {
  KernelRequester = 0,            // ordinal: 0x0
  UserProcessRequester = 1,       // ordinal: 0x1
  UserSharedServiceRequester = 2, // ordinal: 0x2
} _REQUESTER_TYPE;

// 0x4 bytes (sizeof)
typedef struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ {
  LONG unused; // offset: 0x0 ordinal: 0x0
} FEATURE_STATE_CHANGE_SUBSCRIPTION__;

typedef enum _ETW_NOTIFICATION_TYPE {
  EtwNotificationTypeNoReply = 1,                // ordinal: 0x0
  EtwNotificationTypeLegacyEnable = 2,           // ordinal: 0x1
  EtwNotificationTypeEnable = 3,                 // ordinal: 0x2
  EtwNotificationTypePrivateLogger = 4,          // ordinal: 0x3
  EtwNotificationTypePerflib = 5,                // ordinal: 0x4
  EtwNotificationTypeAudio = 6,                  // ordinal: 0x5
  EtwNotificationTypeSession = 7,                // ordinal: 0x6
  EtwNotificationTypeReserved = 8,               // ordinal: 0x7
  EtwNotificationTypeCredentialUI = 9,           // ordinal: 0x8
  EtwNotificationTypeInProcSession = 10,         // ordinal: 0x9
  EtwNotificationTypeFilteredPrivateLogger = 11, // ordinal: 0xa
  EtwNotificationTypeMax = 12,                   // ordinal: 0xb
} _ETW_NOTIFICATION_TYPE;

typedef enum _EXQUEUEINDEX {
  ExPoolUntrusted = 0, // ordinal: 0x0
  IoPoolUntrusted = 1, // ordinal: 0x1
  ExPoolMax = 8,       // ordinal: 0x2
} _EXQUEUEINDEX;

typedef enum _PNP_DEVICE_IOMMU_DOMAIN_POLICY {
  IommuDomainPolicyAllowAll = 0,         // ordinal: 0x0
  IommuDomainPolicyBlockPassthrough = 1, // ordinal: 0x1
  IommuDomainPolicyMax = 2,              // ordinal: 0x2
} _PNP_DEVICE_IOMMU_DOMAIN_POLICY;

// 0x4 bytes (sizeof)
typedef struct __anon_3857 {
  enum _PNP_DEVICE_IOMMU_DOMAIN_POLICY DomainPolicy; // offset: 0x0 ordinal: 0x0
} __anon_3857;

typedef enum _PNP_DEVICE_ACTION_REQUEST {
  AssignResources = 0,                 // ordinal: 0x0
  ClearDeviceProblem = 1,              // ordinal: 0x1
  ClearProblem = 2,                    // ordinal: 0x2
  ClearEjectProblem = 3,               // ordinal: 0x3
  ReservedAction0 = 4,                 // ordinal: 0x4
  QueryPowerRelations = 5,             // ordinal: 0x5
  Rebalance = 6,                       // ordinal: 0x6
  ReenumerateBootDevices = 7,          // ordinal: 0x7
  ReenumerateDeviceOnly = 8,           // ordinal: 0x8
  ReenumerateDeviceTree = 9,           // ordinal: 0x9
  ReenumerateRootDevices = 10,         // ordinal: 0xa
  RequeryDeviceState = 11,             // ordinal: 0xb
  ResetDevice = 12,                    // ordinal: 0xc
  ResourceRequirementsChanged = 13,    // ordinal: 0xd
  RestartEnumeration = 14,             // ordinal: 0xe
  SetDeviceProblem = 15,               // ordinal: 0xf
  StartDevice = 16,                    // ordinal: 0x10
  StartSystemDevicesPass0 = 17,        // ordinal: 0x11
  StartSystemDevicesPass1 = 18,        // ordinal: 0x12
  NotifyTransportRelationsChange = 19, // ordinal: 0x13
  NotifyEjectionRelationsChange = 20,  // ordinal: 0x14
  ConfigureDevice = 21,                // ordinal: 0x15
  ConfigureDeviceClass = 22,           // ordinal: 0x16
  ConfigureDeviceExtensions = 23,      // ordinal: 0x17
  ConfigureDeviceReset = 24,           // ordinal: 0x18
  ClearDmaGuardProblem = 25,           // ordinal: 0x19
  RequestDeviceReset = 26,             // ordinal: 0x1a
  UpdateConsoleLockState = 27,         // ordinal: 0x1b
  PnpDeviceActionRequestMax = 28,      // ordinal: 0x1c
} _PNP_DEVICE_ACTION_REQUEST;

typedef enum POWER_POLICY_DEVICE_TYPE {
  PolicyDeviceSystemButton = 0,                    // ordinal: 0x0
  PolicyDeviceThermalZone = 1,                     // ordinal: 0x1
  PolicyDeviceBattery = 2,                         // ordinal: 0x2
  PolicyDeviceMemory = 3,                          // ordinal: 0x3
  PolicyInitiatePowerActionAPI = 4,                // ordinal: 0x4
  PolicySetPowerStateAPI = 5,                      // ordinal: 0x5
  PolicyImmediateDozeS4 = 6,                       // ordinal: 0x6
  PolicySystemIdle = 7,                            // ordinal: 0x7
  PolicyDeviceWakeAlarm = 8,                       // ordinal: 0x8
  PolicyDeviceFan = 9,                             // ordinal: 0x9
  PolicyCsBatterySaver = 10,                       // ordinal: 0xa
  PolicyImmediateDozeS4Predicted = 11,             // ordinal: 0xb
  PolicyImmediateDozeS4PredictedNoWake = 12,       // ordinal: 0xc
  PolicyImmediateDozeS4AdaptiveBudget = 13,        // ordinal: 0xd
  PolicyImmediateDozeS4AdaptiveReserveNoWake = 14, // ordinal: 0xe
  PolicySystemInitiatedShutdown = 15,              // ordinal: 0xf
  PolicyDeviceMax = 16,                            // ordinal: 0x10
} POWER_POLICY_DEVICE_TYPE;

typedef enum _ARBITER_RESULT {
  ArbiterResultUndefined = -1,       // ordinal: 0x0
  ArbiterResultSuccess = 0,          // ordinal: 0x1
  ArbiterResultExternalConflict = 1, // ordinal: 0x2
  ArbiterResultNullRequest = 2,      // ordinal: 0x3
} _ARBITER_RESULT;

typedef enum _ARBITER_ACTION {
  ArbiterActionTestAllocation = 0,          // ordinal: 0x0
  ArbiterActionRetestAllocation = 1,        // ordinal: 0x1
  ArbiterActionCommitAllocation = 2,        // ordinal: 0x2
  ArbiterActionRollbackAllocation = 3,      // ordinal: 0x3
  ArbiterActionQueryAllocatedResources = 4, // ordinal: 0x4
  ArbiterActionWriteReservedResources = 5,  // ordinal: 0x5
  ArbiterActionQueryConflict = 6,           // ordinal: 0x6
  ArbiterActionQueryArbitrate = 7,          // ordinal: 0x7
  ArbiterActionAddReserved = 8,             // ordinal: 0x8
  ArbiterActionBootAllocation = 9,          // ordinal: 0x9
} _ARBITER_ACTION;

typedef enum _MI_PFN_CACHE_ATTRIBUTE {
  MiNonCached = 0,     // ordinal: 0x0
  MiCached = 1,        // ordinal: 0x1
  MiWriteCombined = 2, // ordinal: 0x2
  MiNotMapped = 3,     // ordinal: 0x3
} _MI_PFN_CACHE_ATTRIBUTE;

typedef enum _MI_PAGE_HASH_ERROR_BEHAVIOR {
  MiPageHashErrorBugcheck = 0,    // ordinal: 0x0
  MiPageHashErrorReturnError = 1, // ordinal: 0x1
  MiPageHashErrorIgnore = 2,      // ordinal: 0x2
} _MI_PAGE_HASH_ERROR_BEHAVIOR;

typedef enum _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE {
  IommuDeviceCreationConfigTypeNone = 0,     // ordinal: 0x0
  IommuDeviceCreationConfigTypeAcpi = 1,     // ordinal: 0x1
  IommuDeviceCreationConfigTypeDeviceId = 2, // ordinal: 0x2
  IommuDeviceCreationConfigTypeMax = 3,      // ordinal: 0x3
} _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE;

typedef enum _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE {
  MapPhysicalAddressTypeMdl = 0,             // ordinal: 0x0
  MapPhysicalAddressTypeContiguousRange = 1, // ordinal: 0x1
  MapPhysicalAddressTypePfn = 2,             // ordinal: 0x2
  MapPhysicalAddressTypeMax = 3,             // ordinal: 0x3
} _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE;

typedef enum _BOOT_ENTROPY_SOURCE_RESULT_CODE {
  BootEntropySourceStructureUninitialized = 0, // ordinal: 0x0
  BootEntropySourceDisabledByPolicy = 1,       // ordinal: 0x1
  BootEntropySourceNotPresent = 2,             // ordinal: 0x2
  BootEntropySourceError = 3,                  // ordinal: 0x3
  BootEntropySourceSuccess = 4,                // ordinal: 0x4
} _BOOT_ENTROPY_SOURCE_RESULT_CODE;

typedef enum _BOOT_ENTROPY_SOURCE_ID {
  BootEntropySourceNone = 0,       // ordinal: 0x0
  BootEntropySourceSeedfile = 1,   // ordinal: 0x1
  BootEntropySourceExternal = 2,   // ordinal: 0x2
  BootEntropySourceTpm = 3,        // ordinal: 0x3
  BootEntropySourceRdrand = 4,     // ordinal: 0x4
  BootEntropySourceTime = 5,       // ordinal: 0x5
  BootEntropySourceAcpiOem0 = 6,   // ordinal: 0x6
  BootEntropySourceUefi = 7,       // ordinal: 0x7
  BootEntropySourceCng = 8,        // ordinal: 0x8
  BootEntropySourceTcbTpm = 9,     // ordinal: 0x9
  BootEntropySourceTcbRdrand = 10, // ordinal: 0xa
  BootMaxEntropySources = 10,      // ordinal: 0xb
} _BOOT_ENTROPY_SOURCE_ID;

typedef enum _DOMAIN_CONFIGURATION_ARCH {
  DomainConfigurationArm64 = 0,   // ordinal: 0x0
  DomainConfigurationX64 = 1,     // ordinal: 0x1
  DomainConfigurationInvalid = 2, // ordinal: 0x2
} _DOMAIN_CONFIGURATION_ARCH;

typedef enum _CONFIGURATION_TYPE {
  ArcSystem = 0,                // ordinal: 0x0
  CentralProcessor = 1,         // ordinal: 0x1
  FloatingPointProcessor = 2,   // ordinal: 0x2
  PrimaryIcache = 3,            // ordinal: 0x3
  PrimaryDcache = 4,            // ordinal: 0x4
  SecondaryIcache = 5,          // ordinal: 0x5
  SecondaryDcache = 6,          // ordinal: 0x6
  SecondaryCache = 7,           // ordinal: 0x7
  EisaAdapter = 8,              // ordinal: 0x8
  TcAdapter = 9,                // ordinal: 0x9
  ScsiAdapter = 10,             // ordinal: 0xa
  DtiAdapter = 11,              // ordinal: 0xb
  MultiFunctionAdapter = 12,    // ordinal: 0xc
  DiskController = 13,          // ordinal: 0xd
  TapeController = 14,          // ordinal: 0xe
  CdromController = 15,         // ordinal: 0xf
  WormController = 16,          // ordinal: 0x10
  SerialController = 17,        // ordinal: 0x11
  NetworkController = 18,       // ordinal: 0x12
  DisplayController = 19,       // ordinal: 0x13
  ParallelController = 20,      // ordinal: 0x14
  PointerController = 21,       // ordinal: 0x15
  KeyboardController = 22,      // ordinal: 0x16
  AudioController = 23,         // ordinal: 0x17
  OtherController = 24,         // ordinal: 0x18
  DiskPeripheral = 25,          // ordinal: 0x19
  FloppyDiskPeripheral = 26,    // ordinal: 0x1a
  TapePeripheral = 27,          // ordinal: 0x1b
  ModemPeripheral = 28,         // ordinal: 0x1c
  MonitorPeripheral = 29,       // ordinal: 0x1d
  PrinterPeripheral = 30,       // ordinal: 0x1e
  PointerPeripheral = 31,       // ordinal: 0x1f
  KeyboardPeripheral = 32,      // ordinal: 0x20
  TerminalPeripheral = 33,      // ordinal: 0x21
  OtherPeripheral = 34,         // ordinal: 0x22
  LinePeripheral = 35,          // ordinal: 0x23
  NetworkPeripheral = 36,       // ordinal: 0x24
  SystemMemory = 37,            // ordinal: 0x25
  DockingInformation = 38,      // ordinal: 0x26
  RealModeIrqRoutingTable = 39, // ordinal: 0x27
  RealModePCIEnumeration = 40,  // ordinal: 0x28
  MaximumType = 41,             // ordinal: 0x29
} _CONFIGURATION_TYPE;

typedef enum _CONFIGURATION_CLASS {
  SystemClass = 0,     // ordinal: 0x0
  ProcessorClass = 1,  // ordinal: 0x1
  CacheClass = 2,      // ordinal: 0x2
  AdapterClass = 3,    // ordinal: 0x3
  ControllerClass = 4, // ordinal: 0x4
  PeripheralClass = 5, // ordinal: 0x5
  MemoryClass = 6,     // ordinal: 0x6
  MaximumClass = 7,    // ordinal: 0x7
} _CONFIGURATION_CLASS;

typedef enum KD_CALLBACK_ACTION {
  KdConfigureDeviceAndContinue = 0, // ordinal: 0x0
  KdSkipDeviceAndContinue = 1,      // ordinal: 0x1
  KdConfigureDeviceAndStop = 2,     // ordinal: 0x2
  KdSkipDeviceAndStop = 3,          // ordinal: 0x3
} KD_CALLBACK_ACTION;

typedef enum _PCI_BUSMASTER_RID_TYPE {
  BusmasterRidInvalid = 0,             // ordinal: 0x0
  BusmasterRidFromDeviceRid = 1,       // ordinal: 0x1
  BusmasterRidFromBridgeRid = 2,       // ordinal: 0x2
  BusmasterRidFromMultipleBridges = 3, // ordinal: 0x3
} _PCI_BUSMASTER_RID_TYPE;

typedef enum KD_NAMESPACE_ENUM {
  KdNameSpacePCI = 0,  // ordinal: 0x0
  KdNameSpaceACPI = 1, // ordinal: 0x1
  KdNameSpaceAny = 2,  // ordinal: 0x2
  KdNameSpaceNone = 3, // ordinal: 0x3
  KdNameSpaceMax = 4,  // ordinal: 0x4
} KD_NAMESPACE_ENUM;

typedef enum _HAL_PROCESSOR_STAT_TYPE {
  HalProcessorStatResidency = 0, // ordinal: 0x0
  HalProcessorStatCount = 1,     // ordinal: 0x1
  HalProcessorStatMax = 2,       // ordinal: 0x2
} _HAL_PROCESSOR_STAT_TYPE;

typedef enum _HAL_CLOCK_TIMER_MODE {
  HalClockTimerModePeriodic = 0, // ordinal: 0x0
  HalClockTimerModeOneShot = 1,  // ordinal: 0x1
  HalClockTimerModeMax = 2,      // ordinal: 0x2
} _HAL_CLOCK_TIMER_MODE;

typedef enum _BUS_DATA_TYPE {
  ConfigurationSpaceUndefined = -1, // ordinal: 0x0
  Cmos = 0,                         // ordinal: 0x1
  EisaConfiguration = 1,            // ordinal: 0x2
  Pos = 2,                          // ordinal: 0x3
  CbusConfiguration = 3,            // ordinal: 0x4
  PCIConfiguration = 4,             // ordinal: 0x5
  VMEConfiguration = 5,             // ordinal: 0x6
  NuBusConfiguration = 6,           // ordinal: 0x7
  PCMCIAConfiguration = 7,          // ordinal: 0x8
  MPIConfiguration = 8,             // ordinal: 0x9
  MPSAConfiguration = 9,            // ordinal: 0xa
  PNPISAConfiguration = 10,         // ordinal: 0xb
  SgiInternalConfiguration = 11,    // ordinal: 0xc
  MaximumBusDataType = 12,          // ordinal: 0xd
} _BUS_DATA_TYPE;

typedef enum _TYPE_OF_MEMORY {
  LoaderExceptionBlock = 0,       // ordinal: 0x0
  LoaderSystemBlock = 1,          // ordinal: 0x1
  LoaderFree = 2,                 // ordinal: 0x2
  LoaderBad = 3,                  // ordinal: 0x3
  LoaderLoadedProgram = 4,        // ordinal: 0x4
  LoaderFirmwareTemporary = 5,    // ordinal: 0x5
  LoaderFirmwarePermanent = 6,    // ordinal: 0x6
  LoaderOsloaderHeap = 7,         // ordinal: 0x7
  LoaderOsloaderStack = 8,        // ordinal: 0x8
  LoaderSystemCode = 9,           // ordinal: 0x9
  LoaderHalCode = 10,             // ordinal: 0xa
  LoaderBootDriver = 11,          // ordinal: 0xb
  LoaderConsoleInDriver = 12,     // ordinal: 0xc
  LoaderConsoleOutDriver = 13,    // ordinal: 0xd
  LoaderStartupDpcStack = 14,     // ordinal: 0xe
  LoaderStartupKernelStack = 15,  // ordinal: 0xf
  LoaderStartupPanicStack = 16,   // ordinal: 0x10
  LoaderStartupPcrPage = 17,      // ordinal: 0x11
  LoaderStartupPdrPage = 18,      // ordinal: 0x12
  LoaderRegistryData = 19,        // ordinal: 0x13
  LoaderMemoryData = 20,          // ordinal: 0x14
  LoaderNlsData = 21,             // ordinal: 0x15
  LoaderSpecialMemory = 22,       // ordinal: 0x16
  LoaderBBTMemory = 23,           // ordinal: 0x17
  LoaderZero = 24,                // ordinal: 0x18
  LoaderXIPRom = 25,              // ordinal: 0x19
  LoaderHALCachedMemory = 26,     // ordinal: 0x1a
  LoaderLargePageFiller = 27,     // ordinal: 0x1b
  LoaderErrorLogMemory = 28,      // ordinal: 0x1c
  LoaderVsmMemory = 29,           // ordinal: 0x1d
  LoaderFirmwareCode = 30,        // ordinal: 0x1e
  LoaderFirmwareData = 31,        // ordinal: 0x1f
  LoaderFirmwareReserved = 32,    // ordinal: 0x20
  LoaderEnclaveMemory = 33,       // ordinal: 0x21
  LoaderFirmwareKsr = 34,         // ordinal: 0x22
  LoaderEnclaveKsr = 35,          // ordinal: 0x23
  LoaderSkMemory = 36,            // ordinal: 0x24
  LoaderSkFirmwareReserved = 37,  // ordinal: 0x25
  LoaderIoSpaceMemoryZeroed = 38, // ordinal: 0x26
  LoaderIoSpaceMemoryFree = 39,   // ordinal: 0x27
  LoaderIoSpaceMemoryKsr = 40,    // ordinal: 0x28
  LoaderKernelShadowStack = 41,   // ordinal: 0x29
  LoaderIsolatedHostVisible = 42, // ordinal: 0x2a
  LoaderIsolatedKsr = 43,         // ordinal: 0x2b
  LoaderMaximum = 44,             // ordinal: 0x2c
} _TYPE_OF_MEMORY;

typedef enum HAL_APIC_DESTINATION_MODE {
  ApicDestinationModePhysical = 1,         // ordinal: 0x0
  ApicDestinationModeLogicalFlat = 2,      // ordinal: 0x1
  ApicDestinationModeLogicalClustered = 3, // ordinal: 0x2
  ApicDestinationModeUnknown = 4,          // ordinal: 0x3
} HAL_APIC_DESTINATION_MODE;

// 0x4 bytes (sizeof)
typedef struct __anon_3078 {
  enum HAL_APIC_DESTINATION_MODE DestinationMode; // offset: 0x0 ordinal: 0x0
} __anon_3078;

typedef enum _INTERRUPT_STEERING_MODE {
  IntSteerModeNone = 0,            // ordinal: 0x0
  IntSteerModeController = 1,      // ordinal: 0x1
  IntSteerModeRedirect = 2,        // ordinal: 0x2
  IntSteerModeControllerFixed = 3, // ordinal: 0x3
} _INTERRUPT_STEERING_MODE;

typedef enum INTERRUPT_CONNECTION_TYPE {
  InterruptTypeControllerInput = 0, // ordinal: 0x0
  InterruptTypeXapicMessage = 1,    // ordinal: 0x1
  InterruptTypeHypertransport = 2,  // ordinal: 0x2
  InterruptTypeMessageRequest = 3,  // ordinal: 0x3
} INTERRUPT_CONNECTION_TYPE;

typedef enum _VI_DEADLOCK_RESOURCE_TYPE {
  VfDeadlockUnknown = 0,               // ordinal: 0x0
  VfDeadlockMutex = 1,                 // ordinal: 0x1
  VfDeadlockMutexAbandoned = 2,        // ordinal: 0x2
  VfDeadlockFastMutex = 3,             // ordinal: 0x3
  VfDeadlockFastMutexUnsafe = 4,       // ordinal: 0x4
  VfDeadlockSpinLock = 5,              // ordinal: 0x5
  VfDeadlockInStackQueuedSpinLock = 6, // ordinal: 0x6
  VfDeadlockUnusedSpinLock = 7,        // ordinal: 0x7
  VfDeadlockEresource = 8,             // ordinal: 0x8
  VfDeadlockTypeMaximum = 9,           // ordinal: 0x9
} _VI_DEADLOCK_RESOURCE_TYPE;

typedef enum _WNF_SUBSCRIPTION_STATE {
  WNF_SUB_STATE_QUIESCENT = 0,        // ordinal: 0x0
  WNF_SUB_STATE_READY_TO_DELIVER = 1, // ordinal: 0x1
  WNF_SUB_STATE_IN_DELIVERY = 2,      // ordinal: 0x2
  WNF_SUB_STATE_RETRY = 3,            // ordinal: 0x3
} _WNF_SUBSCRIPTION_STATE;

typedef enum _SEP_CACHED_HANDLES_ENTRY_TYPE {
  SepCachedHandlesEntryLowbox = 0,       // ordinal: 0x0
  SepCachedHandlesEntryBnoIsolation = 1, // ordinal: 0x1
} _SEP_CACHED_HANDLES_ENTRY_TYPE;

typedef enum _CREATE_FILE_TYPE {
  CreateFileTypeNone = 0,      // ordinal: 0x0
  CreateFileTypeNamedPipe = 1, // ordinal: 0x1
  CreateFileTypeMailslot = 2,  // ordinal: 0x2
} _CREATE_FILE_TYPE;

typedef enum _IOP_PRIORITY_HINT {
  IopIoPriorityNotSet = 0,   // ordinal: 0x0
  IopIoPriorityVeryLow = 1,  // ordinal: 0x1
  IopIoPriorityLow = 2,      // ordinal: 0x2
  IopIoPriorityNormal = 3,   // ordinal: 0x3
  IopIoPriorityHigh = 4,     // ordinal: 0x4
  IopIoPriorityCritical = 5, // ordinal: 0x5
  MaxIopIoPriorityTypes = 6, // ordinal: 0x6
} _IOP_PRIORITY_HINT;

typedef enum _SECURITY_OPERATION_CODE {
  SetSecurityDescriptor = 0,    // ordinal: 0x0
  QuerySecurityDescriptor = 1,  // ordinal: 0x1
  DeleteSecurityDescriptor = 2, // ordinal: 0x2
  AssignSecurityDescriptor = 3, // ordinal: 0x3
} _SECURITY_OPERATION_CODE;

typedef enum _OB_OPEN_REASON {
  ObCreateHandle = 0,    // ordinal: 0x0
  ObOpenHandle = 1,      // ordinal: 0x1
  ObDuplicateHandle = 2, // ordinal: 0x2
  ObInheritHandle = 3,   // ordinal: 0x3
  ObMaxOpenReason = 4,   // ordinal: 0x4
} _OB_OPEN_REASON;

typedef enum _BLOB_ID {
  BLOB_TYPE_UNKNOWN = 0,          // ordinal: 0x0
  BLOB_TYPE_CONNECTION_INFO = 1,  // ordinal: 0x1
  BLOB_TYPE_MESSAGE = 2,          // ordinal: 0x2
  BLOB_TYPE_SECURITY_CONTEXT = 3, // ordinal: 0x3
  BLOB_TYPE_SECTION = 4,          // ordinal: 0x4
  BLOB_TYPE_REGION = 5,           // ordinal: 0x5
  BLOB_TYPE_VIEW = 6,             // ordinal: 0x6
  BLOB_TYPE_RESERVE = 7,          // ordinal: 0x7
  BLOB_TYPE_DIRECT_TRANSFER = 8,  // ordinal: 0x8
  BLOB_TYPE_HANDLE_DATA = 9,      // ordinal: 0x9
  BLOB_TYPE_MAX_ID = 10,          // ordinal: 0xa
} _BLOB_ID;

typedef enum _RTLP_HP_LOCK_TYPE {
  HeapLockPaged = 0,    // ordinal: 0x0
  HeapLockNonPaged = 1, // ordinal: 0x1
  HeapLockTypeMax = 2,  // ordinal: 0x2
} _RTLP_HP_LOCK_TYPE;

typedef enum _HEAP_FAILURE_TYPE {
  heap_failure_internal = 0,                       // ordinal: 0x0
  heap_failure_unknown = 1,                        // ordinal: 0x1
  heap_failure_generic = 2,                        // ordinal: 0x2
  heap_failure_entry_corruption = 3,               // ordinal: 0x3
  heap_failure_multiple_entries_corruption = 4,    // ordinal: 0x4
  heap_failure_virtual_block_corruption = 5,       // ordinal: 0x5
  heap_failure_buffer_overrun = 6,                 // ordinal: 0x6
  heap_failure_buffer_underrun = 7,                // ordinal: 0x7
  heap_failure_block_not_busy = 8,                 // ordinal: 0x8
  heap_failure_invalid_argument = 9,               // ordinal: 0x9
  heap_failure_invalid_allocation_type = 10,       // ordinal: 0xa
  heap_failure_usage_after_free = 11,              // ordinal: 0xb
  heap_failure_cross_heap_operation = 12,          // ordinal: 0xc
  heap_failure_freelists_corruption = 13,          // ordinal: 0xd
  heap_failure_listentry_corruption = 14,          // ordinal: 0xe
  heap_failure_lfh_bitmap_mismatch = 15,           // ordinal: 0xf
  heap_failure_segment_lfh_bitmap_corruption = 16, // ordinal: 0x10
  heap_failure_segment_lfh_double_free = 17,       // ordinal: 0x11
  heap_failure_vs_subsegment_corruption = 18,      // ordinal: 0x12
  heap_failure_null_heap = 19,                     // ordinal: 0x13
  heap_failure_allocation_limit = 20,              // ordinal: 0x14
  heap_failure_commit_limit = 21,                  // ordinal: 0x15
  heap_failure_invalid_va_mgr_query = 22,          // ordinal: 0x16
} _HEAP_FAILURE_TYPE;

typedef enum _RTLP_HP_ADDRESS_SPACE_TYPE {
  HeapAddressUser = 0,    // ordinal: 0x0
  HeapAddressKernel = 1,  // ordinal: 0x1
  HeapAddressSession = 2, // ordinal: 0x2
  HeapAddressSecure = 3,  // ordinal: 0x3
  HeapAddressTypeMax = 4, // ordinal: 0x4
} _RTLP_HP_ADDRESS_SPACE_TYPE;

typedef enum _WORKER_FUNCTION {
  NoopFunction = 0,             // ordinal: 0x0
  ReadAhead = 1,                // ordinal: 0x1
  WriteBehind = 2,              // ordinal: 0x2
  LazyWriteScan = 3,            // ordinal: 0x3
  EventSet = 4,                 // ordinal: 0x4
  AsyncRead = 5,                // ordinal: 0x5
  CompleteAsyncRead = 6,        // ordinal: 0x6
  AsyncWriteBehind = 7,         // ordinal: 0x7
  CompleteAsyncWriteBehind = 8, // ordinal: 0x8
} _WORKER_FUNCTION;

typedef enum _CC_NUMA_TYPE {
  InvalidNumaNodeType = 0, // ordinal: 0x0
  PartitionNumaNode = 1,   // ordinal: 0x1
  VolumeNumaNode = 2,      // ordinal: 0x2
  MaxNumaNodeType = 3,     // ordinal: 0x3
} _CC_NUMA_TYPE;

typedef enum _CC_LWS_PACKET_TYPE {
  LWSPacket_Invalid = 0,    // ordinal: 0x0
  LWSPacket_Partition = 1,  // ordinal: 0x1
  LWSPacket_PrivateVCM = 2, // ordinal: 0x2
  LWSPacket_Max = 3,        // ordinal: 0x3
} _CC_LWS_PACKET_TYPE;

typedef enum _KHETERO_CPU_POLICY {
  KHeteroCpuPolicyAll = 0,         // ordinal: 0x0
  KHeteroCpuPolicyLarge = 1,       // ordinal: 0x1
  KHeteroCpuPolicyLargeOrIdle = 2, // ordinal: 0x2
  KHeteroCpuPolicySmall = 3,       // ordinal: 0x3
  KHeteroCpuPolicySmallOrIdle = 4, // ordinal: 0x4
  KHeteroCpuPolicyDynamic = 5,     // ordinal: 0x5
  KHeteroCpuPolicyStaticMax = 5,   // ordinal: 0x6
  KHeteroCpuPolicyBiasedSmall = 6, // ordinal: 0x7
  KHeteroCpuPolicyBiasedLarge = 7, // ordinal: 0x8
  KHeteroCpuPolicyDefault = 8,     // ordinal: 0x9
  KHeteroCpuPolicyMax = 9,         // ordinal: 0xa
} _KHETERO_CPU_POLICY;

typedef enum _GPIO_PIN_IORESTRICTION_TYPE {
  IoRestrictionNone = 0,            // ordinal: 0x0
  IoRestrictionInputOnly = 1,       // ordinal: 0x1
  IoRestrictionOutputOnly = 2,      // ordinal: 0x2
  IoRestrictionNoneAndPreserve = 3, // ordinal: 0x3
} _GPIO_PIN_IORESTRICTION_TYPE;

typedef enum _GPIO_PIN_CONFIG_TYPE {
  PullDefault = 0, // ordinal: 0x0
  PullUp = 1,      // ordinal: 0x1
  PullDown = 2,    // ordinal: 0x2
  PullNone = 3,    // ordinal: 0x3
} _GPIO_PIN_CONFIG_TYPE;

typedef enum _PEP_ACPI_RESOURCE_TYPE {
  PepAcpiMemory = 0,         // ordinal: 0x0
  PepAcpiIoPort = 1,         // ordinal: 0x1
  PepAcpiInterrupt = 2,      // ordinal: 0x2
  PepAcpiGpioIo = 3,         // ordinal: 0x3
  PepAcpiGpioInt = 4,        // ordinal: 0x4
  PepAcpiSpbI2c = 5,         // ordinal: 0x5
  PepAcpiSpbSpi = 6,         // ordinal: 0x6
  PepAcpiSpbUart = 7,        // ordinal: 0x7
  PepAcpiExtendedMemory = 8, // ordinal: 0x8
  PepAcpiExtendedIo = 9,     // ordinal: 0x9
} _PEP_ACPI_RESOURCE_TYPE;

typedef enum _ARBITER_REQUEST_SOURCE {
  ArbiterRequestUndefined = -1,     // ordinal: 0x0
  ArbiterRequestLegacyReported = 0, // ordinal: 0x1
  ArbiterRequestHalReported = 1,    // ordinal: 0x2
  ArbiterRequestLegacyAssigned = 2, // ordinal: 0x3
  ArbiterRequestPnpDetected = 3,    // ordinal: 0x4
  ArbiterRequestPnpEnumerated = 4,  // ordinal: 0x5
} _ARBITER_REQUEST_SOURCE;

typedef enum _INBV_PIXEL_FORMAT {
  PixelFormatUnknown = 0,    // ordinal: 0x0
  PixelFormat4BitPlanar = 1, // ordinal: 0x1
  PixelFormatR8G8B8 = 2,     // ordinal: 0x2
  PixelFormatR8G8B8X8 = 3,   // ordinal: 0x3
  PixelFormatB8G8R8 = 4,     // ordinal: 0x4
  PixelFormatB8G8R8X8 = 5,   // ordinal: 0x5
} _INBV_PIXEL_FORMAT;

typedef enum _PCW_CALLBACK_TYPE {
  PcwCallbackAddCounter = 0,         // ordinal: 0x0
  PcwCallbackRemoveCounter = 1,      // ordinal: 0x1
  PcwCallbackEnumerateInstances = 2, // ordinal: 0x2
  PcwCallbackCollectData = 3,        // ordinal: 0x3
} _PCW_CALLBACK_TYPE;

typedef enum PCW_REGISTRATION_FLAGS {
  PcwRegistrationNone = 0,        // ordinal: 0x0
  PcwRegistrationSiloNeutral = 1, // ordinal: 0x1
} PCW_REGISTRATION_FLAGS;

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
  GenericLessThan = 0,    // ordinal: 0x0
  GenericGreaterThan = 1, // ordinal: 0x1
  GenericEqual = 2,       // ordinal: 0x2
} _RTL_GENERIC_COMPARE_RESULTS;

typedef enum _CM_DIRTY_VECTOR_OPERATION {
  DirtyVectorModified = 0,   // ordinal: 0x0
  DirtyDataCaptureStart = 1, // ordinal: 0x1
  DirtyDataCaptureEnd = 2,   // ordinal: 0x2
} _CM_DIRTY_VECTOR_OPERATION;

typedef enum __anon_2447 {
  KTMOH_CommitTransaction_Result = 1,   // ordinal: 0x0
  KTMOH_RollbackTransaction_Result = 2, // ordinal: 0x1
} __anon_2447;

typedef enum KTM_STATE {
  KKtmUninitialized = 0,  // ordinal: 0x0
  KKtmInitialized = 1,    // ordinal: 0x1
  KKtmRecovering = 2,     // ordinal: 0x2
  KKtmOnline = 3,         // ordinal: 0x3
  KKtmRecoveryFailed = 4, // ordinal: 0x4
  KKtmOffline = 5,        // ordinal: 0x5
} KTM_STATE;

typedef enum _KTRANSACTION_OUTCOME {
  KTxOutcomeUninitialized = 0, // ordinal: 0x0
  KTxOutcomeUndetermined = 1,  // ordinal: 0x1
  KTxOutcomeCommitted = 2,     // ordinal: 0x2
  KTxOutcomeAborted = 3,       // ordinal: 0x3
  KTxOutcomeUnavailable = 4,   // ordinal: 0x4
} _KTRANSACTION_OUTCOME;

typedef enum _KTRANSACTION_STATE {
  KTransactionUninitialized = 0, // ordinal: 0x0
  KTransactionActive = 1,        // ordinal: 0x1
  KTransactionPreparing = 2,     // ordinal: 0x2
  KTransactionPrepared = 3,      // ordinal: 0x3
  KTransactionInDoubt = 4,       // ordinal: 0x4
  KTransactionCommitted = 5,     // ordinal: 0x5
  KTransactionAborted = 6,       // ordinal: 0x6
  KTransactionDelegated = 7,     // ordinal: 0x7
  KTransactionPrePreparing = 8,  // ordinal: 0x8
  KTransactionForgotten = 9,     // ordinal: 0x9
  KTransactionRecovering = 10,   // ordinal: 0xa
  KTransactionPrePrepared = 11,  // ordinal: 0xb
} _KTRANSACTION_STATE;

typedef enum _KRESOURCEMANAGER_STATE {
  KResourceManagerUninitialized = 0, // ordinal: 0x0
  KResourceManagerOffline = 1,       // ordinal: 0x1
  KResourceManagerOnline = 2,        // ordinal: 0x2
} _KRESOURCEMANAGER_STATE;

typedef enum HSTORAGE_TYPE {
  Stable = 0,         // ordinal: 0x0
  Volatile = 1,       // ordinal: 0x1
  InvalidStorage = 2, // ordinal: 0x2
} HSTORAGE_TYPE;

typedef enum UoWActionType {
  UoWAddThisKey = 0,            // ordinal: 0x0
  UoWAddChildKey = 1,           // ordinal: 0x1
  UoWDeleteThisKey = 2,         // ordinal: 0x2
  UoWDeleteChildKey = 3,        // ordinal: 0x3
  UoWSetValueNew = 4,           // ordinal: 0x4
  UoWSetValueExisting = 5,      // ordinal: 0x5
  UoWDeleteValue = 6,           // ordinal: 0x6
  UoWSetKeyUserFlags = 7,       // ordinal: 0x7
  UoWSetLastWriteTime = 8,      // ordinal: 0x8
  UoWSetSecurityDescriptor = 9, // ordinal: 0x9
  UoWRenameSubKey = 10,         // ordinal: 0xa
  UoWRenameOldSubKey = 11,      // ordinal: 0xb
  UoWRenameNewSubKey = 12,      // ordinal: 0xc
  UoWIsolation = 13,            // ordinal: 0xd
  UoWInvalid = 14,              // ordinal: 0xe
} UoWActionType;

typedef enum _KENLISTMENT_STATE {
  KEnlistmentUninitialized = 0,           // ordinal: 0x0
  KEnlistmentActive = 256,                // ordinal: 0x1
  KEnlistmentPreparing = 257,             // ordinal: 0x2
  KEnlistmentPrepared = 258,              // ordinal: 0x3
  KEnlistmentInDoubt = 259,               // ordinal: 0x4
  KEnlistmentCommitted = 260,             // ordinal: 0x5
  KEnlistmentCommittedNotify = 261,       // ordinal: 0x6
  KEnlistmentCommitRequested = 262,       // ordinal: 0x7
  KEnlistmentAborted = 263,               // ordinal: 0x8
  KEnlistmentDelegated = 264,             // ordinal: 0x9
  KEnlistmentDelegatedDisconnected = 265, // ordinal: 0xa
  KEnlistmentPrePreparing = 266,          // ordinal: 0xb
  KEnlistmentForgotten = 267,             // ordinal: 0xc
  KEnlistmentRecovering = 268,            // ordinal: 0xd
  KEnlistmentAborting = 269,              // ordinal: 0xe
  KEnlistmentReadOnly = 270,              // ordinal: 0xf
  KEnlistmentOutcomeUnavailable = 271,    // ordinal: 0x10
  KEnlistmentOffline = 272,               // ordinal: 0x11
  KEnlistmentPrePrepared = 273,           // ordinal: 0x12
  KEnlistmentInitialized = 274,           // ordinal: 0x13
} _KENLISTMENT_STATE;

typedef enum _MI_SYSTEM_VA_TYPE {
  MiVaUnused = 0,                      // ordinal: 0x0
  MiVaSessionSpace = 1,                // ordinal: 0x1
  MiVaProcessSpace = 2,                // ordinal: 0x2
  MiVaBootLoaded = 3,                  // ordinal: 0x3
  MiVaPfnDatabase = 4,                 // ordinal: 0x4
  MiVaNonPagedPool = 5,                // ordinal: 0x5
  MiVaPagedPool = 6,                   // ordinal: 0x6
  MiVaSpecialPoolPaged = 7,            // ordinal: 0x7
  MiVaSystemCache = 8,                 // ordinal: 0x8
  MiVaSystemPtes = 9,                  // ordinal: 0x9
  MiVaHal = 10,                        // ordinal: 0xa
  MiVaFormerlySessionGlobalSpace = 11, // ordinal: 0xb
  MiVaDriverImages = 12,               // ordinal: 0xc
  MiVaSystemPtesLarge = 13,            // ordinal: 0xd
  MiVaKernelStacks = 14,               // ordinal: 0xe
  MiVaSecureNonPagedPool = 15,         // ordinal: 0xf
  MiVaKernelShadowStacks = 16,         // ordinal: 0x10
  MiVaKasan = 17,                      // ordinal: 0x11
  MiVaMaximumType = 18,                // ordinal: 0x12
} _MI_SYSTEM_VA_TYPE;

typedef enum _MI_SLAB_ALLOCATOR_TYPE {
  MiSlabAllocatorTypeSlatProtectedStart = 0,         // ordinal: 0x0
  MiSlabAllocatorTypeExecuteProtected = 0,           // ordinal: 0x1
  MiSlabAllocatorTypeReadOnlyProtected = 1,          // ordinal: 0x2
  MiSlabAllocatorTypeNoAccessProtected = 2,          // ordinal: 0x3
  MiSlabAllocatorTypeKernelShadowStackProtected = 3, // ordinal: 0x4
  MiSlabAllocatorTypeSlatProtectedLast = 3,          // ordinal: 0x5
  MiSlabAllocatorTypeSlatUnprotectedStart = 4,       // ordinal: 0x6
  MiSlabAllocatorTypeImageUnprotected = 4,           // ordinal: 0x7
  MiSlabAllocatorTypeGenericUnprotected = 5,         // ordinal: 0x8
  MiSlabAllocatorTypeNonPagedUnprotected = 6,        // ordinal: 0x9
  MiSlabAllocatorTypeSlatUnprotectedLast = 6,        // ordinal: 0xa
  MiSlabAllocatorTypeMax = 7,                        // ordinal: 0xb
} _MI_SLAB_ALLOCATOR_TYPE;

typedef enum _MMLISTS {
  ZeroedPageList = 0,          // ordinal: 0x0
  FreePageList = 1,            // ordinal: 0x1
  StandbyPageList = 2,         // ordinal: 0x2
  ModifiedPageList = 3,        // ordinal: 0x3
  ModifiedNoWritePageList = 4, // ordinal: 0x4
  BadPageList = 5,             // ordinal: 0x5
  ActiveAndValid = 6,          // ordinal: 0x6
  TransitionPage = 7,          // ordinal: 0x7
} _MMLISTS;

typedef enum wil_details_FeatureTestStateKind {
  wil_details_FeatureTestStateKind_EnabledState = 0, // ordinal: 0x0
  wil_details_FeatureTestStateKind_Variant = 1,      // ordinal: 0x1
} wil_details_FeatureTestStateKind;

typedef enum wil_FeatureEnabledState {
  wil_FeatureEnabledState_Default = 0,  // ordinal: 0x0
  wil_FeatureEnabledState_Disabled = 1, // ordinal: 0x1
  wil_FeatureEnabledState_Enabled = 2,  // ordinal: 0x2
} wil_FeatureEnabledState;

// 0x8 bytes (sizeof)
typedef struct Change {
  enum wil_details_ServiceReportingKind kind; // offset: 0x0 ordinal: 0x0
  ULONG count;                                // offset: 0x4 ordinal: 0x1
} Change;

// 0x18 bytes (sizeof)
typedef struct wil_details_RecordUsageResult {
  LONG queueBackground; // offset: 0x0 ordinal: 0x0
  ULONG countImmediate; // offset: 0x4 ordinal: 0x1
  enum wil_details_ServiceReportingKind
      kindImmediate;        // offset: 0x8 ordinal: 0x2
  ULONG payloadId;          // offset: 0xc ordinal: 0x3
  LONG ignoredUse;          // offset: 0x10 ordinal: 0x4
  LONG isWexpConfiguration; // offset: 0x14 ordinal: 0x5
} wil_details_RecordUsageResult;

typedef enum wil_FeatureVariantPayloadKind {
  wil_FeatureVariantPayloadKind_None = 0,     // ordinal: 0x0
  wil_FeatureVariantPayloadKind_Resident = 1, // ordinal: 0x1
  wil_FeatureVariantPayloadKind_External = 2, // ordinal: 0x2
} wil_FeatureVariantPayloadKind;

typedef enum _MM_PAGE_ACCESS_TYPE {
  MmPteAccessType = 0,         // ordinal: 0x0
  MmCcReadAheadType = 1,       // ordinal: 0x1
  MmPfnRepurposeType = 2,      // ordinal: 0x2
  MmMaximumPageAccessType = 3, // ordinal: 0x3
} _MM_PAGE_ACCESS_TYPE;

typedef enum _IO_PRIORITY_HINT {
  IoPriorityVeryLow = 0,  // ordinal: 0x0
  IoPriorityLow = 1,      // ordinal: 0x1
  IoPriorityNormal = 2,   // ordinal: 0x2
  IoPriorityHigh = 3,     // ordinal: 0x3
  IoPriorityCritical = 4, // ordinal: 0x4
  MaxIoPriorityTypes = 5, // ordinal: 0x5
} _IO_PRIORITY_HINT;

typedef enum _TP_CALLBACK_PRIORITY {
  TP_CALLBACK_PRIORITY_HIGH = 0,    // ordinal: 0x0
  TP_CALLBACK_PRIORITY_NORMAL = 1,  // ordinal: 0x1
  TP_CALLBACK_PRIORITY_LOW = 2,     // ordinal: 0x2
  TP_CALLBACK_PRIORITY_INVALID = 3, // ordinal: 0x3
  TP_CALLBACK_PRIORITY_COUNT = 3,   // ordinal: 0x4
} _TP_CALLBACK_PRIORITY;

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
  StandardDesign = 0,  // ordinal: 0x0
  NEC98x86 = 1,        // ordinal: 0x1
  EndAlternatives = 2, // ordinal: 0x2
} _ALTERNATIVE_ARCHITECTURE_TYPE;

typedef enum _INTERRUPT_LINE_SUBTYPE {
  InterruptLineSubTypeNone = 0, // ordinal: 0x0
  InterruptLineSubTypeV2m = 1,  // ordinal: 0x1
  InterruptLineSubTypeLpi = 2,  // ordinal: 0x2
} _INTERRUPT_LINE_SUBTYPE;

typedef enum _INTERRUPT_LINE_TYPE {
  InterruptLineInvalidType = 0,                // ordinal: 0x0
  InterruptLineUnusable = 1,                   // ordinal: 0x1
  InterruptLineStandardPin = 2,                // ordinal: 0x2
  InterruptLineProcessorLocal = 3,             // ordinal: 0x3
  InterruptLineSoftwareOnly = 4,               // ordinal: 0x4
  InterruptLineSoftwareOnlyProcessorLocal = 5, // ordinal: 0x5
  InterruptLineOutputPin = 6,                  // ordinal: 0x6
  InterruptLineMsi = 7,                        // ordinal: 0x7
} _INTERRUPT_LINE_TYPE;

typedef enum _HAL_HV_DMA_DOMAIN_CONFIG_ARCH {
  HalHvDmaDomainConfigArm64 = 0, // ordinal: 0x0
  HalHvDmaDomainConfigX64 = 1,   // ordinal: 0x1
} _HAL_HV_DMA_DOMAIN_CONFIG_ARCH;

typedef enum _WHEA_RECOVERY_CONTEXT_ERROR_TYPE {
  WheaRecoveryContextErrorTypeMemory = 1, // ordinal: 0x0
  WheaRecoveryContextErrorTypePmem = 2,   // ordinal: 0x1
  WheaRecoveryContextErrorTypeMax = 3,    // ordinal: 0x2
} _WHEA_RECOVERY_CONTEXT_ERROR_TYPE;

typedef enum _EXT_IOMMU_INTERRUPT_REMAPPING_POLICY {
  ExtIommuInterruptRemappingPolicyDisable = 0,      // ordinal: 0x0
  ExtIommuInterruptRemappingPolicyEnableLoose = 1,  // ordinal: 0x1
  ExtIommuInterruptRemappingPolicyEnableStrict = 2, // ordinal: 0x2
} _EXT_IOMMU_INTERRUPT_REMAPPING_POLICY;

typedef enum _EXT_IOMMU_ADDRESS_TRANSLATION_POLICY {
  ExtIommuAddressTranslationPolicyDisable = 0,                // ordinal: 0x0
  ExtIommuAddressTranslationPolicyEnableDefaultBypass = 1,    // ordinal: 0x1
  ExtIommuAddressTranslationPolicyEnableDefaultBlock = 2,     // ordinal: 0x2
  ExtIommuAddressTranslationPolicyEnableDefaultTranslate = 3, // ordinal: 0x3
} _EXT_IOMMU_ADDRESS_TRANSLATION_POLICY;

typedef enum _DMA_SPEED {
  Compatible = 0,      // ordinal: 0x0
  TypeA = 1,           // ordinal: 0x1
  TypeB = 2,           // ordinal: 0x2
  TypeC = 3,           // ordinal: 0x3
  TypeF = 4,           // ordinal: 0x4
  MaximumDmaSpeed = 5, // ordinal: 0x5
} _DMA_SPEED;

typedef enum _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE {
  CommonBufferHardwareAccessReadOnly = 0,  // ordinal: 0x0
  CommonBufferHardwareAccessWriteOnly = 1, // ordinal: 0x1
  CommonBufferHardwareAccessReadWrite = 2, // ordinal: 0x2
  CommonBufferHardwareAccessMax = 3,       // ordinal: 0x3
} _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE;

typedef enum _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE {
  CommonBufferConfigTypeLogicalAddressLimits = 0,      // ordinal: 0x0
  CommonBufferConfigTypeSubSection = 1,                // ordinal: 0x1
  CommonBufferConfigTypeHardwareAccessPermissions = 2, // ordinal: 0x2
  CommonBufferConfigTypeMax = 3,                       // ordinal: 0x3
} _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE;

typedef enum _EXT_IOMMU_DOMAIN_TYPE {
  ExtIommuDomainTypeS1 = 0,      // ordinal: 0x0
  ExtIommuDomainTypeS2 = 1,      // ordinal: 0x1
  ExtIommuDomainTypeInvalid = 2, // ordinal: 0x2
} _EXT_IOMMU_DOMAIN_TYPE;

typedef enum _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE {
  IommuDmaLogicalAllocatorNone = 0,  // ordinal: 0x0
  IommuDmaLogicalAllocatorBuddy = 1, // ordinal: 0x1
  IommuDmaLogicalAllocatorMax = 2,   // ordinal: 0x2
} _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE;

typedef enum DMA_COMPLETION_STATUS {
  DmaComplete = 0,  // ordinal: 0x0
  DmaAborted = 1,   // ordinal: 0x1
  DmaError = 2,     // ordinal: 0x2
  DmaCancelled = 3, // ordinal: 0x3
} DMA_COMPLETION_STATUS;

typedef enum _MEMORY_CACHING_TYPE {
  MmNonCached = 0,              // ordinal: 0x0
  MmCached = 1,                 // ordinal: 0x1
  MmWriteCombined = 2,          // ordinal: 0x2
  MmHardwareCoherentCached = 3, // ordinal: 0x3
  MmNonCachedUnordered = 4,     // ordinal: 0x4
  MmUSWCCached = 5,             // ordinal: 0x5
  MmMaximumCacheType = 6,       // ordinal: 0x6
  MmNotMapped = -1,             // ordinal: 0x7
} _MEMORY_CACHING_TYPE;

typedef enum _EXT_IOMMU_KNOWN_IOMMU_TYPE {
  ExtIommuInvalid = 0,    // ordinal: 0x0
  ExtIommuAmd = 1,        // ordinal: 0x1
  ExtIommuIntel = 2,      // ordinal: 0x2
  ExtIommuSmmuv1 = 3,     // ordinal: 0x3
  ExtIommuSmmuv2 = 4,     // ordinal: 0x4
  ExtIommuSmmuv3 = 5,     // ordinal: 0x5
  ExtIommuIts = 6,        // ordinal: 0x6
  ExtIommuUnknown = 4096, // ordinal: 0x7
} _EXT_IOMMU_KNOWN_IOMMU_TYPE;

typedef enum _FAULT_INFORMATION_ARM64_TYPE {
  UnsupportedUpstreamTransaction = 0, // ordinal: 0x0
  AddressSizeFault = 1,               // ordinal: 0x1
  TlbMatchConflict = 2,               // ordinal: 0x2
  ExternalFault = 3,                  // ordinal: 0x3
  PermissionFault = 4,                // ordinal: 0x4
  AccessFlagFault = 5,                // ordinal: 0x5
  TranslationFault = 6,               // ordinal: 0x6
  MaxFaultType = 7,                   // ordinal: 0x7
} _FAULT_INFORMATION_ARM64_TYPE;

typedef enum _EXT_IOMMU_TRANSLATION_TYPE {
  ExtTranslationTypePassThrough = 0, // ordinal: 0x0
  ExtTranslationTypeBlocked = 1,     // ordinal: 0x1
  ExtTranslationTypeTranslate = 2,   // ordinal: 0x2
  ExtTranslationTypeInvalid = 3,     // ordinal: 0x3
} _EXT_IOMMU_TRANSLATION_TYPE;

typedef enum _IOMMU_DMA_DOMAIN_TYPE {
  DomainTypeTranslate = 0,   // ordinal: 0x0
  DomainTypePassThrough = 1, // ordinal: 0x1
  DomainTypeUnmanaged = 2,   // ordinal: 0x2
  DomainTypeMax = 3,         // ordinal: 0x3
} _IOMMU_DMA_DOMAIN_TYPE;

typedef enum _DMA_INTERRUPT_TYPE {
  InterruptTypeCompletion = 0, // ordinal: 0x0
  InterruptTypeError = 1,      // ordinal: 0x1
  InterruptTypeCancelled = 2,  // ordinal: 0x2
} _DMA_INTERRUPT_TYPE;

typedef enum _FAULT_INFORMATION_ARCH {
  FaultInformationInvalid = 0, // ordinal: 0x0
  FaultInformationArm64 = 1,   // ordinal: 0x1
  FaultInformationX64 = 2,     // ordinal: 0x2
} _FAULT_INFORMATION_ARCH;

typedef enum _EXT_IOMMU_DEVICE_TYPE {
  EXT_IOMMU_DEVICE_TYPE_INVALID = 0, // ordinal: 0x0
  EXT_IOMMU_DEVICE_TYPE_PCI = 1,     // ordinal: 0x1
  EXT_IOMMU_DEVICE_TYPE_ACPI = 2,    // ordinal: 0x2
  EXT_IOMMU_DEVICE_TYPE_IOAPIC = 3,  // ordinal: 0x3
  EXT_IOMMU_DEVICE_TYPE_LOGICAL = 4, // ordinal: 0x4
  EXT_IOMMU_DEVICE_TYPE_GIC = 5,     // ordinal: 0x5
  EXT_IOMMU_DEVICE_TYPE_TEST = 6,    // ordinal: 0x6
  EXT_IOMMU_DEVICE_TYPE_MAX = 7,     // ordinal: 0x7
} _EXT_IOMMU_DEVICE_TYPE;

typedef enum _HALP_EMERGENCY_LA_QUEUE_TYPE {
  HalpDmaLegacyLaQueueEntry = 0, // ordinal: 0x0
  HalpDmaThinLaQueueEntry = 1,   // ordinal: 0x1
  HalpDmaLaQueueEntryMax = 2,    // ordinal: 0x2
} _HALP_EMERGENCY_LA_QUEUE_TYPE;

typedef enum _HALP_DMA_ADAPTER_ALLOCATION_STATE {
  HalpDmaAdapterAllocationStateNone = 0,           // ordinal: 0x0
  HalpDmaAdapterAllocateChannel = 1,               // ordinal: 0x1
  HalpDmaAdapterAllocateMapRegisters = 2,          // ordinal: 0x2
  HalpDmaAdapterAllocateChannelRemapResources = 3, // ordinal: 0x3
  HalpDmaAdapterAllocationStateComplete = 4,       // ordinal: 0x4
  HalpDmaAdapterAllocationStateMax = 5,            // ordinal: 0x5
} _HALP_DMA_ADAPTER_ALLOCATION_STATE;

typedef enum _HALP_DMA_TRANSLATION_TYPE {
  DmaTranslationTypePassthrough = 0,       // ordinal: 0x0
  DmaTranslationTypeSafePassthrough = 1,   // ordinal: 0x1
  DmaTranslationTypeHybridPassthrough = 2, // ordinal: 0x2
  DmaTranslationTypeTranslate = 3,         // ordinal: 0x3
  DmaTranslationTypeMax = 4,               // ordinal: 0x4
} _HALP_DMA_TRANSLATION_TYPE;

typedef enum _DMA_WIDTH {
  Width8Bits = 0,      // ordinal: 0x0
  Width16Bits = 1,     // ordinal: 0x1
  Width32Bits = 2,     // ordinal: 0x2
  Width64Bits = 3,     // ordinal: 0x3
  WidthNoWrap = 4,     // ordinal: 0x4
  MaximumDmaWidth = 5, // ordinal: 0x5
} _DMA_WIDTH;

typedef enum _WHEA_CPU_VENDOR {
  WheaCpuVendorOther = 0, // ordinal: 0x0
  WheaCpuVendorIntel = 1, // ordinal: 0x1
  WheaCpuVendorAmd = 2,   // ordinal: 0x2
} _WHEA_CPU_VENDOR;

typedef enum _INTERRUPT_TARGET_TYPE {
  InterruptTargetInvalid = 0,          // ordinal: 0x0
  InterruptTargetAllIncludingSelf = 1, // ordinal: 0x1
  InterruptTargetAllExcludingSelf = 2, // ordinal: 0x2
  InterruptTargetSelfOnly = 3,         // ordinal: 0x3
  InterruptTargetPhysical = 4,         // ordinal: 0x4
  InterruptTargetLogicalFlat = 5,      // ordinal: 0x5
  InterruptTargetLogicalClustered = 6, // ordinal: 0x6
  InterruptTargetRemapIndex = 7,       // ordinal: 0x7
  InterruptTargetHypervisor = 8,       // ordinal: 0x8
} _INTERRUPT_TARGET_TYPE;

typedef enum _INTERRUPT_RESULT {
  InterruptBeginFatalError = 0, // ordinal: 0x0
  InterruptBeginLine = 1,       // ordinal: 0x1
  InterruptBeginSpurious = 2,   // ordinal: 0x2
  InterruptBeginVector = 3,     // ordinal: 0x3
  InterruptBeginNone = 4,       // ordinal: 0x4
} _INTERRUPT_RESULT;

typedef enum _INTERRUPT_PROBLEM {
  InterruptProblemNone = 0,                              // ordinal: 0x0
  InterruptProblemMadtParsingFailure = 1,                // ordinal: 0x1
  InterruptProblemNoControllersFound = 2,                // ordinal: 0x2
  InterruptProblemFailedDiscovery = 3,                   // ordinal: 0x3
  InterruptProblemInitializeLocalUnitFailed = 4,         // ordinal: 0x4
  InterruptProblemInitializeIoUnitFailed = 5,            // ordinal: 0x5
  InterruptProblemSetLogicalIdFailed = 6,                // ordinal: 0x6
  InterruptProblemSetLineStateFailed = 7,                // ordinal: 0x7
  InterruptProblemGenerateMessageFailed = 8,             // ordinal: 0x8
  InterruptProblemConvertIdFailed = 9,                   // ordinal: 0x9
  InterruptProblemCmciSetupFailed = 10,                  // ordinal: 0xa
  InterruptProblemQueryMaxProcessorsCalledTooEarly = 11, // ordinal: 0xb
  InterruptProblemProcessorReset = 12,                   // ordinal: 0xc
  InterruptProblemStartProcessorFailed = 13,             // ordinal: 0xd
  InterruptProblemProcessorNotAlive = 14,                // ordinal: 0xe
  InterruptProblemLowerIrqlViolation = 15,               // ordinal: 0xf
  InterruptProblemInvalidIrql = 16,                      // ordinal: 0x10
  InterruptProblemNoSuchController = 17,                 // ordinal: 0x11
  InterruptProblemNoSuchLines = 18,                      // ordinal: 0x12
  InterruptProblemBadConnectionData = 19,                // ordinal: 0x13
  InterruptProblemBadRoutingData = 20,                   // ordinal: 0x14
  InterruptProblemInvalidProcessor = 21,                 // ordinal: 0x15
  InterruptProblemFailedToAttainTarget = 22,             // ordinal: 0x16
  InterruptProblemUnsupportedWiringConfiguration = 23,   // ordinal: 0x17
  InterruptProblemSpareAlreadyStarted = 24,              // ordinal: 0x18
  InterruptProblemClusterNotFullyReplaced = 25,          // ordinal: 0x19
  InterruptProblemNewClusterAlreadyActive = 26,          // ordinal: 0x1a
  InterruptProblemNewClusterTooLarge = 27,               // ordinal: 0x1b
  InterruptProblemCannotHardwareQuiesce = 28,            // ordinal: 0x1c
  InterruptProblemIpiDestinationUpdateFailed = 29,       // ordinal: 0x1d
  InterruptProblemNoMemory = 30,                         // ordinal: 0x1e
  InterruptProblemNoIrtEntries = 31,                     // ordinal: 0x1f
  InterruptProblemConnectionDataBaitAndSwitch = 32,      // ordinal: 0x20
  InterruptProblemInvalidLogicalFlatId = 33,             // ordinal: 0x21
  InterruptProblemDeinitializeLocalUnitFailed = 34,      // ordinal: 0x22
  InterruptProblemDeinitializeIoUnitFailed = 35,         // ordinal: 0x23
  InterruptProblemMismatchedThermalLvtIsr = 36,          // ordinal: 0x24
  InterruptProblemHvRetargetFailed = 37,                 // ordinal: 0x25
  InterruptProblemDeferredErrorSetupFailed = 38,         // ordinal: 0x26
  InterruptProblemBadInterruptPartition = 39,            // ordinal: 0x27
} _INTERRUPT_PROBLEM;

typedef enum _KNOWN_CONTROLLER_TYPE {
  InterruptControllerInvalid = 0,    // ordinal: 0x0
  InterruptControllerPic = 1,        // ordinal: 0x1
  InterruptControllerApic = 2,       // ordinal: 0x2
  InterruptControllerGic = 3,        // ordinal: 0x3
  InterruptControllerGicV3 = 4,      // ordinal: 0x4
  InterruptControllerGicV4 = 5,      // ordinal: 0x5
  InterruptControllerBcm = 6,        // ordinal: 0x6
  InterruptControllerUnknown = 4096, // ordinal: 0x7
} _KNOWN_CONTROLLER_TYPE;

typedef enum _KINTERRUPT_MODE {
  LevelSensitive = 0, // ordinal: 0x0
  Latched = 1,        // ordinal: 0x1
} _KINTERRUPT_MODE;

typedef enum _KINTERRUPT_POLARITY {
  InterruptPolarityUnknown = 0,       // ordinal: 0x0
  InterruptActiveHigh = 1,            // ordinal: 0x1
  InterruptRisingEdge = 1,            // ordinal: 0x2
  InterruptActiveLow = 2,             // ordinal: 0x3
  InterruptFallingEdge = 2,           // ordinal: 0x4
  InterruptActiveBoth = 3,            // ordinal: 0x5
  InterruptActiveBothTriggerLow = 3,  // ordinal: 0x6
  InterruptActiveBothTriggerHigh = 4, // ordinal: 0x7
} _KINTERRUPT_POLARITY;

typedef enum _WHEA_ERROR_PACKET_DATA_FORMAT {
  WheaDataFormatIPFSalRecord = 0, // ordinal: 0x0
  WheaDataFormatXPFMCA = 1,       // ordinal: 0x1
  WheaDataFormatMemory = 2,       // ordinal: 0x2
  WheaDataFormatPCIExpress = 3,   // ordinal: 0x3
  WheaDataFormatNMIPort = 4,      // ordinal: 0x4
  WheaDataFormatPCIXBus = 5,      // ordinal: 0x5
  WheaDataFormatPCIXDevice = 6,   // ordinal: 0x6
  WheaDataFormatGeneric = 7,      // ordinal: 0x7
  WheaDataFormatMax = 8,          // ordinal: 0x8
} _WHEA_ERROR_PACKET_DATA_FORMAT;

typedef enum _WHEA_ERROR_SEVERITY {
  WheaErrSevRecoverable = 0,   // ordinal: 0x0
  WheaErrSevFatal = 1,         // ordinal: 0x1
  WheaErrSevCorrected = 2,     // ordinal: 0x2
  WheaErrSevInformational = 3, // ordinal: 0x3
} _WHEA_ERROR_SEVERITY;

typedef enum _WHEA_ERROR_TYPE {
  WheaErrTypeProcessor = 0,  // ordinal: 0x0
  WheaErrTypeMemory = 1,     // ordinal: 0x1
  WheaErrTypePCIExpress = 2, // ordinal: 0x2
  WheaErrTypeNMI = 3,        // ordinal: 0x3
  WheaErrTypePCIXBus = 4,    // ordinal: 0x4
  WheaErrTypePCIXDevice = 5, // ordinal: 0x5
  WheaErrTypeGeneric = 6,    // ordinal: 0x6
  WheaErrTypePmem = 7,       // ordinal: 0x7
} _WHEA_ERROR_TYPE;

typedef enum _WHEA_EVENT_LOG_ENTRY_ID {
  WheaEventLogEntryIdCmcPollingTimeout = -2147483647,       // ordinal: 0x0
  WheaEventLogEntryIdWheaInit = -2147483646,                // ordinal: 0x1
  WheaEventLogEntryIdCmcSwitchToPolling = -2147483645,      // ordinal: 0x2
  WheaEventLogEntryIdDroppedCorrectedError = -2147483644,   // ordinal: 0x3
  WheaEventLogEntryIdStartedReportHwError = -2147483643,    // ordinal: 0x4
  WheaEventLogEntryIdPFAMemoryOfflined = -2147483642,       // ordinal: 0x5
  WheaEventLogEntryIdPFAMemoryRemoveMonitor = -2147483641,  // ordinal: 0x6
  WheaEventLogEntryIdPFAMemoryPolicy = -2147483640,         // ordinal: 0x7
  WheaEventLogEntryIdPshedInjectError = -2147483639,        // ordinal: 0x8
  WheaEventLogEntryIdOscCapabilities = -2147483638,         // ordinal: 0x9
  WheaEventLogEntryIdPshedPluginRegister = -2147483637,     // ordinal: 0xa
  WheaEventLogEntryIdAddRemoveErrorSource = -2147483636,    // ordinal: 0xb
  WheaEventLogEntryIdWorkQueueItem = -2147483635,           // ordinal: 0xc
  WheaEventLogEntryIdAttemptErrorRecovery = -2147483634,    // ordinal: 0xd
  WheaEventLogEntryIdMcaFoundErrorInBank = -2147483633,     // ordinal: 0xe
  WheaEventLogEntryIdMcaStuckErrorCheck = -2147483632,      // ordinal: 0xf
  WheaEventLogEntryIdMcaErrorCleared = -2147483631,         // ordinal: 0x10
  WheaEventLogEntryIdClearedPoison = -2147483630,           // ordinal: 0x11
  WheaEventLogEntryIdProcessEINJ = -2147483629,             // ordinal: 0x12
  WheaEventLogEntryIdProcessHEST = -2147483628,             // ordinal: 0x13
  WheaEventLogEntryIdCreateGenericRecord = -2147483627,     // ordinal: 0x14
  WheaEventLogEntryIdErrorRecord = -2147483626,             // ordinal: 0x15
  WheaEventLogEntryIdErrorRecordLimit = -2147483625,        // ordinal: 0x16
  WheaEventLogEntryIdAerNotGrantedToOs = -2147483624,       // ordinal: 0x17
  WheaEventLogEntryIdErrSrcArrayInvalid = -2147483623,      // ordinal: 0x18
  WheaEventLogEntryIdAcpiTimeOut = -2147483622,             // ordinal: 0x19
  WheaEventLogCmciRestart = -2147483621,                    // ordinal: 0x1a
  WheaEventLogCmciFinalRestart = -2147483620,               // ordinal: 0x1b
  WheaEventLogEntryEtwOverFlow = -2147483619,               // ordinal: 0x1c
  WheaEventLogAzccRootBusSearchErr = -2147483618,           // ordinal: 0x1d
  WheaEventLogAzccRootBusList = -2147483617,                // ordinal: 0x1e
  WheaEventLogEntryIdErrSrcInvalid = -2147483616,           // ordinal: 0x1f
  WheaEventLogEntryIdGenericErrMemMap = -2147483615,        // ordinal: 0x20
  WheaEventLogEntryIdPshedCallbackCollision = -2147483614,  // ordinal: 0x21
  WheaEventLogEntryIdSELBugCheckProgress = -2147483613,     // ordinal: 0x22
  WheaEventLogEntryIdPshedPluginLoad = -2147483612,         // ordinal: 0x23
  WheaEventLogEntryIdPshedPluginUnload = -2147483611,       // ordinal: 0x24
  WheaEventLogEntryIdPshedPluginSupported = -2147483610,    // ordinal: 0x25
  WheaEventLogEntryIdDeviceDriver = -2147483609,            // ordinal: 0x26
  WheaEventLogEntryIdCmciImplPresent = -2147483608,         // ordinal: 0x27
  WheaEventLogEntryIdCmciInitError = -2147483607,           // ordinal: 0x28
  WheaEventLogEntryIdSELBugCheckRecovery = -2147483606,     // ordinal: 0x29
  WheaEventLogEntryIdDrvErrSrcInvalid = -2147483605,        // ordinal: 0x2a
  WheaEventLogEntryIdDrvHandleBusy = -2147483604,           // ordinal: 0x2b
  WheaEventLogEntryIdWheaHeartbeat = -2147483603,           // ordinal: 0x2c
  WheaEventLogAzccRootBusPoisonSet = -2147483602,           // ordinal: 0x2d
  WheaEventLogEntryIdSELBugCheckInfo = -2147483601,         // ordinal: 0x2e
  WheaEventLogEntryIdErrDimmInfoMismatch = -2147483600,     // ordinal: 0x2f
  WheaEventLogEntryIdeDpcEnabled = -2147483599,             // ordinal: 0x30
  WheaEventLogEntryPageOfflineDone = -2147483598,           // ordinal: 0x31
  WheaEventLogEntryPageOfflinePendMax = -2147483597,        // ordinal: 0x32
  WheaEventLogEntryIdBadPageLimitReached = -2147483596,     // ordinal: 0x33
  WheaEventLogEntrySrarDetail = -2147483595,                // ordinal: 0x34
  WheaEventLogEntryEarlyError = -2147483594,                // ordinal: 0x35
  WheaEventLogEntryIdPcieOverrideInfo = -2147483593,        // ordinal: 0x36
  WheaEventLogEntryIdReadPcieOverridesErr = -2147483592,    // ordinal: 0x37
  WheaEventLogEntryIdPcieConfigInfo = -2147483591,          // ordinal: 0x38
  WheaEventLogEntryIdPcieSummaryFailed = -2147483584,       // ordinal: 0x39
  WheaEventLogEntryIdThrottleRegCorrupt = -2147483583,      // ordinal: 0x3a
  WheaEventLogEntryIdThrottleAddErrSrcFailed = -2147483582, // ordinal: 0x3b
  WheaEventLogEntryIdThrottleRegDataIgnored = -2147483581,  // ordinal: 0x3c
  WheaEventLogEntryIdEnableKeyNotifFailed = -2147483580,    // ordinal: 0x3d
  WheaEventLogEntryIdKeyNotificationFailed = -2147483579,   // ordinal: 0x3e
  WheaEventLogEntryIdPcieRemoveDevice = -2147483578,        // ordinal: 0x3f
  WheaEventLogEntryIdPcieAddDevice = -2147483577,           // ordinal: 0x40
  WheaEventLogEntryIdPcieSpuriousErrSource = -2147483576,   // ordinal: 0x41
  WheaEventLogEntryIdMemoryAddDevice = -2147483575,         // ordinal: 0x42
  WheaEventLogEntryIdMemoryRemoveDevice = -2147483574,      // ordinal: 0x43
  WheaEventLogEntryIdMemorySummaryFailed = -2147483573,     // ordinal: 0x44
  WheaEventLogEntryIdPcieDpcError = -2147483572,            // ordinal: 0x45
  WheaEventLogEntryIdCpuBusesInitFailed = -2147483571,      // ordinal: 0x46
  WheaEventLogEntryIdPshedPluginInitFailed = -2147483570,   // ordinal: 0x47
  WheaEventLogEntryIdFailedAddToDefectList = -2147483569,   // ordinal: 0x48
  WheaEventLogEntryIdDefectListFull = -2147483568,          // ordinal: 0x49
  WheaEventLogEntryIdDefectListUEFIVarFailed = -2147483567, // ordinal: 0x4a
  WheaEventLogEntryIdDefectListCorrupt = -2147483566,       // ordinal: 0x4b
  WheaEventLogEntryIdBadHestNotifyData = -2147483565,       // ordinal: 0x4c
  WheaEventLogEntryIdSrasTableNotFound = -2147483564,       // ordinal: 0x4d
  WheaEventLogEntryIdSrasTableError = -2147483563,          // ordinal: 0x4e
  WheaEventLogEntryIdSrasTableEntries = -2147483562,        // ordinal: 0x4f
  WheaEventLogEntryIdRowFailure = -2147483561,              // ordinal: 0x50
  WheaEventLogEntryIdCpusFrozen = -2147483552,              // ordinal: 0x51
  WheaEventLogEntryIdCpusFrozenNoCrashDump = -2147483551,   // ordinal: 0x52
  WheaEventLogEntryIdPshedPiTraceLog = -2147221488,         // ordinal: 0x53
} _WHEA_EVENT_LOG_ENTRY_ID;

typedef enum _WHEA_EVENT_LOG_ENTRY_TYPE {
  WheaEventLogEntryTypeInformational = 0, // ordinal: 0x0
  WheaEventLogEntryTypeWarning = 1,       // ordinal: 0x1
  WheaEventLogEntryTypeError = 2,         // ordinal: 0x2
} _WHEA_EVENT_LOG_ENTRY_TYPE;

typedef enum _WHEA_ERROR_SOURCE_STATE {
  WheaErrSrcStateStopped = 1,       // ordinal: 0x0
  WheaErrSrcStateStarted = 2,       // ordinal: 0x1
  WheaErrSrcStateRemoved = 3,       // ordinal: 0x2
  WheaErrSrcStateRemovePending = 4, // ordinal: 0x3
} _WHEA_ERROR_SOURCE_STATE;

typedef enum _WHEA_ERROR_SOURCE_TYPE {
  WheaErrSrcTypeMCE = 0,           // ordinal: 0x0
  WheaErrSrcTypeCMC = 1,           // ordinal: 0x1
  WheaErrSrcTypeCPE = 2,           // ordinal: 0x2
  WheaErrSrcTypeNMI = 3,           // ordinal: 0x3
  WheaErrSrcTypePCIe = 4,          // ordinal: 0x4
  WheaErrSrcTypeGeneric = 5,       // ordinal: 0x5
  WheaErrSrcTypeINIT = 6,          // ordinal: 0x6
  WheaErrSrcTypeBOOT = 7,          // ordinal: 0x7
  WheaErrSrcTypeSCIGeneric = 8,    // ordinal: 0x8
  WheaErrSrcTypeIPFMCA = 9,        // ordinal: 0x9
  WheaErrSrcTypeIPFCMC = 10,       // ordinal: 0xa
  WheaErrSrcTypeIPFCPE = 11,       // ordinal: 0xb
  WheaErrSrcTypeGenericV2 = 12,    // ordinal: 0xc
  WheaErrSrcTypeSCIGenericV2 = 13, // ordinal: 0xd
  WheaErrSrcTypeBMC = 14,          // ordinal: 0xe
  WheaErrSrcTypePMEM = 15,         // ordinal: 0xf
  WheaErrSrcTypeDeviceDriver = 16, // ordinal: 0x10
  WheaErrSrcTypeSea = 17,          // ordinal: 0x11
  WheaErrSrcTypeSei = 18,          // ordinal: 0x12
  WheaErrSrcTypeMax = 19,          // ordinal: 0x13
} _WHEA_ERROR_SOURCE_TYPE;

typedef enum _EXCEPTION_DISPOSITION {
  ExceptionContinueExecution = 0, // ordinal: 0x0
  ExceptionContinueSearch = 1,    // ordinal: 0x1
  ExceptionNestedException = 2,   // ordinal: 0x2
  ExceptionCollidedUnwind = 3,    // ordinal: 0x3
} _EXCEPTION_DISPOSITION;

typedef enum _DEVICE_RELATION_LEVEL {
  RELATION_LEVEL_REMOVE_EJECT = 0,      // ordinal: 0x0
  RELATION_LEVEL_DEPENDENT = 1,         // ordinal: 0x1
  RELATION_LEVEL_DIRECT_DESCENDANT = 2, // ordinal: 0x2
} _DEVICE_RELATION_LEVEL;

typedef enum _PO_FX_PERF_STATE_TYPE {
  PoFxPerfStateTypeDiscrete = 0, // ordinal: 0x0
  PoFxPerfStateTypeRange = 1,    // ordinal: 0x1
  PoFxPerfStateTypeMaximum = 2,  // ordinal: 0x2
} _PO_FX_PERF_STATE_TYPE;

typedef enum _PO_FX_PERF_STATE_UNIT {
  PoFxPerfStateUnitOther = 0,     // ordinal: 0x0
  PoFxPerfStateUnitFrequency = 1, // ordinal: 0x1
  PoFxPerfStateUnitBandwidth = 2, // ordinal: 0x2
  PoFxPerfStateUnitMaximum = 3,   // ordinal: 0x3
} _PO_FX_PERF_STATE_UNIT;

typedef enum _IRQ_PRIORITY {
  IrqPriorityUndefined = 0, // ordinal: 0x0
  IrqPriorityLow = 1,       // ordinal: 0x1
  IrqPriorityNormal = 2,    // ordinal: 0x2
  IrqPriorityHigh = 3,      // ordinal: 0x3
} _IRQ_PRIORITY;

typedef enum _NT_IORING_REG_BUFFERS_ADV_FLAGS {
  NT_IORING_REG_BUFFERS_ADV_FLAG_NONE = 0, // ordinal: 0x0
} _NT_IORING_REG_BUFFERS_ADV_FLAGS;

typedef enum _NT_IORING_REG_BUFFERS_REQ_FLAGS {
  NT_IORING_REG_BUFFERS_REQ_FLAG_NONE = 0, // ordinal: 0x0
} _NT_IORING_REG_BUFFERS_REQ_FLAGS;

// 0x8 bytes (sizeof)
typedef struct _NT_IORING_REG_BUFFERS_FLAGS {
  enum _NT_IORING_REG_BUFFERS_REQ_FLAGS Required; // offset: 0x0 ordinal: 0x0
  enum _NT_IORING_REG_BUFFERS_ADV_FLAGS Advisory; // offset: 0x4 ordinal: 0x1
} _NT_IORING_REG_BUFFERS_FLAGS;

typedef enum _NT_IORING_REG_FILES_ADV_FLAGS {
  NT_IORING_REG_FILES_ADV_FLAG_NONE = 0, // ordinal: 0x0
} _NT_IORING_REG_FILES_ADV_FLAGS;

typedef enum _NT_IORING_REG_FILES_REQ_FLAGS {
  NT_IORING_REG_FILES_REQ_FLAG_NONE = 0, // ordinal: 0x0
} _NT_IORING_REG_FILES_REQ_FLAGS;

// 0x8 bytes (sizeof)
typedef struct _NT_IORING_REG_FILES_FLAGS {
  enum _NT_IORING_REG_FILES_REQ_FLAGS Required; // offset: 0x0 ordinal: 0x0
  enum _NT_IORING_REG_FILES_ADV_FLAGS Advisory; // offset: 0x4 ordinal: 0x1
} _NT_IORING_REG_FILES_FLAGS;

typedef enum _FS_FILTER_SECTION_SYNC_TYPE {
  SyncTypeOther = 0,         // ordinal: 0x0
  SyncTypeCreateSection = 1, // ordinal: 0x1
} _FS_FILTER_SECTION_SYNC_TYPE;

typedef enum PROFILE_DEPARTURE_STYLE {
  PDS_UPDATE_DEFAULT = 1,      // ordinal: 0x0
  PDS_UPDATE_ON_REMOVE = 2,    // ordinal: 0x1
  PDS_UPDATE_ON_INTERFACE = 3, // ordinal: 0x2
  PDS_UPDATE_ON_EJECT = 4,     // ordinal: 0x3
} PROFILE_DEPARTURE_STYLE;

typedef enum _PNP_WATCHDOG_TYPE {
  PNP_WATCHDOG_NONE = 0,                    // ordinal: 0x0
  PNP_EVENT_WORKER_WATCHDOG = 1,            // ordinal: 0x1
  PNP_DEVICE_COMPLETION_QUEUE_WATCHDOG = 2, // ordinal: 0x2
  PNP_DELAYED_REMOVE_WORKER_WATCHDOG = 3,   // ordinal: 0x3
  PNP_ADD_DEVICE_WATCHDOG = 4,              // ordinal: 0x4
  PNP_DRIVER_ENTRY_WATCHDOG = 5,            // ordinal: 0x5
} _PNP_WATCHDOG_TYPE;

typedef enum _NT_WRITE_FLAGS {
  NT_WRITE_FLAG_NONE = 0,          // ordinal: 0x0
  NT_WRITE_FLAG_WRITE_THROUGH = 1, // ordinal: 0x1
} _NT_WRITE_FLAGS;

typedef enum _NT_IORING_OP_FLAGS {
  NT_IORING_OP_FLAG_NONE = 0,                // ordinal: 0x0
  NT_IORING_OP_FLAG_REGISTERED_FILE_0 = 1,   // ordinal: 0x1
  NT_IORING_OP_FLAG_REGISTERED_FILE = 1,     // ordinal: 0x2
  NT_IORING_OP_FLAG_REGISTERED_BUFFER_0 = 2, // ordinal: 0x3
  NT_IORING_OP_FLAG_REGISTERED_BUFFER = 2,   // ordinal: 0x4
} _NT_IORING_OP_FLAGS;

typedef enum _PLUGPLAY_EVENT_CATEGORY {
  HardwareProfileChangeEvent = 0,  // ordinal: 0x0
  TargetDeviceChangeEvent = 1,     // ordinal: 0x1
  DeviceClassChangeEvent = 2,      // ordinal: 0x2
  CustomDeviceEvent = 3,           // ordinal: 0x3
  DeviceInstallEvent = 4,          // ordinal: 0x4
  DeviceArrivalEvent = 5,          // ordinal: 0x5
  VetoEvent = 6,                   // ordinal: 0x6
  BlockedDriverEvent = 7,          // ordinal: 0x7
  InvalidIDEvent = 8,              // ordinal: 0x8
  DevicePropertyChangeEvent = 9,   // ordinal: 0x9
  DeviceInstanceRemovalEvent = 10, // ordinal: 0xa
  DeviceInstanceStartedEvent = 11, // ordinal: 0xb
  MaxPlugEventCategory = 12,       // ordinal: 0xc
} _PLUGPLAY_EVENT_CATEGORY;

typedef enum _PNP_VETO_TYPE {
  PNP_VetoTypeUnknown = 0,          // ordinal: 0x0
  PNP_VetoLegacyDevice = 1,         // ordinal: 0x1
  PNP_VetoPendingClose = 2,         // ordinal: 0x2
  PNP_VetoWindowsApp = 3,           // ordinal: 0x3
  PNP_VetoWindowsService = 4,       // ordinal: 0x4
  PNP_VetoOutstandingOpen = 5,      // ordinal: 0x5
  PNP_VetoDevice = 6,               // ordinal: 0x6
  PNP_VetoDriver = 7,               // ordinal: 0x7
  PNP_VetoIllegalDeviceRequest = 8, // ordinal: 0x8
  PNP_VetoInsufficientPower = 9,    // ordinal: 0x9
  PNP_VetoNonDisableable = 10,      // ordinal: 0xa
  PNP_VetoLegacyDriver = 11,        // ordinal: 0xb
  PNP_VetoInsufficientRights = 12,  // ordinal: 0xc
  PNP_VetoAlreadyRemoved = 13,      // ordinal: 0xd
} _PNP_VETO_TYPE;

typedef enum _NT_IORING_SQE_FLAGS {
  NT_IORING_SQE_FLAG_NONE = 0,                // ordinal: 0x0
  NT_IORING_SQE_FLAG_DRAIN_PRECEDING_OPS = 1, // ordinal: 0x1
} _NT_IORING_SQE_FLAGS;

typedef enum IORING_OP_CODE {
  IORING_OP_NOP = 0,              // ordinal: 0x0
  IORING_OP_READ = 1,             // ordinal: 0x1
  IORING_OP_REGISTER_FILES = 2,   // ordinal: 0x2
  IORING_OP_REGISTER_BUFFERS = 3, // ordinal: 0x3
  IORING_OP_CANCEL = 4,           // ordinal: 0x4
  IORING_OP_WRITE = 5,            // ordinal: 0x5
  IORING_OP_FLUSH = 6,            // ordinal: 0x6
} IORING_OP_CODE;

typedef enum _IOP_MC_BUFFER_ENTRY_FLAGS {
  IOP_MCBF_UNLOCK = 1,         // ordinal: 0x0
  IOP_MCBF_SIGNAL_RUNDOWN = 2, // ordinal: 0x1
  IOP_MCBF_CLEANED_UP = 4,     // ordinal: 0x2
} _IOP_MC_BUFFER_ENTRY_FLAGS;

// 0x4 bytes (sizeof)
typedef struct POHANDLE__ {
  LONG unused; // offset: 0x0 ordinal: 0x0
} POHANDLE__;

typedef enum _PNP_DEVNODE_QUERY_REBALANCE_VETO_REASON {
  DeviceQueryRebalanceSucceeded = 0,         // ordinal: 0x0
  DeviceQueryStopFailed = 1,                 // ordinal: 0x1
  DeviceFailedGetNewResourceRequirement = 2, // ordinal: 0x2
  DeviceInUnexpectedState = 3,               // ordinal: 0x3
  DeviceNotSupportQueryRebalance = 4,        // ordinal: 0x4
} _PNP_DEVNODE_QUERY_REBALANCE_VETO_REASON;

typedef enum _PNP_REBALANCE_FAILURE {
  RebalanceFailureNone = 0,                    // ordinal: 0x0
  RebalanceFailureDisabled = 1,                // ordinal: 0x1
  RebalanceFailureNoMemory = 2,                // ordinal: 0x2
  RebalanceFailureQueryStopUnexpectedVeto = 3, // ordinal: 0x3
  RebalanceFailureNoRequirements = 4,          // ordinal: 0x4
  RebalanceFailureNoCandidates = 5,            // ordinal: 0x5
  RebalanceFailureNoConfiguration = 6,         // ordinal: 0x6
} _PNP_REBALANCE_FAILURE;

typedef enum _KPROFILE_SOURCE {
  ProfileTime = 0,                  // ordinal: 0x0
  ProfileAlignmentFixup = 1,        // ordinal: 0x1
  ProfileTotalIssues = 2,           // ordinal: 0x2
  ProfilePipelineDry = 3,           // ordinal: 0x3
  ProfileLoadInstructions = 4,      // ordinal: 0x4
  ProfilePipelineFrozen = 5,        // ordinal: 0x5
  ProfileBranchInstructions = 6,    // ordinal: 0x6
  ProfileTotalNonissues = 7,        // ordinal: 0x7
  ProfileDcacheMisses = 8,          // ordinal: 0x8
  ProfileIcacheMisses = 9,          // ordinal: 0x9
  ProfileCacheMisses = 10,          // ordinal: 0xa
  ProfileBranchMispredictions = 11, // ordinal: 0xb
  ProfileStoreInstructions = 12,    // ordinal: 0xc
  ProfileFpInstructions = 13,       // ordinal: 0xd
  ProfileIntegerInstructions = 14,  // ordinal: 0xe
  Profile2Issue = 15,               // ordinal: 0xf
  Profile3Issue = 16,               // ordinal: 0x10
  Profile4Issue = 17,               // ordinal: 0x11
  ProfileSpecialInstructions = 18,  // ordinal: 0x12
  ProfileTotalCycles = 19,          // ordinal: 0x13
  ProfileIcacheIssues = 20,         // ordinal: 0x14
  ProfileDcacheAccesses = 21,       // ordinal: 0x15
  ProfileMemoryBarrierCycles = 22,  // ordinal: 0x16
  ProfileLoadLinkedIssues = 23,     // ordinal: 0x17
  ProfileMaximum = 24,              // ordinal: 0x18
} _KPROFILE_SOURCE;

typedef enum POWER_ACTION {
  PowerActionNone = 0,          // ordinal: 0x0
  PowerActionReserved = 1,      // ordinal: 0x1
  PowerActionSleep = 2,         // ordinal: 0x2
  PowerActionHibernate = 3,     // ordinal: 0x3
  PowerActionShutdown = 4,      // ordinal: 0x4
  PowerActionShutdownReset = 5, // ordinal: 0x5
  PowerActionShutdownOff = 6,   // ordinal: 0x6
  PowerActionWarmEject = 7,     // ordinal: 0x7
  PowerActionDisplayOff = 8,    // ordinal: 0x8
} POWER_ACTION;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
  DeviceUsageTypeUndefined = 0,     // ordinal: 0x0
  DeviceUsageTypePaging = 1,        // ordinal: 0x1
  DeviceUsageTypeHibernation = 2,   // ordinal: 0x2
  DeviceUsageTypeDumpFile = 3,      // ordinal: 0x3
  DeviceUsageTypeBoot = 4,          // ordinal: 0x4
  DeviceUsageTypePostDisplay = 5,   // ordinal: 0x5
  DeviceUsageTypeGuestAssigned = 6, // ordinal: 0x6
} _DEVICE_USAGE_NOTIFICATION_TYPE;

typedef enum DEVICE_TEXT_TYPE {
  DeviceTextDescription = 0,         // ordinal: 0x0
  DeviceTextLocationInformation = 1, // ordinal: 0x1
} DEVICE_TEXT_TYPE;

typedef enum BUS_QUERY_ID_TYPE {
  BusQueryDeviceID = 0,           // ordinal: 0x0
  BusQueryHardwareIDs = 1,        // ordinal: 0x1
  BusQueryCompatibleIDs = 2,      // ordinal: 0x2
  BusQueryInstanceID = 3,         // ordinal: 0x3
  BusQueryDeviceSerialNumber = 4, // ordinal: 0x4
  BusQueryContainerID = 5,        // ordinal: 0x5
} BUS_QUERY_ID_TYPE;

// 0x4 bytes (sizeof)
typedef struct __anon_1015 {
  enum BUS_QUERY_ID_TYPE IdType; // offset: 0x0 ordinal: 0x0
} __anon_1015;

typedef enum _DEVICE_RELATION_TYPE {
  BusRelations = 0,         // ordinal: 0x0
  EjectionRelations = 1,    // ordinal: 0x1
  PowerRelations = 2,       // ordinal: 0x2
  RemovalRelations = 3,     // ordinal: 0x3
  TargetDeviceRelation = 4, // ordinal: 0x4
  SingleBusRelations = 5,   // ordinal: 0x5
  TransportRelations = 6,   // ordinal: 0x6
} _DEVICE_RELATION_TYPE;

// 0x4 bytes (sizeof)
typedef struct __anon_1009 {
  enum _DEVICE_RELATION_TYPE Type; // offset: 0x0 ordinal: 0x0
} __anon_1009;

typedef enum _FSINFOCLASS {
  FileFsVolumeInformation = 1,        // ordinal: 0x0
  FileFsLabelInformation = 2,         // ordinal: 0x1
  FileFsSizeInformation = 3,          // ordinal: 0x2
  FileFsDeviceInformation = 4,        // ordinal: 0x3
  FileFsAttributeInformation = 5,     // ordinal: 0x4
  FileFsControlInformation = 6,       // ordinal: 0x5
  FileFsFullSizeInformation = 7,      // ordinal: 0x6
  FileFsObjectIdInformation = 8,      // ordinal: 0x7
  FileFsDriverPathInformation = 9,    // ordinal: 0x8
  FileFsVolumeFlagsInformation = 10,  // ordinal: 0x9
  FileFsSectorSizeInformation = 11,   // ordinal: 0xa
  FileFsDataCopyInformation = 12,     // ordinal: 0xb
  FileFsMetadataSizeInformation = 13, // ordinal: 0xc
  FileFsFullSizeInformationEx = 14,   // ordinal: 0xd
  FileFsMaximumInformation = 15,      // ordinal: 0xe
} _FSINFOCLASS;

typedef enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {
  DirectoryNotifyInformation = 1,         // ordinal: 0x0
  DirectoryNotifyExtendedInformation = 2, // ordinal: 0x1
  DirectoryNotifyFullInformation = 3,     // ordinal: 0x2
  DirectoryNotifyMaximumInformation = 4,  // ordinal: 0x3
} _DIRECTORY_NOTIFY_INFORMATION_CLASS;

typedef enum _FILE_INFORMATION_CLASS {
  FileDirectoryInformation = 1,                      // ordinal: 0x0
  FileFullDirectoryInformation = 2,                  // ordinal: 0x1
  FileBothDirectoryInformation = 3,                  // ordinal: 0x2
  FileBasicInformation = 4,                          // ordinal: 0x3
  FileStandardInformation = 5,                       // ordinal: 0x4
  FileInternalInformation = 6,                       // ordinal: 0x5
  FileEaInformation = 7,                             // ordinal: 0x6
  FileAccessInformation = 8,                         // ordinal: 0x7
  FileNameInformation = 9,                           // ordinal: 0x8
  FileRenameInformation = 10,                        // ordinal: 0x9
  FileLinkInformation = 11,                          // ordinal: 0xa
  FileNamesInformation = 12,                         // ordinal: 0xb
  FileDispositionInformation = 13,                   // ordinal: 0xc
  FilePositionInformation = 14,                      // ordinal: 0xd
  FileFullEaInformation = 15,                        // ordinal: 0xe
  FileModeInformation = 16,                          // ordinal: 0xf
  FileAlignmentInformation = 17,                     // ordinal: 0x10
  FileAllInformation = 18,                           // ordinal: 0x11
  FileAllocationInformation = 19,                    // ordinal: 0x12
  FileEndOfFileInformation = 20,                     // ordinal: 0x13
  FileAlternateNameInformation = 21,                 // ordinal: 0x14
  FileStreamInformation = 22,                        // ordinal: 0x15
  FilePipeInformation = 23,                          // ordinal: 0x16
  FilePipeLocalInformation = 24,                     // ordinal: 0x17
  FilePipeRemoteInformation = 25,                    // ordinal: 0x18
  FileMailslotQueryInformation = 26,                 // ordinal: 0x19
  FileMailslotSetInformation = 27,                   // ordinal: 0x1a
  FileCompressionInformation = 28,                   // ordinal: 0x1b
  FileObjectIdInformation = 29,                      // ordinal: 0x1c
  FileCompletionInformation = 30,                    // ordinal: 0x1d
  FileMoveClusterInformation = 31,                   // ordinal: 0x1e
  FileQuotaInformation = 32,                         // ordinal: 0x1f
  FileReparsePointInformation = 33,                  // ordinal: 0x20
  FileNetworkOpenInformation = 34,                   // ordinal: 0x21
  FileAttributeTagInformation = 35,                  // ordinal: 0x22
  FileTrackingInformation = 36,                      // ordinal: 0x23
  FileIdBothDirectoryInformation = 37,               // ordinal: 0x24
  FileIdFullDirectoryInformation = 38,               // ordinal: 0x25
  FileValidDataLengthInformation = 39,               // ordinal: 0x26
  FileShortNameInformation = 40,                     // ordinal: 0x27
  FileIoCompletionNotificationInformation = 41,      // ordinal: 0x28
  FileIoStatusBlockRangeInformation = 42,            // ordinal: 0x29
  FileIoPriorityHintInformation = 43,                // ordinal: 0x2a
  FileSfioReserveInformation = 44,                   // ordinal: 0x2b
  FileSfioVolumeInformation = 45,                    // ordinal: 0x2c
  FileHardLinkInformation = 46,                      // ordinal: 0x2d
  FileProcessIdsUsingFileInformation = 47,           // ordinal: 0x2e
  FileNormalizedNameInformation = 48,                // ordinal: 0x2f
  FileNetworkPhysicalNameInformation = 49,           // ordinal: 0x30
  FileIdGlobalTxDirectoryInformation = 50,           // ordinal: 0x31
  FileIsRemoteDeviceInformation = 51,                // ordinal: 0x32
  FileUnusedInformation = 52,                        // ordinal: 0x33
  FileNumaNodeInformation = 53,                      // ordinal: 0x34
  FileStandardLinkInformation = 54,                  // ordinal: 0x35
  FileRemoteProtocolInformation = 55,                // ordinal: 0x36
  FileRenameInformationBypassAccessCheck = 56,       // ordinal: 0x37
  FileLinkInformationBypassAccessCheck = 57,         // ordinal: 0x38
  FileVolumeNameInformation = 58,                    // ordinal: 0x39
  FileIdInformation = 59,                            // ordinal: 0x3a
  FileIdExtdDirectoryInformation = 60,               // ordinal: 0x3b
  FileReplaceCompletionInformation = 61,             // ordinal: 0x3c
  FileHardLinkFullIdInformation = 62,                // ordinal: 0x3d
  FileIdExtdBothDirectoryInformation = 63,           // ordinal: 0x3e
  FileDispositionInformationEx = 64,                 // ordinal: 0x3f
  FileRenameInformationEx = 65,                      // ordinal: 0x40
  FileRenameInformationExBypassAccessCheck = 66,     // ordinal: 0x41
  FileDesiredStorageClassInformation = 67,           // ordinal: 0x42
  FileStatInformation = 68,                          // ordinal: 0x43
  FileMemoryPartitionInformation = 69,               // ordinal: 0x44
  FileStatLxInformation = 70,                        // ordinal: 0x45
  FileCaseSensitiveInformation = 71,                 // ordinal: 0x46
  FileLinkInformationEx = 72,                        // ordinal: 0x47
  FileLinkInformationExBypassAccessCheck = 73,       // ordinal: 0x48
  FileStorageReserveIdInformation = 74,              // ordinal: 0x49
  FileCaseSensitiveInformationForceAccessCheck = 75, // ordinal: 0x4a
  FileKnownFolderInformation = 76,                   // ordinal: 0x4b
  FileMaximumInformation = 77,                       // ordinal: 0x4c
} _FILE_INFORMATION_CLASS;

typedef enum _NT_IORING_SQ_FLAGS {
  NT_IORING_SQ_FLAG_NONE = 0, // ordinal: 0x0
} _NT_IORING_SQ_FLAGS;

typedef enum _NT_IORING_CREATE_ADVISORY_FLAGS {
  NT_IORING_CREATE_ADVISORY_FLAG_NONE = 0, // ordinal: 0x0
} _NT_IORING_CREATE_ADVISORY_FLAGS;

typedef enum _NT_IORING_CREATE_REQUIRED_FLAGS {
  NT_IORING_CREATE_REQUIRED_FLAG_NONE = 0, // ordinal: 0x0
} _NT_IORING_CREATE_REQUIRED_FLAGS;

// 0x8 bytes (sizeof)
typedef struct _NT_IORING_CREATE_FLAGS {
  enum _NT_IORING_CREATE_REQUIRED_FLAGS Required; // offset: 0x0 ordinal: 0x0
  enum _NT_IORING_CREATE_ADVISORY_FLAGS Advisory; // offset: 0x4 ordinal: 0x1
} _NT_IORING_CREATE_FLAGS;

typedef enum _PNP_PROBLEM_CODE_LOG_OPERATION {
  ProblemCodeOpInvalid = 0, // ordinal: 0x0
  ProblemCodeOpSet = 1,     // ordinal: 0x1
  ProblemCodeOpClear = 2,   // ordinal: 0x2
  ProblemCodeOpMax = 3,     // ordinal: 0x3
} _PNP_PROBLEM_CODE_LOG_OPERATION;

typedef enum _PNP_REBALANCE_REASON {
  RebalanceReasonUnknown = 0,             // ordinal: 0x0
  RebalanceReasonRequirementsChanged = 1, // ordinal: 0x1
  RebalanceReasonNewDevice = 2,           // ordinal: 0x2
} _PNP_REBALANCE_REASON;

typedef enum _PNP_DEVICE_DELETE_TYPE {
  QueryRemoveDevice = 0,           // ordinal: 0x0
  CancelRemoveDevice = 1,          // ordinal: 0x1
  RemoveDevice = 2,                // ordinal: 0x2
  SurpriseRemoveDevice = 3,        // ordinal: 0x3
  EjectDevice = 4,                 // ordinal: 0x4
  RemoveFailedDevice = 5,          // ordinal: 0x5
  RemoveUnstartedFailedDevice = 6, // ordinal: 0x6
  MaxDeviceDeleteType = 7,         // ordinal: 0x7
} _PNP_DEVICE_DELETE_TYPE;

typedef enum IRPLOCK {
  IRPLOCK_CANCELABLE = 0,      // ordinal: 0x0
  IRPLOCK_CANCEL_STARTED = 1,  // ordinal: 0x1
  IRPLOCK_CANCEL_COMPLETE = 2, // ordinal: 0x2
  IRPLOCK_COMPLETED = 3,       // ordinal: 0x3
} IRPLOCK;

typedef enum _ETW_PERIODIC_TIMER_STATE {
  EtwpPeriodicTimerUnset = 0, // ordinal: 0x0
  EtwpPeriodicTimerSet = 1,   // ordinal: 0x1
} _ETW_PERIODIC_TIMER_STATE;

typedef enum _TOKEN_TYPE {
  TokenPrimary = 1,       // ordinal: 0x0
  TokenImpersonation = 2, // ordinal: 0x1
} _TOKEN_TYPE;

typedef enum _SECURITY_IMPERSONATION_LEVEL {
  SecurityAnonymous = 0,      // ordinal: 0x0
  SecurityIdentification = 1, // ordinal: 0x1
  SecurityImpersonation = 2,  // ordinal: 0x2
  SecurityDelegation = 3,     // ordinal: 0x3
} _SECURITY_IMPERSONATION_LEVEL;

typedef enum _ETW_BUFFER_STATE {
  EtwBufferStateFree = 0,               // ordinal: 0x0
  EtwBufferStateGeneralLogging = 1,     // ordinal: 0x1
  EtwBufferStateCSwitch = 2,            // ordinal: 0x2
  EtwBufferStateFlush = 3,              // ordinal: 0x3
  EtwBufferStatePendingCompression = 4, // ordinal: 0x4
  EtwBufferStateCompressed = 5,         // ordinal: 0x5
  EtwBufferStatePlaceholder = 6,        // ordinal: 0x6
  EtwBufferStateMaximum = 7,            // ordinal: 0x7
} _ETW_BUFFER_STATE;

typedef enum IORING_VERSION {
  IORING_VERSION_INVALID = 0, // ordinal: 0x0
  IORING_VERSION_1 = 1,       // ordinal: 0x1
  IORING_VERSION_2 = 2,       // ordinal: 0x2
  IORING_VERSION_3 = 300,     // ordinal: 0x3
} IORING_VERSION;

typedef enum _PEP_WORK_TYPE {
  PepWorkActiveComplete = 0,                    // ordinal: 0x0
  PepWorkRequestIdleState = 1,                  // ordinal: 0x1
  PepWorkDevicePower = 2,                       // ordinal: 0x2
  PepWorkRequestPowerControl = 3,               // ordinal: 0x3
  PepWorkDeviceIdle = 4,                        // ordinal: 0x4
  PepWorkCompleteIdleState = 5,                 // ordinal: 0x5
  PepWorkCompletePerfState = 6,                 // ordinal: 0x6
  PepWorkAcpiNotify = 7,                        // ordinal: 0x7
  PepWorkAcpiEvaluateControlMethodComplete = 8, // ordinal: 0x8
  PepWorkMax = 9,                               // ordinal: 0x9
} _PEP_WORK_TYPE;

typedef enum PROFILE_STATUS {
  DOCK_NOTDOCKDEVICE = 0,      // ordinal: 0x0
  DOCK_QUIESCENT = 1,          // ordinal: 0x1
  DOCK_ARRIVING = 2,           // ordinal: 0x2
  DOCK_DEPARTING = 3,          // ordinal: 0x3
  DOCK_EJECTIRP_COMPLETED = 4, // ordinal: 0x4
} PROFILE_STATUS;

typedef enum _SYSTEM_POWER_STATE {
  PowerSystemUnspecified = 0, // ordinal: 0x0
  PowerSystemWorking = 1,     // ordinal: 0x1
  PowerSystemSleeping1 = 2,   // ordinal: 0x2
  PowerSystemSleeping2 = 3,   // ordinal: 0x3
  PowerSystemSleeping3 = 4,   // ordinal: 0x4
  PowerSystemHibernate = 5,   // ordinal: 0x5
  PowerSystemShutdown = 6,    // ordinal: 0x6
  PowerSystemMaximum = 7,     // ordinal: 0x7
} _SYSTEM_POWER_STATE;

// 0x4 bytes (sizeof)
typedef struct __anon_1018 {
  enum _SYSTEM_POWER_STATE PowerState; // offset: 0x0 ordinal: 0x0
} __anon_1018;

typedef enum _INTERFACE_TYPE {
  InterfaceTypeUndefined = -1, // ordinal: 0x0
  Internal = 0,                // ordinal: 0x1
  Isa = 1,                     // ordinal: 0x2
  Eisa = 2,                    // ordinal: 0x3
  MicroChannel = 3,            // ordinal: 0x4
  TurboChannel = 4,            // ordinal: 0x5
  PCIBus = 5,                  // ordinal: 0x6
  VMEBus = 6,                  // ordinal: 0x7
  NuBus = 7,                   // ordinal: 0x8
  PCMCIABus = 8,               // ordinal: 0x9
  CBus = 9,                    // ordinal: 0xa
  MPIBus = 10,                 // ordinal: 0xb
  MPSABus = 11,                // ordinal: 0xc
  ProcessorInternal = 12,      // ordinal: 0xd
  InternalPowerBus = 13,       // ordinal: 0xe
  PNPISABus = 14,              // ordinal: 0xf
  PNPBus = 15,                 // ordinal: 0x10
  Vmcs = 16,                   // ordinal: 0x11
  ACPIBus = 17,                // ordinal: 0x12
  MaximumInterfaceType = 18,   // ordinal: 0x13
} _INTERFACE_TYPE;

typedef enum _PNP_DEVNODE_STATE {
  DeviceNodeUnspecified = 768,            // ordinal: 0x0
  DeviceNodeUninitialized = 769,          // ordinal: 0x1
  DeviceNodeUninitializedPending = 770,   // ordinal: 0x2
  DeviceNodeInitializedPending = 771,     // ordinal: 0x3
  DeviceNodeInitialized = 772,            // ordinal: 0x4
  DeviceNodeDriversAdded = 773,           // ordinal: 0x5
  DeviceNodeResourcesAssigned = 774,      // ordinal: 0x6
  DeviceNodeStartPending = 775,           // ordinal: 0x7
  DeviceNodeStartCompletion = 776,        // ordinal: 0x8
  DeviceNodeStartPostWork = 777,          // ordinal: 0x9
  DeviceNodeStarted = 778,                // ordinal: 0xa
  DeviceNodeQueryStopped = 779,           // ordinal: 0xb
  DeviceNodeStopped = 780,                // ordinal: 0xc
  DeviceNodeRestartCompletion = 781,      // ordinal: 0xd
  DeviceNodeEnumeratePending = 782,       // ordinal: 0xe
  DeviceNodeEnumerateCompletion = 783,    // ordinal: 0xf
  DeviceNodeAwaitingQueuedDeletion = 784, // ordinal: 0x10
  DeviceNodeAwaitingQueuedRemoval = 785,  // ordinal: 0x11
  DeviceNodeQueryRemoved = 786,           // ordinal: 0x12
  DeviceNodeRemovePendingCloses = 787,    // ordinal: 0x13
  DeviceNodeRemoved = 788,                // ordinal: 0x14
  DeviceNodeDeletePendingCloses = 789,    // ordinal: 0x15
  DeviceNodeDeleted = 790,                // ordinal: 0x16
  MaxDeviceNodeState = 791,               // ordinal: 0x17
} _PNP_DEVNODE_STATE;

typedef enum _POP_IRP_WATCHDOG_STATE {
  IrpWatchdogStateDisabled = 0,         // ordinal: 0x0
  IrpWatchdogStateEnabled = 1,          // ordinal: 0x1
  IrpWatchdogStateCompleted = 2,        // ordinal: 0x2
  IrpWatchdogStateBlackboxSelected = 3, // ordinal: 0x3
} _POP_IRP_WATCHDOG_STATE;

typedef enum _POP_PEP_NOTIFY_DEVICE_DSTATE_REASON {
  PepNotifyDeviceDStateReasonNone = 0,             // ordinal: 0x0
  PepNotifyDeviceDStateReasonSystemTransition = 1, // ordinal: 0x1
  PepNotifyDeviceDStateReasonDfx = 2,              // ordinal: 0x2
  PepNotifyDeviceDStateReasonMax = 3,              // ordinal: 0x3
} _POP_PEP_NOTIFY_DEVICE_DSTATE_REASON;

typedef enum _POWER_STATE_TYPE {
  SystemPowerState = 0, // ordinal: 0x0
  DevicePowerState = 1, // ordinal: 0x1
} _POWER_STATE_TYPE;

typedef enum _WNF_DATA_SCOPE {
  WnfDataScopeSystem = 0,          // ordinal: 0x0
  WnfDataScopeSession = 1,         // ordinal: 0x1
  WnfDataScopeUser = 2,            // ordinal: 0x2
  WnfDataScopeProcess = 3,         // ordinal: 0x3
  WnfDataScopeMachine = 4,         // ordinal: 0x4
  WnfDataScopePhysicalMachine = 5, // ordinal: 0x5
} _WNF_DATA_SCOPE;

typedef enum ETW_COMPRESSION_RESUMPTION_MODE {
  EtwCompressionModeRestart = 0,   // ordinal: 0x0
  EtwCompressionModeNoDisable = 1, // ordinal: 0x1
  EtwCompressionModeNoRestart = 2, // ordinal: 0x2
} ETW_COMPRESSION_RESUMPTION_MODE;

typedef enum _ETW_RT_EVENT_LOSS {
  EtwRtEventNoLoss = 0,  // ordinal: 0x0
  EtwRtEventLost = 1,    // ordinal: 0x1
  EtwRtBufferLost = 2,   // ordinal: 0x2
  EtwRtBackupLost = 3,   // ordinal: 0x3
  EtwRtEventLossMax = 4, // ordinal: 0x4
} _ETW_RT_EVENT_LOSS;

typedef enum _POP_FX_ACCOUNTING_MODE {
  PopFxAccountingModeDisabled = 0, // ordinal: 0x0
  PopFxAccountingModeBasic = 1,    // ordinal: 0x1
  PopFxAccountingModeEnhanced = 2, // ordinal: 0x2
  PopFxAccountingModeMax = 3,      // ordinal: 0x3
} _POP_FX_ACCOUNTING_MODE;

// 0x4 bytes (sizeof)
typedef struct PEPHANDLE__ {
  LONG unused; // offset: 0x0 ordinal: 0x0
} PEPHANDLE__;

typedef enum _PROCESSOR_PRESENCE {
  ProcessorPresenceNt = 0,     // ordinal: 0x0
  ProcessorPresenceHv = 1,     // ordinal: 0x1
  ProcessorPresenceHidden = 2, // ordinal: 0x2
} _PROCESSOR_PRESENCE;

// 0x4 bytes (sizeof)
typedef union _POWER_STATE {
  enum _SYSTEM_POWER_STATE SystemState; // offset: 0x0 ordinal: 0x0
  enum _DEVICE_POWER_STATE DeviceState; // offset: 0x0 ordinal: 0x1
} _POWER_STATE;

typedef enum _POP_DEVICE_IDLE_TYPE {
  DeviceIdleNormal = 0, // ordinal: 0x0
  DeviceIdleDisk = 1,   // ordinal: 0x1
} _POP_DEVICE_IDLE_TYPE;

typedef enum _IO_ALLOCATION_ACTION {
  KeepObject = 1,                    // ordinal: 0x0
  DeallocateObject = 2,              // ordinal: 0x1
  DeallocateObjectKeepRegisters = 3, // ordinal: 0x2
} _IO_ALLOCATION_ACTION;

typedef enum PPM_IDLE_BUCKET_TIME_TYPE {
  PpmIdleBucketTimeInQpc = 0,   // ordinal: 0x0
  PpmIdleBucketTimeIn100ns = 1, // ordinal: 0x1
  PpmIdleBucketTimeMaximum = 2, // ordinal: 0x2
} PPM_IDLE_BUCKET_TIME_TYPE;

typedef enum _PROCESSOR_CACHE_TYPE {
  CacheUnified = 0,     // ordinal: 0x0
  CacheInstruction = 1, // ordinal: 0x1
  CacheData = 2,        // ordinal: 0x2
  CacheTrace = 3,       // ordinal: 0x3
} _PROCESSOR_CACHE_TYPE;

typedef enum _POOL_TYPE {
  NonPagedPool = 0,                          // ordinal: 0x0
  NonPagedPoolExecute = 0,                   // ordinal: 0x1
  PagedPool = 1,                             // ordinal: 0x2
  NonPagedPoolMustSucceed = 2,               // ordinal: 0x3
  DontUseThisType = 3,                       // ordinal: 0x4
  NonPagedPoolCacheAligned = 4,              // ordinal: 0x5
  PagedPoolCacheAligned = 5,                 // ordinal: 0x6
  NonPagedPoolCacheAlignedMustS = 6,         // ordinal: 0x7
  MaxPoolType = 7,                           // ordinal: 0x8
  NonPagedPoolBase = 0,                      // ordinal: 0x9
  NonPagedPoolBaseMustSucceed = 2,           // ordinal: 0xa
  NonPagedPoolBaseCacheAligned = 4,          // ordinal: 0xb
  NonPagedPoolBaseCacheAlignedMustS = 6,     // ordinal: 0xc
  NonPagedPoolSession = 32,                  // ordinal: 0xd
  PagedPoolSession = 33,                     // ordinal: 0xe
  NonPagedPoolMustSucceedSession = 34,       // ordinal: 0xf
  DontUseThisTypeSession = 35,               // ordinal: 0x10
  NonPagedPoolCacheAlignedSession = 36,      // ordinal: 0x11
  PagedPoolCacheAlignedSession = 37,         // ordinal: 0x12
  NonPagedPoolCacheAlignedMustSSession = 38, // ordinal: 0x13
  NonPagedPoolNx = 512,                      // ordinal: 0x14
  NonPagedPoolNxCacheAligned = 516,          // ordinal: 0x15
  NonPagedPoolSessionNx = 544,               // ordinal: 0x16
} _POOL_TYPE;

typedef enum _HARDWARE_COUNTER_TYPE {
  PMCCounter = 0,             // ordinal: 0x0
  MaxHardwareCounterType = 1, // ordinal: 0x1
} _HARDWARE_COUNTER_TYPE;

typedef enum _FUNCTION_TABLE_TYPE {
  RF_SORTED = 0,         // ordinal: 0x0
  RF_UNSORTED = 1,       // ordinal: 0x1
  RF_CALLBACK = 2,       // ordinal: 0x2
  RF_KERNEL_DYNAMIC = 3, // ordinal: 0x3
} _FUNCTION_TABLE_TYPE;

typedef enum _NT_PRODUCT_TYPE {
  NtProductWinNt = 1,    // ordinal: 0x0
  NtProductLanManNt = 2, // ordinal: 0x1
  NtProductServer = 3,   // ordinal: 0x2
} _NT_PRODUCT_TYPE;

typedef enum _KCLOCK_TIMER_DEADLINE_TYPE {
  KClockTimerKTimerExpirationNonHr = 0,        // ordinal: 0x0
  KClockTimerKTimerExpirationPseudoHr = 1,     // ordinal: 0x1
  KClockTimerKTimer2ExpirationHr = 2,          // ordinal: 0x2
  KClockTimerKTimersMax = 2,                   // ordinal: 0x3
  KClockTimerQuantumEnd = 3,                   // ordinal: 0x4
  KClockTimerGroupSchedulingGenerationEnd = 4, // ordinal: 0x5
  KClockTimerIdlePromotion = 5,                // ordinal: 0x6
  KClockTimerBamQosHysteresisEnd = 6,          // ordinal: 0x7
  KClockTimerMax = 7,                          // ordinal: 0x8
} _KCLOCK_TIMER_DEADLINE_TYPE;

typedef enum _KCLOCK_TIMER_ONE_SHOT_STATE {
  KClockTimerOneShotUnarmed = 0,       // ordinal: 0x0
  KClockTimerOneShotArmed = 1,         // ordinal: 0x1
  KClockTimerOneShotRearmRequired = 2, // ordinal: 0x2
  KClockTimerOneShotInvalid = 3,       // ordinal: 0x3
} _KCLOCK_TIMER_ONE_SHOT_STATE;

typedef enum _KHETERO_CPU_QOS {
  KHeteroCpuQosDefault = 0,    // ordinal: 0x0
  KHeteroCpuQosHigh = 0,       // ordinal: 0x1
  KHeteroCpuQosMedium = 1,     // ordinal: 0x2
  KHeteroCpuQosLow = 2,        // ordinal: 0x3
  KHeteroCpuQosMultimedia = 3, // ordinal: 0x4
  KHeteroCpuQosDeadline = 4,   // ordinal: 0x5
  KHeteroCpuQosEco = 5,        // ordinal: 0x6
  KHeteroCpuQosUtility = 6,    // ordinal: 0x7
  KHeteroCpuQosDynamic = 7,    // ordinal: 0x8
  KHeteroCpuQosMax = 7,        // ordinal: 0x9
} _KHETERO_CPU_QOS;

typedef enum _PROC_HYPERVISOR_STATE {
  ProcHypervisorNone = 0,       // ordinal: 0x0
  ProcHypervisorPresent = 1,    // ordinal: 0x1
  ProcHypervisorPower = 2,      // ordinal: 0x2
  ProcHypervisorHvCounters = 3, // ordinal: 0x3
} _PROC_HYPERVISOR_STATE;

typedef enum _SERVERSILO_STATE {
  SERVERSILO_INITING = 0,       // ordinal: 0x0
  SERVERSILO_STARTED = 1,       // ordinal: 0x1
  SERVERSILO_SHUTTING_DOWN = 2, // ordinal: 0x2
  SERVERSILO_TERMINATING = 3,   // ordinal: 0x3
  SERVERSILO_TERMINATED = 4,    // ordinal: 0x4
} _SERVERSILO_STATE;

// 0x0 bytes (sizeof)
typedef struct _CHPEV2_PROCESS_INFO {
} _CHPEV2_PROCESS_INFO;

// 0x0 bytes (sizeof)
typedef struct _ASSEMBLY_STORAGE_MAP {
} _ASSEMBLY_STORAGE_MAP;

// 0x0 bytes (sizeof)
typedef struct _JOB_NET_RATE_CONTROL {
} _JOB_NET_RATE_CONTROL;

// 0x0 bytes (sizeof)
typedef struct _PSP_STORAGE {
} _PSP_STORAGE;

// 0x0 bytes (sizeof)
typedef struct _JOB_CPU_RATE_CONTROL {
} _JOB_CPU_RATE_CONTROL;

// 0x0 bytes (sizeof)
typedef struct _JOB_NOTIFICATION_INFORMATION {
} _JOB_NOTIFICATION_INFORMATION;

// 0x0 bytes (sizeof)
typedef struct _JOB_ACCESS_STATE {
} _JOB_ACCESS_STATE;

typedef short SHORT;

typedef long long LONGLONG;

typedef enum _SYSTEM_DLL_TYPE {
  PsNativeSystemDll = 0,       // ordinal: 0x0
  PsWowX86SystemDll = 1,       // ordinal: 0x1
  PsWowArm32SystemDll = 2,     // ordinal: 0x2
  PsWowChpeX86SystemDll = 3,   // ordinal: 0x3
  PsChpeV2SystemDll = 4,       // ordinal: 0x4
  PsVsmEnclaveRuntimeDll = 5,  // ordinal: 0x5
  PsTrustedAppsRuntimeDll = 6, // ordinal: 0x6
  PsSystemDllTotalTypes = 7,   // ordinal: 0x7
} _SYSTEM_DLL_TYPE;

typedef enum _IO_SESSION_STATE {
  IoSessionStateCreated = 1,              // ordinal: 0x0
  IoSessionStateInitialized = 2,          // ordinal: 0x1
  IoSessionStateConnected = 3,            // ordinal: 0x2
  IoSessionStateDisconnected = 4,         // ordinal: 0x3
  IoSessionStateDisconnectedLoggedOn = 5, // ordinal: 0x4
  IoSessionStateLoggedOn = 6,             // ordinal: 0x5
  IoSessionStateLoggedOff = 7,            // ordinal: 0x6
  IoSessionStateTerminated = 8,           // ordinal: 0x7
  IoSessionStateMax = 9,                  // ordinal: 0x8
} _IO_SESSION_STATE;

// 0x8 bytes (sizeof)
typedef struct _ARBITER_ADD_RESERVED_PARAMETERS {
  struct _DEVICE_OBJECT *ReserveDevice; // offset: 0x0 ordinal: 0x0
} _ARBITER_ADD_RESERVED_PARAMETERS;

// 0x0 bytes (sizeof)
typedef struct _PS_SYSCALL_PROVIDER {
} _PS_SYSCALL_PROVIDER;

// 0x0 bytes (sizeof)
typedef struct _PO_PROCESS_ENERGY_CONTEXT {
} _PO_PROCESS_ENERGY_CONTEXT;

// 0x0 bytes (sizeof)
typedef struct _EPROCESS_QUOTA_BLOCK {
} _EPROCESS_QUOTA_BLOCK;

// 0x0 bytes (sizeof)
typedef struct _PAGEFAULT_HISTORY {
} _PAGEFAULT_HISTORY;

// 0x44 bytes (sizeof)
typedef struct _IO_APIC_REGISTERS {
  ULONG RegisterIndex;  // offset: 0x0 ordinal: 0x0
  ULONG Reserved1[3];   // offset: 0x4 ordinal: 0x1
  ULONG RegisterValue;  // offset: 0x10 ordinal: 0x2
  ULONG Reserved2[11];  // offset: 0x14 ordinal: 0x3
  ULONG EndOfInterrupt; // offset: 0x40 ordinal: 0x4
} _IO_APIC_REGISTERS;

// 0x10 bytes (sizeof)
typedef struct _HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS {
  ULONGLONG SmallPagesInUseWithinLarge;  // offset: 0x0 ordinal: 0x0
  ULONGLONG OpportunisticLargePageCount; // offset: 0x8 ordinal: 0x1
} _HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS;

// 0x8 bytes (sizeof)
typedef struct _RTL_AVL_TREE {
  struct _RTL_BALANCED_NODE *Root; // offset: 0x0 ordinal: 0x0
} _RTL_AVL_TREE;

// 0x10 bytes (sizeof)
typedef struct _HIVE_WRITE_WAIT_QUEUE {
  struct _ETHREAD *ActiveThread;      // offset: 0x0 ordinal: 0x0
  struct _HIVE_WAIT_PACKET *WaitList; // offset: 0x8 ordinal: 0x1
} _HIVE_WRITE_WAIT_QUEUE;

// 0x4 bytes (sizeof)
typedef struct __anon_2846 {
  SHORT Type;           // offset: 0x0 ordinal: 0x0
  SHORT DataInfoOffset; // offset: 0x2 ordinal: 0x1
} __anon_2846;

// 0x4 bytes (sizeof)
typedef struct __anon_2844 {
  SHORT DataLength;  // offset: 0x0 ordinal: 0x0
  SHORT TotalLength; // offset: 0x2 ordinal: 0x1
} __anon_2844;

// 0x10 bytes (sizeof)
typedef struct _TIME_FIELDS {
  SHORT Year;         // offset: 0x0 ordinal: 0x0
  SHORT Month;        // offset: 0x2 ordinal: 0x1
  SHORT Day;          // offset: 0x4 ordinal: 0x2
  SHORT Hour;         // offset: 0x6 ordinal: 0x3
  SHORT Minute;       // offset: 0x8 ordinal: 0x4
  SHORT Second;       // offset: 0xa ordinal: 0x5
  SHORT Milliseconds; // offset: 0xc ordinal: 0x6
  SHORT Weekday;      // offset: 0xe ordinal: 0x7
} _TIME_FIELDS;

// 0x8 bytes (sizeof)
typedef struct __anon_3564 {
  struct _MDL *Mdl; // offset: 0x0 ordinal: 0x0
} __anon_3564;

// 0x1 bytes (sizeof)
typedef union __anon_4013 {
  UCHAR AsUCHAR;                // offset: 0x0 ordinal: 0x0
  UCHAR NoDomainAccounting : 1; // offset: 0x0 ordinal: 0x1
  UCHAR IncreasePolicy : 2;     // offset: 0x0 ordinal: 0x2
  UCHAR DecreasePolicy : 2;     // offset: 0x0 ordinal: 0x3
  UCHAR Reserved : 3;           // offset: 0x0 ordinal: 0x4
} __anon_4013;

// 0x1 bytes (sizeof)
typedef struct __anon_3854 {
  UCHAR StopRequired; // offset: 0x0 ordinal: 0x0
} __anon_3854;

// 0x1 bytes (sizeof)
typedef struct __anon_3853 {
  UCHAR ClearWaitingForFdo; // offset: 0x0 ordinal: 0x0
} __anon_3853;

// 0x1 bytes (sizeof)
typedef struct __anon_3696 {
  UCHAR EntireWsle; // offset: 0x0 ordinal: 0x0
} __anon_3696;

// 0x1 bytes (sizeof)
typedef struct __anon_3695 {
  UCHAR Age : 4;        // offset: 0x0 ordinal: 0x0
  UCHAR Protection : 3; // offset: 0x0 ordinal: 0x1
  UCHAR Reserved : 1;   // offset: 0x0 ordinal: 0x2
} __anon_3695;

// 0x1 bytes (sizeof)
typedef union __anon_3681 {
  struct __anon_3695 e1; // offset: 0x0 ordinal: 0x0
  struct __anon_3696 e2; // offset: 0x0 ordinal: 0x1
} __anon_3681;

// 0x1 bytes (sizeof)
typedef struct _MI_WSLE {
  union __anon_3681 u1; // offset: 0x0 ordinal: 0x0
} _MI_WSLE;

// 0x1 bytes (sizeof)
typedef union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
  UCHAR Trustlet : 1;    // offset: 0x0 ordinal: 0x0
  UCHAR Ntos : 1;        // offset: 0x0 ordinal: 0x1
  UCHAR WriteHandle : 1; // offset: 0x0 ordinal: 0x2
  UCHAR ReadHandle : 1;  // offset: 0x0 ordinal: 0x3
  UCHAR Reserved : 4;    // offset: 0x0 ordinal: 0x4
  UCHAR AccessRights;    // offset: 0x0 ordinal: 0x5
} _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS;

// 0x1 bytes (sizeof)
typedef union _IOMMU_ATS_SETTINGS {
  UCHAR AtsSupported : 1; // offset: 0x0 ordinal: 0x0
  UCHAR AtsRequired : 1;  // offset: 0x0 ordinal: 0x1
  UCHAR Rsvd : 6;         // offset: 0x0 ordinal: 0x2
  UCHAR AsUCHAR;          // offset: 0x0 ordinal: 0x3
} _IOMMU_ATS_SETTINGS;

// 0x2 bytes (sizeof)
typedef struct __anon_3383 {
  UCHAR SecondaryBus;   // offset: 0x0 ordinal: 0x0
  UCHAR SubordinateBus; // offset: 0x1 ordinal: 0x1
} __anon_3383;

// 0x4 bytes (sizeof)
typedef struct __anon_3382 {
  UCHAR Bus;      // offset: 0x0 ordinal: 0x0
  UCHAR Device;   // offset: 0x1 ordinal: 0x1
  UCHAR Function; // offset: 0x2 ordinal: 0x2
  UCHAR Reserved; // offset: 0x3 ordinal: 0x3
} __anon_3382;

typedef UCHAR (*__anon_3292)(UCHAR);

// 0x1e bytes (sizeof)
typedef struct _TOKEN_AUDIT_POLICY {
  UCHAR PerUserPolicy[30]; // offset: 0x0 ordinal: 0x0
} _TOKEN_AUDIT_POLICY;

// 0x1f bytes (sizeof)
typedef struct _SEP_AUDIT_POLICY {
  struct _TOKEN_AUDIT_POLICY AdtTokenPolicy; // offset: 0x0 ordinal: 0x0
  UCHAR PolicySetStatus;                     // offset: 0x1e ordinal: 0x1
} _SEP_AUDIT_POLICY;

// 0x1 bytes (sizeof)
typedef struct _ETW_LOGGER_HANDLE {
  UCHAR DereferenceAndLeave; // offset: 0x0 ordinal: 0x0
} _ETW_LOGGER_HANDLE;

// 0x4 bytes (sizeof)
typedef struct __anon_2968 {
  UCHAR MajorVersion;    // offset: 0x0 ordinal: 0x0
  UCHAR MinorVersion;    // offset: 0x1 ordinal: 0x1
  UCHAR SubVersion;      // offset: 0x2 ordinal: 0x2
  UCHAR SubMinorVersion; // offset: 0x3 ordinal: 0x3
} __anon_2968;

// 0x1 bytes (sizeof)
typedef struct __anon_2855 {
  UCHAR ReferenceCache : 1; // offset: 0x0 ordinal: 0x0
  UCHAR Lookaside : 1;      // offset: 0x0 ordinal: 0x1
  UCHAR Initializing : 1;   // offset: 0x0 ordinal: 0x2
  UCHAR Deleted : 1;        // offset: 0x0 ordinal: 0x3
} __anon_2855;

// 0x1 bytes (sizeof)
typedef union __anon_2856 {
  struct __anon_2855 s1; // offset: 0x0 ordinal: 0x0
  UCHAR Flags;           // offset: 0x0 ordinal: 0x1
} __anon_2856;

// 0x2 bytes (sizeof)
typedef struct _HEAP_LFH_SUBSEGMENT_STAT {
  UCHAR Index; // offset: 0x0 ordinal: 0x0
  UCHAR Count; // offset: 0x1 ordinal: 0x1
} _HEAP_LFH_SUBSEGMENT_STAT;

// 0x1 bytes (sizeof)
typedef union __anon_2780 {
  UCHAR LargePagePolicy : 3;       // offset: 0x0 ordinal: 0x0
  UCHAR FullDecommit : 1;          // offset: 0x0 ordinal: 0x1
  UCHAR ReleaseEmptySegments : 1;  // offset: 0x0 ordinal: 0x2
  UCHAR LargeHeapFirstSegment : 1; // offset: 0x0 ordinal: 0x3
  UCHAR AllFlags;                  // offset: 0x0 ordinal: 0x4
} __anon_2780;

// 0x8 bytes (sizeof)
typedef union __anon_2702 {
  struct _CC_PARTITION *Partition; // offset: 0x0 ordinal: 0x0
  struct _PRIVATE_VOLUME_CACHEMAP
      *PrivateVolumeCacheMap; // offset: 0x0 ordinal: 0x1
} __anon_2702;

// 0x10 bytes (sizeof)
typedef struct _CC_LWS_PACKET {
  enum _CC_LWS_PACKET_TYPE Type; // offset: 0x0 ordinal: 0x0
  UCHAR Active;                  // offset: 0x4 ordinal: 0x1
  union __anon_2702 Overlay;     // offset: 0x8 ordinal: 0x2
} _CC_LWS_PACKET;

// 0x4 bytes (sizeof)
typedef struct _MMPAGE_FILE_EXPANSION_FLAGS {
  UCHAR PageFileNumber : 8;        // offset: 0x0 ordinal: 0x0
  UCHAR Spare1 : 8;                // offset: 0x1 ordinal: 0x1
  UCHAR Spare2 : 8;                // offset: 0x2 ordinal: 0x2
  UCHAR IgnoreCurrentCommit : 1;   // offset: 0x3 ordinal: 0x3
  UCHAR IncreaseMinimumSize : 1;   // offset: 0x3 ordinal: 0x4
  UCHAR AttemptForCantExtend : 1;  // offset: 0x3 ordinal: 0x5
  UCHAR UnusedSegmentDeletion : 1; // offset: 0x3 ordinal: 0x6
  UCHAR PageFileContract : 1;      // offset: 0x3 ordinal: 0x7
  UCHAR NoWait : 1;                // offset: 0x3 ordinal: 0x8
  UCHAR Spare3 : 2;                // offset: 0x3 ordinal: 0x9
} _MMPAGE_FILE_EXPANSION_FLAGS;

// 0x3 bytes (sizeof)
typedef struct _MI_RESTRICTED_MODWRITES {
  UCHAR MaximumClusterPages;  // offset: 0x0 ordinal: 0x0
  UCHAR ReducedClusterWrites; // offset: 0x1 ordinal: 0x1
  UCHAR ImposeDelay;          // offset: 0x2 ordinal: 0x2
} _MI_RESTRICTED_MODWRITES;

// 0x1 bytes (sizeof)
typedef struct __anon_2121 {
  UCHAR ModifiedListBucketIndex : 4; // offset: 0x0 ordinal: 0x0
} __anon_2121;

// 0x1 bytes (sizeof)
typedef struct _MMPFNENTRY3 {
  UCHAR Priority : 3;           // offset: 0x0 ordinal: 0x0
  UCHAR OnProtectedStandby : 1; // offset: 0x0 ordinal: 0x1
  UCHAR InPageError : 1;        // offset: 0x0 ordinal: 0x2
  UCHAR SystemChargedPage : 1;  // offset: 0x0 ordinal: 0x3
  UCHAR RemovalRequested : 1;   // offset: 0x0 ordinal: 0x4
  UCHAR ParityError : 1;        // offset: 0x0 ordinal: 0x5
} _MMPFNENTRY3;

// 0x1 bytes (sizeof)
typedef struct _MMPFNENTRY1 {
  UCHAR PageLocation : 3;    // offset: 0x0 ordinal: 0x0
  UCHAR WriteInProgress : 1; // offset: 0x0 ordinal: 0x1
  UCHAR Modified : 1;        // offset: 0x0 ordinal: 0x2
  UCHAR ReadInProgress : 1;  // offset: 0x0 ordinal: 0x3
  UCHAR CacheAttribute : 2;  // offset: 0x0 ordinal: 0x4
} _MMPFNENTRY1;

// 0x20 bytes (sizeof)
typedef struct wil_details_FeatureTestState {
  enum wil_details_FeatureTestStateKind kind;     // offset: 0x0 ordinal: 0x0
  ULONG featureId;                                // offset: 0x4 ordinal: 0x1
  enum wil_FeatureEnabledState state;             // offset: 0x8 ordinal: 0x2
  UCHAR variant;                                  // offset: 0xc ordinal: 0x3
  ULONG payload;                                  // offset: 0x10 ordinal: 0x4
  enum wil_FeatureVariantPayloadKind payloadKind; // offset: 0x14 ordinal: 0x5
  struct wil_details_FeatureTestState *next;      // offset: 0x18 ordinal: 0x6
} wil_details_FeatureTestState;

// 0x18 bytes (sizeof)
typedef struct wil_FeatureState {
  enum wil_FeatureEnabledState enabledState;      // offset: 0x0 ordinal: 0x0
  UCHAR variant;                                  // offset: 0x4 ordinal: 0x1
  enum wil_FeatureVariantPayloadKind payloadKind; // offset: 0x8 ordinal: 0x2
  ULONG payload;                                  // offset: 0xc ordinal: 0x3
  LONG hasNotification;                           // offset: 0x10 ordinal: 0x4
  LONG isWexpConfiguration;                       // offset: 0x14 ordinal: 0x5
} wil_FeatureState;

// 0x1 bytes (sizeof)
typedef struct __anon_2005 {
  UCHAR ProcessorOnly : 1;      // offset: 0x0 ordinal: 0x0
  UCHAR GroupsAssigned : 1;     // offset: 0x0 ordinal: 0x1
  UCHAR MeasurableDistance : 1; // offset: 0x0 ordinal: 0x2
} __anon_2005;

typedef UCHAR (*__anon_1853)();

// 0x1 bytes (sizeof)
typedef struct __anon_1767 {
  UCHAR EnableTranslation : 1; // offset: 0x0 ordinal: 0x0
  UCHAR Reserved : 7;          // offset: 0x0 ordinal: 0x1
} __anon_1767;

// 0x1 bytes (sizeof)
typedef struct __anon_1728 {
  UCHAR DefaultDomain : 1;  // offset: 0x0 ordinal: 0x0
  UCHAR FirmwareDomain : 1; // offset: 0x0 ordinal: 0x1
} __anon_1728;

// 0x1 bytes (sizeof)
typedef union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
  UCHAR FRUId : 1;    // offset: 0x0 ordinal: 0x0
  UCHAR FRUText : 1;  // offset: 0x0 ordinal: 0x1
  UCHAR Reserved : 6; // offset: 0x0 ordinal: 0x2
  UCHAR AsUCHAR;      // offset: 0x0 ordinal: 0x3
} _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS;

// 0x1 bytes (sizeof)
typedef union _XPF_MC_BANK_FLAGS {
  UCHAR ClearOnInitializationRW : 1; // offset: 0x0 ordinal: 0x0
  UCHAR ControlDataRW : 1;           // offset: 0x0 ordinal: 0x1
  UCHAR Reserved : 6;                // offset: 0x0 ordinal: 0x2
  UCHAR AsUCHAR;                     // offset: 0x0 ordinal: 0x3
} _XPF_MC_BANK_FLAGS;

// 0x4 bytes (sizeof)
typedef struct __anon_1293 {
  UCHAR BaseMiddle; // offset: 0x0 ordinal: 0x0
  UCHAR Flags1;     // offset: 0x1 ordinal: 0x1
  UCHAR Flags2;     // offset: 0x2 ordinal: 0x2
  UCHAR BaseHigh;   // offset: 0x3 ordinal: 0x3
} __anon_1293;

// 0x1 bytes (sizeof)
typedef struct __anon_1014 {
  UCHAR Lock; // offset: 0x0 ordinal: 0x0
} __anon_1014;

// 0x10 bytes (sizeof)
typedef struct _PEP_WORK_DEVICE_IDLE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  UCHAR IgnoreIdleTimeout;         // offset: 0x8 ordinal: 0x1
} _PEP_WORK_DEVICE_IDLE;

// 0x10 bytes (sizeof)
typedef struct _PEP_WORK_DEVICE_POWER {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  UCHAR PowerRequired;             // offset: 0x8 ordinal: 0x1
} _PEP_WORK_DEVICE_POWER;

typedef UCHAR (*__anon_786)(struct _FILE_OBJECT *, struct _MDL *,
                            struct _DEVICE_OBJECT *);

// 0x4 bytes (sizeof)
typedef struct _KHETERO_HWFEEDBACK_CLASS {
  UCHAR PerformanceClass;         // offset: 0x0 ordinal: 0x0
  UCHAR EfficiencyClass;          // offset: 0x1 ordinal: 0x1
  UCHAR PerformanceClassRawValue; // offset: 0x2 ordinal: 0x2
  UCHAR EfficiencyClassRawValue;  // offset: 0x3 ordinal: 0x3
} _KHETERO_HWFEEDBACK_CLASS;

// 0x2 bytes (sizeof)
typedef struct _ETW_SYSTEM_LOGGER {
  UCHAR LoggerId;  // offset: 0x0 ordinal: 0x0
  UCHAR ClockType; // offset: 0x1 ordinal: 0x1
} _ETW_SYSTEM_LOGGER;

// 0x1 bytes (sizeof)
typedef union _KHETERO_STATE {
  UCHAR Qos : 3;           // offset: 0x0 ordinal: 0x0
  UCHAR WorkloadClass : 3; // offset: 0x0 ordinal: 0x1
  UCHAR RunningType : 1;   // offset: 0x0 ordinal: 0x2
  UCHAR AllFields;         // offset: 0x0 ordinal: 0x3
} _KHETERO_STATE;

// 0x2 bytes (sizeof)
typedef struct _PROC_PERF_LOAD {
  UCHAR BusyPercentage;      // offset: 0x0 ordinal: 0x0
  UCHAR FrequencyPercentage; // offset: 0x1 ordinal: 0x1
} _PROC_PERF_LOAD;

// 0x1 bytes (sizeof)
typedef struct _flags {
  UCHAR SmtSetsPresent : 1; // offset: 0x0 ordinal: 0x0
  UCHAR Fill : 7;           // offset: 0x0 ordinal: 0x1
} _flags;

// 0x6 bytes (sizeof)
typedef struct _PROC_IDLE_POLICY {
  UCHAR PromotePercent;     // offset: 0x0 ordinal: 0x0
  UCHAR DemotePercent;      // offset: 0x1 ordinal: 0x1
  UCHAR PromotePercentBase; // offset: 0x2 ordinal: 0x2
  UCHAR DemotePercentBase;  // offset: 0x3 ordinal: 0x3
  UCHAR AllowScaling;       // offset: 0x4 ordinal: 0x4
  UCHAR ForceLightIdle;     // offset: 0x5 ordinal: 0x5
} _PROC_IDLE_POLICY;

// 0x1 bytes (sizeof)
typedef union _KPRIORITY_STATE {
  UCHAR Priority : 7;       // offset: 0x0 ordinal: 0x0
  UCHAR IsolationWidth : 1; // offset: 0x0 ordinal: 0x1
  UCHAR AllFields;          // offset: 0x0 ordinal: 0x2
} _KPRIORITY_STATE;

// 0x8 bytes (sizeof)
typedef struct __anon_3548 {
  UCHAR Pch;                // offset: 0x0 ordinal: 0x0
  UCHAR EmbeddedController; // offset: 0x1 ordinal: 0x1
  UCHAR Reserved[6];        // offset: 0x2 ordinal: 0x2
} __anon_3548;

// 0x6 bytes (sizeof)
typedef struct _SID_IDENTIFIER_AUTHORITY {
  UCHAR Value[6]; // offset: 0x0 ordinal: 0x0
} _SID_IDENTIFIER_AUTHORITY;

// 0x48 bytes (sizeof)
typedef struct _KCORE_CONTROL_BLOCK {
  UCHAR ProcessorCount;    // offset: 0x0 ordinal: 0x0
  UCHAR ScanStartIndex;    // offset: 0x1 ordinal: 0x1
  UCHAR Spare[6];          // offset: 0x2 ordinal: 0x2
  struct _KPRCB *Prcbs[8]; // offset: 0x8 ordinal: 0x3
} _KCORE_CONTROL_BLOCK;

// 0x10 bytes (sizeof)
typedef struct _VF_ADDRESS_RANGE {
  UCHAR *Start; // offset: 0x0 ordinal: 0x0
  UCHAR *End;   // offset: 0x8 ordinal: 0x1
} _VF_ADDRESS_RANGE;

// 0x10 bytes (sizeof)
typedef struct __anon_1017 {
  UCHAR InPath;                              // offset: 0x0 ordinal: 0x0
  UCHAR Reserved[3];                         // offset: 0x1 ordinal: 0x1
  enum _DEVICE_USAGE_NOTIFICATION_TYPE Type; // offset: 0x8 ordinal: 0x2
} __anon_1017;

// 0x50 bytes (sizeof)
typedef struct _RTL_FUNCTION_OVERRIDE_CAPABILITIES {
  UCHAR AMD64Capabilities[40];       // offset: 0x0 ordinal: 0x0
  UCHAR AMD64KernelCapabilities[40]; // offset: 0x28 ordinal: 0x1
} _RTL_FUNCTION_OVERRIDE_CAPABILITIES;

// 0x1 bytes (sizeof)
typedef union _KWAIT_STATUS_REGISTER {
  UCHAR Flags;        // offset: 0x0 ordinal: 0x0
  UCHAR State : 3;    // offset: 0x0 ordinal: 0x1
  UCHAR Affinity : 1; // offset: 0x0 ordinal: 0x2
  UCHAR Priority : 1; // offset: 0x0 ordinal: 0x3
  UCHAR Apc : 1;      // offset: 0x0 ordinal: 0x4
  UCHAR UserApc : 1;  // offset: 0x0 ordinal: 0x5
  UCHAR Alert : 1;    // offset: 0x0 ordinal: 0x6
} _KWAIT_STATUS_REGISTER;

// 0x10 bytes (sizeof)
typedef struct _RTL_RB_TREE {
  struct _RTL_BALANCED_NODE *Root; // offset: 0x0 ordinal: 0x0
  UCHAR Encoded : 1;               // offset: 0x8 ordinal: 0x1
  struct _RTL_BALANCED_NODE *Min;  // offset: 0x8 ordinal: 0x2
} _RTL_RB_TREE;

// 0x1 bytes (sizeof)
typedef union _KEXECUTE_OPTIONS {
  UCHAR ExecuteDisable : 1;                  // offset: 0x0 ordinal: 0x0
  UCHAR ExecuteEnable : 1;                   // offset: 0x0 ordinal: 0x1
  UCHAR DisableThunkEmulation : 1;           // offset: 0x0 ordinal: 0x2
  UCHAR Permanent : 1;                       // offset: 0x0 ordinal: 0x3
  UCHAR ExecuteDispatchEnable : 1;           // offset: 0x0 ordinal: 0x4
  UCHAR ImageDispatchEnable : 1;             // offset: 0x0 ordinal: 0x5
  UCHAR DisableExceptionChainValidation : 1; // offset: 0x0 ordinal: 0x6
  UCHAR Spare : 1;                           // offset: 0x0 ordinal: 0x7
  UCHAR ExecuteOptions;                      // offset: 0x0 ordinal: 0x8
  UCHAR ExecuteOptionsNV;                    // offset: 0x0 ordinal: 0x9
} _KEXECUTE_OPTIONS;

// 0x1 bytes (sizeof)
typedef struct _PS_PROTECTION {
  union {
    UCHAR Level;    // offset: 0x0 ordinal: 0x0
    UCHAR Type : 3; // offset: 0x0 ordinal: 0x1
  };
  UCHAR Audit : 1;  // offset: 0x0 ordinal: 0x2
  UCHAR Signer : 4; // offset: 0x0 ordinal: 0x3
} _PS_PROTECTION;

// 0x10 bytes (sizeof)
typedef struct _MM_SYSTEM_PAGE_COUNTS {
  ULONG SystemCodePage;        // offset: 0x0 ordinal: 0x0
  ULONG SystemDriverPage;      // offset: 0x4 ordinal: 0x1
  LONG TotalSystemCodePages;   // offset: 0x8 ordinal: 0x2
  LONG TotalSystemDriverPages; // offset: 0xc ordinal: 0x3
} _MM_SYSTEM_PAGE_COUNTS;

// 0x10 bytes (sizeof)
typedef struct _MI_COMBINE_PAGE_LISTHEAD {
  struct _RTL_AVL_TREE Table; // offset: 0x0 ordinal: 0x0
  LONG Lock;                  // offset: 0x8 ordinal: 0x1
} _MI_COMBINE_PAGE_LISTHEAD;

// 0x10 bytes (sizeof)
typedef struct _COPY_INFORMATION {
  struct _FILE_OBJECT *SourceFileObject; // offset: 0x0 ordinal: 0x0
  LONGLONG SourceFileOffset;             // offset: 0x8 ordinal: 0x1
} _COPY_INFORMATION;

// 0x8 bytes (sizeof)
typedef struct _QUAD {
  union {
    LONGLONG UseThisFieldToCopy; // offset: 0x0 ordinal: 0x0
    double DoNotUseThisField;    // offset: 0x0 ordinal: 0x1
  };
} _QUAD;

// 0x8 bytes (sizeof)
typedef struct _UNEXPECTED_INTERRUPT {
  UCHAR PushImm;  // offset: 0x0 ordinal: 0x0
  UCHAR Vector;   // offset: 0x1 ordinal: 0x1
  UCHAR PushRbp;  // offset: 0x2 ordinal: 0x2
  UCHAR JmpOp;    // offset: 0x3 ordinal: 0x3
  LONG JmpOffset; // offset: 0x4 ordinal: 0x4
} _UNEXPECTED_INTERRUPT;

// 0x8 bytes (sizeof)
typedef struct _ISR_THUNK {
  UCHAR PushImm;  // offset: 0x0 ordinal: 0x0
  UCHAR Vector;   // offset: 0x1 ordinal: 0x1
  UCHAR PushRbp;  // offset: 0x2 ordinal: 0x2
  UCHAR JmpOp;    // offset: 0x3 ordinal: 0x3
  LONG JmpOffset; // offset: 0x4 ordinal: 0x4
} _ISR_THUNK;

typedef LONG (*__anon_3346)(struct _BUS_HANDLER *);

typedef LONG (*__anon_3291)(UCHAR (*)(struct _KINTERRUPT *, VOID *));

typedef LONG (*__anon_3268)(enum _SYSTEM_POWER_STATE);

// 0x8 bytes (sizeof)
typedef struct _VACB_LEVEL_REFERENCE {
  LONG Reference;        // offset: 0x0 ordinal: 0x0
  LONG SpecialReference; // offset: 0x4 ordinal: 0x1
} _VACB_LEVEL_REFERENCE;

// 0x4 bytes (sizeof)
typedef struct _DBGKD_CONTINUE {
  LONG ContinueStatus; // offset: 0x0 ordinal: 0x0
} _DBGKD_CONTINUE;

// 0x18 bytes (sizeof)
typedef struct _ETW_PERF_COUNTERS {
  LONG TotalActiveSessions;           // offset: 0x0 ordinal: 0x0
  LONG TotalBufferMemoryNonPagedPool; // offset: 0x4 ordinal: 0x1
  LONG TotalBufferMemoryPagedPool;    // offset: 0x8 ordinal: 0x2
  LONG TotalGuidsEnabled;             // offset: 0xc ordinal: 0x3
  LONG TotalGuidsNotEnabled;          // offset: 0x10 ordinal: 0x4
  LONG TotalGuidsPreEnabled;          // offset: 0x14 ordinal: 0x5
} _ETW_PERF_COUNTERS;

// 0x4 bytes (sizeof)
typedef union __anon_2159 {
  LONG FlushCompleting : 1;  // offset: 0x0 ordinal: 0x0
  LONG FlushInProgress : 31; // offset: 0x0 ordinal: 0x1
  LONG Long;                 // offset: 0x0 ordinal: 0x2
} __anon_2159;

typedef LONG (*__anon_1878)(UCHAR *);

typedef LONG (*__anon_1869)(UCHAR);

typedef LONG (*__anon_1839)();

typedef LONG (*__anon_1838)(ULONG);

typedef LONG (*__anon_1837)(ULONG, UCHAR, UCHAR);

// 0x10 bytes (sizeof)
typedef struct _DMA_ADAPTER {
  USHORT Version;                        // offset: 0x0 ordinal: 0x0
  USHORT Size;                           // offset: 0x2 ordinal: 0x1
  struct _DMA_OPERATIONS *DmaOperations; // offset: 0x8 ordinal: 0x2
} _DMA_ADAPTER;

typedef LONG (*__anon_1608)(struct _DMA_ADAPTER *);

typedef LONG (*__anon_1607)(struct _DMA_ADAPTER *, struct _MDL *, UCHAR);

typedef LONG (*__anon_791)(struct _FILE_OBJECT *, struct _DEVICE_OBJECT *);

typedef LONG (*__anon_686)(struct _DEVICE_OBJECT *, struct _IRP *);

// 0x10 bytes (sizeof)
typedef struct _ETW_COUNTERS {
  LONG GuidCount;    // offset: 0x0 ordinal: 0x0
  LONG PoolUsage[2]; // offset: 0x4 ordinal: 0x1
  LONG SessionCount; // offset: 0xc ordinal: 0x2
} _ETW_COUNTERS;

typedef VOID (*__anon_3309)(struct _DEVICE_OBJECT *);

typedef VOID (*__anon_3271)(struct _HAL_PMC_COUNTERS *);

typedef VOID (*__anon_3267)(struct _MDL *, UCHAR);

typedef VOID (*__anon_3260)(UCHAR, UCHAR);

typedef VOID (*__anon_3254)(enum _SYSTEM_POWER_STATE);

typedef VOID (*__anon_3233)(UCHAR);

typedef VOID (*__anon_1761)(struct _IOMMU_DMA_LOGICAL_ALLOCATOR *);

typedef VOID (*__anon_1605)(struct _DMA_ADAPTER *, enum _IO_ALLOCATION_ACTION);

typedef VOID (*__anon_1581)(struct _DMA_ADAPTER *);

typedef VOID (*__anon_782)(struct _DEVICE_OBJECT *, struct _DEVICE_OBJECT *);

typedef VOID (*__anon_781)(struct _FILE_OBJECT *);

typedef VOID (*__anon_574)(struct _DEVICE_OBJECT *, struct _IRP *);

typedef VOID (*__anon_256)();

// 0x10 bytes (sizeof)
typedef struct __anon_4047 {
  VOID *UserData; // offset: 0x0 ordinal: 0x0
  VOID *Owner;    // offset: 0x8 ordinal: 0x1
} __anon_4047;

typedef VOID (*__anon_3992)(VOID *, struct _IRP *);

// 0x200 bytes (sizeof)
typedef struct _IOV_FORCED_PENDING_TRACE {
  struct _IRP *Irp;        // offset: 0x0 ordinal: 0x0
  struct _ETHREAD *Thread; // offset: 0x8 ordinal: 0x1
  VOID *StackTrace[62];    // offset: 0x10 ordinal: 0x2
} _IOV_FORCED_PENDING_TRACE;

// 0x48 bytes (sizeof)
typedef struct _FAST_OWNER_ENTRY {
  VOID *Reserved[9]; // offset: 0x0 ordinal: 0x0
} _FAST_OWNER_ENTRY;

// 0x10 bytes (sizeof)
typedef struct _VF_TRACKER_STAMP {
  VOID *Thread;        // offset: 0x0 ordinal: 0x0
  UCHAR Flags : 8;     // offset: 0x8 ordinal: 0x1
  UCHAR OldIrql : 8;   // offset: 0x9 ordinal: 0x2
  UCHAR NewIrql : 8;   // offset: 0xa ordinal: 0x3
  UCHAR Processor : 8; // offset: 0xb ordinal: 0x4
} _VF_TRACKER_STAMP;

// 0x8 bytes (sizeof)
typedef struct _KWAIT_CHAIN {
  VOID *Head; // offset: 0x0 ordinal: 0x0
} _KWAIT_CHAIN;

// 0x20 bytes (sizeof)
typedef struct _MI_DLL_OVERFLOW_AREA {
  VOID *RangeStart;         // offset: 0x0 ordinal: 0x0
  VOID *NextVa;             // offset: 0x8 ordinal: 0x1
  VOID *RangeStartAbove2gb; // offset: 0x10 ordinal: 0x2
  VOID *NextVaAbove2gb;     // offset: 0x18 ordinal: 0x3
} _MI_DLL_OVERFLOW_AREA;

typedef LONG (*__anon_3437)(VOID *, VOID *, UCHAR);

// 0x18 bytes (sizeof)
typedef struct _NLS_DATA_BLOCK {
  VOID *AnsiCodePageData;     // offset: 0x0 ordinal: 0x0
  VOID *OemCodePageData;      // offset: 0x8 ordinal: 0x1
  VOID *UnicodeCaseTableData; // offset: 0x10 ordinal: 0x2
} _NLS_DATA_BLOCK;

// 0x10 bytes (sizeof)
typedef struct _DEBUG_IOMMU_EFI_DATA {
  VOID *PciIoProtocolHandle; // offset: 0x0 ordinal: 0x0
  VOID *Mapping;             // offset: 0x8 ordinal: 0x1
} _DEBUG_IOMMU_EFI_DATA;

// 0x18 bytes (sizeof)
typedef struct _HAL_LBR_ENTRY {
  VOID *FromAddress; // offset: 0x0 ordinal: 0x0
  VOID *ToAddress;   // offset: 0x8 ordinal: 0x1
  VOID *Reserved;    // offset: 0x10 ordinal: 0x2
} _HAL_LBR_ENTRY;

// 0x10 bytes (sizeof)
typedef struct _MAP_REGISTER_ENTRY {
  VOID *MapRegister;   // offset: 0x0 ordinal: 0x0
  UCHAR WriteToDevice; // offset: 0x8 ordinal: 0x1
} _MAP_REGISTER_ENTRY;

typedef VOID *(*__anon_3284)();

// 0x48 bytes (sizeof)
typedef struct _VI_FAULT_TRACE {
  struct _ETHREAD *Thread; // offset: 0x0 ordinal: 0x0
  VOID *StackTrace[8];     // offset: 0x8 ordinal: 0x1
} _VI_FAULT_TRACE;

// 0x40 bytes (sizeof)
typedef struct _VF_KE_CRITICAL_REGION_TRACE {
  struct _ETHREAD *Thread; // offset: 0x0 ordinal: 0x0
  VOID *StackTrace[7];     // offset: 0x8 ordinal: 0x1
} _VF_KE_CRITICAL_REGION_TRACE;

// 0x10 bytes (sizeof)
typedef struct _OB_EXTENDED_USER_INFO {
  VOID *Context1; // offset: 0x0 ordinal: 0x0
  VOID *Context2; // offset: 0x8 ordinal: 0x1
} _OB_EXTENDED_USER_INFO;

// 0x8 bytes (sizeof)
typedef struct _ALPC_HANDLE_ENTRY {
  VOID *Object; // offset: 0x0 ordinal: 0x0
} _ALPC_HANDLE_ENTRY;

// 0x8 bytes (sizeof)
typedef union _HEAP_LFH_SUBSEGMENT_STATS {
  struct _HEAP_LFH_SUBSEGMENT_STAT Buckets[4]; // offset: 0x0 ordinal: 0x0
  VOID *AllStats;                              // offset: 0x0 ordinal: 0x1
} _HEAP_LFH_SUBSEGMENT_STATS;

// 0x10 bytes (sizeof)
typedef struct __anon_2712 {
  struct _FILE_OBJECT *FileObject; // offset: 0x0 ordinal: 0x0
  VOID *DiskIoAttribution;         // offset: 0x8 ordinal: 0x1
} __anon_2712;

typedef UCHAR (*__anon_2697)(VOID *, UCHAR);

// 0x8 bytes (sizeof)
typedef struct _CMSI_RW_LOCK {
  VOID *Reserved; // offset: 0x0 ordinal: 0x0
} _CMSI_RW_LOCK;

// 0x18 bytes (sizeof)
typedef struct _SECTION_OBJECT_POINTERS {
  VOID *DataSectionObject;  // offset: 0x0 ordinal: 0x0
  VOID *SharedCacheMap;     // offset: 0x8 ordinal: 0x1
  VOID *ImageSectionObject; // offset: 0x10 ordinal: 0x2
} _SECTION_OBJECT_POINTERS;

// 0xa8 bytes (sizeof)
typedef struct _PS_NTDLL_EXPORTS {
  VOID *LdrSystemDllInitBlock;                   // offset: 0x0 ordinal: 0x0
  VOID *LdrInitializeThunk;                      // offset: 0x8 ordinal: 0x1
  VOID *RtlUserThreadStart;                      // offset: 0x10 ordinal: 0x2
  VOID *RtlUserFiberStart;                       // offset: 0x18 ordinal: 0x3
  VOID *KiUserExceptionDispatcher;               // offset: 0x20 ordinal: 0x4
  VOID *KiUserApcDispatcher;                     // offset: 0x28 ordinal: 0x5
  VOID *KiUserCallbackDispatcher;                // offset: 0x30 ordinal: 0x6
  VOID *KiUserCallbackDispatcherReturn;          // offset: 0x38 ordinal: 0x7
  VOID *KiRaiseUserExceptionDispatcher;          // offset: 0x40 ordinal: 0x8
  VOID *ExpInterlockedPopEntrySListEnd;          // offset: 0x48 ordinal: 0x9
  VOID *ExpInterlockedPopEntrySListFault;        // offset: 0x50 ordinal: 0xa
  VOID *ExpInterlockedPopEntrySListResume;       // offset: 0x58 ordinal: 0xb
  VOID *RtlpFreezeTimeBias;                      // offset: 0x60 ordinal: 0xc
  VOID *KiUserInvertedFunctionTable;             // offset: 0x68 ordinal: 0xd
  VOID *WerReportExceptionWorker;                // offset: 0x70 ordinal: 0xe
  VOID *RtlCallEnclaveReturn;                    // offset: 0x78 ordinal: 0xf
  VOID *RtlEnclaveCallDispatch;                  // offset: 0x80 ordinal: 0x10
  VOID *RtlEnclaveCallDispatchReturn;            // offset: 0x88 ordinal: 0x11
  VOID *RtlRaiseExceptionForReturnAddressHijack; // offset: 0x90 ordinal: 0x12
  VOID *KiUserEmulationDispatcher;               // offset: 0x98 ordinal: 0x13
  VOID *LdrHotPatchNotify;                       // offset: 0xa0 ordinal: 0x14
} _PS_NTDLL_EXPORTS;

typedef VOID (*__anon_1955)(struct _TP_CALLBACK_INSTANCE *, VOID *);

typedef VOID (*__anon_1954)(VOID *, VOID *);

typedef LONG (*__anon_1879)(VOID *, ULONG, UCHAR);

// 0x10 bytes (sizeof)
typedef struct _EXT_IOMMU_S1_X64_DOMAIN_SETTINGS {
  struct __anon_1767 Flags; // offset: 0x0 ordinal: 0x0
  VOID *PasidTable;         // offset: 0x8 ordinal: 0x1
} _EXT_IOMMU_S1_X64_DOMAIN_SETTINGS;

typedef VOID (*__anon_1695)(struct _EXT_IOMMU *, struct _EXT_IOMMU_DOMAIN *,
                            VOID *);

typedef LONG (*__anon_1694)(struct _EXT_IOMMU *, struct _EXT_IOMMU_DOMAIN *,
                            struct _EXT_IOMMU_DOMAIN *, VOID *);

typedef VOID (*__anon_1616)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *,
                            VOID *, enum DMA_COMPLETION_STATUS);

typedef VOID *(*__anon_1609)(struct _DMA_ADAPTER *);

typedef UCHAR (*__anon_1600)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *,
                             VOID *);

typedef LONG (*__anon_1596)(struct _DMA_ADAPTER *, VOID *);

// 0x20 bytes (sizeof)
typedef struct _SECURITY_SUBJECT_CONTEXT {
  VOID *ClientToken; // offset: 0x0 ordinal: 0x0
  enum _SECURITY_IMPERSONATION_LEVEL
      ImpersonationLevel; // offset: 0x8 ordinal: 0x1
  VOID *PrimaryToken;     // offset: 0x10 ordinal: 0x2
  VOID *ProcessAuditId;   // offset: 0x18 ordinal: 0x3
} _SECURITY_SUBJECT_CONTEXT;

// 0x10 bytes (sizeof)
typedef struct IORING_BUFFER_INFO {
  VOID *Address; // offset: 0x0 ordinal: 0x0
  ULONG Length;  // offset: 0x8 ordinal: 0x1
} IORING_BUFFER_INFO;

// 0x18 bytes (sizeof)
typedef struct _NT_IORING_OP_REGISTER_BUFFERS {
  enum _NT_IORING_OP_FLAGS CommonOpFlags;    // offset: 0x0 ordinal: 0x0
  struct _NT_IORING_REG_BUFFERS_FLAGS Flags; // offset: 0x4 ordinal: 0x1
  ULONG Count;                               // offset: 0xc ordinal: 0x2
  struct IORING_BUFFER_INFO *Buffers;        // offset: 0x10 ordinal: 0x3
} _NT_IORING_OP_REGISTER_BUFFERS;

// 0x8 bytes (sizeof)
typedef struct __anon_1206 {
  VOID *Notification; // offset: 0x0 ordinal: 0x0
} __anon_1206;

// 0x8 bytes (sizeof)
typedef union _NT_IORING_BUFFERREF {
  VOID *Address;                               // offset: 0x0 ordinal: 0x0
  struct IORING_REGISTERED_BUFFER FixedBuffer; // offset: 0x0 ordinal: 0x1
} _NT_IORING_BUFFERREF;

// 0x8 bytes (sizeof)
typedef union _NT_IORING_HANDLEREF {
  VOID *Handle;      // offset: 0x0 ordinal: 0x0
  ULONG HandleIndex; // offset: 0x0 ordinal: 0x1
} _NT_IORING_HANDLEREF;

// 0x28 bytes (sizeof)
typedef struct __anon_1189 {
  VOID *Argument1; // offset: 0x0 ordinal: 0x0
  VOID *Argument2; // offset: 0x8 ordinal: 0x1
  VOID *Argument3; // offset: 0x10 ordinal: 0x2
  VOID *Argument4; // offset: 0x18 ordinal: 0x3
  VOID *Argument5; // offset: 0x20 ordinal: 0x4
} __anon_1189;

typedef LONG (*__anon_1174)(VOID *, VOID *);

typedef LONG (*__anon_1173)(VOID *);

typedef VOID (*__anon_1096)(VOID *, UCHAR);

typedef LONG (*__anon_1024)(struct _DEVICE_OBJECT *, struct _IRP *, VOID *);

// 0x20 bytes (sizeof)
typedef struct __anon_1023 {
  VOID *Argument1; // offset: 0x0 ordinal: 0x0
  VOID *Argument2; // offset: 0x8 ordinal: 0x1
  VOID *Argument3; // offset: 0x10 ordinal: 0x2
  VOID *Argument4; // offset: 0x18 ordinal: 0x3
} __anon_1023;

// 0x10 bytes (sizeof)
typedef struct _PEP_CRASHDUMP_INFORMATION {
  struct PEPHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  VOID *DeviceContext;              // offset: 0x8 ordinal: 0x1
} _PEP_CRASHDUMP_INFORMATION;

typedef UCHAR (*__anon_757)(struct _PEP_CRASHDUMP_INFORMATION *);

// 0x10 bytes (sizeof)
typedef struct _IO_CLIENT_EXTENSION {
  struct _IO_CLIENT_EXTENSION *NextExtension; // offset: 0x0 ordinal: 0x0
  VOID *ClientIdentificationAddress;          // offset: 0x8 ordinal: 0x1
} _IO_CLIENT_EXTENSION;

typedef VOID (*__anon_768)(VOID *, VOID *, VOID *, VOID *);

typedef UCHAR (*__anon_718)(VOID *);

typedef enum _IO_ALLOCATION_ACTION (*__anon_579)(struct _DEVICE_OBJECT *,
                                                 struct _IRP *, VOID *, VOID *);

typedef VOID (*__anon_578)(struct _DEVICE_OBJECT *, VOID *);

// 0x80 bytes (sizeof)
typedef struct _OBJECT_REF_TRACE {
  VOID *StackTrace[16]; // offset: 0x0 ordinal: 0x0
} _OBJECT_REF_TRACE;

// 0x8 bytes (sizeof)
typedef union __anon_488 {
  struct _IRP *MasterIrp; // offset: 0x0 ordinal: 0x0
  LONG IrpCount;          // offset: 0x0 ordinal: 0x1
  VOID *SystemBuffer;     // offset: 0x0 ordinal: 0x2
} __anon_488;

typedef VOID (*__anon_343)(VOID *, VOID *, VOID *);

// 0x20 bytes (sizeof)
typedef struct _KREQUEST_PACKET {
  VOID *CurrentPacket[3]; // offset: 0x0 ordinal: 0x0
  VOID(*WorkerRoutine)
  (VOID *, VOID *, VOID *, VOID *); // offset: 0x18 ordinal: 0x1
} _KREQUEST_PACKET;

// 0x18 bytes (sizeof)
typedef struct _IO_COMPLETION_CONTEXT {
  VOID *Port;          // offset: 0x0 ordinal: 0x0
  VOID *Key;           // offset: 0x8 ordinal: 0x1
  LONGLONG UsageCount; // offset: 0x10 ordinal: 0x2
} _IO_COMPLETION_CONTEXT;

// 0x10 bytes (sizeof)
typedef struct _TERMINATION_PORT {
  struct _TERMINATION_PORT *Next; // offset: 0x0 ordinal: 0x0
  VOID *Port;                     // offset: 0x8 ordinal: 0x1
} _TERMINATION_PORT;

// 0x10 bytes (sizeof)
typedef struct RTL_HP_ENV_HANDLE {
  VOID *h[2]; // offset: 0x0 ordinal: 0x0
} RTL_HP_ENV_HANDLE;

typedef LONG (*__anon_3256)(VOID *, VOID **);

typedef LONG (*__anon_1880)(UCHAR, VOID **);

// 0x18 bytes (sizeof)
typedef struct _NT_IORING_OP_REGISTER_FILES {
  enum _NT_IORING_OP_FLAGS CommonOpFlags;  // offset: 0x0 ordinal: 0x0
  struct _NT_IORING_REG_FILES_FLAGS Flags; // offset: 0x4 ordinal: 0x1
  ULONG Count;                             // offset: 0xc ordinal: 0x2
  VOID **Handles;                          // offset: 0x10 ordinal: 0x3
} _NT_IORING_OP_REGISTER_FILES;

// 0x10 bytes (sizeof)
typedef struct _CLIENT_ID {
  VOID *UniqueProcess; // offset: 0x0 ordinal: 0x0
  VOID *UniqueThread;  // offset: 0x8 ordinal: 0x1
} _CLIENT_ID;

// 0x10 bytes (sizeof)
typedef struct _EWOW64PROCESS {
  VOID *Peb;                       // offset: 0x0 ordinal: 0x0
  enum _SYSTEM_DLL_TYPE NtdllType; // offset: 0x8 ordinal: 0x1
} _EWOW64PROCESS;

typedef VOID (*__anon_40)(VOID *);

// 0x20 bytes (sizeof)
typedef struct _CACHE_MANAGER_CALLBACKS {
  UCHAR (*AcquireForLazyWrite)(VOID *, UCHAR); // offset: 0x0 ordinal: 0x0
  VOID (*ReleaseFromLazyWrite)(VOID *);        // offset: 0x8 ordinal: 0x1
  UCHAR (*AcquireForReadAhead)(VOID *, UCHAR); // offset: 0x10 ordinal: 0x2
  VOID (*ReleaseFromReadAhead)(VOID *);        // offset: 0x18 ordinal: 0x3
} _CACHE_MANAGER_CALLBACKS;

// 0x20 bytes (sizeof)
typedef struct _RTL_BALANCED_LINKS {
  struct _RTL_BALANCED_LINKS *Parent;     // offset: 0x0 ordinal: 0x0
  struct _RTL_BALANCED_LINKS *LeftChild;  // offset: 0x8 ordinal: 0x1
  struct _RTL_BALANCED_LINKS *RightChild; // offset: 0x10 ordinal: 0x2
  CHAR Balance;                           // offset: 0x18 ordinal: 0x3
  UCHAR Reserved[3];                      // offset: 0x19 ordinal: 0x4
} _RTL_BALANCED_LINKS;

// 0x28 bytes (sizeof)
typedef struct _KTMOBJECT_NAMESPACE_LINK {
  struct _RTL_BALANCED_LINKS Links; // offset: 0x0 ordinal: 0x0
  UCHAR Expired;                    // offset: 0x20 ordinal: 0x1
} _KTMOBJECT_NAMESPACE_LINK;

// 0x1 bytes (sizeof)
typedef struct _WDT_HANDLE {
  CHAR Reserved; // offset: 0x0 ordinal: 0x0
} _WDT_HANDLE;

// 0x30 bytes (sizeof)
typedef struct _iobuf {
  CHAR *_ptr;      // offset: 0x0 ordinal: 0x0
  LONG _cnt;       // offset: 0x8 ordinal: 0x1
  CHAR *_base;     // offset: 0x10 ordinal: 0x2
  LONG _flag;      // offset: 0x18 ordinal: 0x3
  LONG _file;      // offset: 0x1c ordinal: 0x4
  LONG _charbuf;   // offset: 0x20 ordinal: 0x5
  LONG _bufsiz;    // offset: 0x24 ordinal: 0x6
  CHAR *_tmpfname; // offset: 0x28 ordinal: 0x7
} _iobuf;

// 0x2 bytes (sizeof)
typedef struct __anon_1210 {
  WCHAR ParentId[1]; // offset: 0x0 ordinal: 0x0
} __anon_1210;

// 0x8 bytes (sizeof)
typedef struct __anon_1208 {
  enum _PNP_VETO_TYPE VetoType;    // offset: 0x0 ordinal: 0x0
  WCHAR DeviceIdVetoNameBuffer[1]; // offset: 0x4 ordinal: 0x1
} __anon_1208;

// 0x10 bytes (sizeof)
typedef struct __anon_1205 {
  VOID *NotificationStructure; // offset: 0x0 ordinal: 0x0
  WCHAR DeviceId[1];           // offset: 0x8 ordinal: 0x1
} __anon_1205;

// 0x2 bytes (sizeof)
typedef struct __anon_1204 {
  WCHAR DeviceId[1]; // offset: 0x0 ordinal: 0x0
} __anon_1204;

// 0xac bytes (sizeof)
typedef struct _RTL_TIME_ZONE_INFORMATION {
  LONG Bias;                         // offset: 0x0 ordinal: 0x0
  WCHAR StandardName[32];            // offset: 0x4 ordinal: 0x1
  struct _TIME_FIELDS StandardStart; // offset: 0x44 ordinal: 0x2
  LONG StandardBias;                 // offset: 0x54 ordinal: 0x3
  WCHAR DaylightName[32];            // offset: 0x58 ordinal: 0x4
  struct _TIME_FIELDS DaylightStart; // offset: 0x98 ordinal: 0x5
  LONG DaylightBias;                 // offset: 0xa8 ordinal: 0x6
} _RTL_TIME_ZONE_INFORMATION;

// 0x1b0 bytes (sizeof)
typedef struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION {
  struct _RTL_TIME_ZONE_INFORMATION tzi; // offset: 0x0 ordinal: 0x0
  WCHAR TimeZoneKeyName[128];            // offset: 0xac ordinal: 0x1
  UCHAR DynamicDaylightTimeDisabled;     // offset: 0x1ac ordinal: 0x2
} _RTL_DYNAMIC_TIME_ZONE_INFORMATION;

// 0x4 bytes (sizeof)
typedef struct _HEAP_FREE_ENTRY_EXTRA {
  USHORT TagIndex;           // offset: 0x0 ordinal: 0x0
  USHORT FreeBackTraceIndex; // offset: 0x2 ordinal: 0x1
} _HEAP_FREE_ENTRY_EXTRA;

// 0x2 bytes (sizeof)
typedef union __anon_3705 {
  USHORT AsUSHORT;         // offset: 0x0 ordinal: 0x0
  USHORT AllowScaling : 1; // offset: 0x0 ordinal: 0x1
  USHORT Disabled : 1;     // offset: 0x0 ordinal: 0x2
  USHORT Reserved : 14;    // offset: 0x0 ordinal: 0x3
} __anon_3705;

// 0x2 bytes (sizeof)
typedef union __anon_3668 {
  USHORT SignatureLevel : 4; // offset: 0x0 ordinal: 0x0
  USHORT SignatureType : 3;  // offset: 0x0 ordinal: 0x1
  USHORT Frozen : 2;         // offset: 0x0 ordinal: 0x2
  USHORT HotPatch : 1;       // offset: 0x0 ordinal: 0x3
  USHORT Unused : 6;         // offset: 0x0 ordinal: 0x4
  USHORT EntireField;        // offset: 0x0 ordinal: 0x5
} __anon_3668;

// 0x2 bytes (sizeof)
typedef union _HAL_UNMASKED_INTERRUPT_FLAGS {
  USHORT SecondaryInterrupt : 1; // offset: 0x0 ordinal: 0x0
  USHORT Reserved : 15;          // offset: 0x0 ordinal: 0x1
  USHORT AsUSHORT;               // offset: 0x0 ordinal: 0x2
} _HAL_UNMASKED_INTERRUPT_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _MMSUBSECTION_FLAGS {
  USHORT SubsectionAccessed : 1;  // offset: 0x0 ordinal: 0x0
  USHORT Protection : 5;          // offset: 0x0 ordinal: 0x1
  USHORT StartingSector4132 : 10; // offset: 0x0 ordinal: 0x2
  USHORT SubsectionStatic : 1;    // offset: 0x2 ordinal: 0x3
  USHORT GlobalMemory : 1;        // offset: 0x2 ordinal: 0x4
  USHORT Spare : 1;               // offset: 0x2 ordinal: 0x5
  USHORT OnDereferenceList : 1;   // offset: 0x2 ordinal: 0x6
  USHORT SectorEndOffset : 12;    // offset: 0x2 ordinal: 0x7
} _MMSUBSECTION_FLAGS;

// 0x8088 bytes (sizeof)
typedef struct _STACK_TABLE {
  USHORT NumStackTraces;                    // offset: 0x0 ordinal: 0x0
  USHORT TraceCapacity;                     // offset: 0x2 ordinal: 0x1
  struct _OBJECT_REF_TRACE *StackTrace[16]; // offset: 0x8 ordinal: 0x2
  USHORT StackTableHash[16381];             // offset: 0x88 ordinal: 0x3
} _STACK_TABLE;

// 0x8 bytes (sizeof)
typedef struct _ACL {
  UCHAR AclRevision; // offset: 0x0 ordinal: 0x0
  UCHAR Sbz1;        // offset: 0x1 ordinal: 0x1
  USHORT AclSize;    // offset: 0x2 ordinal: 0x2
  USHORT AceCount;   // offset: 0x4 ordinal: 0x3
  USHORT Sbz2;       // offset: 0x6 ordinal: 0x4
} _ACL;

// 0x28 bytes (sizeof)
typedef struct _SECURITY_DESCRIPTOR {
  UCHAR Revision;    // offset: 0x0 ordinal: 0x0
  UCHAR Sbz1;        // offset: 0x1 ordinal: 0x1
  USHORT Control;    // offset: 0x2 ordinal: 0x2
  VOID *Owner;       // offset: 0x8 ordinal: 0x3
  VOID *Group;       // offset: 0x10 ordinal: 0x4
  struct _ACL *Sacl; // offset: 0x18 ordinal: 0x5
  struct _ACL *Dacl; // offset: 0x20 ordinal: 0x6
} _SECURITY_DESCRIPTOR;

// 0x10 bytes (sizeof)
typedef struct _ETW_SYSTEMTIME {
  USHORT Year;         // offset: 0x0 ordinal: 0x0
  USHORT Month;        // offset: 0x2 ordinal: 0x1
  USHORT DayOfWeek;    // offset: 0x4 ordinal: 0x2
  USHORT Day;          // offset: 0x6 ordinal: 0x3
  USHORT Hour;         // offset: 0x8 ordinal: 0x4
  USHORT Minute;       // offset: 0xa ordinal: 0x5
  USHORT Second;       // offset: 0xc ordinal: 0x6
  USHORT Milliseconds; // offset: 0xe ordinal: 0x7
} _ETW_SYSTEMTIME;

// 0x10 bytes (sizeof)
typedef struct _IO_IRP_EXT_TRACK_OFFSET_HEADER {
  USHORT Validation; // offset: 0x0 ordinal: 0x0
  USHORT Flags;      // offset: 0x2 ordinal: 0x1
  VOID(*TrackedOffsetCallback)
  (struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *,
   struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *,
   LONGLONG); // offset: 0x8 ordinal: 0x2
} _IO_IRP_EXT_TRACK_OFFSET_HEADER;

typedef VOID (*__anon_2951)(struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *,
                            struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *, LONGLONG);

// 0x2 bytes (sizeof)
typedef union _HEAP_SEGMENT_MGR_COMMIT_STATE {
  USHORT CommittedPageCount : 11;          // offset: 0x0 ordinal: 0x0
  USHORT Spare : 3;                        // offset: 0x0 ordinal: 0x1
  USHORT LargePageOperationInProgress : 1; // offset: 0x0 ordinal: 0x2
  USHORT LargePageCommit : 1;              // offset: 0x0 ordinal: 0x3
  USHORT EntireUShortV;                    // offset: 0x0 ordinal: 0x4
  USHORT EntireUShort;                     // offset: 0x0 ordinal: 0x5
} _HEAP_SEGMENT_MGR_COMMIT_STATE;

// 0x2 bytes (sizeof)
typedef struct _HEAP_VS_UNUSED_BYTES_INFO {
  USHORT UnusedBytes : 13;  // offset: 0x0 ordinal: 0x0
  USHORT LfhSubsegment : 1; // offset: 0x0 ordinal: 0x1
  USHORT ExtraPresent : 1;  // offset: 0x0 ordinal: 0x2
  USHORT OneByteUnused : 1; // offset: 0x0 ordinal: 0x3
  UCHAR Bytes[2];           // offset: 0x0 ordinal: 0x4
} _HEAP_VS_UNUSED_BYTES_INFO;

// 0x2 bytes (sizeof)
typedef struct _HEAP_LFH_UNUSED_BYTES_INFO {
  USHORT UnusedBytes : 14;  // offset: 0x0 ordinal: 0x0
  USHORT ExtraPresent : 1;  // offset: 0x0 ordinal: 0x1
  USHORT OneByteUnused : 1; // offset: 0x0 ordinal: 0x2
  UCHAR Bytes[2];           // offset: 0x0 ordinal: 0x3
} _HEAP_LFH_UNUSED_BYTES_INFO;

// 0x8 bytes (sizeof)
typedef union _HEAP_LFH_ONDEMAND_POINTER {
  USHORT Invalid : 1;              // offset: 0x0 ordinal: 0x0
  USHORT AllocationInProgress : 1; // offset: 0x0 ordinal: 0x1
  USHORT Spare0 : 14;              // offset: 0x0 ordinal: 0x2
  USHORT UsageData;                // offset: 0x2 ordinal: 0x3
  VOID *AllBits;                   // offset: 0x0 ordinal: 0x4
} _HEAP_LFH_ONDEMAND_POINTER;

// 0x4 bytes (sizeof)
typedef struct _RTL_HP_LFH_CONFIG {
  USHORT MaxBlockSize;                  // offset: 0x0 ordinal: 0x0
  USHORT WitholdPageCrossingBlocks : 1; // offset: 0x2 ordinal: 0x1
  USHORT DisableRandomization : 1;      // offset: 0x2 ordinal: 0x2
} _RTL_HP_LFH_CONFIG;

// 0x10 bytes (sizeof)
typedef struct _SEGMENT_HEAP_EXTRA {
  USHORT AllocationTag;       // offset: 0x0 ordinal: 0x0
  UCHAR InterceptorIndex : 4; // offset: 0x2 ordinal: 0x1
  UCHAR UserFlags : 4;        // offset: 0x2 ordinal: 0x2
  UCHAR ExtraSizeInUnits;     // offset: 0x3 ordinal: 0x3
  VOID *Settable;             // offset: 0x8 ordinal: 0x4
} _SEGMENT_HEAP_EXTRA;

// 0x8 bytes (sizeof)
typedef struct _PCW_COUNTER_DESCRIPTOR {
  USHORT Id;          // offset: 0x0 ordinal: 0x0
  USHORT StructIndex; // offset: 0x2 ordinal: 0x1
  USHORT Offset;      // offset: 0x4 ordinal: 0x2
  USHORT Size;        // offset: 0x6 ordinal: 0x3
} _PCW_COUNTER_DESCRIPTOR;

// 0x2 bytes (sizeof)
typedef struct _HV_GET_BIN_CONTEXT {
  USHORT OutstandingReference : 1; // offset: 0x0 ordinal: 0x0
} _HV_GET_BIN_CONTEXT;

// 0x4 bytes (sizeof)
typedef struct _MMSECTION_FLAGS2 {
  USHORT PartitionId : 10;          // offset: 0x0 ordinal: 0x0
  UCHAR NoCrossPartitionAccess : 1; // offset: 0x2 ordinal: 0x1
  UCHAR
  SubsectionCrossPartitionReferenceOverflow : 1; // offset: 0x2 ordinal: 0x2
  UCHAR UsingFileExtents : 2;                    // offset: 0x2 ordinal: 0x3
} _MMSECTION_FLAGS2;

// 0x4 bytes (sizeof)
typedef struct _SEGMENT_FLAGS {
  USHORT TotalNumberOfPtes4132 : 10; // offset: 0x0 ordinal: 0x0
  USHORT Spare0 : 1;                 // offset: 0x0 ordinal: 0x1
  USHORT SessionDriverProtos : 1;    // offset: 0x0 ordinal: 0x2
  USHORT LargePages : 1;             // offset: 0x0 ordinal: 0x3
  USHORT DebugSymbolsLoaded : 1;     // offset: 0x0 ordinal: 0x4
  USHORT WriteCombined : 1;          // offset: 0x0 ordinal: 0x5
  USHORT NoCache : 1;                // offset: 0x0 ordinal: 0x6
  USHORT Short0;                     // offset: 0x0 ordinal: 0x7
  UCHAR Spare : 1;                   // offset: 0x2 ordinal: 0x8
  UCHAR DefaultProtectionMask : 5;   // offset: 0x2 ordinal: 0x9
  UCHAR Binary32 : 1;                // offset: 0x2 ordinal: 0xa
  UCHAR ContainsDebug : 1;           // offset: 0x2 ordinal: 0xb
  UCHAR UChar1;                      // offset: 0x2 ordinal: 0xc
  UCHAR ForceCollision : 1;          // offset: 0x3 ordinal: 0xd
  UCHAR ImageSigningType : 3;        // offset: 0x3 ordinal: 0xe
  UCHAR ImageSigningLevel : 4;       // offset: 0x3 ordinal: 0xf
  UCHAR UChar2;                      // offset: 0x3 ordinal: 0x10
} _SEGMENT_FLAGS;

// 0x4 bytes (sizeof)
typedef struct __anon_2122 {
  UCHAR AnchorLargePageSize : 2; // offset: 0x0 ordinal: 0x0
  UCHAR Spare0 : 6;              // offset: 0x0 ordinal: 0x1
  UCHAR Spare1 : 8;              // offset: 0x1 ordinal: 0x2
  USHORT Spare2;                 // offset: 0x2 ordinal: 0x3
} __anon_2122;

// 0x2 bytes (sizeof)
typedef struct __anon_2111 {
  USHORT ReferenceCount; // offset: 0x0 ordinal: 0x0
} __anon_2111;

// 0x8 bytes (sizeof)
typedef struct _RTL_FEATURE_USAGE_REPORT {
  ULONG FeatureId;         // offset: 0x0 ordinal: 0x0
  USHORT ReportingKind;    // offset: 0x4 ordinal: 0x1
  USHORT ReportingOptions; // offset: 0x6 ordinal: 0x2
} _RTL_FEATURE_USAGE_REPORT;

// 0x6 bytes (sizeof)
typedef struct FEATURE_LOGGED_TRAITS {
  USHORT version;     // offset: 0x0 ordinal: 0x0
  USHORT baseVersion; // offset: 0x2 ordinal: 0x1
  UCHAR stage;        // offset: 0x4 ordinal: 0x2
} FEATURE_LOGGED_TRAITS;

// 0x68 bytes (sizeof)
typedef struct FEATURE_ERROR {
  HRESULT hr;                            // offset: 0x0 ordinal: 0x0
  USHORT lineNumber;                     // offset: 0x4 ordinal: 0x1
  CHAR *file;                            // offset: 0x8 ordinal: 0x2
  CHAR *process;                         // offset: 0x10 ordinal: 0x3
  CHAR *modulePath;                      // offset: 0x18 ordinal: 0x4
  ULONG callerReturnAddressOffset;       // offset: 0x20 ordinal: 0x5
  CHAR *callerModule;                    // offset: 0x28 ordinal: 0x6
  CHAR *message;                         // offset: 0x30 ordinal: 0x7
  USHORT originLineNumber;               // offset: 0x38 ordinal: 0x8
  CHAR *originFile;                      // offset: 0x40 ordinal: 0x9
  CHAR *originModule;                    // offset: 0x48 ordinal: 0xa
  ULONG originCallerReturnAddressOffset; // offset: 0x50 ordinal: 0xb
  CHAR *originCallerModule;              // offset: 0x58 ordinal: 0xc
  CHAR *originName;                      // offset: 0x60 ordinal: 0xd
} FEATURE_ERROR;

// 0x10 bytes (sizeof)
typedef struct _UNICODE_STRING {
  USHORT Length;        // offset: 0x0 ordinal: 0x0
  USHORT MaximumLength; // offset: 0x2 ordinal: 0x1
  WCHAR *Buffer;        // offset: 0x8 ordinal: 0x2
} _UNICODE_STRING;

// 0x2 bytes (sizeof)
typedef struct __anon_1726 {
  USHORT PciSegment : 1; // offset: 0x0 ordinal: 0x0
} __anon_1726;

// 0x2 bytes (sizeof)
typedef union _EXT_IOMMU_DEVICE_ID_FLAGS {
  USHORT AsUSHORT;      // offset: 0x0 ordinal: 0x0
  USHORT IsAliased : 1; // offset: 0x0 ordinal: 0x1
  USHORT Reserved : 15; // offset: 0x0 ordinal: 0x2
} _EXT_IOMMU_DEVICE_ID_FLAGS;

// 0x6 bytes (sizeof)
typedef struct _LOCAL_NMISOURCE {
  UCHAR Type;        // offset: 0x0 ordinal: 0x0
  UCHAR Length;      // offset: 0x1 ordinal: 0x1
  UCHAR ProcessorID; // offset: 0x2 ordinal: 0x2
  USHORT Flags;      // offset: 0x3 ordinal: 0x3
  UCHAR LINTIN;      // offset: 0x5 ordinal: 0x4
} _LOCAL_NMISOURCE;

// 0x14 bytes (sizeof)
typedef struct _XPF_RECOVERY_INFO {
  struct __anon_1441 FailureReason; // offset: 0x0 ordinal: 0x0
  struct __anon_1442 Action;        // offset: 0x4 ordinal: 0x1
  UCHAR ActionRequired;             // offset: 0x8 ordinal: 0x2
  UCHAR RecoverySucceeded;          // offset: 0x9 ordinal: 0x3
  UCHAR RecoveryKernel;             // offset: 0xa ordinal: 0x4
  UCHAR Reserved;                   // offset: 0xb ordinal: 0x5
  USHORT Reserved2;                 // offset: 0xc ordinal: 0x6
  USHORT Reserved3;                 // offset: 0xe ordinal: 0x7
  ULONG Reserved4;                  // offset: 0x10 ordinal: 0x8
} _XPF_RECOVERY_INFO;

// 0x2 bytes (sizeof)
typedef union _WHEA_REVISION {
  UCHAR MinorRevision; // offset: 0x0 ordinal: 0x0
  UCHAR MajorRevision; // offset: 0x1 ordinal: 0x1
  USHORT AsUSHORT;     // offset: 0x0 ordinal: 0x2
} _WHEA_REVISION;

// 0x2 bytes (sizeof)
typedef union _WHEA_NOTIFICATION_FLAGS {
  USHORT PollIntervalRW : 1;             // offset: 0x0 ordinal: 0x0
  USHORT SwitchToPollingThresholdRW : 1; // offset: 0x0 ordinal: 0x1
  USHORT SwitchToPollingWindowRW : 1;    // offset: 0x0 ordinal: 0x2
  USHORT ErrorThresholdRW : 1;           // offset: 0x0 ordinal: 0x3
  USHORT ErrorThresholdWindowRW : 1;     // offset: 0x0 ordinal: 0x4
  USHORT Reserved : 11;                  // offset: 0x0 ordinal: 0x5
  USHORT AsUSHORT;                       // offset: 0x0 ordinal: 0x6
} _WHEA_NOTIFICATION_FLAGS;

// 0x2 bytes (sizeof)
typedef union _AER_BRIDGE_DESCRIPTOR_FLAGS {
  USHORT UncorrectableErrorMaskRW : 1;          // offset: 0x0 ordinal: 0x0
  USHORT UncorrectableErrorSeverityRW : 1;      // offset: 0x0 ordinal: 0x1
  USHORT CorrectableErrorMaskRW : 1;            // offset: 0x0 ordinal: 0x2
  USHORT AdvancedCapsAndControlRW : 1;          // offset: 0x0 ordinal: 0x3
  USHORT SecondaryUncorrectableErrorMaskRW : 1; // offset: 0x0 ordinal: 0x4
  USHORT SecondaryUncorrectableErrorSevRW : 1;  // offset: 0x0 ordinal: 0x5
  USHORT SecondaryCapsAndControlRW : 1;         // offset: 0x0 ordinal: 0x6
  USHORT Reserved : 9;                          // offset: 0x0 ordinal: 0x7
  USHORT AsUSHORT;                              // offset: 0x0 ordinal: 0x8
} _AER_BRIDGE_DESCRIPTOR_FLAGS;

// 0x2 bytes (sizeof)
typedef union _AER_ENDPOINT_DESCRIPTOR_FLAGS {
  USHORT UncorrectableErrorMaskRW : 1;     // offset: 0x0 ordinal: 0x0
  USHORT UncorrectableErrorSeverityRW : 1; // offset: 0x0 ordinal: 0x1
  USHORT CorrectableErrorMaskRW : 1;       // offset: 0x0 ordinal: 0x2
  USHORT AdvancedCapsAndControlRW : 1;     // offset: 0x0 ordinal: 0x3
  USHORT Reserved : 12;                    // offset: 0x0 ordinal: 0x4
  USHORT AsUSHORT;                         // offset: 0x0 ordinal: 0x5
} _AER_ENDPOINT_DESCRIPTOR_FLAGS;

// 0x2 bytes (sizeof)
typedef union _AER_ROOTPORT_DESCRIPTOR_FLAGS {
  USHORT UncorrectableErrorMaskRW : 1;     // offset: 0x0 ordinal: 0x0
  USHORT UncorrectableErrorSeverityRW : 1; // offset: 0x0 ordinal: 0x1
  USHORT CorrectableErrorMaskRW : 1;       // offset: 0x0 ordinal: 0x2
  USHORT AdvancedCapsAndControlRW : 1;     // offset: 0x0 ordinal: 0x3
  USHORT RootErrorCommandRW : 1;           // offset: 0x0 ordinal: 0x4
  USHORT Reserved : 11;                    // offset: 0x0 ordinal: 0x5
  USHORT AsUSHORT;                         // offset: 0x0 ordinal: 0x6
} _AER_ROOTPORT_DESCRIPTOR_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _WHEA_IPF_CPE_DESCRIPTOR {
  USHORT Type;    // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;  // offset: 0x2 ordinal: 0x1
  UCHAR Reserved; // offset: 0x3 ordinal: 0x2
} _WHEA_IPF_CPE_DESCRIPTOR;

// 0x4 bytes (sizeof)
typedef struct _WHEA_IPF_CMC_DESCRIPTOR {
  USHORT Type;    // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;  // offset: 0x2 ordinal: 0x1
  UCHAR Reserved; // offset: 0x3 ordinal: 0x2
} _WHEA_IPF_CMC_DESCRIPTOR;

// 0x4 bytes (sizeof)
typedef struct _WHEA_IPF_MCA_DESCRIPTOR {
  USHORT Type;    // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;  // offset: 0x2 ordinal: 0x1
  UCHAR Reserved; // offset: 0x3 ordinal: 0x2
} _WHEA_IPF_MCA_DESCRIPTOR;

// 0x3 bytes (sizeof)
typedef struct _WHEA_XPF_NMI_DESCRIPTOR {
  USHORT Type;   // offset: 0x0 ordinal: 0x0
  UCHAR Enabled; // offset: 0x2 ordinal: 0x1
} _WHEA_XPF_NMI_DESCRIPTOR;

// 0x10 bytes (sizeof)
typedef struct _TXN_PARAMETER_BLOCK {
  USHORT Length;           // offset: 0x0 ordinal: 0x0
  USHORT TxFsContext;      // offset: 0x2 ordinal: 0x1
  VOID *TransactionObject; // offset: 0x8 ordinal: 0x2
} _TXN_PARAMETER_BLOCK;

// 0x20 bytes (sizeof)
typedef struct _INTERFACE {
  USHORT Size;                          // offset: 0x0 ordinal: 0x0
  USHORT Version;                       // offset: 0x2 ordinal: 0x1
  VOID *Context;                        // offset: 0x8 ordinal: 0x2
  VOID (*InterfaceReference)(VOID *);   // offset: 0x10 ordinal: 0x3
  VOID (*InterfaceDereference)(VOID *); // offset: 0x18 ordinal: 0x4
} _INTERFACE;

// 0x10 bytes (sizeof)
typedef struct _ETW_FILTER_STRING_TOKEN_ELEMENT {
  USHORT Length; // offset: 0x0 ordinal: 0x0
  WCHAR *String; // offset: 0x8 ordinal: 0x1
} _ETW_FILTER_STRING_TOKEN_ELEMENT;

// 0x40 bytes (sizeof)
typedef struct _IMAGE_DOS_HEADER {
  USHORT e_magic;    // offset: 0x0 ordinal: 0x0
  USHORT e_cblp;     // offset: 0x2 ordinal: 0x1
  USHORT e_cp;       // offset: 0x4 ordinal: 0x2
  USHORT e_crlc;     // offset: 0x6 ordinal: 0x3
  USHORT e_cparhdr;  // offset: 0x8 ordinal: 0x4
  USHORT e_minalloc; // offset: 0xa ordinal: 0x5
  USHORT e_maxalloc; // offset: 0xc ordinal: 0x6
  USHORT e_ss;       // offset: 0xe ordinal: 0x7
  USHORT e_sp;       // offset: 0x10 ordinal: 0x8
  USHORT e_csum;     // offset: 0x12 ordinal: 0x9
  USHORT e_ip;       // offset: 0x14 ordinal: 0xa
  USHORT e_cs;       // offset: 0x16 ordinal: 0xb
  USHORT e_lfarlc;   // offset: 0x18 ordinal: 0xc
  USHORT e_ovno;     // offset: 0x1a ordinal: 0xd
  USHORT e_res[4];   // offset: 0x1c ordinal: 0xe
  USHORT e_oemid;    // offset: 0x24 ordinal: 0xf
  USHORT e_oeminfo;  // offset: 0x26 ordinal: 0x10
  USHORT e_res2[10]; // offset: 0x28 ordinal: 0x11
  LONG e_lfanew;     // offset: 0x3c ordinal: 0x12
} _IMAGE_DOS_HEADER;

// 0x20 bytes (sizeof)
typedef struct _ETW_PMC_SUPPORT {
  enum _KPROFILE_SOURCE *Source;              // offset: 0x0 ordinal: 0x0
  ULONG HookIdCount;                          // offset: 0x8 ordinal: 0x1
  USHORT HookId[4];                           // offset: 0xc ordinal: 0x2
  ULONG CountersCount;                        // offset: 0x14 ordinal: 0x3
  struct _HAL_PMC_COUNTERS *ProcessorCtrs[1]; // offset: 0x18 ordinal: 0x4
} _ETW_PMC_SUPPORT;

// 0x4 bytes (sizeof)
typedef struct _ETW_BUFFER_CONTEXT {
  UCHAR ProcessorNumber; // offset: 0x0 ordinal: 0x0
  UCHAR Alignment;       // offset: 0x1 ordinal: 0x1
  USHORT ProcessorIndex; // offset: 0x0 ordinal: 0x2
  USHORT LoggerId;       // offset: 0x2 ordinal: 0x3
} _ETW_BUFFER_CONTEXT;

// 0x18 bytes (sizeof)
typedef struct _ETW_FILTER_STRING_TOKEN {
  USHORT Count;                                      // offset: 0x0 ordinal: 0x0
  struct _ETW_FILTER_STRING_TOKEN_ELEMENT Tokens[1]; // offset: 0x8 ordinal: 0x1
} _ETW_FILTER_STRING_TOKEN;

// 0xc bytes (sizeof)
typedef struct _PROC_PERF_HISTORY_ENTRY {
  USHORT Utility;            // offset: 0x0 ordinal: 0x0
  USHORT AffinitizedUtility; // offset: 0x2 ordinal: 0x1
  USHORT Frequency;          // offset: 0x4 ordinal: 0x2
  UCHAR ImportantPercent;    // offset: 0x6 ordinal: 0x3
  UCHAR IdealPercent;        // offset: 0x7 ordinal: 0x4
  UCHAR TaggedPercent[4];    // offset: 0x8 ordinal: 0x5
} _PROC_PERF_HISTORY_ENTRY;

// 0x4 bytes (sizeof)
typedef struct _WNF_NODE_HEADER {
  USHORT NodeTypeCode; // offset: 0x0 ordinal: 0x0
  USHORT NodeByteSize; // offset: 0x2 ordinal: 0x1
} _WNF_NODE_HEADER;

// 0x4 bytes (sizeof)
typedef struct _PROCESSOR_NUMBER {
  USHORT Group;   // offset: 0x0 ordinal: 0x0
  UCHAR Number;   // offset: 0x2 ordinal: 0x1
  UCHAR Reserved; // offset: 0x3 ordinal: 0x2
} _PROCESSOR_NUMBER;

typedef VOID (*__anon_2662)(VOID *, USHORT *);

// 0x40 bytes (sizeof)
typedef struct _CPTABLEINFO {
  USHORT CodePage;             // offset: 0x0 ordinal: 0x0
  USHORT MaximumCharacterSize; // offset: 0x2 ordinal: 0x1
  USHORT DefaultChar;          // offset: 0x4 ordinal: 0x2
  USHORT UniDefaultChar;       // offset: 0x6 ordinal: 0x3
  USHORT TransDefaultChar;     // offset: 0x8 ordinal: 0x4
  USHORT TransUniDefaultChar;  // offset: 0xa ordinal: 0x5
  USHORT DBCSCodePage;         // offset: 0xc ordinal: 0x6
  UCHAR LeadByte[12];          // offset: 0xe ordinal: 0x7
  USHORT *MultiByteTable;      // offset: 0x20 ordinal: 0x8
  VOID *WideCharTable;         // offset: 0x28 ordinal: 0x9
  USHORT *DBCSRanges;          // offset: 0x30 ordinal: 0xa
  USHORT *DBCSOffsets;         // offset: 0x38 ordinal: 0xb
} _CPTABLEINFO;

// 0xb8 bytes (sizeof)
typedef struct _RTL_NLS_STATE {
  struct _CPTABLEINFO DefaultAcpTableInfo; // offset: 0x0 ordinal: 0x0
  struct _CPTABLEINFO DefaultOemTableInfo; // offset: 0x40 ordinal: 0x1
  USHORT *ActiveCodePageData;              // offset: 0x80 ordinal: 0x2
  USHORT *OemCodePageData;                 // offset: 0x88 ordinal: 0x3
  USHORT *LeadByteInfo;                    // offset: 0x90 ordinal: 0x4
  USHORT *OemLeadByteInfo;                 // offset: 0x98 ordinal: 0x5
  USHORT *CaseMappingData;                 // offset: 0xa0 ordinal: 0x6
  USHORT *UnicodeUpcaseTable844;           // offset: 0xa8 ordinal: 0x7
  USHORT *UnicodeLowercaseTable844;        // offset: 0xb0 ordinal: 0x8
} _RTL_NLS_STATE;

// 0x4 bytes (sizeof)
typedef struct _MMSUPPORT_FLAGS {
  UCHAR WorkingSetType : 3;        // offset: 0x0 ordinal: 0x0
  UCHAR Reserved0 : 3;             // offset: 0x0 ordinal: 0x1
  UCHAR MaximumWorkingSetHard : 1; // offset: 0x0 ordinal: 0x2
  UCHAR MinimumWorkingSetHard : 1; // offset: 0x0 ordinal: 0x3
  UCHAR SessionMaster : 1;         // offset: 0x1 ordinal: 0x4
  UCHAR TrimmerState : 2;          // offset: 0x1 ordinal: 0x5
  UCHAR Reserved : 1;              // offset: 0x1 ordinal: 0x6
  UCHAR PageStealers : 4;          // offset: 0x1 ordinal: 0x7
  USHORT u1;                       // offset: 0x0 ordinal: 0x8
  UCHAR MemoryPriority;            // offset: 0x2 ordinal: 0x9
  UCHAR WsleDeleted : 1;           // offset: 0x3 ordinal: 0xa
  UCHAR SvmEnabled : 1;            // offset: 0x3 ordinal: 0xb
  UCHAR ForceAge : 1;              // offset: 0x3 ordinal: 0xc
  UCHAR ForceTrim : 1;             // offset: 0x3 ordinal: 0xd
  UCHAR NewMaximum : 1;            // offset: 0x3 ordinal: 0xe
  UCHAR CommitReleaseState : 2;    // offset: 0x3 ordinal: 0xf
  UCHAR u2;                        // offset: 0x3 ordinal: 0x10
} _MMSUPPORT_FLAGS;

// 0x10 bytes (sizeof)
typedef struct _KDESCRIPTOR {
  USHORT Pad[3]; // offset: 0x0 ordinal: 0x0
  USHORT Limit;  // offset: 0x6 ordinal: 0x1
  VOID *Base;    // offset: 0x8 ordinal: 0x2
} _KDESCRIPTOR;

// 0x10 bytes (sizeof)
typedef struct _STRING {
  USHORT Length;        // offset: 0x0 ordinal: 0x0
  USHORT MaximumLength; // offset: 0x2 ordinal: 0x1
  CHAR *Buffer;         // offset: 0x8 ordinal: 0x2
} _STRING;

// 0x18 bytes (sizeof)
typedef struct _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR {
  enum _SEP_CACHED_HANDLES_ENTRY_TYPE
      DescriptorType; // offset: 0x0 ordinal: 0x0
  union {
    VOID *PackageSid;                       // offset: 0x8 ordinal: 0x1
    struct _UNICODE_STRING IsolationPrefix; // offset: 0x8 ordinal: 0x2
  };
} _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR;

// 0x20 bytes (sizeof)
typedef struct _RELATIVE_SYMLINK_INFO {
  USHORT ExposedNamespaceLength;                     // offset: 0x0 ordinal: 0x0
  USHORT Flags;                                      // offset: 0x2 ordinal: 0x1
  USHORT DeviceNameLength;                           // offset: 0x4 ordinal: 0x2
  USHORT Reserved;                                   // offset: 0x6 ordinal: 0x3
  struct _RELATIVE_SYMLINK_INFO *InteriorMountPoint; // offset: 0x8 ordinal: 0x4
  struct _UNICODE_STRING OpenedName; // offset: 0x10 ordinal: 0x5
} _RELATIVE_SYMLINK_INFO;

// 0x18 bytes (sizeof)
typedef struct _CURDIR {
  struct _UNICODE_STRING DosPath; // offset: 0x0 ordinal: 0x0
  VOID *Handle;                   // offset: 0x10 ordinal: 0x1
} _CURDIR;

// 0x10 bytes (sizeof)
typedef struct _OBJECT_NAME_INFORMATION {
  struct _UNICODE_STRING Name; // offset: 0x0 ordinal: 0x0
} _OBJECT_NAME_INFORMATION;

// 0x8 bytes (sizeof)
typedef struct _SE_AUDIT_PROCESS_CREATION_INFO {
  struct _OBJECT_NAME_INFORMATION *ImageFileName; // offset: 0x0 ordinal: 0x0
} _SE_AUDIT_PROCESS_CREATION_INFO;

// 0x30 bytes (sizeof)
typedef struct _SEP_SILOSTATE {
  struct _SEP_LOGON_SESSION_REFERENCES
      *SystemLogonSession; // offset: 0x0 ordinal: 0x0
  struct _SEP_LOGON_SESSION_REFERENCES
      *AnonymousLogonSession;             // offset: 0x8 ordinal: 0x1
  VOID *AnonymousLogonToken;              // offset: 0x10 ordinal: 0x2
  VOID *AnonymousLogonTokenNoEveryone;    // offset: 0x18 ordinal: 0x3
  struct _UNICODE_STRING *UncSystemPaths; // offset: 0x20 ordinal: 0x4
  struct _CI_NGEN_PATHS *NgenPaths;       // offset: 0x28 ordinal: 0x5
} _SEP_SILOSTATE;

// 0x8 bytes (sizeof)
typedef struct _LDRP_CSLIST {
  struct _SINGLE_LIST_ENTRY *Tail; // offset: 0x0 ordinal: 0x0
} _LDRP_CSLIST;

// 0x8 bytes (sizeof)
typedef struct _SINGLE_LIST_ENTRY {
  struct _SINGLE_LIST_ENTRY *Next; // offset: 0x0 ordinal: 0x0
} _SINGLE_LIST_ENTRY;

// 0x10 bytes (sizeof)
typedef struct _ETW_BUFFER_QUEUE {
  struct _SINGLE_LIST_ENTRY *QueueTail; // offset: 0x0 ordinal: 0x0
  struct _SINGLE_LIST_ENTRY QueueEntry; // offset: 0x8 ordinal: 0x1
} _ETW_BUFFER_QUEUE;

// 0x10 bytes (sizeof)
typedef struct _KDPC_LIST {
  struct _SINGLE_LIST_ENTRY ListHead;   // offset: 0x0 ordinal: 0x0
  struct _SINGLE_LIST_ENTRY *LastEntry; // offset: 0x8 ordinal: 0x1
} _KDPC_LIST;

// 0x8 bytes (sizeof)
typedef struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList; // offset: 0x0 ordinal: 0x0
} _ARBITER_QUERY_ARBITRATE_PARAMETERS;

// 0x8 bytes (sizeof)
typedef struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList; // offset: 0x0 ordinal: 0x0
} _ARBITER_BOOT_ALLOCATION_PARAMETERS;

typedef VOID (*__anon_1718)(VOID *, VOID *, struct _LIST_ENTRY *);

// 0x10 bytes (sizeof)
typedef struct _LIST_ENTRY {
  struct _LIST_ENTRY *Flink; // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY *Blink; // offset: 0x8 ordinal: 0x1
} _LIST_ENTRY;

// 0x10 bytes (sizeof)
typedef struct __anon_4048 {
  struct _LIST_ENTRY ListHead; // offset: 0x0 ordinal: 0x0
} __anon_4048;

// 0x48 bytes (sizeof)
typedef struct _FAST_OWNER_ENTRY_INTERNAL {
  struct _LIST_ENTRY ListEntry;     // offset: 0x0 ordinal: 0x0
  UCHAR AbLockHandle;               // offset: 0x10 ordinal: 0x1
  UCHAR Disowned : 1;               // offset: 0x11 ordinal: 0x2
  UCHAR DynamicallyAllocated : 1;   // offset: 0x11 ordinal: 0x3
  UCHAR CallerExclusive : 1;        // offset: 0x11 ordinal: 0x4
  UCHAR IsSublistHead;              // offset: 0x12 ordinal: 0x5
  UCHAR IsWaiting;                  // offset: 0x13 ordinal: 0x6
  VOID *LockAddress;                // offset: 0x18 ordinal: 0x7
  VOID *ThreadAddress;              // offset: 0x20 ordinal: 0x8
  struct _LIST_ENTRY SublistHead;   // offset: 0x28 ordinal: 0x9
  struct _LIST_ENTRY LockListEntry; // offset: 0x38 ordinal: 0xa
} _FAST_OWNER_ENTRY_INTERNAL;

// 0x20 bytes (sizeof)
typedef struct _TRIAGE_POP_IRP_DATA {
  struct _LIST_ENTRY Link;    // offset: 0x0 ordinal: 0x0
  struct _IRP *Irp;           // offset: 0x10 ordinal: 0x1
  struct _DEVICE_OBJECT *Pdo; // offset: 0x18 ordinal: 0x2
} _TRIAGE_POP_IRP_DATA;

// 0x38 bytes (sizeof)
typedef struct _TRIAGE_POP_FX_DEVICE {
  struct _LIST_ENTRY Link;                // offset: 0x0 ordinal: 0x0
  struct _IRP *Irp;                       // offset: 0x10 ordinal: 0x1
  struct _TRIAGE_POP_IRP_DATA *IrpData;   // offset: 0x18 ordinal: 0x2
  LONG Status;                            // offset: 0x20 ordinal: 0x3
  LONG PowerReqCall;                      // offset: 0x24 ordinal: 0x4
  LONG PowerNotReqCall;                   // offset: 0x28 ordinal: 0x5
  struct _TRIAGE_DEVICE_NODE *DeviceNode; // offset: 0x30 ordinal: 0x6
} _TRIAGE_POP_FX_DEVICE;

// 0x58 bytes (sizeof)
typedef struct _TRIAGE_DEVICE_NODE {
  struct _TRIAGE_DEVICE_NODE *Sibling;         // offset: 0x0 ordinal: 0x0
  struct _TRIAGE_DEVICE_NODE *Child;           // offset: 0x8 ordinal: 0x1
  struct _TRIAGE_DEVICE_NODE *Parent;          // offset: 0x10 ordinal: 0x2
  struct _TRIAGE_DEVICE_NODE *LastChild;       // offset: 0x18 ordinal: 0x3
  struct _DEVICE_OBJECT *PhysicalDeviceObject; // offset: 0x20 ordinal: 0x4
  struct _UNICODE_STRING InstancePath;         // offset: 0x28 ordinal: 0x5
  struct _UNICODE_STRING ServiceName;          // offset: 0x38 ordinal: 0x6
  struct _IRP *PendingIrp;                     // offset: 0x48 ordinal: 0x7
  struct _TRIAGE_POP_FX_DEVICE *FxDevice;      // offset: 0x50 ordinal: 0x8
} _TRIAGE_DEVICE_NODE;

// 0x18 bytes (sizeof)
typedef struct _TRIAGE_PNP_DEVICE_COMPLETION_REQUEST {
  struct _LIST_ENTRY ListEntry;           // offset: 0x0 ordinal: 0x0
  struct _TRIAGE_DEVICE_NODE *DeviceNode; // offset: 0x10 ordinal: 0x1
} _TRIAGE_PNP_DEVICE_COMPLETION_REQUEST;

// 0x40 bytes (sizeof)
typedef struct _POP_POLICY_DEVICE {
  struct _LIST_ENTRY Link;                  // offset: 0x0 ordinal: 0x0
  enum POWER_POLICY_DEVICE_TYPE DeviceType; // offset: 0x10 ordinal: 0x1
  VOID *Notification;                       // offset: 0x18 ordinal: 0x2
  struct _UNICODE_STRING Name;              // offset: 0x20 ordinal: 0x3
  struct _DEVICE_OBJECT *Device;            // offset: 0x30 ordinal: 0x4
  struct _IRP *Irp;                         // offset: 0x38 ordinal: 0x5
} _POP_POLICY_DEVICE;

// 0x20 bytes (sizeof)
typedef struct _IOMMU_DEVICE_CREATION_CONFIGURATION {
  struct _LIST_ENTRY NextConfiguration; // offset: 0x0 ordinal: 0x0
  enum _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE
      ConfigType; // offset: 0x10 ordinal: 0x1
  union {
    struct _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI
        Acpi;       // offset: 0x18 ordinal: 0x2
    VOID *DeviceId; // offset: 0x18 ordinal: 0x3
  };
} _IOMMU_DEVICE_CREATION_CONFIGURATION;

// 0x10 bytes (sizeof)
typedef struct _ARC_DISK_INFORMATION {
  struct _LIST_ENTRY DiskSignatures; // offset: 0x0 ordinal: 0x0
} _ARC_DISK_INFORMATION;

// 0x18 bytes (sizeof)
typedef struct _DELAY_ACK_FO {
  struct _LIST_ENTRY Links;                // offset: 0x0 ordinal: 0x0
  struct _FILE_OBJECT *OriginalFileObject; // offset: 0x10 ordinal: 0x1
} _DELAY_ACK_FO;

// 0x10 bytes (sizeof)
typedef struct _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE {
  struct _LIST_ENTRY DispatchedList; // offset: 0x0 ordinal: 0x0
} _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE;

// 0x30 bytes (sizeof)
typedef struct _POP_IRP_WORKER_ENTRY {
  struct _LIST_ENTRY Link;       // offset: 0x0 ordinal: 0x0
  struct _ETHREAD *Thread;       // offset: 0x10 ordinal: 0x1
  struct _IRP *Irp;              // offset: 0x18 ordinal: 0x2
  struct _DEVICE_OBJECT *Device; // offset: 0x20 ordinal: 0x3
  UCHAR Static;                  // offset: 0x28 ordinal: 0x4
} _POP_IRP_WORKER_ENTRY;

// 0x18 bytes (sizeof)
typedef struct _CMP_VOLUME_MANAGER {
  struct _CMSI_RW_LOCK VolumeContextListLock; // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY VolumeContextListHead;   // offset: 0x8 ordinal: 0x1
} _CMP_VOLUME_MANAGER;

// 0x20 bytes (sizeof)
typedef struct _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT {
  struct _CM_KEY_CONTROL_BLOCK *BaseKcb; // offset: 0x0 ordinal: 0x0
  LONG PrepareStatus;                    // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY ClonedKcbListHead;  // offset: 0x10 ordinal: 0x2
} _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT;

// 0x30 bytes (sizeof)
typedef struct _CM_KCB_LAYER_INFO {
  struct _LIST_ENTRY LayerListEntry;     // offset: 0x0 ordinal: 0x0
  struct _CM_KEY_CONTROL_BLOCK *Kcb;     // offset: 0x10 ordinal: 0x1
  struct _CM_KCB_LAYER_INFO *LowerLayer; // offset: 0x18 ordinal: 0x2
  struct _LIST_ENTRY UpperLayerListHead; // offset: 0x20 ordinal: 0x3
} _CM_KCB_LAYER_INFO;

// 0x10 bytes (sizeof)
typedef struct _MMWORKING_SET_EXPANSION_HEAD {
  struct _LIST_ENTRY ListHead; // offset: 0x0 ordinal: 0x0
} _MMWORKING_SET_EXPANSION_HEAD;

// 0x18 bytes (sizeof)
typedef struct _HALP_EMERGENCY_LA_QUEUE_ENTRY {
  struct _LIST_ENTRY ListEntry;                 // offset: 0x0 ordinal: 0x0
  enum _HALP_EMERGENCY_LA_QUEUE_TYPE EntryType; // offset: 0x10 ordinal: 0x1
} _HALP_EMERGENCY_LA_QUEUE_ENTRY;

// 0x20 bytes (sizeof)
typedef struct __anon_872 {
  enum PROFILE_STATUS DockStatus; // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY ListEntry;   // offset: 0x8 ordinal: 0x1
  WCHAR *SerialNumber;            // offset: 0x18 ordinal: 0x2
} __anon_872;

// 0x30 bytes (sizeof)
typedef struct _IO_TIMER {
  SHORT Type;                   // offset: 0x0 ordinal: 0x0
  SHORT TimerFlag;              // offset: 0x2 ordinal: 0x1
  struct _LIST_ENTRY TimerList; // offset: 0x8 ordinal: 0x2
  VOID(*TimerRoutine)
  (struct _DEVICE_OBJECT *, VOID *);   // offset: 0x18 ordinal: 0x3
  VOID *Context;                       // offset: 0x20 ordinal: 0x4
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x28 ordinal: 0x5
} _IO_TIMER;

// 0x20 bytes (sizeof)
typedef struct _WORK_QUEUE_ITEM {
  struct _LIST_ENTRY List;       // offset: 0x0 ordinal: 0x0
  VOID (*WorkerRoutine)(VOID *); // offset: 0x10 ordinal: 0x1
  VOID *Parameter;               // offset: 0x18 ordinal: 0x2
} _WORK_QUEUE_ITEM;

// 0x30 bytes (sizeof)
typedef struct _WNF_DISPATCHER {
  struct _WNF_NODE_HEADER Header;   // offset: 0x0 ordinal: 0x0
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x8 ordinal: 0x1
  LONG State;                       // offset: 0x28 ordinal: 0x2
} _WNF_DISPATCHER;

// 0x28 bytes (sizeof)
typedef struct _MI_REBUILD_LARGE_PAGE_TIMER {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 ordinal: 0x0
  UCHAR SecondsLeft;                // offset: 0x20 ordinal: 0x1
  UCHAR RebuildActive;              // offset: 0x21 ordinal: 0x2
  UCHAR NextPassDelta;              // offset: 0x22 ordinal: 0x3
  UCHAR LargeSubPagesActive;        // offset: 0x23 ordinal: 0x4
} _MI_REBUILD_LARGE_PAGE_TIMER;

// 0x28 bytes (sizeof)
typedef struct _MI_COMBINE_WORKITEM {
  VOID *NextEntry;                  // offset: 0x0 ordinal: 0x0
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x8 ordinal: 0x1
} _MI_COMBINE_WORKITEM;

// 0x38 bytes (sizeof)
typedef struct _MI_LDW_WORK_CONTEXT {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 ordinal: 0x0
  struct _FILE_OBJECT *FileObject;  // offset: 0x20 ordinal: 0x1
  LONG ErrorStatus;                 // offset: 0x28 ordinal: 0x2
  LONG Active;                      // offset: 0x2c ordinal: 0x3
  UCHAR FreeWhenDone;               // offset: 0x30 ordinal: 0x4
} _MI_LDW_WORK_CONTEXT;

// 0x38 bytes (sizeof)
typedef struct _POP_FX_WORK_ORDER {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 ordinal: 0x0
  LONG WorkCount;                   // offset: 0x20 ordinal: 0x1
  VOID *Context;                    // offset: 0x28 ordinal: 0x2
  struct _POP_FX_WORK_ORDER_WATCHDOG_INFO
      *WatchdogTimerInfo; // offset: 0x30 ordinal: 0x3
} _POP_FX_WORK_ORDER;

// 0x18 bytes (sizeof)
typedef struct _DISPATCHER_HEADER {
  union {
    LONG Lock;   // offset: 0x0 ordinal: 0x0
    LONG LockNV; // offset: 0x0 ordinal: 0x1
    UCHAR Type;  // offset: 0x0 ordinal: 0x2
  };
  UCHAR Signalling; // offset: 0x1 ordinal: 0x3
  UCHAR Size;       // offset: 0x2 ordinal: 0x4
  UCHAR Reserved1;  // offset: 0x3 ordinal: 0x5
  UCHAR TimerType;  // offset: 0x0 ordinal: 0x6
  union {
    UCHAR TimerControlFlags; // offset: 0x1 ordinal: 0x7
    UCHAR Absolute : 1;      // offset: 0x1 ordinal: 0x8
  };
  UCHAR Wake : 1;                  // offset: 0x1 ordinal: 0x9
  UCHAR EncodedTolerableDelay : 6; // offset: 0x1 ordinal: 0xa
  UCHAR Hand;                      // offset: 0x2 ordinal: 0xb
  union {
    UCHAR TimerMiscFlags; // offset: 0x3 ordinal: 0xc
    UCHAR Index : 6;      // offset: 0x3 ordinal: 0xd
  };
  UCHAR Inserted : 1; // offset: 0x3 ordinal: 0xe
  UCHAR Expired : 1;  // offset: 0x3 ordinal: 0xf
  UCHAR Timer2Type;   // offset: 0x0 ordinal: 0x10
  union {
    UCHAR Timer2Flags;        // offset: 0x1 ordinal: 0x11
    UCHAR Timer2Inserted : 1; // offset: 0x1 ordinal: 0x12
  };
  UCHAR Timer2Expiring : 1;      // offset: 0x1 ordinal: 0x13
  UCHAR Timer2CancelPending : 1; // offset: 0x1 ordinal: 0x14
  UCHAR Timer2SetPending : 1;    // offset: 0x1 ordinal: 0x15
  UCHAR Timer2Running : 1;       // offset: 0x1 ordinal: 0x16
  UCHAR Timer2Disabled : 1;      // offset: 0x1 ordinal: 0x17
  UCHAR Timer2ReservedFlags : 2; // offset: 0x1 ordinal: 0x18
  UCHAR Timer2ComponentId;       // offset: 0x2 ordinal: 0x19
  UCHAR Timer2RelativeId;        // offset: 0x3 ordinal: 0x1a
  UCHAR QueueType;               // offset: 0x0 ordinal: 0x1b
  union {
    UCHAR QueueControlFlags; // offset: 0x1 ordinal: 0x1c
    UCHAR Abandoned : 1;     // offset: 0x1 ordinal: 0x1d
  };
  UCHAR DisableIncrement : 1;          // offset: 0x1 ordinal: 0x1e
  UCHAR QueueReservedControlFlags : 6; // offset: 0x1 ordinal: 0x1f
  UCHAR QueueSize;                     // offset: 0x2 ordinal: 0x20
  UCHAR QueueReserved;                 // offset: 0x3 ordinal: 0x21
  UCHAR ThreadType;                    // offset: 0x0 ordinal: 0x22
  UCHAR ThreadReserved;                // offset: 0x1 ordinal: 0x23
  union {
    UCHAR ThreadControlFlags; // offset: 0x2 ordinal: 0x24
    UCHAR CycleProfiling : 1; // offset: 0x2 ordinal: 0x25
  };
  UCHAR CounterProfiling : 1;           // offset: 0x2 ordinal: 0x26
  UCHAR GroupScheduling : 1;            // offset: 0x2 ordinal: 0x27
  UCHAR AffinitySet : 1;                // offset: 0x2 ordinal: 0x28
  UCHAR Tagged : 1;                     // offset: 0x2 ordinal: 0x29
  UCHAR EnergyProfiling : 1;            // offset: 0x2 ordinal: 0x2a
  UCHAR SchedulerAssist : 1;            // offset: 0x2 ordinal: 0x2b
  UCHAR ThreadReservedControlFlags : 1; // offset: 0x2 ordinal: 0x2c
  union {
    UCHAR DebugActive;   // offset: 0x3 ordinal: 0x2d
    UCHAR ActiveDR7 : 1; // offset: 0x3 ordinal: 0x2e
  };
  UCHAR Instrumented : 1;          // offset: 0x3 ordinal: 0x2f
  UCHAR Minimal : 1;               // offset: 0x3 ordinal: 0x30
  UCHAR Reserved4 : 2;             // offset: 0x3 ordinal: 0x31
  UCHAR AltSyscall : 1;            // offset: 0x3 ordinal: 0x32
  UCHAR Emulation : 1;             // offset: 0x3 ordinal: 0x33
  UCHAR Reserved5 : 1;             // offset: 0x3 ordinal: 0x34
  UCHAR MutantType;                // offset: 0x0 ordinal: 0x35
  UCHAR MutantSize;                // offset: 0x1 ordinal: 0x36
  UCHAR DpcActive;                 // offset: 0x2 ordinal: 0x37
  UCHAR MutantReserved;            // offset: 0x3 ordinal: 0x38
  LONG SignalState;                // offset: 0x4 ordinal: 0x39
  struct _LIST_ENTRY WaitListHead; // offset: 0x8 ordinal: 0x3a
} _DISPATCHER_HEADER;

// 0x38 bytes (sizeof)
typedef struct _KMUTANT {
  struct _DISPATCHER_HEADER Header;   // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY MutantListEntry; // offset: 0x18 ordinal: 0x1
  struct _KTHREAD *OwnerThread;       // offset: 0x28 ordinal: 0x2
  union {
    UCHAR MutantFlags;   // offset: 0x30 ordinal: 0x3
    UCHAR Abandoned : 1; // offset: 0x30 ordinal: 0x4
  };
  UCHAR Spare1 : 7;     // offset: 0x30 ordinal: 0x5
  UCHAR Abandoned2 : 1; // offset: 0x30 ordinal: 0x6
  UCHAR AbEnabled : 1;  // offset: 0x30 ordinal: 0x7
  UCHAR Spare2 : 6;     // offset: 0x30 ordinal: 0x8
  UCHAR ApcDisable;     // offset: 0x31 ordinal: 0x9
} _KMUTANT;

// 0x18 bytes (sizeof)
typedef struct _KGATE {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 ordinal: 0x0
} _KGATE;

// 0x20 bytes (sizeof)
typedef struct _MI_EXTENT_DELETION_WAIT_BLOCK {
  struct _MI_EXTENT_DELETION_WAIT_BLOCK *Next; // offset: 0x0 ordinal: 0x0
  struct _KGATE Gate;                          // offset: 0x8 ordinal: 0x1
} _MI_EXTENT_DELETION_WAIT_BLOCK;

// 0x20 bytes (sizeof)
typedef struct _MI_LARGE_PAGE_LISTS_CHANGING {
  struct _MI_LARGE_PAGE_LISTS_CHANGING *Next; // offset: 0x0 ordinal: 0x0
  struct _KGATE Gate;                         // offset: 0x8 ordinal: 0x1
} _MI_LARGE_PAGE_LISTS_CHANGING;

// 0x20 bytes (sizeof)
typedef struct _KSEMAPHORE {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 ordinal: 0x0
  LONG Limit;                       // offset: 0x18 ordinal: 0x1
} _KSEMAPHORE;

// 0x28 bytes (sizeof)
typedef struct _LPCP_NONPAGED_PORT_QUEUE {
  struct _KSEMAPHORE Semaphore;          // offset: 0x0 ordinal: 0x0
  struct _LPCP_PORT_OBJECT *BackPointer; // offset: 0x20 ordinal: 0x1
} _LPCP_NONPAGED_PORT_QUEUE;

// 0x20 bytes (sizeof)
typedef struct _LPCP_PORT_QUEUE {
  struct _LPCP_NONPAGED_PORT_QUEUE
      *NonPagedPortQueue;         // offset: 0x0 ordinal: 0x0
  struct _KSEMAPHORE *Semaphore;  // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY ReceiveHead; // offset: 0x10 ordinal: 0x2
} _LPCP_PORT_QUEUE;

// 0x50 bytes (sizeof)
typedef struct _MMDEREFERENCE_SEGMENT_HEADER {
  struct _KSEMAPHORE Semaphore;                   // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY ControlAreaDeleteListHead;   // offset: 0x20 ordinal: 0x1
  struct _LIST_ENTRY UnusedSegmentDeleteListHead; // offset: 0x30 ordinal: 0x2
  struct _LIST_ENTRY PagefileExtensionListHead;   // offset: 0x40 ordinal: 0x3
} _MMDEREFERENCE_SEGMENT_HEADER;

// 0x18 bytes (sizeof)
typedef struct _KEVENT {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 ordinal: 0x0
} _KEVENT;

// 0x38 bytes (sizeof)
typedef struct _KWAIT_CHAIN_ENTRY {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  struct _KTHREAD *Thread;      // offset: 0x10 ordinal: 0x1
  struct _KEVENT Event;         // offset: 0x18 ordinal: 0x2
  VOID *AbLockHandle;           // offset: 0x30 ordinal: 0x3
} _KWAIT_CHAIN_ENTRY;

// 0x38 bytes (sizeof)
typedef struct _MI_RESUME_WORKITEM {
  struct _KEVENT ResumeCompleteEvent; // offset: 0x0 ordinal: 0x0
  struct _WORK_QUEUE_ITEM WorkItem;   // offset: 0x18 ordinal: 0x1
} _MI_RESUME_WORKITEM;

// 0x20 bytes (sizeof)
typedef struct _PALPC_PORT_REFERENCE_WAIT_BLOCK {
  struct _KEVENT DesiredReferenceNoEvent; // offset: 0x0 ordinal: 0x0
  LONG DesiredReferenceNo;                // offset: 0x18 ordinal: 0x1
} _PALPC_PORT_REFERENCE_WAIT_BLOCK;

// 0x20 bytes (sizeof)
typedef struct _CACHE_UNINITIALIZE_EVENT {
  struct _CACHE_UNINITIALIZE_EVENT *Next; // offset: 0x0 ordinal: 0x0
  struct _KEVENT Event;                   // offset: 0x8 ordinal: 0x1
} _CACHE_UNINITIALIZE_EVENT;

// 0x28 bytes (sizeof)
typedef struct _HIVE_WAIT_PACKET {
  struct _KEVENT WakeEvent;       // offset: 0x0 ordinal: 0x0
  LONG Status;                    // offset: 0x18 ordinal: 0x1
  struct _HIVE_WAIT_PACKET *Next; // offset: 0x20 ordinal: 0x2
} _HIVE_WAIT_PACKET;

// 0x28 bytes (sizeof)
typedef struct _MMMOD_WRITER_LISTHEAD {
  struct _LIST_ENTRY ListHead; // offset: 0x0 ordinal: 0x0
  union {
    struct _KGATE Gate;   // offset: 0x10 ordinal: 0x1
    struct _KEVENT Event; // offset: 0x10 ordinal: 0x2
  };
} _MMMOD_WRITER_LISTHEAD;

// 0x48 bytes (sizeof)
typedef struct _MI_PARTITION_ZEROING {
  struct _WORK_QUEUE_ITEM RebalanceZeroFreeWorkItem; // offset: 0x0 ordinal: 0x0
  LONG BackgroundZeroingDisabled;               // offset: 0x20 ordinal: 0x1
  LONG BootEnginesCalibrating;                  // offset: 0x24 ordinal: 0x2
  struct _KEVENT BootEnginesCalibrationWaiters; // offset: 0x28 ordinal: 0x3
  LONG ZeroFreePageSlistMinimum;                // offset: 0x40 ordinal: 0x4
} _MI_PARTITION_ZEROING;

// 0x20 bytes (sizeof)
typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
  UCHAR Removed;              // offset: 0x0 ordinal: 0x0
  UCHAR Reserved[3];          // offset: 0x1 ordinal: 0x1
  LONG IoCount;               // offset: 0x4 ordinal: 0x2
  struct _KEVENT RemoveEvent; // offset: 0x8 ordinal: 0x3
} _IO_REMOVE_LOCK_COMMON_BLOCK;

// 0x20 bytes (sizeof)
typedef struct _IO_REMOVE_LOCK {
  struct _IO_REMOVE_LOCK_COMMON_BLOCK Common; // offset: 0x0 ordinal: 0x0
} _IO_REMOVE_LOCK;

// 0x8 bytes (sizeof)
typedef struct __anon_2714 {
  struct _KEVENT *Event; // offset: 0x0 ordinal: 0x0
} __anon_2714;

// 0x4 bytes (sizeof)
typedef union _MI_RESERVATION_CLUSTER_INFO {
  ULONG ClusterSize : 10;    // offset: 0x0 ordinal: 0x0
  ULONG SequenceNumber : 22; // offset: 0x0 ordinal: 0x1
  LONG EntireInfo;           // offset: 0x0 ordinal: 0x2
} _MI_RESERVATION_CLUSTER_INFO;

// 0x8 bytes (sizeof)
typedef struct _ACPI_METHOD_ARGUMENT_V1 {
  USHORT Type;       // offset: 0x0 ordinal: 0x0
  USHORT DataLength; // offset: 0x2 ordinal: 0x1
  union {
    ULONG Argument; // offset: 0x4 ordinal: 0x2
    UCHAR Data[1];  // offset: 0x4 ordinal: 0x3
  };
} _ACPI_METHOD_ARGUMENT_V1;

// 0x28 bytes (sizeof)
typedef struct _CALL_HASH_ENTRY {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  VOID *CallersAddress;         // offset: 0x10 ordinal: 0x1
  VOID *CallersCaller;          // offset: 0x18 ordinal: 0x2
  ULONG CallCount;              // offset: 0x20 ordinal: 0x3
} _CALL_HASH_ENTRY;

// 0x4 bytes (sizeof)
typedef struct _OBJECT_HEADER_PADDING_INFO {
  ULONG PaddingAmount; // offset: 0x0 ordinal: 0x0
} _OBJECT_HEADER_PADDING_INFO;

// 0x1c bytes (sizeof)
typedef struct _IMAGE_DEBUG_DIRECTORY {
  ULONG Characteristics;  // offset: 0x0 ordinal: 0x0
  ULONG TimeDateStamp;    // offset: 0x4 ordinal: 0x1
  USHORT MajorVersion;    // offset: 0x8 ordinal: 0x2
  USHORT MinorVersion;    // offset: 0xa ordinal: 0x3
  ULONG Type;             // offset: 0xc ordinal: 0x4
  ULONG SizeOfData;       // offset: 0x10 ordinal: 0x5
  ULONG AddressOfRawData; // offset: 0x14 ordinal: 0x6
  ULONG PointerToRawData; // offset: 0x18 ordinal: 0x7
} _IMAGE_DEBUG_DIRECTORY;

// 0x14 bytes (sizeof)
typedef struct _NB10 {
  ULONG Signature; // offset: 0x0 ordinal: 0x0
  ULONG Offset;    // offset: 0x4 ordinal: 0x1
  ULONG TimeStamp; // offset: 0x8 ordinal: 0x2
  ULONG Age;       // offset: 0xc ordinal: 0x3
  CHAR PdbName[1]; // offset: 0x10 ordinal: 0x4
} _NB10;

// 0x4 bytes (sizeof)
typedef union __anon_4034 {
  ULONG PhysicalAddress; // offset: 0x0 ordinal: 0x0
  ULONG VirtualSize;     // offset: 0x0 ordinal: 0x1
} __anon_4034;

// 0x28 bytes (sizeof)
typedef struct _IMAGE_SECTION_HEADER {
  UCHAR Name[8];              // offset: 0x0 ordinal: 0x0
  union __anon_4034 Misc;     // offset: 0x8 ordinal: 0x1
  ULONG VirtualAddress;       // offset: 0xc ordinal: 0x2
  ULONG SizeOfRawData;        // offset: 0x10 ordinal: 0x3
  ULONG PointerToRawData;     // offset: 0x14 ordinal: 0x4
  ULONG PointerToRelocations; // offset: 0x18 ordinal: 0x5
  ULONG PointerToLinenumbers; // offset: 0x1c ordinal: 0x6
  USHORT NumberOfRelocations; // offset: 0x20 ordinal: 0x7
  USHORT NumberOfLinenumbers; // offset: 0x22 ordinal: 0x8
  ULONG Characteristics;      // offset: 0x24 ordinal: 0x9
} _IMAGE_SECTION_HEADER;

// 0x4 bytes (sizeof)
typedef struct _MMVAD_FLAGS2 {
  ULONG FileOffset : 24;        // offset: 0x0 ordinal: 0x0
  ULONG Large : 1;              // offset: 0x0 ordinal: 0x1
  ULONG TrimBehind : 1;         // offset: 0x0 ordinal: 0x2
  ULONG Inherit : 1;            // offset: 0x0 ordinal: 0x3
  ULONG NoValidationNeeded : 1; // offset: 0x0 ordinal: 0x4
  ULONG PrivateDemandZero : 1;  // offset: 0x0 ordinal: 0x5
  ULONG Spare : 3;              // offset: 0x0 ordinal: 0x6
} _MMVAD_FLAGS2;

// 0x20 bytes (sizeof)
typedef struct _VF_WATCHDOG_IRP {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  struct _IRP *Irp;             // offset: 0x10 ordinal: 0x1
  ULONG DueTickCount;           // offset: 0x18 ordinal: 0x2
  UCHAR Inserted;               // offset: 0x1c ordinal: 0x3
  CHAR TrackedStackLocation;    // offset: 0x1d ordinal: 0x4
  USHORT CancelTimeoutTicks;    // offset: 0x1e ordinal: 0x5
} _VF_WATCHDOG_IRP;

// 0x10 bytes (sizeof)
typedef struct _LDR_SERVICE_TAG_RECORD {
  struct _LDR_SERVICE_TAG_RECORD *Next; // offset: 0x0 ordinal: 0x0
  ULONG ServiceTag;                     // offset: 0x8 ordinal: 0x1
} _LDR_SERVICE_TAG_RECORD;

// 0x50 bytes (sizeof)
typedef struct _LDR_DDAG_NODE {
  struct _LIST_ENTRY Modules;                     // offset: 0x0 ordinal: 0x0
  struct _LDR_SERVICE_TAG_RECORD *ServiceTagList; // offset: 0x10 ordinal: 0x1
  ULONG LoadCount;                                // offset: 0x18 ordinal: 0x2
  ULONG LoadWhileUnloadingCount;                  // offset: 0x1c ordinal: 0x3
  ULONG LowestLink;                               // offset: 0x20 ordinal: 0x4
  struct _LDRP_CSLIST Dependencies;               // offset: 0x28 ordinal: 0x5
  struct _LDRP_CSLIST IncomingDependencies;       // offset: 0x30 ordinal: 0x6
  enum _LDR_DDAG_STATE State;                     // offset: 0x38 ordinal: 0x7
  struct _SINGLE_LIST_ENTRY CondenseLink;         // offset: 0x40 ordinal: 0x8
  ULONG PreorderNumber;                           // offset: 0x48 ordinal: 0x9
} _LDR_DDAG_NODE;

// 0x4 bytes (sizeof)
typedef union __anon_4016 {
  ULONG LongFlags2;               // offset: 0x0 ordinal: 0x0
  struct _MMVAD_FLAGS2 VadFlags2; // offset: 0x0 ordinal: 0x1
} __anon_4016;

// 0x1c bytes (sizeof)
typedef struct PROCESSOR_PERFSTATE_POLICY {
  ULONG Revision;         // offset: 0x0 ordinal: 0x0
  UCHAR MaxThrottle;      // offset: 0x4 ordinal: 0x1
  UCHAR MinThrottle;      // offset: 0x5 ordinal: 0x2
  UCHAR BusyAdjThreshold; // offset: 0x6 ordinal: 0x3
  union {
    UCHAR Spare;             // offset: 0x7 ordinal: 0x4
    union __anon_4013 Flags; // offset: 0x7 ordinal: 0x5
  };
  ULONG TimeCheck;       // offset: 0x8 ordinal: 0x6
  ULONG IncreaseTime;    // offset: 0xc ordinal: 0x7
  ULONG DecreaseTime;    // offset: 0x10 ordinal: 0x8
  ULONG IncreasePercent; // offset: 0x14 ordinal: 0x9
  ULONG DecreasePercent; // offset: 0x18 ordinal: 0xa
} PROCESSOR_PERFSTATE_POLICY;

// 0x4 bytes (sizeof)
typedef union _PPM_IDLE_SYNCHRONIZATION_STATE {
  LONG AsLong;        // offset: 0x0 ordinal: 0x0
  LONG RefCount : 24; // offset: 0x0 ordinal: 0x1
  ULONG State : 8;    // offset: 0x0 ordinal: 0x2
} _PPM_IDLE_SYNCHRONIZATION_STATE;

// 0x4 bytes (sizeof)
typedef struct _CM_FAST_LEAF_HINT {
  union {
    UCHAR Characters[4]; // offset: 0x0 ordinal: 0x0
    ULONG FullHint;      // offset: 0x0 ordinal: 0x1
  };
} _CM_FAST_LEAF_HINT;

// 0x40 bytes (sizeof)
typedef struct _WAITING_IRP {
  struct _LIST_ENTRY Links;                         // offset: 0x0 ordinal: 0x0
  struct _IRP *Irp;                                 // offset: 0x10 ordinal: 0x1
  VOID (*CompletionRoutine)(VOID *, struct _IRP *); // offset: 0x18 ordinal: 0x2
  VOID *Context;                                    // offset: 0x20 ordinal: 0x3
  struct _KEVENT *Event;                            // offset: 0x28 ordinal: 0x4
  ULONG Information;                                // offset: 0x30 ordinal: 0x5
  UCHAR BreakAllRH;                                 // offset: 0x34 ordinal: 0x6
  UCHAR OplockBreakNotify;                          // offset: 0x35 ordinal: 0x7
  struct _FILE_OBJECT *FileObject;                  // offset: 0x38 ordinal: 0x8
} _WAITING_IRP;

typedef VOID (*__anon_3986)(enum _DUMP_EVENTS, VOID *, ULONG);

typedef LONG (*__anon_3984)(ULONG, ULONG, VOID *, ULONG);

// 0x8 bytes (sizeof)
typedef struct __anon_3981 {
  ULONG Signature; // offset: 0x0 ordinal: 0x0
  ULONG CheckSum;  // offset: 0x4 ordinal: 0x1
} __anon_3981;

// 0x4 bytes (sizeof)
typedef union RTLP_HP_LFH_PERF_FLAGS {
  ULONG HotspotDetection : 1;            // offset: 0x0 ordinal: 0x0
  ULONG HotspotFullCommit : 1;           // offset: 0x0 ordinal: 0x1
  ULONG ActiveSubsegment : 1;            // offset: 0x0 ordinal: 0x2
  ULONG SmallerSubsegment : 1;           // offset: 0x0 ordinal: 0x3
  ULONG SingleAffinitySlot : 1;          // offset: 0x0 ordinal: 0x4
  ULONG ApplyLfhDecommitPolicy : 1;      // offset: 0x0 ordinal: 0x5
  ULONG EnableGarbageCollection : 1;     // offset: 0x0 ordinal: 0x6
  ULONG LargePagePreCommit : 1;          // offset: 0x0 ordinal: 0x7
  ULONG OpportunisticLargePreCommit : 1; // offset: 0x0 ordinal: 0x8
  ULONG LfhForcedAffinity : 1;           // offset: 0x0 ordinal: 0x9
  ULONG LfhCachelinePadding : 1;         // offset: 0x0 ordinal: 0xa
  ULONG AllFlags;                        // offset: 0x0 ordinal: 0xb
} RTLP_HP_LFH_PERF_FLAGS;

// 0x4 bytes (sizeof)
typedef union _PPM_COORDINATED_SYNCHRONIZATION {
  LONG AsLong;               // offset: 0x0 ordinal: 0x0
  ULONG EnterProcessor : 12; // offset: 0x0 ordinal: 0x1
  ULONG ExitProcessor : 12;  // offset: 0x0 ordinal: 0x2
  ULONG Transition : 2;      // offset: 0x0 ordinal: 0x3
  ULONG Entered : 1;         // offset: 0x0 ordinal: 0x4
  ULONG EntryPriority : 5;   // offset: 0x0 ordinal: 0x5
} _PPM_COORDINATED_SYNCHRONIZATION;

// 0x80 bytes (sizeof)
typedef struct _IOV_IRP_TRACE {
  struct _IRP *Irp;         // offset: 0x0 ordinal: 0x0
  struct _KTHREAD *Thread;  // offset: 0x8 ordinal: 0x1
  SHORT KernelApcDisable;   // offset: 0x10 ordinal: 0x2
  SHORT SpecialApcDisable;  // offset: 0x12 ordinal: 0x3
  ULONG CombinedApcDisable; // offset: 0x10 ordinal: 0x4
  UCHAR Irql;               // offset: 0x14 ordinal: 0x5
  VOID *StackTrace[13];     // offset: 0x18 ordinal: 0x6
} _IOV_IRP_TRACE;

// 0x38 bytes (sizeof)
typedef struct _VI_TRACK_IRQL {
  VOID *Thread;        // offset: 0x0 ordinal: 0x0
  UCHAR OldIrql;       // offset: 0x8 ordinal: 0x1
  UCHAR NewIrql;       // offset: 0x9 ordinal: 0x2
  USHORT Processor;    // offset: 0xa ordinal: 0x3
  ULONG TickCount;     // offset: 0xc ordinal: 0x4
  VOID *StackTrace[5]; // offset: 0x10 ordinal: 0x5
} _VI_TRACK_IRQL;

// 0x4 bytes (sizeof)
typedef struct _HEAP_GLOBAL_APPCOMPAT_FLAGS {
  ULONG SafeInputValidation : 1;  // offset: 0x0 ordinal: 0x0
  ULONG Padding : 1;              // offset: 0x0 ordinal: 0x1
  ULONG CommitLFHSubsegments : 1; // offset: 0x0 ordinal: 0x2
  ULONG AllocateHeapFromEnv : 1;  // offset: 0x0 ordinal: 0x3
} _HEAP_GLOBAL_APPCOMPAT_FLAGS;

// 0x10 bytes (sizeof)
typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
  ULONG Flags;     // offset: 0x0 ordinal: 0x0
  CHAR *FrameName; // offset: 0x8 ordinal: 0x1
} _TEB_ACTIVE_FRAME_CONTEXT;

// 0x4 bytes (sizeof)
typedef struct __anon_3891 {
  ULONG SnapSharedExportsFailed : 1; // offset: 0x0 ordinal: 0x0
  ULONG Spare : 31;                  // offset: 0x0 ordinal: 0x1
} __anon_3891;

// 0x18 bytes (sizeof)
typedef union __anon_3892 {
  struct _VF_TARGET_ALL_SHARED_EXPORT_THUNKS
      AllSharedExportThunks; // offset: 0x0 ordinal: 0x0
  struct __anon_3891 Flags;  // offset: 0x0 ordinal: 0x1
} __anon_3892;

// 0x10 bytes (sizeof)
typedef struct _VF_TRACKER {
  ULONG TrackerFlags; // offset: 0x0 ordinal: 0x0
  ULONG TrackerSize;  // offset: 0x4 ordinal: 0x1
  ULONG TrackerIndex; // offset: 0x8 ordinal: 0x2
  ULONG TraceDepth;   // offset: 0xc ordinal: 0x3
} _VF_TRACKER;

// 0xc bytes (sizeof)
typedef struct _IOP_IRP_EXTENSION_STATUS {
  ULONG Flags;      // offset: 0x0 ordinal: 0x0
  ULONG ActivityId; // offset: 0x4 ordinal: 0x1
  ULONG IoTracking; // offset: 0x8 ordinal: 0x2
} _IOP_IRP_EXTENSION_STATUS;

// 0x28 bytes (sizeof)
typedef struct _PLUGPLAY_CONTROL_STATUS_DATA {
  struct _UNICODE_STRING DeviceInstance; // offset: 0x0 ordinal: 0x0
  ULONG Operation;                       // offset: 0x10 ordinal: 0x1
  ULONG DeviceStatus;                    // offset: 0x14 ordinal: 0x2
  ULONG DeviceProblem;                   // offset: 0x18 ordinal: 0x3
  ULONG Flags;                           // offset: 0x1c ordinal: 0x4
  LONG ProblemStatus;                    // offset: 0x20 ordinal: 0x5
} _PLUGPLAY_CONTROL_STATUS_DATA;

// 0x8 bytes (sizeof)
typedef struct __anon_3856 {
  struct _PLUGPLAY_CONTROL_STATUS_DATA
      *ControlStatusData; // offset: 0x0 ordinal: 0x0
} __anon_3856;

// 0x4 bytes (sizeof)
typedef struct __anon_3855 {
  ULONG Flags; // offset: 0x0 ordinal: 0x0
} __anon_3855;

// 0x4 bytes (sizeof)
typedef struct __anon_3852 {
  ULONG ProblemCodeToClear; // offset: 0x0 ordinal: 0x0
} __anon_3852;

// 0x4 bytes (sizeof)
typedef union _KSTACK_COUNT {
  LONG Value;            // offset: 0x0 ordinal: 0x0
  ULONG State : 3;       // offset: 0x0 ordinal: 0x1
  ULONG StackCount : 29; // offset: 0x0 ordinal: 0x2
} _KSTACK_COUNT;

// 0x18 bytes (sizeof)
typedef struct _RTL_ATOM_TABLE_REFERENCE {
  struct _LIST_ENTRY LowBoxList; // offset: 0x0 ordinal: 0x0
  ULONG LowBoxID;                // offset: 0x10 ordinal: 0x1
  USHORT ReferenceCount;         // offset: 0x14 ordinal: 0x2
  USHORT Flags;                  // offset: 0x16 ordinal: 0x3
} _RTL_ATOM_TABLE_REFERENCE;

// 0x30 bytes (sizeof)
typedef struct _RTL_ATOM_TABLE_ENTRY {
  struct _RTL_ATOM_TABLE_ENTRY *HashLink;     // offset: 0x0 ordinal: 0x0
  USHORT HandleIndex;                         // offset: 0x8 ordinal: 0x1
  USHORT Atom;                                // offset: 0xa ordinal: 0x2
  struct _RTL_ATOM_TABLE_REFERENCE Reference; // offset: 0x10 ordinal: 0x3
  UCHAR NameLength;                           // offset: 0x28 ordinal: 0x4
  WCHAR Name[1];                              // offset: 0x2a ordinal: 0x5
} _RTL_ATOM_TABLE_ENTRY;

// 0x4 bytes (sizeof)
typedef struct __anon_3830 {
  ULONG Type; // offset: 0x0 ordinal: 0x0
} __anon_3830;

// 0x4 bytes (sizeof)
typedef struct __anon_3829 {
  ULONG PercentLevel; // offset: 0x0 ordinal: 0x0
} __anon_3829;

// 0x18 bytes (sizeof)
typedef struct _POP_ACTION_TRIGGER {
  enum POWER_POLICY_DEVICE_TYPE Type; // offset: 0x0 ordinal: 0x0
  ULONG Flags;                        // offset: 0x4 ordinal: 0x1
  struct _POP_TRIGGER_WAIT *Wait;     // offset: 0x8 ordinal: 0x2
  union {
    struct __anon_3829 Battery; // offset: 0x10 ordinal: 0x3
    struct __anon_3830 Button;  // offset: 0x10 ordinal: 0x4
  };
} _POP_ACTION_TRIGGER;

// 0x38 bytes (sizeof)
typedef struct _POP_TRIGGER_WAIT {
  struct _KEVENT Event;                // offset: 0x0 ordinal: 0x0
  LONG Status;                         // offset: 0x18 ordinal: 0x1
  struct _LIST_ENTRY Link;             // offset: 0x20 ordinal: 0x2
  struct _POP_ACTION_TRIGGER *Trigger; // offset: 0x30 ordinal: 0x3
} _POP_TRIGGER_WAIT;

// 0x70 bytes (sizeof)
typedef struct _PI_BUS_EXTENSION {
  ULONG Flags;                                // offset: 0x0 ordinal: 0x0
  UCHAR NumberCSNs;                           // offset: 0x4 ordinal: 0x1
  UCHAR *ReadDataPort;                        // offset: 0x8 ordinal: 0x2
  UCHAR DataPortMapped;                       // offset: 0x10 ordinal: 0x3
  UCHAR *AddressPort;                         // offset: 0x18 ordinal: 0x4
  UCHAR AddrPortMapped;                       // offset: 0x20 ordinal: 0x5
  UCHAR *CommandPort;                         // offset: 0x28 ordinal: 0x6
  UCHAR CmdPortMapped;                        // offset: 0x30 ordinal: 0x7
  ULONG NextSlotNumber;                       // offset: 0x34 ordinal: 0x8
  struct _SINGLE_LIST_ENTRY DeviceList;       // offset: 0x38 ordinal: 0x9
  struct _SINGLE_LIST_ENTRY CardList;         // offset: 0x40 ordinal: 0xa
  struct _DEVICE_OBJECT *PhysicalBusDevice;   // offset: 0x48 ordinal: 0xb
  struct _DEVICE_OBJECT *FunctionalBusDevice; // offset: 0x50 ordinal: 0xc
  struct _DEVICE_OBJECT *AttachedDevice;      // offset: 0x58 ordinal: 0xd
  ULONG BusNumber;                            // offset: 0x60 ordinal: 0xe
  enum _SYSTEM_POWER_STATE SystemPowerState;  // offset: 0x64 ordinal: 0xf
  enum _DEVICE_POWER_STATE DevicePowerState;  // offset: 0x68 ordinal: 0x10
} _PI_BUS_EXTENSION;

// 0x10 bytes (sizeof)
typedef struct _BUS_EXTENSION_LIST {
  VOID *Next;                             // offset: 0x0 ordinal: 0x0
  struct _PI_BUS_EXTENSION *BusExtension; // offset: 0x8 ordinal: 0x1
} _BUS_EXTENSION_LIST;

// 0x18 bytes (sizeof)
typedef struct _THERMAL_POLICY {
  ULONG Version;           // offset: 0x0 ordinal: 0x0
  UCHAR WaitForUpdate;     // offset: 0x4 ordinal: 0x1
  UCHAR Hibernate;         // offset: 0x5 ordinal: 0x2
  UCHAR Critical;          // offset: 0x6 ordinal: 0x3
  UCHAR ThermalStandby;    // offset: 0x7 ordinal: 0x4
  ULONG ActivationReasons; // offset: 0x8 ordinal: 0x5
  ULONG PassiveLimit;      // offset: 0xc ordinal: 0x6
  ULONG ActiveLevel;       // offset: 0x10 ordinal: 0x7
  UCHAR OverThrottled;     // offset: 0x14 ordinal: 0x8
} _THERMAL_POLICY;

// 0x8 bytes (sizeof)
typedef struct BATTERY_REPORTING_SCALE {
  ULONG Granularity; // offset: 0x0 ordinal: 0x0
  ULONG Capacity;    // offset: 0x4 ordinal: 0x1
} BATTERY_REPORTING_SCALE;

// 0x4c bytes (sizeof)
typedef struct SYSTEM_POWER_CAPABILITIES {
  UCHAR PowerButtonPresent;                       // offset: 0x0 ordinal: 0x0
  UCHAR SleepButtonPresent;                       // offset: 0x1 ordinal: 0x1
  UCHAR LidPresent;                               // offset: 0x2 ordinal: 0x2
  UCHAR SystemS1;                                 // offset: 0x3 ordinal: 0x3
  UCHAR SystemS2;                                 // offset: 0x4 ordinal: 0x4
  UCHAR SystemS3;                                 // offset: 0x5 ordinal: 0x5
  UCHAR SystemS4;                                 // offset: 0x6 ordinal: 0x6
  UCHAR SystemS5;                                 // offset: 0x7 ordinal: 0x7
  UCHAR HiberFilePresent;                         // offset: 0x8 ordinal: 0x8
  UCHAR FullWake;                                 // offset: 0x9 ordinal: 0x9
  UCHAR VideoDimPresent;                          // offset: 0xa ordinal: 0xa
  UCHAR ApmPresent;                               // offset: 0xb ordinal: 0xb
  UCHAR UpsPresent;                               // offset: 0xc ordinal: 0xc
  UCHAR ThermalControl;                           // offset: 0xd ordinal: 0xd
  UCHAR ProcessorThrottle;                        // offset: 0xe ordinal: 0xe
  UCHAR ProcessorMinThrottle;                     // offset: 0xf ordinal: 0xf
  UCHAR ProcessorMaxThrottle;                     // offset: 0x10 ordinal: 0x10
  UCHAR FastSystemS4;                             // offset: 0x11 ordinal: 0x11
  UCHAR Hiberboot;                                // offset: 0x12 ordinal: 0x12
  UCHAR WakeAlarmPresent;                         // offset: 0x13 ordinal: 0x13
  UCHAR AoAc;                                     // offset: 0x14 ordinal: 0x14
  UCHAR DiskSpinDown;                             // offset: 0x15 ordinal: 0x15
  UCHAR HiberFileType;                            // offset: 0x16 ordinal: 0x16
  UCHAR AoAcConnectivitySupported;                // offset: 0x17 ordinal: 0x17
  UCHAR spare3[6];                                // offset: 0x18 ordinal: 0x18
  UCHAR SystemBatteriesPresent;                   // offset: 0x1e ordinal: 0x19
  UCHAR BatteriesAreShortTerm;                    // offset: 0x1f ordinal: 0x1a
  struct BATTERY_REPORTING_SCALE BatteryScale[3]; // offset: 0x20 ordinal: 0x1b
  enum _SYSTEM_POWER_STATE AcOnLineWake;          // offset: 0x38 ordinal: 0x1c
  enum _SYSTEM_POWER_STATE SoftLidWake;           // offset: 0x3c ordinal: 0x1d
  enum _SYSTEM_POWER_STATE RtcWake;               // offset: 0x40 ordinal: 0x1e
  enum _SYSTEM_POWER_STATE MinDeviceWakeState;    // offset: 0x44 ordinal: 0x1f
  enum _SYSTEM_POWER_STATE DefaultLowLatencyWake; // offset: 0x48 ordinal: 0x20
} SYSTEM_POWER_CAPABILITIES;

// 0x8 bytes (sizeof)
typedef struct _MI_FLAGS {
  ULONG VerifierEnabled : 1;                        // offset: 0x0 ordinal: 0x0
  ULONG KernelVerifierEnabled : 1;                  // offset: 0x0 ordinal: 0x1
  ULONG LargePageKernel : 1;                        // offset: 0x0 ordinal: 0x2
  ULONG StopOn4d : 1;                               // offset: 0x0 ordinal: 0x3
  ULONG InitializationPhase : 2;                    // offset: 0x0 ordinal: 0x4
  ULONG PageKernelStacks : 1;                       // offset: 0x0 ordinal: 0x5
  ULONG CheckZeroPages : 1;                         // offset: 0x0 ordinal: 0x6
  ULONG ProcessorPrewalks : 1;                      // offset: 0x0 ordinal: 0x7
  ULONG ProcessorPostwalks : 1;                     // offset: 0x0 ordinal: 0x8
  ULONG CoverageBuild : 1;                          // offset: 0x0 ordinal: 0x9
  ULONG CheckExecute : 1;                           // offset: 0x0 ordinal: 0xa
  ULONG ProtectedPagesEnabled : 1;                  // offset: 0x0 ordinal: 0xb
  ULONG SecureRelocations : 1;                      // offset: 0x0 ordinal: 0xc
  ULONG StrongPageIdentity : 1;                     // offset: 0x0 ordinal: 0xd
  ULONG StrongCodeGuarantees : 1;                   // offset: 0x0 ordinal: 0xe
  ULONG HardCodeGuarantees : 1;                     // offset: 0x0 ordinal: 0xf
  ULONG ExecutePagePrivilegeRequired : 1;           // offset: 0x0 ordinal: 0x10
  ULONG SecureKernelCfgEnabled : 1;                 // offset: 0x0 ordinal: 0x11
  ULONG FullHvci : 1;                               // offset: 0x0 ordinal: 0x12
  ULONG BootDebuggerActive : 1;                     // offset: 0x0 ordinal: 0x13
  ULONG ExceptionHandlingReady : 1;                 // offset: 0x0 ordinal: 0x14
  ULONG ShadowStacksSupported : 1;                  // offset: 0x0 ordinal: 0x15
  ULONG AccessBitFenceRequired : 1;                 // offset: 0x0 ordinal: 0x16
  ULONG AccessBitReplacementCapability : 2;         // offset: 0x0 ordinal: 0x17
  ULONG PfnDatabaseExists : 1;                      // offset: 0x0 ordinal: 0x18
  ULONG PfnDatabaseGapsFilled : 1;                  // offset: 0x0 ordinal: 0x19
  ULONG SystemPtesReady : 1;                        // offset: 0x0 ordinal: 0x1a
  ULONG BootImageUnprivilegedPagesUnregistered : 1; // offset: 0x0 ordinal: 0x1b
  ULONG ImageProtectedSlabExecutableOnly : 1;       // offset: 0x0 ordinal: 0x1c
  ULONG SpecialReadOnlyProtectedSlabPages : 1;      // offset: 0x0 ordinal: 0x1d
  ULONG SlabAllocatorsReady : 1;                    // offset: 0x4 ordinal: 0x1e
  ULONG KasanEnabled : 1;                           // offset: 0x4 ordinal: 0x1f
} _MI_FLAGS;

// 0x20 bytes (sizeof)
typedef struct _RTL_RANGE_LIST {
  struct _LIST_ENTRY ListHead; // offset: 0x0 ordinal: 0x0
  ULONG Flags;                 // offset: 0x10 ordinal: 0x1
  ULONG Count;                 // offset: 0x14 ordinal: 0x2
  ULONG Stamp;                 // offset: 0x18 ordinal: 0x3
} _RTL_RANGE_LIST;

// 0x4 bytes (sizeof)
typedef union __anon_3709 {
  ULONG NodeSize;     // offset: 0x0 ordinal: 0x0
  ULONG UseLookaside; // offset: 0x0 ordinal: 0x1
} __anon_3709;

// 0x8 bytes (sizeof)
typedef struct PROCESSOR_IDLESTATE_INFO {
  ULONG TimeCheck;      // offset: 0x0 ordinal: 0x0
  UCHAR DemotePercent;  // offset: 0x4 ordinal: 0x1
  UCHAR PromotePercent; // offset: 0x5 ordinal: 0x2
  UCHAR Spare[2];       // offset: 0x6 ordinal: 0x3
} PROCESSOR_IDLESTATE_INFO;

// 0x20 bytes (sizeof)
typedef struct PROCESSOR_IDLESTATE_POLICY {
  USHORT Revision;                           // offset: 0x0 ordinal: 0x0
  union __anon_3705 Flags;                   // offset: 0x2 ordinal: 0x1
  ULONG PolicyCount;                         // offset: 0x4 ordinal: 0x2
  struct PROCESSOR_IDLESTATE_INFO Policy[3]; // offset: 0x8 ordinal: 0x3
} PROCESSOR_IDLESTATE_POLICY;

// 0x4 bytes (sizeof)
typedef struct _MI_STORE_INPAGE_COMPLETE_FLAGS {
  union {
    ULONG EntireFlags;    // offset: 0x0 ordinal: 0x0
    ULONG StoreFault : 1; // offset: 0x0 ordinal: 0x1
  };
  ULONG LowResourceFailure : 1;  // offset: 0x0 ordinal: 0x2
  ULONG Spare : 14;              // offset: 0x0 ordinal: 0x3
  ULONG RemainingPageCount : 16; // offset: 0x0 ordinal: 0x4
} _MI_STORE_INPAGE_COMPLETE_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _MMINPAGE_FLAGS {
  ULONG GetExtents : 1;              // offset: 0x0 ordinal: 0x0
  ULONG PrefetchSystemVmType : 2;    // offset: 0x0 ordinal: 0x1
  ULONG VaPrefetchReadBlock : 1;     // offset: 0x0 ordinal: 0x2
  ULONG CollidedFlowThrough : 1;     // offset: 0x0 ordinal: 0x3
  ULONG ForceCollisions : 1;         // offset: 0x0 ordinal: 0x4
  ULONG InPageExpanded : 1;          // offset: 0x0 ordinal: 0x5
  ULONG IssuedAtLowPriority : 1;     // offset: 0x0 ordinal: 0x6
  ULONG FaultFromStore : 1;          // offset: 0x0 ordinal: 0x7
  ULONG PagePriority : 3;            // offset: 0x0 ordinal: 0x8
  ULONG ClusteredPagePriority : 3;   // offset: 0x0 ordinal: 0x9
  ULONG MakeClusterValid : 1;        // offset: 0x0 ordinal: 0xa
  ULONG PerformRelocations : 1;      // offset: 0x0 ordinal: 0xb
  ULONG ZeroLastPage : 1;            // offset: 0x0 ordinal: 0xc
  ULONG UserFault : 1;               // offset: 0x0 ordinal: 0xd
  ULONG StandbyProtectionNeeded : 1; // offset: 0x0 ordinal: 0xe
  ULONG PteChanged : 1;              // offset: 0x0 ordinal: 0xf
  ULONG PageFileFault : 1;           // offset: 0x0 ordinal: 0x10
  ULONG PageFilePageHashActive : 1;  // offset: 0x0 ordinal: 0x11
  ULONG CoalescedIo : 1;             // offset: 0x0 ordinal: 0x12
  ULONG VmLockNotNeeded : 1;         // offset: 0x0 ordinal: 0x13
  ULONG Spare0 : 1;                  // offset: 0x0 ordinal: 0x14
  ULONG Spare1 : 6;                  // offset: 0x0 ordinal: 0x15
} _MMINPAGE_FLAGS;

// 0x4 bytes (sizeof)
typedef union __anon_3690 {
  struct _MMINPAGE_FLAGS e1; // offset: 0x0 ordinal: 0x0
  ULONG LongFlags;           // offset: 0x0 ordinal: 0x1
} __anon_3690;

// 0x4 bytes (sizeof)
typedef union __anon_3689 {
  ULONG ImagePteOffset; // offset: 0x0 ordinal: 0x0
  ULONG TossPage;       // offset: 0x0 ordinal: 0x1
} __anon_3689;

// 0x10 bytes (sizeof)
typedef struct _MI_HUGE_SYSTEM_VIEW_HEAD {
  struct _RTL_AVL_TREE ViewRoot; // offset: 0x0 ordinal: 0x0
  ULONG ViewCount;               // offset: 0x8 ordinal: 0x1
  LONG Lock;                     // offset: 0xc ordinal: 0x2
} _MI_HUGE_SYSTEM_VIEW_HEAD;

// 0x8 bytes (sizeof)
typedef struct _MI_PAGEFILE_METADATA_LAYOUT {
  ULONG EntryInBytes;    // offset: 0x0 ordinal: 0x0
  ULONG OwningPteOffset; // offset: 0x4 ordinal: 0x1
} _MI_PAGEFILE_METADATA_LAYOUT;

// 0x10 bytes (sizeof)
typedef struct _MI_IO_CACHE_STATS {
  ULONG UnmappedCacheFlush;           // offset: 0x0 ordinal: 0x0
  ULONG UnmappedCacheConflict;        // offset: 0x4 ordinal: 0x1
  ULONG PermanentIoAttributeConflict; // offset: 0x8 ordinal: 0x2
  ULONG PermanentIoNodeConflict;      // offset: 0xc ordinal: 0x3
} _MI_IO_CACHE_STATS;

// 0x8 bytes (sizeof)
typedef struct _MI_RESAVAIL_FAILURES {
  ULONG Wrap;     // offset: 0x0 ordinal: 0x0
  ULONG NoCharge; // offset: 0x4 ordinal: 0x1
} _MI_RESAVAIL_FAILURES;

// 0x8 bytes (sizeof)
typedef struct _MI_FORCED_COMMITS {
  ULONG Regular; // offset: 0x0 ordinal: 0x0
  ULONG Wrap;    // offset: 0x4 ordinal: 0x1
} _MI_FORCED_COMMITS;

// 0x40 bytes (sizeof)
typedef struct _MI_PROBE_RAISE_TRACKER {
  ULONG UserRangeInKernel;              // offset: 0x0 ordinal: 0x0
  ULONG FaultFailed;                    // offset: 0x4 ordinal: 0x1
  ULONG WriteFaultFailed;               // offset: 0x8 ordinal: 0x2
  ULONG LargePageFailed;                // offset: 0xc ordinal: 0x3
  ULONG UserAccessToKernelPte;          // offset: 0x10 ordinal: 0x4
  ULONG BadPageLocation;                // offset: 0x14 ordinal: 0x5
  ULONG InsufficientCharge;             // offset: 0x18 ordinal: 0x6
  ULONG PageTableCharge;                // offset: 0x1c ordinal: 0x7
  ULONG NoIoReference;                  // offset: 0x20 ordinal: 0x8
  ULONG ProbeFailed;                    // offset: 0x24 ordinal: 0x9
  ULONG PteIsZero;                      // offset: 0x28 ordinal: 0xa
  ULONG StrongCodeWrite;                // offset: 0x2c ordinal: 0xb
  ULONG ReducedCloneCommitChargeFailed; // offset: 0x30 ordinal: 0xc
  ULONG CopyOnWriteAtDispatchNoPages;   // offset: 0x34 ordinal: 0xd
  ULONG NoPageTablesAllowed;            // offset: 0x38 ordinal: 0xe
  ULONG EnclavePageFailed;              // offset: 0x3c ordinal: 0xf
} _MI_PROBE_RAISE_TRACKER;

// 0x28 bytes (sizeof)
typedef struct _MI_SYSTEM_ACCELERATORS {
  struct _LIST_ENTRY HardwareInstances; // offset: 0x0 ordinal: 0x0
  ULONG NumberOfHardwareInstances;      // offset: 0x10 ordinal: 0x1
  UCHAR ShuttingDown;                   // offset: 0x14 ordinal: 0x2
  UCHAR AllocationFailures;             // offset: 0x15 ordinal: 0x3
  UCHAR AllocationQueryFailures;        // offset: 0x16 ordinal: 0x4
  VOID **OpaqueContext;                 // offset: 0x18 ordinal: 0x5
  LONG Lock;                            // offset: 0x20 ordinal: 0x6
} _MI_SYSTEM_ACCELERATORS;

// 0x4 bytes (sizeof)
typedef struct __anon_3562 {
  ULONG AddressWidth; // offset: 0x0 ordinal: 0x0
} __anon_3562;

// 0x8 bytes (sizeof)
typedef struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG {
  enum _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE
      LogicalAllocatorType;                // offset: 0x0 ordinal: 0x0
  struct __anon_3562 BuddyAllocatorConfig; // offset: 0x4 ordinal: 0x1
} _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG;

// 0x4 bytes (sizeof)
typedef union __anon_3549 {
  ULONG AllFlags;                              // offset: 0x0 ordinal: 0x0
  ULONG LkgSupported : 1;                      // offset: 0x0 ordinal: 0x1
  ULONG FinalBootBeforeRecovery : 1;           // offset: 0x0 ordinal: 0x2
  ULONG ConfigurationComparisonAttempted : 1;  // offset: 0x0 ordinal: 0x3
  ULONG CurrentConfigurationLoadAttempted : 1; // offset: 0x0 ordinal: 0x4
  ULONG LkgConfigurationLoadAttempted : 1;     // offset: 0x0 ordinal: 0x5
  ULONG UsageSubscriptionLoadAttempted : 1;    // offset: 0x0 ordinal: 0x6
  ULONG Spare : 26;                            // offset: 0x0 ordinal: 0x7
} __anon_3549;

// 0x18 bytes (sizeof)
typedef struct _LOADER_FEATURE_CONFIGURATION_DIAGNOSTIC_INFORMATION {
  UCHAR OriginalBootStatus;            // offset: 0x0 ordinal: 0x0
  UCHAR NewBootStatus;                 // offset: 0x1 ordinal: 0x1
  UCHAR ConfigurationLoaded;           // offset: 0x2 ordinal: 0x2
  UCHAR Spare;                         // offset: 0x3 ordinal: 0x3
  union __anon_3549 Flags;             // offset: 0x4 ordinal: 0x4
  LONG ConfigurationComparisonStatus;  // offset: 0x8 ordinal: 0x5
  LONG CurrentConfigurationLoadStatus; // offset: 0xc ordinal: 0x6
  LONG LkgConfigurationLoadStatus;     // offset: 0x10 ordinal: 0x7
  LONG UsageSubscriptionLoadStatus;    // offset: 0x14 ordinal: 0x8
} _LOADER_FEATURE_CONFIGURATION_DIAGNOSTIC_INFORMATION;

// 0x4 bytes (sizeof)
typedef struct _INPUT_MAPPING_ELEMENT {
  ULONG InputMappingId; // offset: 0x0 ordinal: 0x0
} _INPUT_MAPPING_ELEMENT;

// 0x20 bytes (sizeof)
typedef struct _NETWORK_LOADER_BLOCK {
  UCHAR *DHCPServerACK;              // offset: 0x0 ordinal: 0x0
  ULONG DHCPServerACKLength;         // offset: 0x8 ordinal: 0x1
  UCHAR *BootServerReplyPacket;      // offset: 0x10 ordinal: 0x2
  ULONG BootServerReplyPacketLength; // offset: 0x18 ordinal: 0x3
} _NETWORK_LOADER_BLOCK;

// 0x4 bytes (sizeof)
typedef struct _DEVICE_FLAGS {
  ULONG Failed : 1;     // offset: 0x0 ordinal: 0x0
  ULONG ReadOnly : 1;   // offset: 0x0 ordinal: 0x1
  ULONG Removable : 1;  // offset: 0x0 ordinal: 0x2
  ULONG ConsoleIn : 1;  // offset: 0x0 ordinal: 0x3
  ULONG ConsoleOut : 1; // offset: 0x0 ordinal: 0x4
  ULONG Input : 1;      // offset: 0x0 ordinal: 0x5
  ULONG Output : 1;     // offset: 0x0 ordinal: 0x6
} _DEVICE_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _PCAT_FIRMWARE_INFORMATION {
  ULONG PlaceHolder; // offset: 0x0 ordinal: 0x0
} _PCAT_FIRMWARE_INFORMATION;

// 0x18 bytes (sizeof)
typedef struct _ETW_BOOT_CONFIG {
  ULONG MaxLoggers;                   // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY BootLoggersList; // offset: 0x8 ordinal: 0x1
} _ETW_BOOT_CONFIG;

// 0x14 bytes (sizeof)
typedef struct _LOADER_HIVE_RECOVERY_INFO {
  ULONG Recovered : 1;          // offset: 0x0 ordinal: 0x0
  ULONG LegacyRecovery : 1;     // offset: 0x0 ordinal: 0x1
  ULONG SoftRebootConflict : 1; // offset: 0x0 ordinal: 0x2
  ULONG MostRecentLog : 3;      // offset: 0x0 ordinal: 0x3
  ULONG LoadedFromSnapshot : 1; // offset: 0x0 ordinal: 0x4
  ULONG Spare : 27;             // offset: 0x4 ordinal: 0x5
  ULONG LogNextSequence;        // offset: 0x8 ordinal: 0x6
  ULONG LogMinimumSequence;     // offset: 0xc ordinal: 0x7
  ULONG LogCurrentOffset;       // offset: 0x10 ordinal: 0x8
} _LOADER_HIVE_RECOVERY_INFO;

// 0x10 bytes (sizeof)
typedef struct _PROFILE_PARAMETER_BLOCK {
  USHORT Status;       // offset: 0x0 ordinal: 0x0
  USHORT Reserved;     // offset: 0x2 ordinal: 0x1
  USHORT DockingState; // offset: 0x4 ordinal: 0x2
  USHORT Capabilities; // offset: 0x6 ordinal: 0x3
  ULONG DockID;        // offset: 0x8 ordinal: 0x4
  ULONG SerialNumber;  // offset: 0xc ordinal: 0x5
} _PROFILE_PARAMETER_BLOCK;

// 0x28 bytes (sizeof)
typedef struct _CONFIGURATION_COMPONENT {
  enum _CONFIGURATION_CLASS Class; // offset: 0x0 ordinal: 0x0
  enum _CONFIGURATION_TYPE Type;   // offset: 0x4 ordinal: 0x1
  struct _DEVICE_FLAGS Flags;      // offset: 0x8 ordinal: 0x2
  USHORT Version;                  // offset: 0xc ordinal: 0x3
  USHORT Revision;                 // offset: 0xe ordinal: 0x4
  ULONG Key;                       // offset: 0x10 ordinal: 0x5
  union {
    ULONG AffinityMask; // offset: 0x14 ordinal: 0x6
    USHORT Group;       // offset: 0x14 ordinal: 0x7
  };
  USHORT GroupIndex;             // offset: 0x16 ordinal: 0x8
  ULONG ConfigurationDataLength; // offset: 0x18 ordinal: 0x9
  ULONG IdentifierLength;        // offset: 0x1c ordinal: 0xa
  CHAR *Identifier;              // offset: 0x20 ordinal: 0xb
} _CONFIGURATION_COMPONENT;

// 0x48 bytes (sizeof)
typedef struct _CONFIGURATION_COMPONENT_DATA {
  struct _CONFIGURATION_COMPONENT_DATA *Parent;   // offset: 0x0 ordinal: 0x0
  struct _CONFIGURATION_COMPONENT_DATA *Child;    // offset: 0x8 ordinal: 0x1
  struct _CONFIGURATION_COMPONENT_DATA *Sibling;  // offset: 0x10 ordinal: 0x2
  struct _CONFIGURATION_COMPONENT ComponentEntry; // offset: 0x18 ordinal: 0x3
  VOID *ConfigurationData;                        // offset: 0x40 ordinal: 0x4
} _CONFIGURATION_COMPONENT_DATA;

// 0x28 bytes (sizeof)
typedef struct _SUPPORTED_RANGE {
  struct _SUPPORTED_RANGE *Next; // offset: 0x0 ordinal: 0x0
  ULONG SystemAddressSpace;      // offset: 0x8 ordinal: 0x1
  LONGLONG SystemBase;           // offset: 0x10 ordinal: 0x2
  LONGLONG Base;                 // offset: 0x18 ordinal: 0x3
  LONGLONG Limit;                // offset: 0x20 ordinal: 0x4
} _SUPPORTED_RANGE;

typedef LONG (*__anon_3456)(ULONG, USHORT, USHORT, ULONG, ULONG);

typedef VOID *(*__anon_3435)(ULONG);

typedef LONG (*__anon_3431)(ULONG, ULONG, VOID **);

typedef VOID (*__anon_3429)(ULONG, VOID *, ULONG);

// 0x4 bytes (sizeof)
typedef struct _ARM_LOADER_BLOCK {
  ULONG PlaceHolder; // offset: 0x0 ordinal: 0x0
} _ARM_LOADER_BLOCK;

// 0x10 bytes (sizeof)
typedef struct _I386_LOADER_BLOCK {
  VOID *CommonDataArea; // offset: 0x0 ordinal: 0x0
  ULONG MachineType;    // offset: 0x8 ordinal: 0x1
  ULONG VirtualBias;    // offset: 0xc ordinal: 0x2
} _I386_LOADER_BLOCK;

// 0x10 bytes (sizeof)
typedef union __anon_3377 {
  struct _I386_LOADER_BLOCK I386; // offset: 0x0 ordinal: 0x0
  struct _ARM_LOADER_BLOCK Arm;   // offset: 0x0 ordinal: 0x1
} __anon_3377;

// 0x18 bytes (sizeof)
typedef struct DEBUG_DEVICE_ADDRESS {
  UCHAR Type;  // offset: 0x0 ordinal: 0x0
  UCHAR Valid; // offset: 0x1 ordinal: 0x1
  union {
    UCHAR Reserved[2]; // offset: 0x2 ordinal: 0x2
    UCHAR BitWidth;    // offset: 0x2 ordinal: 0x3
  };
  UCHAR AccessSize;         // offset: 0x3 ordinal: 0x4
  UCHAR *TranslatedAddress; // offset: 0x8 ordinal: 0x5
  ULONG Length;             // offset: 0x10 ordinal: 0x6
} DEBUG_DEVICE_ADDRESS;

typedef ULONG (*__anon_3416)(struct _BUS_HANDLER *, struct _BUS_HANDLER *,
                             ULONG, VOID *, ULONG, ULONG);

// 0xc0 bytes (sizeof)
typedef struct _SUPPORTED_RANGES {
  USHORT Version;                         // offset: 0x0 ordinal: 0x0
  UCHAR Sorted;                           // offset: 0x2 ordinal: 0x1
  UCHAR Reserved;                         // offset: 0x3 ordinal: 0x2
  ULONG NoIO;                             // offset: 0x4 ordinal: 0x3
  struct _SUPPORTED_RANGE IO;             // offset: 0x8 ordinal: 0x4
  ULONG NoMemory;                         // offset: 0x30 ordinal: 0x5
  struct _SUPPORTED_RANGE Memory;         // offset: 0x38 ordinal: 0x6
  ULONG NoPrefetchMemory;                 // offset: 0x60 ordinal: 0x7
  struct _SUPPORTED_RANGE PrefetchMemory; // offset: 0x68 ordinal: 0x8
  ULONG NoDma;                            // offset: 0x90 ordinal: 0x9
  struct _SUPPORTED_RANGE Dma;            // offset: 0x98 ordinal: 0xa
} _SUPPORTED_RANGES;

// 0xc bytes (sizeof)
typedef struct _DEBUG_TRANSPORT_DATA {
  ULONG HwContextSize;         // offset: 0x0 ordinal: 0x0
  ULONG SharedVisibleDataSize; // offset: 0x4 ordinal: 0x1
  UCHAR UseSerialFraming;      // offset: 0x8 ordinal: 0x2
  UCHAR ValidUSBCoreId;        // offset: 0x9 ordinal: 0x3
  UCHAR USBCoreId;             // offset: 0xa ordinal: 0x4
} _DEBUG_TRANSPORT_DATA;

typedef VOID (*__anon_3357)(ULONG, LONG *);

// 0x20 bytes (sizeof)
typedef struct _HAL_UNMASKED_INTERRUPT_INFORMATION {
  USHORT Version;                            // offset: 0x0 ordinal: 0x0
  USHORT Size;                               // offset: 0x2 ordinal: 0x1
  union _HAL_UNMASKED_INTERRUPT_FLAGS Flags; // offset: 0x4 ordinal: 0x2
  enum _KINTERRUPT_MODE Mode;                // offset: 0x8 ordinal: 0x3
  enum _KINTERRUPT_POLARITY Polarity;        // offset: 0xc ordinal: 0x4
  ULONG Gsiv;                                // offset: 0x10 ordinal: 0x5
  USHORT PinNumber;                          // offset: 0x14 ordinal: 0x6
  VOID *DeviceHandle;                        // offset: 0x18 ordinal: 0x7
} _HAL_UNMASKED_INTERRUPT_INFORMATION;

typedef UCHAR (*__anon_3353)(VOID *,
                             struct _HAL_UNMASKED_INTERRUPT_INFORMATION *);

typedef LONG (*__anon_3275)(
    UCHAR (*)(VOID *, struct _HAL_UNMASKED_INTERRUPT_INFORMATION *), VOID *,
    struct _HAL_UNMASKED_INTERRUPT_INFORMATION *);

// 0xc bytes (sizeof)
typedef struct _PCI_BUSMASTER_DESCRIPTOR {
  enum _PCI_BUSMASTER_RID_TYPE Type; // offset: 0x0 ordinal: 0x0
  ULONG Segment;                     // offset: 0x4 ordinal: 0x1
  union {
    struct __anon_3382 DeviceRid;       // offset: 0x8 ordinal: 0x2
    struct __anon_3382 BridgeRid;       // offset: 0x8 ordinal: 0x3
    struct __anon_3383 MultipleBridges; // offset: 0x8 ordinal: 0x4
  };
} _PCI_BUSMASTER_DESCRIPTOR;

// 0x10 bytes (sizeof)
typedef struct _HAL_LOG_REGISTER_CONTEXT {
  VOID (*LogRoutine)(ULONG, VOID *, ULONG); // offset: 0x0 ordinal: 0x0
  ULONG Flag;                               // offset: 0x8 ordinal: 0x1
} _HAL_LOG_REGISTER_CONTEXT;

typedef VOID (*__anon_3261)(struct _HAL_LOG_REGISTER_CONTEXT *);

typedef VOID (*__anon_3278)(struct _MDL *, ULONG, ULONG, ULONG, ULONG, UCHAR);

typedef LONG (*__anon_3272)(ULONG, VOID *, LONG (*)(VOID *));

typedef LONG (*__anon_3269)(ULONG, enum _KPROFILE_SOURCE *, ULONG,
                            struct _HAL_PMC_COUNTERS **);

typedef UCHAR (*__anon_3263)(ULONG, ULONG);

typedef ULONG (*__anon_3244)(ULONG, ULONG, VOID *, ULONG, ULONG);

typedef UCHAR (*__anon_3242)(ULONG);

typedef LONG (*__anon_3232)(enum _INTERFACE_TYPE, enum _BUS_DATA_TYPE, ULONG,
                            enum _INTERFACE_TYPE, ULONG, ULONG,
                            LONG (*)(struct _BUS_HANDLER *),
                            struct _BUS_HANDLER **);

typedef struct _BUS_HANDLER *(*__anon_3231)(enum _BUS_DATA_TYPE, ULONG);

typedef struct _BUS_HANDLER *(*__anon_3230)(enum _INTERFACE_TYPE, ULONG);

// 0xc bytes (sizeof)
typedef struct POWER_ACTION_POLICY {
  enum POWER_ACTION Action; // offset: 0x0 ordinal: 0x0
  ULONG Flags;              // offset: 0x4 ordinal: 0x1
  ULONG EventCode;          // offset: 0x8 ordinal: 0x2
} POWER_ACTION_POLICY;

// 0x18 bytes (sizeof)
typedef struct SYSTEM_POWER_LEVEL {
  UCHAR Enable;                            // offset: 0x0 ordinal: 0x0
  UCHAR Spare[3];                          // offset: 0x1 ordinal: 0x1
  ULONG BatteryLevel;                      // offset: 0x4 ordinal: 0x2
  struct POWER_ACTION_POLICY PowerPolicy;  // offset: 0x8 ordinal: 0x3
  enum _SYSTEM_POWER_STATE MinSystemState; // offset: 0x14 ordinal: 0x4
} SYSTEM_POWER_LEVEL;

// 0x28 bytes (sizeof)
typedef struct _VF_SUSPECT_DRIVER_ENTRY {
  struct _LIST_ENTRY Links;        // offset: 0x0 ordinal: 0x0
  ULONG Loads;                     // offset: 0x10 ordinal: 0x1
  ULONG Unloads;                   // offset: 0x14 ordinal: 0x2
  struct _UNICODE_STRING BaseName; // offset: 0x18 ordinal: 0x3
} _VF_SUSPECT_DRIVER_ENTRY;

// 0x4 bytes (sizeof)
typedef struct __anon_3133 {
  ULONG MissedEtwRegistration : 1; // offset: 0x0 ordinal: 0x0
  ULONG IsBootDriver : 1;          // offset: 0x0 ordinal: 0x1
  ULONG Spare : 30;                // offset: 0x0 ordinal: 0x2
} __anon_3133;

// 0x4 bytes (sizeof)
typedef union __anon_3134 {
  struct __anon_3133 Flags; // offset: 0x0 ordinal: 0x0
  ULONG Whole;              // offset: 0x0 ordinal: 0x1
} __anon_3134;

// 0x4 bytes (sizeof)
typedef struct _HEAP_STOP_ON_TAG {
  union {
    ULONG HeapAndTagIndex; // offset: 0x0 ordinal: 0x0
    USHORT TagIndex;       // offset: 0x0 ordinal: 0x1
  };
  USHORT HeapIndex; // offset: 0x2 ordinal: 0x2
} _HEAP_STOP_ON_TAG;

// 0x4 bytes (sizeof)
typedef union __anon_3127 {
  ULONG ReferenceCount;     // offset: 0x0 ordinal: 0x0
  ULONG NumberOfPtesToFree; // offset: 0x0 ordinal: 0x1
} __anon_3127;

// 0x4 bytes (sizeof)
typedef struct _MI_SUBSECTION_ENTRY1 {
  ULONG CrossPartitionReferences : 30; // offset: 0x0 ordinal: 0x0
  ULONG SubsectionMappedLarge : 2;     // offset: 0x0 ordinal: 0x1
} _MI_SUBSECTION_ENTRY1;

// 0x4 bytes (sizeof)
typedef union __anon_3121 {
  struct _MI_SUBSECTION_ENTRY1 e1; // offset: 0x0 ordinal: 0x0
  ULONG EntireField;               // offset: 0x0 ordinal: 0x1
} __anon_3121;

// 0x4 bytes (sizeof)
typedef union __anon_3119 {
  ULONG LongFlags;                            // offset: 0x0 ordinal: 0x0
  struct _MMSUBSECTION_FLAGS SubsectionFlags; // offset: 0x0 ordinal: 0x1
} __anon_3119;

// 0xc bytes (sizeof)
typedef struct _OBJECT_REF_STACK_INFO {
  ULONG Sequence;   // offset: 0x0 ordinal: 0x0
  USHORT Index;     // offset: 0x4 ordinal: 0x1
  USHORT NumTraces; // offset: 0x6 ordinal: 0x2
  ULONG Tag;        // offset: 0x8 ordinal: 0x3
} _OBJECT_REF_STACK_INFO;

// 0x48 bytes (sizeof)
typedef struct _PO_NOTIFY_ORDER_LEVEL {
  ULONG DeviceCount;             // offset: 0x0 ordinal: 0x0
  ULONG ActiveCount;             // offset: 0x4 ordinal: 0x1
  struct _LIST_ENTRY WaitSleep;  // offset: 0x8 ordinal: 0x2
  struct _LIST_ENTRY ReadySleep; // offset: 0x18 ordinal: 0x3
  struct _LIST_ENTRY ReadyS0;    // offset: 0x28 ordinal: 0x4
  struct _LIST_ENTRY WaitS0;     // offset: 0x38 ordinal: 0x5
} _PO_NOTIFY_ORDER_LEVEL;

// 0x180 bytes (sizeof)
typedef struct _PO_DEVICE_NOTIFY_ORDER {
  UCHAR Locked;                                // offset: 0x0 ordinal: 0x0
  struct _DEVICE_OBJECT **WarmEjectPdoPointer; // offset: 0x8 ordinal: 0x1
  struct _PO_NOTIFY_ORDER_LEVEL OrderLevel[5]; // offset: 0x10 ordinal: 0x2
  ULONG Flags;                                 // offset: 0x178 ordinal: 0x3
} _PO_DEVICE_NOTIFY_ORDER;

// 0x2b0 bytes (sizeof)
typedef struct _KPRIQUEUE {
  struct _DISPATCHER_HEADER Header;     // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY EntryListHead[32]; // offset: 0x18 ordinal: 0x1
  LONG CurrentCount[32];                // offset: 0x218 ordinal: 0x2
  ULONG MaximumCount;                   // offset: 0x298 ordinal: 0x3
  struct _LIST_ENTRY ThreadListHead;    // offset: 0x2a0 ordinal: 0x4
} _KPRIQUEUE;

// 0x2b0 bytes (sizeof)
typedef struct _TRIAGE_EX_WORK_QUEUE {
  struct _KPRIQUEUE WorkPriQueue; // offset: 0x0 ordinal: 0x0
} _TRIAGE_EX_WORK_QUEUE;

// 0x28 bytes (sizeof)
typedef struct _TRIAGE_9F_POWER {
  USHORT Signature;                                 // offset: 0x0 ordinal: 0x0
  USHORT Revision;                                  // offset: 0x2 ordinal: 0x1
  struct _LIST_ENTRY *IrpList;                      // offset: 0x8 ordinal: 0x2
  struct _LIST_ENTRY *ThreadList;                   // offset: 0x10 ordinal: 0x3
  struct _TRIAGE_EX_WORK_QUEUE *DelayedWorkQueue;   // offset: 0x18 ordinal: 0x4
  struct _TRIAGE_EX_WORK_QUEUE *DelayedIoWorkQueue; // offset: 0x20 ordinal: 0x5
} _TRIAGE_9F_POWER;

// 0x20 bytes (sizeof)
typedef struct _TRIAGE_9F_PNP {
  USHORT Signature; // offset: 0x0 ordinal: 0x0
  USHORT Revision;  // offset: 0x2 ordinal: 0x1
  struct _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE
      *CompletionQueue;                             // offset: 0x8 ordinal: 0x2
  struct _TRIAGE_EX_WORK_QUEUE *DelayedWorkQueue;   // offset: 0x10 ordinal: 0x3
  struct _TRIAGE_EX_WORK_QUEUE *DelayedIoWorkQueue; // offset: 0x18 ordinal: 0x4
} _TRIAGE_9F_PNP;

// 0x4 bytes (sizeof)
typedef struct __anon_3097 {
  ULONG ExtendedDestination : 24; // offset: 0x0 ordinal: 0x0
  ULONG Reserved : 6;             // offset: 0x0 ordinal: 0x1
  ULONG PassPW : 1;               // offset: 0x0 ordinal: 0x2
  ULONG WaitingForEOI : 1;        // offset: 0x0 ordinal: 0x3
} __anon_3097;

// 0x4 bytes (sizeof)
typedef struct __anon_3096 {
  ULONG Mask : 1;            // offset: 0x0 ordinal: 0x0
  ULONG Polarity : 1;        // offset: 0x0 ordinal: 0x1
  ULONG MessageType : 3;     // offset: 0x0 ordinal: 0x2
  ULONG RequestEOI : 1;      // offset: 0x0 ordinal: 0x3
  ULONG DestinationMode : 1; // offset: 0x0 ordinal: 0x4
  ULONG MessageType3 : 1;    // offset: 0x0 ordinal: 0x5
  ULONG Destination : 8;     // offset: 0x0 ordinal: 0x6
  ULONG Vector : 8;          // offset: 0x0 ordinal: 0x7
  ULONG ExtendedAddress : 8; // offset: 0x0 ordinal: 0x8
} __anon_3096;

// 0x4 bytes (sizeof)
typedef union __anon_3091 {
  struct __anon_3097 bits; // offset: 0x0 ordinal: 0x0
  ULONG AsULONG;           // offset: 0x0 ordinal: 0x1
} __anon_3091;

// 0x4 bytes (sizeof)
typedef union __anon_3090 {
  struct __anon_3096 bits; // offset: 0x0 ordinal: 0x0
  ULONG AsULONG;           // offset: 0x0 ordinal: 0x1
} __anon_3090;

// 0x8 bytes (sizeof)
typedef struct _INTERRUPT_HT_INTR_INFO {
  union __anon_3090 LowPart;  // offset: 0x0 ordinal: 0x0
  union __anon_3091 HighPart; // offset: 0x4 ordinal: 0x1
} _INTERRUPT_HT_INTR_INFO;

// 0x8 bytes (sizeof)
typedef struct __anon_3077 {
  struct _INTERRUPT_HT_INTR_INFO IntrInfo; // offset: 0x0 ordinal: 0x0
} __anon_3077;

// 0xc bytes (sizeof)
typedef struct __anon_3089 {
  ULONG MessageAddressHigh; // offset: 0x0 ordinal: 0x0
  ULONG MessageAddressLow;  // offset: 0x4 ordinal: 0x1
  USHORT MessageData;       // offset: 0x8 ordinal: 0x2
  USHORT Reserved;          // offset: 0xa ordinal: 0x3
} __anon_3089;

// 0xc bytes (sizeof)
typedef union __anon_3081 {
  struct __anon_3089 Msi; // offset: 0x0 ordinal: 0x0
} __anon_3081;

// 0x8 bytes (sizeof)
typedef struct __anon_3075 {
  ULONG Gsiv;               // offset: 0x0 ordinal: 0x0
  ULONG WakeInterrupt : 1;  // offset: 0x4 ordinal: 0x1
  ULONG ReservedFlags : 31; // offset: 0x4 ordinal: 0x2
} __anon_3075;

// 0x10 bytes (sizeof)
typedef struct _INTERRUPT_REMAPPING_INFO {
  ULONG IrtIndex : 30;       // offset: 0x0 ordinal: 0x0
  ULONG FlagHalInternal : 1; // offset: 0x0 ordinal: 0x1
  ULONG FlagTranslated : 1;  // offset: 0x0 ordinal: 0x2
  union __anon_3081 u;       // offset: 0x4 ordinal: 0x3
} _INTERRUPT_REMAPPING_INFO;

// 0x48 bytes (sizeof)
typedef struct _SK_CRASH_MODULE {
  WCHAR ImageName[32]; // offset: 0x0 ordinal: 0x0
  ULONG SizeOfImage;   // offset: 0x40 ordinal: 0x1
  ULONG TimeDateStamp; // offset: 0x44 ordinal: 0x2
} _SK_CRASH_MODULE;

// 0x4 bytes (sizeof)
typedef union __anon_3059 {
  ULONG Active : 1;             // offset: 0x0 ordinal: 0x0
  ULONG OnlyTryAcquireUsed : 1; // offset: 0x0 ordinal: 0x1
  ULONG ReleasedOutOfOrder : 1; // offset: 0x0 ordinal: 0x2
  ULONG SequenceNumber : 29;    // offset: 0x0 ordinal: 0x3
  ULONG Whole;                  // offset: 0x0 ordinal: 0x4
} __anon_3059;

// 0x38 bytes (sizeof)
typedef struct _VI_DEADLOCK_THREAD {
  struct _KTHREAD *Thread;                    // offset: 0x0 ordinal: 0x0
  struct _VI_DEADLOCK_NODE *CurrentSpinNode;  // offset: 0x8 ordinal: 0x1
  struct _VI_DEADLOCK_NODE *CurrentOtherNode; // offset: 0x10 ordinal: 0x2
  union {
    struct _LIST_ENTRY ListEntry;     // offset: 0x18 ordinal: 0x3
    struct _LIST_ENTRY FreeListEntry; // offset: 0x18 ordinal: 0x4
  };
  ULONG NodeCount;            // offset: 0x28 ordinal: 0x5
  ULONG PagingCount;          // offset: 0x2c ordinal: 0x6
  UCHAR ThreadUsesEresources; // offset: 0x30 ordinal: 0x7
} _VI_DEADLOCK_THREAD;

// 0xf8 bytes (sizeof)
typedef struct _VI_DEADLOCK_RESOURCE {
  enum _VI_DEADLOCK_RESOURCE_TYPE Type;    // offset: 0x0 ordinal: 0x0
  ULONG NodeCount : 16;                    // offset: 0x4 ordinal: 0x1
  ULONG RecursionCount : 16;               // offset: 0x4 ordinal: 0x2
  VOID *ResourceAddress;                   // offset: 0x8 ordinal: 0x3
  struct _VI_DEADLOCK_THREAD *ThreadOwner; // offset: 0x10 ordinal: 0x4
  struct _LIST_ENTRY ResourceList;         // offset: 0x18 ordinal: 0x5
  union {
    struct _LIST_ENTRY HashChainList; // offset: 0x28 ordinal: 0x6
    struct _LIST_ENTRY FreeListEntry; // offset: 0x28 ordinal: 0x7
  };
  VOID *StackTrace[8];       // offset: 0x38 ordinal: 0x8
  VOID *LastAcquireTrace[8]; // offset: 0x78 ordinal: 0x9
  VOID *LastReleaseTrace[8]; // offset: 0xb8 ordinal: 0xa
} _VI_DEADLOCK_RESOURCE;

// 0xd0 bytes (sizeof)
typedef struct _VI_DEADLOCK_NODE {
  struct _VI_DEADLOCK_NODE *Parent; // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY ChildrenList;  // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY SiblingsList;  // offset: 0x18 ordinal: 0x2
  union {
    struct _LIST_ENTRY ResourceList;  // offset: 0x28 ordinal: 0x3
    struct _LIST_ENTRY FreeListEntry; // offset: 0x28 ordinal: 0x4
  };
  struct _VI_DEADLOCK_RESOURCE *Root;      // offset: 0x38 ordinal: 0x5
  struct _VI_DEADLOCK_THREAD *ThreadEntry; // offset: 0x40 ordinal: 0x6
  union __anon_3059 u1;                    // offset: 0x48 ordinal: 0x7
  LONG ChildrenCount;                      // offset: 0x4c ordinal: 0x8
  VOID *StackTrace[8];                     // offset: 0x50 ordinal: 0x9
  VOID *ParentStackTrace[8];               // offset: 0x90 ordinal: 0xa
} _VI_DEADLOCK_NODE;

// 0x10 bytes (sizeof)
typedef struct _WNF_STATE_DATA {
  struct _WNF_NODE_HEADER Header; // offset: 0x0 ordinal: 0x0
  ULONG AllocatedSize;            // offset: 0x4 ordinal: 0x1
  ULONG DataSize;                 // offset: 0x8 ordinal: 0x2
  ULONG ChangeStamp;              // offset: 0xc ordinal: 0x3
} _WNF_STATE_DATA;

// 0x4 bytes (sizeof)
typedef union _WHEAP_ERROR_RECORD_WRAPPER_FLAGS {
  ULONG Preallocated : 1;            // offset: 0x0 ordinal: 0x0
  ULONG FromPersistentStore : 1;     // offset: 0x0 ordinal: 0x1
  ULONG PlatformPfaControl : 1;      // offset: 0x0 ordinal: 0x2
  ULONG PlatformDirectedOffline : 1; // offset: 0x0 ordinal: 0x3
  ULONG Reserved : 28;               // offset: 0x0 ordinal: 0x4
  ULONG AsULONG;                     // offset: 0x0 ordinal: 0x5
} _WHEAP_ERROR_RECORD_WRAPPER_FLAGS;

// 0x38 bytes (sizeof)
typedef struct _WHEAP_ERROR_SOURCE_TABLE {
  ULONG Signature;           // offset: 0x0 ordinal: 0x0
  LONG Count;                // offset: 0x4 ordinal: 0x1
  ULONG NextId;              // offset: 0x8 ordinal: 0x2
  struct _LIST_ENTRY Items;  // offset: 0x10 ordinal: 0x3
  struct _KEVENT InsertLock; // offset: 0x20 ordinal: 0x4
} _WHEAP_ERROR_SOURCE_TABLE;

// 0x18 bytes (sizeof)
typedef struct _OBP_LOOKUP_CONTEXT {
  struct _OBJECT_DIRECTORY *Directory;        // offset: 0x0 ordinal: 0x0
  struct _OBJECT_DIRECTORY_ENTRY **EntryLink; // offset: 0x8 ordinal: 0x1
  ULONG HashValue;                            // offset: 0x10 ordinal: 0x2
  UCHAR HashIndex;                            // offset: 0x14 ordinal: 0x3
  UCHAR LockedExclusive;                      // offset: 0x15 ordinal: 0x4
  UCHAR DirectoryReferenced;                  // offset: 0x16 ordinal: 0x5
  UCHAR Unused;                               // offset: 0x17 ordinal: 0x6
} _OBP_LOOKUP_CONTEXT;

// 0x20 bytes (sizeof)
typedef struct _OBJECT_HEADER_CREATOR_INFO {
  struct _LIST_ENTRY TypeList;  // offset: 0x0 ordinal: 0x0
  VOID *CreatorUniqueProcess;   // offset: 0x10 ordinal: 0x1
  USHORT CreatorBackTraceIndex; // offset: 0x18 ordinal: 0x2
  USHORT Reserved1;             // offset: 0x1a ordinal: 0x3
  ULONG Reserved2;              // offset: 0x1c ordinal: 0x4
} _OBJECT_HEADER_CREATOR_INFO;

// 0x20 bytes (sizeof)
typedef struct _OBJECT_HEADER_NAME_INFO {
  struct _OBJECT_DIRECTORY *Directory; // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING Name;         // offset: 0x8 ordinal: 0x1
  LONG ReferenceCount;                 // offset: 0x18 ordinal: 0x2
  ULONG Reserved;                      // offset: 0x1c ordinal: 0x3
} _OBJECT_HEADER_NAME_INFO;

// 0x60 bytes (sizeof)
typedef struct _IOP_FILE_OBJECT_EXTENSION {
  ULONG FoExtFlags;                         // offset: 0x0 ordinal: 0x0
  VOID *FoExtPerTypeExtension[10];          // offset: 0x8 ordinal: 0x1
  enum _IOP_PRIORITY_HINT FoIoPriorityHint; // offset: 0x58 ordinal: 0x2
} _IOP_FILE_OBJECT_EXTENSION;

// 0x10 bytes (sizeof)
typedef struct _OB_EXTENDED_PARSE_PARAMETERS {
  USHORT Length;              // offset: 0x0 ordinal: 0x0
  ULONG RestrictedAccessMask; // offset: 0x4 ordinal: 0x1
  struct _EJOB *Silo;         // offset: 0x8 ordinal: 0x2
} _OB_EXTENDED_PARSE_PARAMETERS;

// 0x10 bytes (sizeof)
typedef struct _OBJECT_DUMP_CONTROL {
  VOID *Stream; // offset: 0x0 ordinal: 0x0
  ULONG Detail; // offset: 0x8 ordinal: 0x1
} _OBJECT_DUMP_CONTROL;

typedef VOID (*__anon_2924)(VOID *, struct _OBJECT_DUMP_CONTROL *);

// 0x30 bytes (sizeof)
typedef struct _OBJECT_ATTRIBUTES {
  ULONG Length;                       // offset: 0x0 ordinal: 0x0
  VOID *RootDirectory;                // offset: 0x8 ordinal: 0x1
  struct _UNICODE_STRING *ObjectName; // offset: 0x10 ordinal: 0x2
  ULONG Attributes;                   // offset: 0x18 ordinal: 0x3
  VOID *SecurityDescriptor;           // offset: 0x20 ordinal: 0x4
  VOID *SecurityQualityOfService;     // offset: 0x28 ordinal: 0x5
} _OBJECT_ATTRIBUTES;

// 0x4 bytes (sizeof)
typedef struct __anon_2912 {
  ULONG Secure : 1; // offset: 0x0 ordinal: 0x0
} __anon_2912;

// 0x4 bytes (sizeof)
typedef union __anon_2911 {
  struct __anon_2912 s1; // offset: 0x0 ordinal: 0x0
} __anon_2911;

// 0x4 bytes (sizeof)
typedef struct __anon_2909 {
  ULONG WriteAccess : 1; // offset: 0x0 ordinal: 0x0
  ULONG AutoRelease : 1; // offset: 0x0 ordinal: 0x1
  ULONG ForceUnlink : 1; // offset: 0x0 ordinal: 0x2
  ULONG SystemSpace : 1; // offset: 0x0 ordinal: 0x3
} __anon_2909;

// 0x4 bytes (sizeof)
typedef union __anon_2904 {
  struct __anon_2909 s1; // offset: 0x0 ordinal: 0x0
} __anon_2904;

// 0x4 bytes (sizeof)
typedef struct __anon_2907 {
  ULONG Revoked : 1;      // offset: 0x0 ordinal: 0x0
  ULONG Impersonated : 1; // offset: 0x0 ordinal: 0x1
} __anon_2907;

// 0x4 bytes (sizeof)
typedef union __anon_2902 {
  struct __anon_2907 s1; // offset: 0x0 ordinal: 0x0
} __anon_2902;

// 0x8 bytes (sizeof)
typedef struct _ALPC_WORK_ON_BEHALF_TICKET {
  ULONG ThreadId;              // offset: 0x0 ordinal: 0x0
  ULONG ThreadCreationTimeLow; // offset: 0x4 ordinal: 0x1
} _ALPC_WORK_ON_BEHALF_TICKET;

// 0x8 bytes (sizeof)
typedef struct _KALPC_WORK_ON_BEHALF_DATA {
  struct _ALPC_WORK_ON_BEHALF_TICKET Ticket; // offset: 0x0 ordinal: 0x0
} _KALPC_WORK_ON_BEHALF_DATA;

// 0x4 bytes (sizeof)
typedef struct __anon_2889 {
  ULONG QueueType : 3;                    // offset: 0x0 ordinal: 0x0
  ULONG QueuePortType : 4;                // offset: 0x0 ordinal: 0x1
  ULONG Canceled : 1;                     // offset: 0x0 ordinal: 0x2
  ULONG Ready : 1;                        // offset: 0x0 ordinal: 0x3
  ULONG ReleaseMessage : 1;               // offset: 0x0 ordinal: 0x4
  ULONG SharedQuota : 1;                  // offset: 0x0 ordinal: 0x5
  ULONG ReplyWaitReply : 1;               // offset: 0x0 ordinal: 0x6
  ULONG OwnerPortReference : 1;           // offset: 0x0 ordinal: 0x7
  ULONG ReceiverReference : 1;            // offset: 0x0 ordinal: 0x8
  ULONG ViewAttributeRetrieved : 1;       // offset: 0x0 ordinal: 0x9
  ULONG ViewAttributeDeleteOnRelease : 1; // offset: 0x0 ordinal: 0xa
  ULONG InDispatch : 1;                   // offset: 0x0 ordinal: 0xb
  ULONG InCanceledQueue : 1;              // offset: 0x0 ordinal: 0xc
} __anon_2889;

// 0x4 bytes (sizeof)
typedef union __anon_2884 {
  struct __anon_2889 s1; // offset: 0x0 ordinal: 0x0
  ULONG State;           // offset: 0x0 ordinal: 0x1
} __anon_2884;

// 0x4 bytes (sizeof)
typedef struct __anon_2880 {
  ULONG Initialized : 1;          // offset: 0x0 ordinal: 0x0
  ULONG Type : 2;                 // offset: 0x0 ordinal: 0x1
  ULONG ConnectionPending : 1;    // offset: 0x0 ordinal: 0x2
  ULONG ConnectionRefused : 1;    // offset: 0x0 ordinal: 0x3
  ULONG Disconnected : 1;         // offset: 0x0 ordinal: 0x4
  ULONG Closed : 1;               // offset: 0x0 ordinal: 0x5
  ULONG NoFlushOnClose : 1;       // offset: 0x0 ordinal: 0x6
  ULONG ReturnExtendedInfo : 1;   // offset: 0x0 ordinal: 0x7
  ULONG Waitable : 1;             // offset: 0x0 ordinal: 0x8
  ULONG DynamicSecurity : 1;      // offset: 0x0 ordinal: 0x9
  ULONG Wow64CompletionList : 1;  // offset: 0x0 ordinal: 0xa
  ULONG Lpc : 1;                  // offset: 0x0 ordinal: 0xb
  ULONG LpcToLpc : 1;             // offset: 0x0 ordinal: 0xc
  ULONG HasCompletionList : 1;    // offset: 0x0 ordinal: 0xd
  ULONG HadCompletionList : 1;    // offset: 0x0 ordinal: 0xe
  ULONG EnableCompletionList : 1; // offset: 0x0 ordinal: 0xf
} __anon_2880;

// 0x4 bytes (sizeof)
typedef union __anon_2873 {
  struct __anon_2880 s1; // offset: 0x0 ordinal: 0x0
  ULONG State;           // offset: 0x0 ordinal: 0x1
} __anon_2873;

// 0x4 bytes (sizeof)
typedef struct __anon_2858 {
  ULONG Internal : 1; // offset: 0x0 ordinal: 0x0
  ULONG Secure : 1;   // offset: 0x0 ordinal: 0x1
} __anon_2858;

// 0x4 bytes (sizeof)
typedef union __anon_2859 {
  struct __anon_2858 s1; // offset: 0x0 ordinal: 0x0
} __anon_2859;

// 0x8 bytes (sizeof)
typedef struct _BLOB_COUNTERS {
  ULONG CreatedObjects; // offset: 0x0 ordinal: 0x0
  ULONG DeletedObjects; // offset: 0x4 ordinal: 0x1
} _BLOB_COUNTERS;

// 0x8 bytes (sizeof)
typedef struct _ALPC_MESSAGE_ATTRIBUTES {
  ULONG AllocatedAttributes; // offset: 0x0 ordinal: 0x0
  ULONG ValidAttributes;     // offset: 0x4 ordinal: 0x1
} _ALPC_MESSAGE_ATTRIBUTES;

// 0x4 bytes (sizeof)
typedef union __anon_2847 {
  struct __anon_2846 s2; // offset: 0x0 ordinal: 0x0
  ULONG ZeroInit;        // offset: 0x0 ordinal: 0x1
} __anon_2847;

// 0x4 bytes (sizeof)
typedef union __anon_2845 {
  struct __anon_2844 s1; // offset: 0x0 ordinal: 0x0
  ULONG Length;          // offset: 0x0 ordinal: 0x1
} __anon_2845;

// 0x10 bytes (sizeof)
typedef struct _HEAP_EXTENDED_ENTRY {
  VOID *Reserved;               // offset: 0x0 ordinal: 0x0
  USHORT FunctionIndex;         // offset: 0x8 ordinal: 0x1
  USHORT ContextValue;          // offset: 0xa ordinal: 0x2
  ULONG InterceptorValue;       // offset: 0x8 ordinal: 0x3
  USHORT UnusedBytesLength;     // offset: 0xc ordinal: 0x4
  UCHAR EntryOffset;            // offset: 0xe ordinal: 0x5
  UCHAR ExtendedBlockSignature; // offset: 0xf ordinal: 0x6
} _HEAP_EXTENDED_ENTRY;

// 0x4 bytes (sizeof)
typedef struct _HEAP_DESCRIPTOR_KEY {
  union {
    ULONG Key;                            // offset: 0x0 ordinal: 0x0
    ULONG EncodedCommittedPageCount : 16; // offset: 0x0 ordinal: 0x1
  };
  ULONG LargePageCost : 8; // offset: 0x0 ordinal: 0x2
  ULONG UnitCount : 8;     // offset: 0x0 ordinal: 0x3
} _HEAP_DESCRIPTOR_KEY;

// 0x4 bytes (sizeof)
typedef struct _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS {
  USHORT BlockSize;        // offset: 0x0 ordinal: 0x0
  USHORT FirstBlockOffset; // offset: 0x2 ordinal: 0x1
  ULONG EncodedData;       // offset: 0x0 ordinal: 0x2
} _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS;

// 0x4 bytes (sizeof)
typedef struct __anon_2760 {
  ULONG PageAlignLargeAllocs : 1; // offset: 0x0 ordinal: 0x0
  ULONG FullDecommit : 1;         // offset: 0x0 ordinal: 0x1
  ULONG EnableDelayFree : 1;      // offset: 0x0 ordinal: 0x2
} __anon_2760;

// 0x4 bytes (sizeof)
typedef struct _RTL_HP_VS_CONFIG {
  struct __anon_2760 Flags; // offset: 0x0 ordinal: 0x0
} _RTL_HP_VS_CONFIG;

// 0x8 bytes (sizeof)
typedef struct _RTL_HP_SUB_ALLOCATOR_CONFIGS {
  struct _RTL_HP_LFH_CONFIG LfhConfigs; // offset: 0x0 ordinal: 0x0
  struct _RTL_HP_VS_CONFIG VsConfigs;   // offset: 0x4 ordinal: 0x1
} _RTL_HP_SUB_ALLOCATOR_CONFIGS;

// 0x4 bytes (sizeof)
typedef struct __anon_2757 {
  ULONG ErmsSupported : 1; // offset: 0x0 ordinal: 0x0
  ULONG ErmsChecked : 1;   // offset: 0x0 ordinal: 0x1
} __anon_2757;

// 0x20 bytes (sizeof)
typedef struct _CC_ASYNC_READ_CONTEXT {
  UCHAR (*CompletionRoutine)(VOID *); // offset: 0x0 ordinal: 0x0
  VOID *Context;                      // offset: 0x8 ordinal: 0x1
  struct _MDL *Mdl;                   // offset: 0x10 ordinal: 0x2
  CHAR RequestorMode;                 // offset: 0x18 ordinal: 0x3
  ULONG NestingLevel;                 // offset: 0x1c ordinal: 0x4
} _CC_ASYNC_READ_CONTEXT;

// 0x4 bytes (sizeof)
typedef struct __anon_2715 {
  ULONG Reason; // offset: 0x0 ordinal: 0x0
} __anon_2715;

// 0x194 bytes (sizeof)
typedef struct _ASYNC_READ_THREAD_STATS {
  ULONG CurrentLoad[101]; // offset: 0x0 ordinal: 0x0
} _ASYNC_READ_THREAD_STATS;

// 0x2c bytes (sizeof)
typedef struct _ASYNC_LAZYWRITE_THREAD_STATS {
  ULONG CurrentLoad[11]; // offset: 0x0 ordinal: 0x0
} _ASYNC_LAZYWRITE_THREAD_STATS;

// 0x10 bytes (sizeof)
typedef struct _VACB_ARRAY_HEADER {
  ULONG VacbArrayIndex;     // offset: 0x0 ordinal: 0x0
  ULONG MappingCount;       // offset: 0x4 ordinal: 0x1
  ULONG HighestMappedIndex; // offset: 0x8 ordinal: 0x2
  ULONG Reserved;           // offset: 0xc ordinal: 0x3
} _VACB_ARRAY_HEADER;

// 0x8 bytes (sizeof)
typedef struct _WRITE_BEHIND_THROUGHPUT {
  ULONG PagesYetToWrite; // offset: 0x0 ordinal: 0x0
  ULONG Throughput;      // offset: 0x4 ordinal: 0x1
} _WRITE_BEHIND_THROUGHPUT;

// 0x18 bytes (sizeof)
typedef struct _SHARED_CACHE_MAP_LIST_CURSOR {
  struct _LIST_ENTRY SharedCacheMapLinks; // offset: 0x0 ordinal: 0x0
  ULONG Flags;                            // offset: 0x10 ordinal: 0x1
} _SHARED_CACHE_MAP_LIST_CURSOR;

// 0x4 bytes (sizeof)
typedef struct _PRIVATE_CACHE_MAP_FLAGS {
  ULONG DontUse : 16;           // offset: 0x0 ordinal: 0x0
  ULONG ReadAheadActive : 1;    // offset: 0x0 ordinal: 0x1
  ULONG ReadAheadEnabled : 1;   // offset: 0x0 ordinal: 0x2
  ULONG PagePriority : 3;       // offset: 0x0 ordinal: 0x3
  ULONG PipelineReadAheads : 1; // offset: 0x0 ordinal: 0x4
  ULONG Available : 10;         // offset: 0x0 ordinal: 0x5
} _PRIVATE_CACHE_MAP_FLAGS;

// 0x4 bytes (sizeof)
typedef union _POP_FX_DEVICE_STATUS {
  LONG Value;                             // offset: 0x0 ordinal: 0x0
  ULONG SystemTransition : 1;             // offset: 0x0 ordinal: 0x1
  ULONG PepD0Notify : 1;                  // offset: 0x0 ordinal: 0x2
  ULONG IdleTimerOn : 1;                  // offset: 0x0 ordinal: 0x3
  ULONG IgnoreIdleTimeout : 1;            // offset: 0x0 ordinal: 0x4
  ULONG IrpInUse : 1;                     // offset: 0x0 ordinal: 0x5
  ULONG IrpPending : 1;                   // offset: 0x0 ordinal: 0x6
  ULONG DPNRDeviceNotified : 1;           // offset: 0x0 ordinal: 0x7
  ULONG DPNRReceivedFromPep : 1;          // offset: 0x0 ordinal: 0x8
  ULONG IrpFirstPendingIndex : 1;         // offset: 0x0 ordinal: 0x9
  ULONG IrpLastPendingIndex : 1;          // offset: 0x0 ordinal: 0xa
  ULONG SIrpBlocked : 1;                  // offset: 0x0 ordinal: 0xb
  ULONG BlockFastResume : 1;              // offset: 0x0 ordinal: 0xc
  ULONG DirectedPoweredDown : 1;          // offset: 0x0 ordinal: 0xd
  ULONG DirectedTransitionInProgress : 1; // offset: 0x0 ordinal: 0xe
  ULONG Reserved : 18;                    // offset: 0x0 ordinal: 0xf
} _POP_FX_DEVICE_STATUS;

// 0x4 bytes (sizeof)
typedef union _POP_FX_PERF_FLAGS {
  LONG Value;                    // offset: 0x0 ordinal: 0x0
  ULONG Progress : 3;            // offset: 0x0 ordinal: 0x1
  ULONG Reserved : 24;           // offset: 0x0 ordinal: 0x2
  ULONG Synchronicity : 2;       // offset: 0x0 ordinal: 0x3
  ULONG RequestPepCompleted : 1; // offset: 0x0 ordinal: 0x4
  ULONG RequestSucceeded : 1;    // offset: 0x0 ordinal: 0x5
  ULONG NestedCallback : 1;      // offset: 0x0 ordinal: 0x6
} _POP_FX_PERF_FLAGS;

// 0x8 bytes (sizeof)
typedef union _POP_FX_COMPONENT_FLAGS {
  LONG Value;                     // offset: 0x0 ordinal: 0x0
  LONG Value2;                    // offset: 0x4 ordinal: 0x1
  ULONG RefCount : 30;            // offset: 0x0 ordinal: 0x2
  ULONG Idling : 1;               // offset: 0x0 ordinal: 0x3
  ULONG Active : 1;               // offset: 0x0 ordinal: 0x4
  ULONG CriticalIdleOverride : 1; // offset: 0x4 ordinal: 0x5
  ULONG ResidentOverride : 1;     // offset: 0x4 ordinal: 0x6
  ULONG Reserved : 30;            // offset: 0x4 ordinal: 0x7
} _POP_FX_COMPONENT_FLAGS;

// 0x10 bytes (sizeof)
typedef union _CPU_INFO {
  ULONG AsUINT32[4]; // offset: 0x0 ordinal: 0x0
  ULONG Eax;         // offset: 0x0 ordinal: 0x1
  ULONG Ebx;         // offset: 0x4 ordinal: 0x2
  ULONG Ecx;         // offset: 0x8 ordinal: 0x3
  ULONG Edx;         // offset: 0xc ordinal: 0x4
} _CPU_INFO;

// 0x4 bytes (sizeof)
typedef union _PEP_ACPI_RESOURCE_FLAGS {
  ULONG AsULong;            // offset: 0x0 ordinal: 0x0
  ULONG Shared : 1;         // offset: 0x0 ordinal: 0x1
  ULONG Wake : 1;           // offset: 0x0 ordinal: 0x2
  ULONG ResourceUsage : 1;  // offset: 0x0 ordinal: 0x3
  ULONG SlaveMode : 1;      // offset: 0x0 ordinal: 0x4
  ULONG AddressingMode : 1; // offset: 0x0 ordinal: 0x5
  ULONG SharedMode : 1;     // offset: 0x0 ordinal: 0x6
  ULONG Reserved : 26;      // offset: 0x0 ordinal: 0x7
} _PEP_ACPI_RESOURCE_FLAGS;

// 0x28 bytes (sizeof)
typedef struct _PEP_ACPI_SPB_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;          // offset: 0x0 ordinal: 0x0
  union _PEP_ACPI_RESOURCE_FLAGS Flags;       // offset: 0x4 ordinal: 0x1
  USHORT TypeSpecificFlags;                   // offset: 0x8 ordinal: 0x2
  UCHAR ResourceSourceIndex;                  // offset: 0xa ordinal: 0x3
  struct _UNICODE_STRING *ResourceSourceName; // offset: 0x10 ordinal: 0x4
  CHAR *VendorData;                           // offset: 0x18 ordinal: 0x5
  USHORT VendorDataLength;                    // offset: 0x20 ordinal: 0x6
} _PEP_ACPI_SPB_RESOURCE;

// 0x48 bytes (sizeof)
typedef struct _PEP_ACPI_GPIO_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;           // offset: 0x0 ordinal: 0x0
  union _PEP_ACPI_RESOURCE_FLAGS Flags;        // offset: 0x4 ordinal: 0x1
  enum _KINTERRUPT_MODE InterruptType;         // offset: 0x8 ordinal: 0x2
  enum _KINTERRUPT_POLARITY InterruptPolarity; // offset: 0xc ordinal: 0x3
  enum _GPIO_PIN_CONFIG_TYPE PinConfig;        // offset: 0x10 ordinal: 0x4
  enum _GPIO_PIN_IORESTRICTION_TYPE
      IoRestrictionType;                      // offset: 0x14 ordinal: 0x5
  USHORT DriveStrength;                       // offset: 0x18 ordinal: 0x6
  USHORT DebounceTimeout;                     // offset: 0x1a ordinal: 0x7
  USHORT *PinTable;                           // offset: 0x20 ordinal: 0x8
  USHORT PinCount;                            // offset: 0x28 ordinal: 0x9
  UCHAR ResourceSourceIndex;                  // offset: 0x2a ordinal: 0xa
  struct _UNICODE_STRING *ResourceSourceName; // offset: 0x30 ordinal: 0xb
  UCHAR *VendorData;                          // offset: 0x38 ordinal: 0xc
  USHORT VendorDataLength;                    // offset: 0x40 ordinal: 0xd
} _PEP_ACPI_GPIO_RESOURCE;

// 0x38 bytes (sizeof)
typedef struct _PEP_ACPI_SPB_UART_RESOURCE {
  struct _PEP_ACPI_SPB_RESOURCE SpbCommon; // offset: 0x0 ordinal: 0x0
  ULONG BaudRate;                          // offset: 0x28 ordinal: 0x1
  USHORT RxBufferSize;                     // offset: 0x2c ordinal: 0x2
  USHORT TxBufferSize;                     // offset: 0x2e ordinal: 0x3
  UCHAR Parity;                            // offset: 0x30 ordinal: 0x4
  UCHAR LinesInUse;                        // offset: 0x31 ordinal: 0x5
} _PEP_ACPI_SPB_UART_RESOURCE;

// 0x38 bytes (sizeof)
typedef struct _PEP_ACPI_SPB_SPI_RESOURCE {
  struct _PEP_ACPI_SPB_RESOURCE SpbCommon; // offset: 0x0 ordinal: 0x0
  ULONG ConnectionSpeed;                   // offset: 0x28 ordinal: 0x1
  UCHAR DataBitLength;                     // offset: 0x2c ordinal: 0x2
  UCHAR Phase;                             // offset: 0x2d ordinal: 0x3
  UCHAR Polarity;                          // offset: 0x2e ordinal: 0x4
  USHORT DeviceSelection;                  // offset: 0x30 ordinal: 0x5
} _PEP_ACPI_SPB_SPI_RESOURCE;

// 0x30 bytes (sizeof)
typedef struct _PEP_ACPI_SPB_I2C_RESOURCE {
  struct _PEP_ACPI_SPB_RESOURCE SpbCommon; // offset: 0x0 ordinal: 0x0
  ULONG ConnectionSpeed;                   // offset: 0x28 ordinal: 0x1
  USHORT SlaveAddress;                     // offset: 0x2c ordinal: 0x2
} _PEP_ACPI_SPB_I2C_RESOURCE;

// 0x24 bytes (sizeof)
typedef struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
  ULONG Size;                // offset: 0x0 ordinal: 0x0
  ULONG Action;              // offset: 0x4 ordinal: 0x1
  ULONG Flags;               // offset: 0x8 ordinal: 0x2
  ULONG OperationStatus;     // offset: 0xc ordinal: 0x3
  ULONG ExtendedError;       // offset: 0x10 ordinal: 0x4
  ULONG TargetDetailedError; // offset: 0x14 ordinal: 0x5
  ULONG ReservedStatus;      // offset: 0x18 ordinal: 0x6
  ULONG OutputBlockOffset;   // offset: 0x1c ordinal: 0x7
  ULONG OutputBlockLength;   // offset: 0x20 ordinal: 0x8
} _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;

// 0x1c bytes (sizeof)
typedef struct _DEVICE_DSM_DEFINITION {
  ULONG Action;                  // offset: 0x0 ordinal: 0x0
  UCHAR SingleRange;             // offset: 0x4 ordinal: 0x1
  ULONG ParameterBlockAlignment; // offset: 0x8 ordinal: 0x2
  ULONG ParameterBlockLength;    // offset: 0xc ordinal: 0x3
  UCHAR HasOutput;               // offset: 0x10 ordinal: 0x4
  ULONG OutputBlockAlignment;    // offset: 0x14 ordinal: 0x5
  ULONG OutputBlockLength;       // offset: 0x18 ordinal: 0x6
} _DEVICE_DSM_DEFINITION;

// 0x1c bytes (sizeof)
typedef struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
  ULONG Size;                 // offset: 0x0 ordinal: 0x0
  ULONG Action;               // offset: 0x4 ordinal: 0x1
  ULONG Flags;                // offset: 0x8 ordinal: 0x2
  ULONG ParameterBlockOffset; // offset: 0xc ordinal: 0x3
  ULONG ParameterBlockLength; // offset: 0x10 ordinal: 0x4
  ULONG DataSetRangesOffset;  // offset: 0x14 ordinal: 0x5
  ULONG DataSetRangesLength;  // offset: 0x18 ordinal: 0x6
} _DEVICE_MANAGE_DATA_SET_ATTRIBUTES;

// 0x28 bytes (sizeof)
typedef struct _DBGKD_GET_VERSION32 {
  USHORT MajorVersion;            // offset: 0x0 ordinal: 0x0
  USHORT MinorVersion;            // offset: 0x2 ordinal: 0x1
  USHORT ProtocolVersion;         // offset: 0x4 ordinal: 0x2
  USHORT Flags;                   // offset: 0x6 ordinal: 0x3
  ULONG KernBase;                 // offset: 0x8 ordinal: 0x4
  ULONG PsLoadedModuleList;       // offset: 0xc ordinal: 0x5
  USHORT MachineType;             // offset: 0x10 ordinal: 0x6
  USHORT ThCallbackStack;         // offset: 0x12 ordinal: 0x7
  USHORT NextCallback;            // offset: 0x14 ordinal: 0x8
  USHORT FramePointer;            // offset: 0x16 ordinal: 0x9
  ULONG KiCallUserMode;           // offset: 0x18 ordinal: 0xa
  ULONG KeUserCallbackDispatcher; // offset: 0x1c ordinal: 0xb
  ULONG BreakpointWithStatus;     // offset: 0x20 ordinal: 0xc
  ULONG DebuggerDataList;         // offset: 0x24 ordinal: 0xd
} _DBGKD_GET_VERSION32;

// 0xc bytes (sizeof)
typedef struct _PPC_DBGKD_CONTROL_SET {
  ULONG Continue;           // offset: 0x0 ordinal: 0x0
  ULONG CurrentSymbolStart; // offset: 0x4 ordinal: 0x1
  ULONG CurrentSymbolEnd;   // offset: 0x8 ordinal: 0x2
} _PPC_DBGKD_CONTROL_SET;

// 0xc bytes (sizeof)
typedef struct _ARMCE_DBGKD_CONTROL_SET {
  ULONG Continue;           // offset: 0x0 ordinal: 0x0
  ULONG CurrentSymbolStart; // offset: 0x4 ordinal: 0x1
  ULONG CurrentSymbolEnd;   // offset: 0x8 ordinal: 0x2
} _ARMCE_DBGKD_CONTROL_SET;

// 0xc bytes (sizeof)
typedef struct _ARM_DBGKD_CONTROL_SET {
  ULONG Continue;           // offset: 0x0 ordinal: 0x0
  ULONG CurrentSymbolStart; // offset: 0x4 ordinal: 0x1
  ULONG CurrentSymbolEnd;   // offset: 0x8 ordinal: 0x2
} _ARM_DBGKD_CONTROL_SET;

// 0x10 bytes (sizeof)
typedef struct _X86_DBGKD_CONTROL_SET {
  ULONG TraceFlag;          // offset: 0x0 ordinal: 0x0
  ULONG Dr7;                // offset: 0x4 ordinal: 0x1
  ULONG CurrentSymbolStart; // offset: 0x8 ordinal: 0x2
  ULONG CurrentSymbolEnd;   // offset: 0xc ordinal: 0x3
} _X86_DBGKD_CONTROL_SET;

// 0xc bytes (sizeof)
typedef struct _DBGKD_CONTEXT_EX {
  ULONG Offset;      // offset: 0x0 ordinal: 0x0
  ULONG ByteCount;   // offset: 0x4 ordinal: 0x1
  ULONG BytesCopied; // offset: 0x8 ordinal: 0x2
} _DBGKD_CONTEXT_EX;

// 0x4 bytes (sizeof)
typedef struct _DBGKD_SWITCH_PARTITION {
  ULONG Partition; // offset: 0x0 ordinal: 0x0
} _DBGKD_SWITCH_PARTITION;

// 0x14 bytes (sizeof)
typedef struct _DBGKD_GET_SET_BUS_DATA {
  ULONG BusDataType; // offset: 0x0 ordinal: 0x0
  ULONG BusNumber;   // offset: 0x4 ordinal: 0x1
  ULONG SlotNumber;  // offset: 0x8 ordinal: 0x2
  ULONG Offset;      // offset: 0xc ordinal: 0x3
  ULONG Length;      // offset: 0x10 ordinal: 0x4
} _DBGKD_GET_SET_BUS_DATA;

// 0xc bytes (sizeof)
typedef struct _DBGKD_READ_WRITE_MSR {
  ULONG Msr;           // offset: 0x0 ordinal: 0x0
  ULONG DataValueLow;  // offset: 0x4 ordinal: 0x1
  ULONG DataValueHigh; // offset: 0x8 ordinal: 0x2
} _DBGKD_READ_WRITE_MSR;

// 0x8 bytes (sizeof)
typedef struct _DBGKD_BREAKPOINTEX {
  ULONG BreakPointCount; // offset: 0x0 ordinal: 0x0
  LONG ContinueStatus;   // offset: 0x4 ordinal: 0x1
} _DBGKD_BREAKPOINTEX;

// 0x4 bytes (sizeof)
typedef struct _DBGKD_QUERY_SPECIAL_CALLS {
  ULONG NumberOfSpecialCalls; // offset: 0x0 ordinal: 0x0
} _DBGKD_QUERY_SPECIAL_CALLS;

// 0x4 bytes (sizeof)
typedef struct _DBGKD_RESTORE_BREAKPOINT {
  ULONG BreakPointHandle; // offset: 0x0 ordinal: 0x0
} _DBGKD_RESTORE_BREAKPOINT;

// 0x4 bytes (sizeof)
typedef struct _DBGKD_SET_CONTEXT {
  ULONG ContextFlags; // offset: 0x0 ordinal: 0x0
} _DBGKD_SET_CONTEXT;

// 0x4 bytes (sizeof)
typedef struct _DBGKD_GET_CONTEXT {
  ULONG Unused; // offset: 0x0 ordinal: 0x0
} _DBGKD_GET_CONTEXT;

// 0x1c bytes (sizeof)
typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT32 {
  ULONG BreakpointAddress; // offset: 0x0 ordinal: 0x0
  ULONG Flags;             // offset: 0x4 ordinal: 0x1
  ULONG Calls;             // offset: 0x8 ordinal: 0x2
  ULONG MaxCallsPerPeriod; // offset: 0xc ordinal: 0x3
  ULONG MinInstructions;   // offset: 0x10 ordinal: 0x4
  ULONG MaxInstructions;   // offset: 0x14 ordinal: 0x5
  ULONG TotalInstructions; // offset: 0x18 ordinal: 0x6
} _DBGKD_GET_INTERNAL_BREAKPOINT32;

// 0x8 bytes (sizeof)
typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT32 {
  ULONG BreakpointAddress; // offset: 0x0 ordinal: 0x0
  ULONG Flags;             // offset: 0x4 ordinal: 0x1
} _DBGKD_SET_INTERNAL_BREAKPOINT32;

// 0x4 bytes (sizeof)
typedef struct _DBGKD_SET_SPECIAL_CALL32 {
  ULONG SpecialCall; // offset: 0x0 ordinal: 0x0
} _DBGKD_SET_SPECIAL_CALL32;

// 0x18 bytes (sizeof)
typedef struct _DBGKD_READ_WRITE_IO_EXTENDED32 {
  ULONG DataSize;      // offset: 0x0 ordinal: 0x0
  ULONG InterfaceType; // offset: 0x4 ordinal: 0x1
  ULONG BusNumber;     // offset: 0x8 ordinal: 0x2
  ULONG AddressSpace;  // offset: 0xc ordinal: 0x3
  ULONG IoAddress;     // offset: 0x10 ordinal: 0x4
  ULONG DataValue;     // offset: 0x14 ordinal: 0x5
} _DBGKD_READ_WRITE_IO_EXTENDED32;

// 0xc bytes (sizeof)
typedef struct _DBGKD_READ_WRITE_IO32 {
  ULONG DataSize;  // offset: 0x0 ordinal: 0x0
  ULONG IoAddress; // offset: 0x4 ordinal: 0x1
  ULONG DataValue; // offset: 0x8 ordinal: 0x2
} _DBGKD_READ_WRITE_IO32;

// 0x8 bytes (sizeof)
typedef struct _DBGKD_WRITE_BREAKPOINT32 {
  ULONG BreakPointAddress; // offset: 0x0 ordinal: 0x0
  ULONG BreakPointHandle;  // offset: 0x4 ordinal: 0x1
} _DBGKD_WRITE_BREAKPOINT32;

// 0xc bytes (sizeof)
typedef struct _DBGKD_WRITE_MEMORY32 {
  ULONG TargetBaseAddress;  // offset: 0x0 ordinal: 0x0
  ULONG TransferCount;      // offset: 0x4 ordinal: 0x1
  ULONG ActualBytesWritten; // offset: 0x8 ordinal: 0x2
} _DBGKD_WRITE_MEMORY32;

// 0xc bytes (sizeof)
typedef struct _DBGKD_READ_MEMORY32 {
  ULONG TargetBaseAddress; // offset: 0x0 ordinal: 0x0
  ULONG TransferCount;     // offset: 0x4 ordinal: 0x1
  ULONG ActualBytesRead;   // offset: 0x8 ordinal: 0x2
} _DBGKD_READ_MEMORY32;

// 0x18 bytes (sizeof)
typedef struct _DBGKD_LOAD_SYMBOLS32 {
  ULONG PathNameLength; // offset: 0x0 ordinal: 0x0
  ULONG BaseOfDll;      // offset: 0x4 ordinal: 0x1
  ULONG ProcessId;      // offset: 0x8 ordinal: 0x2
  ULONG CheckSum;       // offset: 0xc ordinal: 0x3
  ULONG SizeOfImage;    // offset: 0x10 ordinal: 0x4
  UCHAR UnloadSymbols;  // offset: 0x14 ordinal: 0x5
} _DBGKD_LOAD_SYMBOLS32;

// 0x8c bytes (sizeof)
typedef struct _X86_KTRAP_FRAME_BLUE {
  ULONG DbgEbp;               // offset: 0x0 ordinal: 0x0
  ULONG DbgEip;               // offset: 0x4 ordinal: 0x1
  ULONG DbgArgMark;           // offset: 0x8 ordinal: 0x2
  USHORT TempSegCs;           // offset: 0xc ordinal: 0x3
  UCHAR Logging;              // offset: 0xe ordinal: 0x4
  UCHAR FrameType;            // offset: 0xf ordinal: 0x5
  ULONG TempEsp;              // offset: 0x10 ordinal: 0x6
  ULONG Dr0;                  // offset: 0x14 ordinal: 0x7
  ULONG Dr1;                  // offset: 0x18 ordinal: 0x8
  ULONG Dr2;                  // offset: 0x1c ordinal: 0x9
  ULONG Dr3;                  // offset: 0x20 ordinal: 0xa
  ULONG Dr6;                  // offset: 0x24 ordinal: 0xb
  ULONG Dr7;                  // offset: 0x28 ordinal: 0xc
  ULONG SegGs;                // offset: 0x2c ordinal: 0xd
  ULONG SegEs;                // offset: 0x30 ordinal: 0xe
  ULONG SegDs;                // offset: 0x34 ordinal: 0xf
  ULONG Edx;                  // offset: 0x38 ordinal: 0x10
  ULONG Ecx;                  // offset: 0x3c ordinal: 0x11
  ULONG Eax;                  // offset: 0x40 ordinal: 0x12
  UCHAR PreviousPreviousMode; // offset: 0x44 ordinal: 0x13
  UCHAR EntropyQueueDpc;      // offset: 0x45 ordinal: 0x14
  UCHAR Reserved[2];          // offset: 0x46 ordinal: 0x15
  ULONG MxCsr;                // offset: 0x48 ordinal: 0x16
  ULONG ExceptionList;        // offset: 0x4c ordinal: 0x17
  ULONG SegFs;                // offset: 0x50 ordinal: 0x18
  ULONG Edi;                  // offset: 0x54 ordinal: 0x19
  ULONG Esi;                  // offset: 0x58 ordinal: 0x1a
  ULONG Ebx;                  // offset: 0x5c ordinal: 0x1b
  ULONG Ebp;                  // offset: 0x60 ordinal: 0x1c
  ULONG ErrCode;              // offset: 0x64 ordinal: 0x1d
  ULONG Eip;                  // offset: 0x68 ordinal: 0x1e
  ULONG SegCs;                // offset: 0x6c ordinal: 0x1f
  ULONG EFlags;               // offset: 0x70 ordinal: 0x20
  ULONG HardwareEsp;          // offset: 0x74 ordinal: 0x21
  ULONG HardwareSegSs;        // offset: 0x78 ordinal: 0x22
  ULONG V86Es;                // offset: 0x7c ordinal: 0x23
  ULONG V86Ds;                // offset: 0x80 ordinal: 0x24
  ULONG V86Fs;                // offset: 0x84 ordinal: 0x25
  ULONG V86Gs;                // offset: 0x88 ordinal: 0x26
} _X86_KTRAP_FRAME_BLUE;

// 0x8c bytes (sizeof)
typedef struct _X86_KTRAP_FRAME {
  ULONG DbgEbp;               // offset: 0x0 ordinal: 0x0
  ULONG DbgEip;               // offset: 0x4 ordinal: 0x1
  ULONG DbgArgMark;           // offset: 0x8 ordinal: 0x2
  ULONG DbgArgPointer;        // offset: 0xc ordinal: 0x3
  ULONG TempSegCs;            // offset: 0x10 ordinal: 0x4
  ULONG TempEsp;              // offset: 0x14 ordinal: 0x5
  ULONG Dr0;                  // offset: 0x18 ordinal: 0x6
  ULONG Dr1;                  // offset: 0x1c ordinal: 0x7
  ULONG Dr2;                  // offset: 0x20 ordinal: 0x8
  ULONG Dr3;                  // offset: 0x24 ordinal: 0x9
  ULONG Dr6;                  // offset: 0x28 ordinal: 0xa
  ULONG Dr7;                  // offset: 0x2c ordinal: 0xb
  ULONG SegGs;                // offset: 0x30 ordinal: 0xc
  ULONG SegEs;                // offset: 0x34 ordinal: 0xd
  ULONG SegDs;                // offset: 0x38 ordinal: 0xe
  ULONG Edx;                  // offset: 0x3c ordinal: 0xf
  ULONG Ecx;                  // offset: 0x40 ordinal: 0x10
  ULONG Eax;                  // offset: 0x44 ordinal: 0x11
  UCHAR PreviousPreviousMode; // offset: 0x48 ordinal: 0x12
  UCHAR EntropyQueueDpc;      // offset: 0x49 ordinal: 0x13
  UCHAR Reserved[2];          // offset: 0x4a ordinal: 0x14
  ULONG ExceptionList;        // offset: 0x4c ordinal: 0x15
  ULONG SegFs;                // offset: 0x50 ordinal: 0x16
  ULONG Edi;                  // offset: 0x54 ordinal: 0x17
  ULONG Esi;                  // offset: 0x58 ordinal: 0x18
  ULONG Ebx;                  // offset: 0x5c ordinal: 0x19
  ULONG Ebp;                  // offset: 0x60 ordinal: 0x1a
  ULONG ErrCode;              // offset: 0x64 ordinal: 0x1b
  ULONG Eip;                  // offset: 0x68 ordinal: 0x1c
  ULONG SegCs;                // offset: 0x6c ordinal: 0x1d
  ULONG EFlags;               // offset: 0x70 ordinal: 0x1e
  ULONG HardwareEsp;          // offset: 0x74 ordinal: 0x1f
  ULONG HardwareSegSs;        // offset: 0x78 ordinal: 0x20
  ULONG V86Es;                // offset: 0x7c ordinal: 0x21
  ULONG V86Ds;                // offset: 0x80 ordinal: 0x22
  ULONG V86Fs;                // offset: 0x84 ordinal: 0x23
  ULONG V86Gs;                // offset: 0x88 ordinal: 0x24
} _X86_KTRAP_FRAME;

// 0x10 bytes (sizeof)
typedef struct _PNP_ASSIGN_RESOURCES_CONTEXT {
  ULONG IncludeFailedDevices;           // offset: 0x0 ordinal: 0x0
  ULONG DeviceCount;                    // offset: 0x4 ordinal: 0x1
  struct _DEVICE_OBJECT *DeviceList[1]; // offset: 0x8 ordinal: 0x2
} _PNP_ASSIGN_RESOURCES_CONTEXT;

// 0x8 bytes (sizeof)
typedef struct _INBV_OFFSET {
  ULONG X; // offset: 0x0 ordinal: 0x0
  ULONG Y; // offset: 0x4 ordinal: 0x1
} _INBV_OFFSET;

// 0x18 bytes (sizeof)
typedef struct _INBV_GRAPHICS_RECTANGLE {
  ULONG Height;                        // offset: 0x0 ordinal: 0x0
  ULONG Width;                         // offset: 0x4 ordinal: 0x1
  enum _INBV_PIXEL_FORMAT PixelFormat; // offset: 0x8 ordinal: 0x2
  ULONG Size;                          // offset: 0xc ordinal: 0x3
  VOID *Data;                          // offset: 0x10 ordinal: 0x4
} _INBV_GRAPHICS_RECTANGLE;

typedef LONG (*__anon_2543)(struct _INBV_GRAPHICS_RECTANGLE *,
                            struct _INBV_OFFSET *, UCHAR);

// 0x8 bytes (sizeof)
typedef union __anon_2540 {
  VOID *FrameBuffer; // offset: 0x0 ordinal: 0x0
  LONG(*BltRoutine)
  (struct _INBV_GRAPHICS_RECTANGLE *, struct _INBV_OFFSET *,
   UCHAR); // offset: 0x0 ordinal: 0x1
} __anon_2540;

// 0x10 bytes (sizeof)
typedef struct _INBV_MODE_INFORMATION {
  ULONG Height;                        // offset: 0x0 ordinal: 0x0
  ULONG Width;                         // offset: 0x4 ordinal: 0x1
  ULONG Stride;                        // offset: 0x8 ordinal: 0x2
  enum _INBV_PIXEL_FORMAT PixelFormat; // offset: 0xc ordinal: 0x3
} _INBV_MODE_INFORMATION;

// 0x28 bytes (sizeof)
typedef struct _INBV_DISPLAY_CONTEXT {
  UCHAR FrameBufferValid;                        // offset: 0x0 ordinal: 0x0
  UCHAR FrameBufferMapped;                       // offset: 0x1 ordinal: 0x1
  UCHAR DisplayRotation;                         // offset: 0x2 ordinal: 0x2
  struct _INBV_MODE_INFORMATION ModeInformation; // offset: 0x4 ordinal: 0x3
  VOID *ShadowBuffer;                            // offset: 0x18 ordinal: 0x4
  union __anon_2540 VideoMemory;                 // offset: 0x20 ordinal: 0x5
} _INBV_DISPLAY_CONTEXT;

// 0x4 bytes (sizeof)
typedef union _KSR_CAPABILITIES {
  ULONG PerennialDatabase : 1; // offset: 0x0 ordinal: 0x0
  ULONG SkipSubAllocator : 1;  // offset: 0x0 ordinal: 0x1
  ULONG Reserved : 30;         // offset: 0x0 ordinal: 0x2
  ULONG AsULong;               // offset: 0x0 ordinal: 0x3
} _KSR_CAPABILITIES;

// 0x8 bytes (sizeof)
typedef struct _STRING32 {
  USHORT Length;        // offset: 0x0 ordinal: 0x0
  USHORT MaximumLength; // offset: 0x2 ordinal: 0x1
  ULONG Buffer;         // offset: 0x4 ordinal: 0x2
} _STRING32;

// 0x8 bytes (sizeof)
typedef struct _CLIENT_ID32 {
  ULONG UniqueProcess; // offset: 0x0 ordinal: 0x0
  ULONG UniqueThread;  // offset: 0x4 ordinal: 0x1
} _CLIENT_ID32;

// 0x18 bytes (sizeof)
typedef struct _PORT_MESSAGE32 {
  union __anon_2845 u1; // offset: 0x0 ordinal: 0x0
  union __anon_2847 u2; // offset: 0x4 ordinal: 0x1
  union {
    struct _CLIENT_ID32 ClientId; // offset: 0x8 ordinal: 0x2
    double DoNotUseThisField;     // offset: 0x8 ordinal: 0x3
  };
  ULONG MessageId; // offset: 0x10 ordinal: 0x4
  union {
    ULONG ClientViewSize; // offset: 0x14 ordinal: 0x5
    ULONG CallbackId;     // offset: 0x14 ordinal: 0x6
  };
} _PORT_MESSAGE32;

// 0x1c bytes (sizeof)
typedef struct _NT_TIB32 {
  ULONG ExceptionList; // offset: 0x0 ordinal: 0x0
  ULONG StackBase;     // offset: 0x4 ordinal: 0x1
  ULONG StackLimit;    // offset: 0x8 ordinal: 0x2
  ULONG SubSystemTib;  // offset: 0xc ordinal: 0x3
  union {
    ULONG FiberData; // offset: 0x10 ordinal: 0x4
    ULONG Version;   // offset: 0x10 ordinal: 0x5
  };
  ULONG ArbitraryUserPointer; // offset: 0x14 ordinal: 0x6
  ULONG Self;                 // offset: 0x18 ordinal: 0x7
} _NT_TIB32;

// 0x10 bytes (sizeof)
typedef struct _THERMAL_ZONE_COUNTERS {
  ULONG Temperature;              // offset: 0x0 ordinal: 0x0
  ULONG ThrottleLimit;            // offset: 0x4 ordinal: 0x1
  ULONG ThrottleReasons;          // offset: 0x8 ordinal: 0x2
  ULONG TemperatureHighPrecision; // offset: 0xc ordinal: 0x3
} _THERMAL_ZONE_COUNTERS;

// 0xb8 bytes (sizeof)
typedef struct _SYNCH_COUNTERS {
  ULONG SpinLockAcquireCount;                   // offset: 0x0 ordinal: 0x0
  ULONG SpinLockContentionCount;                // offset: 0x4 ordinal: 0x1
  ULONG SpinLockSpinCount;                      // offset: 0x8 ordinal: 0x2
  ULONG IpiSendRequestBroadcastCount;           // offset: 0xc ordinal: 0x3
  ULONG IpiSendRequestRoutineCount;             // offset: 0x10 ordinal: 0x4
  ULONG IpiSendSoftwareInterruptCount;          // offset: 0x14 ordinal: 0x5
  ULONG ExInitializeResourceCount;              // offset: 0x18 ordinal: 0x6
  ULONG ExReInitializeResourceCount;            // offset: 0x1c ordinal: 0x7
  ULONG ExDeleteResourceCount;                  // offset: 0x20 ordinal: 0x8
  ULONG ExecutiveResourceAcquiresCount;         // offset: 0x24 ordinal: 0x9
  ULONG ExecutiveResourceContentionsCount;      // offset: 0x28 ordinal: 0xa
  ULONG ExecutiveResourceReleaseExclusiveCount; // offset: 0x2c ordinal: 0xb
  ULONG ExecutiveResourceReleaseSharedCount;    // offset: 0x30 ordinal: 0xc
  ULONG ExecutiveResourceConvertsCount;         // offset: 0x34 ordinal: 0xd
  ULONG ExAcqResExclusiveAttempts;              // offset: 0x38 ordinal: 0xe
  ULONG ExAcqResExclusiveAcquiresExclusive;     // offset: 0x3c ordinal: 0xf
  ULONG
  ExAcqResExclusiveAcquiresExclusiveRecursive; // offset: 0x40 ordinal: 0x10
  ULONG ExAcqResExclusiveWaits;                // offset: 0x44 ordinal: 0x11
  ULONG ExAcqResExclusiveNotAcquires;          // offset: 0x48 ordinal: 0x12
  ULONG ExAcqResSharedAttempts;                // offset: 0x4c ordinal: 0x13
  ULONG ExAcqResSharedAcquiresExclusive;       // offset: 0x50 ordinal: 0x14
  ULONG ExAcqResSharedAcquiresShared;          // offset: 0x54 ordinal: 0x15
  ULONG ExAcqResSharedAcquiresSharedRecursive; // offset: 0x58 ordinal: 0x16
  ULONG ExAcqResSharedWaits;                   // offset: 0x5c ordinal: 0x17
  ULONG ExAcqResSharedNotAcquires;             // offset: 0x60 ordinal: 0x18
  ULONG ExAcqResSharedStarveExclusiveAttempts; // offset: 0x64 ordinal: 0x19
  ULONG ExAcqResSharedStarveExclusiveAcquiresExclusive; // offset: 0x68 ordinal:
                                                        // 0x1a
  ULONG
  ExAcqResSharedStarveExclusiveAcquiresShared; // offset: 0x6c ordinal: 0x1b
  ULONG ExAcqResSharedStarveExclusiveAcquiresSharedRecursive; // offset: 0x70
                                                              // ordinal: 0x1c
  ULONG ExAcqResSharedStarveExclusiveWaits;       // offset: 0x74 ordinal: 0x1d
  ULONG ExAcqResSharedStarveExclusiveNotAcquires; // offset: 0x78 ordinal: 0x1e
  ULONG ExAcqResSharedWaitForExclusiveAttempts;   // offset: 0x7c ordinal: 0x1f
  ULONG ExAcqResSharedWaitForExclusiveAcquiresExclusive; // offset: 0x80
                                                         // ordinal: 0x20
  ULONG ExAcqResSharedWaitForExclusiveAcquiresShared; // offset: 0x84 ordinal:
                                                      // 0x21
  ULONG ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive; // offset: 0x88
                                                               // ordinal: 0x22
  ULONG ExAcqResSharedWaitForExclusiveWaits;       // offset: 0x8c ordinal: 0x23
  ULONG ExAcqResSharedWaitForExclusiveNotAcquires; // offset: 0x90 ordinal: 0x24
  ULONG ExSetResOwnerPointerExclusive;             // offset: 0x94 ordinal: 0x25
  ULONG ExSetResOwnerPointerSharedNew;             // offset: 0x98 ordinal: 0x26
  ULONG ExSetResOwnerPointerSharedOld;             // offset: 0x9c ordinal: 0x27
  ULONG ExTryToAcqExclusiveAttempts;               // offset: 0xa0 ordinal: 0x28
  ULONG ExTryToAcqExclusiveAcquires;               // offset: 0xa4 ordinal: 0x29
  ULONG ExBoostExclusiveOwner;                     // offset: 0xa8 ordinal: 0x2a
  ULONG ExBoostSharedOwners;                       // offset: 0xac ordinal: 0x2b
  ULONG ExEtwSynchTrackingNotificationsCount;      // offset: 0xb0 ordinal: 0x2c
  ULONG ExEtwSynchTrackingNotificationsAccountedCount; // offset: 0xb4 ordinal:
                                                       // 0x2d
} _SYNCH_COUNTERS;

// 0x10 bytes (sizeof)
typedef struct _PCW_DATA {
  VOID *Data; // offset: 0x0 ordinal: 0x0
  ULONG Size; // offset: 0x8 ordinal: 0x1
} _PCW_DATA;

// 0x8 bytes (sizeof)
typedef struct __anon_2456 {
  ULONG Context1; // offset: 0x0 ordinal: 0x0
  ULONG Context2; // offset: 0x4 ordinal: 0x1
} __anon_2456;

// 0x8 bytes (sizeof)
typedef struct __anon_2455 {
  ULONG RangeCount;  // offset: 0x0 ordinal: 0x0
  ULONG SetBitCount; // offset: 0x4 ordinal: 0x1
} __anon_2455;

// 0x8 bytes (sizeof)
typedef struct __anon_2454 {
  ULONG Start;  // offset: 0x0 ordinal: 0x0
  ULONG Length; // offset: 0x4 ordinal: 0x1
} __anon_2454;

// 0x8 bytes (sizeof)
typedef union __anon_2449 {
  struct __anon_2454 DirtyVectorModifiedContext; // offset: 0x0 ordinal: 0x0
  struct __anon_2455 DirtyDataCaptureContext;    // offset: 0x0 ordinal: 0x1
  struct __anon_2456 Raw;                        // offset: 0x0 ordinal: 0x2
} __anon_2449;

// 0x48 bytes (sizeof)
typedef struct _CM_DIRTY_VECTOR_LOG_ENTRY {
  struct _ETHREAD *Thread;                   // offset: 0x0 ordinal: 0x0
  enum _CM_DIRTY_VECTOR_OPERATION Operation; // offset: 0x8 ordinal: 0x1
  union __anon_2449 Data;                    // offset: 0xc ordinal: 0x2
  VOID *Stack[6];                            // offset: 0x18 ordinal: 0x3
} _CM_DIRTY_VECTOR_LOG_ENTRY;

// 0x8 bytes (sizeof)
typedef struct _KTRANSACTION_HISTORY {
  enum __anon_2447 RecordType; // offset: 0x0 ordinal: 0x0
  ULONG Payload;               // offset: 0x4 ordinal: 0x1
} _KTRANSACTION_HISTORY;

// 0x8 bytes (sizeof)
typedef struct __anon_2438 {
  ULONG idxRecord;    // offset: 0x0 ordinal: 0x0
  ULONG cidContainer; // offset: 0x4 ordinal: 0x1
} __anon_2438;

// 0x68 bytes (sizeof)
typedef struct _RTL_AVL_TABLE {
  struct _RTL_BALANCED_LINKS BalancedRoot; // offset: 0x0 ordinal: 0x0
  VOID *OrderedPointer;                    // offset: 0x20 ordinal: 0x1
  ULONG WhichOrderedElement;               // offset: 0x28 ordinal: 0x2
  ULONG NumberGenericTableElements;        // offset: 0x2c ordinal: 0x3
  ULONG DepthOfTree;                       // offset: 0x30 ordinal: 0x4
  struct _RTL_BALANCED_LINKS *RestartKey;  // offset: 0x38 ordinal: 0x5
  ULONG DeleteCount;                       // offset: 0x40 ordinal: 0x6
  enum _RTL_GENERIC_COMPARE_RESULTS (*CompareRoutine)(
      struct _RTL_AVL_TABLE *, VOID *, VOID *); // offset: 0x48 ordinal: 0x7
  VOID *(*AllocateRoutine)(struct _RTL_AVL_TABLE *,
                           ULONG); // offset: 0x50 ordinal: 0x8
  VOID(*FreeRoutine)
  (struct _RTL_AVL_TABLE *, VOID *); // offset: 0x58 ordinal: 0x9
  VOID *TableContext;                // offset: 0x60 ordinal: 0xa
} _RTL_AVL_TABLE;

typedef VOID (*__anon_2453)(struct _RTL_AVL_TABLE *, VOID *);

typedef VOID *(*__anon_2452)(struct _RTL_AVL_TABLE *, ULONG);

typedef enum _RTL_GENERIC_COMPARE_RESULTS (*__anon_2451)(
    struct _RTL_AVL_TABLE *, VOID *, VOID *);

// 0xa8 bytes (sizeof)
typedef struct _KTMOBJECT_NAMESPACE {
  struct _RTL_AVL_TABLE Table; // offset: 0x0 ordinal: 0x0
  struct _KMUTANT Mutex;       // offset: 0x68 ordinal: 0x1
  USHORT LinksOffset;          // offset: 0xa0 ordinal: 0x2
  USHORT GuidOffset;           // offset: 0xa2 ordinal: 0x3
  UCHAR Expired;               // offset: 0xa4 ordinal: 0x4
} _KTMOBJECT_NAMESPACE;

// 0x10 bytes (sizeof)
typedef struct _CM_UOW_SET_VALUE_KEY_DATA {
  ULONG PreparedCell; // offset: 0x0 ordinal: 0x0
  ULONG OldValueCell; // offset: 0x4 ordinal: 0x1
  USHORT NameLength;  // offset: 0x8 ordinal: 0x2
  ULONG DataSize;     // offset: 0xc ordinal: 0x3
} _CM_UOW_SET_VALUE_KEY_DATA;

// 0x4 bytes (sizeof)
typedef struct _CM_UOW_SET_SD_DATA {
  ULONG SecurityCell; // offset: 0x0 ordinal: 0x0
} _CM_UOW_SET_SD_DATA;

// 0x488 bytes (sizeof)
typedef struct _CM_DIRTY_VECTOR_LOG {
  ULONG Next;                                // offset: 0x0 ordinal: 0x0
  ULONG Size;                                // offset: 0x4 ordinal: 0x1
  struct _CM_DIRTY_VECTOR_LOG_ENTRY Log[16]; // offset: 0x8 ordinal: 0x2
} _CM_DIRTY_VECTOR_LOG;

// 0x8 bytes (sizeof)
typedef struct _KENLISTMENT_HISTORY {
  ULONG Notification;               // offset: 0x0 ordinal: 0x0
  enum _KENLISTMENT_STATE NewState; // offset: 0x4 ordinal: 0x1
} _KENLISTMENT_HISTORY;

// 0x4 bytes (sizeof)
typedef struct _CM_COMPONENT_HASH {
  ULONG Hash; // offset: 0x0 ordinal: 0x0
} _CM_COMPONENT_HASH;

// 0x8 bytes (sizeof)
typedef struct _CM_INDEX {
  ULONG Cell; // offset: 0x0 ordinal: 0x0
  union {
    struct _CM_FAST_LEAF_HINT NameHint; // offset: 0x4 ordinal: 0x1
    struct _CM_COMPONENT_HASH HashKey;  // offset: 0x4 ordinal: 0x2
  };
} _CM_INDEX;

// 0x18 bytes (sizeof)
typedef struct _CM_NAME_HASH {
  struct _CM_COMPONENT_HASH ConvKey; // offset: 0x0 ordinal: 0x0
  struct _CM_NAME_HASH *NextHash;    // offset: 0x8 ordinal: 0x1
  USHORT NameLength;                 // offset: 0x10 ordinal: 0x2
  WCHAR Name[1];                     // offset: 0x12 ordinal: 0x3
} _CM_NAME_HASH;

// 0x20 bytes (sizeof)
typedef struct _CM_NAME_CONTROL_BLOCK {
  ULONG Compressed : 1; // offset: 0x0 ordinal: 0x0
  ULONG RefCount : 31;  // offset: 0x0 ordinal: 0x1
  union {
    struct _CM_NAME_HASH NameHash;     // offset: 0x8 ordinal: 0x2
    struct _CM_COMPONENT_HASH ConvKey; // offset: 0x8 ordinal: 0x3
  };
  struct _CM_KEY_HASH *NextHash; // offset: 0x10 ordinal: 0x4
  USHORT NameLength;             // offset: 0x18 ordinal: 0x5
  WCHAR Name[1];                 // offset: 0x1a ordinal: 0x6
} _CM_NAME_CONTROL_BLOCK;

// 0x10 bytes (sizeof)
typedef struct _CM_INTENT_LOCK {
  ULONG OwnerCount;                // offset: 0x0 ordinal: 0x0
  struct _CM_KCB_UOW **OwnerTable; // offset: 0x8 ordinal: 0x1
} _CM_INTENT_LOCK;

// 0x4 bytes (sizeof)
typedef struct _CM_PATH_HASH {
  ULONG Hash; // offset: 0x0 ordinal: 0x0
} _CM_PATH_HASH;

// 0x14 bytes (sizeof)
typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
  UCHAR Revision; // offset: 0x0 ordinal: 0x0
  UCHAR Sbz1;     // offset: 0x1 ordinal: 0x1
  USHORT Control; // offset: 0x2 ordinal: 0x2
  ULONG Owner;    // offset: 0x4 ordinal: 0x3
  ULONG Group;    // offset: 0x8 ordinal: 0x4
  ULONG Sacl;     // offset: 0xc ordinal: 0x5
  ULONG Dacl;     // offset: 0x10 ordinal: 0x6
} _SECURITY_DESCRIPTOR_RELATIVE;

// 0x38 bytes (sizeof)
typedef struct _CM_KEY_SECURITY_CACHE {
  ULONG Cell;                                      // offset: 0x0 ordinal: 0x0
  ULONG ConvKey;                                   // offset: 0x4 ordinal: 0x1
  struct _LIST_ENTRY List;                         // offset: 0x8 ordinal: 0x2
  ULONG DescriptorLength;                          // offset: 0x18 ordinal: 0x3
  ULONG RealRefCount;                              // offset: 0x1c ordinal: 0x4
  struct _SECURITY_DESCRIPTOR_RELATIVE Descriptor; // offset: 0x20 ordinal: 0x5
} _CM_KEY_SECURITY_CACHE;

// 0x10 bytes (sizeof)
typedef struct _CM_KEY_SECURITY_CACHE_ENTRY {
  ULONG Cell;                                    // offset: 0x0 ordinal: 0x0
  struct _CM_KEY_SECURITY_CACHE *CachedSecurity; // offset: 0x8 ordinal: 0x1
} _CM_KEY_SECURITY_CACHE_ENTRY;

// 0x8 bytes (sizeof)
typedef struct _CHILD_LIST {
  ULONG Count; // offset: 0x0 ordinal: 0x0
  ULONG List;  // offset: 0x4 ordinal: 0x1
} _CHILD_LIST;

// 0xc bytes (sizeof)
typedef struct _CM_UOW_SET_VALUE_LIST_DATA {
  ULONG RefCount;               // offset: 0x0 ordinal: 0x0
  struct _CHILD_LIST ValueList; // offset: 0x4 ordinal: 0x1
} _CM_UOW_SET_VALUE_LIST_DATA;

// 0x8 bytes (sizeof)
typedef struct _CM_BIG_DATA {
  USHORT Signature; // offset: 0x0 ordinal: 0x0
  USHORT Count;     // offset: 0x2 ordinal: 0x1
  ULONG List;       // offset: 0x4 ordinal: 0x2
} _CM_BIG_DATA;

// 0x28 bytes (sizeof)
typedef struct _CM_KEY_SECURITY {
  USHORT Signature;                                // offset: 0x0 ordinal: 0x0
  USHORT Reserved;                                 // offset: 0x2 ordinal: 0x1
  ULONG Flink;                                     // offset: 0x4 ordinal: 0x2
  ULONG Blink;                                     // offset: 0x8 ordinal: 0x3
  ULONG ReferenceCount;                            // offset: 0xc ordinal: 0x4
  ULONG DescriptorLength;                          // offset: 0x10 ordinal: 0x5
  struct _SECURITY_DESCRIPTOR_RELATIVE Descriptor; // offset: 0x14 ordinal: 0x6
} _CM_KEY_SECURITY;

// 0x18 bytes (sizeof)
typedef struct _CM_KEY_VALUE {
  USHORT Signature;  // offset: 0x0 ordinal: 0x0
  USHORT NameLength; // offset: 0x2 ordinal: 0x1
  ULONG DataLength;  // offset: 0x4 ordinal: 0x2
  ULONG Data;        // offset: 0x8 ordinal: 0x3
  ULONG Type;        // offset: 0xc ordinal: 0x4
  USHORT Flags;      // offset: 0x10 ordinal: 0x5
  USHORT Spare;      // offset: 0x12 ordinal: 0x6
  WCHAR Name[1];     // offset: 0x14 ordinal: 0x7
} _CM_KEY_VALUE;

// 0x18 bytes (sizeof)
typedef struct CMP_OFFSET_ARRAY {
  ULONG FileOffset; // offset: 0x0 ordinal: 0x0
  VOID *DataBuffer; // offset: 0x8 ordinal: 0x1
  ULONG DataLength; // offset: 0x10 ordinal: 0x2
} CMP_OFFSET_ARRAY;

// 0x8 bytes (sizeof)
typedef struct _HV_GET_CELL_CONTEXT {
  ULONG Cell;                            // offset: 0x0 ordinal: 0x0
  struct _HV_GET_BIN_CONTEXT BinContext; // offset: 0x4 ordinal: 0x1
} _HV_GET_CELL_CONTEXT;

typedef VOID *(*__anon_2316)(ULONG, UCHAR, ULONG);

// 0x4 bytes (sizeof)
typedef struct _MMVAD_FLAGS1 {
  ULONG CommitCharge : 31; // offset: 0x0 ordinal: 0x0
  ULONG MemCommit : 1;     // offset: 0x0 ordinal: 0x1
} _MMVAD_FLAGS1;

// 0x4 bytes (sizeof)
typedef union __anon_2298 {
  ULONG LongFlags1;               // offset: 0x0 ordinal: 0x0
  struct _MMVAD_FLAGS1 VadFlags1; // offset: 0x0 ordinal: 0x1
} __anon_2298;

// 0x4 bytes (sizeof)
typedef struct _MM_SHARED_VAD_FLAGS {
  ULONG Lock : 1;                     // offset: 0x0 ordinal: 0x0
  ULONG LockContended : 1;            // offset: 0x0 ordinal: 0x1
  ULONG DeleteInProgress : 1;         // offset: 0x0 ordinal: 0x2
  ULONG NoChange : 1;                 // offset: 0x0 ordinal: 0x3
  ULONG VadType : 3;                  // offset: 0x0 ordinal: 0x4
  ULONG Protection : 5;               // offset: 0x0 ordinal: 0x5
  ULONG PreferredNode : 7;            // offset: 0x0 ordinal: 0x6
  ULONG PageSize : 2;                 // offset: 0x0 ordinal: 0x7
  ULONG PrivateMemoryAlwaysClear : 1; // offset: 0x0 ordinal: 0x8
  ULONG PrivateFixup : 1;             // offset: 0x0 ordinal: 0x9
  ULONG HotPatchState : 2;            // offset: 0x0 ordinal: 0xa
} _MM_SHARED_VAD_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _MM_GRAPHICS_VAD_FLAGS {
  ULONG Lock : 1;                   // offset: 0x0 ordinal: 0x0
  ULONG LockContended : 1;          // offset: 0x0 ordinal: 0x1
  ULONG DeleteInProgress : 1;       // offset: 0x0 ordinal: 0x2
  ULONG NoChange : 1;               // offset: 0x0 ordinal: 0x3
  ULONG VadType : 3;                // offset: 0x0 ordinal: 0x4
  ULONG Protection : 5;             // offset: 0x0 ordinal: 0x5
  ULONG PreferredNode : 7;          // offset: 0x0 ordinal: 0x6
  ULONG PageSize : 2;               // offset: 0x0 ordinal: 0x7
  ULONG PrivateMemoryAlwaysSet : 1; // offset: 0x0 ordinal: 0x8
  ULONG WriteWatch : 1;             // offset: 0x0 ordinal: 0x9
  ULONG FixedLargePageSize : 1;     // offset: 0x0 ordinal: 0xa
  ULONG ZeroFillPagesOptional : 1;  // offset: 0x0 ordinal: 0xb
  ULONG GraphicsAlwaysSet : 1;      // offset: 0x0 ordinal: 0xc
  ULONG GraphicsUseCoherentBus : 1; // offset: 0x0 ordinal: 0xd
  ULONG GraphicsNoCache : 1;        // offset: 0x0 ordinal: 0xe
  ULONG GraphicsPageProtection : 3; // offset: 0x0 ordinal: 0xf
} _MM_GRAPHICS_VAD_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _MM_PRIVATE_VAD_FLAGS {
  ULONG Lock : 1;                         // offset: 0x0 ordinal: 0x0
  ULONG LockContended : 1;                // offset: 0x0 ordinal: 0x1
  ULONG DeleteInProgress : 1;             // offset: 0x0 ordinal: 0x2
  ULONG NoChange : 1;                     // offset: 0x0 ordinal: 0x3
  ULONG VadType : 3;                      // offset: 0x0 ordinal: 0x4
  ULONG Protection : 5;                   // offset: 0x0 ordinal: 0x5
  ULONG PreferredNode : 7;                // offset: 0x0 ordinal: 0x6
  ULONG PageSize : 2;                     // offset: 0x0 ordinal: 0x7
  ULONG PrivateMemoryAlwaysSet : 1;       // offset: 0x0 ordinal: 0x8
  ULONG WriteWatch : 1;                   // offset: 0x0 ordinal: 0x9
  ULONG FixedLargePageSize : 1;           // offset: 0x0 ordinal: 0xa
  ULONG ZeroFillPagesOptional : 1;        // offset: 0x0 ordinal: 0xb
  ULONG Graphics : 1;                     // offset: 0x0 ordinal: 0xc
  ULONG Enclave : 1;                      // offset: 0x0 ordinal: 0xd
  ULONG ShadowStack : 1;                  // offset: 0x0 ordinal: 0xe
  ULONG PhysicalMemoryPfnsReferenced : 1; // offset: 0x0 ordinal: 0xf
} _MM_PRIVATE_VAD_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _MMVAD_FLAGS {
  ULONG Lock : 1;             // offset: 0x0 ordinal: 0x0
  ULONG LockContended : 1;    // offset: 0x0 ordinal: 0x1
  ULONG DeleteInProgress : 1; // offset: 0x0 ordinal: 0x2
  ULONG NoChange : 1;         // offset: 0x0 ordinal: 0x3
  ULONG VadType : 3;          // offset: 0x0 ordinal: 0x4
  ULONG Protection : 5;       // offset: 0x0 ordinal: 0x5
  ULONG PreferredNode : 7;    // offset: 0x0 ordinal: 0x6
  ULONG PageSize : 2;         // offset: 0x0 ordinal: 0x7
  ULONG PrivateMemory : 1;    // offset: 0x0 ordinal: 0x8
} _MMVAD_FLAGS;

// 0x4 bytes (sizeof)
typedef union __anon_2293 {
  ULONG LongFlags;                                // offset: 0x0 ordinal: 0x0
  struct _MMVAD_FLAGS VadFlags;                   // offset: 0x0 ordinal: 0x1
  struct _MM_PRIVATE_VAD_FLAGS PrivateVadFlags;   // offset: 0x0 ordinal: 0x2
  struct _MM_GRAPHICS_VAD_FLAGS GraphicsVadFlags; // offset: 0x0 ordinal: 0x3
  struct _MM_SHARED_VAD_FLAGS SharedVadFlags;     // offset: 0x0 ordinal: 0x4
  ULONG VolatileVadLong;                          // offset: 0x0 ordinal: 0x5
} __anon_2293;

// 0x4 bytes (sizeof)
typedef struct _MODWRITER_FLAGS {
  ULONG KeepForever : 1;        // offset: 0x0 ordinal: 0x0
  ULONG Networked : 1;          // offset: 0x0 ordinal: 0x1
  ULONG IoPriority : 3;         // offset: 0x0 ordinal: 0x2
  ULONG ModifiedStoreWrite : 1; // offset: 0x0 ordinal: 0x3
} _MODWRITER_FLAGS;

// 0x10 bytes (sizeof)
typedef struct _MI_EXTRA_IMAGE_INFORMATION {
  ULONG SizeOfHeaders;                      // offset: 0x0 ordinal: 0x0
  ULONG SizeOfImage;                        // offset: 0x4 ordinal: 0x1
  ULONG TimeDateStamp;                      // offset: 0x8 ordinal: 0x2
  ULONG ImageCetShadowStacksReady : 1;      // offset: 0xc ordinal: 0x3
  ULONG ImageCetShadowStacksStrictMode : 1; // offset: 0xc ordinal: 0x4
  ULONG
  ImageCetSetContextIpValidationRelaxedMode : 1; // offset: 0xc ordinal: 0x5
  ULONG ImageCetDynamicApisAllowInProc : 1;      // offset: 0xc ordinal: 0x6
  ULONG ImageCetDowngradeReserved1 : 1;          // offset: 0xc ordinal: 0x7
  ULONG ImageCetDowngradeReserved2 : 1;          // offset: 0xc ordinal: 0x8
  ULONG Spare : 26;                              // offset: 0xc ordinal: 0x9
} _MI_EXTRA_IMAGE_INFORMATION;

// 0x28 bytes (sizeof)
typedef struct _MI_CONTROL_AREA_WAIT_BLOCK {
  struct _MI_CONTROL_AREA_WAIT_BLOCK *Next; // offset: 0x0 ordinal: 0x0
  ULONG WaitReason;                         // offset: 0x8 ordinal: 0x1
  ULONG WaitResponse;                       // offset: 0xc ordinal: 0x2
  struct _KGATE Gate;                       // offset: 0x10 ordinal: 0x3
} _MI_CONTROL_AREA_WAIT_BLOCK;

// 0x4 bytes (sizeof)
typedef struct _MMSECTION_FLAGS {
  ULONG BeingDeleted : 1;                     // offset: 0x0 ordinal: 0x0
  ULONG BeingCreated : 1;                     // offset: 0x0 ordinal: 0x1
  ULONG BeingPurged : 1;                      // offset: 0x0 ordinal: 0x2
  ULONG NoModifiedWriting : 1;                // offset: 0x0 ordinal: 0x3
  ULONG FailAllIo : 1;                        // offset: 0x0 ordinal: 0x4
  ULONG Image : 1;                            // offset: 0x0 ordinal: 0x5
  ULONG Based : 1;                            // offset: 0x0 ordinal: 0x6
  ULONG File : 1;                             // offset: 0x0 ordinal: 0x7
  ULONG AttemptingDelete : 1;                 // offset: 0x0 ordinal: 0x8
  ULONG PrefetchCreated : 1;                  // offset: 0x0 ordinal: 0x9
  ULONG PhysicalMemory : 1;                   // offset: 0x0 ordinal: 0xa
  ULONG ImageControlAreaOnRemovableMedia : 1; // offset: 0x0 ordinal: 0xb
  ULONG Reserve : 1;                          // offset: 0x0 ordinal: 0xc
  ULONG Commit : 1;                           // offset: 0x0 ordinal: 0xd
  ULONG NoChange : 1;                         // offset: 0x0 ordinal: 0xe
  ULONG WasPurged : 1;                        // offset: 0x0 ordinal: 0xf
  ULONG UserReference : 1;                    // offset: 0x0 ordinal: 0x10
  ULONG GlobalMemory : 1;                     // offset: 0x0 ordinal: 0x11
  ULONG DeleteOnClose : 1;                    // offset: 0x0 ordinal: 0x12
  ULONG FilePointerNull : 1;                  // offset: 0x0 ordinal: 0x13
  ULONG PreferredNode : 7;                    // offset: 0x0 ordinal: 0x14
  ULONG GlobalOnlyPerSession : 1;             // offset: 0x0 ordinal: 0x15
  ULONG UserWritable : 1;                     // offset: 0x0 ordinal: 0x16
  ULONG SystemVaAllocated : 1;                // offset: 0x0 ordinal: 0x17
  ULONG PreferredFsCompressionBoundary : 1;   // offset: 0x0 ordinal: 0x18
  ULONG PageSize64K : 1;                      // offset: 0x0 ordinal: 0x19
} _MMSECTION_FLAGS;

// 0x4 bytes (sizeof)
typedef union __anon_2263 {
  ULONG LongFlags;                // offset: 0x0 ordinal: 0x0
  struct _MMSECTION_FLAGS2 Flags; // offset: 0x0 ordinal: 0x1
} __anon_2263;

// 0x4 bytes (sizeof)
typedef union __anon_2262 {
  ULONG LongFlags;               // offset: 0x0 ordinal: 0x0
  struct _MMSECTION_FLAGS Flags; // offset: 0x0 ordinal: 0x1
} __anon_2262;

// 0x4 bytes (sizeof)
typedef union __anon_2251 {
  ULONG EntryBecameEmpty : 1; // offset: 0x0 ordinal: 0x0
  ULONG DemoteInProgress : 1; // offset: 0x0 ordinal: 0x1
  ULONG ZeroedPages : 1;      // offset: 0x0 ordinal: 0x2
  ULONG Spare : 29;           // offset: 0x0 ordinal: 0x3
  ULONG AllFlags;             // offset: 0x0 ordinal: 0x4
} __anon_2251;

// 0x4 bytes (sizeof)
typedef struct _MI_NODE_NUMBER_ZERO_BASED {
  ULONG ZeroBased; // offset: 0x0 ordinal: 0x0
} _MI_NODE_NUMBER_ZERO_BASED;

// 0x4 bytes (sizeof)
typedef struct __anon_2217 {
  ULONG ChannelsHotCold : 1; // offset: 0x0 ordinal: 0x0
  ULONG Spare : 31;          // offset: 0x0 ordinal: 0x1
} __anon_2217;

// 0x20 bytes (sizeof)
typedef struct _MI_AVAILABLE_PAGE_WAIT_STATES {
  struct _KEVENT Event; // offset: 0x0 ordinal: 0x0
  ULONG EventSets;      // offset: 0x18 ordinal: 0x1
} _MI_AVAILABLE_PAGE_WAIT_STATES;

// 0x4 bytes (sizeof)
typedef union __anon_2193 {
  ULONG LongFlags;                           // offset: 0x0 ordinal: 0x0
  struct _MMPAGE_FILE_EXPANSION_FLAGS Flags; // offset: 0x0 ordinal: 0x1
} __anon_2193;

// 0x4 bytes (sizeof)
typedef struct _MI_PARTITION_FLAGS {
  ULONG BeingDeleted : 1;                  // offset: 0x0 ordinal: 0x0
  ULONG PageListsInitialized : 1;          // offset: 0x0 ordinal: 0x1
  ULONG StoreReservedPagesCharged : 1;     // offset: 0x0 ordinal: 0x2
  ULONG UseProtectedSlabAllocators : 1;    // offset: 0x0 ordinal: 0x3
  ULONG PureHoldingPartition : 1;          // offset: 0x0 ordinal: 0x4
  ULONG ZeroPagesOptional : 1;             // offset: 0x0 ordinal: 0x5
  ULONG BackgroundZeroingDisabled : 1;     // offset: 0x0 ordinal: 0x6
  ULONG SpecialPurposeMemoryPartition : 1; // offset: 0x0 ordinal: 0x7
} _MI_PARTITION_FLAGS;

// 0x4 bytes (sizeof)
typedef union __anon_2150 {
  ULONG LongFlags;                  // offset: 0x0 ordinal: 0x0
  struct _MI_PARTITION_FLAGS Flags; // offset: 0x0 ordinal: 0x1
} __anon_2150;

// 0x8 bytes (sizeof)
typedef struct _MI_CACHED_PTE {
  ULONG GlobalTimeStamp; // offset: 0x0 ordinal: 0x0
  ULONG PteIndex;        // offset: 0x4 ordinal: 0x1
  LONGLONG Long;         // offset: 0x0 ordinal: 0x2
} _MI_CACHED_PTE;

// 0x48 bytes (sizeof)
typedef struct _MI_CACHED_PTES {
  struct _MI_CACHED_PTE Bins[8]; // offset: 0x0 ordinal: 0x0
  LONG CachedPteCount;           // offset: 0x40 ordinal: 0x1
} _MI_CACHED_PTES;

// 0x4 bytes (sizeof)
typedef struct __anon_2120 {
  ULONG NodeBlinkHigh : 21;   // offset: 0x0 ordinal: 0x0
  ULONG NodeFlinkMiddle : 11; // offset: 0x0 ordinal: 0x1
} __anon_2120;

// 0x4 bytes (sizeof)
typedef struct _MI_PFN_ULONG5 {
  union {
    ULONG EntireField;                 // offset: 0x0 ordinal: 0x0
    struct __anon_2120 StandbyList;    // offset: 0x0 ordinal: 0x1
    struct __anon_2121 MappedPageList; // offset: 0x0 ordinal: 0x2
    struct __anon_2122 Active;         // offset: 0x0 ordinal: 0x3
  };
} _MI_PFN_ULONG5;

// 0x4 bytes (sizeof)
typedef struct __anon_2112 {
  ULONG EntireField; // offset: 0x0 ordinal: 0x0
} __anon_2112;

// 0x4 bytes (sizeof)
typedef union __anon_2113 {
  USHORT ReferenceCount;  // offset: 0x0 ordinal: 0x0
  struct _MMPFNENTRY1 e1; // offset: 0x2 ordinal: 0x1
  struct _MMPFNENTRY3 e3; // offset: 0x3 ordinal: 0x2
  struct __anon_2111 e2;  // offset: 0x0 ordinal: 0x3
  struct __anon_2112 e4;  // offset: 0x0 ordinal: 0x4
} __anon_2113;

// 0x4 bytes (sizeof)
typedef struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
  ULONG Expanded : 1;      // offset: 0x0 ordinal: 0x0
  ULONG Transitioning : 1; // offset: 0x0 ordinal: 0x1
  ULONG Pageable : 1;      // offset: 0x0 ordinal: 0x2
  ULONG Value;             // offset: 0x0 ordinal: 0x3
} _EX_PUSH_LOCK_AUTO_EXPAND_STATE;

// 0x10 bytes (sizeof)
typedef struct _GUID {
  ULONG Data1;    // offset: 0x0 ordinal: 0x0
  USHORT Data2;   // offset: 0x4 ordinal: 0x1
  USHORT Data3;   // offset: 0x6 ordinal: 0x2
  UCHAR Data4[8]; // offset: 0x8 ordinal: 0x3
} _GUID;

// 0x10 bytes (sizeof)
typedef struct _RTL_HASH_TABLE {
  ULONG EntryCount;                   // offset: 0x0 ordinal: 0x0
  ULONG MaskBitCount : 5;             // offset: 0x4 ordinal: 0x1
  ULONG BucketCount : 27;             // offset: 0x4 ordinal: 0x2
  struct _SINGLE_LIST_ENTRY *Buckets; // offset: 0x8 ordinal: 0x3
} _RTL_HASH_TABLE;

// 0x4 bytes (sizeof)
typedef struct __anon_2042 {
  ULONG FilePointerIndex : 9; // offset: 0x0 ordinal: 0x0
  ULONG HardFault : 1;        // offset: 0x0 ordinal: 0x1
  ULONG Spare1 : 2;           // offset: 0x0 ordinal: 0x2
} __anon_2042;

// 0x4 bytes (sizeof)
typedef struct __anon_2041 {
  ULONG FilePointerIndex : 9; // offset: 0x0 ordinal: 0x0
  ULONG HardFault : 1;        // offset: 0x0 ordinal: 0x1
  ULONG Image : 1;            // offset: 0x0 ordinal: 0x2
  ULONG Spare0 : 1;           // offset: 0x0 ordinal: 0x3
} __anon_2041;

// 0x4 bytes (sizeof)
typedef union _MM_PAGE_ACCESS_INFO_FLAGS {
  struct __anon_2041 File;    // offset: 0x0 ordinal: 0x0
  struct __anon_2042 Private; // offset: 0x0 ordinal: 0x1
} _MM_PAGE_ACCESS_INFO_FLAGS;

// 0x10 bytes (sizeof)
typedef struct _IO_PRIORITY_INFO {
  ULONG Size;                        // offset: 0x0 ordinal: 0x0
  ULONG ThreadPriority;              // offset: 0x4 ordinal: 0x1
  ULONG PagePriority;                // offset: 0x8 ordinal: 0x2
  enum _IO_PRIORITY_HINT IoPriority; // offset: 0xc ordinal: 0x3
} _IO_PRIORITY_INFO;

// 0x8 bytes (sizeof)
typedef struct _OBJECT_HANDLE_INFORMATION {
  ULONG HandleAttributes; // offset: 0x0 ordinal: 0x0
  ULONG GrantedAccess;    // offset: 0x4 ordinal: 0x1
} _OBJECT_HANDLE_INFORMATION;

// 0x10 bytes (sizeof)
typedef struct _GENERIC_MAPPING {
  ULONG GenericRead;    // offset: 0x0 ordinal: 0x0
  ULONG GenericWrite;   // offset: 0x4 ordinal: 0x1
  ULONG GenericExecute; // offset: 0x8 ordinal: 0x2
  ULONG GenericAll;     // offset: 0xc ordinal: 0x3
} _GENERIC_MAPPING;

// 0x4 bytes (sizeof)
typedef struct _PS_TRUSTLET_ATTRIBUTE_TYPE {
  UCHAR Version;      // offset: 0x0 ordinal: 0x0
  UCHAR DataCount;    // offset: 0x1 ordinal: 0x1
  UCHAR SemanticType; // offset: 0x2 ordinal: 0x2
  union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS
      AccessRights;    // offset: 0x3 ordinal: 0x3
  ULONG AttributeType; // offset: 0x0 ordinal: 0x4
} _PS_TRUSTLET_ATTRIBUTE_TYPE;

// 0x8 bytes (sizeof)
typedef struct _PS_TRUSTLET_ATTRIBUTE_HEADER {
  struct _PS_TRUSTLET_ATTRIBUTE_TYPE AttributeType; // offset: 0x0 ordinal: 0x0
  ULONG InstanceNumber : 8;                         // offset: 0x4 ordinal: 0x1
  ULONG Reserved : 24;                              // offset: 0x4 ordinal: 0x2
} _PS_TRUSTLET_ATTRIBUTE_HEADER;

// 0x4 bytes (sizeof)
typedef struct _SINGLE_LIST_ENTRY32 {
  ULONG Next; // offset: 0x0 ordinal: 0x0
} _SINGLE_LIST_ENTRY32;

// 0x8 bytes (sizeof)
typedef struct _IMAGE_DATA_DIRECTORY {
  ULONG VirtualAddress; // offset: 0x0 ordinal: 0x0
  ULONG Size;           // offset: 0x4 ordinal: 0x1
} _IMAGE_DATA_DIRECTORY;

// 0x14 bytes (sizeof)
typedef struct _IMAGE_FILE_HEADER {
  USHORT Machine;              // offset: 0x0 ordinal: 0x0
  USHORT NumberOfSections;     // offset: 0x2 ordinal: 0x1
  ULONG TimeDateStamp;         // offset: 0x4 ordinal: 0x2
  ULONG PointerToSymbolTable;  // offset: 0x8 ordinal: 0x3
  ULONG NumberOfSymbols;       // offset: 0xc ordinal: 0x4
  USHORT SizeOfOptionalHeader; // offset: 0x10 ordinal: 0x5
  USHORT Characteristics;      // offset: 0x12 ordinal: 0x6
} _IMAGE_FILE_HEADER;

// 0x18 bytes (sizeof)
typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
  struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME
      *Previous;                                 // offset: 0x0 ordinal: 0x0
  struct _ACTIVATION_CONTEXT *ActivationContext; // offset: 0x8 ordinal: 0x1
  ULONG Flags;                                   // offset: 0x10 ordinal: 0x2
} _RTL_ACTIVATION_CONTEXT_STACK_FRAME;

// 0x18 bytes (sizeof)
typedef struct _TEB_ACTIVE_FRAME {
  ULONG Flags;                               // offset: 0x0 ordinal: 0x0
  struct _TEB_ACTIVE_FRAME *Previous;        // offset: 0x8 ordinal: 0x1
  struct _TEB_ACTIVE_FRAME_CONTEXT *Context; // offset: 0x10 ordinal: 0x2
} _TEB_ACTIVE_FRAME;

// 0x4e0 bytes (sizeof)
typedef struct _GDI_TEB_BATCH32 {
  ULONG Offset : 31;             // offset: 0x0 ordinal: 0x0
  ULONG HasRenderingCommand : 1; // offset: 0x0 ordinal: 0x1
  ULONG HDC;                     // offset: 0x4 ordinal: 0x2
  ULONG Buffer[310];             // offset: 0x8 ordinal: 0x3
} _GDI_TEB_BATCH32;

// 0x28 bytes (sizeof)
typedef struct _ACTIVATION_CONTEXT_STACK {
  struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME
      *ActiveFrame;                  // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY FrameListCache; // offset: 0x8 ordinal: 0x1
  ULONG Flags;                       // offset: 0x18 ordinal: 0x2
  ULONG NextCookieSequenceNumber;    // offset: 0x1c ordinal: 0x3
  ULONG StackId;                     // offset: 0x20 ordinal: 0x4
} _ACTIVATION_CONTEXT_STACK;

// 0x4 bytes (sizeof)
typedef struct __anon_1945 {
  ULONG LongFunction : 1; // offset: 0x0 ordinal: 0x0
  ULONG Persistent : 1;   // offset: 0x0 ordinal: 0x1
  ULONG Private : 30;     // offset: 0x0 ordinal: 0x2
} __anon_1945;

// 0x4 bytes (sizeof)
typedef union __anon_1946 {
  ULONG Flags;          // offset: 0x0 ordinal: 0x0
  struct __anon_1945 s; // offset: 0x0 ordinal: 0x1
} __anon_1946;

// 0x48 bytes (sizeof)
typedef struct _TP_CALLBACK_ENVIRON_V3 {
  ULONG Version;                          // offset: 0x0 ordinal: 0x0
  struct _TP_POOL *Pool;                  // offset: 0x8 ordinal: 0x1
  struct _TP_CLEANUP_GROUP *CleanupGroup; // offset: 0x10 ordinal: 0x2
  VOID(*CleanupGroupCancelCallback)
  (VOID *, VOID *);                              // offset: 0x18 ordinal: 0x3
  VOID *RaceDll;                                 // offset: 0x20 ordinal: 0x4
  struct _ACTIVATION_CONTEXT *ActivationContext; // offset: 0x28 ordinal: 0x5
  VOID(*FinalizationCallback)
  (struct _TP_CALLBACK_INSTANCE *, VOID *);    // offset: 0x30 ordinal: 0x6
  union __anon_1946 u;                         // offset: 0x38 ordinal: 0x7
  enum _TP_CALLBACK_PRIORITY CallbackPriority; // offset: 0x3c ordinal: 0x8
  ULONG Size;                                  // offset: 0x40 ordinal: 0x9
} _TP_CALLBACK_ENVIRON_V3;

// 0x8 bytes (sizeof)
typedef struct _XSTATE_FEATURE {
  ULONG Offset; // offset: 0x0 ordinal: 0x0
  ULONG Size;   // offset: 0x4 ordinal: 0x1
} _XSTATE_FEATURE;

// 0xc bytes (sizeof)
typedef struct _KSYSTEM_TIME {
  ULONG LowPart;  // offset: 0x0 ordinal: 0x0
  LONG High1Time; // offset: 0x4 ordinal: 0x1
  LONG High2Time; // offset: 0x8 ordinal: 0x2
} _KSYSTEM_TIME;

// 0x4 bytes (sizeof)
typedef union _AMD64_MXCSR_REG {
  ULONG Value;    // offset: 0x0 ordinal: 0x0
  ULONG IE : 1;   // offset: 0x0 ordinal: 0x1
  ULONG DE : 1;   // offset: 0x0 ordinal: 0x2
  ULONG ZE : 1;   // offset: 0x0 ordinal: 0x3
  ULONG OE : 1;   // offset: 0x0 ordinal: 0x4
  ULONG UE : 1;   // offset: 0x0 ordinal: 0x5
  ULONG PE : 1;   // offset: 0x0 ordinal: 0x6
  ULONG DAZ : 1;  // offset: 0x0 ordinal: 0x7
  ULONG IM : 1;   // offset: 0x0 ordinal: 0x8
  ULONG DM : 1;   // offset: 0x0 ordinal: 0x9
  ULONG ZM : 1;   // offset: 0x0 ordinal: 0xa
  ULONG OM : 1;   // offset: 0x0 ordinal: 0xb
  ULONG UM : 1;   // offset: 0x0 ordinal: 0xc
  ULONG PM : 1;   // offset: 0x0 ordinal: 0xd
  ULONG RC : 2;   // offset: 0x0 ordinal: 0xe
  ULONG FZ : 1;   // offset: 0x0 ordinal: 0xf
  ULONG res : 16; // offset: 0x0 ordinal: 0x10
} _AMD64_MXCSR_REG;

// 0x4 bytes (sizeof)
typedef union _ARM64_FPSR_REG {
  ULONG Value;       // offset: 0x0 ordinal: 0x0
  ULONG IOC : 1;     // offset: 0x0 ordinal: 0x1
  ULONG DZC : 1;     // offset: 0x0 ordinal: 0x2
  ULONG OFC : 1;     // offset: 0x0 ordinal: 0x3
  ULONG UFC : 1;     // offset: 0x0 ordinal: 0x4
  ULONG IXC : 1;     // offset: 0x0 ordinal: 0x5
  ULONG res0_1 : 2;  // offset: 0x0 ordinal: 0x6
  ULONG IDC : 1;     // offset: 0x0 ordinal: 0x7
  ULONG res0_2 : 19; // offset: 0x0 ordinal: 0x8
  ULONG QC : 1;      // offset: 0x0 ordinal: 0x9
  ULONG V : 1;       // offset: 0x0 ordinal: 0xa
  ULONG C : 1;       // offset: 0x0 ordinal: 0xb
  ULONG Z : 1;       // offset: 0x0 ordinal: 0xc
  ULONG N : 1;       // offset: 0x0 ordinal: 0xd
} _ARM64_FPSR_REG;

// 0x4 bytes (sizeof)
typedef union _ARM64_FPCR_REG {
  ULONG Value;      // offset: 0x0 ordinal: 0x0
  ULONG res0_1 : 8; // offset: 0x0 ordinal: 0x1
  ULONG IOE : 1;    // offset: 0x0 ordinal: 0x2
  ULONG DZE : 1;    // offset: 0x0 ordinal: 0x3
  ULONG OFE : 1;    // offset: 0x0 ordinal: 0x4
  ULONG UFE : 1;    // offset: 0x0 ordinal: 0x5
  ULONG IXE : 1;    // offset: 0x0 ordinal: 0x6
  ULONG res0_2 : 2; // offset: 0x0 ordinal: 0x7
  ULONG IDE : 1;    // offset: 0x0 ordinal: 0x8
  ULONG Len : 3;    // offset: 0x0 ordinal: 0x9
  ULONG FZ16 : 1;   // offset: 0x0 ordinal: 0xa
  ULONG Stride : 2; // offset: 0x0 ordinal: 0xb
  ULONG RMode : 2;  // offset: 0x0 ordinal: 0xc
  ULONG FZ : 1;     // offset: 0x0 ordinal: 0xd
  ULONG DN : 1;     // offset: 0x0 ordinal: 0xe
  ULONG AHP : 1;    // offset: 0x0 ordinal: 0xf
  ULONG res0_3 : 5; // offset: 0x0 ordinal: 0x10
} _ARM64_FPCR_REG;

// 0x10 bytes (sizeof)
typedef struct _INTERRUPT_LINE_INTERNAL_STATE {
  UCHAR Fixed;               // offset: 0x0 ordinal: 0x0
  UCHAR Irql;                // offset: 0x1 ordinal: 0x1
  UCHAR Swapping;            // offset: 0x2 ordinal: 0x2
  ULONG OldClusterId;        // offset: 0x4 ordinal: 0x3
  ULONG OldClusterMask;      // offset: 0x8 ordinal: 0x4
  UCHAR LineStateDetermined; // offset: 0xc ordinal: 0x5
} _INTERRUPT_LINE_INTERNAL_STATE;

// 0xa bytes (sizeof)
typedef struct _ISA_VECTOR {
  UCHAR Type;                        // offset: 0x0 ordinal: 0x0
  UCHAR Length;                      // offset: 0x1 ordinal: 0x1
  UCHAR Bus;                         // offset: 0x2 ordinal: 0x2
  UCHAR Source;                      // offset: 0x3 ordinal: 0x3
  ULONG GlobalSystemInterruptVector; // offset: 0x4 ordinal: 0x4
  USHORT Flags;                      // offset: 0x8 ordinal: 0x5
} _ISA_VECTOR;

// 0x8 bytes (sizeof)
typedef struct _IO_NMISOURCE {
  UCHAR Type;                        // offset: 0x0 ordinal: 0x0
  UCHAR Length;                      // offset: 0x1 ordinal: 0x1
  USHORT Flags;                      // offset: 0x2 ordinal: 0x2
  ULONG GlobalSystemInterruptVector; // offset: 0x4 ordinal: 0x3
} _IO_NMISOURCE;

// 0x8 bytes (sizeof)
typedef struct _HAL_HV_DMA_DOMAIN_INFO {
  ULONG DomainId; // offset: 0x0 ordinal: 0x0
  UCHAR IsStage1; // offset: 0x4 ordinal: 0x1
} _HAL_HV_DMA_DOMAIN_INFO;

// 0xc bytes (sizeof)
typedef struct _HAL_HV_DMA_CREATE_DOMAIN_INFO {
  struct _HAL_HV_DMA_DOMAIN_INFO DomainInfo; // offset: 0x0 ordinal: 0x0
  UCHAR InheritPassthroughDomain;            // offset: 0x8 ordinal: 0x1
  UCHAR ForwardProgressRequired;             // offset: 0x9 ordinal: 0x2
} _HAL_HV_DMA_CREATE_DOMAIN_INFO;

typedef LONG (*__anon_1871)(struct _HAL_HV_DMA_CREATE_DOMAIN_INFO *);

typedef LONG (*__anon_1873)(struct _HAL_HV_DMA_DOMAIN_INFO *);

// 0x18 bytes (sizeof)
typedef struct _HAL_HV_SVM_SYSTEM_CAPABILITIES {
  ULONG SvmSupported : 1;        // offset: 0x0 ordinal: 0x0
  ULONG GpaAlwaysValid : 1;      // offset: 0x0 ordinal: 0x1
  ULONG MaxPasidSpaceCount;      // offset: 0x4 ordinal: 0x2
  ULONG MaxPasidSpacePasidCount; // offset: 0x8 ordinal: 0x3
  ULONG MaxPrqSize;              // offset: 0xc ordinal: 0x4
  ULONG IommuCount;              // offset: 0x10 ordinal: 0x5
  ULONG MinIommuPasidCount;      // offset: 0x14 ordinal: 0x6
} _HAL_HV_SVM_SYSTEM_CAPABILITIES;

typedef VOID (*__anon_1858)(struct _HAL_HV_SVM_SYSTEM_CAPABILITIES *);

typedef LONG (*__anon_1860)(ULONG, ULONG);

typedef LONG (*__anon_1856)(UCHAR, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG,
                            VOID *);

typedef LONG (*__anon_1854)(ULONG, VOID *);

typedef ULONG (*__anon_1851)(ULONG);

typedef LONG (*__anon_1847)(ULONG);

typedef VOID (*__anon_1835)(ULONG);

typedef VOID (*__anon_1834)(ULONG, ULONG);

// 0xc bytes (sizeof)
typedef struct _IOAPIC {
  UCHAR Type;             // offset: 0x0 ordinal: 0x0
  UCHAR Length;           // offset: 0x1 ordinal: 0x1
  UCHAR IOAPICID;         // offset: 0x2 ordinal: 0x2
  UCHAR Reserved;         // offset: 0x3 ordinal: 0x3
  ULONG IOAPICAddress;    // offset: 0x4 ordinal: 0x4
  ULONG SystemVectorBase; // offset: 0x8 ordinal: 0x5
} _IOAPIC;

// 0x4 bytes (sizeof)
typedef struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CAPABILITIES {
  ULONG ExplicitAddressCapable : 1; // offset: 0x0 ordinal: 0x0
  ULONG Reserved : 31;              // offset: 0x0 ordinal: 0x1
} _IOMMU_DMA_LOGICAL_ALLOCATOR_CAPABILITIES;

typedef struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CAPABILITIES (*__anon_1760)(
    struct _IOMMU_DMA_LOGICAL_ALLOCATOR *);

// 0x10 bytes (sizeof)
typedef struct _DMA_TRANSFER_INFO_V2 {
  ULONG MapRegisterCount;          // offset: 0x0 ordinal: 0x0
  ULONG ScatterGatherElementCount; // offset: 0x4 ordinal: 0x1
  ULONG ScatterGatherListSize;     // offset: 0x8 ordinal: 0x2
  ULONG LogicalPageCount;          // offset: 0xc ordinal: 0x3
} _DMA_TRANSFER_INFO_V2;

// 0xc bytes (sizeof)
typedef struct _DMA_TRANSFER_INFO_V1 {
  ULONG MapRegisterCount;          // offset: 0x0 ordinal: 0x0
  ULONG ScatterGatherElementCount; // offset: 0x4 ordinal: 0x1
  ULONG ScatterGatherListSize;     // offset: 0x8 ordinal: 0x2
} _DMA_TRANSFER_INFO_V1;

// 0x14 bytes (sizeof)
typedef struct _DMA_ADAPTER_INFO_V1 {
  ULONG ReadDmaCounterAvailable; // offset: 0x0 ordinal: 0x0
  ULONG ScatterGatherLimit;      // offset: 0x4 ordinal: 0x1
  ULONG DmaAddressWidth;         // offset: 0x8 ordinal: 0x2
  ULONG Flags;                   // offset: 0xc ordinal: 0x3
  ULONG MinimumTransferUnit;     // offset: 0x10 ordinal: 0x4
} _DMA_ADAPTER_INFO_V1;

typedef LONG (*__anon_1704)(VOID *, ULONG, ULONG);

typedef LONG (*__anon_1693)(struct _EXT_IOMMU *, ULONG, UCHAR);

// 0x14 bytes (sizeof)
typedef struct _DMA_TRANSFER_INFO {
  ULONG Version; // offset: 0x0 ordinal: 0x0
  union {
    struct _DMA_TRANSFER_INFO_V1 V1; // offset: 0x4 ordinal: 0x1
    struct _DMA_TRANSFER_INFO_V2 V2; // offset: 0x4 ordinal: 0x2
  };
} _DMA_TRANSFER_INFO;

// 0x8 bytes (sizeof)
typedef struct _DMA_REQUEST_LINE_BINDING_DESCRIPTION {
  ULONG RequestLine;   // offset: 0x0 ordinal: 0x0
  ULONG ChannelNumber; // offset: 0x4 ordinal: 0x1
} _DMA_REQUEST_LINE_BINDING_DESCRIPTION;

typedef UCHAR (*__anon_1561)(VOID *,
                             struct _DMA_REQUEST_LINE_BINDING_DESCRIPTION *);

// 0x40 bytes (sizeof)
typedef struct _IOMMU_PASID_TABLE_OBJECT {
  struct _LIST_ENTRY ListEntry;      // offset: 0x0 ordinal: 0x0
  ULONG Domain;                      // offset: 0x10 ordinal: 0x1
  struct _LIST_ENTRY DeviceListHead; // offset: 0x18 ordinal: 0x2
  VOID *Table;                       // offset: 0x28 ordinal: 0x3
  ULONG PasidCount;                  // offset: 0x30 ordinal: 0x4
  VOID *OldTable;                    // offset: 0x38 ordinal: 0x5
} _IOMMU_PASID_TABLE_OBJECT;

typedef VOID (*__anon_1723)(VOID *, struct _IOMMU_PASID_TABLE_OBJECT *, VOID *);

typedef LONG (*__anon_1710)(VOID *, struct _IOMMU_PASID_TABLE_OBJECT *, ULONG);

// 0x4 bytes (sizeof)
typedef struct __anon_1632 {
  ULONG PasidMaxWidth : 5;           // offset: 0x0 ordinal: 0x0
  ULONG PasidExePerm : 1;            // offset: 0x0 ordinal: 0x1
  ULONG PasidPrivMode : 1;           // offset: 0x0 ordinal: 0x2
  ULONG AtsPageAlignedRequest : 1;   // offset: 0x0 ordinal: 0x3
  ULONG AtsGlobalInvalidate : 1;     // offset: 0x0 ordinal: 0x4
  ULONG AtsInvalidateQueueDepth : 5; // offset: 0x0 ordinal: 0x5
} __anon_1632;

// 0x4 bytes (sizeof)
typedef union _IOMMU_INTERFACE_STATE_CHANGE_FIELDS {
  ULONG AvailableDomainTypes : 1; // offset: 0x0 ordinal: 0x0
  ULONG Reserved : 31;            // offset: 0x0 ordinal: 0x1
  ULONG AsULONG;                  // offset: 0x0 ordinal: 0x2
} _IOMMU_INTERFACE_STATE_CHANGE_FIELDS;

typedef LONG (*__anon_1599)(struct _DMA_ADAPTER *, ULONG, VOID *);

typedef LONG (*__anon_1598)(
    struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *, ULONG, ULONG,
    enum _IO_ALLOCATION_ACTION (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                   VOID *, VOID *),
    VOID *, VOID **);

typedef ULONG (*__anon_1588)(struct _DMA_ADAPTER *);

typedef VOID (*__anon_1586)(struct _DMA_ADAPTER *, VOID *, ULONG);

typedef UCHAR (*__anon_1585)(struct _DMA_ADAPTER *, struct _MDL *, VOID *,
                             VOID *, ULONG, UCHAR);

typedef LONG (*__anon_1584)(
    struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, ULONG,
    enum _IO_ALLOCATION_ACTION (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                   VOID *, VOID *),
    VOID *);

// 0x4 bytes (sizeof)
typedef struct _FAULT_INFORMATION_X64_FLAGS {
  ULONG FaultAddressValid : 1; // offset: 0x0 ordinal: 0x0
  ULONG Reserved : 31;         // offset: 0x0 ordinal: 0x1
} _FAULT_INFORMATION_X64_FLAGS;

// 0x4 bytes (sizeof)
typedef struct _FAULT_INFORMATION_ARM64_FLAGS {
  ULONG WriteNotRead : 1;       // offset: 0x0 ordinal: 0x0
  ULONG InstructionNotData : 1; // offset: 0x0 ordinal: 0x1
  ULONG Privileged : 1;         // offset: 0x0 ordinal: 0x2
  ULONG FaultAddressValid : 1;  // offset: 0x0 ordinal: 0x3
  ULONG Reserved : 28;          // offset: 0x0 ordinal: 0x4
} _FAULT_INFORMATION_ARM64_FLAGS;

// 0xc bytes (sizeof)
typedef union _IOMMU_SVM_CAPABILITIES {
  ULONG AtsCapability : 1;   // offset: 0x0 ordinal: 0x0
  ULONG PriCapability : 1;   // offset: 0x0 ordinal: 0x1
  ULONG PasidCapability : 1; // offset: 0x0 ordinal: 0x2
  struct __anon_1632 CapReg; // offset: 0x4 ordinal: 0x3
  ULONG Rsvd : 15;           // offset: 0x8 ordinal: 0x4
  ULONG AsULONG;             // offset: 0x0 ordinal: 0x5
} _IOMMU_SVM_CAPABILITIES;

// 0x8 bytes (sizeof)
typedef struct _IOMMU_INTERFACE_STATE_CHANGE {
  union _IOMMU_INTERFACE_STATE_CHANGE_FIELDS
      PresentFields;          // offset: 0x0 ordinal: 0x0
  ULONG AvailableDomainTypes; // offset: 0x4 ordinal: 0x1
} _IOMMU_INTERFACE_STATE_CHANGE;

typedef VOID (*__anon_1630)(struct _IOMMU_INTERFACE_STATE_CHANGE *, VOID *);

typedef UCHAR (*__anon_1566)(VOID *, ULONG);

typedef LONG (*__anon_1563)(VOID *, ULONG, ULONG, VOID *);

// 0x18 bytes (sizeof)
typedef struct _HALP_DMA_TRANSLATION_BUFFER {
  struct _HALP_DMA_TRANSLATION_BUFFER *Next;   // offset: 0x0 ordinal: 0x0
  ULONG EntryCount;                            // offset: 0x8 ordinal: 0x1
  struct _HALP_DMA_TRANSLATION_ENTRY *Entries; // offset: 0x10 ordinal: 0x2
} _HALP_DMA_TRANSLATION_BUFFER;

// 0x10 bytes (sizeof)
typedef struct _HALP_DMA_TRANSLATION_BUFFER_POSITION {
  struct _HALP_DMA_TRANSLATION_BUFFER *Buffer; // offset: 0x0 ordinal: 0x0
  ULONG Offset;                                // offset: 0x8 ordinal: 0x1
} _HALP_DMA_TRANSLATION_BUFFER_POSITION;

// 0x20 bytes (sizeof)
typedef struct __anon_1473 {
  struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
      ContiguousHint; // offset: 0x0 ordinal: 0x0
  struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
      ScatterHint; // offset: 0x10 ordinal: 0x1
} __anon_1473;

// 0x10 bytes (sizeof)
typedef struct _PLATFORM_INTERRUPT {
  UCHAR Type;          // offset: 0x0 ordinal: 0x0
  UCHAR Length;        // offset: 0x1 ordinal: 0x1
  USHORT Flags;        // offset: 0x2 ordinal: 0x2
  UCHAR InterruptType; // offset: 0x4 ordinal: 0x3
  UCHAR APICID;        // offset: 0x5 ordinal: 0x4
  UCHAR ACPIEID;       // offset: 0x6 ordinal: 0x5
  UCHAR IOSAPICVector; // offset: 0x7 ordinal: 0x6
  ULONG GlobalVector;  // offset: 0x8 ordinal: 0x7
  ULONG Reserved;      // offset: 0xc ordinal: 0x8
} _PLATFORM_INTERRUPT;

// 0x8 bytes (sizeof)
typedef struct _PROCLOCALAPIC {
  UCHAR Type;            // offset: 0x0 ordinal: 0x0
  UCHAR Length;          // offset: 0x1 ordinal: 0x1
  UCHAR ACPIProcessorID; // offset: 0x2 ordinal: 0x2
  UCHAR APICID;          // offset: 0x3 ordinal: 0x3
  ULONG Flags;           // offset: 0x4 ordinal: 0x4
} _PROCLOCALAPIC;

// 0x24 bytes (sizeof)
typedef struct _DESCRIPTION_HEADER {
  ULONG Signature;    // offset: 0x0 ordinal: 0x0
  ULONG Length;       // offset: 0x4 ordinal: 0x1
  UCHAR Revision;     // offset: 0x8 ordinal: 0x2
  UCHAR Checksum;     // offset: 0x9 ordinal: 0x3
  CHAR OEMID[6];      // offset: 0xa ordinal: 0x4
  CHAR OEMTableID[8]; // offset: 0x10 ordinal: 0x5
  ULONG OEMRevision;  // offset: 0x18 ordinal: 0x6
  CHAR CreatorID[4];  // offset: 0x1c ordinal: 0x7
  ULONG CreatorRev;   // offset: 0x20 ordinal: 0x8
} _DESCRIPTION_HEADER;

// 0x58 bytes (sizeof)
typedef struct _KAPC {
  UCHAR Type;                      // offset: 0x0 ordinal: 0x0
  UCHAR AllFlags;                  // offset: 0x1 ordinal: 0x1
  UCHAR Size;                      // offset: 0x2 ordinal: 0x2
  UCHAR SpareByte1;                // offset: 0x3 ordinal: 0x3
  ULONG SpareLong0;                // offset: 0x4 ordinal: 0x4
  struct _KTHREAD *Thread;         // offset: 0x8 ordinal: 0x5
  struct _LIST_ENTRY ApcListEntry; // offset: 0x10 ordinal: 0x6
  VOID *Reserved[3];               // offset: 0x20 ordinal: 0x7
  VOID *NormalContext;             // offset: 0x38 ordinal: 0x8
  VOID *SystemArgument1;           // offset: 0x40 ordinal: 0x9
  VOID *SystemArgument2;           // offset: 0x48 ordinal: 0xa
  CHAR ApcStateIndex;              // offset: 0x50 ordinal: 0xb
  CHAR ApcMode;                    // offset: 0x51 ordinal: 0xc
  UCHAR Inserted;                  // offset: 0x52 ordinal: 0xd
} _KAPC;

// 0x10 bytes (sizeof)
typedef struct _PROCLOCALX2APIC {
  UCHAR Type;            // offset: 0x0 ordinal: 0x0
  UCHAR Length;          // offset: 0x1 ordinal: 0x1
  USHORT Reserved;       // offset: 0x2 ordinal: 0x2
  ULONG APICID;          // offset: 0x4 ordinal: 0x3
  ULONG Flags;           // offset: 0x8 ordinal: 0x4
  ULONG ACPIProcessorID; // offset: 0xc ordinal: 0x5
} _PROCLOCALX2APIC;

// 0xc bytes (sizeof)
typedef struct _LOCAL_X2APIC_NMISOURCE {
  UCHAR Type;        // offset: 0x0 ordinal: 0x0
  UCHAR Length;      // offset: 0x1 ordinal: 0x1
  USHORT Flags;      // offset: 0x2 ordinal: 0x2
  ULONG ProcessorID; // offset: 0x4 ordinal: 0x3
  UCHAR LINTIN;      // offset: 0x8 ordinal: 0x4
  UCHAR Reserved[3]; // offset: 0x9 ordinal: 0x5
} _LOCAL_X2APIC_NMISOURCE;

// 0x11 bytes (sizeof)
typedef struct _PROCLOCALSAPIC {
  UCHAR Type;                     // offset: 0x0 ordinal: 0x0
  UCHAR Length;                   // offset: 0x1 ordinal: 0x1
  UCHAR ACPIProcessorID;          // offset: 0x2 ordinal: 0x2
  UCHAR APICID;                   // offset: 0x3 ordinal: 0x3
  UCHAR APICEID;                  // offset: 0x4 ordinal: 0x4
  UCHAR Reserved[3];              // offset: 0x5 ordinal: 0x5
  ULONG Flags;                    // offset: 0x8 ordinal: 0x6
  ULONG ACPIProcessorUIDInteger;  // offset: 0xc ordinal: 0x7
  CHAR ACPIProcessorUIDString[1]; // offset: 0x10 ordinal: 0x8
} _PROCLOCALSAPIC;

// 0x8 bytes (sizeof)
typedef struct _INTERRUPT_LINE {
  ULONG UnitId; // offset: 0x0 ordinal: 0x0
  LONG Line;    // offset: 0x4 ordinal: 0x1
} _INTERRUPT_LINE;

typedef LONG (*__anon_1410)(VOID *, struct _INTERRUPT_LINE *, UCHAR *, UCHAR *);

typedef LONG (*__anon_1405)(VOID *, ULONG, VOID *, ULONG);

// 0x10 bytes (sizeof)
typedef struct _SECONDARY_INTERRUPT_LINE_STATE {
  enum _KINTERRUPT_POLARITY Polarity; // offset: 0x0 ordinal: 0x0
  enum _KINTERRUPT_MODE Mode;         // offset: 0x4 ordinal: 0x1
  ULONG Vector;                       // offset: 0x8 ordinal: 0x2
  UCHAR Unmasked;                     // offset: 0xc ordinal: 0x3
} _SECONDARY_INTERRUPT_LINE_STATE;

// 0x4 bytes (sizeof)
typedef union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
  ULONG Primary : 1;              // offset: 0x0 ordinal: 0x0
  ULONG ContainmentWarning : 1;   // offset: 0x0 ordinal: 0x1
  ULONG Reset : 1;                // offset: 0x0 ordinal: 0x2
  ULONG ThresholdExceeded : 1;    // offset: 0x0 ordinal: 0x3
  ULONG ResourceNotAvailable : 1; // offset: 0x0 ordinal: 0x4
  ULONG LatentError : 1;          // offset: 0x0 ordinal: 0x5
  ULONG Propagated : 1;           // offset: 0x0 ordinal: 0x6
  ULONG FruTextByPlugin : 1;      // offset: 0x0 ordinal: 0x7
  ULONG Reserved : 24;            // offset: 0x0 ordinal: 0x8
  ULONG AsULONG;                  // offset: 0x0 ordinal: 0x9
} _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS;

// 0x4 bytes (sizeof)
typedef union _WHEA_ERROR_RECORD_HEADER_FLAGS {
  ULONG Recovered : 1;          // offset: 0x0 ordinal: 0x0
  ULONG PreviousError : 1;      // offset: 0x0 ordinal: 0x1
  ULONG Simulated : 1;          // offset: 0x0 ordinal: 0x2
  ULONG DeviceDriver : 1;       // offset: 0x0 ordinal: 0x3
  ULONG CriticalEvent : 1;      // offset: 0x0 ordinal: 0x4
  ULONG PersistPfn : 1;         // offset: 0x0 ordinal: 0x5
  ULONG SectionsTruncated : 1;  // offset: 0x0 ordinal: 0x6
  ULONG RecoveryInProgress : 1; // offset: 0x0 ordinal: 0x7
  ULONG Throttle : 1;           // offset: 0x0 ordinal: 0x8
  ULONG Reserved : 23;          // offset: 0x0 ordinal: 0x9
  ULONG AsULONG;                // offset: 0x0 ordinal: 0xa
} _WHEA_ERROR_RECORD_HEADER_FLAGS;

// 0x4 bytes (sizeof)
typedef union _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
  ULONG PlatformId : 1;  // offset: 0x0 ordinal: 0x0
  ULONG Timestamp : 1;   // offset: 0x0 ordinal: 0x1
  ULONG PartitionId : 1; // offset: 0x0 ordinal: 0x2
  ULONG Reserved : 29;   // offset: 0x0 ordinal: 0x3
  ULONG AsULONG;         // offset: 0x0 ordinal: 0x4
} _WHEA_ERROR_RECORD_HEADER_VALIDBITS;

// 0x4 bytes (sizeof)
typedef union _WHEA_ERROR_PACKET_FLAGS {
  ULONG PreviousError : 1;               // offset: 0x0 ordinal: 0x0
  ULONG CriticalEvent : 1;               // offset: 0x0 ordinal: 0x1
  ULONG HypervisorError : 1;             // offset: 0x0 ordinal: 0x2
  ULONG Simulated : 1;                   // offset: 0x0 ordinal: 0x3
  ULONG PlatformPfaControl : 1;          // offset: 0x0 ordinal: 0x4
  ULONG PlatformDirectedOffline : 1;     // offset: 0x0 ordinal: 0x5
  ULONG AddressTranslationRequired : 1;  // offset: 0x0 ordinal: 0x6
  ULONG AddressTranslationCompleted : 1; // offset: 0x0 ordinal: 0x7
  ULONG RecoveryOptional : 1;            // offset: 0x0 ordinal: 0x8
  ULONG Reserved2 : 23;                  // offset: 0x0 ordinal: 0x9
  ULONG AsULONG;                         // offset: 0x0 ordinal: 0xa
} _WHEA_ERROR_PACKET_FLAGS;

// 0x4 bytes (sizeof)
typedef union _WHEA_EVENT_LOG_ENTRY_FLAGS {
  ULONG Reserved1 : 1;      // offset: 0x0 ordinal: 0x0
  ULONG LogInternalEtw : 1; // offset: 0x0 ordinal: 0x1
  ULONG LogBlackbox : 1;    // offset: 0x0 ordinal: 0x2
  ULONG LogSel : 1;         // offset: 0x0 ordinal: 0x3
  ULONG RawSel : 1;         // offset: 0x0 ordinal: 0x4
  ULONG NoFormat : 1;       // offset: 0x0 ordinal: 0x5
  ULONG Driver : 1;         // offset: 0x0 ordinal: 0x6
  ULONG Reserved2 : 25;     // offset: 0x0 ordinal: 0x7
  ULONG AsULONG;            // offset: 0x0 ordinal: 0x8
} _WHEA_EVENT_LOG_ENTRY_FLAGS;

// 0x20 bytes (sizeof)
typedef struct _WHEA_EVENT_LOG_ENTRY_HEADER {
  ULONG Signature;                         // offset: 0x0 ordinal: 0x0
  ULONG Version;                           // offset: 0x4 ordinal: 0x1
  ULONG Length;                            // offset: 0x8 ordinal: 0x2
  enum _WHEA_EVENT_LOG_ENTRY_TYPE Type;    // offset: 0xc ordinal: 0x3
  ULONG OwnerTag;                          // offset: 0x10 ordinal: 0x4
  enum _WHEA_EVENT_LOG_ENTRY_ID Id;        // offset: 0x14 ordinal: 0x5
  union _WHEA_EVENT_LOG_ENTRY_FLAGS Flags; // offset: 0x18 ordinal: 0x6
  ULONG PayloadLength;                     // offset: 0x1c ordinal: 0x7
} _WHEA_EVENT_LOG_ENTRY_HEADER;

// 0x20 bytes (sizeof)
typedef struct _WHEA_EVENT_LOG_ENTRY {
  struct _WHEA_EVENT_LOG_ENTRY_HEADER Header; // offset: 0x0 ordinal: 0x0
} _WHEA_EVENT_LOG_ENTRY;

typedef LONG (*__anon_1337)(VOID *, ULONG);

// 0x4 bytes (sizeof)
typedef struct __anon_1336 {
  ULONG DeviceNumber : 5;   // offset: 0x0 ordinal: 0x0
  ULONG FunctionNumber : 3; // offset: 0x0 ordinal: 0x1
  ULONG Reserved : 24;      // offset: 0x0 ordinal: 0x2
} __anon_1336;

// 0x18 bytes (sizeof)
typedef struct __anon_1335 {
  ULONG PollInterval;             // offset: 0x0 ordinal: 0x0
  ULONG Vector;                   // offset: 0x4 ordinal: 0x1
  ULONG SwitchToPollingThreshold; // offset: 0x8 ordinal: 0x2
  ULONG SwitchToPollingWindow;    // offset: 0xc ordinal: 0x3
  ULONG ErrorThreshold;           // offset: 0x10 ordinal: 0x4
  ULONG ErrorThresholdWindow;     // offset: 0x14 ordinal: 0x5
} __anon_1335;

// 0x4 bytes (sizeof)
typedef struct __anon_1334 {
  ULONG PollInterval; // offset: 0x0 ordinal: 0x0
} __anon_1334;

// 0x18 bytes (sizeof)
typedef union __anon_1329 {
  struct __anon_1334 Polled;         // offset: 0x0 ordinal: 0x0
  struct __anon_1335 Interrupt;      // offset: 0x0 ordinal: 0x1
  struct __anon_1335 LocalInterrupt; // offset: 0x0 ordinal: 0x2
  struct __anon_1335 Sci;            // offset: 0x0 ordinal: 0x3
  struct __anon_1335 Nmi;            // offset: 0x0 ordinal: 0x4
  struct __anon_1335 Sea;            // offset: 0x0 ordinal: 0x5
  struct __anon_1335 Sei;            // offset: 0x0 ordinal: 0x6
  struct __anon_1335 Gsiv;           // offset: 0x0 ordinal: 0x7
} __anon_1329;

// 0x1c bytes (sizeof)
typedef struct _WHEA_NOTIFICATION_DESCRIPTOR {
  UCHAR Type;                           // offset: 0x0 ordinal: 0x0
  UCHAR Length;                         // offset: 0x1 ordinal: 0x1
  union _WHEA_NOTIFICATION_FLAGS Flags; // offset: 0x2 ordinal: 0x2
  union __anon_1329 u;                  // offset: 0x4 ordinal: 0x3
} _WHEA_NOTIFICATION_DESCRIPTOR;

// 0x4 bytes (sizeof)
typedef union __anon_1330 {
  struct __anon_1336 bits; // offset: 0x0 ordinal: 0x0
  ULONG AsULONG;           // offset: 0x0 ordinal: 0x1
} __anon_1330;

// 0x4 bytes (sizeof)
typedef struct _PCI_SLOT_NUMBER {
  union __anon_1330 u; // offset: 0x0 ordinal: 0x0
} _PCI_SLOT_NUMBER;

// 0x4 bytes (sizeof)
typedef struct _WHEA_PCI_SLOT_NUMBER {
  union __anon_1330 u; // offset: 0x0 ordinal: 0x0
} _WHEA_PCI_SLOT_NUMBER;

// 0x4 bytes (sizeof)
typedef union _XPF_MCE_FLAGS {
  ULONG MCG_CapabilityRW : 1;    // offset: 0x0 ordinal: 0x0
  ULONG MCG_GlobalControlRW : 1; // offset: 0x0 ordinal: 0x1
  ULONG Reserved : 30;           // offset: 0x0 ordinal: 0x2
  ULONG AsULONG;                 // offset: 0x0 ordinal: 0x3
} _XPF_MCE_FLAGS;

// 0x2c bytes (sizeof)
typedef struct _WHEA_AER_BRIDGE_DESCRIPTOR {
  USHORT Type;                              // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;                            // offset: 0x2 ordinal: 0x1
  UCHAR Reserved;                           // offset: 0x3 ordinal: 0x2
  ULONG BusNumber;                          // offset: 0x4 ordinal: 0x3
  struct _WHEA_PCI_SLOT_NUMBER Slot;        // offset: 0x8 ordinal: 0x4
  USHORT DeviceControl;                     // offset: 0xc ordinal: 0x5
  union _AER_BRIDGE_DESCRIPTOR_FLAGS Flags; // offset: 0xe ordinal: 0x6
  ULONG UncorrectableErrorMask;             // offset: 0x10 ordinal: 0x7
  ULONG UncorrectableErrorSeverity;         // offset: 0x14 ordinal: 0x8
  ULONG CorrectableErrorMask;               // offset: 0x18 ordinal: 0x9
  ULONG AdvancedCapsAndControl;             // offset: 0x1c ordinal: 0xa
  ULONG SecondaryUncorrectableErrorMask;    // offset: 0x20 ordinal: 0xb
  ULONG SecondaryUncorrectableErrorSev;     // offset: 0x24 ordinal: 0xc
  ULONG SecondaryCapsAndControl;            // offset: 0x28 ordinal: 0xd
} _WHEA_AER_BRIDGE_DESCRIPTOR;

// 0x20 bytes (sizeof)
typedef struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
  USHORT Type;                                // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;                              // offset: 0x2 ordinal: 0x1
  UCHAR Reserved;                             // offset: 0x3 ordinal: 0x2
  ULONG BusNumber;                            // offset: 0x4 ordinal: 0x3
  struct _WHEA_PCI_SLOT_NUMBER Slot;          // offset: 0x8 ordinal: 0x4
  USHORT DeviceControl;                       // offset: 0xc ordinal: 0x5
  union _AER_ENDPOINT_DESCRIPTOR_FLAGS Flags; // offset: 0xe ordinal: 0x6
  ULONG UncorrectableErrorMask;               // offset: 0x10 ordinal: 0x7
  ULONG UncorrectableErrorSeverity;           // offset: 0x14 ordinal: 0x8
  ULONG CorrectableErrorMask;                 // offset: 0x18 ordinal: 0x9
  ULONG AdvancedCapsAndControl;               // offset: 0x1c ordinal: 0xa
} _WHEA_AER_ENDPOINT_DESCRIPTOR;

// 0x24 bytes (sizeof)
typedef struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
  USHORT Type;                                // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;                              // offset: 0x2 ordinal: 0x1
  UCHAR Reserved;                             // offset: 0x3 ordinal: 0x2
  ULONG BusNumber;                            // offset: 0x4 ordinal: 0x3
  struct _WHEA_PCI_SLOT_NUMBER Slot;          // offset: 0x8 ordinal: 0x4
  USHORT DeviceControl;                       // offset: 0xc ordinal: 0x5
  union _AER_ROOTPORT_DESCRIPTOR_FLAGS Flags; // offset: 0xe ordinal: 0x6
  ULONG UncorrectableErrorMask;               // offset: 0x10 ordinal: 0x7
  ULONG UncorrectableErrorSeverity;           // offset: 0x14 ordinal: 0x8
  ULONG CorrectableErrorMask;                 // offset: 0x18 ordinal: 0x9
  ULONG AdvancedCapsAndControl;               // offset: 0x1c ordinal: 0xa
  ULONG RootErrorCommand;                     // offset: 0x20 ordinal: 0xb
} _WHEA_AER_ROOTPORT_DESCRIPTOR;

// 0x18 bytes (sizeof)
typedef struct _ECP_LIST {
  ULONG Signature;            // offset: 0x0 ordinal: 0x0
  ULONG Flags;                // offset: 0x4 ordinal: 0x1
  struct _LIST_ENTRY EcpList; // offset: 0x8 ordinal: 0x2
} _ECP_LIST;

// 0x28 bytes (sizeof)
typedef struct _IO_DRIVER_CREATE_CONTEXT {
  SHORT Size;                                 // offset: 0x0 ordinal: 0x0
  struct _ECP_LIST *ExtraCreateParameter;     // offset: 0x8 ordinal: 0x1
  VOID *DeviceObjectHint;                     // offset: 0x10 ordinal: 0x2
  struct _TXN_PARAMETER_BLOCK *TxnParameters; // offset: 0x18 ordinal: 0x3
  struct _EJOB *SiloContext;                  // offset: 0x20 ordinal: 0x4
} _IO_DRIVER_CREATE_CONTEXT;

// 0x4 bytes (sizeof)
typedef struct __anon_1294 {
  ULONG BaseMiddle : 8;  // offset: 0x0 ordinal: 0x0
  ULONG Type : 5;        // offset: 0x0 ordinal: 0x1
  ULONG Dpl : 2;         // offset: 0x0 ordinal: 0x2
  ULONG Present : 1;     // offset: 0x0 ordinal: 0x3
  ULONG LimitHigh : 4;   // offset: 0x0 ordinal: 0x4
  ULONG System : 1;      // offset: 0x0 ordinal: 0x5
  ULONG LongMode : 1;    // offset: 0x0 ordinal: 0x6
  ULONG DefaultBig : 1;  // offset: 0x0 ordinal: 0x7
  ULONG Granularity : 1; // offset: 0x0 ordinal: 0x8
  ULONG BaseHigh : 8;    // offset: 0x0 ordinal: 0x9
} __anon_1294;

// 0x10 bytes (sizeof)
typedef union _KGDTENTRY64 {
  USHORT LimitLow;          // offset: 0x0 ordinal: 0x0
  USHORT BaseLow;           // offset: 0x2 ordinal: 0x1
  struct __anon_1293 Bytes; // offset: 0x4 ordinal: 0x2
  struct __anon_1294 Bits;  // offset: 0x4 ordinal: 0x3
  ULONG BaseUpper;          // offset: 0x8 ordinal: 0x4
  ULONG MustBeZero;         // offset: 0xc ordinal: 0x5
  LONGLONG DataLow;         // offset: 0x0 ordinal: 0x6
  LONGLONG DataHigh;        // offset: 0x8 ordinal: 0x7
} _KGDTENTRY64;

// 0x54 bytes (sizeof)
typedef struct _RTL_RETPOLINE_ROUTINES {
  ULONG UnwindDataOffset;    // offset: 0x0 ordinal: 0x0
  ULONG SwitchtableJump[16]; // offset: 0x4 ordinal: 0x1
  ULONG CfgIndirectRax;      // offset: 0x44 ordinal: 0x2
  ULONG NonCfgIndirectRax;   // offset: 0x48 ordinal: 0x3
  ULONG ImportR10;           // offset: 0x4c ordinal: 0x4
  ULONG JumpHpat;            // offset: 0x50 ordinal: 0x5
} _RTL_RETPOLINE_ROUTINES;

// 0x50 bytes (sizeof)
typedef struct _EXCEPTION_RECORD32 {
  LONG ExceptionCode;             // offset: 0x0 ordinal: 0x0
  ULONG ExceptionFlags;           // offset: 0x4 ordinal: 0x1
  ULONG ExceptionRecord;          // offset: 0x8 ordinal: 0x2
  ULONG ExceptionAddress;         // offset: 0xc ordinal: 0x3
  ULONG NumberParameters;         // offset: 0x10 ordinal: 0x4
  ULONG ExceptionInformation[15]; // offset: 0x14 ordinal: 0x5
} _EXCEPTION_RECORD32;

// 0x54 bytes (sizeof)
typedef struct _DBGKM_EXCEPTION32 {
  struct _EXCEPTION_RECORD32 ExceptionRecord; // offset: 0x0 ordinal: 0x0
  ULONG FirstChance;                          // offset: 0x50 ordinal: 0x1
} _DBGKM_EXCEPTION32;

// 0x38 bytes (sizeof)
typedef struct _NT_TIB {
  struct _EXCEPTION_REGISTRATION_RECORD
      *ExceptionList; // offset: 0x0 ordinal: 0x0
  VOID *StackBase;    // offset: 0x8 ordinal: 0x1
  VOID *StackLimit;   // offset: 0x10 ordinal: 0x2
  VOID *SubSystemTib; // offset: 0x18 ordinal: 0x3
  union {
    VOID *FiberData; // offset: 0x20 ordinal: 0x4
    ULONG Version;   // offset: 0x20 ordinal: 0x5
  };
  VOID *ArbitraryUserPointer; // offset: 0x28 ordinal: 0x6
  struct _NT_TIB *Self;       // offset: 0x30 ordinal: 0x7
} _NT_TIB;

// 0x10 bytes (sizeof)
typedef struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
  ULONG Size;       // offset: 0x0 ordinal: 0x0
  WCHAR *TriggerId; // offset: 0x8 ordinal: 0x1
} _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;

// 0xc bytes (sizeof)
typedef struct __anon_1253 {
  ULONG DataSize;  // offset: 0x0 ordinal: 0x0
  ULONG Reserved1; // offset: 0x4 ordinal: 0x1
  ULONG Reserved2; // offset: 0x8 ordinal: 0x2
} __anon_1253;

// 0xc bytes (sizeof)
typedef struct __anon_1252 {
  ULONG Start;    // offset: 0x0 ordinal: 0x0
  ULONG Length;   // offset: 0x4 ordinal: 0x1
  ULONG Reserved; // offset: 0x8 ordinal: 0x2
} __anon_1252;

// 0xc bytes (sizeof)
typedef struct __anon_1251 {
  ULONG Channel;       // offset: 0x0 ordinal: 0x0
  ULONG RequestLine;   // offset: 0x4 ordinal: 0x1
  UCHAR TransferWidth; // offset: 0x8 ordinal: 0x2
  UCHAR Reserved1;     // offset: 0x9 ordinal: 0x3
  UCHAR Reserved2;     // offset: 0xa ordinal: 0x4
  UCHAR Reserved3;     // offset: 0xb ordinal: 0x5
} __anon_1251;

// 0xc bytes (sizeof)
typedef struct __anon_1250 {
  ULONG Channel;   // offset: 0x0 ordinal: 0x0
  ULONG Port;      // offset: 0x4 ordinal: 0x1
  ULONG Reserved1; // offset: 0x8 ordinal: 0x2
} __anon_1250;

// 0x10 bytes (sizeof)
typedef struct _FS_FILTER_SECTION_SYNC_OUTPUT {
  ULONG StructureSize;        // offset: 0x0 ordinal: 0x0
  ULONG SizeReturned;         // offset: 0x4 ordinal: 0x1
  ULONG Flags;                // offset: 0x8 ordinal: 0x2
  ULONG DesiredReadAlignment; // offset: 0xc ordinal: 0x3
} _FS_FILTER_SECTION_SYNC_OUTPUT;

// 0x18 bytes (sizeof)
typedef struct _DEVICE_OBJECT_LIST_ENTRY {
  struct _DEVICE_OBJECT *DeviceObject;       // offset: 0x0 ordinal: 0x0
  enum _DEVICE_RELATION_LEVEL RelationLevel; // offset: 0x8 ordinal: 0x1
  ULONG Ordinal;                             // offset: 0xc ordinal: 0x2
  ULONG Flags;                               // offset: 0x10 ordinal: 0x3
} _DEVICE_OBJECT_LIST_ENTRY;

// 0xc bytes (sizeof)
typedef struct __anon_1224 {
  UCHAR Class;      // offset: 0x0 ordinal: 0x0
  UCHAR Type;       // offset: 0x1 ordinal: 0x1
  UCHAR Reserved1;  // offset: 0x2 ordinal: 0x2
  UCHAR Reserved2;  // offset: 0x3 ordinal: 0x3
  ULONG IdLowPart;  // offset: 0x4 ordinal: 0x4
  ULONG IdHighPart; // offset: 0x8 ordinal: 0x5
} __anon_1224;

// 0xc bytes (sizeof)
typedef struct __anon_1220 {
  ULONG Priority;  // offset: 0x0 ordinal: 0x0
  ULONG Reserved1; // offset: 0x4 ordinal: 0x1
  ULONG Reserved2; // offset: 0x8 ordinal: 0x2
} __anon_1220;

// 0x10 bytes (sizeof)
typedef struct __anon_1219 {
  ULONG Length;       // offset: 0x0 ordinal: 0x0
  ULONG MinBusNumber; // offset: 0x4 ordinal: 0x1
  ULONG MaxBusNumber; // offset: 0x8 ordinal: 0x2
  ULONG Reserved;     // offset: 0xc ordinal: 0x3
} __anon_1219;

// 0x10 bytes (sizeof)
typedef struct __anon_1217 {
  ULONG RequestLine;   // offset: 0x0 ordinal: 0x0
  ULONG Reserved;      // offset: 0x4 ordinal: 0x1
  ULONG Channel;       // offset: 0x8 ordinal: 0x2
  ULONG TransferWidth; // offset: 0xc ordinal: 0x3
} __anon_1217;

// 0x8 bytes (sizeof)
typedef struct __anon_1216 {
  ULONG MinimumChannel; // offset: 0x0 ordinal: 0x0
  ULONG MaximumChannel; // offset: 0x4 ordinal: 0x1
} __anon_1216;

// 0x8 bytes (sizeof)
typedef struct __anon_1207 {
  ULONG NotificationCode; // offset: 0x0 ordinal: 0x0
  ULONG NotificationData; // offset: 0x4 ordinal: 0x1
} __anon_1207;

// 0x18 bytes (sizeof)
typedef struct __anon_1187 {
  enum _FS_FILTER_SECTION_SYNC_TYPE SyncType; // offset: 0x0 ordinal: 0x0
  ULONG PageProtection;                       // offset: 0x4 ordinal: 0x1
  struct _FS_FILTER_SECTION_SYNC_OUTPUT
      *OutputInformation;     // offset: 0x8 ordinal: 0x2
  ULONG Flags;                // offset: 0x10 ordinal: 0x3
  ULONG AllocationAttributes; // offset: 0x14 ordinal: 0x4
} __anon_1187;

typedef ULONG (*__anon_1182)(VOID *);

typedef ULONG (*__anon_1181)(VOID *, enum PROFILE_DEPARTURE_STYLE);

// 0x30 bytes (sizeof)
typedef struct DOCK_INTERFACE {
  USHORT Size;                          // offset: 0x0 ordinal: 0x0
  USHORT Version;                       // offset: 0x2 ordinal: 0x1
  VOID *Context;                        // offset: 0x8 ordinal: 0x2
  VOID (*InterfaceReference)(VOID *);   // offset: 0x10 ordinal: 0x3
  VOID (*InterfaceDereference)(VOID *); // offset: 0x18 ordinal: 0x4
  ULONG(*ProfileDepartureSetMode)
  (VOID *, enum PROFILE_DEPARTURE_STYLE);  // offset: 0x20 ordinal: 0x5
  ULONG (*ProfileDepartureUpdate)(VOID *); // offset: 0x28 ordinal: 0x6
} DOCK_INTERFACE;

// 0x28 bytes (sizeof)
typedef struct _DEVICE_OBJECT_LIST {
  ULONG Count;                                 // offset: 0x0 ordinal: 0x0
  ULONG MaxCount;                              // offset: 0x4 ordinal: 0x1
  ULONG TagCount;                              // offset: 0x8 ordinal: 0x2
  enum _PNP_DEVICE_DELETE_TYPE OperationCode;  // offset: 0xc ordinal: 0x3
  struct _DEVICE_OBJECT_LIST_ENTRY Devices[1]; // offset: 0x10 ordinal: 0x4
} _DEVICE_OBJECT_LIST;

// 0x10 bytes (sizeof)
typedef struct _RELATION_LIST {
  struct _DEVICE_OBJECT_LIST *DeviceObjectList; // offset: 0x0 ordinal: 0x0
  UCHAR Sorted;                                 // offset: 0x8 ordinal: 0x1
} _RELATION_LIST;

// 0x10 bytes (sizeof)
typedef struct _NT_IORING_OP_FLUSH {
  enum _NT_IORING_OP_FLAGS CommonOpFlags; // offset: 0x0 ordinal: 0x0
  ULONG Flags;                            // offset: 0x4 ordinal: 0x1
  union _NT_IORING_HANDLEREF File;        // offset: 0x8 ordinal: 0x2
} _NT_IORING_OP_FLUSH;

typedef VOID (*__anon_1153)(VOID *, ULONG, UCHAR, VOID *);

// 0x18 bytes (sizeof)
typedef struct _OBJECT_DIRECTORY_ENTRY {
  struct _OBJECT_DIRECTORY_ENTRY *ChainLink; // offset: 0x0 ordinal: 0x0
  VOID *Object;                              // offset: 0x8 ordinal: 0x1
  ULONG HashValue;                           // offset: 0x10 ordinal: 0x2
} _OBJECT_DIRECTORY_ENTRY;

// 0xc bytes (sizeof)
typedef struct _POWER_SEQUENCE {
  ULONG SequenceD1; // offset: 0x0 ordinal: 0x0
  ULONG SequenceD2; // offset: 0x4 ordinal: 0x1
  ULONG SequenceD3; // offset: 0x8 ordinal: 0x2
} _POWER_SEQUENCE;

// 0x8 bytes (sizeof)
typedef struct __anon_1019 {
  struct _POWER_SEQUENCE *PowerSequence; // offset: 0x0 ordinal: 0x0
} __anon_1019;

// 0x40 bytes (sizeof)
typedef struct _DEVICE_CAPABILITIES {
  USHORT Size;                             // offset: 0x0 ordinal: 0x0
  USHORT Version;                          // offset: 0x2 ordinal: 0x1
  ULONG DeviceD1 : 1;                      // offset: 0x4 ordinal: 0x2
  ULONG DeviceD2 : 1;                      // offset: 0x4 ordinal: 0x3
  ULONG LockSupported : 1;                 // offset: 0x4 ordinal: 0x4
  ULONG EjectSupported : 1;                // offset: 0x4 ordinal: 0x5
  ULONG Removable : 1;                     // offset: 0x4 ordinal: 0x6
  ULONG DockDevice : 1;                    // offset: 0x4 ordinal: 0x7
  ULONG UniqueID : 1;                      // offset: 0x4 ordinal: 0x8
  ULONG SilentInstall : 1;                 // offset: 0x4 ordinal: 0x9
  ULONG RawDeviceOK : 1;                   // offset: 0x4 ordinal: 0xa
  ULONG SurpriseRemovalOK : 1;             // offset: 0x4 ordinal: 0xb
  ULONG WakeFromD0 : 1;                    // offset: 0x4 ordinal: 0xc
  ULONG WakeFromD1 : 1;                    // offset: 0x4 ordinal: 0xd
  ULONG WakeFromD2 : 1;                    // offset: 0x4 ordinal: 0xe
  ULONG WakeFromD3 : 1;                    // offset: 0x4 ordinal: 0xf
  ULONG HardwareDisabled : 1;              // offset: 0x4 ordinal: 0x10
  ULONG NonDynamic : 1;                    // offset: 0x4 ordinal: 0x11
  ULONG WarmEjectSupported : 1;            // offset: 0x4 ordinal: 0x12
  ULONG NoDisplayInUI : 1;                 // offset: 0x4 ordinal: 0x13
  ULONG Reserved1 : 1;                     // offset: 0x4 ordinal: 0x14
  ULONG WakeFromInterrupt : 1;             // offset: 0x4 ordinal: 0x15
  ULONG SecureDevice : 1;                  // offset: 0x4 ordinal: 0x16
  ULONG ChildOfVgaEnabledBridge : 1;       // offset: 0x4 ordinal: 0x17
  ULONG DecodeIoOnBoot : 1;                // offset: 0x4 ordinal: 0x18
  ULONG Reserved : 9;                      // offset: 0x4 ordinal: 0x19
  ULONG Address;                           // offset: 0x8 ordinal: 0x1a
  ULONG UINumber;                          // offset: 0xc ordinal: 0x1b
  enum _DEVICE_POWER_STATE DeviceState[7]; // offset: 0x10 ordinal: 0x1c
  enum _SYSTEM_POWER_STATE SystemWake;     // offset: 0x2c ordinal: 0x1d
  enum _DEVICE_POWER_STATE DeviceWake;     // offset: 0x30 ordinal: 0x1e
  ULONG D1Latency;                         // offset: 0x34 ordinal: 0x1f
  ULONG D2Latency;                         // offset: 0x38 ordinal: 0x20
  ULONG D3Latency;                         // offset: 0x3c ordinal: 0x21
} _DEVICE_CAPABILITIES;

// 0x8 bytes (sizeof)
typedef struct __anon_1011 {
  struct _DEVICE_CAPABILITIES *Capabilities; // offset: 0x0 ordinal: 0x0
} __anon_1011;

// 0x4 bytes (sizeof)
typedef struct __anon_1113 {
  ULONG RebalanceDueToDynamicPartitioning : 1; // offset: 0x0 ordinal: 0x0
  ULONG ResetDeviceWhileStopped : 1;           // offset: 0x0 ordinal: 0x1
  ULONG Reserved : 30;                         // offset: 0x0 ordinal: 0x2
} __anon_1113;

// 0x4 bytes (sizeof)
typedef struct _SYSTEM_POWER_STATE_CONTEXT {
  ULONG Reserved1 : 8;               // offset: 0x0 ordinal: 0x0
  ULONG TargetSystemState : 4;       // offset: 0x0 ordinal: 0x1
  ULONG EffectiveSystemState : 4;    // offset: 0x0 ordinal: 0x2
  ULONG CurrentSystemState : 4;      // offset: 0x0 ordinal: 0x3
  ULONG IgnoreHibernationPath : 1;   // offset: 0x0 ordinal: 0x4
  ULONG PseudoTransition : 1;        // offset: 0x0 ordinal: 0x5
  ULONG KernelSoftReboot : 1;        // offset: 0x0 ordinal: 0x6
  ULONG DirectedDripsTransition : 1; // offset: 0x0 ordinal: 0x7
  ULONG Reserved2 : 8;               // offset: 0x0 ordinal: 0x8
  ULONG ContextAsUlong;              // offset: 0x0 ordinal: 0x9
} _SYSTEM_POWER_STATE_CONTEXT;

// 0x8 bytes (sizeof)
typedef struct _POP_FX_DEPENDENT {
  ULONG Index;         // offset: 0x0 ordinal: 0x0
  ULONG ProviderIndex; // offset: 0x4 ordinal: 0x1
} _POP_FX_DEPENDENT;

// 0x8 bytes (sizeof)
typedef struct _POP_FX_PROVIDER {
  ULONG Index;      // offset: 0x0 ordinal: 0x0
  UCHAR Activating; // offset: 0x4 ordinal: 0x1
} _POP_FX_PROVIDER;

// 0x4 bytes (sizeof)
typedef union _PNP_REBALANCE_FLAGS {
  struct __anon_1113 u; // offset: 0x0 ordinal: 0x0
  ULONG AsUlong;        // offset: 0x0 ordinal: 0x1
} _PNP_REBALANCE_FLAGS;

// 0x10 bytes (sizeof)
typedef struct _DEVICE_RELATIONS {
  ULONG Count;                       // offset: 0x0 ordinal: 0x0
  struct _DEVICE_OBJECT *Objects[1]; // offset: 0x8 ordinal: 0x1
} _DEVICE_RELATIONS;

// 0x8 bytes (sizeof)
typedef union __anon_870 {
  struct _DEVICE_NODE *LegacyDeviceNode;            // offset: 0x0 ordinal: 0x0
  struct _DEVICE_RELATIONS *PendingDeviceRelations; // offset: 0x0 ordinal: 0x1
  VOID *Information;                                // offset: 0x0 ordinal: 0x2
} __anon_870;

// 0xe8 bytes (sizeof)
typedef struct _SYSTEM_POWER_POLICY {
  ULONG Revision;                               // offset: 0x0 ordinal: 0x0
  struct POWER_ACTION_POLICY PowerButton;       // offset: 0x4 ordinal: 0x1
  struct POWER_ACTION_POLICY SleepButton;       // offset: 0x10 ordinal: 0x2
  struct POWER_ACTION_POLICY LidClose;          // offset: 0x1c ordinal: 0x3
  enum _SYSTEM_POWER_STATE LidOpenWake;         // offset: 0x28 ordinal: 0x4
  ULONG Reserved;                               // offset: 0x2c ordinal: 0x5
  struct POWER_ACTION_POLICY Idle;              // offset: 0x30 ordinal: 0x6
  ULONG IdleTimeout;                            // offset: 0x3c ordinal: 0x7
  UCHAR IdleSensitivity;                        // offset: 0x40 ordinal: 0x8
  UCHAR DynamicThrottle;                        // offset: 0x41 ordinal: 0x9
  UCHAR Spare2[2];                              // offset: 0x42 ordinal: 0xa
  enum _SYSTEM_POWER_STATE MinSleep;            // offset: 0x44 ordinal: 0xb
  enum _SYSTEM_POWER_STATE MaxSleep;            // offset: 0x48 ordinal: 0xc
  enum _SYSTEM_POWER_STATE ReducedLatencySleep; // offset: 0x4c ordinal: 0xd
  ULONG WinLogonFlags;                          // offset: 0x50 ordinal: 0xe
  ULONG Spare3;                                 // offset: 0x54 ordinal: 0xf
  ULONG DozeS4Timeout;                          // offset: 0x58 ordinal: 0x10
  ULONG BroadcastCapacityResolution;            // offset: 0x5c ordinal: 0x11
  struct SYSTEM_POWER_LEVEL DischargePolicy[4]; // offset: 0x60 ordinal: 0x12
  ULONG VideoTimeout;                           // offset: 0xc0 ordinal: 0x13
  UCHAR VideoDimDisplay;                        // offset: 0xc4 ordinal: 0x14
  ULONG VideoReserved[3];                       // offset: 0xc8 ordinal: 0x15
  ULONG SpindownTimeout;                        // offset: 0xd4 ordinal: 0x16
  UCHAR OptimizeForPower;                       // offset: 0xd8 ordinal: 0x17
  UCHAR FanThrottleTolerance;                   // offset: 0xd9 ordinal: 0x18
  UCHAR ForcedThrottle;                         // offset: 0xda ordinal: 0x19
  UCHAR MinThrottle;                            // offset: 0xdb ordinal: 0x1a
  struct POWER_ACTION_POLICY OverThrottled;     // offset: 0xdc ordinal: 0x1b
} _SYSTEM_POWER_POLICY;

// 0x148 bytes (sizeof)
typedef struct _POP_POWER_SETTING_VALUES {
  ULONG StructureSize;                   // offset: 0x0 ordinal: 0x0
  struct _SYSTEM_POWER_POLICY PopPolicy; // offset: 0x4 ordinal: 0x1
  enum SYSTEM_POWER_CONDITION
      CurrentAcDcPowerState;           // offset: 0xec ordinal: 0x2
  UCHAR AwayModeEnabled;               // offset: 0xf0 ordinal: 0x3
  UCHAR AwayModeEngaged;               // offset: 0xf1 ordinal: 0x4
  UCHAR AwayModePolicyAllowed;         // offset: 0xf2 ordinal: 0x5
  LONG AwayModeIgnoreUserPresent;      // offset: 0xf4 ordinal: 0x6
  LONG AwayModeIgnoreAction;           // offset: 0xf8 ordinal: 0x7
  UCHAR DisableFastS4;                 // offset: 0xfc ordinal: 0x8
  UCHAR DisableStandbyStates;          // offset: 0xfd ordinal: 0x9
  ULONG UnattendSleepTimeout;          // offset: 0x100 ordinal: 0xa
  ULONG DiskIgnoreTime;                // offset: 0x104 ordinal: 0xb
  ULONG DeviceIdlePolicy;              // offset: 0x108 ordinal: 0xc
  ULONG VideoDimTimeout;               // offset: 0x10c ordinal: 0xd
  ULONG VideoNormalBrightness;         // offset: 0x110 ordinal: 0xe
  ULONG VideoDimBrightness;            // offset: 0x114 ordinal: 0xf
  ULONG AlsOffset;                     // offset: 0x118 ordinal: 0x10
  ULONG AlsEnabled;                    // offset: 0x11c ordinal: 0x11
  ULONG EsBrightness;                  // offset: 0x120 ordinal: 0x12
  UCHAR SwitchShutdownForced;          // offset: 0x124 ordinal: 0x13
  ULONG SystemCoolingPolicy;           // offset: 0x128 ordinal: 0x14
  UCHAR MediaBufferingEngaged;         // offset: 0x12c ordinal: 0x15
  UCHAR AudioActivity;                 // offset: 0x12d ordinal: 0x16
  UCHAR FullscreenVideoPlayback;       // offset: 0x12e ordinal: 0x17
  ULONG EsBatteryThreshold;            // offset: 0x130 ordinal: 0x18
  UCHAR EsAggressive;                  // offset: 0x134 ordinal: 0x19
  UCHAR EsUserAwaySetting;             // offset: 0x135 ordinal: 0x1a
  ULONG ConnectivityInStandby;         // offset: 0x138 ordinal: 0x1b
  ULONG DisconnectedStandbyMode;       // offset: 0x13c ordinal: 0x1c
  ULONG UserPresencePredictionEnabled; // offset: 0x140 ordinal: 0x1d
  UCHAR AirplaneModeEnabled;           // offset: 0x144 ordinal: 0x1e
  UCHAR BluetoothDeviceCharging;       // offset: 0x145 ordinal: 0x1f
} _POP_POWER_SETTING_VALUES;

// 0xc bytes (sizeof)
typedef struct __anon_1218 {
  ULONG Data[3]; // offset: 0x0 ordinal: 0x0
} __anon_1218;

// 0x4 bytes (sizeof)
typedef struct _TOKEN_MANDATORY_POLICY {
  ULONG Policy; // offset: 0x0 ordinal: 0x0
} _TOKEN_MANDATORY_POLICY;

// 0x20 bytes (sizeof)
typedef struct __anon_1020 {
  union {
    ULONG SystemContext; // offset: 0x0 ordinal: 0x0
    struct _SYSTEM_POWER_STATE_CONTEXT
        SystemPowerStateContext; // offset: 0x0 ordinal: 0x1
  };
  enum _POWER_STATE_TYPE Type;    // offset: 0x8 ordinal: 0x2
  union _POWER_STATE State;       // offset: 0x10 ordinal: 0x3
  enum POWER_ACTION ShutdownType; // offset: 0x18 ordinal: 0x4
} __anon_1020;

// 0x10 bytes (sizeof)
typedef struct __anon_1016 {
  enum DEVICE_TEXT_TYPE DeviceTextType; // offset: 0x0 ordinal: 0x0
  ULONG LocaleId;                       // offset: 0x8 ordinal: 0x1
} __anon_1016;

// 0x20 bytes (sizeof)
typedef struct __anon_1013 {
  ULONG WhichSpace; // offset: 0x0 ordinal: 0x0
  VOID *Buffer;     // offset: 0x8 ordinal: 0x1
  ULONG Offset;     // offset: 0x10 ordinal: 0x2
  ULONG Length;     // offset: 0x18 ordinal: 0x3
} __anon_1013;

// 0x10 bytes (sizeof)
typedef struct __anon_1005 {
  ULONG SecurityInformation; // offset: 0x0 ordinal: 0x0
  VOID *SecurityDescriptor;  // offset: 0x8 ordinal: 0x1
} __anon_1005;

// 0x10 bytes (sizeof)
typedef struct __anon_1004 {
  ULONG SecurityInformation; // offset: 0x0 ordinal: 0x0
  ULONG Length;              // offset: 0x8 ordinal: 0x1
} __anon_1004;

// 0x20 bytes (sizeof)
typedef struct __anon_1003 {
  ULONG OutputBufferLength; // offset: 0x0 ordinal: 0x0
  ULONG InputBufferLength;  // offset: 0x8 ordinal: 0x1
  ULONG IoControlCode;      // offset: 0x10 ordinal: 0x2
  VOID *Type3InputBuffer;   // offset: 0x18 ordinal: 0x3
} __anon_1003;

// 0x20 bytes (sizeof)
typedef struct __anon_1001 {
  ULONG OutputBufferLength; // offset: 0x0 ordinal: 0x0
  ULONG InputBufferLength;  // offset: 0x8 ordinal: 0x1
  ULONG FsControlCode;      // offset: 0x10 ordinal: 0x2
  VOID *Type3InputBuffer;   // offset: 0x18 ordinal: 0x3
} __anon_1001;

// 0x10 bytes (sizeof)
typedef struct __anon_1000 {
  ULONG Length;                         // offset: 0x0 ordinal: 0x0
  enum _FSINFOCLASS FsInformationClass; // offset: 0x8 ordinal: 0x1
} __anon_1000;

// 0x4 bytes (sizeof)
typedef struct __anon_999 {
  ULONG Length; // offset: 0x0 ordinal: 0x0
} __anon_999;

// 0x20 bytes (sizeof)
typedef struct __anon_998 {
  ULONG Length;       // offset: 0x0 ordinal: 0x0
  VOID *EaList;       // offset: 0x8 ordinal: 0x1
  ULONG EaListLength; // offset: 0x10 ordinal: 0x2
  ULONG EaIndex;      // offset: 0x18 ordinal: 0x3
} __anon_998;

// 0x20 bytes (sizeof)
typedef struct __anon_997 {
  ULONG Length;                                      // offset: 0x0 ordinal: 0x0
  enum _FILE_INFORMATION_CLASS FileInformationClass; // offset: 0x8 ordinal: 0x1
  struct _FILE_OBJECT *FileObject; // offset: 0x10 ordinal: 0x2
  UCHAR ReplaceIfExists;           // offset: 0x18 ordinal: 0x3
  UCHAR AdvanceOnly;               // offset: 0x19 ordinal: 0x4
  union {
    ULONG ClusterCount; // offset: 0x18 ordinal: 0x5
    VOID *DeleteHandle; // offset: 0x18 ordinal: 0x6
  };
} __anon_997;

// 0x10 bytes (sizeof)
typedef struct __anon_996 {
  ULONG Length;                                      // offset: 0x0 ordinal: 0x0
  enum _FILE_INFORMATION_CLASS FileInformationClass; // offset: 0x8 ordinal: 0x1
} __anon_996;

// 0x18 bytes (sizeof)
typedef struct __anon_995 {
  ULONG Length;           // offset: 0x0 ordinal: 0x0
  ULONG CompletionFilter; // offset: 0x8 ordinal: 0x1
  enum _DIRECTORY_NOTIFY_INFORMATION_CLASS
      DirectoryNotifyInformationClass; // offset: 0x10 ordinal: 0x2
} __anon_995;

// 0x10 bytes (sizeof)
typedef struct __anon_994 {
  ULONG Length;           // offset: 0x0 ordinal: 0x0
  ULONG CompletionFilter; // offset: 0x8 ordinal: 0x1
} __anon_994;

// 0x20 bytes (sizeof)
typedef struct __anon_993 {
  ULONG Length;                     // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING *FileName; // offset: 0x8 ordinal: 0x1
  enum _FILE_INFORMATION_CLASS
      FileInformationClass; // offset: 0x10 ordinal: 0x2
  ULONG FileIndex;          // offset: 0x18 ordinal: 0x3
} __anon_993;

// 0x8 bytes (sizeof)
typedef struct _PO_POWER_PLANE_PROFILE {
  ULONG ExclusivePowerMw; // offset: 0x0 ordinal: 0x0
  ULONG PeakPowerMw;      // offset: 0x4 ordinal: 0x1
} _PO_POWER_PLANE_PROFILE;

// 0x10 bytes (sizeof)
typedef struct _PEP_WORK_ACPI_NOTIFY {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  ULONG NotifyCode;                // offset: 0x8 ordinal: 0x1
} _PEP_WORK_ACPI_NOTIFY;

// 0x10 bytes (sizeof)
typedef struct _PEP_WORK_COMPLETE_PERF_STATE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  ULONG Component;                 // offset: 0x8 ordinal: 0x1
  UCHAR Succeeded;                 // offset: 0xc ordinal: 0x2
} _PEP_WORK_COMPLETE_PERF_STATE;

// 0x10 bytes (sizeof)
typedef struct _PEP_WORK_COMPLETE_IDLE_STATE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  ULONG Component;                 // offset: 0x8 ordinal: 0x1
} _PEP_WORK_COMPLETE_IDLE_STATE;

// 0x10 bytes (sizeof)
typedef struct _PEP_WORK_IDLE_STATE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  ULONG Component;                 // offset: 0x8 ordinal: 0x1
  ULONG State;                     // offset: 0xc ordinal: 0x2
} _PEP_WORK_IDLE_STATE;

// 0x10 bytes (sizeof)
typedef struct _PEP_WORK_ACTIVE_COMPLETE {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  ULONG Component;                 // offset: 0x8 ordinal: 0x1
} _PEP_WORK_ACTIVE_COMPLETE;

typedef UCHAR (*__anon_955)(struct PEPHANDLE__ *, ULONG, VOID *);

typedef UCHAR (*__anon_954)(ULONG, VOID *);

// 0x70 bytes (sizeof)
typedef struct _PENDING_RELATIONS_LIST_ENTRY {
  struct _LIST_ENTRY Link;                     // offset: 0x0 ordinal: 0x0
  struct _WORK_QUEUE_ITEM WorkItem;            // offset: 0x10 ordinal: 0x1
  struct _PNP_DEVICE_EVENT_ENTRY *DeviceEvent; // offset: 0x30 ordinal: 0x2
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x38 ordinal: 0x3
  struct _RELATION_LIST *RelationsList;        // offset: 0x40 ordinal: 0x4
  struct _IRP *EjectIrp;                       // offset: 0x48 ordinal: 0x5
  enum IRPLOCK Lock;                           // offset: 0x50 ordinal: 0x6
  ULONG Problem;                               // offset: 0x54 ordinal: 0x7
  UCHAR ProfileChangingEject;                  // offset: 0x58 ordinal: 0x8
  UCHAR DisplaySafeRemovalDialog;              // offset: 0x59 ordinal: 0x9
  enum _SYSTEM_POWER_STATE LightestSleepState; // offset: 0x5c ordinal: 0xa
  struct DOCK_INTERFACE *DockInterface;        // offset: 0x60 ordinal: 0xb
  UCHAR DequeuePending;                        // offset: 0x68 ordinal: 0xc
  enum _PNP_DEVICE_DELETE_TYPE DeleteType;     // offset: 0x6c ordinal: 0xd
} _PENDING_RELATIONS_LIST_ENTRY;

// 0x14 bytes (sizeof)
typedef struct _ETW_LBR_SUPPORT {
  ULONG LbrHandle;   // offset: 0x0 ordinal: 0x0
  ULONG LbrOptions;  // offset: 0x4 ordinal: 0x1
  ULONG HookIdCount; // offset: 0x8 ordinal: 0x2
  USHORT HookId[4];  // offset: 0xc ordinal: 0x3
} _ETW_LBR_SUPPORT;

// 0xc bytes (sizeof)
typedef struct _SECURITY_QUALITY_OF_SERVICE {
  ULONG Length; // offset: 0x0 ordinal: 0x0
  enum _SECURITY_IMPERSONATION_LEVEL
      ImpersonationLevel;    // offset: 0x4 ordinal: 0x1
  UCHAR ContextTrackingMode; // offset: 0x8 ordinal: 0x2
  UCHAR EffectiveOnly;       // offset: 0x9 ordinal: 0x3
} _SECURITY_QUALITY_OF_SERVICE;

// 0x40 bytes (sizeof)
typedef struct _OBJECT_CREATE_INFORMATION {
  ULONG Attributes;                                 // offset: 0x0 ordinal: 0x0
  VOID *RootDirectory;                              // offset: 0x8 ordinal: 0x1
  CHAR ProbeMode;                                   // offset: 0x10 ordinal: 0x2
  ULONG PagedPoolCharge;                            // offset: 0x14 ordinal: 0x3
  ULONG NonPagedPoolCharge;                         // offset: 0x18 ordinal: 0x4
  ULONG SecurityDescriptorCharge;                   // offset: 0x1c ordinal: 0x5
  VOID *SecurityDescriptor;                         // offset: 0x20 ordinal: 0x6
  struct _SECURITY_QUALITY_OF_SERVICE *SecurityQos; // offset: 0x28 ordinal: 0x7
  struct _SECURITY_QUALITY_OF_SERVICE
      SecurityQualityOfService; // offset: 0x30 ordinal: 0x8
} _OBJECT_CREATE_INFORMATION;

// 0x30 bytes (sizeof)
typedef struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION {
  ULONG SecurityAttributeCount;                     // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY SecurityAttributesList;        // offset: 0x8 ordinal: 0x1
  ULONG WorkingSecurityAttributeCount;              // offset: 0x18 ordinal: 0x2
  struct _LIST_ENTRY WorkingSecurityAttributesList; // offset: 0x20 ordinal: 0x3
} _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION;

// 0x10 bytes (sizeof)
typedef struct _SID_AND_ATTRIBUTES {
  VOID *Sid;        // offset: 0x0 ordinal: 0x0
  ULONG Attributes; // offset: 0x8 ordinal: 0x1
} _SID_AND_ATTRIBUTES;

typedef VOID (*__anon_884)(VOID *, struct _DEVICE_OBJECT *, ULONG);

typedef VOID (*__anon_883)(VOID *, ULONG, UCHAR);

typedef VOID (*__anon_881)(VOID *, ULONG, ULONG);

// 0x38 bytes (sizeof)
typedef struct _PO_DIRECTED_DRIPS_STATE {
  struct _LIST_ENTRY QueueLink;        // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY VisitedQueueLink; // offset: 0x10 ordinal: 0x1
  ULONG Flags;                         // offset: 0x20 ordinal: 0x2
  ULONG CachedFlags;                   // offset: 0x24 ordinal: 0x3
  ULONG DeviceUsageCount;              // offset: 0x28 ordinal: 0x4
  VOID *Diagnostic;                    // offset: 0x30 ordinal: 0x5
} _PO_DIRECTED_DRIPS_STATE;

// 0x68 bytes (sizeof)
typedef struct _PO_DEVICE_NOTIFY {
  struct _LIST_ENTRY Link;             // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY PowerChildren;    // offset: 0x10 ordinal: 0x1
  struct _LIST_ENTRY PowerParents;     // offset: 0x20 ordinal: 0x2
  struct _DEVICE_OBJECT *TargetDevice; // offset: 0x30 ordinal: 0x3
  UCHAR OrderLevel;                    // offset: 0x38 ordinal: 0x4
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x40 ordinal: 0x5
  WCHAR *DeviceName;                   // offset: 0x48 ordinal: 0x6
  WCHAR *DriverName;                   // offset: 0x50 ordinal: 0x7
  ULONG ChildCount;                    // offset: 0x58 ordinal: 0x8
  ULONG ActiveChild;                   // offset: 0x5c ordinal: 0x9
  ULONG ParentCount;                   // offset: 0x60 ordinal: 0xa
  ULONG ActiveParent;                  // offset: 0x64 ordinal: 0xb
} _PO_DEVICE_NOTIFY;

// 0x10 bytes (sizeof)
typedef struct __anon_860 {
  struct _PO_DEVICE_NOTIFY *NotifyDevice; // offset: 0x0 ordinal: 0x0
  UCHAR FxDeviceActivated;                // offset: 0x8 ordinal: 0x1
} __anon_860;

// 0x1c bytes (sizeof)
typedef struct _PROC_PERF_QOS_CLASS_POLICY {
  ULONG MaxPolicyPercent;              // offset: 0x0 ordinal: 0x0
  ULONG MaxEquivalentFrequencyPercent; // offset: 0x4 ordinal: 0x1
  ULONG MinPolicyPercent;              // offset: 0x8 ordinal: 0x2
  ULONG AutonomousActivityWindow;      // offset: 0xc ordinal: 0x3
  ULONG EnergyPerfPreference;          // offset: 0x10 ordinal: 0x4
  UCHAR ProvideGuidance;               // offset: 0x14 ordinal: 0x5
  UCHAR AllowThrottling;               // offset: 0x15 ordinal: 0x6
  UCHAR PerfBoostMode;                 // offset: 0x16 ordinal: 0x7
  UCHAR LatencyHintPerf;               // offset: 0x17 ordinal: 0x8
  UCHAR TrackDesiredCrossClass;        // offset: 0x18 ordinal: 0x9
} _PROC_PERF_QOS_CLASS_POLICY;

typedef ULONG (*__anon_852)();

// 0xc bytes (sizeof)
typedef struct _SID {
  UCHAR Revision;          // offset: 0x0 ordinal: 0x0
  UCHAR SubAuthorityCount; // offset: 0x1 ordinal: 0x1
  struct _SID_IDENTIFIER_AUTHORITY
      IdentifierAuthority; // offset: 0x2 ordinal: 0x2
  ULONG SubAuthority[1];   // offset: 0x8 ordinal: 0x3
} _SID;

// 0x8 bytes (sizeof)
typedef struct _CM_INDEX_HINT_BLOCK {
  ULONG Count;      // offset: 0x0 ordinal: 0x0
  ULONG HashKey[1]; // offset: 0x4 ordinal: 0x1
} _CM_INDEX_HINT_BLOCK;

// 0x8 bytes (sizeof)
typedef struct _CM_KEY_INDEX {
  USHORT Signature; // offset: 0x0 ordinal: 0x0
  USHORT Count;     // offset: 0x2 ordinal: 0x1
  ULONG List[1];    // offset: 0x4 ordinal: 0x2
} _CM_KEY_INDEX;

// 0x30 bytes (sizeof)
typedef struct _MAPIC {
  struct _DESCRIPTION_HEADER Header; // offset: 0x0 ordinal: 0x0
  ULONG LocalAPICAddress;            // offset: 0x24 ordinal: 0x1
  ULONG Flags;                       // offset: 0x28 ordinal: 0x2
  ULONG APICTables[1];               // offset: 0x2c ordinal: 0x3
} _MAPIC;

// 0x28 bytes (sizeof)
typedef struct _RSDT_32 {
  struct _DESCRIPTION_HEADER Header; // offset: 0x0 ordinal: 0x0
  ULONG Tables[1];                   // offset: 0x24 ordinal: 0x1
} _RSDT_32;

// 0x14 bytes (sizeof)
typedef struct _FILE_GET_QUOTA_INFORMATION {
  ULONG NextEntryOffset; // offset: 0x0 ordinal: 0x0
  ULONG SidLength;       // offset: 0x4 ordinal: 0x1
  struct _SID Sid;       // offset: 0x8 ordinal: 0x2
} _FILE_GET_QUOTA_INFORMATION;

// 0x20 bytes (sizeof)
typedef struct __anon_1008 {
  ULONG Length;                                // offset: 0x0 ordinal: 0x0
  VOID *StartSid;                              // offset: 0x8 ordinal: 0x1
  struct _FILE_GET_QUOTA_INFORMATION *SidList; // offset: 0x10 ordinal: 0x2
  ULONG SidListLength;                         // offset: 0x18 ordinal: 0x3
} __anon_1008;

// 0xc bytes (sizeof)
typedef struct _COMPRESSED_DATA_INFO {
  USHORT CompressionFormatAndEngine; // offset: 0x0 ordinal: 0x0
  UCHAR CompressionUnitShift;        // offset: 0x2 ordinal: 0x1
  UCHAR ChunkShift;                  // offset: 0x3 ordinal: 0x2
  UCHAR ClusterShift;                // offset: 0x4 ordinal: 0x3
  UCHAR Reserved;                    // offset: 0x5 ordinal: 0x4
  USHORT NumberOfChunks;             // offset: 0x6 ordinal: 0x5
  ULONG CompressedChunkSizes[1];     // offset: 0x8 ordinal: 0x6
} _COMPRESSED_DATA_INFO;

// 0x8 bytes (sizeof)
typedef struct _PROCESSOR_IDLE_DEPENDENCY {
  ULONG ProcessorIndex;    // offset: 0x0 ordinal: 0x0
  UCHAR ExpectedState;     // offset: 0x4 ordinal: 0x1
  UCHAR AllowDeeperStates; // offset: 0x5 ordinal: 0x2
  UCHAR LooseDependency;   // offset: 0x6 ordinal: 0x3
} _PROCESSOR_IDLE_DEPENDENCY;

// 0x28 bytes (sizeof)
typedef struct _RTL_DYNAMIC_HASH_TABLE {
  ULONG Flags;           // offset: 0x0 ordinal: 0x0
  ULONG Shift;           // offset: 0x4 ordinal: 0x1
  ULONG TableSize;       // offset: 0x8 ordinal: 0x2
  ULONG Pivot;           // offset: 0xc ordinal: 0x3
  ULONG DivisorMask;     // offset: 0x10 ordinal: 0x4
  ULONG NumEntries;      // offset: 0x14 ordinal: 0x5
  ULONG NonEmptyBuckets; // offset: 0x18 ordinal: 0x6
  ULONG NumEnumerators;  // offset: 0x1c ordinal: 0x7
  VOID *Directory;       // offset: 0x20 ordinal: 0x8
} _RTL_DYNAMIC_HASH_TABLE;

// 0x8 bytes (sizeof)
typedef struct __anon_796 {
  ULONG IdleTime;    // offset: 0x0 ordinal: 0x0
  ULONG NonIdleTime; // offset: 0x4 ordinal: 0x1
} __anon_796;

// 0x8 bytes (sizeof)
typedef union __anon_695 {
  struct __anon_796 Disk; // offset: 0x0 ordinal: 0x0
} __anon_695;

// 0x68 bytes (sizeof)
typedef struct _FAST_ERESOURCE {
  VOID *Reserved1[3]; // offset: 0x0 ordinal: 0x0
  ULONG Reserved2;    // offset: 0x18 ordinal: 0x1
  VOID *Reserved3[4]; // offset: 0x20 ordinal: 0x2
  ULONG Reserved4[4]; // offset: 0x40 ordinal: 0x3
  VOID *Reserved5;    // offset: 0x50 ordinal: 0x4
  VOID *Reserved6[2]; // offset: 0x58 ordinal: 0x5
} _FAST_ERESOURCE;

// 0x38 bytes (sizeof)
typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
  USHORT Magic;                  // offset: 0x0 ordinal: 0x0
  UCHAR MajorLinkerVersion;      // offset: 0x2 ordinal: 0x1
  UCHAR MinorLinkerVersion;      // offset: 0x3 ordinal: 0x2
  ULONG SizeOfCode;              // offset: 0x4 ordinal: 0x3
  ULONG SizeOfInitializedData;   // offset: 0x8 ordinal: 0x4
  ULONG SizeOfUninitializedData; // offset: 0xc ordinal: 0x5
  ULONG AddressOfEntryPoint;     // offset: 0x10 ordinal: 0x6
  ULONG BaseOfCode;              // offset: 0x14 ordinal: 0x7
  ULONG BaseOfData;              // offset: 0x18 ordinal: 0x8
  ULONG BaseOfBss;               // offset: 0x1c ordinal: 0x9
  ULONG GprMask;                 // offset: 0x20 ordinal: 0xa
  ULONG CprMask[4];              // offset: 0x24 ordinal: 0xb
  ULONG GpValue;                 // offset: 0x34 ordinal: 0xc
} _IMAGE_ROM_OPTIONAL_HEADER;

// 0x10 bytes (sizeof)
typedef struct _MI_PAGE_COLORS {
  ULONG PageSize[4]; // offset: 0x0 ordinal: 0x0
} _MI_PAGE_COLORS;

// 0xc bytes (sizeof)
typedef struct _PERFINFO_PPM_STATE_SELECTION {
  ULONG SelectedState; // offset: 0x0 ordinal: 0x0
  ULONG VetoedStates;  // offset: 0x4 ordinal: 0x1
  ULONG VetoReason[1]; // offset: 0x8 ordinal: 0x2
} _PERFINFO_PPM_STATE_SELECTION;

typedef VOID (*__anon_717)(VOID *, ULONG);

// 0x38 bytes (sizeof)
typedef struct _THERMAL_COOLING_INTERFACE {
  USHORT Size;                           // offset: 0x0 ordinal: 0x0
  USHORT Version;                        // offset: 0x2 ordinal: 0x1
  VOID *Context;                         // offset: 0x8 ordinal: 0x2
  VOID (*InterfaceReference)(VOID *);    // offset: 0x10 ordinal: 0x3
  VOID (*InterfaceDereference)(VOID *);  // offset: 0x18 ordinal: 0x4
  ULONG Flags;                           // offset: 0x20 ordinal: 0x5
  VOID (*ActiveCooling)(VOID *, UCHAR);  // offset: 0x28 ordinal: 0x6
  VOID (*PassiveCooling)(VOID *, ULONG); // offset: 0x30 ordinal: 0x7
} _THERMAL_COOLING_INTERFACE;

typedef ULONG (*__anon_715)(VOID *, ULONG);

typedef ULONG (*__anon_714)(VOID *, ULONG, ULONG);

// 0x10 bytes (sizeof)
typedef struct _POP_FX_DEVICE_DIRECTED_TRANSITION_STATE {
  VOID *CompletionContext; // offset: 0x0 ordinal: 0x0
  LONG CompletionStatus;   // offset: 0x8 ordinal: 0x1
  ULONG DIrpPending : 1;   // offset: 0xc ordinal: 0x2
  ULONG DIrpCompleted : 1; // offset: 0xc ordinal: 0x3
} _POP_FX_DEVICE_DIRECTED_TRANSITION_STATE;

// 0x28 bytes (sizeof)
typedef struct _POP_FX_DRIPS_WATCHDOG_CONTEXT {
  struct _LIST_ENTRY Link;            // offset: 0x0 ordinal: 0x0
  ULONG ComponentIndex;               // offset: 0x10 ordinal: 0x1
  struct _DEVICE_NODE **ChildDevices; // offset: 0x18 ordinal: 0x2
  ULONG ChildDeviceCount;             // offset: 0x20 ordinal: 0x3
} _POP_FX_DRIPS_WATCHDOG_CONTEXT;

// 0x38 bytes (sizeof)
typedef struct _PROC_PERF_HISTORY {
  ULONG Count;                                    // offset: 0x0 ordinal: 0x0
  ULONG Slot;                                     // offset: 0x4 ordinal: 0x1
  ULONG UtilityTotal;                             // offset: 0x8 ordinal: 0x2
  ULONG AffinitizedUtilityTotal;                  // offset: 0xc ordinal: 0x3
  ULONG FrequencyTotal;                           // offset: 0x10 ordinal: 0x4
  ULONG ImportantPercentTotal;                    // offset: 0x14 ordinal: 0x5
  ULONG IdealPercentTotal;                        // offset: 0x18 ordinal: 0x6
  ULONG TaggedPercentTotal[4];                    // offset: 0x1c ordinal: 0x7
  struct _PROC_PERF_HISTORY_ENTRY HistoryList[1]; // offset: 0x2c ordinal: 0x8
} _PROC_PERF_HISTORY;

// 0x10 bytes (sizeof)
typedef struct _PPM_SELECTION_MENU {
  ULONG Count;                               // offset: 0x0 ordinal: 0x0
  struct _PPM_SELECTION_MENU_ENTRY *Entries; // offset: 0x8 ordinal: 0x1
} _PPM_SELECTION_MENU;

// 0x18 bytes (sizeof)
typedef struct _PPM_SELECTION_DEPENDENCY {
  ULONG Processor;                 // offset: 0x0 ordinal: 0x0
  struct _PPM_SELECTION_MENU Menu; // offset: 0x8 ordinal: 0x1
} _PPM_SELECTION_DEPENDENCY;

// 0x18 bytes (sizeof)
typedef struct _PPM_SELECTION_MENU_ENTRY {
  UCHAR StrictDependency;                           // offset: 0x0 ordinal: 0x0
  UCHAR InitiatingState;                            // offset: 0x1 ordinal: 0x1
  UCHAR DependentState;                             // offset: 0x2 ordinal: 0x2
  ULONG StateIndex;                                 // offset: 0x4 ordinal: 0x3
  ULONG Dependencies;                               // offset: 0x8 ordinal: 0x4
  struct _PPM_SELECTION_DEPENDENCY *DependencyList; // offset: 0x10 ordinal: 0x5
} _PPM_SELECTION_MENU_ENTRY;

// 0x8 bytes (sizeof)
typedef struct _HANDLE_TABLE_ENTRY_INFO {
  ULONG AuditMask;             // offset: 0x0 ordinal: 0x0
  ULONG MaxRelativeAccessMask; // offset: 0x4 ordinal: 0x1
} _HANDLE_TABLE_ENTRY_INFO;

// 0x8 bytes (sizeof)
typedef struct _LUID {
  ULONG LowPart; // offset: 0x0 ordinal: 0x0
  LONG HighPart; // offset: 0x4 ordinal: 0x1
} _LUID;

// 0xc bytes (sizeof)
typedef struct _LUID_AND_ATTRIBUTES {
  struct _LUID Luid; // offset: 0x0 ordinal: 0x0
  ULONG Attributes;  // offset: 0x8 ordinal: 0x1
} _LUID_AND_ATTRIBUTES;

// 0x2c bytes (sizeof)
typedef struct _INITIAL_PRIVILEGE_SET {
  ULONG PrivilegeCount;                     // offset: 0x0 ordinal: 0x0
  ULONG Control;                            // offset: 0x4 ordinal: 0x1
  struct _LUID_AND_ATTRIBUTES Privilege[3]; // offset: 0x8 ordinal: 0x2
} _INITIAL_PRIVILEGE_SET;

// 0x14 bytes (sizeof)
typedef struct _PRIVILEGE_SET {
  ULONG PrivilegeCount;                     // offset: 0x0 ordinal: 0x0
  ULONG Control;                            // offset: 0x4 ordinal: 0x1
  struct _LUID_AND_ATTRIBUTES Privilege[1]; // offset: 0x8 ordinal: 0x2
} _PRIVILEGE_SET;

// 0x2c bytes (sizeof)
typedef union __anon_1235 {
  struct _INITIAL_PRIVILEGE_SET InitialPrivilegeSet; // offset: 0x0 ordinal: 0x0
  struct _PRIVILEGE_SET PrivilegeSet;                // offset: 0x0 ordinal: 0x1
} __anon_1235;

// 0xa0 bytes (sizeof)
typedef struct _ACCESS_STATE {
  struct _LUID OperationID;      // offset: 0x0 ordinal: 0x0
  UCHAR SecurityEvaluated;       // offset: 0x8 ordinal: 0x1
  UCHAR GenerateAudit;           // offset: 0x9 ordinal: 0x2
  UCHAR GenerateOnClose;         // offset: 0xa ordinal: 0x3
  UCHAR PrivilegesAllocated;     // offset: 0xb ordinal: 0x4
  ULONG Flags;                   // offset: 0xc ordinal: 0x5
  ULONG RemainingDesiredAccess;  // offset: 0x10 ordinal: 0x6
  ULONG PreviouslyGrantedAccess; // offset: 0x14 ordinal: 0x7
  ULONG OriginalDesiredAccess;   // offset: 0x18 ordinal: 0x8
  struct _SECURITY_SUBJECT_CONTEXT
      SubjectSecurityContext;            // offset: 0x20 ordinal: 0x9
  VOID *SecurityDescriptor;              // offset: 0x40 ordinal: 0xa
  VOID *AuxData;                         // offset: 0x48 ordinal: 0xb
  union __anon_1235 Privileges;          // offset: 0x50 ordinal: 0xc
  UCHAR AuditPrivileges;                 // offset: 0x7c ordinal: 0xd
  struct _UNICODE_STRING ObjectName;     // offset: 0x80 ordinal: 0xe
  struct _UNICODE_STRING ObjectTypeName; // offset: 0x90 ordinal: 0xf
} _ACCESS_STATE;

typedef LONG (*__anon_2928)(VOID *, VOID *, struct _ACCESS_STATE *, CHAR, ULONG,
                            struct _UNICODE_STRING *, struct _UNICODE_STRING *,
                            VOID *, struct _SECURITY_QUALITY_OF_SERVICE *,
                            struct _OB_EXTENDED_PARSE_PARAMETERS *, VOID **);

typedef LONG (*__anon_2927)(VOID *, VOID *, struct _ACCESS_STATE *, CHAR, ULONG,
                            struct _UNICODE_STRING *, struct _UNICODE_STRING *,
                            VOID *, struct _SECURITY_QUALITY_OF_SERVICE *,
                            VOID **);

// 0x18 bytes (sizeof)
typedef struct _IO_SECURITY_CONTEXT {
  struct _SECURITY_QUALITY_OF_SERVICE *SecurityQos; // offset: 0x0 ordinal: 0x0
  struct _ACCESS_STATE *AccessState;                // offset: 0x8 ordinal: 0x1
  ULONG DesiredAccess;                              // offset: 0x10 ordinal: 0x2
  ULONG FullCreateOptions;                          // offset: 0x14 ordinal: 0x3
} _IO_SECURITY_CONTEXT;

// 0x20 bytes (sizeof)
typedef struct __anon_989 {
  struct _IO_SECURITY_CONTEXT *SecurityContext; // offset: 0x0 ordinal: 0x0
  ULONG Options;                                // offset: 0x8 ordinal: 0x1
  USHORT FileAttributes;                        // offset: 0x10 ordinal: 0x2
  USHORT ShareAccess;                           // offset: 0x12 ordinal: 0x3
  ULONG EaLength;                               // offset: 0x18 ordinal: 0x4
} __anon_989;

// 0x10 bytes (sizeof)
typedef struct _TOKEN_PRIVILEGES {
  ULONG PrivilegeCount;                      // offset: 0x0 ordinal: 0x0
  struct _LUID_AND_ATTRIBUTES Privileges[1]; // offset: 0x4 ordinal: 0x1
} _TOKEN_PRIVILEGES;

// 0x10 bytes (sizeof)
typedef struct _TOKEN_SOURCE {
  CHAR SourceName[8];            // offset: 0x0 ordinal: 0x0
  struct _LUID SourceIdentifier; // offset: 0x8 ordinal: 0x1
} _TOKEN_SOURCE;

// 0x28 bytes (sizeof)
typedef struct _TOKEN_CONTROL {
  struct _LUID TokenId;             // offset: 0x0 ordinal: 0x0
  struct _LUID AuthenticationId;    // offset: 0x8 ordinal: 0x1
  struct _LUID ModifiedId;          // offset: 0x10 ordinal: 0x2
  struct _TOKEN_SOURCE TokenSource; // offset: 0x18 ordinal: 0x3
} _TOKEN_CONTROL;

// 0x48 bytes (sizeof)
typedef struct _SECURITY_CLIENT_CONTEXT {
  struct _SECURITY_QUALITY_OF_SERVICE SecurityQos; // offset: 0x0 ordinal: 0x0
  VOID *ClientToken;                               // offset: 0x10 ordinal: 0x1
  UCHAR DirectlyAccessClientToken;                 // offset: 0x18 ordinal: 0x2
  UCHAR DirectAccessEffectiveOnly;                 // offset: 0x19 ordinal: 0x3
  UCHAR ServerIsRemote;                            // offset: 0x1a ordinal: 0x4
  struct _TOKEN_CONTROL ClientTokenControl;        // offset: 0x1c ordinal: 0x5
} _SECURITY_CLIENT_CONTEXT;

// 0x8 bytes (sizeof)
typedef struct _KHETRO_HWFEEDBACK_TYPE {
  ULONG Count; // offset: 0x0 ordinal: 0x0
  struct _KHETERO_HWFEEDBACK_CLASS
      HwFeedbackClass[1]; // offset: 0x4 ordinal: 0x1
} _KHETRO_HWFEEDBACK_TYPE;

// 0x18 bytes (sizeof)
typedef struct _KDEVICE_QUEUE_ENTRY {
  struct _LIST_ENTRY DeviceListEntry; // offset: 0x0 ordinal: 0x0
  ULONG SortKey;                      // offset: 0x10 ordinal: 0x1
  UCHAR Inserted;                     // offset: 0x14 ordinal: 0x2
} _KDEVICE_QUEUE_ENTRY;

// 0xc bytes (sizeof)
typedef struct _CACHE_DESCRIPTOR {
  UCHAR Level;                     // offset: 0x0 ordinal: 0x0
  UCHAR Associativity;             // offset: 0x1 ordinal: 0x1
  USHORT LineSize;                 // offset: 0x2 ordinal: 0x2
  ULONG Size;                      // offset: 0x4 ordinal: 0x3
  enum _PROCESSOR_CACHE_TYPE Type; // offset: 0x8 ordinal: 0x4
} _CACHE_DESCRIPTOR;

// 0x40 bytes (sizeof)
typedef struct _KQUEUE {
  struct _DISPATCHER_HEADER Header;  // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY EntryListHead;  // offset: 0x18 ordinal: 0x1
  ULONG CurrentCount;                // offset: 0x28 ordinal: 0x2
  ULONG MaximumCount;                // offset: 0x2c ordinal: 0x3
  struct _LIST_ENTRY ThreadListHead; // offset: 0x30 ordinal: 0x4
} _KQUEUE;

// 0x48 bytes (sizeof)
typedef struct _ETW_REPLY_QUEUE {
  struct _KQUEUE Queue; // offset: 0x0 ordinal: 0x0
  LONG EventsLost;      // offset: 0x40 ordinal: 0x1
} _ETW_REPLY_QUEUE;

// 0xc bytes (sizeof)
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
  ULONG BeginAddress; // offset: 0x0 ordinal: 0x0
  ULONG EndAddress;   // offset: 0x4 ordinal: 0x1
  union {
    ULONG UnwindInfoAddress; // offset: 0x8 ordinal: 0x2
    ULONG UnwindData;        // offset: 0x8 ordinal: 0x3
  };
} _IMAGE_RUNTIME_FUNCTION_ENTRY;

// 0xa0 bytes (sizeof)
typedef struct _HANDLE_TRACE_DB_ENTRY {
  struct _CLIENT_ID ClientId; // offset: 0x0 ordinal: 0x0
  VOID *Handle;               // offset: 0x10 ordinal: 0x1
  ULONG Type;                 // offset: 0x18 ordinal: 0x2
  VOID *StackTrace[16];       // offset: 0x20 ordinal: 0x3
} _HANDLE_TRACE_DB_ENTRY;

// 0x18 bytes (sizeof)
typedef struct _RTL_DRIVE_LETTER_CURDIR {
  USHORT Flags;           // offset: 0x0 ordinal: 0x0
  USHORT Length;          // offset: 0x2 ordinal: 0x1
  ULONG TimeStamp;        // offset: 0x4 ordinal: 0x2
  struct _STRING DosPath; // offset: 0x8 ordinal: 0x3
} _RTL_DRIVE_LETTER_CURDIR;

// 0x6c bytes (sizeof)
typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE {
  ULONG GlobalDeviceMap;      // offset: 0x0 ordinal: 0x0
  ULONG LocalDeviceCount[26]; // offset: 0x4 ordinal: 0x1
} _OBP_SYSTEM_DOS_DEVICE_STATE;

// 0x54 bytes (sizeof)
typedef struct _IOP_IRP_STACK_PROFILER {
  ULONG Profile[20]; // offset: 0x0 ordinal: 0x0
  ULONG TotalIrps;   // offset: 0x50 ordinal: 0x1
} _IOP_IRP_STACK_PROFILER;

// 0x5c bytes (sizeof)
typedef struct _THERMAL_INFORMATION_EX {
  ULONG ThermalStamp;                 // offset: 0x0 ordinal: 0x0
  ULONG ThermalConstant1;             // offset: 0x4 ordinal: 0x1
  ULONG ThermalConstant2;             // offset: 0x8 ordinal: 0x2
  ULONG SamplingPeriod;               // offset: 0xc ordinal: 0x3
  ULONG CurrentTemperature;           // offset: 0x10 ordinal: 0x4
  ULONG PassiveTripPoint;             // offset: 0x14 ordinal: 0x5
  ULONG ThermalStandbyTripPoint;      // offset: 0x18 ordinal: 0x6
  ULONG CriticalTripPoint;            // offset: 0x1c ordinal: 0x7
  UCHAR ActiveTripPointCount;         // offset: 0x20 ordinal: 0x8
  UCHAR PassiveCoolingDevicesPresent; // offset: 0x21 ordinal: 0x9
  ULONG ActiveTripPoint[10];          // offset: 0x24 ordinal: 0xa
  ULONG S4TransitionTripPoint;        // offset: 0x4c ordinal: 0xb
  ULONG MinimumThrottle;              // offset: 0x50 ordinal: 0xc
  ULONG OverThrottleThreshold;        // offset: 0x54 ordinal: 0xd
  ULONG PollingPeriod;                // offset: 0x58 ordinal: 0xe
} _THERMAL_INFORMATION_EX;

// 0x24 bytes (sizeof)
typedef struct _ETW_FILTER_PID {
  ULONG Count;   // offset: 0x0 ordinal: 0x0
  ULONG Pids[8]; // offset: 0x4 ordinal: 0x1
} _ETW_FILTER_PID;

// 0x20 bytes (sizeof)
typedef struct _PERFINFO_GROUPMASK {
  ULONG Masks[8]; // offset: 0x0 ordinal: 0x0
} _PERFINFO_GROUPMASK;

// 0x174 bytes (sizeof)
typedef struct _ETW_SYSTEM_LOGGER_SETTINGS {
  struct _ETW_SYSTEM_LOGGER EtwpSystemLogger[8];  // offset: 0x0 ordinal: 0x0
  ULONG EtwpActiveSystemLoggers;                  // offset: 0x10 ordinal: 0x1
  struct _PERFINFO_GROUPMASK SiloGlobalGroupMask; // offset: 0x14 ordinal: 0x2
  struct _PERFINFO_GROUPMASK EtwpGroupMasks[10];  // offset: 0x34 ordinal: 0x3
} _ETW_SYSTEM_LOGGER_SETTINGS;

// 0x4 bytes (sizeof)
typedef union _KPRCBFLAG {
  LONG PrcbFlags;                  // offset: 0x0 ordinal: 0x0
  ULONG BamQosLevel : 8;           // offset: 0x0 ordinal: 0x1
  ULONG PendingQosUpdate : 2;      // offset: 0x0 ordinal: 0x2
  ULONG CacheIsolationEnabled : 1; // offset: 0x0 ordinal: 0x3
  ULONG TracepointActive : 1;      // offset: 0x0 ordinal: 0x4
  ULONG LongDpcRunning : 1;        // offset: 0x0 ordinal: 0x5
  ULONG PrcbFlagsReserved : 19;    // offset: 0x0 ordinal: 0x6
} _KPRCBFLAG;

// 0x60 bytes (sizeof)
typedef struct _VPB {
  SHORT Type;                          // offset: 0x0 ordinal: 0x0
  SHORT Size;                          // offset: 0x2 ordinal: 0x1
  USHORT Flags;                        // offset: 0x4 ordinal: 0x2
  USHORT VolumeLabelLength;            // offset: 0x6 ordinal: 0x3
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 ordinal: 0x4
  struct _DEVICE_OBJECT *RealDevice;   // offset: 0x10 ordinal: 0x5
  ULONG SerialNumber;                  // offset: 0x18 ordinal: 0x6
  ULONG ReferenceCount;                // offset: 0x1c ordinal: 0x7
  WCHAR VolumeLabel[32];               // offset: 0x20 ordinal: 0x8
} _VPB;

// 0x10 bytes (sizeof)
typedef struct __anon_1006 {
  struct _VPB *Vpb;                    // offset: 0x0 ordinal: 0x0
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 ordinal: 0x1
} __anon_1006;

// 0x4 bytes (sizeof)
typedef struct _MM_SESSION_SPACE_FLAGS {
  ULONG Initialized : 1;       // offset: 0x0 ordinal: 0x0
  ULONG DeletePending : 1;     // offset: 0x0 ordinal: 0x1
  ULONG WsInitialized : 1;     // offset: 0x0 ordinal: 0x2
  ULONG ObjectInitialized : 1; // offset: 0x0 ordinal: 0x3
  ULONG Filler : 28;           // offset: 0x0 ordinal: 0x4
} _MM_SESSION_SPACE_FLAGS;

// 0x58 bytes (sizeof)
typedef struct _PEB_LDR_DATA {
  ULONG Length;                               // offset: 0x0 ordinal: 0x0
  UCHAR Initialized;                          // offset: 0x4 ordinal: 0x1
  VOID *SsHandle;                             // offset: 0x8 ordinal: 0x2
  struct _LIST_ENTRY InLoadOrderModuleList;   // offset: 0x10 ordinal: 0x3
  struct _LIST_ENTRY InMemoryOrderModuleList; // offset: 0x20 ordinal: 0x4
  struct _LIST_ENTRY
      InInitializationOrderModuleList; // offset: 0x30 ordinal: 0x5
  VOID *EntryInProgress;               // offset: 0x40 ordinal: 0x6
  UCHAR ShutdownInProgress;            // offset: 0x48 ordinal: 0x7
  VOID *ShutdownThreadId;              // offset: 0x50 ordinal: 0x8
} _PEB_LDR_DATA;

typedef UCHAR (*__anon_3359)(struct _GUID *, WCHAR *);

// 0x20 bytes (sizeof)
typedef struct __anon_1010 {
  struct _GUID *InterfaceType;  // offset: 0x0 ordinal: 0x0
  USHORT Size;                  // offset: 0x8 ordinal: 0x1
  USHORT Version;               // offset: 0xa ordinal: 0x2
  struct _INTERFACE *Interface; // offset: 0x10 ordinal: 0x3
  VOID *InterfaceSpecificData;  // offset: 0x18 ordinal: 0x4
} __anon_1010;

typedef VOID (*__anon_342)(struct _KAPC *);

typedef VOID (*__anon_341)(struct _KAPC *, VOID (**)(VOID *, VOID *, VOID *),
                           VOID **, VOID **, VOID **);

// 0x8 bytes (sizeof)
typedef struct _KSCHEDULING_GROUP_POLICY {
  union {
    ULONG Value;    // offset: 0x0 ordinal: 0x0
    USHORT Weight;  // offset: 0x0 ordinal: 0x1
    USHORT MinRate; // offset: 0x0 ordinal: 0x2
  };
  USHORT MaxRate; // offset: 0x2 ordinal: 0x3
  union {
    ULONG AllFlags; // offset: 0x4 ordinal: 0x4
    ULONG Type : 1; // offset: 0x4 ordinal: 0x5
  };
  ULONG Disabled : 1; // offset: 0x4 ordinal: 0x6
  ULONG RankBias : 1; // offset: 0x4 ordinal: 0x7
  ULONG Spare1 : 29;  // offset: 0x4 ordinal: 0x8
} _KSCHEDULING_GROUP_POLICY;

// 0x4 bytes (sizeof)
typedef union __anon_172 {
  ULONG LongFlags;                      // offset: 0x0 ordinal: 0x0
  struct _MM_SESSION_SPACE_FLAGS Flags; // offset: 0x0 ordinal: 0x1
} __anon_172;

// 0x80 bytes (sizeof)
typedef struct _ACCESS_REASONS {
  ULONG Data[32]; // offset: 0x0 ordinal: 0x0
} _ACCESS_REASONS;

// 0x1c bytes (sizeof)
typedef struct _RSDS {
  ULONG Signature;   // offset: 0x0 ordinal: 0x0
  struct _GUID Guid; // offset: 0x4 ordinal: 0x1
  ULONG Age;         // offset: 0x14 ordinal: 0x2
  CHAR PdbName[1];   // offset: 0x18 ordinal: 0x3
} _RSDS;

// 0x1c bytes (sizeof)
typedef union _CVDD {
  ULONG Signature;   // offset: 0x0 ordinal: 0x0
  struct _NB10 NB10; // offset: 0x0 ordinal: 0x1
  struct _RSDS RsDs; // offset: 0x0 ordinal: 0x2
} _CVDD;

// 0x38 bytes (sizeof)
typedef struct _ETW_DEBUGID_TRACKING_ENTRY {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  UCHAR ConsumersNotified;      // offset: 0x10 ordinal: 0x1
  UCHAR Spare[3];               // offset: 0x11 ordinal: 0x2
  ULONG DebugIdSize;            // offset: 0x14 ordinal: 0x3
  union _CVDD DebugId;          // offset: 0x18 ordinal: 0x4
} _ETW_DEBUGID_TRACKING_ENTRY;

// 0x10 bytes (sizeof)
typedef struct __anon_3982 {
  struct _GUID DiskId; // offset: 0x0 ordinal: 0x0
} __anon_3982;

// 0x10 bytes (sizeof)
typedef union __anon_3973 {
  struct __anon_3981 Mbr; // offset: 0x0 ordinal: 0x0
  struct __anon_3982 Gpt; // offset: 0x0 ordinal: 0x1
} __anon_3973;

// 0x10 bytes (sizeof)
typedef struct __WIL__WNF_TYPE_ID {
  struct _GUID TypeId; // offset: 0x0 ordinal: 0x0
} __WIL__WNF_TYPE_ID;

// 0x58 bytes (sizeof)
typedef struct _IO_WORKITEM {
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x0 ordinal: 0x0
  VOID(*Routine)
  (VOID *, VOID *, struct _IO_WORKITEM *); // offset: 0x20 ordinal: 0x1
  VOID *IoObject;                          // offset: 0x28 ordinal: 0x2
  VOID *Context;                           // offset: 0x30 ordinal: 0x3
  struct _ETHREAD *WorkOnBehalfThread;     // offset: 0x38 ordinal: 0x4
  ULONG Type;                              // offset: 0x40 ordinal: 0x5
  struct _GUID ActivityId;                 // offset: 0x44 ordinal: 0x6
} _IO_WORKITEM;

typedef VOID (*__anon_3868)(VOID *, VOID *, struct _IO_WORKITEM *);

// 0x10 bytes (sizeof)
typedef struct _WNF_TYPE_ID {
  struct _GUID TypeId; // offset: 0x0 ordinal: 0x0
} _WNF_TYPE_ID;

// 0x40 bytes (sizeof)
typedef struct _HEADLESS_LOADER_BLOCK {
  UCHAR UsedBiosSettings;   // offset: 0x0 ordinal: 0x0
  UCHAR DataBits;           // offset: 0x1 ordinal: 0x1
  UCHAR StopBits;           // offset: 0x2 ordinal: 0x2
  UCHAR Parity;             // offset: 0x3 ordinal: 0x3
  ULONG BaudRate;           // offset: 0x4 ordinal: 0x4
  ULONG PortNumber;         // offset: 0x8 ordinal: 0x5
  UCHAR *PortAddress;       // offset: 0x10 ordinal: 0x6
  USHORT PciDeviceId;       // offset: 0x18 ordinal: 0x7
  USHORT PciVendorId;       // offset: 0x1a ordinal: 0x8
  UCHAR PciBusNumber;       // offset: 0x1c ordinal: 0x9
  USHORT PciBusSegment;     // offset: 0x1e ordinal: 0xa
  UCHAR PciSlotNumber;      // offset: 0x20 ordinal: 0xb
  UCHAR PciFunctionNumber;  // offset: 0x21 ordinal: 0xc
  ULONG PciFlags;           // offset: 0x24 ordinal: 0xd
  struct _GUID SystemGUID;  // offset: 0x28 ordinal: 0xe
  UCHAR IsMMIODevice;       // offset: 0x38 ordinal: 0xf
  UCHAR TerminalType;       // offset: 0x39 ordinal: 0x10
  UCHAR InterfaceType;      // offset: 0x3a ordinal: 0x11
  UCHAR RegisterBitWidth;   // offset: 0x3b ordinal: 0x12
  UCHAR RegisterAccessSize; // offset: 0x3c ordinal: 0x13
} _HEADLESS_LOADER_BLOCK;

// 0x20 bytes (sizeof)
typedef struct __anon_3495 {
  struct _GUID TargetVolume;        // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING *CimFiles; // offset: 0x10 ordinal: 0x1
  ULONG CimFilesCount;              // offset: 0x18 ordinal: 0x2
} __anon_3495;

// 0x18 bytes (sizeof)
typedef struct _WNF_STATE_NAME_REGISTRATION {
  ULONG MaxStateSize;                              // offset: 0x0 ordinal: 0x0
  struct _WNF_TYPE_ID *TypeId;                     // offset: 0x8 ordinal: 0x1
  struct _SECURITY_DESCRIPTOR *SecurityDescriptor; // offset: 0x10 ordinal: 0x2
} _WNF_STATE_NAME_REGISTRATION;

// 0x48 bytes (sizeof)
typedef struct _CMP_VOLUME_CONTEXT {
  struct _LIST_ENTRY VolumeContextListEntry; // offset: 0x0 ordinal: 0x0
  struct _CMP_VOLUME_MANAGER *VolumeManager; // offset: 0x10 ordinal: 0x1
  LONGLONG RefCount;                         // offset: 0x18 ordinal: 0x2
  struct _GUID VolumeGuid;                   // offset: 0x20 ordinal: 0x3
  VOID *VolumeFileObject;                    // offset: 0x30 ordinal: 0x4
  struct _CMSI_RW_LOCK VolumeContextLock;    // offset: 0x38 ordinal: 0x5
  UCHAR DeviceUsageNotificationSent;         // offset: 0x40 ordinal: 0x6
} _CMP_VOLUME_CONTEXT;

// 0x13 bytes (sizeof)
typedef struct _tlgProviderMetadata_t {
  UCHAR Type;              // offset: 0x0 ordinal: 0x0
  struct _GUID ProviderId; // offset: 0x1 ordinal: 0x1
  USHORT RemainingSize;    // offset: 0x11 ordinal: 0x2
} _tlgProviderMetadata_t;

// 0xe0 bytes (sizeof)
typedef struct _AUX_ACCESS_DATA {
  struct _PRIVILEGE_SET *PrivilegesUsed;           // offset: 0x0 ordinal: 0x0
  struct _GENERIC_MAPPING GenericMapping;          // offset: 0x8 ordinal: 0x1
  ULONG AccessesToAudit;                           // offset: 0x18 ordinal: 0x2
  ULONG MaximumAuditMask;                          // offset: 0x1c ordinal: 0x3
  struct _GUID TransactionId;                      // offset: 0x20 ordinal: 0x4
  VOID *NewSecurityDescriptor;                     // offset: 0x30 ordinal: 0x5
  VOID *ExistingSecurityDescriptor;                // offset: 0x38 ordinal: 0x6
  VOID *ParentSecurityDescriptor;                  // offset: 0x40 ordinal: 0x7
  VOID (*DeRefSecurityDescriptor)(VOID *, VOID *); // offset: 0x48 ordinal: 0x8
  VOID *SDLock;                                    // offset: 0x50 ordinal: 0x9
  struct _ACCESS_REASONS AccessReasons;            // offset: 0x58 ordinal: 0xa
  UCHAR GenerateStagingEvents;                     // offset: 0xd8 ordinal: 0xb
} _AUX_ACCESS_DATA;

// 0x14 bytes (sizeof)
typedef struct _DEVPROPKEY {
  struct _GUID fmtid; // offset: 0x0 ordinal: 0x0
  ULONG pid;          // offset: 0x10 ordinal: 0x1
} _DEVPROPKEY;

// 0x48 bytes (sizeof)
typedef struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
  ULONG SectionOffset;           // offset: 0x0 ordinal: 0x0
  ULONG SectionLength;           // offset: 0x4 ordinal: 0x1
  union _WHEA_REVISION Revision; // offset: 0x8 ordinal: 0x2
  union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS
      ValidBits;  // offset: 0xa ordinal: 0x3
  UCHAR Reserved; // offset: 0xb ordinal: 0x4
  union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS
      Flags;                                 // offset: 0xc ordinal: 0x5
  struct _GUID SectionType;                  // offset: 0x10 ordinal: 0x6
  struct _GUID FRUId;                        // offset: 0x20 ordinal: 0x7
  enum _WHEA_ERROR_SEVERITY SectionSeverity; // offset: 0x30 ordinal: 0x8
  CHAR FRUText[20];                          // offset: 0x34 ordinal: 0x9
} _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR;

// 0x20 bytes (sizeof)
typedef struct __anon_1211 {
  struct _GUID PowerSettingGuid; // offset: 0x0 ordinal: 0x0
  ULONG Flags;                   // offset: 0x10 ordinal: 0x1
  ULONG SessionId;               // offset: 0x14 ordinal: 0x2
  ULONG DataLength;              // offset: 0x18 ordinal: 0x3
  UCHAR Data[1];                 // offset: 0x1c ordinal: 0x4
} __anon_1211;

// 0x10 bytes (sizeof)
typedef struct __anon_1209 {
  struct _GUID BlockedDriverGuid; // offset: 0x0 ordinal: 0x0
} __anon_1209;

// 0x14 bytes (sizeof)
typedef struct __anon_1203 {
  struct _GUID ClassGuid;    // offset: 0x0 ordinal: 0x0
  WCHAR SymbolicLinkName[1]; // offset: 0x10 ordinal: 0x1
} __anon_1203;

// 0x20 bytes (sizeof)
typedef union __anon_1179 {
  struct __anon_1203 DeviceClass;                // offset: 0x0 ordinal: 0x0
  struct __anon_1204 TargetDevice;               // offset: 0x0 ordinal: 0x1
  struct __anon_1204 InstallDevice;              // offset: 0x0 ordinal: 0x2
  struct __anon_1205 CustomNotification;         // offset: 0x0 ordinal: 0x3
  struct __anon_1206 ProfileNotification;        // offset: 0x0 ordinal: 0x4
  struct __anon_1207 PowerNotification;          // offset: 0x0 ordinal: 0x5
  struct __anon_1208 VetoNotification;           // offset: 0x0 ordinal: 0x6
  struct __anon_1209 BlockedDriverNotification;  // offset: 0x0 ordinal: 0x7
  struct __anon_1210 InvalidIDNotification;      // offset: 0x0 ordinal: 0x8
  struct __anon_1211 PowerSettingNotification;   // offset: 0x0 ordinal: 0x9
  struct __anon_1204 PropertyChangeNotification; // offset: 0x0 ordinal: 0xa
  struct __anon_1204 DeviceInstanceNotification; // offset: 0x0 ordinal: 0xb
} __anon_1179;

// 0x10 bytes (sizeof)
typedef struct _PERIODIC_CAPTURE_STATE_GUIDS {
  USHORT ProviderCount;    // offset: 0x0 ordinal: 0x0
  struct _GUID *Providers; // offset: 0x8 ordinal: 0x1
} _PERIODIC_CAPTURE_STATE_GUIDS;

// 0x48 bytes (sizeof)
typedef struct PERIODIC_CAPTURE_STATE_CONTEXT {
  LONGLONG RelativeTimerDueTime;              // offset: 0x0 ordinal: 0x0
  struct _EX_TIMER *Timer;                    // offset: 0x8 ordinal: 0x1
  struct _PERIODIC_CAPTURE_STATE_GUIDS Guids; // offset: 0x10 ordinal: 0x2
  struct _WORK_QUEUE_ITEM WorkItem;           // offset: 0x20 ordinal: 0x3
  enum _ETW_PERIODIC_TIMER_STATE TimerState;  // offset: 0x40 ordinal: 0x4
} PERIODIC_CAPTURE_STATE_CONTEXT;

// 0x10 bytes (sizeof)
typedef struct _DISALLOWED_GUIDS {
  USHORT Count;        // offset: 0x0 ordinal: 0x0
  struct _GUID *Guids; // offset: 0x8 ordinal: 0x1
} _DISALLOWED_GUIDS;

// 0x30 bytes (sizeof)
typedef struct _ETW_DECODE_CONTROL_ENTRY {
  struct _ETW_DECODE_CONTROL_ENTRY *Next; // offset: 0x0 ordinal: 0x0
  struct _GUID Decode;                    // offset: 0x8 ordinal: 0x1
  struct _GUID Control;                   // offset: 0x18 ordinal: 0x2
  UCHAR ConsumersNotified;                // offset: 0x28 ordinal: 0x3
} _ETW_DECODE_CONTROL_ENTRY;

// 0x4 bytes (sizeof)
typedef union __anon_119 {
  ULONG ConcurrencyCountFixed : 1; // offset: 0x0 ordinal: 0x0
  ULONG AllFlags;                  // offset: 0x0 ordinal: 0x1
} __anon_119;

// 0x4 bytes (sizeof)
typedef union _KE_PROCESS_CONCURRENCY_COUNT {
  ULONG Fraction : 20; // offset: 0x0 ordinal: 0x0
  ULONG Count : 12;    // offset: 0x0 ordinal: 0x1
  ULONG AllFields;     // offset: 0x0 ordinal: 0x2
} _KE_PROCESS_CONCURRENCY_COUNT;

// 0x8 bytes (sizeof)
typedef struct _KE_IDEAL_PROCESSOR_SET_BREAKPOINTS {
  union _KE_PROCESS_CONCURRENCY_COUNT Low;  // offset: 0x0 ordinal: 0x0
  union _KE_PROCESS_CONCURRENCY_COUNT High; // offset: 0x4 ordinal: 0x1
} _KE_IDEAL_PROCESSOR_SET_BREAKPOINTS;

// 0x8 bytes (sizeof)
typedef struct _JOBOBJECT_WAKE_FILTER {
  ULONG HighEdgeFilter; // offset: 0x0 ordinal: 0x0
  ULONG LowEdgeFilter;  // offset: 0x4 ordinal: 0x1
} _JOBOBJECT_WAKE_FILTER;

// 0x8 bytes (sizeof)
typedef struct __WIL__WNF_STATE_NAME {
  ULONG Data[2]; // offset: 0x0 ordinal: 0x0
} __WIL__WNF_STATE_NAME;

// 0x8 bytes (sizeof)
typedef struct _WNF_STATE_NAME {
  ULONG Data[2]; // offset: 0x0 ordinal: 0x0
} _WNF_STATE_NAME;

// 0x14 bytes (sizeof)
typedef struct _CM_UOW_KEY_STATE_MODIFICATION {
  ULONG RefCount;           // offset: 0x0 ordinal: 0x0
  ULONG SubKeyListCount[2]; // offset: 0x4 ordinal: 0x1
  ULONG NewSubKeyList[2];   // offset: 0xc ordinal: 0x2
} _CM_UOW_KEY_STATE_MODIFICATION;

// 0x10 bytes (sizeof)
typedef struct _PO_DIAG_STACK_RECORD {
  ULONG StackDepth; // offset: 0x0 ordinal: 0x0
  VOID *Stack[1];   // offset: 0x8 ordinal: 0x1
} _PO_DIAG_STACK_RECORD;

// 0x4 bytes (sizeof)
typedef struct __anon_86 {
  ULONG RestrictCoreSharing : 1;    // offset: 0x0 ordinal: 0x0
  ULONG MitigationFlags3Spare : 31; // offset: 0x0 ordinal: 0x1
} __anon_86;

// 0x8 bytes (sizeof)
typedef struct _PSP_SYSCALL_PROVIDER_DISPATCH_CONTEXT {
  ULONG Level; // offset: 0x0 ordinal: 0x0
  ULONG Slot;  // offset: 0x4 ordinal: 0x1
} _PSP_SYSCALL_PROVIDER_DISPATCH_CONTEXT;

// 0x4 bytes (sizeof)
typedef struct __anon_80 {
  ULONG EnableExportAddressFilter : 1;          // offset: 0x0 ordinal: 0x0
  ULONG AuditExportAddressFilter : 1;           // offset: 0x0 ordinal: 0x1
  ULONG EnableExportAddressFilterPlus : 1;      // offset: 0x0 ordinal: 0x2
  ULONG AuditExportAddressFilterPlus : 1;       // offset: 0x0 ordinal: 0x3
  ULONG EnableRopStackPivot : 1;                // offset: 0x0 ordinal: 0x4
  ULONG AuditRopStackPivot : 1;                 // offset: 0x0 ordinal: 0x5
  ULONG EnableRopCallerCheck : 1;               // offset: 0x0 ordinal: 0x6
  ULONG AuditRopCallerCheck : 1;                // offset: 0x0 ordinal: 0x7
  ULONG EnableRopSimExec : 1;                   // offset: 0x0 ordinal: 0x8
  ULONG AuditRopSimExec : 1;                    // offset: 0x0 ordinal: 0x9
  ULONG EnableImportAddressFilter : 1;          // offset: 0x0 ordinal: 0xa
  ULONG AuditImportAddressFilter : 1;           // offset: 0x0 ordinal: 0xb
  ULONG DisablePageCombine : 1;                 // offset: 0x0 ordinal: 0xc
  ULONG SpeculativeStoreBypassDisable : 1;      // offset: 0x0 ordinal: 0xd
  ULONG CetUserShadowStacks : 1;                // offset: 0x0 ordinal: 0xe
  ULONG AuditCetUserShadowStacks : 1;           // offset: 0x0 ordinal: 0xf
  ULONG AuditCetUserShadowStacksLogged : 1;     // offset: 0x0 ordinal: 0x10
  ULONG UserCetSetContextIpValidation : 1;      // offset: 0x0 ordinal: 0x11
  ULONG AuditUserCetSetContextIpValidation : 1; // offset: 0x0 ordinal: 0x12
  ULONG
  AuditUserCetSetContextIpValidationLogged : 1; // offset: 0x0 ordinal: 0x13
  ULONG CetUserShadowStacksStrictMode : 1;      // offset: 0x0 ordinal: 0x14
  ULONG BlockNonCetBinaries : 1;                // offset: 0x0 ordinal: 0x15
  ULONG BlockNonCetBinariesNonEhcont : 1;       // offset: 0x0 ordinal: 0x16
  ULONG AuditBlockNonCetBinaries : 1;           // offset: 0x0 ordinal: 0x17
  ULONG AuditBlockNonCetBinariesLogged : 1;     // offset: 0x0 ordinal: 0x18
  ULONG XtendedControlFlowGuard : 1;            // offset: 0x0 ordinal: 0x19
  ULONG AuditXtendedControlFlowGuard : 1;       // offset: 0x0 ordinal: 0x1a
  ULONG PointerAuthUserIp : 1;                  // offset: 0x0 ordinal: 0x1b
  ULONG AuditPointerAuthUserIp : 1;             // offset: 0x0 ordinal: 0x1c
  ULONG AuditPointerAuthUserIpLogged : 1;       // offset: 0x0 ordinal: 0x1d
  ULONG CetDynamicApisOutOfProcOnly : 1;        // offset: 0x0 ordinal: 0x1e
  ULONG
  UserCetSetContextIpValidationRelaxedMode : 1; // offset: 0x0 ordinal: 0x1f
} __anon_80;

// 0x4 bytes (sizeof)
typedef struct __anon_79 {
  ULONG ControlFlowGuardEnabled : 1; // offset: 0x0 ordinal: 0x0
  ULONG
  ControlFlowGuardExportSuppressionEnabled : 1;     // offset: 0x0 ordinal: 0x1
  ULONG ControlFlowGuardStrict : 1;                 // offset: 0x0 ordinal: 0x2
  ULONG DisallowStrippedImages : 1;                 // offset: 0x0 ordinal: 0x3
  ULONG ForceRelocateImages : 1;                    // offset: 0x0 ordinal: 0x4
  ULONG HighEntropyASLREnabled : 1;                 // offset: 0x0 ordinal: 0x5
  ULONG StackRandomizationDisabled : 1;             // offset: 0x0 ordinal: 0x6
  ULONG ExtensionPointDisable : 1;                  // offset: 0x0 ordinal: 0x7
  ULONG DisableDynamicCode : 1;                     // offset: 0x0 ordinal: 0x8
  ULONG DisableDynamicCodeAllowOptOut : 1;          // offset: 0x0 ordinal: 0x9
  ULONG DisableDynamicCodeAllowRemoteDowngrade : 1; // offset: 0x0 ordinal: 0xa
  ULONG AuditDisableDynamicCode : 1;                // offset: 0x0 ordinal: 0xb
  ULONG DisallowWin32kSystemCalls : 1;              // offset: 0x0 ordinal: 0xc
  ULONG AuditDisallowWin32kSystemCalls : 1;         // offset: 0x0 ordinal: 0xd
  ULONG EnableFilteredWin32kAPIs : 1;               // offset: 0x0 ordinal: 0xe
  ULONG AuditFilteredWin32kAPIs : 1;                // offset: 0x0 ordinal: 0xf
  ULONG DisableNonSystemFonts : 1;                  // offset: 0x0 ordinal: 0x10
  ULONG AuditNonSystemFontLoading : 1;              // offset: 0x0 ordinal: 0x11
  ULONG PreferSystem32Images : 1;                   // offset: 0x0 ordinal: 0x12
  ULONG ProhibitRemoteImageMap : 1;                 // offset: 0x0 ordinal: 0x13
  ULONG AuditProhibitRemoteImageMap : 1;            // offset: 0x0 ordinal: 0x14
  ULONG ProhibitLowILImageMap : 1;                  // offset: 0x0 ordinal: 0x15
  ULONG AuditProhibitLowILImageMap : 1;             // offset: 0x0 ordinal: 0x16
  ULONG SignatureMitigationOptIn : 1;               // offset: 0x0 ordinal: 0x17
  ULONG AuditBlockNonMicrosoftBinaries : 1;         // offset: 0x0 ordinal: 0x18
  ULONG
  AuditBlockNonMicrosoftBinariesAllowStore : 1; // offset: 0x0 ordinal: 0x19
  ULONG LoaderIntegrityContinuityEnabled : 1;   // offset: 0x0 ordinal: 0x1a
  ULONG AuditLoaderIntegrityContinuity : 1;     // offset: 0x0 ordinal: 0x1b
  ULONG EnableModuleTamperingProtection : 1;    // offset: 0x0 ordinal: 0x1c
  ULONG
  EnableModuleTamperingProtectionNoInherit : 1; // offset: 0x0 ordinal: 0x1d
  ULONG RestrictIndirectBranchPrediction : 1;   // offset: 0x0 ordinal: 0x1e
  ULONG IsolateSecurityDomain : 1;              // offset: 0x0 ordinal: 0x1f
} __anon_79;

// 0x18 bytes (sizeof)
typedef struct _EXT_DELETE_PARAMETERS {
  ULONG Version;                  // offset: 0x0 ordinal: 0x0
  ULONG Reserved;                 // offset: 0x4 ordinal: 0x1
  VOID (*DeleteCallback)(VOID *); // offset: 0x8 ordinal: 0x2
  VOID *DeleteContext;            // offset: 0x10 ordinal: 0x3
} _EXT_DELETE_PARAMETERS;

// 0x38 bytes (sizeof)
typedef struct _FAST_MUTEX {
  LONG Count;           // offset: 0x0 ordinal: 0x0
  VOID *Owner;          // offset: 0x8 ordinal: 0x1
  ULONG Contention;     // offset: 0x10 ordinal: 0x2
  struct _KEVENT Event; // offset: 0x18 ordinal: 0x3
  ULONG OldIrql;        // offset: 0x30 ordinal: 0x4
} _FAST_MUTEX;

// 0x88 bytes (sizeof)
typedef struct _PNP_DEVICE_EVENT_LIST {
  LONG Status;                     // offset: 0x0 ordinal: 0x0
  struct _KMUTANT EventQueueMutex; // offset: 0x8 ordinal: 0x1
  struct _FAST_MUTEX Lock;         // offset: 0x40 ordinal: 0x2
  struct _LIST_ENTRY List;         // offset: 0x78 ordinal: 0x3
} _PNP_DEVICE_EVENT_LIST;

// 0xf0 bytes (sizeof)
typedef struct _HANDLE_TRACE_DEBUG_INFO {
  LONG RefCount;                            // offset: 0x0 ordinal: 0x0
  ULONG TableSize;                          // offset: 0x4 ordinal: 0x1
  ULONG BitMaskFlags;                       // offset: 0x8 ordinal: 0x2
  struct _FAST_MUTEX CloseCompactionLock;   // offset: 0x10 ordinal: 0x3
  ULONG CurrentStackIndex;                  // offset: 0x48 ordinal: 0x4
  struct _HANDLE_TRACE_DB_ENTRY TraceDb[1]; // offset: 0x50 ordinal: 0x5
} _HANDLE_TRACE_DEBUG_INFO;

// 0x10 bytes (sizeof)
typedef struct _EXT_SET_PARAMETERS_V0 {
  ULONG Version;            // offset: 0x0 ordinal: 0x0
  ULONG Reserved;           // offset: 0x4 ordinal: 0x1
  LONGLONG NoWakeTolerance; // offset: 0x8 ordinal: 0x2
} _EXT_SET_PARAMETERS_V0;

// 0x4 bytes (sizeof)
typedef struct _KFLOATING_SAVE {
  ULONG Dummy; // offset: 0x0 ordinal: 0x0
} _KFLOATING_SAVE;

typedef VOID (*__anon_3985)(ULONG *, ULONG *);

typedef LONG (*__anon_3455)(ULONG, USHORT, USHORT, ULONG *);

typedef LONG (*__anon_3446)(struct _DEVICE_OBJECT *,
                            struct _INPUT_MAPPING_ELEMENT *, ULONG, ULONG *);

typedef LONG (*__anon_3430)(ULONG, ULONG *, ULONG *, VOID **);

typedef LONG (*__anon_3307)(enum _KPROFILE_SOURCE, ULONG *, ULONG *,
                            struct _HAL_PMC_COUNTERS **);

typedef LONG (*__anon_3306)(ULONG, enum _KPROFILE_SOURCE *, ULONG, ULONG *,
                            struct _HAL_PMC_COUNTERS **, ULONG *);

typedef LONG (*__anon_3301)(ULONG, ULONG, UCHAR *, UCHAR *, UCHAR *, ULONG *,
                            ULONG *);

typedef UCHAR (*__anon_3297)(ULONG *, ULONG *);

typedef LONG (*__anon_3296)(ULONG, struct _HAL_LBR_ENTRY *, ULONG *);

typedef LONG (*__anon_3295)(ULONG, UCHAR (*)(struct _GUID *, WCHAR *), VOID *,
                            ULONG *);

typedef LONG (*__anon_3287)(ULONG *, UCHAR *);

typedef LONG (*__anon_3264)(CHAR *, USHORT, ULONG *);

typedef VOID (*__anon_3252)(UCHAR, ULONG *);

typedef LONG (*__anon_2930)(VOID *, UCHAR, struct _OBJECT_NAME_INFORMATION *,
                            ULONG, ULONG *, CHAR);

typedef LONG (*__anon_2929)(VOID *, enum _SECURITY_OPERATION_CODE, ULONG *,
                            VOID *, ULONG *, VOID **, enum _POOL_TYPE,
                            struct _GENERIC_MAPPING *, CHAR);

// 0x38 bytes (sizeof)
typedef struct _HEAP_LIST_LOOKUP {
  struct _HEAP_LIST_LOOKUP *ExtendedLookup; // offset: 0x0 ordinal: 0x0
  ULONG ArraySize;                          // offset: 0x8 ordinal: 0x1
  ULONG ExtraItem;                          // offset: 0xc ordinal: 0x2
  ULONG ItemCount;                          // offset: 0x10 ordinal: 0x3
  ULONG OutOfRangeItems;                    // offset: 0x14 ordinal: 0x4
  ULONG BaseIndex;                          // offset: 0x18 ordinal: 0x5
  struct _LIST_ENTRY *ListHead;             // offset: 0x20 ordinal: 0x6
  ULONG *ListsInUseUlong;                   // offset: 0x28 ordinal: 0x7
  struct _LIST_ENTRY **ListHints;           // offset: 0x30 ordinal: 0x8
} _HEAP_LIST_LOOKUP;

typedef UCHAR (*__anon_2704)(VOID *, ULONG, ULONG *);

// 0x20 bytes (sizeof)
typedef struct _CACHE_MANAGER_CALLBACK_FUNCTIONS {
  UCHAR(*AcquireForLazyWriteEx)
  (VOID *, ULONG, ULONG *);                    // offset: 0x0 ordinal: 0x0
  VOID (*ReleaseFromLazyWrite)(VOID *);        // offset: 0x8 ordinal: 0x1
  UCHAR (*AcquireForReadAhead)(VOID *, UCHAR); // offset: 0x10 ordinal: 0x2
  VOID (*ReleaseFromReadAhead)(VOID *);        // offset: 0x18 ordinal: 0x3
} _CACHE_MANAGER_CALLBACK_FUNCTIONS;

// 0x28 bytes (sizeof)
typedef struct _CACHE_MANAGER_CALLBACKS_EX {
  USHORT Version; // offset: 0x0 ordinal: 0x0
  USHORT Size;    // offset: 0x2 ordinal: 0x1
  struct _CACHE_MANAGER_CALLBACK_FUNCTIONS
      Functions; // offset: 0x8 ordinal: 0x2
} _CACHE_MANAGER_CALLBACKS_EX;

// 0x30 bytes (sizeof)
typedef struct _BITMAP_RANGE {
  struct _LIST_ENTRY Links; // offset: 0x0 ordinal: 0x0
  LONGLONG BasePage;        // offset: 0x10 ordinal: 0x1
  ULONG FirstDirtyPage;     // offset: 0x18 ordinal: 0x2
  ULONG LastDirtyPage;      // offset: 0x1c ordinal: 0x3
  ULONG DirtyPages;         // offset: 0x20 ordinal: 0x4
  ULONG *Bitmap;            // offset: 0x28 ordinal: 0x5
} _BITMAP_RANGE;

// 0xc0 bytes (sizeof)
typedef struct _MBCB {
  SHORT NodeTypeCode;                // offset: 0x0 ordinal: 0x0
  SHORT NodeIsInZone;                // offset: 0x2 ordinal: 0x1
  ULONG PagesToWrite;                // offset: 0x4 ordinal: 0x2
  ULONG DirtyPages;                  // offset: 0x8 ordinal: 0x3
  ULONG Reserved;                    // offset: 0xc ordinal: 0x4
  struct _LIST_ENTRY BitmapRanges;   // offset: 0x10 ordinal: 0x5
  LONGLONG ResumeWritePage;          // offset: 0x20 ordinal: 0x6
  LONGLONG MostRecentlyDirtiedPage;  // offset: 0x28 ordinal: 0x7
  struct _BITMAP_RANGE BitmapRange1; // offset: 0x30 ordinal: 0x8
  struct _BITMAP_RANGE BitmapRange2; // offset: 0x60 ordinal: 0x9
  struct _BITMAP_RANGE BitmapRange3; // offset: 0x90 ordinal: 0xa
} _MBCB;

// 0x20 bytes (sizeof)
typedef struct _PEP_ACPI_INTERRUPT_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;           // offset: 0x0 ordinal: 0x0
  enum _KINTERRUPT_MODE InterruptType;         // offset: 0x4 ordinal: 0x1
  enum _KINTERRUPT_POLARITY InterruptPolarity; // offset: 0x8 ordinal: 0x2
  union _PEP_ACPI_RESOURCE_FLAGS Flags;        // offset: 0xc ordinal: 0x3
  UCHAR Count;                                 // offset: 0x10 ordinal: 0x4
  ULONG *Pins;                                 // offset: 0x18 ordinal: 0x5
} _PEP_ACPI_INTERRUPT_RESOURCE;

typedef LONG (*__anon_1865)(ULONG, VOID *, ULONG *);

typedef LONG (*__anon_1855)(ULONG, ULONG *);

typedef LONG (*__anon_1846)(ULONG, ULONG, ULONG *, ULONG *, ULONG *, ULONG *);

typedef LONG (*__anon_1844)(ULONG, ULONG *, ULONG *);

typedef VOID (*__anon_1706)(VOID *, UCHAR, ULONG *, ULONG *, ULONG);

typedef LONG (*__anon_1591)(struct _DMA_ADAPTER *, struct _MDL *, VOID *, ULONG,
                            ULONG *, ULONG *);

typedef UCHAR (*__anon_1564)(VOID *, ULONG *, enum _DMA_INTERRUPT_TYPE *);

typedef LONG (*__anon_1409)(VOID *, ULONG, ULONG *, ULONG *,
                            enum _KINTERRUPT_MODE *, enum _KINTERRUPT_MODE *);

typedef enum _INTERRUPT_RESULT (*__anon_1408)(VOID *, LONG *, ULONG *, UCHAR *);

typedef enum _INTERRUPT_RESULT (*__anon_1402)(VOID *, LONG *, ULONG *);

typedef LONG (*__anon_1400)(VOID *, ULONG, ULONG, ULONG, ULONG, ULONG *);

typedef LONG (*__anon_1338)(VOID *, ULONG *);

// 0x18 bytes (sizeof)
typedef struct _WHEA_ERROR_SOURCE_CONFIGURATION_DD {
  LONG (*Initialize)(VOID *, ULONG); // offset: 0x0 ordinal: 0x0
  VOID (*Uninitialize)(VOID *);      // offset: 0x8 ordinal: 0x1
  LONG (*Correct)(VOID *, ULONG *);  // offset: 0x10 ordinal: 0x2
} _WHEA_ERROR_SOURCE_CONFIGURATION_DD;

// 0x74 bytes (sizeof)
typedef struct _WHEA_DEVICE_DRIVER_DESCRIPTOR {
  USHORT Type;             // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;           // offset: 0x2 ordinal: 0x1
  UCHAR Reserved;          // offset: 0x3 ordinal: 0x2
  struct _GUID SourceGuid; // offset: 0x4 ordinal: 0x3
  USHORT LogTag;           // offset: 0x14 ordinal: 0x4
  USHORT Reserved2;        // offset: 0x16 ordinal: 0x5
  ULONG PacketLength;      // offset: 0x18 ordinal: 0x6
  ULONG PacketCount;       // offset: 0x1c ordinal: 0x7
  UCHAR *PacketBuffer;     // offset: 0x20 ordinal: 0x8
  struct _WHEA_ERROR_SOURCE_CONFIGURATION_DD
      Config;                 // offset: 0x28 ordinal: 0x9
  struct _GUID CreatorId;     // offset: 0x40 ordinal: 0xa
  struct _GUID PartitionId;   // offset: 0x50 ordinal: 0xb
  ULONG MaxSectionDataLength; // offset: 0x60 ordinal: 0xc
  ULONG MaxSectionsPerRecord; // offset: 0x64 ordinal: 0xd
  UCHAR *PacketStateBuffer;   // offset: 0x68 ordinal: 0xe
  LONG OpenHandles;           // offset: 0x70 ordinal: 0xf
} _WHEA_DEVICE_DRIVER_DESCRIPTOR;

// 0x20 bytes (sizeof)
typedef struct __anon_1188 {
  struct _IRP *Irp;      // offset: 0x0 ordinal: 0x0
  VOID *FileInformation; // offset: 0x8 ordinal: 0x1
  ULONG *Length;         // offset: 0x10 ordinal: 0x2
  enum _FILE_INFORMATION_CLASS
      FileInformationClass; // offset: 0x18 ordinal: 0x3
  LONG CompletionStatus;    // offset: 0x1c ordinal: 0x4
} __anon_1188;

// 0x50 bytes (sizeof)
typedef struct _PLUGPLAY_EVENT_BLOCK {
  struct _GUID EventGuid;                      // offset: 0x0 ordinal: 0x0
  enum _PLUGPLAY_EVENT_CATEGORY EventCategory; // offset: 0x10 ordinal: 0x1
  ULONG *Result;                               // offset: 0x18 ordinal: 0x2
  ULONG Flags;                                 // offset: 0x20 ordinal: 0x3
  ULONG TotalSize;                             // offset: 0x24 ordinal: 0x4
  VOID *DeviceObject;                          // offset: 0x28 ordinal: 0x5
  union __anon_1179 u;                         // offset: 0x30 ordinal: 0x6
} _PLUGPLAY_EVENT_BLOCK;

typedef LONG (*__anon_853)(ULONG, ULONG *, VOID *, ULONG);

typedef VOID (*__anon_716)(VOID *, ULONG, ULONG, ULONG, ULONG *);

typedef LONG (*__anon_711)(VOID *, ULONG, ULONG, ULONG, ULONG *);

// 0x18 bytes (sizeof)
typedef struct _PPM_COORDINATED_SELECTION {
  ULONG MaximumStates;    // offset: 0x0 ordinal: 0x0
  ULONG SelectedStates;   // offset: 0x4 ordinal: 0x1
  ULONG DefaultSelection; // offset: 0x8 ordinal: 0x2
  ULONG *Selection;       // offset: 0x10 ordinal: 0x3
} _PPM_COORDINATED_SELECTION;

// 0x10 bytes (sizeof)
typedef struct _RTL_BITMAP {
  ULONG SizeOfBitMap; // offset: 0x0 ordinal: 0x0
  ULONG *Buffer;      // offset: 0x8 ordinal: 0x1
} _RTL_BITMAP;

// 0x18 bytes (sizeof)
typedef struct _FREE_DISPLAY {
  ULONG RealVectorSize;       // offset: 0x0 ordinal: 0x0
  ULONG Hint;                 // offset: 0x4 ordinal: 0x1
  struct _RTL_BITMAP Display; // offset: 0x8 ordinal: 0x2
} _FREE_DISPLAY;

// 0x28 bytes (sizeof)
typedef struct _MI_PAGING_FILE_SPACE_BITMAPS {
  union {
    ULONG RefCount;                               // offset: 0x0 ordinal: 0x0
    struct _MI_PAGING_FILE_SPACE_BITMAPS *Anchor; // offset: 0x0 ordinal: 0x1
  };
  struct _RTL_BITMAP AllocationBitmap; // offset: 0x8 ordinal: 0x2
  union {
    struct _RTL_BITMAP ReservationBitmap; // offset: 0x18 ordinal: 0x3
    struct _RTL_BITMAP EvictedBitmap;     // offset: 0x18 ordinal: 0x4
  };
} _MI_PAGING_FILE_SPACE_BITMAPS;

// 0x8 bytes (sizeof)
typedef struct __anon_26 {
  ULONG LowPart;  // offset: 0x0 ordinal: 0x0
  ULONG HighPart; // offset: 0x4 ordinal: 0x1
} __anon_26;

// 0x8 bytes (sizeof)
typedef struct __anon_23 {
  ULONG LowPart; // offset: 0x0 ordinal: 0x0
  LONG HighPart; // offset: 0x4 ordinal: 0x1
} __anon_23;

// 0x8 bytes (sizeof)
typedef union _LARGE_INTEGER {
  ULONG LowPart;      // offset: 0x0 ordinal: 0x0
  LONG HighPart;      // offset: 0x4 ordinal: 0x1
  struct __anon_23 u; // offset: 0x0 ordinal: 0x2
  LONGLONG QuadPart;  // offset: 0x0 ordinal: 0x3
} _LARGE_INTEGER;

// 0x2c bytes (sizeof)
typedef struct _XSDT {
  struct _DESCRIPTION_HEADER Header; // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER Tables[1];    // offset: 0x24 ordinal: 0x1
} _XSDT;

typedef UCHAR (*__anon_3978)(union _LARGE_INTEGER);

// 0x28 bytes (sizeof)
typedef struct _OBJECT_SYMBOLIC_LINK {
  union _LARGE_INTEGER CreationTime; // offset: 0x0 ordinal: 0x0
  union {
    struct _UNICODE_STRING LinkTarget; // offset: 0x8 ordinal: 0x1
    LONG(*Callback)
    (struct _OBJECT_SYMBOLIC_LINK *, VOID *, struct _UNICODE_STRING *,
     VOID **); // offset: 0x8 ordinal: 0x2
  };
  VOID *CallbackContext;     // offset: 0x10 ordinal: 0x3
  ULONG DosDeviceDriveIndex; // offset: 0x18 ordinal: 0x4
  ULONG Flags;               // offset: 0x1c ordinal: 0x5
  ULONG AccessMask;          // offset: 0x20 ordinal: 0x6
  ULONG IntegrityLevel;      // offset: 0x24 ordinal: 0x7
} _OBJECT_SYMBOLIC_LINK;

typedef LONG (*__anon_3842)(struct _OBJECT_SYMBOLIC_LINK *, VOID *,
                            struct _UNICODE_STRING *, VOID **);

// 0x38 bytes (sizeof)
typedef struct _MI_BAD_MEMORY_EVENT_ENTRY {
  ULONG BugCheckCode;                   // offset: 0x0 ordinal: 0x0
  LONG Active;                          // offset: 0x4 ordinal: 0x1
  ULONG Data;                           // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER PhysicalAddress; // offset: 0x10 ordinal: 0x3
  struct _WORK_QUEUE_ITEM WorkItem;     // offset: 0x18 ordinal: 0x4
} _MI_BAD_MEMORY_EVENT_ENTRY;

// 0x10 bytes (sizeof)
typedef struct _DOMAIN_CONFIGURATION_X64 {
  union _LARGE_INTEGER FirstLevelPageTableRoot; // offset: 0x0 ordinal: 0x0
  UCHAR TranslationEnabled;                     // offset: 0x8 ordinal: 0x1
} _DOMAIN_CONFIGURATION_X64;

// 0x20 bytes (sizeof)
typedef struct _DOMAIN_CONFIGURATION_ARM64 {
  union _LARGE_INTEGER Ttbr0; // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER Ttbr1; // offset: 0x8 ordinal: 0x1
  ULONG Mair0;                // offset: 0x10 ordinal: 0x2
  ULONG Mair1;                // offset: 0x14 ordinal: 0x3
  UCHAR InputSize0;           // offset: 0x18 ordinal: 0x4
  UCHAR InputSize1;           // offset: 0x19 ordinal: 0x5
  UCHAR CoherentTableWalks;   // offset: 0x1a ordinal: 0x6
  UCHAR TranslationEnabled;   // offset: 0x1b ordinal: 0x7
} _DOMAIN_CONFIGURATION_ARM64;

// 0x28 bytes (sizeof)
typedef struct _DOMAIN_CONFIGURATION {
  enum _DOMAIN_CONFIGURATION_ARCH Type; // offset: 0x0 ordinal: 0x0
  union {
    struct _DOMAIN_CONFIGURATION_ARM64 Arm64; // offset: 0x8 ordinal: 0x1
    struct _DOMAIN_CONFIGURATION_X64 X64;     // offset: 0x8 ordinal: 0x2
  };
} _DOMAIN_CONFIGURATION;

// 0x50 bytes (sizeof)
typedef struct _LOADER_PARAMETER_CI_EXTENSION {
  ULONG CodeIntegrityOptions;                  // offset: 0x0 ordinal: 0x0
  ULONG UpgradeInProgress : 1;                 // offset: 0x4 ordinal: 0x1
  ULONG IsWinPE : 1;                           // offset: 0x4 ordinal: 0x2
  ULONG CustomKernelSignersAllowed : 1;        // offset: 0x4 ordinal: 0x3
  ULONG StateSeparationEnabled : 1;            // offset: 0x4 ordinal: 0x4
  ULONG Reserved : 28;                         // offset: 0x4 ordinal: 0x5
  union _LARGE_INTEGER WhqlEnforcementDate;    // offset: 0x8 ordinal: 0x6
  ULONG RevocationListOffset;                  // offset: 0x10 ordinal: 0x7
  ULONG RevocationListSize;                    // offset: 0x14 ordinal: 0x8
  ULONG CodeIntegrityPolicyOffset;             // offset: 0x18 ordinal: 0x9
  ULONG CodeIntegrityPolicySize;               // offset: 0x1c ordinal: 0xa
  ULONG CodeIntegrityPolicyHashOffset;         // offset: 0x20 ordinal: 0xb
  ULONG CodeIntegrityPolicyHashSize;           // offset: 0x24 ordinal: 0xc
  ULONG CodeIntegrityPolicyOriginalHashOffset; // offset: 0x28 ordinal: 0xd
  ULONG CodeIntegrityPolicyOriginalHashSize;   // offset: 0x2c ordinal: 0xe
  LONG WeakCryptoPolicyLoadStatus;             // offset: 0x30 ordinal: 0xf
  ULONG WeakCryptoPolicyOffset;                // offset: 0x34 ordinal: 0x10
  ULONG WeakCryptoPolicySize;                  // offset: 0x38 ordinal: 0x11
  ULONG SecureBootPolicyOffset;                // offset: 0x3c ordinal: 0x12
  ULONG SecureBootPolicySize;                  // offset: 0x40 ordinal: 0x13
  ULONG Reserved2;                             // offset: 0x44 ordinal: 0x14
  UCHAR SerializedData[1];                     // offset: 0x48 ordinal: 0x15
} _LOADER_PARAMETER_CI_EXTENSION;

// 0x20 bytes (sizeof)
typedef struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
  ULONG Version;                         // offset: 0x0 ordinal: 0x0
  ULONG AbnormalResetOccurred;           // offset: 0x4 ordinal: 0x1
  ULONG OfflineMemoryDumpCapable;        // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER ResetDataAddress; // offset: 0x10 ordinal: 0x3
  ULONG ResetDataSize;                   // offset: 0x18 ordinal: 0x4
} _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2;

typedef union _LARGE_INTEGER (*__anon_3312)();

typedef LONG (*__anon_3280)(VOID *, ULONG, union _LARGE_INTEGER);

typedef VOID (*__anon_3276)(union _LARGE_INTEGER);

typedef LONG (*__anon_3255)(union _LARGE_INTEGER, ULONG, VOID *);

typedef VOID *(*__anon_3243)(union _LARGE_INTEGER, ULONG, UCHAR);

// 0x10 bytes (sizeof)
typedef struct __anon_3076 {
  union _LARGE_INTEGER Address; // offset: 0x0 ordinal: 0x0
  ULONG DataPayload;            // offset: 0x8 ordinal: 0x1
} __anon_3076;

// 0x118 bytes (sizeof)
typedef struct _TRACE_LOGFILE_HEADER {
  ULONG BufferSize; // offset: 0x0 ordinal: 0x0
  union {
    ULONG Version;                    // offset: 0x4 ordinal: 0x1
    struct __anon_2968 VersionDetail; // offset: 0x4 ordinal: 0x2
  };
  ULONG ProviderVersion;        // offset: 0x8 ordinal: 0x3
  ULONG NumberOfProcessors;     // offset: 0xc ordinal: 0x4
  union _LARGE_INTEGER EndTime; // offset: 0x10 ordinal: 0x5
  ULONG TimerResolution;        // offset: 0x18 ordinal: 0x6
  ULONG MaximumFileSize;        // offset: 0x1c ordinal: 0x7
  ULONG LogFileMode;            // offset: 0x20 ordinal: 0x8
  ULONG BuffersWritten;         // offset: 0x24 ordinal: 0x9
  union {
    struct _GUID LogInstanceGuid; // offset: 0x28 ordinal: 0xa
    ULONG StartBuffers;           // offset: 0x28 ordinal: 0xb
  };
  ULONG PointerSize;                          // offset: 0x2c ordinal: 0xc
  ULONG EventsLost;                           // offset: 0x30 ordinal: 0xd
  ULONG CpuSpeedInMHz;                        // offset: 0x34 ordinal: 0xe
  WCHAR *LoggerName;                          // offset: 0x38 ordinal: 0xf
  WCHAR *LogFileName;                         // offset: 0x40 ordinal: 0x10
  struct _RTL_TIME_ZONE_INFORMATION TimeZone; // offset: 0x48 ordinal: 0x11
  union _LARGE_INTEGER BootTime;              // offset: 0xf8 ordinal: 0x12
  union _LARGE_INTEGER PerfFreq;              // offset: 0x100 ordinal: 0x13
  union _LARGE_INTEGER StartTime;             // offset: 0x108 ordinal: 0x14
  ULONG ReservedFlags;                        // offset: 0x110 ordinal: 0x15
  ULONG BuffersLost;                          // offset: 0x114 ordinal: 0x16
} _TRACE_LOGFILE_HEADER;

// 0x48 bytes (sizeof)
typedef struct _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR {
  ULONG Version;                           // offset: 0x0 ordinal: 0x0
  ULONG Size;                              // offset: 0x4 ordinal: 0x1
  ULONG CryptoIndex;                       // offset: 0x8 ordinal: 0x2
  ULONG AlgorithmId;                       // offset: 0xc ordinal: 0x3
  ULONG DataUnitSize;                      // offset: 0x10 ordinal: 0x4
  ULONG KeySize;                           // offset: 0x14 ordinal: 0x5
  UCHAR KeyHash[32];                       // offset: 0x18 ordinal: 0x6
  VOID *KeyVirtualAddress;                 // offset: 0x38 ordinal: 0x7
  union _LARGE_INTEGER KeyPhysicalAddress; // offset: 0x40 ordinal: 0x8
} _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR;

// 0x10 bytes (sizeof)
typedef union __anon_2695 {
  union _LARGE_INTEGER FileOffset; // offset: 0x0 ordinal: 0x0
  USHORT ActiveCount;              // offset: 0x0 ordinal: 0x1
  struct _LIST_ENTRY Links;        // offset: 0x0 ordinal: 0x2
} __anon_2695;

// 0x28 bytes (sizeof)
typedef struct _VACB {
  VOID *BaseAddress;                        // offset: 0x0 ordinal: 0x0
  struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x8 ordinal: 0x1
  union __anon_2695 Overlay;                // offset: 0x10 ordinal: 0x2
  struct _VACB_ARRAY_HEADER *ArrayHead;     // offset: 0x20 ordinal: 0x3
} _VACB;

typedef VOID (*__anon_2661)(VOID *, union _LARGE_INTEGER);

// 0x10 bytes (sizeof)
typedef struct _LOGGED_STREAM_CALLBACK_V1 {
  VOID *LogHandle; // offset: 0x0 ordinal: 0x0
  VOID(*FlushToLsnRoutine)
  (VOID *, union _LARGE_INTEGER); // offset: 0x8 ordinal: 0x1
} _LOGGED_STREAM_CALLBACK_V1;

// 0x20 bytes (sizeof)
typedef struct _PEP_ACPI_IO_MEMORY_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;   // offset: 0x0 ordinal: 0x0
  UCHAR Information;                   // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER MinimumAddress; // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER MaximumAddress; // offset: 0x10 ordinal: 0x3
  ULONG Alignment;                     // offset: 0x18 ordinal: 0x4
  ULONG Length;                        // offset: 0x1c ordinal: 0x5
} _PEP_ACPI_IO_MEMORY_RESOURCE;

// 0x10 bytes (sizeof)
typedef struct _PHYSICAL_MEMORY_RANGE {
  union _LARGE_INTEGER BaseAddress;   // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER NumberOfBytes; // offset: 0x8 ordinal: 0x1
} _PHYSICAL_MEMORY_RANGE;

// 0x20 bytes (sizeof)
typedef struct DEBUG_MEMORY_REQUIREMENTS {
  union _LARGE_INTEGER Start;  // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER MaxEnd; // offset: 0x8 ordinal: 0x1
  VOID *VirtualAddress;        // offset: 0x10 ordinal: 0x2
  ULONG Length;                // offset: 0x18 ordinal: 0x3
  UCHAR Cached;                // offset: 0x1c ordinal: 0x4
  UCHAR Aligned;               // offset: 0x1d ordinal: 0x5
} DEBUG_MEMORY_REQUIREMENTS;

// 0x110 bytes (sizeof)
typedef struct _DEBUG_DEVICE_DESCRIPTOR {
  ULONG Bus;       // offset: 0x0 ordinal: 0x0
  ULONG Slot;      // offset: 0x4 ordinal: 0x1
  USHORT Segment;  // offset: 0x8 ordinal: 0x2
  USHORT VendorID; // offset: 0xa ordinal: 0x3
  USHORT DeviceID; // offset: 0xc ordinal: 0x4
  UCHAR BaseClass; // offset: 0xe ordinal: 0x5
  UCHAR SubClass;  // offset: 0xf ordinal: 0x6
  UCHAR ProgIf;    // offset: 0x10 ordinal: 0x7
  union {
    UCHAR Flags;                      // offset: 0x11 ordinal: 0x8
    UCHAR DbgHalScratchAllocated : 1; // offset: 0x11 ordinal: 0x9
  };
  UCHAR DbgBarsMapped : 1;                    // offset: 0x11 ordinal: 0xa
  UCHAR DbgScratchAllocated : 1;              // offset: 0x11 ordinal: 0xb
  UCHAR DbgUncachedMemory : 1;                // offset: 0x11 ordinal: 0xc
  UCHAR DbgSynthetic : 1;                     // offset: 0x11 ordinal: 0xd
  UCHAR Initialized;                          // offset: 0x12 ordinal: 0xe
  UCHAR Configured;                           // offset: 0x13 ordinal: 0xf
  struct DEBUG_DEVICE_ADDRESS BaseAddress[6]; // offset: 0x18 ordinal: 0x10
  struct DEBUG_MEMORY_REQUIREMENTS Memory;    // offset: 0xa8 ordinal: 0x11
  ULONG Dbg2TableIndex;                       // offset: 0xc8 ordinal: 0x12
  USHORT PortType;                            // offset: 0xcc ordinal: 0x13
  USHORT PortSubtype;                         // offset: 0xce ordinal: 0x14
  VOID *OemData;                              // offset: 0xd0 ordinal: 0x15
  ULONG OemDataLength;                        // offset: 0xd8 ordinal: 0x16
  enum KD_NAMESPACE_ENUM NameSpace;           // offset: 0xdc ordinal: 0x17
  WCHAR *NameSpacePath;                       // offset: 0xe0 ordinal: 0x18
  ULONG NameSpacePathLength;                  // offset: 0xe8 ordinal: 0x19
  ULONG TransportType;                        // offset: 0xec ordinal: 0x1a
  struct _DEBUG_TRANSPORT_DATA TransportData; // offset: 0xf0 ordinal: 0x1b
  struct _DEBUG_IOMMU_EFI_DATA EfiIoMmuData;  // offset: 0x100 ordinal: 0x1c
} _DEBUG_DEVICE_DESCRIPTOR;

typedef enum KD_CALLBACK_ACTION (*__anon_3355)(
    struct _DEBUG_DEVICE_DESCRIPTOR *);

typedef LONG (*__anon_3277)(
    VOID *, struct _DEBUG_DEVICE_DESCRIPTOR *,
    enum KD_CALLBACK_ACTION (*)(struct _DEBUG_DEVICE_DESCRIPTOR *));

typedef LONG (*__anon_3240)(struct _DEBUG_DEVICE_DESCRIPTOR *);

typedef LONG (*__anon_3239)(VOID *, struct _DEBUG_DEVICE_DESCRIPTOR *);

// 0x18 bytes (sizeof)
typedef struct _CC_FILE_SIZES {
  union _LARGE_INTEGER AllocationSize;  // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER FileSize;        // offset: 0x8 ordinal: 0x1
  union _LARGE_INTEGER ValidDataLength; // offset: 0x10 ordinal: 0x2
} _CC_FILE_SIZES;

// 0x40 bytes (sizeof)
typedef struct _FACS {
  ULONG Signature;                             // offset: 0x0 ordinal: 0x0
  ULONG Length;                                // offset: 0x4 ordinal: 0x1
  ULONG HardwareSignature;                     // offset: 0x8 ordinal: 0x2
  ULONG pFirmwareWakingVector;                 // offset: 0xc ordinal: 0x3
  ULONG GlobalLock;                            // offset: 0x10 ordinal: 0x4
  ULONG Flags;                                 // offset: 0x14 ordinal: 0x5
  union _LARGE_INTEGER x_FirmwareWakingVector; // offset: 0x18 ordinal: 0x6
  UCHAR version;                               // offset: 0x20 ordinal: 0x7
  UCHAR Reserved[31];                          // offset: 0x21 ordinal: 0x8
} _FACS;

// 0x10 bytes (sizeof)
typedef struct _HAL_HV_DMA_DOMAIN_CONFIG_X64 {
  union _LARGE_INTEGER FirstLevelPageTableRoot; // offset: 0x0 ordinal: 0x0
  UCHAR TranslationEnabled;                     // offset: 0x8 ordinal: 0x1
} _HAL_HV_DMA_DOMAIN_CONFIG_X64;

// 0x20 bytes (sizeof)
typedef struct _HAL_HV_DMA_DOMAIN_CONFIG_ARM64 {
  union _LARGE_INTEGER Ttbr0; // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER Ttbr1; // offset: 0x8 ordinal: 0x1
  ULONG Mair0;                // offset: 0x10 ordinal: 0x2
  ULONG Mair1;                // offset: 0x14 ordinal: 0x3
  UCHAR InputSize0;           // offset: 0x18 ordinal: 0x4
  UCHAR InputSize1;           // offset: 0x19 ordinal: 0x5
  USHORT Asid;                // offset: 0x1a ordinal: 0x6
  UCHAR CoherentTableWalks;   // offset: 0x1c ordinal: 0x7
  UCHAR TranslationEnabled;   // offset: 0x1d ordinal: 0x8
} _HAL_HV_DMA_DOMAIN_CONFIG_ARM64;

// 0x28 bytes (sizeof)
typedef struct _HAL_HV_DMA_DOMAIN_CONFIG {
  enum _HAL_HV_DMA_DOMAIN_CONFIG_ARCH Type; // offset: 0x0 ordinal: 0x0
  union {
    struct _HAL_HV_DMA_DOMAIN_CONFIG_ARM64 Arm64; // offset: 0x8 ordinal: 0x1
    struct _HAL_HV_DMA_DOMAIN_CONFIG_X64 X64;     // offset: 0x8 ordinal: 0x2
  };
} _HAL_HV_DMA_DOMAIN_CONFIG;

typedef LONG (*__anon_1881)(struct _HAL_HV_DMA_DOMAIN_INFO *,
                            struct _HAL_HV_DMA_DOMAIN_CONFIG *);

typedef LONG (*__anon_1866)(ULONG, ULONG, union _LARGE_INTEGER, ULONG, ULONG);

// 0x18 bytes (sizeof)
typedef struct _EXT_IOMMU_RESERVED_MEMORY_REGION {
  union _LARGE_INTEGER Base;  // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER Limit; // offset: 0x8 ordinal: 0x1
  UCHAR Ignored;              // offset: 0x10 ordinal: 0x2
} _EXT_IOMMU_RESERVED_MEMORY_REGION;

// 0x10 bytes (sizeof)
typedef struct _DMA_COMMON_BUFFER_ENTRY {
  VOID *VirtualAddress;                // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER LogicalAddress; // offset: 0x8 ordinal: 0x1
} _DMA_COMMON_BUFFER_ENTRY;

// 0x40 bytes (sizeof)
typedef struct _DEVICE_DESCRIPTION {
  ULONG Version;                      // offset: 0x0 ordinal: 0x0
  UCHAR Master;                       // offset: 0x4 ordinal: 0x1
  UCHAR ScatterGather;                // offset: 0x5 ordinal: 0x2
  UCHAR DemandMode;                   // offset: 0x6 ordinal: 0x3
  UCHAR AutoInitialize;               // offset: 0x7 ordinal: 0x4
  UCHAR Dma32BitAddresses;            // offset: 0x8 ordinal: 0x5
  UCHAR IgnoreCount;                  // offset: 0x9 ordinal: 0x6
  UCHAR Reserved1;                    // offset: 0xa ordinal: 0x7
  UCHAR Dma64BitAddresses;            // offset: 0xb ordinal: 0x8
  ULONG BusNumber;                    // offset: 0xc ordinal: 0x9
  ULONG DmaChannel;                   // offset: 0x10 ordinal: 0xa
  enum _INTERFACE_TYPE InterfaceType; // offset: 0x14 ordinal: 0xb
  enum _DMA_WIDTH DmaWidth;           // offset: 0x18 ordinal: 0xc
  enum _DMA_SPEED DmaSpeed;           // offset: 0x1c ordinal: 0xd
  ULONG MaximumLength;                // offset: 0x20 ordinal: 0xe
  ULONG DmaPort;                      // offset: 0x24 ordinal: 0xf
  ULONG DmaAddressWidth;              // offset: 0x28 ordinal: 0x10
  ULONG DmaControllerInstance;        // offset: 0x2c ordinal: 0x11
  ULONG DmaRequestLine;               // offset: 0x30 ordinal: 0x12
  union _LARGE_INTEGER DeviceAddress; // offset: 0x38 ordinal: 0x13
} _DEVICE_DESCRIPTION;

// 0x10 bytes (sizeof)
typedef struct __anon_1737 {
  union _LARGE_INTEGER MinimumAddress; // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER MaximumAddress; // offset: 0x8 ordinal: 0x1
} __anon_1737;

typedef LONG (*__anon_1716)(VOID *, UCHAR, union _LARGE_INTEGER, ULONG);

typedef union _LARGE_INTEGER (*__anon_1587)(struct _DMA_ADAPTER *,
                                            struct _MDL *, VOID *, VOID *,
                                            ULONG *, UCHAR);

typedef VOID (*__anon_1583)(struct _DMA_ADAPTER *, ULONG, union _LARGE_INTEGER,
                            VOID *, UCHAR);

typedef VOID (*__anon_1565)(VOID *, ULONG, VOID *, union _LARGE_INTEGER);

// 0x40 bytes (sizeof)
typedef struct _ACPI_CACHED_TABLE {
  struct _LIST_ENTRY Links;             // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER PhysicalAddress; // offset: 0x10 ordinal: 0x1
  struct _DESCRIPTION_HEADER Header;    // offset: 0x18 ordinal: 0x2
} _ACPI_CACHED_TABLE;

// 0xc bytes (sizeof)
typedef struct _GEN_ADDR {
  UCHAR AddressSpaceID;         // offset: 0x0 ordinal: 0x0
  UCHAR BitWidth;               // offset: 0x1 ordinal: 0x1
  UCHAR BitOffset;              // offset: 0x2 ordinal: 0x2
  UCHAR AccessSize;             // offset: 0x3 ordinal: 0x3
  union _LARGE_INTEGER Address; // offset: 0x4 ordinal: 0x4
} _GEN_ADDR;

// 0x34 bytes (sizeof)
typedef struct _WHEA_GENERIC_ERROR_DESCRIPTOR {
  USHORT Type;                                 // offset: 0x0 ordinal: 0x0
  UCHAR Reserved;                              // offset: 0x2 ordinal: 0x1
  UCHAR Enabled;                               // offset: 0x3 ordinal: 0x2
  ULONG ErrStatusBlockLength;                  // offset: 0x4 ordinal: 0x3
  ULONG RelatedErrorSourceId;                  // offset: 0x8 ordinal: 0x4
  UCHAR ErrStatusAddressSpaceID;               // offset: 0xc ordinal: 0x5
  UCHAR ErrStatusAddressBitWidth;              // offset: 0xd ordinal: 0x6
  UCHAR ErrStatusAddressBitOffset;             // offset: 0xe ordinal: 0x7
  UCHAR ErrStatusAddressAccessSize;            // offset: 0xf ordinal: 0x8
  union _LARGE_INTEGER ErrStatusAddress;       // offset: 0x10 ordinal: 0x9
  struct _WHEA_NOTIFICATION_DESCRIPTOR Notify; // offset: 0x18 ordinal: 0xa
} _WHEA_GENERIC_ERROR_DESCRIPTOR;

// 0xc bytes (sizeof)
typedef struct __anon_1256 {
  union _LARGE_INTEGER Start; // offset: 0x0 ordinal: 0x0
  ULONG Length64;             // offset: 0x8 ordinal: 0x1
} __anon_1256;

// 0xc bytes (sizeof)
typedef struct __anon_1255 {
  union _LARGE_INTEGER Start; // offset: 0x0 ordinal: 0x0
  ULONG Length48;             // offset: 0x8 ordinal: 0x1
} __anon_1255;

// 0xc bytes (sizeof)
typedef struct __anon_1254 {
  union _LARGE_INTEGER Start; // offset: 0x0 ordinal: 0x0
  ULONG Length40;             // offset: 0x8 ordinal: 0x1
} __anon_1254;

// 0xc bytes (sizeof)
typedef struct __anon_1247 {
  union _LARGE_INTEGER Start; // offset: 0x0 ordinal: 0x0
  ULONG Length;               // offset: 0x8 ordinal: 0x1
} __anon_1247;

// 0x18 bytes (sizeof)
typedef struct __anon_1223 {
  ULONG Length64;                      // offset: 0x0 ordinal: 0x0
  ULONG Alignment64;                   // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER MinimumAddress; // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER MaximumAddress; // offset: 0x10 ordinal: 0x3
} __anon_1223;

// 0x18 bytes (sizeof)
typedef struct __anon_1222 {
  ULONG Length48;                      // offset: 0x0 ordinal: 0x0
  ULONG Alignment48;                   // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER MinimumAddress; // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER MaximumAddress; // offset: 0x10 ordinal: 0x3
} __anon_1222;

// 0x18 bytes (sizeof)
typedef struct __anon_1221 {
  ULONG Length40;                      // offset: 0x0 ordinal: 0x0
  ULONG Alignment40;                   // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER MinimumAddress; // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER MaximumAddress; // offset: 0x10 ordinal: 0x3
} __anon_1221;

// 0x18 bytes (sizeof)
typedef struct __anon_1214 {
  ULONG Length;                        // offset: 0x0 ordinal: 0x0
  ULONG Alignment;                     // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER MinimumAddress; // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER MaximumAddress; // offset: 0x10 ordinal: 0x3
} __anon_1214;

// 0x18 bytes (sizeof)
typedef struct _MAILSLOT_CREATE_PARAMETERS {
  ULONG MailslotQuota;              // offset: 0x0 ordinal: 0x0
  ULONG MaximumMessageSize;         // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER ReadTimeout; // offset: 0x8 ordinal: 0x2
  UCHAR TimeoutSpecified;           // offset: 0x10 ordinal: 0x3
} _MAILSLOT_CREATE_PARAMETERS;

// 0x20 bytes (sizeof)
typedef struct __anon_991 {
  struct _IO_SECURITY_CONTEXT *SecurityContext;   // offset: 0x0 ordinal: 0x0
  ULONG Options;                                  // offset: 0x8 ordinal: 0x1
  USHORT Reserved;                                // offset: 0x10 ordinal: 0x2
  USHORT ShareAccess;                             // offset: 0x12 ordinal: 0x3
  struct _MAILSLOT_CREATE_PARAMETERS *Parameters; // offset: 0x18 ordinal: 0x4
} __anon_991;

// 0x28 bytes (sizeof)
typedef struct _NAMED_PIPE_CREATE_PARAMETERS {
  ULONG NamedPipeType;                 // offset: 0x0 ordinal: 0x0
  ULONG ReadMode;                      // offset: 0x4 ordinal: 0x1
  ULONG CompletionMode;                // offset: 0x8 ordinal: 0x2
  ULONG MaximumInstances;              // offset: 0xc ordinal: 0x3
  ULONG InboundQuota;                  // offset: 0x10 ordinal: 0x4
  ULONG OutboundQuota;                 // offset: 0x14 ordinal: 0x5
  union _LARGE_INTEGER DefaultTimeout; // offset: 0x18 ordinal: 0x6
  UCHAR TimeoutSpecified;              // offset: 0x20 ordinal: 0x7
} _NAMED_PIPE_CREATE_PARAMETERS;

// 0x20 bytes (sizeof)
typedef struct __anon_990 {
  struct _IO_SECURITY_CONTEXT *SecurityContext;     // offset: 0x0 ordinal: 0x0
  ULONG Options;                                    // offset: 0x8 ordinal: 0x1
  USHORT Reserved;                                  // offset: 0x10 ordinal: 0x2
  USHORT ShareAccess;                               // offset: 0x12 ordinal: 0x3
  struct _NAMED_PIPE_CREATE_PARAMETERS *Parameters; // offset: 0x18 ordinal: 0x4
} __anon_990;

// 0x18 bytes (sizeof)
typedef struct __anon_992 {
  ULONG Length;                    // offset: 0x0 ordinal: 0x0
  ULONG Key;                       // offset: 0x8 ordinal: 0x1
  ULONG Flags;                     // offset: 0xc ordinal: 0x2
  union _LARGE_INTEGER ByteOffset; // offset: 0x10 ordinal: 0x3
} __anon_992;

// 0x38 bytes (sizeof)
typedef struct _FILE_NETWORK_OPEN_INFORMATION {
  union _LARGE_INTEGER CreationTime;   // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER LastAccessTime; // offset: 0x8 ordinal: 0x1
  union _LARGE_INTEGER LastWriteTime;  // offset: 0x10 ordinal: 0x2
  union _LARGE_INTEGER ChangeTime;     // offset: 0x18 ordinal: 0x3
  union _LARGE_INTEGER AllocationSize; // offset: 0x20 ordinal: 0x4
  union _LARGE_INTEGER EndOfFile;      // offset: 0x28 ordinal: 0x5
  ULONG FileAttributes;                // offset: 0x30 ordinal: 0x6
} _FILE_NETWORK_OPEN_INFORMATION;

typedef UCHAR (*__anon_789)(struct _IRP *,
                            struct _FILE_NETWORK_OPEN_INFORMATION *,
                            struct _DEVICE_OBJECT *);

// 0x18 bytes (sizeof)
typedef struct _FILE_STANDARD_INFORMATION {
  union _LARGE_INTEGER AllocationSize; // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER EndOfFile;      // offset: 0x8 ordinal: 0x1
  ULONG NumberOfLinks;                 // offset: 0x10 ordinal: 0x2
  UCHAR DeletePending;                 // offset: 0x14 ordinal: 0x3
  UCHAR Directory;                     // offset: 0x15 ordinal: 0x4
} _FILE_STANDARD_INFORMATION;

// 0x28 bytes (sizeof)
typedef struct _FILE_BASIC_INFORMATION {
  union _LARGE_INTEGER CreationTime;   // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER LastAccessTime; // offset: 0x8 ordinal: 0x1
  union _LARGE_INTEGER LastWriteTime;  // offset: 0x10 ordinal: 0x2
  union _LARGE_INTEGER ChangeTime;     // offset: 0x18 ordinal: 0x3
  ULONG FileAttributes;                // offset: 0x20 ordinal: 0x4
} _FILE_BASIC_INFORMATION;

// 0x18 bytes (sizeof)
typedef struct _PNP_PROBLEM_CODE_LOG_ENTRY {
  union _LARGE_INTEGER Timestamp;                 // offset: 0x0 ordinal: 0x0
  enum _PNP_PROBLEM_CODE_LOG_OPERATION Operation; // offset: 0x8 ordinal: 0x1
  ULONG ProblemCode;                              // offset: 0xc ordinal: 0x2
  LONG ProblemStatus;                             // offset: 0x10 ordinal: 0x3
} _PNP_PROBLEM_CODE_LOG_ENTRY;

typedef LONG (*__anon_3983)(LONG, union _LARGE_INTEGER *, struct _MDL *);

typedef LONG (*__anon_3980)(LONG, union _LARGE_INTEGER *, struct _MDL *,
                            VOID *);

typedef LONG (*__anon_3979)(union _LARGE_INTEGER *, struct _MDL *);

typedef UCHAR (*__anon_3419)(struct _BUS_HANDLER *, struct _BUS_HANDLER *,
                             union _LARGE_INTEGER, ULONG *,
                             union _LARGE_INTEGER *);

typedef LONG (*__anon_3274)(union _LARGE_INTEGER *);

typedef UCHAR (*__anon_3235)(enum _INTERFACE_TYPE, ULONG, union _LARGE_INTEGER,
                             ULONG *, union _LARGE_INTEGER *);

typedef LONG (*__anon_2435)(struct _KENLISTMENT *, VOID *, VOID *, ULONG,
                            union _LARGE_INTEGER *, ULONG, VOID *);

typedef VOID *(*__anon_1610)(struct _DMA_ADAPTER *, union _LARGE_INTEGER *,
                             union _LARGE_INTEGER *, ULONG, ULONG,
                             enum _MEMORY_CACHING_TYPE *, ULONG,
                             union _LARGE_INTEGER *);

typedef LONG (*__anon_1606)(struct _DMA_ADAPTER *, VOID *,
                            union _LARGE_INTEGER *, ULONG, ULONG,
                            enum _MEMORY_CACHING_TYPE *, ULONG,
                            union _LARGE_INTEGER *, VOID **);

typedef VOID *(*__anon_1597)(struct _DMA_ADAPTER *, union _LARGE_INTEGER *,
                             ULONG, union _LARGE_INTEGER *, UCHAR, ULONG);

typedef VOID *(*__anon_1582)(struct _DMA_ADAPTER *, ULONG,
                             union _LARGE_INTEGER *, UCHAR);

// 0x18 bytes (sizeof)
typedef struct __anon_1002 {
  union _LARGE_INTEGER *Length;    // offset: 0x0 ordinal: 0x0
  ULONG Key;                       // offset: 0x8 ordinal: 0x1
  union _LARGE_INTEGER ByteOffset; // offset: 0x10 ordinal: 0x2
} __anon_1002;

typedef UCHAR (*__anon_787)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                            struct _MDL *, struct _DEVICE_OBJECT *);

// 0x10 bytes (sizeof)
typedef struct _ETW_REF_CLOCK {
  union _LARGE_INTEGER StartTime;      // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER StartPerfClock; // offset: 0x8 ordinal: 0x1
} _ETW_REF_CLOCK;

// 0x10 bytes (sizeof)
typedef struct _ETW_LAST_ENABLE_INFO {
  union _LARGE_INTEGER EnableFlags; // offset: 0x0 ordinal: 0x0
  USHORT LoggerId;                  // offset: 0x8 ordinal: 0x1
  UCHAR Level;                      // offset: 0xa ordinal: 0x2
  UCHAR Enabled : 1;                // offset: 0xb ordinal: 0x3
  UCHAR InternalFlag : 7;           // offset: 0xb ordinal: 0x4
} _ETW_LAST_ENABLE_INFO;

// 0x270 bytes (sizeof)
typedef struct _SILO_USER_SHARED_DATA {
  ULONG ServiceSessionId;                          // offset: 0x0 ordinal: 0x0
  ULONG ActiveConsoleId;                           // offset: 0x4 ordinal: 0x1
  LONGLONG ConsoleSessionForegroundProcessId;      // offset: 0x8 ordinal: 0x2
  enum _NT_PRODUCT_TYPE NtProductType;             // offset: 0x10 ordinal: 0x3
  ULONG SuiteMask;                                 // offset: 0x14 ordinal: 0x4
  ULONG SharedUserSessionId;                       // offset: 0x18 ordinal: 0x5
  UCHAR IsMultiSessionSku;                         // offset: 0x1c ordinal: 0x6
  UCHAR IsStateSeparationEnabled;                  // offset: 0x1d ordinal: 0x7
  WCHAR NtSystemRoot[260];                         // offset: 0x1e ordinal: 0x8
  USHORT UserModeGlobalLogger[16];                 // offset: 0x226 ordinal: 0x9
  ULONG TimeZoneId;                                // offset: 0x248 ordinal: 0xa
  LONG TimeZoneBiasStamp;                          // offset: 0x24c ordinal: 0xb
  struct _KSYSTEM_TIME TimeZoneBias;               // offset: 0x250 ordinal: 0xc
  union _LARGE_INTEGER TimeZoneBiasEffectiveStart; // offset: 0x260 ordinal: 0xd
  union _LARGE_INTEGER TimeZoneBiasEffectiveEnd;   // offset: 0x268 ordinal: 0xe
} _SILO_USER_SHARED_DATA;

// 0x10 bytes (sizeof)
typedef struct _LEAP_SECOND_DATA {
  UCHAR Enabled;                // offset: 0x0 ordinal: 0x0
  ULONG Count;                  // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER Data[1]; // offset: 0x8 ordinal: 0x2
} _LEAP_SECOND_DATA;

// 0x50 bytes (sizeof)
typedef struct _SEP_RM_LSA_CONNECTION_STATE {
  VOID *LsaProcessHandle;                         // offset: 0x0 ordinal: 0x0
  VOID *LsaCommandPortHandle;                     // offset: 0x8 ordinal: 0x1
  VOID *SepRmThreadHandle;                        // offset: 0x10 ordinal: 0x2
  VOID *RmCommandPortHandle;                      // offset: 0x18 ordinal: 0x3
  VOID *RmCommandServerPortHandle;                // offset: 0x20 ordinal: 0x4
  VOID *LsaCommandPortSectionHandle;              // offset: 0x28 ordinal: 0x5
  union _LARGE_INTEGER LsaCommandPortSectionSize; // offset: 0x30 ordinal: 0x6
  VOID *LsaViewPortMemory;                        // offset: 0x38 ordinal: 0x7
  VOID *RmViewPortMemory;                         // offset: 0x40 ordinal: 0x8
  LONG LsaCommandPortMemoryDelta;                 // offset: 0x48 ordinal: 0x9
  UCHAR LsaCommandPortActive;                     // offset: 0x4c ordinal: 0xa
} _SEP_RM_LSA_CONNECTION_STATE;

typedef LONG (*__anon_20)(WCHAR *, ULONG, VOID *, ULONG, VOID *, VOID *);

// 0x38 bytes (sizeof)
typedef struct _RTL_QUERY_REGISTRY_TABLE {
  LONG(*QueryRoutine)
  (WCHAR *, ULONG, VOID *, ULONG, VOID *, VOID *); // offset: 0x0 ordinal: 0x0
  ULONG Flags;                                     // offset: 0x8 ordinal: 0x1
  WCHAR *Name;                                     // offset: 0x10 ordinal: 0x2
  VOID *EntryContext;                              // offset: 0x18 ordinal: 0x3
  ULONG DefaultType;                               // offset: 0x20 ordinal: 0x4
  VOID *DefaultData;                               // offset: 0x28 ordinal: 0x5
  ULONG DefaultLength;                             // offset: 0x30 ordinal: 0x6
} _RTL_QUERY_REGISTRY_TABLE;

// 0x8 bytes (sizeof)
typedef struct LIST_ENTRY32 {
  ULONG Flink; // offset: 0x0 ordinal: 0x0
  ULONG Blink; // offset: 0x4 ordinal: 0x1
} LIST_ENTRY32;

// 0x18 bytes (sizeof)
typedef struct _ACTIVATION_CONTEXT_STACK32 {
  ULONG ActiveFrame;                  // offset: 0x0 ordinal: 0x0
  struct LIST_ENTRY32 FrameListCache; // offset: 0x4 ordinal: 0x1
  ULONG Flags;                        // offset: 0xc ordinal: 0x2
  ULONG NextCookieSequenceNumber;     // offset: 0x10 ordinal: 0x3
  ULONG StackId;                      // offset: 0x14 ordinal: 0x4
} _ACTIVATION_CONTEXT_STACK32;

// 0x38 bytes (sizeof)
typedef struct _BLOB_TYPE {
  enum _BLOB_ID ResourceId;         // offset: 0x0 ordinal: 0x0
  ULONG PoolTag;                    // offset: 0x4 ordinal: 0x1
  ULONG LookasideIndex;             // offset: 0x8 ordinal: 0x2
  ULONG Flags;                      // offset: 0xc ordinal: 0x3
  struct _BLOB_COUNTERS *Counters;  // offset: 0x10 ordinal: 0x4
  VOID (*CleanupProcedure)(VOID *); // offset: 0x18 ordinal: 0x5
  VOID (*DeleteProcedure)(VOID *);  // offset: 0x20 ordinal: 0x6
  LONG (*DestroyProcedure)(VOID *); // offset: 0x28 ordinal: 0x7
  ULONGLONG UsualSize;              // offset: 0x30 ordinal: 0x8
} _BLOB_TYPE;

// 0x40 bytes (sizeof)
typedef struct _MI_TRIAGE_DUMP_DATA {
  ULONGLONG BadPageCount;                 // offset: 0x0 ordinal: 0x0
  LONG BadPagesDetected;                  // offset: 0x8 ordinal: 0x1
  LONG ZeroedPageSingleBitErrorsDetected; // offset: 0xc ordinal: 0x2
  LONG ScrubPasses;                       // offset: 0x10 ordinal: 0x3
  LONG ScrubBadPagesFound;                // offset: 0x14 ordinal: 0x4
  ULONG PageHashErrors;                   // offset: 0x18 ordinal: 0x5
  ULONGLONG FeatureBits;                  // offset: 0x20 ordinal: 0x6
  ULONG TimeZoneId;                       // offset: 0x28 ordinal: 0x7
  struct _MI_FLAGS Flags;                 // offset: 0x2c ordinal: 0x8
  VOID *VsmConnection;                    // offset: 0x38 ordinal: 0x9
} _MI_TRIAGE_DUMP_DATA;

// 0x58 bytes (sizeof)
typedef struct _THERMAL_INFORMATION {
  ULONG ThermalStamp;         // offset: 0x0 ordinal: 0x0
  ULONG ThermalConstant1;     // offset: 0x4 ordinal: 0x1
  ULONG ThermalConstant2;     // offset: 0x8 ordinal: 0x2
  ULONGLONG Processors;       // offset: 0x10 ordinal: 0x3
  ULONG SamplingPeriod;       // offset: 0x18 ordinal: 0x4
  ULONG CurrentTemperature;   // offset: 0x1c ordinal: 0x5
  ULONG PassiveTripPoint;     // offset: 0x20 ordinal: 0x6
  ULONG CriticalTripPoint;    // offset: 0x24 ordinal: 0x7
  UCHAR ActiveTripPointCount; // offset: 0x28 ordinal: 0x8
  ULONG ActiveTripPoint[10];  // offset: 0x2c ordinal: 0x9
} _THERMAL_INFORMATION;

// 0x38 bytes (sizeof)
typedef struct _RTLP_RANGE_LIST_ENTRY {
  ULONGLONG Start; // offset: 0x0 ordinal: 0x0
  ULONGLONG End;   // offset: 0x8 ordinal: 0x1
  union {
    struct __anon_4047 Allocated; // offset: 0x10 ordinal: 0x2
    struct __anon_4048 Merged;    // offset: 0x10 ordinal: 0x3
  };
  UCHAR Attributes;             // offset: 0x20 ordinal: 0x4
  UCHAR PublicFlags;            // offset: 0x21 ordinal: 0x5
  USHORT PrivateFlags;          // offset: 0x22 ordinal: 0x6
  struct _LIST_ENTRY ListEntry; // offset: 0x28 ordinal: 0x7
} _RTLP_RANGE_LIST_ENTRY;

// 0x30 bytes (sizeof)
typedef struct _HEAP_UCR_DESCRIPTOR {
  struct _LIST_ENTRY ListEntry;    // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY SegmentEntry; // offset: 0x10 ordinal: 0x1
  VOID *Address;                   // offset: 0x20 ordinal: 0x2
  ULONGLONG Size;                  // offset: 0x28 ordinal: 0x3
} _HEAP_UCR_DESCRIPTOR;

// 0xf0 bytes (sizeof)
typedef struct _ETW_WMITRACE_WORK {
  ULONG LoggerId;        // offset: 0x0 ordinal: 0x0
  ULONG SiloSessionId;   // offset: 0x4 ordinal: 0x1
  CHAR LoggerName[65];   // offset: 0x8 ordinal: 0x2
  CHAR FileName[129];    // offset: 0x49 ordinal: 0x3
  ULONG MaximumFileSize; // offset: 0xcc ordinal: 0x4
  ULONG MinBuffers;      // offset: 0xd0 ordinal: 0x5
  ULONG MaxBuffers;      // offset: 0xd4 ordinal: 0x6
  ULONG BufferSize;      // offset: 0xd8 ordinal: 0x7
  ULONG Mode;            // offset: 0xdc ordinal: 0x8
  ULONG FlushTimer;      // offset: 0xe0 ordinal: 0x9
  ULONGLONG MatchAny;    // offset: 0x8 ordinal: 0xa
  ULONGLONG MatchAll;    // offset: 0x10 ordinal: 0xb
  ULONG EnableProperty;  // offset: 0x18 ordinal: 0xc
  struct _GUID Guid;     // offset: 0x1c ordinal: 0xd
  UCHAR Level;           // offset: 0x2c ordinal: 0xe
  LONG Status;           // offset: 0xe8 ordinal: 0xf
} _ETW_WMITRACE_WORK;

// 0x18 bytes (sizeof)
typedef struct _KTIMER2_COLLECTION {
  struct _RTL_RB_TREE Tree; // offset: 0x0 ordinal: 0x0
  ULONGLONG NextDueTime;    // offset: 0x10 ordinal: 0x1
} _KTIMER2_COLLECTION;

// 0x8 bytes (sizeof)
typedef struct _MI_VAD_SEQUENTIAL_INFO {
  ULONGLONG Length : 12; // offset: 0x0 ordinal: 0x0
  ULONGLONG Vpn : 52;    // offset: 0x0 ordinal: 0x1
} _MI_VAD_SEQUENTIAL_INFO;

// 0x408 bytes (sizeof)
typedef struct _CALL_PERFORMANCE_DATA {
  ULONGLONG SpinLock;               // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY HashTable[64]; // offset: 0x8 ordinal: 0x1
} _CALL_PERFORMANCE_DATA;

// 0x30 bytes (sizeof)
typedef struct _CRITICAL_PROCESS_EXCEPTION_DATA {
  struct _GUID ReportId;             // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING ModuleName; // offset: 0x10 ordinal: 0x1
  ULONG ModuleTimestamp;             // offset: 0x20 ordinal: 0x2
  ULONG ModuleSize;                  // offset: 0x24 ordinal: 0x3
  ULONGLONG Offset;                  // offset: 0x28 ordinal: 0x4
} _CRITICAL_PROCESS_EXCEPTION_DATA;

// 0x80 bytes (sizeof)
typedef struct _PTE_TRACKER {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  struct _MDL *Mdl;             // offset: 0x10 ordinal: 0x1
  ULONGLONG Count;              // offset: 0x18 ordinal: 0x2
  VOID *SystemVa;               // offset: 0x20 ordinal: 0x3
  VOID *StartVa;                // offset: 0x28 ordinal: 0x4
  ULONG Offset;                 // offset: 0x30 ordinal: 0x5
  ULONG Length;                 // offset: 0x34 ordinal: 0x6
  ULONGLONG Page;               // offset: 0x38 ordinal: 0x7
  ULONG IoMapping : 1;          // offset: 0x40 ordinal: 0x8
  ULONG Matched : 1;            // offset: 0x40 ordinal: 0x9
  ULONG CacheAttribute : 2;     // offset: 0x40 ordinal: 0xa
  ULONG GuardPte : 1;           // offset: 0x40 ordinal: 0xb
  ULONG Spare : 27;             // offset: 0x40 ordinal: 0xc
  VOID *StackTrace[7];          // offset: 0x48 ordinal: 0xd
} _PTE_TRACKER;

// 0x8180 bytes (sizeof)
typedef struct _VI_DEADLOCK_GLOBALS {
  LONGLONG TimeAcquire;                 // offset: 0x0 ordinal: 0x0
  LONGLONG TimeRelease;                 // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY *ResourceDatabase; // offset: 0x10 ordinal: 0x2
  ULONGLONG ResourceDatabaseCount;      // offset: 0x18 ordinal: 0x3
  struct _VF_ADDRESS_RANGE
      ResourceAddressRange[1023];     // offset: 0x20 ordinal: 0x4
  struct _LIST_ENTRY *ThreadDatabase; // offset: 0x4010 ordinal: 0x5
  ULONGLONG ThreadDatabaseCount;      // offset: 0x4018 ordinal: 0x6
  struct _VF_ADDRESS_RANGE
      ThreadAddressRange[1023];              // offset: 0x4020 ordinal: 0x7
  ULONG AllocationFailures;                  // offset: 0x8010 ordinal: 0x8
  ULONG NodesTrimmedBasedOnAge;              // offset: 0x8014 ordinal: 0x9
  ULONG NodesTrimmedBasedOnCount;            // offset: 0x8018 ordinal: 0xa
  ULONG NodesSearched;                       // offset: 0x801c ordinal: 0xb
  ULONG MaxNodesSearched;                    // offset: 0x8020 ordinal: 0xc
  ULONG SequenceNumber;                      // offset: 0x8024 ordinal: 0xd
  ULONG RecursionDepthLimit;                 // offset: 0x8028 ordinal: 0xe
  ULONG SearchedNodesLimit;                  // offset: 0x802c ordinal: 0xf
  ULONG DepthLimitHits;                      // offset: 0x8030 ordinal: 0x10
  ULONG SearchLimitHits;                     // offset: 0x8034 ordinal: 0x11
  ULONG StackLimitHits;                      // offset: 0x8038 ordinal: 0x12
  ULONG ABC_ACB_Skipped;                     // offset: 0x803c ordinal: 0x13
  ULONG OutOfOrderReleases;                  // offset: 0x8040 ordinal: 0x14
  ULONG NodesReleasedOutOfOrder;             // offset: 0x8044 ordinal: 0x15
  ULONG TotalReleases;                       // offset: 0x8048 ordinal: 0x16
  ULONG RootNodesDeleted;                    // offset: 0x804c ordinal: 0x17
  ULONG ForgetHistoryCounter;                // offset: 0x8050 ordinal: 0x18
  VOID *Instigator;                          // offset: 0x8058 ordinal: 0x19
  ULONG NumberOfParticipants;                // offset: 0x8060 ordinal: 0x1a
  struct _VI_DEADLOCK_NODE *Participant[32]; // offset: 0x8068 ordinal: 0x1b
  LONG ChildrenCountWatermark;               // offset: 0x8168 ordinal: 0x1c
  enum _KERNEL_STACK_LIMITS StackType;       // offset: 0x816c ordinal: 0x1d
  ULONGLONG StackLowLimit;                   // offset: 0x8170 ordinal: 0x1e
  ULONGLONG StackHighLimit;                  // offset: 0x8178 ordinal: 0x1f
} _VI_DEADLOCK_GLOBALS;

// 0x68 bytes (sizeof)
typedef struct _FAST_ERESOURCE_INTERNAL {
  struct _LIST_ENTRY SystemResourcesList; // offset: 0x0 ordinal: 0x0
  VOID *ReservedPointer;                  // offset: 0x10 ordinal: 0x1
  SHORT ActiveCount;                      // offset: 0x18 ordinal: 0x2
  USHORT Flag;                            // offset: 0x1a ordinal: 0x3
  struct _KWAIT_CHAIN SharedWaiters;      // offset: 0x20 ordinal: 0x4
  struct _KWAIT_CHAIN ExclusiveWaiters;   // offset: 0x28 ordinal: 0x5
  struct _LIST_ENTRY OwnerEntryListHead;  // offset: 0x30 ordinal: 0x6
  ULONG ActiveEntries;                    // offset: 0x40 ordinal: 0x7
  ULONG ContentionCount;                  // offset: 0x44 ordinal: 0x8
  ULONG NumberOfSharedWaiters;            // offset: 0x48 ordinal: 0x9
  ULONG NumberOfExclusiveWaiters;         // offset: 0x4c ordinal: 0xa
  VOID *ReservedWin64OnlyPointer;         // offset: 0x50 ordinal: 0xb
  union {
    VOID *Address;                   // offset: 0x58 ordinal: 0xc
    ULONGLONG CreatorBackTraceIndex; // offset: 0x58 ordinal: 0xd
  };
  ULONGLONG SpinLock; // offset: 0x60 ordinal: 0xe
} _FAST_ERESOURCE_INTERNAL;

// 0x70 bytes (sizeof)
typedef struct _POP_IO_INFO {
  struct _MDL *DumpMdl;            // offset: 0x0 ordinal: 0x0
  enum _POP_IO_STATUS IoStatus;    // offset: 0x8 ordinal: 0x1
  ULONGLONG IoStartCount;          // offset: 0x10 ordinal: 0x2
  ULONGLONG IoBytesCompleted;      // offset: 0x18 ordinal: 0x3
  ULONGLONG IoBytesInProgress;     // offset: 0x20 ordinal: 0x4
  ULONGLONG RequestSize;           // offset: 0x28 ordinal: 0x5
  union _LARGE_INTEGER IoLocation; // offset: 0x30 ordinal: 0x6
  ULONGLONG FileOffset;            // offset: 0x38 ordinal: 0x7
  VOID *Buffer;                    // offset: 0x40 ordinal: 0x8
  UCHAR AsyncCapable;              // offset: 0x48 ordinal: 0x9
  ULONGLONG BytesToRead;           // offset: 0x50 ordinal: 0xa
  ULONG Pages;                     // offset: 0x58 ordinal: 0xb
  ULONGLONG HighestChecksumIndex;  // offset: 0x60 ordinal: 0xc
  USHORT PreviousChecksum;         // offset: 0x68 ordinal: 0xd
} _POP_IO_INFO;

// 0x28 bytes (sizeof)
typedef struct _DIAGNOSTIC_BUFFER {
  ULONGLONG Size;                    // offset: 0x0 ordinal: 0x0
  enum _REQUESTER_TYPE CallerType;   // offset: 0x8 ordinal: 0x1
  ULONGLONG ProcessImageNameOffset;  // offset: 0x10 ordinal: 0x2
  ULONG ProcessId;                   // offset: 0x18 ordinal: 0x3
  ULONG ServiceTag;                  // offset: 0x1c ordinal: 0x4
  ULONGLONG DeviceDescriptionOffset; // offset: 0x10 ordinal: 0x5
  ULONGLONG DevicePathOffset;        // offset: 0x18 ordinal: 0x6
  ULONGLONG ReasonOffset;            // offset: 0x20 ordinal: 0x7
} _DIAGNOSTIC_BUFFER;

// 0x18 bytes (sizeof)
typedef struct __anon_3948 {
  ULONGLONG RequestedTime;              // offset: 0x0 ordinal: 0x0
  ULONGLONG ProgrammedTime;             // offset: 0x8 ordinal: 0x1
  struct _DIAGNOSTIC_BUFFER *TimerInfo; // offset: 0x10 ordinal: 0x2
} __anon_3948;

// 0x8 bytes (sizeof)
typedef union _PS_INTERLOCKED_TIMER_DELAY_VALUES {
  ULONGLONG DelayMs : 30;            // offset: 0x0 ordinal: 0x0
  ULONGLONG CoalescingWindowMs : 30; // offset: 0x0 ordinal: 0x1
  ULONGLONG Reserved : 1;            // offset: 0x0 ordinal: 0x2
  ULONGLONG NewTimerWheel : 1;       // offset: 0x0 ordinal: 0x3
  ULONGLONG Retry : 1;               // offset: 0x0 ordinal: 0x4
  ULONGLONG Locked : 1;              // offset: 0x0 ordinal: 0x5
  ULONGLONG All;                     // offset: 0x0 ordinal: 0x6
} _PS_INTERLOCKED_TIMER_DELAY_VALUES;

// 0x48 bytes (sizeof)
typedef struct _ETWP_NOTIFICATION_HEADER {
  enum _ETW_NOTIFICATION_TYPE NotificationType; // offset: 0x0 ordinal: 0x0
  ULONG NotificationSize;                       // offset: 0x4 ordinal: 0x1
  LONG RefCount;                                // offset: 0x8 ordinal: 0x2
  UCHAR ReplyRequested;                         // offset: 0xc ordinal: 0x3
  union {
    ULONG ReplyIndex; // offset: 0x10 ordinal: 0x4
    ULONG Timeout;    // offset: 0x10 ordinal: 0x5
  };
  union {
    ULONG ReplyCount;    // offset: 0x14 ordinal: 0x6
    ULONG NotifyeeCount; // offset: 0x14 ordinal: 0x7
  };
  union {
    ULONGLONG ReplyHandle; // offset: 0x18 ordinal: 0x8
    VOID *ReplyObject;     // offset: 0x18 ordinal: 0x9
    ULONG RegIndex;        // offset: 0x18 ordinal: 0xa
  };
  ULONG TargetPID;              // offset: 0x20 ordinal: 0xb
  ULONG SourcePID;              // offset: 0x24 ordinal: 0xc
  struct _GUID DestinationGuid; // offset: 0x28 ordinal: 0xd
  struct _GUID SourceGuid;      // offset: 0x38 ordinal: 0xe
} _ETWP_NOTIFICATION_HEADER;

// 0x8 bytes (sizeof)
typedef struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES {
  ULONGLONG NumberOfPtes : 6;   // offset: 0x0 ordinal: 0x0
  ULONGLONG PartitionId : 10;   // offset: 0x0 ordinal: 0x1
  ULONGLONG SectionOffset : 46; // offset: 0x0 ordinal: 0x2
  ULONGLONG ViewState : 2;      // offset: 0x0 ordinal: 0x3
} _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES;

// 0x20 bytes (sizeof)
typedef struct _VI_POOL_ENTRY_INUSE {
  VOID *VirtualAddress;    // offset: 0x0 ordinal: 0x0
  VOID *CallingAddress;    // offset: 0x8 ordinal: 0x1
  ULONGLONG NumberOfBytes; // offset: 0x10 ordinal: 0x2
  ULONGLONG Tag;           // offset: 0x18 ordinal: 0x3
} _VI_POOL_ENTRY_INUSE;

// 0x18 bytes (sizeof)
typedef struct _VI_POOL_PAGE_HEADER {
  struct _SLIST_ENTRY *NextPage; // offset: 0x0 ordinal: 0x0
  VOID *VerifierEntry;           // offset: 0x8 ordinal: 0x1
  ULONGLONG Signature;           // offset: 0x10 ordinal: 0x2
} _VI_POOL_PAGE_HEADER;

// 0x20 bytes (sizeof)
typedef struct _VI_POOL_ENTRY {
  union {
    struct _VI_POOL_PAGE_HEADER PageHeader; // offset: 0x0 ordinal: 0x0
    struct _VI_POOL_ENTRY_INUSE InUse;      // offset: 0x0 ordinal: 0x1
    struct _SLIST_ENTRY *NextFree;          // offset: 0x0 ordinal: 0x2
  };
} _VI_POOL_ENTRY;

// 0x8 bytes (sizeof)
typedef struct _VI_VERIFIER_POOL_HEADER {
  struct _VI_POOL_ENTRY *VerifierPoolEntry; // offset: 0x0 ordinal: 0x0
} _VI_VERIFIER_POOL_HEADER;

// 0x8 bytes (sizeof)
typedef union _WHEA_ERROR_STATUS {
  ULONGLONG ErrorStatus;    // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved1 : 8;  // offset: 0x0 ordinal: 0x1
  ULONGLONG ErrorType : 8;  // offset: 0x0 ordinal: 0x2
  ULONGLONG Address : 1;    // offset: 0x0 ordinal: 0x3
  ULONGLONG Control : 1;    // offset: 0x0 ordinal: 0x4
  ULONGLONG Data : 1;       // offset: 0x0 ordinal: 0x5
  ULONGLONG Responder : 1;  // offset: 0x0 ordinal: 0x6
  ULONGLONG Requester : 1;  // offset: 0x0 ordinal: 0x7
  ULONGLONG FirstError : 1; // offset: 0x0 ordinal: 0x8
  ULONGLONG Overflow : 1;   // offset: 0x0 ordinal: 0x9
  ULONGLONG Reserved2 : 41; // offset: 0x0 ordinal: 0xa
} _WHEA_ERROR_STATUS;

// 0x8 bytes (sizeof)
typedef union _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
  ULONGLONG ErrorStatus : 1;         // offset: 0x0 ordinal: 0x0
  ULONGLONG PhysicalAddress : 1;     // offset: 0x0 ordinal: 0x1
  ULONGLONG PhysicalAddressMask : 1; // offset: 0x0 ordinal: 0x2
  ULONGLONG Node : 1;                // offset: 0x0 ordinal: 0x3
  ULONGLONG Card : 1;                // offset: 0x0 ordinal: 0x4
  ULONGLONG Module : 1;              // offset: 0x0 ordinal: 0x5
  ULONGLONG Bank : 1;                // offset: 0x0 ordinal: 0x6
  ULONGLONG Device : 1;              // offset: 0x0 ordinal: 0x7
  ULONGLONG Row : 1;                 // offset: 0x0 ordinal: 0x8
  ULONGLONG Column : 1;              // offset: 0x0 ordinal: 0x9
  ULONGLONG BitPosition : 1;         // offset: 0x0 ordinal: 0xa
  ULONGLONG RequesterId : 1;         // offset: 0x0 ordinal: 0xb
  ULONGLONG ResponderId : 1;         // offset: 0x0 ordinal: 0xc
  ULONGLONG TargetId : 1;            // offset: 0x0 ordinal: 0xd
  ULONGLONG ErrorType : 1;           // offset: 0x0 ordinal: 0xe
  ULONGLONG RankNumber : 1;          // offset: 0x0 ordinal: 0xf
  ULONGLONG CardHandle : 1;          // offset: 0x0 ordinal: 0x10
  ULONGLONG ModuleHandle : 1;        // offset: 0x0 ordinal: 0x11
  ULONGLONG ExtendedRow : 1;         // offset: 0x0 ordinal: 0x12
  ULONGLONG BankGroup : 1;           // offset: 0x0 ordinal: 0x13
  ULONGLONG BankAddress : 1;         // offset: 0x0 ordinal: 0x14
  ULONGLONG ChipIdentification : 1;  // offset: 0x0 ordinal: 0x15
  ULONGLONG Reserved : 42;           // offset: 0x0 ordinal: 0x16
  ULONGLONG ValidBits;               // offset: 0x0 ordinal: 0x17
} _WHEA_MEMORY_ERROR_SECTION_VALIDBITS;

// 0x50 bytes (sizeof)
typedef struct _WHEA_MEMORY_ERROR_SECTION {
  union _WHEA_MEMORY_ERROR_SECTION_VALIDBITS
      ValidBits;                        // offset: 0x0 ordinal: 0x0
  union _WHEA_ERROR_STATUS ErrorStatus; // offset: 0x8 ordinal: 0x1
  ULONGLONG PhysicalAddress;            // offset: 0x10 ordinal: 0x2
  ULONGLONG PhysicalAddressMask;        // offset: 0x18 ordinal: 0x3
  USHORT Node;                          // offset: 0x20 ordinal: 0x4
  USHORT Card;                          // offset: 0x22 ordinal: 0x5
  USHORT Module;                        // offset: 0x24 ordinal: 0x6
  USHORT Bank;                          // offset: 0x26 ordinal: 0x7
  USHORT Device;                        // offset: 0x28 ordinal: 0x8
  USHORT Row;                           // offset: 0x2a ordinal: 0x9
  USHORT Column;                        // offset: 0x2c ordinal: 0xa
  USHORT BitPosition;                   // offset: 0x2e ordinal: 0xb
  ULONGLONG RequesterId;                // offset: 0x30 ordinal: 0xc
  ULONGLONG ResponderId;                // offset: 0x38 ordinal: 0xd
  ULONGLONG TargetId;                   // offset: 0x40 ordinal: 0xe
  UCHAR ErrorType;                      // offset: 0x48 ordinal: 0xf
  UCHAR Extended;                       // offset: 0x49 ordinal: 0x10
  USHORT RankNumber;                    // offset: 0x4a ordinal: 0x11
  USHORT CardHandle;                    // offset: 0x4c ordinal: 0x12
  USHORT ModuleHandle;                  // offset: 0x4e ordinal: 0x13
} _WHEA_MEMORY_ERROR_SECTION;

// 0x10 bytes (sizeof)
typedef struct _TraceLoggingMetadata_t {
  ULONG Signature; // offset: 0x0 ordinal: 0x0
  USHORT Size;     // offset: 0x4 ordinal: 0x1
  UCHAR Version;   // offset: 0x6 ordinal: 0x2
  UCHAR Flags;     // offset: 0x7 ordinal: 0x3
  ULONGLONG Magic; // offset: 0x8 ordinal: 0x4
} _TraceLoggingMetadata_t;

// 0x30 bytes (sizeof)
typedef struct _WNF_DELIVERY_DESCRIPTOR {
  ULONGLONG SubscriptionId;         // offset: 0x0 ordinal: 0x0
  struct _WNF_STATE_NAME StateName; // offset: 0x8 ordinal: 0x1
  ULONG ChangeStamp;                // offset: 0x10 ordinal: 0x2
  ULONG StateDataSize;              // offset: 0x14 ordinal: 0x3
  ULONG EventMask;                  // offset: 0x18 ordinal: 0x4
  struct _WNF_TYPE_ID TypeId;       // offset: 0x1c ordinal: 0x5
  ULONG StateDataOffset;            // offset: 0x2c ordinal: 0x6
} _WNF_DELIVERY_DESCRIPTOR;

// 0x8 bytes (sizeof)
typedef union _PNP_DEVICE_ACTION_REQUEST_ARGUMENT {
  struct __anon_3852 ClearProblem;                // offset: 0x0 ordinal: 0x0
  union _PNP_REBALANCE_FLAGS Rebalance;           // offset: 0x0 ordinal: 0x1
  struct __anon_3853 ReenumerateDeviceOnly;       // offset: 0x0 ordinal: 0x2
  struct __anon_3854 ResourceRequirementsChanged; // offset: 0x0 ordinal: 0x3
  struct __anon_3855 RequestDeviceReset;          // offset: 0x0 ordinal: 0x4
  struct __anon_3856 SetDeviceProblem;            // offset: 0x0 ordinal: 0x5
  struct __anon_3857 UpdateConsoleLockState;      // offset: 0x0 ordinal: 0x6
  ULONGLONG AsUlong64;                            // offset: 0x0 ordinal: 0x7
} _PNP_DEVICE_ACTION_REQUEST_ARGUMENT;

// 0xb0 bytes (sizeof)
typedef struct _MM_DRIVER_VERIFIER_DATA {
  ULONG Level;                               // offset: 0x0 ordinal: 0x0
  ULONG RaiseIrqls;                          // offset: 0x4 ordinal: 0x1
  ULONG AcquireSpinLocks;                    // offset: 0x8 ordinal: 0x2
  ULONG SynchronizeExecutions;               // offset: 0xc ordinal: 0x3
  ULONG AllocationsAttempted;                // offset: 0x10 ordinal: 0x4
  ULONG AllocationsSucceeded;                // offset: 0x14 ordinal: 0x5
  ULONG AllocationsSucceededSpecialPool;     // offset: 0x18 ordinal: 0x6
  ULONG AllocationsWithNoTag;                // offset: 0x1c ordinal: 0x7
  ULONG TrimRequests;                        // offset: 0x20 ordinal: 0x8
  ULONG Trims;                               // offset: 0x24 ordinal: 0x9
  ULONG AllocationsFailed;                   // offset: 0x28 ordinal: 0xa
  ULONG AllocationsFailedDeliberately;       // offset: 0x2c ordinal: 0xb
  ULONG AllocationFreed;                     // offset: 0x30 ordinal: 0xc
  ULONG Loads;                               // offset: 0x34 ordinal: 0xd
  ULONG Unloads;                             // offset: 0x38 ordinal: 0xe
  ULONG UnTrackedPool;                       // offset: 0x3c ordinal: 0xf
  ULONG UserTrims;                           // offset: 0x40 ordinal: 0x10
  ULONG CurrentPagedPoolAllocations;         // offset: 0x44 ordinal: 0x11
  ULONG CurrentNonPagedPoolAllocations;      // offset: 0x48 ordinal: 0x12
  ULONG PeakPagedPoolAllocations;            // offset: 0x4c ordinal: 0x13
  ULONG PeakNonPagedPoolAllocations;         // offset: 0x50 ordinal: 0x14
  ULONGLONG PagedBytes;                      // offset: 0x58 ordinal: 0x15
  ULONGLONG NonPagedBytes;                   // offset: 0x60 ordinal: 0x16
  ULONGLONG PeakPagedBytes;                  // offset: 0x68 ordinal: 0x17
  ULONGLONG PeakNonPagedBytes;               // offset: 0x70 ordinal: 0x18
  ULONG BurstAllocationsFailedDeliberately;  // offset: 0x78 ordinal: 0x19
  ULONG SessionTrims;                        // offset: 0x7c ordinal: 0x1a
  ULONG OptionChanges;                       // offset: 0x80 ordinal: 0x1b
  ULONG VerifyMode;                          // offset: 0x84 ordinal: 0x1c
  struct _UNICODE_STRING PreviousBucketName; // offset: 0x88 ordinal: 0x1d
  ULONG ExecutePoolTypes;                    // offset: 0x98 ordinal: 0x1e
  ULONG ExecutePageProtections;              // offset: 0x9c ordinal: 0x1f
  ULONG ExecutePageMappings;                 // offset: 0xa0 ordinal: 0x20
  ULONG ExecuteWriteSections;                // offset: 0xa4 ordinal: 0x21
  ULONG SectionAlignmentFailures;            // offset: 0xa8 ordinal: 0x22
  ULONG IATInExecutableSection;              // offset: 0xac ordinal: 0x23
} _MM_DRIVER_VERIFIER_DATA;

// 0x218 bytes (sizeof)
typedef struct _POP_THERMAL_TELEMETRY_TRACKER {
  UCHAR AccountingDisabled;        // offset: 0x0 ordinal: 0x0
  UCHAR ActiveLevels;              // offset: 0x1 ordinal: 0x1
  ULONGLONG LastPassiveUpdateTime; // offset: 0x8 ordinal: 0x2
  ULONGLONG LastActiveUpdateTime;  // offset: 0x10 ordinal: 0x3
  ULONGLONG TotalPassiveTime[21];  // offset: 0x18 ordinal: 0x4
  ULONGLONG PassiveTimeSnap[21];   // offset: 0xc0 ordinal: 0x5
  ULONGLONG TotalActiveTime[10];   // offset: 0x168 ordinal: 0x6
  ULONGLONG ActiveTimeSnap[10];    // offset: 0x1b8 ordinal: 0x7
  ULONGLONG TotalTime;             // offset: 0x208 ordinal: 0x8
  ULONGLONG TotalTimeSnap;         // offset: 0x210 ordinal: 0x9
} _POP_THERMAL_TELEMETRY_TRACKER;

// 0x1a8 bytes (sizeof)
typedef struct _VF_POOL_TRACE {
  VOID *Address;           // offset: 0x0 ordinal: 0x0
  ULONGLONG Size;          // offset: 0x8 ordinal: 0x1
  struct _ETHREAD *Thread; // offset: 0x10 ordinal: 0x2
  VOID *StackTrace[50];    // offset: 0x18 ordinal: 0x3
} _VF_POOL_TRACE;

// 0x18 bytes (sizeof)
typedef struct _ARBITER_CONFLICT_INFO {
  struct _DEVICE_OBJECT *OwningObject; // offset: 0x0 ordinal: 0x0
  ULONGLONG Start;                     // offset: 0x8 ordinal: 0x1
  ULONGLONG End;                       // offset: 0x10 ordinal: 0x2
} _ARBITER_CONFLICT_INFO;

// 0x28 bytes (sizeof)
typedef struct _RTL_RANGE {
  ULONGLONG Start;  // offset: 0x0 ordinal: 0x0
  ULONGLONG End;    // offset: 0x8 ordinal: 0x1
  VOID *UserData;   // offset: 0x10 ordinal: 0x2
  VOID *Owner;      // offset: 0x18 ordinal: 0x3
  UCHAR Attributes; // offset: 0x20 ordinal: 0x4
  UCHAR Flags;      // offset: 0x21 ordinal: 0x5
} _RTL_RANGE;

typedef UCHAR (*__anon_3760)(VOID *, struct _RTL_RANGE *);

// 0x10 bytes (sizeof)
typedef struct _ARBITER_ORDERING {
  ULONGLONG Start; // offset: 0x0 ordinal: 0x0
  ULONGLONG End;   // offset: 0x8 ordinal: 0x1
} _ARBITER_ORDERING;

// 0x10 bytes (sizeof)
typedef struct _ARBITER_ORDERING_LIST {
  USHORT Count;                        // offset: 0x0 ordinal: 0x0
  USHORT Maximum;                      // offset: 0x2 ordinal: 0x1
  struct _ARBITER_ORDERING *Orderings; // offset: 0x8 ordinal: 0x2
} _ARBITER_ORDERING_LIST;

// 0x10 bytes (sizeof)
typedef struct _VF_AVL_TREE_NODE {
  VOID *p;             // offset: 0x0 ordinal: 0x0
  ULONGLONG RangeSize; // offset: 0x8 ordinal: 0x1
} _VF_AVL_TREE_NODE;

// 0x18 bytes (sizeof)
typedef struct _VF_AVL_TREE_NODE_EX {
  struct _VF_AVL_TREE_NODE Base; // offset: 0x0 ordinal: 0x0
  ULONG SessionId;               // offset: 0x10 ordinal: 0x1
} _VF_AVL_TREE_NODE_EX;

// 0xc0 bytes (sizeof)
typedef struct _VF_AVL_TABLE {
  struct _RTL_AVL_TABLE RtlTable;         // offset: 0x0 ordinal: 0x0
  struct _VF_AVL_TREE_NODE *ReservedNode; // offset: 0x68 ordinal: 0x1
  VOID *NodeToFree;                       // offset: 0x70 ordinal: 0x2
  LONG Lock;                              // offset: 0x80 ordinal: 0x3
} _VF_AVL_TABLE;

// 0x28 bytes (sizeof)
typedef struct _VF_AVL_TREE {
  ULONGLONG NodeRangeSize;      // offset: 0x0 ordinal: 0x0
  ULONGLONG NodeCount;          // offset: 0x8 ordinal: 0x1
  struct _VF_AVL_TABLE *Tables; // offset: 0x10 ordinal: 0x2
  ULONG TablesNo;               // offset: 0x18 ordinal: 0x3
  UCHAR UseSessionId;           // offset: 0x1c ordinal: 0x4
  union __anon_3709 u1;         // offset: 0x20 ordinal: 0x5
} _VF_AVL_TREE;

// 0x10 bytes (sizeof)
typedef struct _MI_ZERO_COST_COUNTS {
  ULONGLONG NativeSum;    // offset: 0x0 ordinal: 0x0
  ULONGLONG AlternateSum; // offset: 0x8 ordinal: 0x1
} _MI_ZERO_COST_COUNTS;

// 0x8 bytes (sizeof)
typedef struct __anon_3686 {
  ULONGLONG PageState : 3;       // offset: 0x0 ordinal: 0x0
  ULONGLONG HasError : 1;        // offset: 0x0 ordinal: 0x1
  ULONGLONG Partition : 11;      // offset: 0x0 ordinal: 0x2
  ULONGLONG DanglingIoNodes : 9; // offset: 0x0 ordinal: 0x3
} __anon_3686;

// 0x8 bytes (sizeof)
typedef struct __anon_3685 {
  ULONGLONG PageState : 3;  // offset: 0x0 ordinal: 0x0
  ULONGLONG HasError : 1;   // offset: 0x0 ordinal: 0x1
  ULONGLONG Partition : 11; // offset: 0x0 ordinal: 0x2
  ULONGLONG DeleteBit : 1;  // offset: 0x0 ordinal: 0x3
  ULONGLONG
  ContentsWereNonZeroWhenInitiallyUnlinked : 1; // offset: 0x0 ordinal: 0x4
  ULONGLONG ShareCount : 22;                    // offset: 0x0 ordinal: 0x5
} __anon_3685;

// 0x8 bytes (sizeof)
typedef struct __anon_3684 {
  ULONGLONG PageState : 3;       // offset: 0x0 ordinal: 0x0
  ULONGLONG HasError : 1;        // offset: 0x0 ordinal: 0x1
  ULONGLONG Partition : 11;      // offset: 0x0 ordinal: 0x2
  ULONGLONG Flink : 22;          // offset: 0x0 ordinal: 0x3
  ULONGLONG Blink : 22;          // offset: 0x0 ordinal: 0x4
  ULONGLONG WriteInProgress : 1; // offset: 0x0 ordinal: 0x5
} __anon_3684;

// 0x8 bytes (sizeof)
typedef struct __anon_3683 {
  ULONGLONG PageState : 3;                 // offset: 0x0 ordinal: 0x0
  ULONGLONG HasError : 1;                  // offset: 0x0 ordinal: 0x1
  ULONGLONG Partition : 11;                // offset: 0x0 ordinal: 0x2
  ULONGLONG ZeroedDuringStateChanges : 49; // offset: 0x0 ordinal: 0x3
} __anon_3683;

// 0x8 bytes (sizeof)
typedef struct __anon_3682 {
  ULONGLONG EntireField; // offset: 0x0 ordinal: 0x0
} __anon_3682;

// 0x8 bytes (sizeof)
typedef union __anon_3674 {
  struct __anon_3682 e1;         // offset: 0x0 ordinal: 0x0
  struct __anon_3683 e2;         // offset: 0x0 ordinal: 0x1
  struct __anon_3684 OnList;     // offset: 0x0 ordinal: 0x2
  struct __anon_3685 Active;     // offset: 0x0 ordinal: 0x3
  struct __anon_3686 Transition; // offset: 0x0 ordinal: 0x4
} __anon_3674;

// 0x8 bytes (sizeof)
typedef struct _MI_HUGE_PFN {
  union __anon_3674 u1; // offset: 0x0 ordinal: 0x0
} _MI_HUGE_PFN;

// 0x20 bytes (sizeof)
typedef struct _NON_PAGED_DEBUG_INFO {
  USHORT Signature;       // offset: 0x0 ordinal: 0x0
  USHORT Flags;           // offset: 0x2 ordinal: 0x1
  ULONG Size;             // offset: 0x4 ordinal: 0x2
  USHORT Machine;         // offset: 0x8 ordinal: 0x3
  USHORT Characteristics; // offset: 0xa ordinal: 0x4
  ULONG TimeDateStamp;    // offset: 0xc ordinal: 0x5
  ULONG CheckSum;         // offset: 0x10 ordinal: 0x6
  ULONG SizeOfImage;      // offset: 0x14 ordinal: 0x7
  ULONGLONG ImageBase;    // offset: 0x18 ordinal: 0x8
} _NON_PAGED_DEBUG_INFO;

// 0xa0 bytes (sizeof)
typedef struct _KLDR_DATA_TABLE_ENTRY {
  struct _LIST_ENTRY InLoadOrderLinks;             // offset: 0x0 ordinal: 0x0
  VOID *ExceptionTable;                            // offset: 0x10 ordinal: 0x1
  ULONG ExceptionTableSize;                        // offset: 0x18 ordinal: 0x2
  VOID *GpValue;                                   // offset: 0x20 ordinal: 0x3
  struct _NON_PAGED_DEBUG_INFO *NonPagedDebugInfo; // offset: 0x28 ordinal: 0x4
  VOID *DllBase;                                   // offset: 0x30 ordinal: 0x5
  VOID *EntryPoint;                                // offset: 0x38 ordinal: 0x6
  ULONG SizeOfImage;                               // offset: 0x40 ordinal: 0x7
  struct _UNICODE_STRING FullDllName;              // offset: 0x48 ordinal: 0x8
  struct _UNICODE_STRING BaseDllName;              // offset: 0x58 ordinal: 0x9
  ULONG Flags;                                     // offset: 0x68 ordinal: 0xa
  USHORT LoadCount;                                // offset: 0x6c ordinal: 0xb
  union __anon_3668 u1;                            // offset: 0x6e ordinal: 0xc
  VOID *SectionPointer;                            // offset: 0x70 ordinal: 0xd
  ULONG CheckSum;                                  // offset: 0x78 ordinal: 0xe
  ULONG CoverageSectionSize;                       // offset: 0x7c ordinal: 0xf
  VOID *CoverageSection;                           // offset: 0x80 ordinal: 0x10
  VOID *LoadedImports;                             // offset: 0x88 ordinal: 0x11
  union {
    VOID *Spare; // offset: 0x90 ordinal: 0x12
    struct _KLDR_DATA_TABLE_ENTRY
        *NtDataTableEntry; // offset: 0x90 ordinal: 0x13
  };
  ULONG SizeOfImageNotRounded; // offset: 0x98 ordinal: 0x14
  ULONG TimeDateStamp;         // offset: 0x9c ordinal: 0x15
} _KLDR_DATA_TABLE_ENTRY;

// 0x8 bytes (sizeof)
typedef union __anon_3666 {
  struct _CONTROL_AREA *ControlArea;   // offset: 0x0 ordinal: 0x0
  struct _FILE_OBJECT *FileObject;     // offset: 0x0 ordinal: 0x1
  ULONGLONG RemoteImageFileObject : 1; // offset: 0x0 ordinal: 0x2
  ULONGLONG RemoteDataFileObject : 1;  // offset: 0x0 ordinal: 0x3
} __anon_3666;

// 0x10 bytes (sizeof)
typedef struct _MI_SYSTEM_VA_ASSIGNMENT {
  VOID *BaseAddress;       // offset: 0x0 ordinal: 0x0
  ULONGLONG NumberOfBytes; // offset: 0x8 ordinal: 0x1
} _MI_SYSTEM_VA_ASSIGNMENT;

// 0x10 bytes (sizeof)
typedef struct _HAL_CHANNEL_MEMORY_RANGES {
  ULONGLONG PageFrameIndex; // offset: 0x0 ordinal: 0x0
  USHORT MpnId;             // offset: 0x8 ordinal: 0x1
  USHORT Node;              // offset: 0xa ordinal: 0x2
  USHORT Channel;           // offset: 0xc ordinal: 0x3
  UCHAR IsPowerManageable;  // offset: 0xe ordinal: 0x4
  UCHAR DeepPowerState;     // offset: 0xf ordinal: 0x5
} _HAL_CHANNEL_MEMORY_RANGES;

// 0x10 bytes (sizeof)
typedef struct _HAL_NODE_RANGE {
  ULONGLONG PageFrameIndex; // offset: 0x0 ordinal: 0x0
  ULONG Node;               // offset: 0x8 ordinal: 0x1
} _HAL_NODE_RANGE;

// 0x118 bytes (sizeof)
typedef struct _SYSPTES_HEADER {
  struct _LIST_ENTRY ListHead[16]; // offset: 0x0 ordinal: 0x0
  ULONGLONG Count;                 // offset: 0x100 ordinal: 0x1
  ULONGLONG NumberOfEntries;       // offset: 0x108 ordinal: 0x2
  ULONGLONG NumberOfEntriesPeak;   // offset: 0x110 ordinal: 0x3
} _SYSPTES_HEADER;

// 0x40 bytes (sizeof)
typedef struct _MI_SYSTEM_TRIM_STATE {
  ULONGLONG ExpansionLock;                // offset: 0x0 ordinal: 0x0
  LONG TrimInProgressCount;               // offset: 0x8 ordinal: 0x1
  struct _KEVENT PeriodicWorkingSetEvent; // offset: 0x10 ordinal: 0x2
  ULONG TrimAllPageFaultCount[3];         // offset: 0x28 ordinal: 0x3
} _MI_SYSTEM_TRIM_STATE;

// 0x100 bytes (sizeof)
typedef struct _MI_ERROR_STATE {
  struct _MI_BAD_MEMORY_EVENT_ENTRY
      BadMemoryEventEntry;                    // offset: 0x0 ordinal: 0x0
  struct _MI_PROBE_RAISE_TRACKER ProbeRaises; // offset: 0x38 ordinal: 0x1
  struct _MI_FORCED_COMMITS ForcedCommits;    // offset: 0x78 ordinal: 0x2
  ULONG PrePhase0BugCheckParameter;           // offset: 0x80 ordinal: 0x3
  ULONG WsleFailures;                         // offset: 0x84 ordinal: 0x4
  UCHAR PendingBadPages;                      // offset: 0x88 ordinal: 0x5
  UCHAR FatalGraphicsFailures;                // offset: 0x89 ordinal: 0x6
  UCHAR InitFailure;                          // offset: 0x8a ordinal: 0x7
  UCHAR BadPagesInsertSignalState;            // offset: 0x8b ordinal: 0x8
  enum _MI_PAGE_HASH_ERROR_BEHAVIOR
      PageHashErrorBehavior;                     // offset: 0x8c ordinal: 0x9
  ULONG PageHashReadErrors;                      // offset: 0x90 ordinal: 0xa
  ULONG PageHashStandbyErrors;                   // offset: 0x94 ordinal: 0xb
  ULONG PageHashTransferErrors;                  // offset: 0x98 ordinal: 0xc
  ULONG PageHashAllocationErrors;                // offset: 0x9c ordinal: 0xd
  ULONGLONG FailedHashPageFrameIndex;            // offset: 0xa0 ordinal: 0xe
  ULONG CheckZeroCount;                          // offset: 0xa8 ordinal: 0xf
  LONG ZeroedPageSingleBitErrorsDetected;        // offset: 0xac ordinal: 0x10
  LONG BadPagesDetected;                         // offset: 0xb0 ordinal: 0x11
  ULONG BadPagesInserted;                        // offset: 0xb4 ordinal: 0x12
  struct _WORK_QUEUE_ITEM BadPageInsertWorkItem; // offset: 0xb8 ordinal: 0x13
  LONG ScrubPasses;                              // offset: 0xd8 ordinal: 0x14
  LONG ScrubBadPagesFound;                       // offset: 0xdc ordinal: 0x15
  ULONG UserViewFailures;                        // offset: 0xe0 ordinal: 0x16
  ULONG UserViewCollisionFailures;               // offset: 0xe4 ordinal: 0x17
  ULONG UserAllocateFailures;                    // offset: 0xe8 ordinal: 0x18
  ULONG UserAllocateCollisionFailures;           // offset: 0xec ordinal: 0x19
  struct _MI_RESAVAIL_FAILURES ResavailFailures; // offset: 0xf0 ordinal: 0x1a
  LONG BadPhysicalMapsEarly;                     // offset: 0xf8 ordinal: 0x1b
  LONG BadPhysicalMaps;                          // offset: 0xfc ordinal: 0x1c
} _MI_ERROR_STATE;

// 0x20 bytes (sizeof)
typedef struct _MI_COMBINE_STATE {
  LONG ActiveSpinLock;                   // offset: 0x0 ordinal: 0x0
  ULONG CombiningThreadCount;            // offset: 0x4 ordinal: 0x1
  struct _RTL_AVL_TREE ActiveThreadTree; // offset: 0x8 ordinal: 0x2
  ULONGLONG CommonPageCombineDomain;     // offset: 0x10 ordinal: 0x3
  ULONG CommonCombineDomainAssigned;     // offset: 0x18 ordinal: 0x4
  LONG CombineSequence;                  // offset: 0x1c ordinal: 0x5
} _MI_COMBINE_STATE;

// 0x10 bytes (sizeof)
typedef struct __anon_3565 {
  union _LARGE_INTEGER Base; // offset: 0x0 ordinal: 0x0
  ULONGLONG Size;            // offset: 0x8 ordinal: 0x1
} __anon_3565;

// 0x10 bytes (sizeof)
typedef struct _LOADER_MEMORY_RANGE {
  ULONGLONG StartPage;     // offset: 0x0 ordinal: 0x0
  ULONGLONG NumberOfPages; // offset: 0x8 ordinal: 0x1
} _LOADER_MEMORY_RANGE;

// 0x18 bytes (sizeof)
typedef struct _MEMORY_MIRRORING_DATA {
  ULONG MemoryRangeCount;                     // offset: 0x0 ordinal: 0x0
  ULONG IoSpaceRangeCount;                    // offset: 0x4 ordinal: 0x1
  struct _LOADER_MEMORY_RANGE *MemoryRanges;  // offset: 0x8 ordinal: 0x2
  struct _LOADER_MEMORY_RANGE *IoSpaceRanges; // offset: 0x10 ordinal: 0x3
} _MEMORY_MIRRORING_DATA;

// 0x20 bytes (sizeof)
typedef struct _IOMMU_DMA_RESERVED_REGION {
  struct _IOMMU_DMA_RESERVED_REGION *RegionNext; // offset: 0x0 ordinal: 0x0
  ULONGLONG Base;                                // offset: 0x8 ordinal: 0x1
  ULONGLONG NumberOfPages;                       // offset: 0x10 ordinal: 0x2
  UCHAR ShouldMap;                               // offset: 0x18 ordinal: 0x3
} _IOMMU_DMA_RESERVED_REGION;

// 0x10 bytes (sizeof)
typedef struct _INSTALLED_MEMORY_RANGE {
  ULONGLONG BasePage;  // offset: 0x0 ordinal: 0x0
  ULONGLONG PageCount; // offset: 0x8 ordinal: 0x1
} _INSTALLED_MEMORY_RANGE;

// 0x10 bytes (sizeof)
typedef struct __anon_3494 {
  struct _INSTALLED_MEMORY_RANGE *Ranges; // offset: 0x0 ordinal: 0x0
  ULONG RangeCount;                       // offset: 0x8 ordinal: 0x1
} __anon_3494;

// 0x68 bytes (sizeof)
typedef struct _BOOT_ENTROPY_SOURCE_LDR_RESULT {
  enum _BOOT_ENTROPY_SOURCE_ID SourceId;            // offset: 0x0 ordinal: 0x0
  ULONGLONG Policy;                                 // offset: 0x8 ordinal: 0x1
  enum _BOOT_ENTROPY_SOURCE_RESULT_CODE ResultCode; // offset: 0x10 ordinal: 0x2
  LONG ResultStatus;                                // offset: 0x14 ordinal: 0x3
  ULONGLONG Time;                                   // offset: 0x18 ordinal: 0x4
  ULONG EntropyLength;                              // offset: 0x20 ordinal: 0x5
  UCHAR EntropyData[64];                            // offset: 0x24 ordinal: 0x6
} _BOOT_ENTROPY_SOURCE_LDR_RESULT;

// 0x868 bytes (sizeof)
typedef struct _BOOT_ENTROPY_LDR_RESULT {
  ULONG maxEntropySources; // offset: 0x0 ordinal: 0x0
  struct _BOOT_ENTROPY_SOURCE_LDR_RESULT
      EntropySourceResult[10];     // offset: 0x8 ordinal: 0x1
  UCHAR SeedBytesForCng[48];       // offset: 0x418 ordinal: 0x2
  UCHAR RngBytesForNtoskrnl[1024]; // offset: 0x448 ordinal: 0x3
  UCHAR KdEntropy[32];             // offset: 0x848 ordinal: 0x4
} _BOOT_ENTROPY_LDR_RESULT;

// 0x8 bytes (sizeof)
typedef union _IOMMU_DMA_DOMAIN_CREATION_FLAGS {
  ULONGLONG Reserved : 64; // offset: 0x0 ordinal: 0x0
  ULONGLONG AsUlonglong;   // offset: 0x0 ordinal: 0x1
} _IOMMU_DMA_DOMAIN_CREATION_FLAGS;

// 0x18 bytes (sizeof)
typedef struct _BOOT_FIRMWARE_RAMDISK_INFO {
  ULONG Version;         // offset: 0x0 ordinal: 0x0
  ULONG BlockSize;       // offset: 0x4 ordinal: 0x1
  ULONGLONG BaseAddress; // offset: 0x8 ordinal: 0x2
  ULONGLONG Size;        // offset: 0x10 ordinal: 0x3
} _BOOT_FIRMWARE_RAMDISK_INFO;

// 0x18 bytes (sizeof)
typedef struct _NUMA_MEMORY_RANGE {
  ULONG ProximityId;  // offset: 0x0 ordinal: 0x0
  ULONGLONG BasePage; // offset: 0x8 ordinal: 0x1
  ULONGLONG EndPage;  // offset: 0x10 ordinal: 0x2
} _NUMA_MEMORY_RANGE;

// 0x8 bytes (sizeof)
typedef union __anon_3528 {
  struct __anon_3548 Component; // offset: 0x0 ordinal: 0x0
  ULONGLONG AsULONG64;          // offset: 0x0 ordinal: 0x1
  UCHAR AsBytes[8];             // offset: 0x0 ordinal: 0x2
} __anon_3528;

// 0x30 bytes (sizeof)
typedef struct _LOADER_RESET_REASON {
  UCHAR Supplied;          // offset: 0x0 ordinal: 0x0
  union __anon_3528 Basic; // offset: 0x8 ordinal: 0x1
  ULONG AdditionalInfo[8]; // offset: 0x10 ordinal: 0x2
} _LOADER_RESET_REASON;

// 0x18 bytes (sizeof)
typedef struct _SMBIOS3_TABLE_HEADER {
  UCHAR Signature[5];              // offset: 0x0 ordinal: 0x0
  UCHAR Checksum;                  // offset: 0x5 ordinal: 0x1
  UCHAR Length;                    // offset: 0x6 ordinal: 0x2
  UCHAR MajorVersion;              // offset: 0x7 ordinal: 0x3
  UCHAR MinorVersion;              // offset: 0x8 ordinal: 0x4
  UCHAR Docrev;                    // offset: 0x9 ordinal: 0x5
  UCHAR EntryPointRevision;        // offset: 0xa ordinal: 0x6
  UCHAR Reserved;                  // offset: 0xb ordinal: 0x7
  ULONG StructureTableMaximumSize; // offset: 0xc ordinal: 0x8
  ULONGLONG StructureTableAddress; // offset: 0x10 ordinal: 0x9
} _SMBIOS3_TABLE_HEADER;

// 0x48 bytes (sizeof)
typedef struct _LOADER_FEATURE_CONFIGURATION_INFORMATION {
  VOID *FeatureConfigurationBuffer;         // offset: 0x0 ordinal: 0x0
  ULONGLONG FeatureConfigurationBufferSize; // offset: 0x8 ordinal: 0x1
  VOID *UsageSubscriptionBuffer;            // offset: 0x10 ordinal: 0x2
  ULONGLONG UsageSubscriptionBufferSize;    // offset: 0x18 ordinal: 0x3
  VOID *DelayedUsageReportBuffer;           // offset: 0x20 ordinal: 0x4
  ULONGLONG DelayedUsageReportBufferSize;   // offset: 0x28 ordinal: 0x5
  struct _LOADER_FEATURE_CONFIGURATION_DIAGNOSTIC_INFORMATION
      DiagnosticInformation; // offset: 0x30 ordinal: 0x6
} _LOADER_FEATURE_CONFIGURATION_INFORMATION;

// 0x10 bytes (sizeof)
typedef struct __anon_3487 {
  VOID *CodeBase;     // offset: 0x0 ordinal: 0x0
  ULONGLONG CodeSize; // offset: 0x8 ordinal: 0x1
} __anon_3487;

// 0x28 bytes (sizeof)
typedef struct _LOADER_BUGCHECK_PARAMETERS {
  ULONG BugcheckCode;           // offset: 0x0 ordinal: 0x0
  ULONGLONG BugcheckParameter1; // offset: 0x8 ordinal: 0x1
  ULONGLONG BugcheckParameter2; // offset: 0x10 ordinal: 0x2
  ULONGLONG BugcheckParameter3; // offset: 0x18 ordinal: 0x3
  ULONGLONG BugcheckParameter4; // offset: 0x20 ordinal: 0x4
} _LOADER_BUGCHECK_PARAMETERS;

// 0x40 bytes (sizeof)
typedef struct _LOADER_PARAMETER_HYPERVISOR_EXTENSION {
  ULONG InitialHypervisorCrashdumpAreaPageCount; // offset: 0x0 ordinal: 0x0
  ULONG HypervisorCrashdumpAreaPageCount;        // offset: 0x4 ordinal: 0x1
  ULONGLONG InitialHypervisorCrashdumpAreaSpa;   // offset: 0x8 ordinal: 0x2
  ULONGLONG HypervisorCrashdumpAreaSpa;          // offset: 0x10 ordinal: 0x3
  ULONGLONG HypervisorLaunchStatus;              // offset: 0x18 ordinal: 0x4
  ULONGLONG HypervisorLaunchStatusArg1;          // offset: 0x20 ordinal: 0x5
  ULONGLONG HypervisorLaunchStatusArg2;          // offset: 0x28 ordinal: 0x6
  ULONGLONG HypervisorLaunchStatusArg3;          // offset: 0x30 ordinal: 0x7
  ULONGLONG HypervisorLaunchStatusArg4;          // offset: 0x38 ordinal: 0x8
  VOID *RangeArray;                              // offset: 0x28 ordinal: 0x9
  ULONG RangeCount;                              // offset: 0x30 ordinal: 0xa
} _LOADER_PARAMETER_HYPERVISOR_EXTENSION;

// 0x60 bytes (sizeof)
typedef struct _LOADER_PERFORMANCE_DATA {
  ULONGLONG StartTime;                  // offset: 0x0 ordinal: 0x0
  ULONGLONG EndTime;                    // offset: 0x8 ordinal: 0x1
  ULONGLONG PreloadEndTime;             // offset: 0x10 ordinal: 0x2
  ULONGLONG TcbLoaderStartTime;         // offset: 0x18 ordinal: 0x3
  ULONGLONG LoadHypervisorTime;         // offset: 0x20 ordinal: 0x4
  ULONGLONG LaunchHypervisorTime;       // offset: 0x28 ordinal: 0x5
  ULONGLONG LoadVsmTime;                // offset: 0x30 ordinal: 0x6
  ULONGLONG LaunchVsmTime;              // offset: 0x38 ordinal: 0x7
  ULONGLONG ExecuteTransitionStartTime; // offset: 0x40 ordinal: 0x8
  ULONGLONG ExecuteTransitionEndTime;   // offset: 0x48 ordinal: 0x9
  ULONGLONG LoadDriversTime;            // offset: 0x50 ordinal: 0xa
  ULONGLONG CleanupVsmTime;             // offset: 0x58 ordinal: 0xb
} _LOADER_PERFORMANCE_DATA;

typedef LONG (*__anon_3454)(ULONG, ULONG, ULONGLONG, ULONGLONG);

typedef LONG (*__anon_3436)(ULONGLONG, VOID *, ULONG);

typedef LONG (*__anon_3433)(VOID *, ULONGLONG);

// 0x20 bytes (sizeof)
typedef struct _HAL_CLOCK_TIMER_CONFIGURATION {
  union {
    UCHAR Flags;             // offset: 0x0 ordinal: 0x0
    UCHAR AlwaysOnTimer : 1; // offset: 0x0 ordinal: 0x1
  };
  UCHAR HighLatency : 1;          // offset: 0x0 ordinal: 0x2
  UCHAR PerCpuTimer : 1;          // offset: 0x0 ordinal: 0x3
  UCHAR DynamicTickSupported : 1; // offset: 0x0 ordinal: 0x4
  ULONG KnownType;                // offset: 0x4 ordinal: 0x5
  ULONG Capabilities;             // offset: 0x8 ordinal: 0x6
  ULONGLONG MaxIncrement;         // offset: 0x10 ordinal: 0x7
  ULONG MinIncrement;             // offset: 0x18 ordinal: 0x8
} _HAL_CLOCK_TIMER_CONFIGURATION;

typedef VOID (*__anon_3282)(struct _HAL_CLOCK_TIMER_CONFIGURATION *);

typedef UCHAR (*__anon_3310)(ULONGLONG, USHORT *, UCHAR *, UCHAR *, UCHAR *);

typedef LONG (*__anon_3303)(ULONG, ULONGLONG);

typedef ULONGLONG (*__anon_3294)(UCHAR);

typedef LONG (*__anon_3288)(ULONGLONG, struct _DEVICE_OBJECT *);

typedef VOID *(*__anon_3259)(ULONGLONG, ULONG, ULONG);

typedef LONG (*__anon_3234)(ULONGLONG, ULONGLONG);

// 0x30 bytes (sizeof)
typedef struct _HEAP_STOP_ON_VALUES {
  ULONGLONG AllocAddress;              // offset: 0x0 ordinal: 0x0
  struct _HEAP_STOP_ON_TAG AllocTag;   // offset: 0x8 ordinal: 0x1
  ULONGLONG ReAllocAddress;            // offset: 0x10 ordinal: 0x2
  struct _HEAP_STOP_ON_TAG ReAllocTag; // offset: 0x18 ordinal: 0x3
  ULONGLONG FreeAddress;               // offset: 0x20 ordinal: 0x4
  struct _HEAP_STOP_ON_TAG FreeTag;    // offset: 0x28 ordinal: 0x5
} _HEAP_STOP_ON_VALUES;

// 0x1d8 bytes (sizeof)
typedef struct _POP_DEVICE_SYS_STATE {
  UCHAR IrpMinor;                        // offset: 0x0 ordinal: 0x0
  enum _SYSTEM_POWER_STATE SystemState;  // offset: 0x4 ordinal: 0x1
  ULONGLONG SpinLock;                    // offset: 0x8 ordinal: 0x2
  struct _KTHREAD *Thread;               // offset: 0x10 ordinal: 0x3
  struct _KEVENT *AbortEvent;            // offset: 0x18 ordinal: 0x4
  struct _KSEMAPHORE *ReadySemaphore;    // offset: 0x20 ordinal: 0x5
  struct _KSEMAPHORE *FinishedSemaphore; // offset: 0x28 ordinal: 0x6
  struct _PO_DEVICE_NOTIFY_ORDER Order;  // offset: 0x30 ordinal: 0x7
  struct _LIST_ENTRY Pending;            // offset: 0x1b0 ordinal: 0x8
  LONG Status;                           // offset: 0x1c0 ordinal: 0x9
  struct _DEVICE_OBJECT *FailedDevice;   // offset: 0x1c8 ordinal: 0xa
  UCHAR Waking;                          // offset: 0x1d0 ordinal: 0xb
  UCHAR Cancelled;                       // offset: 0x1d1 ordinal: 0xc
  UCHAR IgnoreErrors;                    // offset: 0x1d2 ordinal: 0xd
  UCHAR IgnoreNotImplemented;            // offset: 0x1d3 ordinal: 0xe
  UCHAR TimeRefreshLockAcquired;         // offset: 0x1d4 ordinal: 0xf
} _POP_DEVICE_SYS_STATE;

// 0x18 bytes (sizeof)
typedef struct _POP_CURRENT_BROADCAST {
  UCHAR InProgress;                                 // offset: 0x0 ordinal: 0x0
  struct _SYSTEM_POWER_STATE_CONTEXT SystemContext; // offset: 0x4 ordinal: 0x1
  enum POWER_ACTION PowerAction;                    // offset: 0x8 ordinal: 0x2
  struct _POP_DEVICE_SYS_STATE *DeviceState;        // offset: 0x10 ordinal: 0x3
} _POP_CURRENT_BROADCAST;

// 0x28 bytes (sizeof)
typedef struct _ISRDPCSTATS_SEQUENCE {
  ULONG SequenceNumber; // offset: 0x0 ordinal: 0x0
  ULONGLONG IsrTime;    // offset: 0x8 ordinal: 0x1
  ULONGLONG IsrCount;   // offset: 0x10 ordinal: 0x2
  ULONGLONG DpcTime;    // offset: 0x18 ordinal: 0x3
  ULONGLONG DpcCount;   // offset: 0x20 ordinal: 0x4
} _ISRDPCSTATS_SEQUENCE;

// 0x60 bytes (sizeof)
typedef struct _ISRDPCSTATS {
  ULONGLONG IsrTime;                        // offset: 0x0 ordinal: 0x0
  ULONGLONG IsrTimeStart;                   // offset: 0x8 ordinal: 0x1
  ULONGLONG IsrCount;                       // offset: 0x10 ordinal: 0x2
  ULONGLONG DpcTime;                        // offset: 0x18 ordinal: 0x3
  ULONGLONG DpcTimeStart;                   // offset: 0x20 ordinal: 0x4
  ULONGLONG DpcCount;                       // offset: 0x28 ordinal: 0x5
  UCHAR IsrActive;                          // offset: 0x30 ordinal: 0x6
  UCHAR Reserved[7];                        // offset: 0x31 ordinal: 0x7
  struct _ISRDPCSTATS_SEQUENCE DpcWatchdog; // offset: 0x38 ordinal: 0x8
} _ISRDPCSTATS;

// 0x8 bytes (sizeof)
typedef struct _SK_CRASH_STACK_FRAME {
  ULONG ModuleId; // offset: 0x0 ordinal: 0x0
  ULONG Rva;      // offset: 0x4 ordinal: 0x1
  ULONGLONG Pc;   // offset: 0x0 ordinal: 0x2
} _SK_CRASH_STACK_FRAME;

// 0x1000 bytes (sizeof)
typedef struct _SK_CRASH_MINIDUMP {
  ULONG Size;                                    // offset: 0x0 ordinal: 0x0
  ULONG Version;                                 // offset: 0x4 ordinal: 0x1
  ULONG ModuleCount;                             // offset: 0x8 ordinal: 0x2
  ULONG FrameCount;                              // offset: 0xc ordinal: 0x3
  struct _SK_CRASH_MODULE Modules[16];           // offset: 0x10 ordinal: 0x4
  struct _SK_CRASH_STACK_FRAME StackFrames[366]; // offset: 0x490 ordinal: 0x5
} _SK_CRASH_MINIDUMP;

// 0x28 bytes (sizeof)
typedef struct _LOCK_HEADER {
  struct _RTL_AVL_TREE LockTree;            // offset: 0x0 ordinal: 0x0
  struct _RTL_AVL_TREE LockMdlSwitchedTree; // offset: 0x8 ordinal: 0x1
  ULONGLONG Count;                          // offset: 0x10 ordinal: 0x2
  ULONGLONG Lock;                           // offset: 0x18 ordinal: 0x3
  ULONG Valid;                              // offset: 0x20 ordinal: 0x4
} _LOCK_HEADER;

// 0x18 bytes (sizeof)
typedef struct _POOL_LIMIT_INFO {
  ULONGLONG HardMemoryLimit;   // offset: 0x0 ordinal: 0x0
  ULONGLONG NotificationLimit; // offset: 0x8 ordinal: 0x1
  ULONGLONG MemoryIssued;      // offset: 0x10 ordinal: 0x2
} _POOL_LIMIT_INFO;

// 0x8 bytes (sizeof)
typedef struct _WNF_STATE_NAME_STRUCT {
  ULONGLONG Version : 4;       // offset: 0x0 ordinal: 0x0
  ULONGLONG NameLifetime : 2;  // offset: 0x0 ordinal: 0x1
  ULONGLONG DataScope : 4;     // offset: 0x0 ordinal: 0x2
  ULONGLONG PermanentData : 1; // offset: 0x0 ordinal: 0x3
  ULONGLONG Sequence : 53;     // offset: 0x0 ordinal: 0x4
} _WNF_STATE_NAME_STRUCT;

// 0x10 bytes (sizeof)
typedef struct _OBJECT_HEADER_AUDIT_INFO {
  VOID *SecurityDescriptor; // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved;       // offset: 0x8 ordinal: 0x1
} _OBJECT_HEADER_AUDIT_INFO;

// 0x20 bytes (sizeof)
typedef struct _OBJECT_HEADER_QUOTA_INFO {
  ULONG PagedPoolCharge;              // offset: 0x0 ordinal: 0x0
  ULONG NonPagedPoolCharge;           // offset: 0x4 ordinal: 0x1
  ULONG SecurityDescriptorCharge;     // offset: 0x8 ordinal: 0x2
  ULONG Reserved1;                    // offset: 0xc ordinal: 0x3
  VOID *SecurityDescriptorQuotaBlock; // offset: 0x10 ordinal: 0x4
  ULONGLONG Reserved2;                // offset: 0x18 ordinal: 0x5
} _OBJECT_HEADER_QUOTA_INFO;

// 0x18 bytes (sizeof)
typedef struct _SEP_TOKEN_PRIVILEGES {
  ULONGLONG Present;          // offset: 0x0 ordinal: 0x0
  ULONGLONG Enabled;          // offset: 0x8 ordinal: 0x1
  ULONGLONG EnabledByDefault; // offset: 0x10 ordinal: 0x2
} _SEP_TOKEN_PRIVILEGES;

// 0x8 bytes (sizeof)
typedef union _FILE_SEGMENT_ELEMENT {
  VOID *Buffer;        // offset: 0x0 ordinal: 0x0
  ULONGLONG Alignment; // offset: 0x0 ordinal: 0x1
} _FILE_SEGMENT_ELEMENT;

// 0x10 bytes (sizeof)
typedef struct _IO_ADAPTER_CRYPTO_PARAMETERS {
  ULONGLONG Tweak; // offset: 0x0 ordinal: 0x0
  struct _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR
      *KeyDescriptor; // offset: 0x8 ordinal: 0x1
} _IO_ADAPTER_CRYPTO_PARAMETERS;

// 0x8 bytes (sizeof)
typedef union __anon_2942 {
  ULONGLONG Value;            // offset: 0x0 ordinal: 0x0
  ULONGLONG UserFlags : 32;   // offset: 0x0 ordinal: 0x1
  ULONGLONG SystemFlags : 16; // offset: 0x0 ordinal: 0x2
  ULONGLONG UserFlagsId : 16; // offset: 0x0 ordinal: 0x3
} __anon_2942;

// 0x50 bytes (sizeof)
typedef struct _IOP_IRP_EXTENSION {
  union {
    USHORT ExtensionFlags; // offset: 0x0 ordinal: 0x0
    USHORT Allocated : 1;  // offset: 0x0 ordinal: 0x1
  };
  USHORT PropagateId : 1;            // offset: 0x0 ordinal: 0x2
  USHORT SpareBits : 14;             // offset: 0x0 ordinal: 0x3
  USHORT TypesAllocated;             // offset: 0x2 ordinal: 0x4
  UCHAR GenericExtension[4];         // offset: 0x4 ordinal: 0x5
  VOID *VerifierContext;             // offset: 0x8 ordinal: 0x6
  ULONGLONG DiskIoAttributionHandle; // offset: 0x10 ordinal: 0x7
  struct _GUID ActivityId;           // offset: 0x18 ordinal: 0x8
  union {
    union _LARGE_INTEGER Timestamp; // offset: 0x28 ordinal: 0x9
    ULONG ZeroingOffset;            // offset: 0x28 ordinal: 0xa
    struct _IO_IRP_EXT_TRACK_OFFSET_HEADER
        *FsTrackOffsetBlob; // offset: 0x28 ordinal: 0xb
  };
  LONGLONG FsTrackedOffset; // offset: 0x30 ordinal: 0xc
  struct _IO_ADAPTER_CRYPTO_PARAMETERS
      AdapterCryptoParameters;              // offset: 0x28 ordinal: 0xd
  union __anon_2942 DriverFlags;            // offset: 0x38 ordinal: 0xe
  struct _COPY_INFORMATION CopyInformation; // offset: 0x40 ordinal: 0xf
} _IOP_IRP_EXTENSION;

// 0x18 bytes (sizeof)
typedef struct _REMOTE_PORT_VIEW {
  ULONG Length;       // offset: 0x0 ordinal: 0x0
  ULONGLONG ViewSize; // offset: 0x8 ordinal: 0x1
  VOID *ViewBase;     // offset: 0x10 ordinal: 0x2
} _REMOTE_PORT_VIEW;

// 0x8 bytes (sizeof)
typedef struct __anon_2906 {
  ULONGLONG Head : 24;              // offset: 0x0 ordinal: 0x0
  ULONGLONG Tail : 24;              // offset: 0x0 ordinal: 0x1
  ULONGLONG ActiveThreadCount : 16; // offset: 0x0 ordinal: 0x2
} __anon_2906;

// 0x8 bytes (sizeof)
typedef union __anon_2901 {
  struct __anon_2906 s1; // offset: 0x0 ordinal: 0x0
  LONGLONG Value;        // offset: 0x0 ordinal: 0x1
} __anon_2901;

// 0x8 bytes (sizeof)
typedef struct _ALPC_COMPLETION_LIST_STATE {
  union __anon_2901 u1; // offset: 0x0 ordinal: 0x0
} _ALPC_COMPLETION_LIST_STATE;

// 0x8 bytes (sizeof)
typedef union _KALPC_DIRECT_EVENT {
  ULONGLONG Value;                // offset: 0x0 ordinal: 0x0
  ULONGLONG DirectType : 1;       // offset: 0x0 ordinal: 0x1
  ULONGLONG EventReferenced : 1;  // offset: 0x0 ordinal: 0x2
  ULONGLONG EventObjectBits : 62; // offset: 0x0 ordinal: 0x3
} _KALPC_DIRECT_EVENT;

// 0x48 bytes (sizeof)
typedef struct _ALPC_PORT_ATTRIBUTES {
  ULONG Flags;                                     // offset: 0x0 ordinal: 0x0
  struct _SECURITY_QUALITY_OF_SERVICE SecurityQos; // offset: 0x4 ordinal: 0x1
  ULONGLONG MaxMessageLength;                      // offset: 0x10 ordinal: 0x2
  ULONGLONG MemoryBandwidth;                       // offset: 0x18 ordinal: 0x3
  ULONGLONG MaxPoolUsage;                          // offset: 0x20 ordinal: 0x4
  ULONGLONG MaxSectionSize;                        // offset: 0x28 ordinal: 0x5
  ULONGLONG MaxViewSize;                           // offset: 0x30 ordinal: 0x6
  ULONGLONG MaxTotalSectionSize;                   // offset: 0x38 ordinal: 0x7
  ULONG DupObjectTypes;                            // offset: 0x40 ordinal: 0x8
  ULONG Reserved;                                  // offset: 0x44 ordinal: 0x9
} _ALPC_PORT_ATTRIBUTES;

// 0x28 bytes (sizeof)
typedef struct _PORT_MESSAGE {
  union __anon_2845 u1; // offset: 0x0 ordinal: 0x0
  union __anon_2847 u2; // offset: 0x4 ordinal: 0x1
  union {
    struct _CLIENT_ID ClientId; // offset: 0x8 ordinal: 0x2
    double DoNotUseThisField;   // offset: 0x8 ordinal: 0x3
  };
  ULONG MessageId; // offset: 0x18 ordinal: 0x4
  union {
    ULONGLONG ClientViewSize; // offset: 0x20 ordinal: 0x5
    ULONG CallbackId;         // offset: 0x20 ordinal: 0x6
  };
} _PORT_MESSAGE;

// 0x50 bytes (sizeof)
typedef struct _LPCP_MESSAGE {
  union {
    struct _LIST_ENTRY Entry;            // offset: 0x0 ordinal: 0x0
    struct _SINGLE_LIST_ENTRY FreeEntry; // offset: 0x0 ordinal: 0x1
  };
  ULONG Reserved0;                  // offset: 0x8 ordinal: 0x2
  VOID *SenderPort;                 // offset: 0x10 ordinal: 0x3
  struct _ETHREAD *RepliedToThread; // offset: 0x18 ordinal: 0x4
  VOID *PortContext;                // offset: 0x20 ordinal: 0x5
  struct _PORT_MESSAGE Request;     // offset: 0x28 ordinal: 0x6
} _LPCP_MESSAGE;

// 0x10 bytes (sizeof)
typedef struct _RTLP_HP_PADDING_HEADER {
  ULONGLONG PaddingSize; // offset: 0x0 ordinal: 0x0
  ULONGLONG Spare;       // offset: 0x8 ordinal: 0x1
} _RTLP_HP_PADDING_HEADER;

// 0x10 bytes (sizeof)
typedef struct _HEAP_ENTRY_EXTRA {
  USHORT AllocatorBackTraceIndex; // offset: 0x0 ordinal: 0x0
  USHORT TagIndex;                // offset: 0x2 ordinal: 0x1
  ULONGLONG Settable;             // offset: 0x8 ordinal: 0x2
  ULONGLONG ZeroInit;             // offset: 0x0 ordinal: 0x3
  ULONGLONG ZeroInit1;            // offset: 0x8 ordinal: 0x4
} _HEAP_ENTRY_EXTRA;

// 0x10 bytes (sizeof)
typedef struct _HEAP_PSEUDO_TAG_ENTRY {
  ULONG Allocs;   // offset: 0x0 ordinal: 0x0
  ULONG Frees;    // offset: 0x4 ordinal: 0x1
  ULONGLONG Size; // offset: 0x8 ordinal: 0x2
} _HEAP_PSEUDO_TAG_ENTRY;

// 0x48 bytes (sizeof)
typedef struct _HEAP_TAG_ENTRY {
  ULONG Allocs;                 // offset: 0x0 ordinal: 0x0
  ULONG Frees;                  // offset: 0x4 ordinal: 0x1
  ULONGLONG Size;               // offset: 0x8 ordinal: 0x2
  USHORT TagIndex;              // offset: 0x10 ordinal: 0x3
  USHORT CreatorBackTraceIndex; // offset: 0x12 ordinal: 0x4
  WCHAR TagName[24];            // offset: 0x14 ordinal: 0x5
} _HEAP_TAG_ENTRY;

// 0x10 bytes (sizeof)
typedef struct _HEAP_UNPACKED_ENTRY {
  VOID *PreviousBlockPrivateData; // offset: 0x0 ordinal: 0x0
  USHORT Size;                    // offset: 0x8 ordinal: 0x1
  UCHAR Flags;                    // offset: 0xa ordinal: 0x2
  UCHAR SmallTagIndex;            // offset: 0xb ordinal: 0x3
  ULONG SubSegmentCode;           // offset: 0x8 ordinal: 0x4
  USHORT PreviousSize;            // offset: 0xc ordinal: 0x5
  union {
    UCHAR SegmentOffset; // offset: 0xe ordinal: 0x6
    UCHAR LFHFlags;      // offset: 0xe ordinal: 0x7
  };
  UCHAR UnusedBytes;       // offset: 0xf ordinal: 0x8
  ULONGLONG CompactHeader; // offset: 0x8 ordinal: 0x9
} _HEAP_UNPACKED_ENTRY;

// 0x10 bytes (sizeof)
typedef struct _HEAP_TUNING_PARAMETERS {
  ULONG CommittThresholdShift;      // offset: 0x0 ordinal: 0x0
  ULONGLONG MaxPreCommittThreshold; // offset: 0x8 ordinal: 0x1
} _HEAP_TUNING_PARAMETERS;

// 0x78 bytes (sizeof)
typedef struct _HEAP_COUNTERS {
  ULONGLONG TotalMemoryReserved;      // offset: 0x0 ordinal: 0x0
  ULONGLONG TotalMemoryCommitted;     // offset: 0x8 ordinal: 0x1
  ULONGLONG TotalMemoryLargeUCR;      // offset: 0x10 ordinal: 0x2
  ULONGLONG TotalSizeInVirtualBlocks; // offset: 0x18 ordinal: 0x3
  ULONG TotalSegments;                // offset: 0x20 ordinal: 0x4
  ULONG TotalUCRs;                    // offset: 0x24 ordinal: 0x5
  ULONG CommittOps;                   // offset: 0x28 ordinal: 0x6
  ULONG DeCommitOps;                  // offset: 0x2c ordinal: 0x7
  ULONG LockAcquires;                 // offset: 0x30 ordinal: 0x8
  ULONG LockCollisions;               // offset: 0x34 ordinal: 0x9
  ULONG CommitRate;                   // offset: 0x38 ordinal: 0xa
  ULONG DecommittRate;                // offset: 0x3c ordinal: 0xb
  ULONG CommitFailures;               // offset: 0x40 ordinal: 0xc
  ULONG InBlockCommitFailures;        // offset: 0x44 ordinal: 0xd
  ULONG PollIntervalCounter;          // offset: 0x48 ordinal: 0xe
  ULONG DecommitsSinceLastCheck;      // offset: 0x4c ordinal: 0xf
  ULONG HeapPollInterval;             // offset: 0x50 ordinal: 0x10
  ULONG AllocAndFreeOps;              // offset: 0x54 ordinal: 0x11
  ULONG AllocationIndicesActive;      // offset: 0x58 ordinal: 0x12
  ULONG InBlockDeccommits;            // offset: 0x5c ordinal: 0x13
  ULONGLONG InBlockDeccomitSize;      // offset: 0x60 ordinal: 0x14
  ULONGLONG HighWatermarkSize;        // offset: 0x68 ordinal: 0x15
  ULONGLONG LastPolledSize;           // offset: 0x70 ordinal: 0x16
} _HEAP_COUNTERS;

// 0x10 bytes (sizeof)
typedef struct _HEAP_ENTRY {
  union {
    struct _HEAP_UNPACKED_ENTRY UnpackedEntry; // offset: 0x0 ordinal: 0x0
    VOID *PreviousBlockPrivateData;            // offset: 0x0 ordinal: 0x1
  };
  USHORT Size;          // offset: 0x8 ordinal: 0x2
  UCHAR Flags;          // offset: 0xa ordinal: 0x3
  UCHAR SmallTagIndex;  // offset: 0xb ordinal: 0x4
  ULONG SubSegmentCode; // offset: 0x8 ordinal: 0x5
  USHORT PreviousSize;  // offset: 0xc ordinal: 0x6
  union {
    UCHAR SegmentOffset; // offset: 0xe ordinal: 0x7
    UCHAR LFHFlags;      // offset: 0xe ordinal: 0x8
  };
  UCHAR UnusedBytes;       // offset: 0xf ordinal: 0x9
  ULONGLONG CompactHeader; // offset: 0x8 ordinal: 0xa
  union {
    struct _HEAP_EXTENDED_ENTRY ExtendedEntry; // offset: 0x0 ordinal: 0xb
    VOID *Reserved;                            // offset: 0x0 ordinal: 0xc
  };
  USHORT FunctionIndex;         // offset: 0x8 ordinal: 0xd
  USHORT ContextValue;          // offset: 0xa ordinal: 0xe
  ULONG InterceptorValue;       // offset: 0x8 ordinal: 0xf
  USHORT UnusedBytesLength;     // offset: 0xc ordinal: 0x10
  UCHAR EntryOffset;            // offset: 0xe ordinal: 0x11
  UCHAR ExtendedBlockSignature; // offset: 0xf ordinal: 0x12
  VOID *ReservedForAlignment;   // offset: 0x0 ordinal: 0x13
  ULONG Code1;                  // offset: 0x8 ordinal: 0x14
  USHORT Code2;                 // offset: 0xc ordinal: 0x15
  UCHAR Code3;                  // offset: 0xe ordinal: 0x16
  UCHAR Code4;                  // offset: 0xf ordinal: 0x17
  ULONG Code234;                // offset: 0xc ordinal: 0x18
  ULONGLONG AgregateCode;       // offset: 0x8 ordinal: 0x19
} _HEAP_ENTRY;

// 0x20 bytes (sizeof)
typedef struct _HEAP_FREE_ENTRY {
  union {
    struct _HEAP_ENTRY HeapEntry;              // offset: 0x0 ordinal: 0x0
    struct _HEAP_UNPACKED_ENTRY UnpackedEntry; // offset: 0x0 ordinal: 0x1
    VOID *PreviousBlockPrivateData;            // offset: 0x0 ordinal: 0x2
  };
  USHORT Size;          // offset: 0x8 ordinal: 0x3
  UCHAR Flags;          // offset: 0xa ordinal: 0x4
  UCHAR SmallTagIndex;  // offset: 0xb ordinal: 0x5
  ULONG SubSegmentCode; // offset: 0x8 ordinal: 0x6
  USHORT PreviousSize;  // offset: 0xc ordinal: 0x7
  union {
    UCHAR SegmentOffset; // offset: 0xe ordinal: 0x8
    UCHAR LFHFlags;      // offset: 0xe ordinal: 0x9
  };
  UCHAR UnusedBytes;       // offset: 0xf ordinal: 0xa
  ULONGLONG CompactHeader; // offset: 0x8 ordinal: 0xb
  union {
    struct _HEAP_EXTENDED_ENTRY ExtendedEntry; // offset: 0x0 ordinal: 0xc
    VOID *Reserved;                            // offset: 0x0 ordinal: 0xd
  };
  USHORT FunctionIndex;         // offset: 0x8 ordinal: 0xe
  USHORT ContextValue;          // offset: 0xa ordinal: 0xf
  ULONG InterceptorValue;       // offset: 0x8 ordinal: 0x10
  USHORT UnusedBytesLength;     // offset: 0xc ordinal: 0x11
  UCHAR EntryOffset;            // offset: 0xe ordinal: 0x12
  UCHAR ExtendedBlockSignature; // offset: 0xf ordinal: 0x13
  VOID *ReservedForAlignment;   // offset: 0x0 ordinal: 0x14
  ULONG Code1;                  // offset: 0x8 ordinal: 0x15
  USHORT Code2;                 // offset: 0xc ordinal: 0x16
  UCHAR Code3;                  // offset: 0xe ordinal: 0x17
  UCHAR Code4;                  // offset: 0xf ordinal: 0x18
  ULONG Code234;                // offset: 0xc ordinal: 0x19
  ULONGLONG AgregateCode;       // offset: 0x8 ordinal: 0x1a
  struct _LIST_ENTRY FreeList;  // offset: 0x10 ordinal: 0x1b
} _HEAP_FREE_ENTRY;

// 0x40 bytes (sizeof)
typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
  struct _LIST_ENTRY Entry;            // offset: 0x0 ordinal: 0x0
  struct _HEAP_ENTRY_EXTRA ExtraStuff; // offset: 0x10 ordinal: 0x1
  ULONGLONG CommitSize;                // offset: 0x20 ordinal: 0x2
  ULONGLONG ReserveSize;               // offset: 0x28 ordinal: 0x3
  struct _HEAP_ENTRY BusyBlock;        // offset: 0x30 ordinal: 0x4
} _HEAP_VIRTUAL_ALLOC_ENTRY;

// 0x70 bytes (sizeof)
typedef struct _HEAP_SEGMENT {
  struct _HEAP_ENTRY Entry;              // offset: 0x0 ordinal: 0x0
  ULONG SegmentSignature;                // offset: 0x10 ordinal: 0x1
  ULONG SegmentFlags;                    // offset: 0x14 ordinal: 0x2
  struct _LIST_ENTRY SegmentListEntry;   // offset: 0x18 ordinal: 0x3
  struct _HEAP *Heap;                    // offset: 0x28 ordinal: 0x4
  VOID *BaseAddress;                     // offset: 0x30 ordinal: 0x5
  ULONG NumberOfPages;                   // offset: 0x38 ordinal: 0x6
  struct _HEAP_ENTRY *FirstEntry;        // offset: 0x40 ordinal: 0x7
  struct _HEAP_ENTRY *LastValidEntry;    // offset: 0x48 ordinal: 0x8
  ULONG NumberOfUnCommittedPages;        // offset: 0x50 ordinal: 0x9
  ULONG NumberOfUnCommittedRanges;       // offset: 0x54 ordinal: 0xa
  USHORT SegmentAllocatorBackTraceIndex; // offset: 0x58 ordinal: 0xb
  USHORT Reserved;                       // offset: 0x5a ordinal: 0xc
  struct _LIST_ENTRY UCRSegmentList;     // offset: 0x60 ordinal: 0xd
} _HEAP_SEGMENT;

// 0x28 bytes (sizeof)
typedef struct _HEAP_VS_SUBSEGMENT {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  ULONGLONG CommitBitmap;       // offset: 0x10 ordinal: 0x1
  ULONGLONG CommitLock;         // offset: 0x18 ordinal: 0x2
  USHORT Size;                  // offset: 0x20 ordinal: 0x3
  USHORT Signature : 15;        // offset: 0x22 ordinal: 0x4
  USHORT FullCommit : 1;        // offset: 0x22 ordinal: 0x5
} _HEAP_VS_SUBSEGMENT;

// 0x8 bytes (sizeof)
typedef union _HEAP_VS_CHUNK_HEADER_SIZE {
  ULONG MemoryCost : 16;     // offset: 0x0 ordinal: 0x0
  ULONG UnsafeSize : 16;     // offset: 0x0 ordinal: 0x1
  ULONG UnsafePrevSize : 16; // offset: 0x4 ordinal: 0x2
  ULONG Allocated : 8;       // offset: 0x4 ordinal: 0x3
  USHORT KeyUShort;          // offset: 0x0 ordinal: 0x4
  ULONG KeyULong;            // offset: 0x0 ordinal: 0x5
  ULONGLONG HeaderBits;      // offset: 0x0 ordinal: 0x6
} _HEAP_VS_CHUNK_HEADER_SIZE;

// 0x10 bytes (sizeof)
typedef struct _HEAP_VS_CHUNK_HEADER {
  union _HEAP_VS_CHUNK_HEADER_SIZE Sizes; // offset: 0x0 ordinal: 0x0
  ULONG EncodedSegmentPageOffset : 8;     // offset: 0x8 ordinal: 0x1
  ULONG UnusedBytes : 1;                  // offset: 0x8 ordinal: 0x2
  ULONG SkipDuringWalk : 1;               // offset: 0x8 ordinal: 0x3
  ULONG Spare : 22;                       // offset: 0x8 ordinal: 0x4
  ULONG AllocatedChunkBits;               // offset: 0x8 ordinal: 0x5
} _HEAP_VS_CHUNK_HEADER;

// 0x18 bytes (sizeof)
typedef struct _RTLP_HP_QUEUE_LOCK_HANDLE {
  ULONGLONG Reserved1;  // offset: 0x0 ordinal: 0x0
  ULONGLONG LockPtr;    // offset: 0x8 ordinal: 0x1
  ULONGLONG HandleData; // offset: 0x10 ordinal: 0x2
} _RTLP_HP_QUEUE_LOCK_HANDLE;

// 0x8 bytes (sizeof)
typedef union _HEAP_LFH_SUBSEGMENT_DELAY_FREE {
  ULONGLONG DelayFree : 1; // offset: 0x0 ordinal: 0x0
  ULONGLONG Count : 63;    // offset: 0x0 ordinal: 0x1
  VOID *AllBits;           // offset: 0x0 ordinal: 0x2
} _HEAP_LFH_SUBSEGMENT_DELAY_FREE;

typedef VOID *(*__anon_2794)(ULONGLONG, VOID *);

// 0x8 bytes (sizeof)
typedef struct _RTL_SRWLOCK {
  ULONGLONG Locked : 1;         // offset: 0x0 ordinal: 0x0
  ULONGLONG Waiting : 1;        // offset: 0x0 ordinal: 0x1
  ULONGLONG Waking : 1;         // offset: 0x0 ordinal: 0x2
  ULONGLONG MultipleShared : 1; // offset: 0x0 ordinal: 0x3
  ULONGLONG Shared : 60;        // offset: 0x0 ordinal: 0x4
  union {
    ULONGLONG Value; // offset: 0x0 ordinal: 0x5
    VOID *Ptr;       // offset: 0x0 ordinal: 0x6
  };
} _RTL_SRWLOCK;

// 0x180 bytes (sizeof)
typedef struct _ALPC_COMPLETION_LIST_HEADER {
  ULONGLONG StartMagic;                     // offset: 0x0 ordinal: 0x0
  ULONG TotalSize;                          // offset: 0x8 ordinal: 0x1
  ULONG ListOffset;                         // offset: 0xc ordinal: 0x2
  ULONG ListSize;                           // offset: 0x10 ordinal: 0x3
  ULONG BitmapOffset;                       // offset: 0x14 ordinal: 0x4
  ULONG BitmapSize;                         // offset: 0x18 ordinal: 0x5
  ULONG DataOffset;                         // offset: 0x1c ordinal: 0x6
  ULONG DataSize;                           // offset: 0x20 ordinal: 0x7
  ULONG AttributeFlags;                     // offset: 0x24 ordinal: 0x8
  ULONG AttributeSize;                      // offset: 0x28 ordinal: 0x9
  struct _ALPC_COMPLETION_LIST_STATE State; // offset: 0x40 ordinal: 0xa
  ULONG LastMessageId;                      // offset: 0x48 ordinal: 0xb
  ULONG LastCallbackId;                     // offset: 0x4c ordinal: 0xc
  ULONG PostCount;                          // offset: 0x80 ordinal: 0xd
  ULONG ReturnCount;                        // offset: 0xc0 ordinal: 0xe
  ULONG LogSequenceNumber;                  // offset: 0x100 ordinal: 0xf
  struct _RTL_SRWLOCK UserLock;             // offset: 0x140 ordinal: 0x10
  ULONGLONG EndMagic;                       // offset: 0x148 ordinal: 0x11
} _ALPC_COMPLETION_LIST_HEADER;

// 0x48 bytes (sizeof)
typedef struct _RTL_STACKDB_CONTEXT {
  struct _RTL_HASH_TABLE StackSegmentTable; // offset: 0x0 ordinal: 0x0
  struct _RTL_HASH_TABLE StackEntryTable;   // offset: 0x10 ordinal: 0x1
  struct _RTL_SRWLOCK StackEntryTableLock;  // offset: 0x20 ordinal: 0x2
  struct _RTL_SRWLOCK SegmentTableLock;     // offset: 0x28 ordinal: 0x3
  VOID *(*Allocate)(ULONGLONG, VOID *);     // offset: 0x30 ordinal: 0x4
  VOID (*Free)(VOID *, VOID *);             // offset: 0x38 ordinal: 0x5
  VOID *AllocatorContext;                   // offset: 0x40 ordinal: 0x6
} _RTL_STACKDB_CONTEXT;

// 0x8 bytes (sizeof)
typedef struct _HEAP_LFH_FAST_REF {
  union {
    VOID *Target;            // offset: 0x0 ordinal: 0x0
    ULONGLONG Value;         // offset: 0x0 ordinal: 0x1
    ULONGLONG RefCount : 12; // offset: 0x0 ordinal: 0x2
  };
} _HEAP_LFH_FAST_REF;

// 0x38 bytes (sizeof)
typedef struct _HEAP_LFH_SUBSEGMENT_OWNER {
  UCHAR IsBucket : 1; // offset: 0x0 ordinal: 0x0
  UCHAR Spare0 : 7;   // offset: 0x0 ordinal: 0x1
  UCHAR BucketIndex;  // offset: 0x1 ordinal: 0x2
  union {
    UCHAR SlotCount; // offset: 0x2 ordinal: 0x3
    UCHAR SlotIndex; // offset: 0x2 ordinal: 0x4
  };
  UCHAR Spare1;                               // offset: 0x3 ordinal: 0x5
  ULONGLONG AvailableSubsegmentCount;         // offset: 0x8 ordinal: 0x6
  ULONGLONG Lock;                             // offset: 0x10 ordinal: 0x7
  struct _LIST_ENTRY AvailableSubsegmentList; // offset: 0x18 ordinal: 0x8
  struct _LIST_ENTRY FullSubsegmentList;      // offset: 0x28 ordinal: 0x9
} _HEAP_LFH_SUBSEGMENT_OWNER;

// 0x40 bytes (sizeof)
typedef struct _HEAP_LFH_AFFINITY_SLOT {
  struct _HEAP_LFH_SUBSEGMENT_OWNER State;    // offset: 0x0 ordinal: 0x0
  struct _HEAP_LFH_FAST_REF ActiveSubsegment; // offset: 0x38 ordinal: 0x1
} _HEAP_LFH_AFFINITY_SLOT;

// 0x68 bytes (sizeof)
typedef struct _HEAP_LFH_BUCKET {
  struct _HEAP_LFH_SUBSEGMENT_OWNER State;        // offset: 0x0 ordinal: 0x0
  ULONGLONG TotalBlockCount;                      // offset: 0x38 ordinal: 0x1
  ULONGLONG TotalSubsegmentCount;                 // offset: 0x40 ordinal: 0x2
  ULONG ReciprocalBlockSize;                      // offset: 0x48 ordinal: 0x3
  UCHAR Shift;                                    // offset: 0x4c ordinal: 0x4
  UCHAR ContentionCount;                          // offset: 0x4d ordinal: 0x5
  ULONGLONG AffinityMappingLock;                  // offset: 0x50 ordinal: 0x6
  UCHAR *ProcAffinityMapping;                     // offset: 0x58 ordinal: 0x7
  struct _HEAP_LFH_AFFINITY_SLOT **AffinitySlots; // offset: 0x60 ordinal: 0x8
} _HEAP_LFH_BUCKET;

// 0xc0 bytes (sizeof)
typedef struct _HEAP_SEG_CONTEXT {
  ULONGLONG SegmentMask;                        // offset: 0x0 ordinal: 0x0
  UCHAR UnitShift;                              // offset: 0x8 ordinal: 0x1
  UCHAR PagesPerUnitShift;                      // offset: 0x9 ordinal: 0x2
  UCHAR FirstDescriptorIndex;                   // offset: 0xa ordinal: 0x3
  UCHAR CachedCommitSoftShift;                  // offset: 0xb ordinal: 0x4
  UCHAR CachedCommitHighShift;                  // offset: 0xc ordinal: 0x5
  union __anon_2780 Flags;                      // offset: 0xd ordinal: 0x6
  ULONG MaxAllocationSize;                      // offset: 0x10 ordinal: 0x7
  SHORT OlpStatsOffset;                         // offset: 0x14 ordinal: 0x8
  SHORT MemStatsOffset;                         // offset: 0x16 ordinal: 0x9
  VOID *LfhContext;                             // offset: 0x18 ordinal: 0xa
  VOID *VsContext;                              // offset: 0x20 ordinal: 0xb
  struct RTL_HP_ENV_HANDLE EnvHandle;           // offset: 0x28 ordinal: 0xc
  VOID *Heap;                                   // offset: 0x38 ordinal: 0xd
  ULONGLONG SegmentLock;                        // offset: 0x40 ordinal: 0xe
  struct _LIST_ENTRY SegmentListHead;           // offset: 0x48 ordinal: 0xf
  ULONGLONG SegmentCount;                       // offset: 0x58 ordinal: 0x10
  struct _RTL_RB_TREE FreePageRanges;           // offset: 0x60 ordinal: 0x11
  ULONGLONG FreeSegmentListLock;                // offset: 0x70 ordinal: 0x12
  struct _SINGLE_LIST_ENTRY FreeSegmentList[2]; // offset: 0x78 ordinal: 0x13
} _HEAP_SEG_CONTEXT;

// 0x18 bytes (sizeof)
typedef struct _RTL_HP_SEG_ALLOC_POLICY {
  ULONGLONG MinLargePages; // offset: 0x0 ordinal: 0x0
  ULONGLONG MaxLargePages; // offset: 0x8 ordinal: 0x1
  UCHAR MinUtilization;    // offset: 0x10 ordinal: 0x2
} _RTL_HP_SEG_ALLOC_POLICY;

// 0x20 bytes (sizeof)
typedef struct _RTL_HP_HEAP_VA_CALLBACKS_ENCODED {
  ULONGLONG CallbackContext;              // offset: 0x0 ordinal: 0x0
  ULONGLONG AllocateVirtualMemoryEncoded; // offset: 0x8 ordinal: 0x1
  ULONGLONG FreeVirtualMemoryEncoded;     // offset: 0x10 ordinal: 0x2
  ULONGLONG QueryVirtualMemoryEncoded;    // offset: 0x18 ordinal: 0x3
} _RTL_HP_HEAP_VA_CALLBACKS_ENCODED;

// 0x58 bytes (sizeof)
typedef struct _HEAP_RUNTIME_MEMORY_STATS {
  ULONGLONG TotalReservedPages;    // offset: 0x0 ordinal: 0x0
  ULONGLONG TotalCommittedPages;   // offset: 0x8 ordinal: 0x1
  ULONGLONG FreeCommittedPages;    // offset: 0x10 ordinal: 0x2
  ULONGLONG LfhFreeCommittedPages; // offset: 0x18 ordinal: 0x3
  struct _HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS
      LargePageStats[2]; // offset: 0x20 ordinal: 0x4
  struct _RTL_HP_SEG_ALLOC_POLICY
      LargePageUtilizationPolicy; // offset: 0x40 ordinal: 0x5
} _HEAP_RUNTIME_MEMORY_STATS;

// 0x10 bytes (sizeof)
typedef struct _FAKE_HEAP_ENTRY {
  ULONGLONG Size;         // offset: 0x0 ordinal: 0x0
  ULONGLONG PreviousSize; // offset: 0x8 ordinal: 0x1
} _FAKE_HEAP_ENTRY;

// 0x8 bytes (sizeof)
typedef union _RTL_RUN_ONCE {
  VOID *Ptr;           // offset: 0x0 ordinal: 0x0
  ULONGLONG Value;     // offset: 0x0 ordinal: 0x1
  ULONGLONG State : 2; // offset: 0x0 ordinal: 0x2
} _RTL_RUN_ONCE;

// 0x20 bytes (sizeof)
typedef struct _RTL_HEAP_MEMORY_LIMIT_DATA {
  ULONGLONG CommitLimitBytes;           // offset: 0x0 ordinal: 0x0
  ULONGLONG CommitLimitFailureCode;     // offset: 0x8 ordinal: 0x1
  ULONGLONG MaxAllocationSizeBytes;     // offset: 0x10 ordinal: 0x2
  ULONGLONG AllocationLimitFailureCode; // offset: 0x18 ordinal: 0x3
} _RTL_HEAP_MEMORY_LIMIT_DATA;

// 0x28 bytes (sizeof)
typedef struct _HEAP_SUBALLOCATOR_CALLBACKS {
  ULONGLONG Allocate;      // offset: 0x0 ordinal: 0x0
  ULONGLONG Free;          // offset: 0x8 ordinal: 0x1
  ULONGLONG Commit;        // offset: 0x10 ordinal: 0x2
  ULONGLONG Decommit;      // offset: 0x18 ordinal: 0x3
  ULONGLONG ExtendContext; // offset: 0x20 ordinal: 0x4
} _HEAP_SUBALLOCATOR_CALLBACKS;

// 0x4c0 bytes (sizeof)
typedef struct _HEAP_LFH_CONTEXT {
  VOID *BackendCtx;                              // offset: 0x0 ordinal: 0x0
  struct _HEAP_SUBALLOCATOR_CALLBACKS Callbacks; // offset: 0x8 ordinal: 0x1
  UCHAR *AffinityModArray;                       // offset: 0x30 ordinal: 0x2
  UCHAR MaxAffinity;                             // offset: 0x38 ordinal: 0x3
  UCHAR LockType;                                // offset: 0x39 ordinal: 0x4
  SHORT MemStatsOffset;                          // offset: 0x3a ordinal: 0x5
  struct _RTL_HP_LFH_CONFIG Config;              // offset: 0x3c ordinal: 0x6
  union _HEAP_LFH_SUBSEGMENT_STATS BucketStats;  // offset: 0x40 ordinal: 0x7
  ULONGLONG SubsegmentCreationLock;              // offset: 0x48 ordinal: 0x8
  struct _HEAP_LFH_BUCKET *Buckets[129];         // offset: 0x80 ordinal: 0x9
} _HEAP_LFH_CONTEXT;

// 0x78 bytes (sizeof)
typedef struct _PRIVATE_CACHE_MAP {
  union {
    SHORT NodeTypeCode;                    // offset: 0x0 ordinal: 0x0
    struct _PRIVATE_CACHE_MAP_FLAGS Flags; // offset: 0x0 ordinal: 0x1
  };
  ULONG ReadAheadMask;                          // offset: 0x4 ordinal: 0x2
  struct _FILE_OBJECT *FileObject;              // offset: 0x8 ordinal: 0x3
  union _LARGE_INTEGER FileOffset1;             // offset: 0x10 ordinal: 0x4
  union _LARGE_INTEGER BeyondLastByte1;         // offset: 0x18 ordinal: 0x5
  union _LARGE_INTEGER FileOffset2;             // offset: 0x20 ordinal: 0x6
  union _LARGE_INTEGER BeyondLastByte2;         // offset: 0x28 ordinal: 0x7
  ULONG SequentialReadCount;                    // offset: 0x30 ordinal: 0x8
  ULONG ReadAheadLength;                        // offset: 0x34 ordinal: 0x9
  union _LARGE_INTEGER ReadAheadOffset;         // offset: 0x38 ordinal: 0xa
  union _LARGE_INTEGER ReadAheadBeyondLastByte; // offset: 0x40 ordinal: 0xb
  ULONGLONG PrevReadAheadBeyondLastByte;        // offset: 0x48 ordinal: 0xc
  ULONGLONG ReadAheadSpinLock;                  // offset: 0x50 ordinal: 0xd
  ULONG PipelinedReadAheadRequestSize;          // offset: 0x58 ordinal: 0xe
  ULONG ReadAheadGrowth;                        // offset: 0x5c ordinal: 0xf
  struct _LIST_ENTRY PrivateLinks;              // offset: 0x60 ordinal: 0x10
  VOID *ReadAheadWorkItem;                      // offset: 0x70 ordinal: 0x11
} _PRIVATE_CACHE_MAP;

// 0x38 bytes (sizeof)
typedef struct _DIRTY_PAGE_THRESHOLDS {
  ULONGLONG DirtyPageThreshold;       // offset: 0x0 ordinal: 0x0
  ULONGLONG DirtyPageThresholdTop;    // offset: 0x8 ordinal: 0x1
  ULONGLONG DirtyPageThresholdBottom; // offset: 0x10 ordinal: 0x2
  ULONG DirtyPageTarget;              // offset: 0x18 ordinal: 0x3
  ULONGLONG AggregateAvailablePages;  // offset: 0x20 ordinal: 0x4
  ULONGLONG AggregateDirtyPages;      // offset: 0x28 ordinal: 0x5
  ULONG AvailableHistory;             // offset: 0x30 ordinal: 0x6
} _DIRTY_PAGE_THRESHOLDS;

// 0x18 bytes (sizeof)
typedef struct _DIRTY_PAGE_STATISTICS {
  ULONGLONG DirtyPages;              // offset: 0x0 ordinal: 0x0
  ULONGLONG DirtyPagesLastScan;      // offset: 0x8 ordinal: 0x1
  ULONG DirtyPagesScheduledLastScan; // offset: 0x10 ordinal: 0x2
} _DIRTY_PAGE_STATISTICS;

// 0x9b0 bytes (sizeof)
typedef struct _CC_VOLUME_TELEMETRY {
  struct _GUID DeviceGuid;                  // offset: 0x0 ordinal: 0x0
  ULONGLONG TotalDirtyPages;                // offset: 0x10 ordinal: 0x1
  ULONGLONG MaxDirtyPages;                  // offset: 0x18 ordinal: 0x2
  ULONGLONG TotalDirtyPageThreshold;        // offset: 0x20 ordinal: 0x3
  ULONGLONG TopDirtyPageThreshold;          // offset: 0x28 ordinal: 0x4
  ULONGLONG BottomDirtyPageThreshold;       // offset: 0x30 ordinal: 0x5
  ULONGLONG DirtyPageSamples;               // offset: 0x38 ordinal: 0x6
  ULONGLONG TotalPagesQueuedToDisk;         // offset: 0x40 ordinal: 0x7
  ULONGLONG MaxPagesQueuedToDisk;           // offset: 0x48 ordinal: 0x8
  ULONGLONG PagesQueuedToDiskSamples;       // offset: 0x50 ordinal: 0x9
  ULONGLONG TotalLoggedPagesQueuedToDisk;   // offset: 0x58 ordinal: 0xa
  ULONGLONG MaxLoggedPagesQueuedToDisk;     // offset: 0x60 ordinal: 0xb
  ULONGLONG LoggedPagesQueuedToDiskSamples; // offset: 0x68 ordinal: 0xc
  ULONGLONG ReadTotalBytes;                 // offset: 0x70 ordinal: 0xd
  ULONGLONG ReadPagedInTotalBytes;          // offset: 0x78 ordinal: 0xe
  ULONGLONG ReadAheadTotalBytes;            // offset: 0x80 ordinal: 0xf
  ULONGLONG TotalSynchronousReadIoCount;    // offset: 0x88 ordinal: 0x10
  ULONGLONG
  TotalSynchronousNonBlockingReadIoCount; // offset: 0x90 ordinal: 0x11
  ULONGLONG TotalFailedSynchronousNonBlockingReadIoCount; // offset: 0x98
                                                          // ordinal: 0x12
  ULONGLONG TotalWrites;                      // offset: 0xa0 ordinal: 0x13
  ULONGLONG TotalHardThrottleWrites;          // offset: 0xa8 ordinal: 0x14
  ULONGLONG TotalSoftThrottleWrites;          // offset: 0xb0 ordinal: 0x15
  ULONGLONG TotalLazyWriterCalls;             // offset: 0xb8 ordinal: 0x16
  ULONGLONG TotalLazyWriterLatency;           // offset: 0xc0 ordinal: 0x17
  ULONGLONG TotalLazyWriterPagesFlushed;      // offset: 0xc8 ordinal: 0x18
  ULONGLONG TotalLazyWriterAvgPagesPerSecond; // offset: 0xd0 ordinal: 0x19
  ULONGLONG SynchronousReadIoMaxLatency;      // offset: 0xd8 ordinal: 0x1a
  ULONGLONG
  SynchronousReadIoNonBlockingMaxLatency;    // offset: 0xe0 ordinal: 0x1b
  ULONGLONG SynchronousReadIoCounts[12];     // offset: 0xe8 ordinal: 0x1c
  ULONGLONG SynchronousReadTotalLatency[12]; // offset: 0x148 ordinal: 0x1d
  ULONGLONG
  SynchronousReadNonBlockingIoCounts[12]; // offset: 0x1a8 ordinal: 0x1e
  ULONGLONG
  SynchronousReadNonBlockingTotalLatency[12]; // offset: 0x208 ordinal: 0x1f
  ULONGLONG TotalSynchronousWriteIoCount;     // offset: 0x268 ordinal: 0x20
  ULONGLONG
  TotalSynchronousNonBlockingWriteIoCount; // offset: 0x270 ordinal: 0x21
  ULONGLONG TotalFailedSynchronousNonBlockingWriteIoCount; // offset: 0x278
                                                           // ordinal: 0x22
  ULONGLONG SynchronousWriteIoMaxLatency; // offset: 0x280 ordinal: 0x23
  ULONGLONG
  SynchronousWriteIoNonBlockingMaxLatency;    // offset: 0x288 ordinal: 0x24
  ULONGLONG SynchronousWriteIoCounts[12];     // offset: 0x290 ordinal: 0x25
  ULONGLONG SynchronousWriteTotalLatency[12]; // offset: 0x2f0 ordinal: 0x26
  ULONGLONG
  SynchronousWriteNonBlockingIoCounts[12]; // offset: 0x350 ordinal: 0x27
  ULONGLONG SynchronousWriteNonBlockingTotalLatency[12]; // offset: 0x3b0
                                                         // ordinal: 0x28
  ULONGLONG TotalAsynchronousReadIoCount;       // offset: 0x410 ordinal: 0x29
  ULONGLONG AsynchronousReadIoMaxLatency;       // offset: 0x418 ordinal: 0x2a
  ULONGLONG AsynchronousReadIoCounts[12];       // offset: 0x420 ordinal: 0x2b
  ULONGLONG AsynchronousReadTotalLatency[12];   // offset: 0x480 ordinal: 0x2c
  ULONGLONG CumulativeTotalDirtyPages;          // offset: 0x4e0 ordinal: 0x2d
  ULONGLONG CumulativeMaxDirtyPages;            // offset: 0x4e8 ordinal: 0x2e
  ULONGLONG CumulativeDirtyPageThreshold;       // offset: 0x4f0 ordinal: 0x2f
  ULONGLONG CumulativeTopDirtyPageThreshold;    // offset: 0x4f8 ordinal: 0x30
  ULONGLONG CumulativeBottomDirtyPageThreshold; // offset: 0x500 ordinal: 0x31
  ULONGLONG CumulativeDirtyPageSamples;         // offset: 0x508 ordinal: 0x32
  ULONGLONG CumulativeTotalPagesQueuedToDisk;   // offset: 0x510 ordinal: 0x33
  ULONGLONG CumulativeMaxPagesQueuedToDisk;     // offset: 0x518 ordinal: 0x34
  ULONGLONG CumulativePagesQueuedToDiskSamples; // offset: 0x520 ordinal: 0x35
  ULONGLONG
  CumulativeTotalLoggedPagesQueuedToDisk;         // offset: 0x528 ordinal: 0x36
  ULONGLONG CumulativeMaxLoggedPagesQueuedToDisk; // offset: 0x530 ordinal: 0x37
  ULONGLONG
  CumulativeLoggedPagesQueuedToDiskSamples;  // offset: 0x538 ordinal: 0x38
  ULONGLONG CumulativeReadTotalBytes;        // offset: 0x540 ordinal: 0x39
  ULONGLONG CumulativeReadPagedInTotalBytes; // offset: 0x548 ordinal: 0x3a
  ULONGLONG CumulativeReadAheadTotalBytes;   // offset: 0x550 ordinal: 0x3b
  ULONGLONG
  CumulativeTotalSynchronousReadIoCount; // offset: 0x558 ordinal: 0x3c
  ULONGLONG CumulativeTotalSynchronousNonBlockingReadIoCount; // offset: 0x560
                                                              // ordinal: 0x3d
  ULONGLONG
  CumulativeTotalFailedSynchronousNonBlockingReadIoCount; // offset: 0x568
                                                          // ordinal: 0x3e
  ULONGLONG CumulativeTotalWrites;             // offset: 0x570 ordinal: 0x3f
  ULONGLONG CumulativeTotalHardThrottleWrites; // offset: 0x578 ordinal: 0x40
  ULONGLONG CumulativeTotalSoftThrottleWrites; // offset: 0x580 ordinal: 0x41
  ULONGLONG CumulativeLazyWriterCalls;         // offset: 0x588 ordinal: 0x42
  ULONGLONG CumulativeLazyWriterLatency;       // offset: 0x590 ordinal: 0x43
  ULONGLONG CumulativeLazyWriterPagesFlushed;  // offset: 0x598 ordinal: 0x44
  ULONGLONG
  CumulativeLazyWriterAvgPagesPerSecond; // offset: 0x5a0 ordinal: 0x45
  ULONGLONG
  CumulativeSynchronousReadIoMaxLatency; // offset: 0x5a8 ordinal: 0x46
  ULONGLONG CumulativeSynchronousReadIoNonBlockingMaxLatency; // offset: 0x5b0
                                                              // ordinal: 0x47
  ULONGLONG
  CumulativeSynchronousReadIoCounts[12]; // offset: 0x5b8 ordinal: 0x48
  ULONGLONG
  CumulativeSynchronousReadTotalLatency[12]; // offset: 0x618 ordinal: 0x49
  ULONGLONG CumulativeSynchronousReadNonBlockingIoCounts[12]; // offset: 0x678
                                                              // ordinal: 0x4a
  ULONGLONG
  CumulativeSynchronousReadNonBlockingTotalLatency[12]; // offset: 0x6d8
                                                        // ordinal: 0x4b
  ULONGLONG
  CumulativeTotalSynchronousWriteIoCount; // offset: 0x738 ordinal: 0x4c
  ULONGLONG CumulativeTotalSynchronousNonBlockingWriteIoCount; // offset: 0x740
                                                               // ordinal: 0x4d
  ULONGLONG
  CumulativeTotalFailedSynchronousNonBlockingWriteIoCount; // offset: 0x748
                                                           // ordinal: 0x4e
  ULONGLONG
  CumulativeSynchronousWriteIoMaxLatency; // offset: 0x750 ordinal: 0x4f
  ULONGLONG CumulativeSynchronousWriteIoNonBlockingMaxLatency; // offset: 0x758
                                                               // ordinal: 0x50
  ULONGLONG
  CumulativeSynchronousWriteIoCounts[12]; // offset: 0x760 ordinal: 0x51
  ULONGLONG
  CumulativeSynchronousWriteTotalLatency[12]; // offset: 0x7c0 ordinal: 0x52
  ULONGLONG CumulativeSynchronousWriteNonBlockingIoCounts[12]; // offset: 0x820
                                                               // ordinal: 0x53
  ULONGLONG
  CumulativeSynchronousWriteNonBlockingTotalLatency[12]; // offset: 0x880
                                                         // ordinal: 0x54
  ULONGLONG
  CumulativeTotalAsynchronousReadIoCount; // offset: 0x8e0 ordinal: 0x55
  ULONGLONG
  CumulativeAsynchronousReadIoMaxLatency; // offset: 0x8e8 ordinal: 0x56
  ULONGLONG
  CumulativeAsynchronousReadIoCounts[12]; // offset: 0x8f0 ordinal: 0x57
  ULONGLONG
  CumulativeAsynchronousReadTotalLatency[12]; // offset: 0x950 ordinal: 0x58
} _CC_VOLUME_TELEMETRY;

// 0x98 bytes (sizeof)
typedef struct _LOG_HANDLE_CONTEXT {
  VOID *LogHandle; // offset: 0x0 ordinal: 0x0
  VOID(*FlushToLsnRoutine)
  (VOID *, union _LARGE_INTEGER); // offset: 0x8 ordinal: 0x1
  VOID(*QueryLogHandleInfoRoutine)
  (VOID *, USHORT *); // offset: 0x10 ordinal: 0x2
  struct _DIRTY_PAGE_STATISTICS
      DirtyPageStatistics; // offset: 0x18 ordinal: 0x3
  struct _DIRTY_PAGE_THRESHOLDS
      DirtyPageThresholds;                         // offset: 0x30 ordinal: 0x4
  ULONG AdditionalPagesToWrite;                    // offset: 0x68 ordinal: 0x5
  ULONG CcLWScanDPThreshold;                       // offset: 0x6c ordinal: 0x6
  union _LARGE_INTEGER LargestLsnForCurrentLWScan; // offset: 0x70 ordinal: 0x7
  struct _FILE_OBJECT *RelatedFileObject;          // offset: 0x78 ordinal: 0x8
  ULONGLONG LargestLsnFileObjectKey;               // offset: 0x80 ordinal: 0x9
  union _LARGE_INTEGER LastLWTimeStamp;            // offset: 0x88 ordinal: 0xa
  ULONG Flags;                                     // offset: 0x90 ordinal: 0xb
} _LOG_HANDLE_CONTEXT;

// 0x8 bytes (sizeof)
typedef struct _LOGGED_STREAM_CALLBACK_V2 {
  struct _LOG_HANDLE_CONTEXT *LogHandleContext; // offset: 0x0 ordinal: 0x0
} _LOGGED_STREAM_CALLBACK_V2;

// 0xa90 bytes (sizeof)
typedef struct _VOLUME_CACHE_MAP {
  SHORT NodeTypeCode;                          // offset: 0x0 ordinal: 0x0
  SHORT NodeByteCode;                          // offset: 0x2 ordinal: 0x1
  ULONG UseCount;                              // offset: 0x4 ordinal: 0x2
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x8 ordinal: 0x3
  struct _LIST_ENTRY VolumeCacheMapLinks;      // offset: 0x10 ordinal: 0x4
  ULONGLONG DirtyPages;                        // offset: 0x20 ordinal: 0x5
  struct _LOG_HANDLE_CONTEXT LogHandleContext; // offset: 0x28 ordinal: 0x6
  ULONG Flags;                                 // offset: 0xc0 ordinal: 0x7
  ULONG PagesQueuedToDisk;                     // offset: 0xc4 ordinal: 0x8
  ULONG LoggedPagesQueuedToDisk;               // offset: 0xc8 ordinal: 0x9
  ULONG VolumeId;                              // offset: 0xcc ordinal: 0xa
  struct _LIST_ENTRY PrivateVolumeList;        // offset: 0xd0 ordinal: 0xb
  struct _CC_VOLUME_TELEMETRY VolumeTelemetry; // offset: 0xe0 ordinal: 0xc
} _VOLUME_CACHE_MAP;

// 0x8 bytes (sizeof)
typedef union _PPM_POLICY_SETTINGS_MASK {
  ULONGLONG Value;                               // offset: 0x0 ordinal: 0x0
  ULONG PerfDecreaseTime : 1;                    // offset: 0x0 ordinal: 0x1
  ULONG PerfIncreaseTime : 1;                    // offset: 0x0 ordinal: 0x2
  ULONG PerfDecreasePolicy : 1;                  // offset: 0x0 ordinal: 0x3
  ULONG PerfIncreasePolicy : 1;                  // offset: 0x0 ordinal: 0x4
  ULONG PerfDecreaseThreshold : 1;               // offset: 0x0 ordinal: 0x5
  ULONG PerfIncreaseThreshold : 1;               // offset: 0x0 ordinal: 0x6
  ULONG PerfMinPolicy : 1;                       // offset: 0x0 ordinal: 0x7
  ULONG PerfMaxPolicy : 1;                       // offset: 0x0 ordinal: 0x8
  ULONG PerfTimeCheck : 1;                       // offset: 0x0 ordinal: 0x9
  ULONG PerfBoostPolicy : 1;                     // offset: 0x0 ordinal: 0xa
  ULONG PerfBoostMode : 1;                       // offset: 0x0 ordinal: 0xb
  ULONG AllowThrottling : 1;                     // offset: 0x0 ordinal: 0xc
  ULONG PerfHistoryCount : 1;                    // offset: 0x0 ordinal: 0xd
  ULONG ParkingPerfState : 1;                    // offset: 0x0 ordinal: 0xe
  ULONG LatencyHintPerf : 1;                     // offset: 0x0 ordinal: 0xf
  ULONG LatencyHintUnpark : 1;                   // offset: 0x0 ordinal: 0x10
  ULONG CoreParkingMinCores : 1;                 // offset: 0x0 ordinal: 0x11
  ULONG CoreParkingMaxCores : 1;                 // offset: 0x0 ordinal: 0x12
  ULONG CoreParkingDecreasePolicy : 1;           // offset: 0x0 ordinal: 0x13
  ULONG CoreParkingIncreasePolicy : 1;           // offset: 0x0 ordinal: 0x14
  ULONG CoreParkingDecreaseTime : 1;             // offset: 0x0 ordinal: 0x15
  ULONG CoreParkingIncreaseTime : 1;             // offset: 0x0 ordinal: 0x16
  ULONG CoreParkingOverUtilizationThreshold : 1; // offset: 0x0 ordinal: 0x17
  ULONG CoreParkingDistributeUtility : 1;        // offset: 0x0 ordinal: 0x18
  ULONG CoreParkingConcurrencyThreshold : 1;     // offset: 0x0 ordinal: 0x19
  ULONG CoreParkingHeadroomThreshold : 1;        // offset: 0x0 ordinal: 0x1a
  ULONG CoreParkingDistributionThreshold : 1;    // offset: 0x0 ordinal: 0x1b
  ULONG IdleAllowScaling : 1;                    // offset: 0x0 ordinal: 0x1c
  ULONG IdleDisable : 1;                         // offset: 0x0 ordinal: 0x1d
  ULONG IdleTimeCheck : 1;                       // offset: 0x0 ordinal: 0x1e
  ULONG IdleDemoteThreshold : 1;                 // offset: 0x0 ordinal: 0x1f
  ULONG IdlePromoteThreshold : 1;                // offset: 0x0 ordinal: 0x20
  ULONG HeteroDecreaseTime : 1;                  // offset: 0x4 ordinal: 0x21
  ULONG HeteroIncreaseTime : 1;                  // offset: 0x4 ordinal: 0x22
  ULONG HeteroDecreaseThreshold : 1;             // offset: 0x4 ordinal: 0x23
  ULONG HeteroIncreaseThreshold : 1;             // offset: 0x4 ordinal: 0x24
  ULONG Class0FloorPerformance : 1;              // offset: 0x4 ordinal: 0x25
  ULONG Class1InitialPerformance : 1;            // offset: 0x4 ordinal: 0x26
  ULONG EnergyPerfPreference : 1;                // offset: 0x4 ordinal: 0x27
  ULONG AutonomousActivityWindow : 1;            // offset: 0x4 ordinal: 0x28
  ULONG AutonomousMode : 1;                      // offset: 0x4 ordinal: 0x29
  ULONG DutyCycling : 1;                         // offset: 0x4 ordinal: 0x2a
  ULONG FrequencyCap : 1;                        // offset: 0x4 ordinal: 0x2b
  ULONG ThreadPolicy : 1;                        // offset: 0x4 ordinal: 0x2c
  ULONG ShortThreadPolicy : 1;                   // offset: 0x4 ordinal: 0x2d
  ULONG IdleStateMax : 1;                        // offset: 0x4 ordinal: 0x2e
  ULONG ResponsivenessDisableThreshold : 1;      // offset: 0x4 ordinal: 0x2f
  ULONG ResponsivenessEnableThreshold : 1;       // offset: 0x4 ordinal: 0x30
  ULONG ResponsivenessDisableTime : 1;           // offset: 0x4 ordinal: 0x31
  ULONG ResponsivenessEnableTime : 1;            // offset: 0x4 ordinal: 0x32
  ULONG ResponsivenessEppCeiling : 1;            // offset: 0x4 ordinal: 0x33
  ULONG ResponsivenessPerfFloor : 1;             // offset: 0x4 ordinal: 0x34
  ULONG SoftParkLatency : 1;                     // offset: 0x4 ordinal: 0x35
  ULONG ShortThreadRuntimeThreshold : 1;         // offset: 0x4 ordinal: 0x36
  ULONG ShortThreadArchClassUpperThreshold : 1;  // offset: 0x4 ordinal: 0x37
  ULONG ShortThreadArchClassLowerThreshold : 1;  // offset: 0x4 ordinal: 0x38
  ULONG LongThreadArchClassUpperThreshold : 1;   // offset: 0x4 ordinal: 0x39
  ULONG LongThreadArchClassLowerThreshold : 1;   // offset: 0x4 ordinal: 0x3a
  ULONG ModuleUnparkPolicy : 1;                  // offset: 0x4 ordinal: 0x3b
  ULONG ComplexUnparkPolicy : 1;                 // offset: 0x4 ordinal: 0x3c
  ULONG SmtUnparkPolicy : 1;                     // offset: 0x4 ordinal: 0x3d
  ULONG Spare : 3;                               // offset: 0x4 ordinal: 0x3e
} _PPM_POLICY_SETTINGS_MASK;

// 0x1b8 bytes (sizeof)
typedef struct _PPM_ENGINE_SETTINGS {
  union _PPM_POLICY_SETTINGS_MASK
      ExplicitSetting[2];                     // offset: 0x0 ordinal: 0x0
  UCHAR ThrottlingPolicy;                     // offset: 0x10 ordinal: 0x1
  ULONG PerfTimeCheck;                        // offset: 0x14 ordinal: 0x2
  UCHAR PerfHistoryCount[2];                  // offset: 0x18 ordinal: 0x3
  UCHAR PerfMinPolicy[2];                     // offset: 0x1a ordinal: 0x4
  UCHAR PerfMaxPolicy[2];                     // offset: 0x1c ordinal: 0x5
  UCHAR PerfDecreaseTime[2];                  // offset: 0x1e ordinal: 0x6
  UCHAR PerfIncreaseTime[2];                  // offset: 0x20 ordinal: 0x7
  UCHAR PerfDecreasePolicy[2];                // offset: 0x22 ordinal: 0x8
  UCHAR PerfIncreasePolicy[2];                // offset: 0x24 ordinal: 0x9
  UCHAR PerfDecreaseThreshold[2];             // offset: 0x26 ordinal: 0xa
  UCHAR PerfIncreaseThreshold[2];             // offset: 0x28 ordinal: 0xb
  ULONG PerfFrequencyCap[2];                  // offset: 0x2c ordinal: 0xc
  ULONG PerfBoostPolicy;                      // offset: 0x34 ordinal: 0xd
  ULONG PerfBoostMode;                        // offset: 0x38 ordinal: 0xe
  ULONG PerfReductionTolerance;               // offset: 0x3c ordinal: 0xf
  ULONG EnergyPerfPreference[2];              // offset: 0x40 ordinal: 0x10
  ULONG AutonomousActivityWindow;             // offset: 0x48 ordinal: 0x11
  UCHAR AutonomousPreference;                 // offset: 0x4c ordinal: 0x12
  UCHAR LatencyHintPerf[2];                   // offset: 0x4d ordinal: 0x13
  UCHAR LatencyHintUnpark[2];                 // offset: 0x4f ordinal: 0x14
  ULONG ResponsivenessDisableThreshold[2];    // offset: 0x54 ordinal: 0x15
  ULONG ResponsivenessEnableThreshold[2];     // offset: 0x5c ordinal: 0x16
  UCHAR ResponsivenessDisableTime[2];         // offset: 0x64 ordinal: 0x17
  UCHAR ResponsivenessEnableTime[2];          // offset: 0x66 ordinal: 0x18
  ULONG ResponsivenessEppCeiling[2];          // offset: 0x68 ordinal: 0x19
  ULONG ResponsivenessPerfFloor[2];           // offset: 0x70 ordinal: 0x1a
  UCHAR DutyCycling;                          // offset: 0x78 ordinal: 0x1b
  UCHAR ParkingPerfState[2];                  // offset: 0x79 ordinal: 0x1c
  UCHAR DistributeUtility;                    // offset: 0x7b ordinal: 0x1d
  UCHAR CoreParkingOverUtilizationThreshold;  // offset: 0x7c ordinal: 0x1e
  UCHAR CoreParkingConcurrencyThreshold;      // offset: 0x7d ordinal: 0x1f
  UCHAR CoreParkingHeadroomThreshold;         // offset: 0x7e ordinal: 0x20
  UCHAR CoreParkingDistributionThreshold;     // offset: 0x7f ordinal: 0x21
  UCHAR CoreParkingDecreasePolicy;            // offset: 0x80 ordinal: 0x22
  UCHAR CoreParkingIncreasePolicy;            // offset: 0x81 ordinal: 0x23
  ULONG CoreParkingDecreaseTime;              // offset: 0x84 ordinal: 0x24
  ULONG CoreParkingIncreaseTime;              // offset: 0x88 ordinal: 0x25
  UCHAR CoreParkingMinCores[2];               // offset: 0x8c ordinal: 0x26
  UCHAR CoreParkingMaxCores[2];               // offset: 0x8e ordinal: 0x27
  ULONG SoftParkLatency;                      // offset: 0x90 ordinal: 0x28
  UCHAR AllowScaling;                         // offset: 0x94 ordinal: 0x29
  UCHAR IdleDisabled;                         // offset: 0x95 ordinal: 0x2a
  ULONG IdleTimeCheck;                        // offset: 0x98 ordinal: 0x2b
  UCHAR IdleDemotePercent;                    // offset: 0x9c ordinal: 0x2c
  UCHAR IdlePromotePercent;                   // offset: 0x9d ordinal: 0x2d
  UCHAR IdleStateMax;                         // offset: 0x9e ordinal: 0x2e
  UCHAR HeteroDecreaseTime;                   // offset: 0x9f ordinal: 0x2f
  UCHAR HeteroIncreaseTime;                   // offset: 0xa0 ordinal: 0x30
  UCHAR HeteroDecreaseThreshold[2][64];       // offset: 0xa1 ordinal: 0x31
  UCHAR HeteroIncreaseThreshold[2][64];       // offset: 0x121 ordinal: 0x32
  UCHAR Class0FloorPerformance;               // offset: 0x1a1 ordinal: 0x33
  UCHAR Class1InitialPerformance;             // offset: 0x1a2 ordinal: 0x34
  ULONG ShortThreadRuntimeThreshold;          // offset: 0x1a4 ordinal: 0x35
  enum _KHETERO_CPU_POLICY ThreadPolicies[2]; // offset: 0x1a8 ordinal: 0x36
  UCHAR ArchClassLowerThreshold[2];           // offset: 0x1b0 ordinal: 0x37
  UCHAR ArchClassUpperThreshold[2];           // offset: 0x1b2 ordinal: 0x38
  UCHAR ModuleUnparkPolicy;                   // offset: 0x1b4 ordinal: 0x39
  UCHAR ComplexUnparkPolicy;                  // offset: 0x1b5 ordinal: 0x3a
  UCHAR SmtUnparkPolicy;                      // offset: 0x1b6 ordinal: 0x3b
} _PPM_ENGINE_SETTINGS;

// 0x3c0 bytes (sizeof)
typedef struct _POP_PPM_PROFILE {
  WCHAR *Name;                             // offset: 0x0 ordinal: 0x0
  UCHAR Id;                                // offset: 0x8 ordinal: 0x1
  struct _GUID Guid;                       // offset: 0xc ordinal: 0x2
  ULONG Flags;                             // offset: 0x1c ordinal: 0x3
  UCHAR Priority;                          // offset: 0x20 ordinal: 0x4
  struct _PPM_ENGINE_SETTINGS Settings[2]; // offset: 0x28 ordinal: 0x5
  ULONGLONG StartTime;                     // offset: 0x398 ordinal: 0x6
  ULONGLONG Count;                         // offset: 0x3a0 ordinal: 0x7
  ULONGLONG MaxDuration;                   // offset: 0x3a8 ordinal: 0x8
  ULONGLONG MinDuration;                   // offset: 0x3b0 ordinal: 0x9
  ULONGLONG TotalDuration;                 // offset: 0x3b8 ordinal: 0xa
} _POP_PPM_PROFILE;

// 0x10 bytes (sizeof)
typedef struct _PROCESSOR_PLATFORM_STATE_RESIDENCY {
  ULONGLONG Residency;       // offset: 0x0 ordinal: 0x0
  ULONGLONG TransitionCount; // offset: 0x8 ordinal: 0x1
} _PROCESSOR_PLATFORM_STATE_RESIDENCY;

// 0x18 bytes (sizeof)
typedef struct _PROCESSOR_PLATFORM_STATE_RESIDENCIES {
  ULONG Count; // offset: 0x0 ordinal: 0x0
  struct _PROCESSOR_PLATFORM_STATE_RESIDENCY
      States[1]; // offset: 0x8 ordinal: 0x1
} _PROCESSOR_PLATFORM_STATE_RESIDENCIES;

typedef LONG (*__anon_2628)(VOID *,
                            struct _PROCESSOR_PLATFORM_STATE_RESIDENCIES *);

// 0x48 bytes (sizeof)
typedef struct _PEP_ACPI_EXTENDED_ADDRESS {
  enum _PEP_ACPI_RESOURCE_TYPE Type;      // offset: 0x0 ordinal: 0x0
  union _PEP_ACPI_RESOURCE_FLAGS Flags;   // offset: 0x4 ordinal: 0x1
  UCHAR ResourceFlags;                    // offset: 0x8 ordinal: 0x2
  UCHAR GeneralFlags;                     // offset: 0x9 ordinal: 0x3
  UCHAR TypeSpecificFlags;                // offset: 0xa ordinal: 0x4
  UCHAR RevisionId;                       // offset: 0xb ordinal: 0x5
  UCHAR Reserved;                         // offset: 0xc ordinal: 0x6
  ULONGLONG Granularity;                  // offset: 0x10 ordinal: 0x7
  ULONGLONG MinimumAddress;               // offset: 0x18 ordinal: 0x8
  ULONGLONG MaximumAddress;               // offset: 0x20 ordinal: 0x9
  ULONGLONG TranslationAddress;           // offset: 0x28 ordinal: 0xa
  ULONGLONG AddressLength;                // offset: 0x30 ordinal: 0xb
  ULONGLONG TypeAttribute;                // offset: 0x38 ordinal: 0xc
  struct _UNICODE_STRING *DescriptorName; // offset: 0x40 ordinal: 0xd
} _PEP_ACPI_EXTENDED_ADDRESS;

// 0x48 bytes (sizeof)
typedef union _PEP_ACPI_RESOURCE {
  enum _PEP_ACPI_RESOURCE_TYPE Type;                 // offset: 0x0 ordinal: 0x0
  struct _PEP_ACPI_IO_MEMORY_RESOURCE IoMemory;      // offset: 0x0 ordinal: 0x1
  struct _PEP_ACPI_INTERRUPT_RESOURCE Interrupt;     // offset: 0x0 ordinal: 0x2
  struct _PEP_ACPI_GPIO_RESOURCE Gpio;               // offset: 0x0 ordinal: 0x3
  struct _PEP_ACPI_SPB_I2C_RESOURCE SpbI2c;          // offset: 0x0 ordinal: 0x4
  struct _PEP_ACPI_SPB_SPI_RESOURCE SpbSpi;          // offset: 0x0 ordinal: 0x5
  struct _PEP_ACPI_SPB_UART_RESOURCE SpbUart;        // offset: 0x0 ordinal: 0x6
  struct _PEP_ACPI_EXTENDED_ADDRESS ExtendedAddress; // offset: 0x0 ordinal: 0x7
} _PEP_ACPI_RESOURCE;

// 0x10 bytes (sizeof)
typedef struct _DEVICE_DATA_SET_RANGE {
  LONGLONG StartingOffset; // offset: 0x0 ordinal: 0x0
  ULONGLONG LengthInBytes; // offset: 0x8 ordinal: 0x1
} _DEVICE_DATA_SET_RANGE;

// 0x18 bytes (sizeof)
typedef struct _ARM64_DBGKD_CONTROL_SET {
  ULONG Continue;               // offset: 0x0 ordinal: 0x0
  ULONG TraceFlag;              // offset: 0x4 ordinal: 0x1
  ULONGLONG CurrentSymbolStart; // offset: 0x8 ordinal: 0x2
  ULONGLONG CurrentSymbolEnd;   // offset: 0x10 ordinal: 0x3
} _ARM64_DBGKD_CONTROL_SET;

// 0x14 bytes (sizeof)
typedef struct _IA64_DBGKD_CONTROL_SET {
  ULONG Continue;               // offset: 0x0 ordinal: 0x0
  ULONGLONG CurrentSymbolStart; // offset: 0x4 ordinal: 0x1
  ULONGLONG CurrentSymbolEnd;   // offset: 0xc ordinal: 0x2
} _IA64_DBGKD_CONTROL_SET;

// 0x1c bytes (sizeof)
typedef struct _AMD64_DBGKD_CONTROL_SET {
  ULONG TraceFlag;              // offset: 0x0 ordinal: 0x0
  ULONGLONG Dr7;                // offset: 0x4 ordinal: 0x1
  ULONGLONG CurrentSymbolStart; // offset: 0xc ordinal: 0x2
  ULONGLONG CurrentSymbolEnd;   // offset: 0x14 ordinal: 0x3
} _AMD64_DBGKD_CONTROL_SET;

// 0x1c bytes (sizeof)
typedef struct _DBGKD_ANY_CONTROL_SET {
  union {
    struct _X86_DBGKD_CONTROL_SET X86ControlSet;     // offset: 0x0 ordinal: 0x0
    ULONG AlphaControlSet;                           // offset: 0x0 ordinal: 0x1
    struct _IA64_DBGKD_CONTROL_SET IA64ControlSet;   // offset: 0x0 ordinal: 0x2
    struct _AMD64_DBGKD_CONTROL_SET Amd64ControlSet; // offset: 0x0 ordinal: 0x3
    struct _ARM_DBGKD_CONTROL_SET ArmControlSet;     // offset: 0x0 ordinal: 0x4
    struct _ARM64_DBGKD_CONTROL_SET Arm64ControlSet; // offset: 0x0 ordinal: 0x5
    struct _ARMCE_DBGKD_CONTROL_SET ArmCeControlSet; // offset: 0x0 ordinal: 0x6
    struct _PPC_DBGKD_CONTROL_SET PpcControlSet;     // offset: 0x0 ordinal: 0x7
  };
} _DBGKD_ANY_CONTROL_SET;

// 0x20 bytes (sizeof)
typedef struct _DBGKD_CONTINUE2 {
  LONG ContinueStatus; // offset: 0x0 ordinal: 0x0
  union {
    struct _AMD64_DBGKD_CONTROL_SET ControlSet;  // offset: 0x4 ordinal: 0x1
    struct _DBGKD_ANY_CONTROL_SET AnyControlSet; // offset: 0x4 ordinal: 0x2
  };
} _DBGKD_CONTINUE2;

// 0x18 bytes (sizeof)
typedef struct _DBGKD_WRITE_CUSTOM_BREAKPOINT {
  ULONGLONG BreakPointAddress;          // offset: 0x0 ordinal: 0x0
  ULONGLONG BreakPointInstruction;      // offset: 0x8 ordinal: 0x1
  ULONG BreakPointHandle;               // offset: 0x10 ordinal: 0x2
  UCHAR BreakPointInstructionSize;      // offset: 0x14 ordinal: 0x3
  UCHAR BreakPointInstructionAlignment; // offset: 0x15 ordinal: 0x4
} _DBGKD_WRITE_CUSTOM_BREAKPOINT;

// 0x18 bytes (sizeof)
typedef struct _DBGKD_QUERY_MEMORY {
  ULONGLONG Address;  // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved; // offset: 0x8 ordinal: 0x1
  ULONG AddressSpace; // offset: 0x10 ordinal: 0x2
  ULONG Flags;        // offset: 0x14 ordinal: 0x3
} _DBGKD_QUERY_MEMORY;

// 0x10 bytes (sizeof)
typedef struct _DBGKD_FILL_MEMORY {
  ULONGLONG Address;    // offset: 0x0 ordinal: 0x0
  ULONG Length;         // offset: 0x8 ordinal: 0x1
  USHORT Flags;         // offset: 0xc ordinal: 0x2
  USHORT PatternLength; // offset: 0xe ordinal: 0x3
} _DBGKD_FILL_MEMORY;

// 0x18 bytes (sizeof)
typedef struct _DBGKD_SEARCH_MEMORY {
  union {
    ULONGLONG SearchAddress; // offset: 0x0 ordinal: 0x0
    ULONGLONG FoundAddress;  // offset: 0x0 ordinal: 0x1
  };
  ULONGLONG SearchLength; // offset: 0x8 ordinal: 0x2
  ULONG PatternLength;    // offset: 0x10 ordinal: 0x3
} _DBGKD_SEARCH_MEMORY;

// 0x28 bytes (sizeof)
typedef struct _DBGKD_GET_VERSION64 {
  USHORT MajorVersion;          // offset: 0x0 ordinal: 0x0
  USHORT MinorVersion;          // offset: 0x2 ordinal: 0x1
  UCHAR ProtocolVersion;        // offset: 0x4 ordinal: 0x2
  UCHAR KdSecondaryVersion;     // offset: 0x5 ordinal: 0x3
  USHORT Flags;                 // offset: 0x6 ordinal: 0x4
  USHORT MachineType;           // offset: 0x8 ordinal: 0x5
  UCHAR MaxPacketType;          // offset: 0xa ordinal: 0x6
  UCHAR MaxStateChange;         // offset: 0xb ordinal: 0x7
  UCHAR MaxManipulate;          // offset: 0xc ordinal: 0x8
  UCHAR Simulation;             // offset: 0xd ordinal: 0x9
  USHORT Unused[1];             // offset: 0xe ordinal: 0xa
  ULONGLONG KernBase;           // offset: 0x10 ordinal: 0xb
  ULONGLONG PsLoadedModuleList; // offset: 0x18 ordinal: 0xc
  ULONGLONG DebuggerDataList;   // offset: 0x20 ordinal: 0xd
} _DBGKD_GET_VERSION64;

// 0x20 bytes (sizeof)
typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT64 {
  ULONGLONG BreakpointAddress; // offset: 0x0 ordinal: 0x0
  ULONG Flags;                 // offset: 0x8 ordinal: 0x1
  ULONG Calls;                 // offset: 0xc ordinal: 0x2
  ULONG MaxCallsPerPeriod;     // offset: 0x10 ordinal: 0x3
  ULONG MinInstructions;       // offset: 0x14 ordinal: 0x4
  ULONG MaxInstructions;       // offset: 0x18 ordinal: 0x5
  ULONG TotalInstructions;     // offset: 0x1c ordinal: 0x6
} _DBGKD_GET_INTERNAL_BREAKPOINT64;

// 0x10 bytes (sizeof)
typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT64 {
  ULONGLONG BreakpointAddress; // offset: 0x0 ordinal: 0x0
  ULONG Flags;                 // offset: 0x8 ordinal: 0x1
} _DBGKD_SET_INTERNAL_BREAKPOINT64;

// 0x8 bytes (sizeof)
typedef struct _DBGKD_SET_SPECIAL_CALL64 {
  ULONGLONG SpecialCall; // offset: 0x0 ordinal: 0x0
} _DBGKD_SET_SPECIAL_CALL64;

// 0x20 bytes (sizeof)
typedef struct _DBGKD_READ_WRITE_IO_EXTENDED64 {
  ULONG DataSize;      // offset: 0x0 ordinal: 0x0
  ULONG InterfaceType; // offset: 0x4 ordinal: 0x1
  ULONG BusNumber;     // offset: 0x8 ordinal: 0x2
  ULONG AddressSpace;  // offset: 0xc ordinal: 0x3
  ULONGLONG IoAddress; // offset: 0x10 ordinal: 0x4
  ULONG DataValue;     // offset: 0x18 ordinal: 0x5
} _DBGKD_READ_WRITE_IO_EXTENDED64;

// 0x10 bytes (sizeof)
typedef struct _DBGKD_READ_WRITE_IO64 {
  ULONGLONG IoAddress; // offset: 0x0 ordinal: 0x0
  ULONG DataSize;      // offset: 0x8 ordinal: 0x1
  ULONG DataValue;     // offset: 0xc ordinal: 0x2
} _DBGKD_READ_WRITE_IO64;

// 0x10 bytes (sizeof)
typedef struct _DBGKD_WRITE_BREAKPOINT64 {
  ULONGLONG BreakPointAddress; // offset: 0x0 ordinal: 0x0
  ULONG BreakPointHandle;      // offset: 0x8 ordinal: 0x1
} _DBGKD_WRITE_BREAKPOINT64;

// 0x10 bytes (sizeof)
typedef struct _DBGKD_WRITE_MEMORY64 {
  ULONGLONG TargetBaseAddress; // offset: 0x0 ordinal: 0x0
  ULONG TransferCount;         // offset: 0x8 ordinal: 0x1
  ULONG ActualBytesWritten;    // offset: 0xc ordinal: 0x2
} _DBGKD_WRITE_MEMORY64;

// 0x10 bytes (sizeof)
typedef struct _DBGKD_READ_MEMORY64 {
  ULONGLONG TargetBaseAddress; // offset: 0x0 ordinal: 0x0
  ULONG TransferCount;         // offset: 0x8 ordinal: 0x1
  ULONG ActualBytesRead;       // offset: 0xc ordinal: 0x2
} _DBGKD_READ_MEMORY64;

// 0x28 bytes (sizeof)
typedef union __anon_2604 {
  struct _DBGKD_READ_MEMORY32 ReadMemory;           // offset: 0x0 ordinal: 0x0
  struct _DBGKD_WRITE_MEMORY32 WriteMemory;         // offset: 0x0 ordinal: 0x1
  struct _DBGKD_READ_MEMORY64 ReadMemory64;         // offset: 0x0 ordinal: 0x2
  struct _DBGKD_WRITE_MEMORY64 WriteMemory64;       // offset: 0x0 ordinal: 0x3
  struct _DBGKD_GET_CONTEXT GetContext;             // offset: 0x0 ordinal: 0x4
  struct _DBGKD_SET_CONTEXT SetContext;             // offset: 0x0 ordinal: 0x5
  struct _DBGKD_WRITE_BREAKPOINT32 WriteBreakPoint; // offset: 0x0 ordinal: 0x6
  struct _DBGKD_RESTORE_BREAKPOINT
      RestoreBreakPoint;                     // offset: 0x0 ordinal: 0x7
  struct _DBGKD_CONTINUE Continue;           // offset: 0x0 ordinal: 0x8
  struct _DBGKD_CONTINUE2 Continue2;         // offset: 0x0 ordinal: 0x9
  struct _DBGKD_READ_WRITE_IO32 ReadWriteIo; // offset: 0x0 ordinal: 0xa
  struct _DBGKD_READ_WRITE_IO_EXTENDED32
      ReadWriteIoExtended; // offset: 0x0 ordinal: 0xb
  struct _DBGKD_QUERY_SPECIAL_CALLS
      QuerySpecialCalls;                           // offset: 0x0 ordinal: 0xc
  struct _DBGKD_SET_SPECIAL_CALL32 SetSpecialCall; // offset: 0x0 ordinal: 0xd
  struct _DBGKD_SET_INTERNAL_BREAKPOINT32
      SetInternalBreakpoint; // offset: 0x0 ordinal: 0xe
  struct _DBGKD_GET_INTERNAL_BREAKPOINT32
      GetInternalBreakpoint;                 // offset: 0x0 ordinal: 0xf
  struct _DBGKD_GET_VERSION32 GetVersion32;  // offset: 0x0 ordinal: 0x10
  struct _DBGKD_BREAKPOINTEX BreakPointEx;   // offset: 0x0 ordinal: 0x11
  struct _DBGKD_READ_WRITE_MSR ReadWriteMsr; // offset: 0x0 ordinal: 0x12
  struct _DBGKD_SEARCH_MEMORY SearchMemory;  // offset: 0x0 ordinal: 0x13
  struct _DBGKD_CONTEXT_EX GetContextEx;     // offset: 0x0 ordinal: 0x14
  struct _DBGKD_CONTEXT_EX SetContextEx;     // offset: 0x0 ordinal: 0x15
} __anon_2604;

// 0x34 bytes (sizeof)
typedef struct _DBGKD_MANIPULATE_STATE32 {
  ULONG ApiNumber;       // offset: 0x0 ordinal: 0x0
  USHORT ProcessorLevel; // offset: 0x4 ordinal: 0x1
  USHORT Processor;      // offset: 0x6 ordinal: 0x2
  LONG ReturnStatus;     // offset: 0x8 ordinal: 0x3
  union __anon_2604 u;   // offset: 0xc ordinal: 0x4
} _DBGKD_MANIPULATE_STATE32;

// 0x28 bytes (sizeof)
typedef union __anon_2577 {
  struct _DBGKD_READ_MEMORY64 ReadMemory;           // offset: 0x0 ordinal: 0x0
  struct _DBGKD_WRITE_MEMORY64 WriteMemory;         // offset: 0x0 ordinal: 0x1
  struct _DBGKD_GET_CONTEXT GetContext;             // offset: 0x0 ordinal: 0x2
  struct _DBGKD_SET_CONTEXT SetContext;             // offset: 0x0 ordinal: 0x3
  struct _DBGKD_WRITE_BREAKPOINT64 WriteBreakPoint; // offset: 0x0 ordinal: 0x4
  struct _DBGKD_RESTORE_BREAKPOINT
      RestoreBreakPoint;                     // offset: 0x0 ordinal: 0x5
  struct _DBGKD_CONTINUE Continue;           // offset: 0x0 ordinal: 0x6
  struct _DBGKD_CONTINUE2 Continue2;         // offset: 0x0 ordinal: 0x7
  struct _DBGKD_READ_WRITE_IO64 ReadWriteIo; // offset: 0x0 ordinal: 0x8
  struct _DBGKD_READ_WRITE_IO_EXTENDED64
      ReadWriteIoExtended; // offset: 0x0 ordinal: 0x9
  struct _DBGKD_QUERY_SPECIAL_CALLS
      QuerySpecialCalls;                           // offset: 0x0 ordinal: 0xa
  struct _DBGKD_SET_SPECIAL_CALL64 SetSpecialCall; // offset: 0x0 ordinal: 0xb
  struct _DBGKD_SET_INTERNAL_BREAKPOINT64
      SetInternalBreakpoint; // offset: 0x0 ordinal: 0xc
  struct _DBGKD_GET_INTERNAL_BREAKPOINT64
      GetInternalBreakpoint;                      // offset: 0x0 ordinal: 0xd
  struct _DBGKD_GET_VERSION64 GetVersion64;       // offset: 0x0 ordinal: 0xe
  struct _DBGKD_BREAKPOINTEX BreakPointEx;        // offset: 0x0 ordinal: 0xf
  struct _DBGKD_READ_WRITE_MSR ReadWriteMsr;      // offset: 0x0 ordinal: 0x10
  struct _DBGKD_SEARCH_MEMORY SearchMemory;       // offset: 0x0 ordinal: 0x11
  struct _DBGKD_GET_SET_BUS_DATA GetSetBusData;   // offset: 0x0 ordinal: 0x12
  struct _DBGKD_FILL_MEMORY FillMemory;           // offset: 0x0 ordinal: 0x13
  struct _DBGKD_QUERY_MEMORY QueryMemory;         // offset: 0x0 ordinal: 0x14
  struct _DBGKD_SWITCH_PARTITION SwitchPartition; // offset: 0x0 ordinal: 0x15
  struct _DBGKD_CONTEXT_EX GetContextEx;          // offset: 0x0 ordinal: 0x16
  struct _DBGKD_CONTEXT_EX SetContextEx;          // offset: 0x0 ordinal: 0x17
  struct _DBGKD_WRITE_CUSTOM_BREAKPOINT
      WriteCustomBreakPoint; // offset: 0x0 ordinal: 0x18
} __anon_2577;

// 0x38 bytes (sizeof)
typedef struct _DBGKD_MANIPULATE_STATE64 {
  ULONG ApiNumber;       // offset: 0x0 ordinal: 0x0
  USHORT ProcessorLevel; // offset: 0x4 ordinal: 0x1
  USHORT Processor;      // offset: 0x6 ordinal: 0x2
  LONG ReturnStatus;     // offset: 0x8 ordinal: 0x3
  union __anon_2577 u;   // offset: 0x10 ordinal: 0x4
} _DBGKD_MANIPULATE_STATE64;

// 0x28 bytes (sizeof)
typedef struct _DBGKD_LOAD_SYMBOLS64 {
  ULONG PathNameLength; // offset: 0x0 ordinal: 0x0
  ULONGLONG BaseOfDll;  // offset: 0x8 ordinal: 0x1
  ULONGLONG ProcessId;  // offset: 0x10 ordinal: 0x2
  ULONG CheckSum;       // offset: 0x18 ordinal: 0x3
  ULONG SizeOfImage;    // offset: 0x1c ordinal: 0x4
  UCHAR UnloadSymbols;  // offset: 0x20 ordinal: 0x5
} _DBGKD_LOAD_SYMBOLS64;

// 0x50 bytes (sizeof)
typedef struct _PNP_DEVICE_COMPLETION_QUEUE {
  struct _LIST_ENTRY DispatchedList;     // offset: 0x0 ordinal: 0x0
  ULONG DispatchedCount;                 // offset: 0x10 ordinal: 0x1
  struct _LIST_ENTRY CompletedList;      // offset: 0x18 ordinal: 0x2
  struct _KSEMAPHORE CompletedSemaphore; // offset: 0x28 ordinal: 0x3
  ULONGLONG SpinLock;                    // offset: 0x48 ordinal: 0x4
} _PNP_DEVICE_COMPLETION_QUEUE;

// 0x18 bytes (sizeof)
typedef struct _MEMORY_CACHING_REQUIREMENTS {
  ULONGLONG BasePage;                          // offset: 0x0 ordinal: 0x0
  ULONGLONG PageCount;                         // offset: 0x8 ordinal: 0x1
  enum _MEMORY_CACHING_TYPE MemoryCachingType; // offset: 0x10 ordinal: 0x2
} _MEMORY_CACHING_REQUIREMENTS;

// 0x70 bytes (sizeof)
typedef struct _VIRTUAL_EFI_RUNTIME_SERVICES {
  ULONGLONG GetTime;                   // offset: 0x0 ordinal: 0x0
  ULONGLONG SetTime;                   // offset: 0x8 ordinal: 0x1
  ULONGLONG GetWakeupTime;             // offset: 0x10 ordinal: 0x2
  ULONGLONG SetWakeupTime;             // offset: 0x18 ordinal: 0x3
  ULONGLONG SetVirtualAddressMap;      // offset: 0x20 ordinal: 0x4
  ULONGLONG ConvertPointer;            // offset: 0x28 ordinal: 0x5
  ULONGLONG GetVariable;               // offset: 0x30 ordinal: 0x6
  ULONGLONG GetNextVariableName;       // offset: 0x38 ordinal: 0x7
  ULONGLONG SetVariable;               // offset: 0x40 ordinal: 0x8
  ULONGLONG GetNextHighMonotonicCount; // offset: 0x48 ordinal: 0x9
  ULONGLONG ResetSystem;               // offset: 0x50 ordinal: 0xa
  ULONGLONG UpdateCapsule;             // offset: 0x58 ordinal: 0xb
  ULONGLONG QueryCapsuleCapabilities;  // offset: 0x60 ordinal: 0xc
  ULONGLONG QueryVariableInfo;         // offset: 0x68 ordinal: 0xd
} _VIRTUAL_EFI_RUNTIME_SERVICES;

// 0x38 bytes (sizeof)
typedef struct _EFI_FIRMWARE_INFORMATION {
  ULONG FirmwareVersion; // offset: 0x0 ordinal: 0x0
  struct _VIRTUAL_EFI_RUNTIME_SERVICES
      *VirtualEfiRuntimeServices;          // offset: 0x8 ordinal: 0x1
  LONG SetVirtualAddressMapStatus;         // offset: 0x10 ordinal: 0x2
  ULONG MissedMappingsCount;               // offset: 0x14 ordinal: 0x3
  struct _LIST_ENTRY FirmwareResourceList; // offset: 0x18 ordinal: 0x4
  VOID *EfiMemoryMap;                      // offset: 0x28 ordinal: 0x5
  ULONG EfiMemoryMapSize;                  // offset: 0x30 ordinal: 0x6
  ULONG EfiMemoryMapDescriptorSize;        // offset: 0x34 ordinal: 0x7
} _EFI_FIRMWARE_INFORMATION;

// 0x38 bytes (sizeof)
typedef union __anon_3427 {
  struct _EFI_FIRMWARE_INFORMATION EfiInformation;   // offset: 0x0 ordinal: 0x0
  struct _PCAT_FIRMWARE_INFORMATION PcatInformation; // offset: 0x0 ordinal: 0x1
} __anon_3427;

// 0x40 bytes (sizeof)
typedef struct _FIRMWARE_INFORMATION_LOADER_BLOCK {
  ULONG FirmwareTypeUefi : 1;                  // offset: 0x0 ordinal: 0x0
  ULONG EfiRuntimeUseIum : 1;                  // offset: 0x0 ordinal: 0x1
  ULONG EfiRuntimePageProtectionSupported : 1; // offset: 0x0 ordinal: 0x2
  ULONG Reserved : 29;                         // offset: 0x0 ordinal: 0x3
  union __anon_3427 u;                         // offset: 0x8 ordinal: 0x4
} _FIRMWARE_INFORMATION_LOADER_BLOCK;

// 0x148 bytes (sizeof)
typedef struct _KSR_FIRMWARE_INFORMATION {
  ULONG Version;                           // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING EfiVersionString; // offset: 0x8 ordinal: 0x1
  struct _VIRTUAL_EFI_RUNTIME_SERVICES
      EfiRuntimeServices;           // offset: 0x18 ordinal: 0x2
  VOID *EfiMemoryMap;               // offset: 0x88 ordinal: 0x3
  ULONG EfiMemoryMapSize;           // offset: 0x90 ordinal: 0x4
  ULONG EfiMemoryMapDescriptorSize; // offset: 0x94 ordinal: 0x5
  struct _MEMORY_CACHING_REQUIREMENTS
      *CachingRequirements;                     // offset: 0x98 ordinal: 0x6
  ULONG CachingRequirementsCount;               // offset: 0xa0 ordinal: 0x7
  VOID *Smbios;                                 // offset: 0xa8 ordinal: 0x8
  struct _INBV_DISPLAY_CONTEXT *DisplayContext; // offset: 0xb0 ordinal: 0x9
  VOID *SecureBootPolicy;                       // offset: 0xb8 ordinal: 0xa
  ULONG SecureBootPolicySize;                   // offset: 0xc0 ordinal: 0xb
  struct DEBUG_MEMORY_REQUIREMENTS
      DebugDeviceMemory;                        // offset: 0xc8 ordinal: 0xc
  ULONG SoftRestartCount;                       // offset: 0xe8 ordinal: 0xd
  VOID *CodeIntegrityPolicy;                    // offset: 0xf0 ordinal: 0xe
  ULONG CodeIntegrityPolicySize;                // offset: 0xf8 ordinal: 0xf
  VOID *EfiMemoryAttributes;                    // offset: 0x100 ordinal: 0x10
  VOID *Esrt;                                   // offset: 0x108 ordinal: 0x11
  ULONG EsrtSize;                               // offset: 0x110 ordinal: 0x12
  VOID *CodeIntegrityPolicyHash;                // offset: 0x118 ordinal: 0x13
  ULONG CodeIntegrityPolicyHashSize;            // offset: 0x120 ordinal: 0x14
  VOID *CodeIntegrityPolicyOriginalHash;        // offset: 0x128 ordinal: 0x15
  ULONG CodeIntegrityPolicyOriginalHashSize;    // offset: 0x130 ordinal: 0x16
  struct _PHYSICAL_MEMORY_RANGE *BadPageRanges; // offset: 0x138 ordinal: 0x17
  ULONG BadPageRangeCount;                      // offset: 0x140 ordinal: 0x18
  union _KSR_CAPABILITIES Capabilities;         // offset: 0x144 ordinal: 0x19
} _KSR_FIRMWARE_INFORMATION;

// 0x48 bytes (sizeof)
typedef struct _MCGEN_TRACE_CONTEXT {
  ULONGLONG RegistrationHandle; // offset: 0x0 ordinal: 0x0
  ULONGLONG Logger;             // offset: 0x8 ordinal: 0x1
  ULONGLONG MatchAnyKeyword;    // offset: 0x10 ordinal: 0x2
  ULONGLONG MatchAllKeyword;    // offset: 0x18 ordinal: 0x3
  ULONG Flags;                  // offset: 0x20 ordinal: 0x4
  ULONG IsEnabled;              // offset: 0x24 ordinal: 0x5
  UCHAR Level;                  // offset: 0x28 ordinal: 0x6
  UCHAR Reserve;                // offset: 0x29 ordinal: 0x7
  USHORT EnableBitsCount;       // offset: 0x2a ordinal: 0x8
  ULONG *EnableBitMask;         // offset: 0x30 ordinal: 0x9
  ULONGLONG *EnableKeyWords;    // offset: 0x38 ordinal: 0xa
  UCHAR *EnableLevel;           // offset: 0x40 ordinal: 0xb
} _MCGEN_TRACE_CONTEXT;

// 0x8 bytes (sizeof)
typedef union _HV_PARTITION_PRIVILEGE_MASK {
  ULONGLONG AsUINT64;                            // offset: 0x0 ordinal: 0x0
  ULONGLONG AccessVpRunTimeReg : 1;              // offset: 0x0 ordinal: 0x1
  ULONGLONG AccessPartitionReferenceCounter : 1; // offset: 0x0 ordinal: 0x2
  ULONGLONG AccessSynicRegs : 1;                 // offset: 0x0 ordinal: 0x3
  ULONGLONG AccessSyntheticTimerRegs : 1;        // offset: 0x0 ordinal: 0x4
  ULONGLONG AccessIntrCtrlRegs : 1;              // offset: 0x0 ordinal: 0x5
  ULONGLONG AccessHypercallMsrs : 1;             // offset: 0x0 ordinal: 0x6
  ULONGLONG AccessVpIndex : 1;                   // offset: 0x0 ordinal: 0x7
  ULONGLONG AccessResetReg : 1;                  // offset: 0x0 ordinal: 0x8
  ULONGLONG AccessStatsReg : 1;                  // offset: 0x0 ordinal: 0x9
  ULONGLONG AccessPartitionReferenceTsc : 1;     // offset: 0x0 ordinal: 0xa
  ULONGLONG AccessGuestIdleReg : 1;              // offset: 0x0 ordinal: 0xb
  ULONGLONG AccessFrequencyRegs : 1;             // offset: 0x0 ordinal: 0xc
  ULONGLONG AccessDebugRegs : 1;                 // offset: 0x0 ordinal: 0xd
  ULONGLONG AccessReenlightenmentControls : 1;   // offset: 0x0 ordinal: 0xe
  ULONGLONG AccessRootSchedulerReg : 1;          // offset: 0x0 ordinal: 0xf
  ULONGLONG AccessTscInvariantControls : 1;      // offset: 0x0 ordinal: 0x10
  ULONGLONG Reserved1 : 16;                      // offset: 0x0 ordinal: 0x11
  ULONGLONG CreatePartitions : 1;                // offset: 0x0 ordinal: 0x12
  ULONGLONG AccessPartitionId : 1;               // offset: 0x0 ordinal: 0x13
  ULONGLONG AccessMemoryPool : 1;                // offset: 0x0 ordinal: 0x14
  ULONGLONG AdjustMessageBuffers : 1;            // offset: 0x0 ordinal: 0x15
  ULONGLONG PostMessages : 1;                    // offset: 0x0 ordinal: 0x16
  ULONGLONG SignalEvents : 1;                    // offset: 0x0 ordinal: 0x17
  ULONGLONG CreatePort : 1;                      // offset: 0x0 ordinal: 0x18
  ULONGLONG ConnectPort : 1;                     // offset: 0x0 ordinal: 0x19
  ULONGLONG AccessStats : 1;                     // offset: 0x0 ordinal: 0x1a
  ULONGLONG Reserved2 : 2;                       // offset: 0x0 ordinal: 0x1b
  ULONGLONG Debugging : 1;                       // offset: 0x0 ordinal: 0x1c
  ULONGLONG CpuManagement : 1;                   // offset: 0x0 ordinal: 0x1d
  ULONGLONG ConfigureProfiler : 1;               // offset: 0x0 ordinal: 0x1e
  ULONGLONG AccessVpExitTracing : 1;             // offset: 0x0 ordinal: 0x1f
  ULONGLONG
  EnableExtendedGvaRangesForFlushVirtualAddressList : 1; // offset: 0x0
                                                         // ordinal: 0x20
  ULONGLONG AccessVsm : 1;                // offset: 0x0 ordinal: 0x21
  ULONGLONG AccessVpRegisters : 1;        // offset: 0x0 ordinal: 0x22
  ULONGLONG UnusedBit : 1;                // offset: 0x0 ordinal: 0x23
  ULONGLONG FastHypercallOutput : 1;      // offset: 0x0 ordinal: 0x24
  ULONGLONG EnableExtendedHypercalls : 1; // offset: 0x0 ordinal: 0x25
  ULONGLONG StartVirtualProcessor : 1;    // offset: 0x0 ordinal: 0x26
  ULONGLONG Isolation : 1;                // offset: 0x0 ordinal: 0x27
  ULONGLONG Reserved3 : 9;                // offset: 0x0 ordinal: 0x28
} _HV_PARTITION_PRIVILEGE_MASK;

// 0x10 bytes (sizeof)
typedef struct _HV_X64_HYPERVISOR_FEATURES {
  union _HV_PARTITION_PRIVILEGE_MASK
      PartitionPrivileges;                         // offset: 0x0 ordinal: 0x0
  ULONG MaxSupportedCState : 4;                    // offset: 0x8 ordinal: 0x1
  ULONG HpetNeededForC3PowerState_Deprecated : 1;  // offset: 0x8 ordinal: 0x2
  ULONG InvariantMperfAvailable : 1;               // offset: 0x8 ordinal: 0x3
  ULONG SupervisorShadowStackAvailable : 1;        // offset: 0x8 ordinal: 0x4
  ULONG ArchPmuAvailable : 1;                      // offset: 0x8 ordinal: 0x5
  ULONG ExceptionTrapInterceptAvailable : 1;       // offset: 0x8 ordinal: 0x6
  ULONG Reserved : 23;                             // offset: 0x8 ordinal: 0x7
  ULONG MwaitAvailable_Deprecated : 1;             // offset: 0xc ordinal: 0x8
  ULONG GuestDebuggingAvailable : 1;               // offset: 0xc ordinal: 0x9
  ULONG PerformanceMonitorsAvailable : 1;          // offset: 0xc ordinal: 0xa
  ULONG CpuDynamicPartitioningAvailable : 1;       // offset: 0xc ordinal: 0xb
  ULONG XmmRegistersForFastHypercallAvailable : 1; // offset: 0xc ordinal: 0xc
  ULONG GuestIdleAvailable : 1;                    // offset: 0xc ordinal: 0xd
  ULONG HypervisorSleepStateSupportAvailable : 1;  // offset: 0xc ordinal: 0xe
  ULONG NumaDistanceQueryAvailable : 1;            // offset: 0xc ordinal: 0xf
  ULONG FrequencyRegsAvailable : 1;                // offset: 0xc ordinal: 0x10
  ULONG SyntheticMachineCheckAvailable : 1;        // offset: 0xc ordinal: 0x11
  ULONG GuestCrashRegsAvailable : 1;               // offset: 0xc ordinal: 0x12
  ULONG DebugRegsAvailable : 1;                    // offset: 0xc ordinal: 0x13
  ULONG Npiep1Available : 1;                       // offset: 0xc ordinal: 0x14
  ULONG DisableHypervisorAvailable : 1;            // offset: 0xc ordinal: 0x15
  ULONG
  ExtendedGvaRangesForFlushVirtualAddressListAvailable : 1; // offset: 0xc
                                                            // ordinal: 0x16
  ULONG FastHypercallOutputAvailable : 1;        // offset: 0xc ordinal: 0x17
  ULONG SvmFeaturesAvailable : 1;                // offset: 0xc ordinal: 0x18
  ULONG SintPollingModeAvailable : 1;            // offset: 0xc ordinal: 0x19
  ULONG HypercallMsrLockAvailable : 1;           // offset: 0xc ordinal: 0x1a
  ULONG DirectSyntheticTimers : 1;               // offset: 0xc ordinal: 0x1b
  ULONG RegisterPatAvailable : 1;                // offset: 0xc ordinal: 0x1c
  ULONG RegisterBndcfgsAvailable : 1;            // offset: 0xc ordinal: 0x1d
  ULONG WatchdogTimerAvailable : 1;              // offset: 0xc ordinal: 0x1e
  ULONG SyntheticTimeUnhaltedTimerAvailable : 1; // offset: 0xc ordinal: 0x1f
  ULONG DeviceDomainsAvailable : 1;              // offset: 0xc ordinal: 0x20
  ULONG S1DeviceDomainsAvailable : 1;            // offset: 0xc ordinal: 0x21
  ULONG LbrAvailable : 1;                        // offset: 0xc ordinal: 0x22
  ULONG IptAvailable : 1;                        // offset: 0xc ordinal: 0x23
  ULONG CrossVtlFlushAvailable : 1;              // offset: 0xc ordinal: 0x24
  ULONG IdleSpecCtrlAvailable : 1;               // offset: 0xc ordinal: 0x25
  ULONG TranslateGvaFlagsAvailable : 1;          // offset: 0xc ordinal: 0x26
  ULONG ApicEoiInterceptAvailable : 1;           // offset: 0xc ordinal: 0x27
} _HV_X64_HYPERVISOR_FEATURES;

// 0x10 bytes (sizeof)
typedef struct _STRING64 {
  USHORT Length;        // offset: 0x0 ordinal: 0x0
  USHORT MaximumLength; // offset: 0x2 ordinal: 0x1
  ULONGLONG Buffer;     // offset: 0x8 ordinal: 0x2
} _STRING64;

// 0x4e8 bytes (sizeof)
typedef struct _GDI_TEB_BATCH64 {
  ULONG Offset : 31;             // offset: 0x0 ordinal: 0x0
  ULONG HasRenderingCommand : 1; // offset: 0x0 ordinal: 0x1
  ULONGLONG HDC;                 // offset: 0x8 ordinal: 0x2
  ULONG Buffer[310];             // offset: 0x10 ordinal: 0x3
} _GDI_TEB_BATCH64;

// 0x120 bytes (sizeof)
typedef struct _SEP_TOKEN_DIAG_TRACK_ENTRY {
  VOID *ProcessCid;          // offset: 0x0 ordinal: 0x0
  VOID *ThreadCid;           // offset: 0x8 ordinal: 0x1
  UCHAR ImageFileName[16];   // offset: 0x10 ordinal: 0x2
  ULONG CreateMethod;        // offset: 0x20 ordinal: 0x3
  ULONGLONG CreateTrace[30]; // offset: 0x28 ordinal: 0x4
  LONG Count;                // offset: 0x118 ordinal: 0x5
  LONG CaptureCount;         // offset: 0x11c ordinal: 0x6
} _SEP_TOKEN_DIAG_TRACK_ENTRY;

// 0x10 bytes (sizeof)
typedef struct _CLIENT_ID64 {
  ULONGLONG UniqueProcess; // offset: 0x0 ordinal: 0x0
  ULONGLONG UniqueThread;  // offset: 0x8 ordinal: 0x1
} _CLIENT_ID64;

// 0x38 bytes (sizeof)
typedef struct _NT_TIB64 {
  ULONGLONG ExceptionList; // offset: 0x0 ordinal: 0x0
  ULONGLONG StackBase;     // offset: 0x8 ordinal: 0x1
  ULONGLONG StackLimit;    // offset: 0x10 ordinal: 0x2
  ULONGLONG SubSystemTib;  // offset: 0x18 ordinal: 0x3
  union {
    ULONGLONG FiberData; // offset: 0x20 ordinal: 0x4
    ULONG Version;       // offset: 0x20 ordinal: 0x5
  };
  ULONGLONG ArbitraryUserPointer; // offset: 0x28 ordinal: 0x6
  ULONGLONG Self;                 // offset: 0x30 ordinal: 0x7
} _NT_TIB64;

// 0x1018 bytes (sizeof)
typedef struct _TEB32 {
  struct _NT_TIB32 NtTib;                       // offset: 0x0 ordinal: 0x0
  ULONG EnvironmentPointer;                     // offset: 0x1c ordinal: 0x1
  struct _CLIENT_ID32 ClientId;                 // offset: 0x20 ordinal: 0x2
  ULONG ActiveRpcHandle;                        // offset: 0x28 ordinal: 0x3
  ULONG ThreadLocalStoragePointer;              // offset: 0x2c ordinal: 0x4
  ULONG ProcessEnvironmentBlock;                // offset: 0x30 ordinal: 0x5
  ULONG LastErrorValue;                         // offset: 0x34 ordinal: 0x6
  ULONG CountOfOwnedCriticalSections;           // offset: 0x38 ordinal: 0x7
  ULONG CsrClientThread;                        // offset: 0x3c ordinal: 0x8
  ULONG Win32ThreadInfo;                        // offset: 0x40 ordinal: 0x9
  ULONG User32Reserved[26];                     // offset: 0x44 ordinal: 0xa
  ULONG UserReserved[5];                        // offset: 0xac ordinal: 0xb
  ULONG WOW32Reserved;                          // offset: 0xc0 ordinal: 0xc
  ULONG CurrentLocale;                          // offset: 0xc4 ordinal: 0xd
  ULONG FpSoftwareStatusRegister;               // offset: 0xc8 ordinal: 0xe
  ULONG ReservedForDebuggerInstrumentation[16]; // offset: 0xcc ordinal: 0xf
  ULONG SystemReserved1[26];                    // offset: 0x10c ordinal: 0x10
  CHAR PlaceholderCompatibilityMode;            // offset: 0x174 ordinal: 0x11
  UCHAR PlaceholderHydrationAlwaysExplicit;     // offset: 0x175 ordinal: 0x12
  CHAR PlaceholderReserved[10];                 // offset: 0x176 ordinal: 0x13
  ULONG ProxiedProcessId;                       // offset: 0x180 ordinal: 0x14
  struct _ACTIVATION_CONTEXT_STACK32
      _ActivationStack;                    // offset: 0x184 ordinal: 0x15
  UCHAR WorkingOnBehalfTicket[8];          // offset: 0x19c ordinal: 0x16
  LONG ExceptionCode;                      // offset: 0x1a4 ordinal: 0x17
  ULONG ActivationContextStackPointer;     // offset: 0x1a8 ordinal: 0x18
  ULONG InstrumentationCallbackSp;         // offset: 0x1ac ordinal: 0x19
  ULONG InstrumentationCallbackPreviousPc; // offset: 0x1b0 ordinal: 0x1a
  ULONG InstrumentationCallbackPreviousSp; // offset: 0x1b4 ordinal: 0x1b
  UCHAR InstrumentationCallbackDisabled;   // offset: 0x1b8 ordinal: 0x1c
  UCHAR SpareBytes[23];                    // offset: 0x1b9 ordinal: 0x1d
  ULONG TxFsContext;                       // offset: 0x1d0 ordinal: 0x1e
  struct _GDI_TEB_BATCH32 GdiTebBatch;     // offset: 0x1d4 ordinal: 0x1f
  struct _CLIENT_ID32 RealClientId;        // offset: 0x6b4 ordinal: 0x20
  ULONG GdiCachedProcessHandle;            // offset: 0x6bc ordinal: 0x21
  ULONG GdiClientPID;                      // offset: 0x6c0 ordinal: 0x22
  ULONG GdiClientTID;                      // offset: 0x6c4 ordinal: 0x23
  ULONG GdiThreadLocalInfo;                // offset: 0x6c8 ordinal: 0x24
  ULONG Win32ClientInfo[62];               // offset: 0x6cc ordinal: 0x25
  ULONG glDispatchTable[233];              // offset: 0x7c4 ordinal: 0x26
  ULONG glReserved1[29];                   // offset: 0xb68 ordinal: 0x27
  ULONG glReserved2;                       // offset: 0xbdc ordinal: 0x28
  ULONG glSectionInfo;                     // offset: 0xbe0 ordinal: 0x29
  ULONG glSection;                         // offset: 0xbe4 ordinal: 0x2a
  ULONG glTable;                           // offset: 0xbe8 ordinal: 0x2b
  ULONG glCurrentRC;                       // offset: 0xbec ordinal: 0x2c
  ULONG glContext;                         // offset: 0xbf0 ordinal: 0x2d
  ULONG LastStatusValue;                   // offset: 0xbf4 ordinal: 0x2e
  struct _STRING32 StaticUnicodeString;    // offset: 0xbf8 ordinal: 0x2f
  WCHAR StaticUnicodeBuffer[261];          // offset: 0xc00 ordinal: 0x30
  ULONG DeallocationStack;                 // offset: 0xe0c ordinal: 0x31
  ULONG TlsSlots[64];                      // offset: 0xe10 ordinal: 0x32
  struct LIST_ENTRY32 TlsLinks;            // offset: 0xf10 ordinal: 0x33
  ULONG Vdm;                               // offset: 0xf18 ordinal: 0x34
  ULONG ReservedForNtRpc;                  // offset: 0xf1c ordinal: 0x35
  ULONG DbgSsReserved[2];                  // offset: 0xf20 ordinal: 0x36
  ULONG HardErrorMode;                     // offset: 0xf28 ordinal: 0x37
  ULONG Instrumentation[9];                // offset: 0xf2c ordinal: 0x38
  struct _GUID ActivityId;                 // offset: 0xf50 ordinal: 0x39
  ULONG SubProcessTag;                     // offset: 0xf60 ordinal: 0x3a
  ULONG PerflibData;                       // offset: 0xf64 ordinal: 0x3b
  ULONG EtwTraceData;                      // offset: 0xf68 ordinal: 0x3c
  ULONG WinSockData;                       // offset: 0xf6c ordinal: 0x3d
  ULONG GdiBatchCount;                     // offset: 0xf70 ordinal: 0x3e
  union {
    struct _PROCESSOR_NUMBER
        CurrentIdealProcessor; // offset: 0xf74 ordinal: 0x3f
    ULONG IdealProcessorValue; // offset: 0xf74 ordinal: 0x40
    UCHAR ReservedPad0;        // offset: 0xf74 ordinal: 0x41
  };
  UCHAR ReservedPad1;             // offset: 0xf75 ordinal: 0x42
  UCHAR ReservedPad2;             // offset: 0xf76 ordinal: 0x43
  UCHAR IdealProcessor;           // offset: 0xf77 ordinal: 0x44
  ULONG GuaranteedStackBytes;     // offset: 0xf78 ordinal: 0x45
  ULONG ReservedForPerf;          // offset: 0xf7c ordinal: 0x46
  ULONG ReservedForOle;           // offset: 0xf80 ordinal: 0x47
  ULONG WaitingOnLoaderLock;      // offset: 0xf84 ordinal: 0x48
  ULONG SavedPriorityState;       // offset: 0xf88 ordinal: 0x49
  ULONG ReservedForCodeCoverage;  // offset: 0xf8c ordinal: 0x4a
  ULONG ThreadPoolData;           // offset: 0xf90 ordinal: 0x4b
  ULONG TlsExpansionSlots;        // offset: 0xf94 ordinal: 0x4c
  ULONG MuiGeneration;            // offset: 0xf98 ordinal: 0x4d
  ULONG IsImpersonating;          // offset: 0xf9c ordinal: 0x4e
  ULONG NlsCache;                 // offset: 0xfa0 ordinal: 0x4f
  ULONG pShimData;                // offset: 0xfa4 ordinal: 0x50
  ULONG HeapData;                 // offset: 0xfa8 ordinal: 0x51
  ULONG CurrentTransactionHandle; // offset: 0xfac ordinal: 0x52
  ULONG ActiveFrame;              // offset: 0xfb0 ordinal: 0x53
  ULONG FlsData;                  // offset: 0xfb4 ordinal: 0x54
  ULONG PreferredLanguages;       // offset: 0xfb8 ordinal: 0x55
  ULONG UserPrefLanguages;        // offset: 0xfbc ordinal: 0x56
  ULONG MergedPrefLanguages;      // offset: 0xfc0 ordinal: 0x57
  ULONG MuiImpersonation;         // offset: 0xfc4 ordinal: 0x58
  union {
    USHORT CrossTebFlags;          // offset: 0xfc8 ordinal: 0x59
    USHORT SpareCrossTebBits : 16; // offset: 0xfc8 ordinal: 0x5a
  };
  union {
    USHORT SameTebFlags;      // offset: 0xfca ordinal: 0x5b
    USHORT SafeThunkCall : 1; // offset: 0xfca ordinal: 0x5c
  };
  USHORT InDebugPrint : 1;              // offset: 0xfca ordinal: 0x5d
  USHORT HasFiberData : 1;              // offset: 0xfca ordinal: 0x5e
  USHORT SkipThreadAttach : 1;          // offset: 0xfca ordinal: 0x5f
  USHORT WerInShipAssertCode : 1;       // offset: 0xfca ordinal: 0x60
  USHORT RanProcessInit : 1;            // offset: 0xfca ordinal: 0x61
  USHORT ClonedThread : 1;              // offset: 0xfca ordinal: 0x62
  USHORT SuppressDebugMsg : 1;          // offset: 0xfca ordinal: 0x63
  USHORT DisableUserStackWalk : 1;      // offset: 0xfca ordinal: 0x64
  USHORT RtlExceptionAttached : 1;      // offset: 0xfca ordinal: 0x65
  USHORT InitialThread : 1;             // offset: 0xfca ordinal: 0x66
  USHORT SessionAware : 1;              // offset: 0xfca ordinal: 0x67
  USHORT LoadOwner : 1;                 // offset: 0xfca ordinal: 0x68
  USHORT LoaderWorker : 1;              // offset: 0xfca ordinal: 0x69
  USHORT SkipLoaderInit : 1;            // offset: 0xfca ordinal: 0x6a
  USHORT SkipFileAPIBrokering : 1;      // offset: 0xfca ordinal: 0x6b
  ULONG TxnScopeEnterCallback;          // offset: 0xfcc ordinal: 0x6c
  ULONG TxnScopeExitCallback;           // offset: 0xfd0 ordinal: 0x6d
  ULONG TxnScopeContext;                // offset: 0xfd4 ordinal: 0x6e
  ULONG LockCount;                      // offset: 0xfd8 ordinal: 0x6f
  LONG WowTebOffset;                    // offset: 0xfdc ordinal: 0x70
  ULONG ResourceRetValue;               // offset: 0xfe0 ordinal: 0x71
  ULONG ReservedForWdf;                 // offset: 0xfe4 ordinal: 0x72
  ULONGLONG ReservedForCrt;             // offset: 0xfe8 ordinal: 0x73
  struct _GUID EffectiveContainerId;    // offset: 0xff0 ordinal: 0x74
  ULONGLONG LastSleepCounter;           // offset: 0x1000 ordinal: 0x75
  ULONG SpinCallCount;                  // offset: 0x1008 ordinal: 0x76
  ULONGLONG ExtendedFeatureDisableMask; // offset: 0x1010 ordinal: 0x77
} _TEB32;

// 0xd8 bytes (sizeof)
typedef struct PROCESS_PERF_COUNTERS {
  ULONGLONG ProcessorTime;     // offset: 0x0 ordinal: 0x0
  ULONGLONG UserTime;          // offset: 0x8 ordinal: 0x1
  ULONGLONG PrivilegedTime;    // offset: 0x10 ordinal: 0x2
  ULONGLONG VirtualBytesPeak;  // offset: 0x18 ordinal: 0x3
  ULONGLONG VirtualBytes;      // offset: 0x20 ordinal: 0x4
  ULONG PageFaults;            // offset: 0x28 ordinal: 0x5
  ULONG HandleCount;           // offset: 0x2c ordinal: 0x6
  ULONGLONG WorkingSetPeak;    // offset: 0x30 ordinal: 0x7
  ULONGLONG WorkingSet;        // offset: 0x38 ordinal: 0x8
  ULONGLONG PageFileBytesPeak; // offset: 0x40 ordinal: 0x9
  ULONGLONG PageFileBytes;     // offset: 0x48 ordinal: 0xa
  ULONGLONG PrivateBytes;      // offset: 0x50 ordinal: 0xb
  ULONG ThreadCount;           // offset: 0x58 ordinal: 0xc
  ULONG PriorityBase;          // offset: 0x5c ordinal: 0xd
  ULONGLONG ElapsedTime;       // offset: 0x60 ordinal: 0xe
  ULONG ProcessId;             // offset: 0x68 ordinal: 0xf
  ULONG CreatingProcessId;     // offset: 0x6c ordinal: 0x10
  ULONGLONG PoolPagedBytes;    // offset: 0x70 ordinal: 0x11
  ULONGLONG PoolNonpagedBytes; // offset: 0x78 ordinal: 0x12
  ULONGLONG IoReadOperations;  // offset: 0x80 ordinal: 0x13
  ULONGLONG IoWriteOperations; // offset: 0x88 ordinal: 0x14
  ULONGLONG IoDataOperations;  // offset: 0x90 ordinal: 0x15
  ULONGLONG IoOtherOperations; // offset: 0x98 ordinal: 0x16
  ULONGLONG IoReadBytes;       // offset: 0xa0 ordinal: 0x17
  ULONGLONG IoWriteBytes;      // offset: 0xa8 ordinal: 0x18
  ULONGLONG IoDataBytes;       // offset: 0xb0 ordinal: 0x19
  ULONGLONG IoOtherBytes;      // offset: 0xb8 ordinal: 0x1a
  ULONGLONG WorkingSetPrivate; // offset: 0xc0 ordinal: 0x1b
  ULONGLONG PerfFreq;          // offset: 0xc8 ordinal: 0x1c
  ULONGLONG PerfTime;          // offset: 0xd0 ordinal: 0x1d
} PROCESS_PERF_COUNTERS;

// 0x10 bytes (sizeof)
typedef struct _FILESYSTEM_DISK_COUNTERS {
  ULONGLONG FsBytesRead;    // offset: 0x0 ordinal: 0x0
  ULONGLONG FsBytesWritten; // offset: 0x8 ordinal: 0x1
} _FILESYSTEM_DISK_COUNTERS;

// 0x18 bytes (sizeof)
typedef struct _ETW_SESSION_PERF_COUNTERS {
  LONG BufferMemoryPagedPool;    // offset: 0x0 ordinal: 0x0
  LONG BufferMemoryNonPagedPool; // offset: 0x4 ordinal: 0x1
  ULONGLONG EventsLoggedCount;   // offset: 0x8 ordinal: 0x2
  LONG EventsLost;               // offset: 0x10 ordinal: 0x3
  LONG NumConsumers;             // offset: 0x14 ordinal: 0x4
} _ETW_SESSION_PERF_COUNTERS;

// 0xc8 bytes (sizeof)
typedef struct _PCW_PROCESSOR_INFO {
  ULONGLONG IdleTime;               // offset: 0x0 ordinal: 0x0
  ULONGLONG AvailableTime;          // offset: 0x8 ordinal: 0x1
  ULONGLONG UserTime;               // offset: 0x10 ordinal: 0x2
  ULONGLONG KernelTime;             // offset: 0x18 ordinal: 0x3
  ULONG Interrupts;                 // offset: 0x20 ordinal: 0x4
  ULONGLONG DpcTime;                // offset: 0x28 ordinal: 0x5
  ULONGLONG InterruptTime;          // offset: 0x30 ordinal: 0x6
  ULONG ClockInterrupts;            // offset: 0x38 ordinal: 0x7
  ULONG DpcCount;                   // offset: 0x3c ordinal: 0x8
  ULONG DpcRate;                    // offset: 0x40 ordinal: 0x9
  ULONGLONG C1Time;                 // offset: 0x48 ordinal: 0xa
  ULONGLONG C2Time;                 // offset: 0x50 ordinal: 0xb
  ULONGLONG C3Time;                 // offset: 0x58 ordinal: 0xc
  ULONGLONG C1Transitions;          // offset: 0x60 ordinal: 0xd
  ULONGLONG C2Transitions;          // offset: 0x68 ordinal: 0xe
  ULONGLONG C3Transitions;          // offset: 0x70 ordinal: 0xf
  ULONGLONG StallTime;              // offset: 0x78 ordinal: 0x10
  ULONG ParkingStatus;              // offset: 0x80 ordinal: 0x11
  ULONG CurrentFrequency;           // offset: 0x84 ordinal: 0x12
  ULONG PercentMaxFrequency;        // offset: 0x88 ordinal: 0x13
  ULONG StateFlags;                 // offset: 0x8c ordinal: 0x14
  ULONG NominalThroughput;          // offset: 0x90 ordinal: 0x15
  ULONG ActiveThroughput;           // offset: 0x94 ordinal: 0x16
  ULONGLONG ScaledThroughput;       // offset: 0x98 ordinal: 0x17
  ULONGLONG ScaledKernelThroughput; // offset: 0xa0 ordinal: 0x18
  ULONGLONG AverageIdleTime;        // offset: 0xa8 ordinal: 0x19
  ULONGLONG IdleBreakEvents;        // offset: 0xb0 ordinal: 0x1a
  ULONG PerformanceLimit;           // offset: 0xb8 ordinal: 0x1b
  ULONG PerformanceLimitFlags;      // offset: 0xbc ordinal: 0x1c
  ULONGLONG ScaledFrequency;        // offset: 0xc0 ordinal: 0x1d
} _PCW_PROCESSOR_INFO;

// 0x28 bytes (sizeof)
typedef struct _PCW_MASK_INFORMATION {
  ULONGLONG CounterMask;                // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING *InstanceMask; // offset: 0x8 ordinal: 0x1
  ULONG InstanceId;                     // offset: 0x10 ordinal: 0x2
  UCHAR CollectMultiple;                // offset: 0x14 ordinal: 0x3
  struct _PCW_BUFFER *Buffer;           // offset: 0x18 ordinal: 0x4
  struct _KEVENT *CancelEvent;          // offset: 0x20 ordinal: 0x5
} _PCW_MASK_INFORMATION;

// 0x10 bytes (sizeof)
typedef struct _PCW_COUNTER_INFORMATION {
  ULONGLONG CounterMask;                // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING *InstanceMask; // offset: 0x8 ordinal: 0x1
} _PCW_COUNTER_INFORMATION;

// 0x28 bytes (sizeof)
typedef union _PCW_CALLBACK_INFORMATION {
  struct _PCW_COUNTER_INFORMATION AddCounter;      // offset: 0x0 ordinal: 0x0
  struct _PCW_COUNTER_INFORMATION RemoveCounter;   // offset: 0x0 ordinal: 0x1
  struct _PCW_MASK_INFORMATION EnumerateInstances; // offset: 0x0 ordinal: 0x2
  struct _PCW_MASK_INFORMATION CollectData;        // offset: 0x0 ordinal: 0x3
} _PCW_CALLBACK_INFORMATION;

typedef LONG (*__anon_2469)(enum _PCW_CALLBACK_TYPE,
                            union _PCW_CALLBACK_INFORMATION *, VOID *);

// 0x38 bytes (sizeof)
typedef struct _PCW_REGISTRATION_INFORMATION {
  ULONG Version;                            // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING *Name;             // offset: 0x8 ordinal: 0x1
  ULONG CounterCount;                       // offset: 0x10 ordinal: 0x2
  struct _PCW_COUNTER_DESCRIPTOR *Counters; // offset: 0x18 ordinal: 0x3
  LONG(*Callback)
  (enum _PCW_CALLBACK_TYPE, union _PCW_CALLBACK_INFORMATION *,
   VOID *);                          // offset: 0x20 ordinal: 0x4
  VOID *CallbackContext;             // offset: 0x28 ordinal: 0x5
  enum PCW_REGISTRATION_FLAGS Flags; // offset: 0x30 ordinal: 0x6
} _PCW_REGISTRATION_INFORMATION;

// 0x340 bytes (sizeof)
typedef struct tagSWITCH_CONTEXT_DATA {
  ULONGLONG ullOsMaxVersionTested; // offset: 0x0 ordinal: 0x0
  ULONG ulTargetPlatform;          // offset: 0x8 ordinal: 0x1
  ULONGLONG ullContextMinimum;     // offset: 0x10 ordinal: 0x2
  struct _GUID guPlatform;         // offset: 0x18 ordinal: 0x3
  struct _GUID guMinPlatform;      // offset: 0x28 ordinal: 0x4
  ULONG ulContextSource;           // offset: 0x38 ordinal: 0x5
  ULONG ulElementCount;            // offset: 0x3c ordinal: 0x6
  struct _GUID guElements[48];     // offset: 0x40 ordinal: 0x7
} tagSWITCH_CONTEXT_DATA;

// 0x18 bytes (sizeof)
typedef struct tagSWITCH_CONTEXT_ATTRIBUTE {
  ULONGLONG ulContextUpdateCounter; // offset: 0x0 ordinal: 0x0
  LONG fAllowContextUpdate;         // offset: 0x8 ordinal: 0x1
  LONG fEnableTrace;                // offset: 0xc ordinal: 0x2
  ULONGLONG EtwHandle;              // offset: 0x10 ordinal: 0x3
} tagSWITCH_CONTEXT_ATTRIBUTE;

// 0x358 bytes (sizeof)
typedef struct tagSWITCH_CONTEXT {
  struct tagSWITCH_CONTEXT_ATTRIBUTE Attribute; // offset: 0x0 ordinal: 0x0
  struct tagSWITCH_CONTEXT_DATA Data;           // offset: 0x18 ordinal: 0x1
} tagSWITCH_CONTEXT;

// 0x8 bytes (sizeof)
typedef union _CLS_LSN {
  struct __anon_2438 offset; // offset: 0x0 ordinal: 0x0
  ULONGLONG ullOffset;       // offset: 0x0 ordinal: 0x1
} _CLS_LSN;

// 0x8 bytes (sizeof)
typedef union _CM_TRANS_PTR {
  ULONGLONG LightWeight : 1; // offset: 0x0 ordinal: 0x0
  VOID *TransPtr;            // offset: 0x0 ordinal: 0x1
} _CM_TRANS_PTR;

// 0x70 bytes (sizeof)
typedef struct _CM_KEY_BODY {
  ULONG Type;                                    // offset: 0x0 ordinal: 0x0
  struct _CM_KEY_CONTROL_BLOCK *KeyControlBlock; // offset: 0x8 ordinal: 0x1
  struct _CM_NOTIFY_BLOCK *NotifyBlock;          // offset: 0x10 ordinal: 0x2
  VOID *ProcessID;                               // offset: 0x18 ordinal: 0x3
  struct _LIST_ENTRY KeyBodyList;                // offset: 0x20 ordinal: 0x4
  ULONG Flags : 16;                              // offset: 0x30 ordinal: 0x5
  ULONG HandleTags : 16;                         // offset: 0x30 ordinal: 0x6
  union _CM_TRANS_PTR Trans;                     // offset: 0x38 ordinal: 0x7
  struct _GUID *KtmUow;                          // offset: 0x40 ordinal: 0x8
  struct _LIST_ENTRY ContextListHead;            // offset: 0x48 ordinal: 0x9
  VOID *EnumerationResumeContext;                // offset: 0x58 ordinal: 0xa
  ULONG RestrictedAccessMask;                    // offset: 0x60 ordinal: 0xb
  ULONG LastSearchedIndex;                       // offset: 0x64 ordinal: 0xc
  VOID *LockedMemoryMdls;                        // offset: 0x68 ordinal: 0xd
} _CM_KEY_BODY;

// 0x58 bytes (sizeof)
typedef struct _CM_NOTIFY_BLOCK {
  struct _LIST_ENTRY HiveList;                     // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY PostList;                     // offset: 0x10 ordinal: 0x1
  struct _CM_KEY_CONTROL_BLOCK *KeyControlBlock;   // offset: 0x20 ordinal: 0x2
  struct _CM_KEY_BODY *KeyBody;                    // offset: 0x28 ordinal: 0x3
  ULONG Filter : 30;                               // offset: 0x30 ordinal: 0x4
  ULONG WatchTree : 1;                             // offset: 0x30 ordinal: 0x5
  ULONG NotifyPending : 1;                         // offset: 0x30 ordinal: 0x6
  struct _SECURITY_SUBJECT_CONTEXT SubjectContext; // offset: 0x38 ordinal: 0x7
} _CM_NOTIFY_BLOCK;

// 0x18 bytes (sizeof)
typedef struct _HMAP_ENTRY {
  ULONGLONG BlockOffset;         // offset: 0x0 ordinal: 0x0
  ULONGLONG PermanentBinAddress; // offset: 0x8 ordinal: 0x1
  ULONG MemAlloc;                // offset: 0x10 ordinal: 0x2
} _HMAP_ENTRY;

// 0x3000 bytes (sizeof)
typedef struct _HMAP_TABLE {
  struct _HMAP_ENTRY Table[512]; // offset: 0x0 ordinal: 0x0
} _HMAP_TABLE;

// 0x2000 bytes (sizeof)
typedef struct _HMAP_DIRECTORY {
  struct _HMAP_TABLE *Directory[1024]; // offset: 0x0 ordinal: 0x0
} _HMAP_DIRECTORY;

// 0x278 bytes (sizeof)
typedef struct _DUAL {
  ULONG Length;                         // offset: 0x0 ordinal: 0x0
  struct _HMAP_DIRECTORY *Map;          // offset: 0x8 ordinal: 0x1
  struct _HMAP_TABLE *SmallDir;         // offset: 0x10 ordinal: 0x2
  ULONG Guard;                          // offset: 0x18 ordinal: 0x3
  struct _FREE_DISPLAY FreeDisplay[24]; // offset: 0x20 ordinal: 0x4
  struct _LIST_ENTRY FreeBins;          // offset: 0x260 ordinal: 0x5
  ULONG FreeSummary;                    // offset: 0x270 ordinal: 0x6
} _DUAL;

// 0x30 bytes (sizeof)
typedef struct _CMSI_PROCESS_TUPLE {
  VOID *ProcessHandle;                 // offset: 0x0 ordinal: 0x0
  VOID *ProcessReference;              // offset: 0x8 ordinal: 0x1
  struct _CMSI_RW_LOCK WorkingSetLock; // offset: 0x10 ordinal: 0x2
  ULONGLONG LockedPageCharges;         // offset: 0x18 ordinal: 0x3
  ULONGLONG WorkingSetMinimum;         // offset: 0x20 ordinal: 0x4
  ULONGLONG WorkingSetMaximum;         // offset: 0x28 ordinal: 0x5
} _CMSI_PROCESS_TUPLE;

// 0x38 bytes (sizeof)
typedef struct _HVP_VIEW_MAP {
  VOID *SectionReference;                   // offset: 0x0 ordinal: 0x0
  LONGLONG StorageEndFileOffset;            // offset: 0x8 ordinal: 0x1
  LONGLONG SectionEndFileOffset;            // offset: 0x10 ordinal: 0x2
  struct _CMSI_PROCESS_TUPLE *ProcessTuple; // offset: 0x18 ordinal: 0x3
  ULONG Flags;                              // offset: 0x20 ordinal: 0x4
  struct _RTL_RB_TREE ViewTree;             // offset: 0x28 ordinal: 0x5
} _HVP_VIEW_MAP;

// 0x1000 bytes (sizeof)
typedef struct _HBASE_BLOCK {
  ULONG Signature;                // offset: 0x0 ordinal: 0x0
  ULONG Sequence1;                // offset: 0x4 ordinal: 0x1
  ULONG Sequence2;                // offset: 0x8 ordinal: 0x2
  union _LARGE_INTEGER TimeStamp; // offset: 0xc ordinal: 0x3
  ULONG Major;                    // offset: 0x14 ordinal: 0x4
  ULONG Minor;                    // offset: 0x18 ordinal: 0x5
  ULONG Type;                     // offset: 0x1c ordinal: 0x6
  ULONG Format;                   // offset: 0x20 ordinal: 0x7
  ULONG RootCell;                 // offset: 0x24 ordinal: 0x8
  ULONG Length;                   // offset: 0x28 ordinal: 0x9
  ULONG Cluster;                  // offset: 0x2c ordinal: 0xa
  UCHAR FileName[64];             // offset: 0x30 ordinal: 0xb
  struct _GUID RmId;              // offset: 0x70 ordinal: 0xc
  struct _GUID LogId;             // offset: 0x80 ordinal: 0xd
  ULONG Flags;                    // offset: 0x90 ordinal: 0xe
  struct _GUID TmId;              // offset: 0x94 ordinal: 0xf
  ULONG GuidSignature;            // offset: 0xa4 ordinal: 0x10
  ULONGLONG LastReorganizeTime;   // offset: 0xa8 ordinal: 0x11
  ULONG Reserved1[83];            // offset: 0xb0 ordinal: 0x12
  ULONG CheckSum;                 // offset: 0x1fc ordinal: 0x13
  ULONG Reserved2[882];           // offset: 0x200 ordinal: 0x14
  struct _GUID ThawTmId;          // offset: 0xfc8 ordinal: 0x15
  struct _GUID ThawRmId;          // offset: 0xfd8 ordinal: 0x16
  struct _GUID ThawLogId;         // offset: 0xfe8 ordinal: 0x17
  ULONG BootType;                 // offset: 0xff8 ordinal: 0x18
  ULONG BootRecover;              // offset: 0xffc ordinal: 0x19
} _HBASE_BLOCK;

// 0x608 bytes (sizeof)
typedef struct _HHIVE {
  ULONG Signature; // offset: 0x0 ordinal: 0x0
  struct _CELL_DATA *(*GetCellRoutine)(
      struct _HHIVE *, ULONG,
      struct _HV_GET_CELL_CONTEXT *); // offset: 0x8 ordinal: 0x1
  VOID(*ReleaseCellRoutine)
  (struct _HHIVE *, struct _HV_GET_CELL_CONTEXT *); // offset: 0x10 ordinal: 0x2
  VOID *(*Allocate)(ULONG, UCHAR, ULONG);           // offset: 0x18 ordinal: 0x3
  VOID (*Free)(VOID *, ULONG);                      // offset: 0x20 ordinal: 0x4
  LONG(*FileWrite)
  (struct _HHIVE *, ULONG, struct CMP_OFFSET_ARRAY *, ULONG,
   ULONG); // offset: 0x28 ordinal: 0x5
  LONG(*FileRead)
  (struct _HHIVE *, ULONG, ULONG, VOID *, ULONG); // offset: 0x30 ordinal: 0x6
  VOID *HiveLoadFailure;                          // offset: 0x38 ordinal: 0x7
  struct _HBASE_BLOCK *BaseBlock;                 // offset: 0x40 ordinal: 0x8
  struct _CMSI_RW_LOCK FlusherLock;               // offset: 0x48 ordinal: 0x9
  struct _CMSI_RW_LOCK WriterLock;                // offset: 0x50 ordinal: 0xa
  struct _RTL_BITMAP DirtyVector;                 // offset: 0x58 ordinal: 0xb
  ULONG DirtyCount;                               // offset: 0x68 ordinal: 0xc
  ULONG DirtyAlloc;                               // offset: 0x6c ordinal: 0xd
  struct _RTL_BITMAP UnreconciledVector;          // offset: 0x70 ordinal: 0xe
  ULONG UnreconciledCount;                        // offset: 0x80 ordinal: 0xf
  ULONG BaseBlockAlloc;                           // offset: 0x84 ordinal: 0x10
  ULONG Cluster;                                  // offset: 0x88 ordinal: 0x11
  UCHAR Flat : 1;                                 // offset: 0x8c ordinal: 0x12
  UCHAR ReadOnly : 1;                             // offset: 0x8c ordinal: 0x13
  UCHAR Reserved : 6;                             // offset: 0x8c ordinal: 0x14
  UCHAR DirtyFlag;                                // offset: 0x8d ordinal: 0x15
  ULONG HvBinHeadersUse;                          // offset: 0x90 ordinal: 0x16
  ULONG HvFreeCellsUse;                           // offset: 0x94 ordinal: 0x17
  ULONG HvUsedCellsUse;                           // offset: 0x98 ordinal: 0x18
  ULONG CmUsedCellsUse;                           // offset: 0x9c ordinal: 0x19
  ULONG HiveFlags;                                // offset: 0xa0 ordinal: 0x1a
  ULONG FlusherFlags;                             // offset: 0xa4 ordinal: 0x1b
  ULONG CurrentLog;                               // offset: 0xa8 ordinal: 0x1c
  ULONG CurrentLogSequence;                       // offset: 0xac ordinal: 0x1d
  ULONG CurrentLogMinimumSequence;                // offset: 0xb0 ordinal: 0x1e
  ULONG CurrentLogOffset;                         // offset: 0xb4 ordinal: 0x1f
  ULONG MinimumLogSequence;                       // offset: 0xb8 ordinal: 0x20
  ULONG LogFileSizeCap;                           // offset: 0xbc ordinal: 0x21
  UCHAR LogDataPresent[2];                        // offset: 0xc0 ordinal: 0x22
  UCHAR PrimaryFileValid;                         // offset: 0xc2 ordinal: 0x23
  UCHAR BaseBlockDirty;                           // offset: 0xc3 ordinal: 0x24
  union _LARGE_INTEGER LastLogSwapTime;           // offset: 0xc8 ordinal: 0x25
  USHORT FirstLogFile : 3;                        // offset: 0xd0 ordinal: 0x26
  USHORT SecondLogFile : 3;                       // offset: 0xd0 ordinal: 0x27
  USHORT HeaderRecovered : 1;                     // offset: 0xd0 ordinal: 0x28
  USHORT LegacyRecoveryIndicated : 1;             // offset: 0xd0 ordinal: 0x29
  USHORT RecoveryInformationReserved : 8;         // offset: 0xd0 ordinal: 0x2a
  USHORT RecoveryInformation;                     // offset: 0xd0 ordinal: 0x2b
  UCHAR LogEntriesRecovered[2];                   // offset: 0xd2 ordinal: 0x2c
  ULONG RefreshCount;                             // offset: 0xd4 ordinal: 0x2d
  ULONG StorageTypeCount;                         // offset: 0xd8 ordinal: 0x2e
  ULONG Version;                                  // offset: 0xdc ordinal: 0x2f
  struct _HVP_VIEW_MAP ViewMap;                   // offset: 0xe0 ordinal: 0x30
  struct _DUAL Storage[2];                        // offset: 0x118 ordinal: 0x31
} _HHIVE;

// 0x20 bytes (sizeof)
typedef struct _CM_KEY_HASH {
  struct _CM_PATH_HASH ConvKey;  // offset: 0x0 ordinal: 0x0
  struct _CM_KEY_HASH *NextHash; // offset: 0x8 ordinal: 0x1
  struct _HHIVE *KeyHive;        // offset: 0x10 ordinal: 0x2
  ULONG KeyCell;                 // offset: 0x18 ordinal: 0x3
} _CM_KEY_HASH;

// 0x10 bytes (sizeof)
typedef struct _CM_KEY_REFERENCE {
  ULONG KeyCell;          // offset: 0x0 ordinal: 0x0
  struct _HHIVE *KeyHive; // offset: 0x8 ordinal: 0x1
} _CM_KEY_REFERENCE;

// 0x50 bytes (sizeof)
typedef struct _CM_KEY_NODE {
  USHORT Signature;                            // offset: 0x0 ordinal: 0x0
  USHORT Flags;                                // offset: 0x2 ordinal: 0x1
  union _LARGE_INTEGER LastWriteTime;          // offset: 0x4 ordinal: 0x2
  UCHAR AccessBits;                            // offset: 0xc ordinal: 0x3
  UCHAR LayerSemantics : 2;                    // offset: 0xd ordinal: 0x4
  UCHAR Spare1 : 5;                            // offset: 0xd ordinal: 0x5
  UCHAR InheritClass : 1;                      // offset: 0xd ordinal: 0x6
  USHORT Spare2;                               // offset: 0xe ordinal: 0x7
  ULONG Parent;                                // offset: 0x10 ordinal: 0x8
  ULONG SubKeyCounts[2];                       // offset: 0x14 ordinal: 0x9
  ULONG SubKeyLists[2];                        // offset: 0x1c ordinal: 0xa
  struct _CHILD_LIST ValueList;                // offset: 0x24 ordinal: 0xb
  struct _CM_KEY_REFERENCE ChildHiveReference; // offset: 0x1c ordinal: 0xc
  ULONG Security;                              // offset: 0x2c ordinal: 0xd
  ULONG Class;                                 // offset: 0x30 ordinal: 0xe
  ULONG MaxNameLen : 16;                       // offset: 0x34 ordinal: 0xf
  ULONG UserFlags : 4;                         // offset: 0x34 ordinal: 0x10
  ULONG VirtControlFlags : 4;                  // offset: 0x34 ordinal: 0x11
  ULONG Debug : 8;                             // offset: 0x34 ordinal: 0x12
  ULONG MaxClassLen;                           // offset: 0x38 ordinal: 0x13
  ULONG MaxValueNameLen;                       // offset: 0x3c ordinal: 0x14
  ULONG MaxValueDataLen;                       // offset: 0x40 ordinal: 0x15
  ULONG WorkVar;                               // offset: 0x44 ordinal: 0x16
  USHORT NameLength;                           // offset: 0x48 ordinal: 0x17
  USHORT ClassLength;                          // offset: 0x4a ordinal: 0x18
  WCHAR Name[1];                               // offset: 0x4c ordinal: 0x19
} _CM_KEY_NODE;

// 0x50 bytes (sizeof)
typedef union _u {
  struct _CM_KEY_NODE KeyNode;         // offset: 0x0 ordinal: 0x0
  struct _CM_KEY_VALUE KeyValue;       // offset: 0x0 ordinal: 0x1
  struct _CM_KEY_SECURITY KeySecurity; // offset: 0x0 ordinal: 0x2
  struct _CM_KEY_INDEX KeyIndex;       // offset: 0x0 ordinal: 0x3
  struct _CM_BIG_DATA ValueData;       // offset: 0x0 ordinal: 0x4
  ULONG KeyList[1];                    // offset: 0x0 ordinal: 0x5
  WCHAR KeyString[1];                  // offset: 0x0 ordinal: 0x6
} _u;

// 0x50 bytes (sizeof)
typedef struct _CELL_DATA {
  union _u u; // offset: 0x0 ordinal: 0x0
} _CELL_DATA;

typedef LONG (*__anon_2318)(struct _HHIVE *, ULONG, ULONG, VOID *, ULONG);

typedef LONG (*__anon_2317)(struct _HHIVE *, ULONG, struct CMP_OFFSET_ARRAY *,
                            ULONG, ULONG);

typedef VOID (*__anon_2315)(struct _HHIVE *, struct _HV_GET_CELL_CONTEXT *);

typedef struct _CELL_DATA *(*__anon_2314)(struct _HHIVE *, ULONG,
                                          struct _HV_GET_CELL_CONTEXT *);

// 0x8 bytes (sizeof)
typedef union _MM_STORE_KEY {
  ULONGLONG KeyLow : 60; // offset: 0x0 ordinal: 0x0
  ULONGLONG KeyHigh : 4; // offset: 0x0 ordinal: 0x1
  ULONGLONG EntireKey;   // offset: 0x0 ordinal: 0x2
} _MM_STORE_KEY;

// 0x8 bytes (sizeof)
typedef union __anon_2300 {
  ULONGLONG EventListULongPtr; // offset: 0x0 ordinal: 0x0
  UCHAR StartingVpnHigher : 4; // offset: 0x0 ordinal: 0x1
} __anon_2300;

// 0x8 bytes (sizeof)
typedef struct __anon_2287 {
  ULONGLONG PrototypePtesFlags; // offset: 0x0 ordinal: 0x0
} __anon_2287;

// 0x8 bytes (sizeof)
typedef struct __anon_2286 {
  ULONGLONG AllocationType : 3; // offset: 0x0 ordinal: 0x0
  ULONGLONG Inserted : 1;       // offset: 0x0 ordinal: 0x1
} __anon_2286;

// 0x8 bytes (sizeof)
typedef union __anon_2285 {
  struct __anon_2286 e1; // offset: 0x0 ordinal: 0x0
  struct __anon_2287 e2; // offset: 0x0 ordinal: 0x1
} __anon_2285;

// 0x8 bytes (sizeof)
typedef union __anon_2284 {
  VOID *ImageFileExtents;             // offset: 0x0 ordinal: 0x0
  ULONGLONG ImageFileExtentsUlongPtr; // offset: 0x0 ordinal: 0x1
  ULONGLONG FilesystemWantsRva : 1;   // offset: 0x0 ordinal: 0x2
  ULONGLONG Spare : 3;                // offset: 0x0 ordinal: 0x3
} __anon_2284;

// 0x8 bytes (sizeof)
typedef struct _IMAGE_SECURITY_CONTEXT {
  union {
    VOID *PageHashes;                   // offset: 0x0 ordinal: 0x0
    ULONGLONG Value;                    // offset: 0x0 ordinal: 0x1
    ULONGLONG SecurityBeingCreated : 2; // offset: 0x0 ordinal: 0x2
  };
  ULONGLONG SecurityMandatory : 1; // offset: 0x0 ordinal: 0x3
  ULONGLONG PageHashPointer : 61;  // offset: 0x0 ordinal: 0x4
} _IMAGE_SECURITY_CONTEXT;

// 0x40 bytes (sizeof)
typedef struct _SECTION_IMAGE_INFORMATION {
  VOID *TransferAddress;              // offset: 0x0 ordinal: 0x0
  ULONG ZeroBits;                     // offset: 0x8 ordinal: 0x1
  ULONGLONG MaximumStackSize;         // offset: 0x10 ordinal: 0x2
  ULONGLONG CommittedStackSize;       // offset: 0x18 ordinal: 0x3
  ULONG SubSystemType;                // offset: 0x20 ordinal: 0x4
  USHORT SubSystemMinorVersion;       // offset: 0x24 ordinal: 0x5
  USHORT SubSystemMajorVersion;       // offset: 0x26 ordinal: 0x6
  ULONG SubSystemVersion;             // offset: 0x24 ordinal: 0x7
  USHORT MajorOperatingSystemVersion; // offset: 0x28 ordinal: 0x8
  USHORT MinorOperatingSystemVersion; // offset: 0x2a ordinal: 0x9
  ULONG OperatingSystemVersion;       // offset: 0x28 ordinal: 0xa
  USHORT ImageCharacteristics;        // offset: 0x2c ordinal: 0xb
  USHORT DllCharacteristics;          // offset: 0x2e ordinal: 0xc
  USHORT Machine;                     // offset: 0x30 ordinal: 0xd
  UCHAR ImageContainsCode;            // offset: 0x32 ordinal: 0xe
  union {
    UCHAR ImageFlags;             // offset: 0x33 ordinal: 0xf
    UCHAR ComPlusNativeReady : 1; // offset: 0x33 ordinal: 0x10
  };
  UCHAR ComPlusILOnly : 1;             // offset: 0x33 ordinal: 0x11
  UCHAR ImageDynamicallyRelocated : 1; // offset: 0x33 ordinal: 0x12
  UCHAR ImageMappedFlat : 1;           // offset: 0x33 ordinal: 0x13
  UCHAR BaseBelow4gb : 1;              // offset: 0x33 ordinal: 0x14
  UCHAR ComPlusPrefer32bit : 1;        // offset: 0x33 ordinal: 0x15
  UCHAR Reserved : 2;                  // offset: 0x33 ordinal: 0x16
  ULONG LoaderFlags;                   // offset: 0x34 ordinal: 0x17
  ULONG ImageFileSize;                 // offset: 0x38 ordinal: 0x18
  ULONG CheckSum;                      // offset: 0x3c ordinal: 0x19
} _SECTION_IMAGE_INFORMATION;

// 0x50 bytes (sizeof)
typedef struct _MI_SECTION_IMAGE_INFORMATION {
  struct _SECTION_IMAGE_INFORMATION
      ExportedImageInformation; // offset: 0x0 ordinal: 0x0
  struct _MI_EXTRA_IMAGE_INFORMATION
      InternalImageInformation; // offset: 0x40 ordinal: 0x1
} _MI_SECTION_IMAGE_INFORMATION;

// 0x8 bytes (sizeof)
typedef union __anon_2239 {
  struct _MI_SECTION_IMAGE_INFORMATION
      *ImageInformation; // offset: 0x0 ordinal: 0x0
  VOID *FirstMappedVa;   // offset: 0x0 ordinal: 0x1
} __anon_2239;

// 0x8 bytes (sizeof)
typedef union __anon_2266 {
  ULONGLONG IoAttributionContext : 61; // offset: 0x0 ordinal: 0x0
  ULONGLONG Spare : 3;                 // offset: 0x0 ordinal: 0x1
  ULONGLONG ImageCrossPartitionCharge; // offset: 0x0 ordinal: 0x2
  ULONGLONG CommittedPageCount : 36;   // offset: 0x0 ordinal: 0x3
} __anon_2266;

// 0x10 bytes (sizeof)
typedef struct _MMEXTEND_INFO {
  ULONGLONG CommittedSize; // offset: 0x0 ordinal: 0x0
  ULONG ReferenceCount;    // offset: 0x8 ordinal: 0x1
} _MMEXTEND_INFO;

// 0x8 bytes (sizeof)
typedef union __anon_4017 {
  struct _MI_VAD_SEQUENTIAL_INFO SequentialVa; // offset: 0x0 ordinal: 0x0
  struct _MMEXTEND_INFO *ExtendedInfo;         // offset: 0x0 ordinal: 0x1
} __anon_4017;

// 0x8 bytes (sizeof)
typedef struct _MI_DECAY_TIMER_LINKAGE {
  ULONGLONG Spare0 : 1;            // offset: 0x0 ordinal: 0x0
  ULONGLONG PreviousDecayPfn : 31; // offset: 0x0 ordinal: 0x1
  ULONGLONG TimerRemoved : 1;      // offset: 0x0 ordinal: 0x2
  ULONGLONG NextDecayPfn : 31;     // offset: 0x0 ordinal: 0x3
} _MI_DECAY_TIMER_LINKAGE;

// 0x8 bytes (sizeof)
typedef union __anon_2238 {
  ULONGLONG ImageCommitment; // offset: 0x0 ordinal: 0x0
  ULONG CreatingProcessId;   // offset: 0x0 ordinal: 0x1
} __anon_2238;

// 0x10 bytes (sizeof)
typedef struct _PHYSICAL_MEMORY_RUN {
  ULONGLONG BasePage;  // offset: 0x0 ordinal: 0x0
  ULONGLONG PageCount; // offset: 0x8 ordinal: 0x1
} _PHYSICAL_MEMORY_RUN;

// 0x8 bytes (sizeof)
typedef union __anon_2227 {
  ULONGLONG Long;                    // offset: 0x0 ordinal: 0x0
  struct _MI_DECAY_TIMER_LINKAGE e1; // offset: 0x0 ordinal: 0x1
} __anon_2227;

// 0x8 bytes (sizeof)
typedef struct _MI_DECAY_TIMER_LINK {
  union __anon_2227 u1; // offset: 0x0 ordinal: 0x0
} _MI_DECAY_TIMER_LINK;

// 0x200 bytes (sizeof)
typedef struct _MI_STANDBY_LOOKASIDE {
  ULONGLONG Array[64]; // offset: 0x0 ordinal: 0x0
} _MI_STANDBY_LOOKASIDE;

// 0x18 bytes (sizeof)
typedef struct _MI_FREE_LARGE_PAGE_LIST {
  struct _LIST_ENTRY ListHead; // offset: 0x0 ordinal: 0x0
  ULONGLONG EntryCount;        // offset: 0x10 ordinal: 0x1
} _MI_FREE_LARGE_PAGE_LIST;

// 0x20 bytes (sizeof)
typedef struct _MI_CROSS_PARTITION_CHARGES {
  ULONGLONG CurrentCharges; // offset: 0x0 ordinal: 0x0
  ULONGLONG ChargeFailures; // offset: 0x8 ordinal: 0x1
  ULONGLONG ChargePeak;     // offset: 0x10 ordinal: 0x2
  ULONGLONG MaximumAllowed; // offset: 0x18 ordinal: 0x3
} _MI_CROSS_PARTITION_CHARGES;

// 0x20 bytes (sizeof)
typedef struct _PHYSICAL_MEMORY_DESCRIPTOR {
  ULONG NumberOfRuns;                 // offset: 0x0 ordinal: 0x0
  ULONGLONG NumberOfPages;            // offset: 0x8 ordinal: 0x1
  struct _PHYSICAL_MEMORY_RUN Run[1]; // offset: 0x10 ordinal: 0x2
} _PHYSICAL_MEMORY_DESCRIPTOR;

// 0x28 bytes (sizeof)
typedef struct _MI_PAGE_COMBINE_STATISTICS {
  ULONGLONG PagesScannedActive;         // offset: 0x0 ordinal: 0x0
  ULONGLONG PagesScannedStandby;        // offset: 0x8 ordinal: 0x1
  ULONGLONG PagesCombined;              // offset: 0x10 ordinal: 0x2
  ULONG CombineScanCount;               // offset: 0x18 ordinal: 0x3
  LONG CombinedBlocksInUse;             // offset: 0x1c ordinal: 0x4
  LONG SumCombinedBlocksReferenceCount; // offset: 0x20 ordinal: 0x5
  ULONG NonSlabPagesUsedForInPage;      // offset: 0x24 ordinal: 0x6
} _MI_PAGE_COMBINE_STATISTICS;

// 0x20 bytes (sizeof)
typedef struct _MI_DEFERRED_PFNS_TO_FREE {
  struct _LIST_ENTRY ListHead; // offset: 0x0 ordinal: 0x0
  ULONGLONG NumberOfPages;     // offset: 0x10 ordinal: 0x1
  ULONG TbFlushStamp;          // offset: 0x18 ordinal: 0x2
} _MI_DEFERRED_PFNS_TO_FREE;

// 0x40 bytes (sizeof)
typedef struct _MI_MODWRITE_DATA {
  LONGLONG PagesLoad;                    // offset: 0x0 ordinal: 0x0
  ULONGLONG PagesAverage;                // offset: 0x8 ordinal: 0x1
  ULONGLONG AverageAvailablePages;       // offset: 0x10 ordinal: 0x2
  ULONGLONG PagesWritten;                // offset: 0x18 ordinal: 0x3
  ULONG WritesIssued;                    // offset: 0x20 ordinal: 0x4
  ULONG IgnoredReservationsCount;        // offset: 0x24 ordinal: 0x5
  ULONG FreedReservationsCount;          // offset: 0x28 ordinal: 0x6
  ULONG WriteBurstCount;                 // offset: 0x2c ordinal: 0x7
  ULONGLONG IgnoreReservationsStartTime; // offset: 0x30 ordinal: 0x8
  union _MI_RESERVATION_CLUSTER_INFO
      ReservationClusterInfo;    // offset: 0x38 ordinal: 0x9
  USHORT IgnoreReservations : 1; // offset: 0x3c ordinal: 0xa
  USHORT Spare : 15;             // offset: 0x3c ordinal: 0xb
  USHORT Spare1;                 // offset: 0x3e ordinal: 0xc
} _MI_MODWRITE_DATA;

// 0x190 bytes (sizeof)
typedef struct _MI_PAGE_COMBINING_SUPPORT {
  struct _MI_PARTITION *Partition;                 // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY ArbitraryPfnMapList;          // offset: 0x8 ordinal: 0x1
  struct _MI_COMBINE_WORKITEM FreeCombinePoolItem; // offset: 0x18 ordinal: 0x2
  ULONG CombiningThreadCount;                      // offset: 0x40 ordinal: 0x3
  struct _LIST_ENTRY CombinePageFreeList;          // offset: 0x48 ordinal: 0x4
  ULONGLONG CombineFreeListLock;                   // offset: 0x58 ordinal: 0x5
  struct _MI_COMBINE_PAGE_LISTHEAD
      CombinePageListHeads[16];      // offset: 0x60 ordinal: 0x6
  ULONGLONG CommonPageCombineDomain; // offset: 0x160 ordinal: 0x7
  struct _MI_PAGE_COMBINE_STATISTICS
      PageCombineStats; // offset: 0x168 ordinal: 0x8
} _MI_PAGE_COMBINING_SUPPORT;

// 0x40 bytes (sizeof)
typedef struct _MI_PARTITION_COMMIT {
  ULONGLONG PeakCommitment;          // offset: 0x0 ordinal: 0x0
  ULONGLONG TotalCommitLimitMaximum; // offset: 0x8 ordinal: 0x1
  LONG Popups[2];                    // offset: 0x10 ordinal: 0x2
  ULONGLONG LowCommitThreshold;      // offset: 0x18 ordinal: 0x3
  ULONGLONG HighCommitThreshold;     // offset: 0x20 ordinal: 0x4
  ULONGLONG EventLock;               // offset: 0x28 ordinal: 0x5
  ULONGLONG SystemCommitReserve;     // offset: 0x30 ordinal: 0x6
  ULONGLONG OverCommit;              // offset: 0x38 ordinal: 0x7
} _MI_PARTITION_COMMIT;

// 0x8 bytes (sizeof)
typedef struct _MI_CLONE_BLOCK_FLAGS {
  ULONGLONG ReducedCommitCount : 55;            // offset: 0x0 ordinal: 0x0
  ULONGLONG CloneProtection : 5;                // offset: 0x0 ordinal: 0x1
  ULONGLONG OwningPartitionResidentCharged : 1; // offset: 0x0 ordinal: 0x2
  ULONGLONG OwningPartitionCommitCharged : 1;   // offset: 0x0 ordinal: 0x3
  ULONGLONG OwningPartitionCommitFloating : 1;  // offset: 0x0 ordinal: 0x4
  ULONGLONG LockBit : 1;                        // offset: 0x0 ordinal: 0x5
} _MI_CLONE_BLOCK_FLAGS;

// 0x8 bytes (sizeof)
typedef union __anon_2135 {
  LONGLONG EntireField;               // offset: 0x0 ordinal: 0x0
  struct _MI_CLONE_BLOCK_FLAGS Flags; // offset: 0x0 ordinal: 0x1
} __anon_2135;

// 0x8 bytes (sizeof)
typedef struct _MIPFNBLINK {
  ULONGLONG Blink : 40;                  // offset: 0x0 ordinal: 0x0
  ULONGLONG NodeBlinkLow : 19;           // offset: 0x0 ordinal: 0x1
  ULONGLONG TbFlushStamp : 3;            // offset: 0x0 ordinal: 0x2
  ULONGLONG PageBlinkDeleteBit : 1;      // offset: 0x0 ordinal: 0x3
  ULONGLONG PageBlinkLockBit : 1;        // offset: 0x0 ordinal: 0x4
  ULONGLONG ShareCount : 62;             // offset: 0x0 ordinal: 0x5
  ULONGLONG PageShareCountDeleteBit : 1; // offset: 0x0 ordinal: 0x6
  ULONGLONG PageShareCountLockBit : 1;   // offset: 0x0 ordinal: 0x7
  union {
    ULONGLONG EntireField;      // offset: 0x0 ordinal: 0x8
    LONGLONG Lock;              // offset: 0x0 ordinal: 0x9
    ULONGLONG LockNotUsed : 62; // offset: 0x0 ordinal: 0xa
  };
  ULONGLONG DeleteBit : 1; // offset: 0x0 ordinal: 0xb
  ULONGLONG LockBit : 1;   // offset: 0x0 ordinal: 0xc
} _MIPFNBLINK;

// 0x8 bytes (sizeof)
typedef union __anon_2116 {
  ULONGLONG PteFrame : 40;     // offset: 0x0 ordinal: 0x0
  ULONGLONG ResidentPage : 1;  // offset: 0x0 ordinal: 0x1
  ULONGLONG Unused1 : 1;       // offset: 0x0 ordinal: 0x2
  ULONGLONG Unused2 : 1;       // offset: 0x0 ordinal: 0x3
  ULONGLONG Partition : 10;    // offset: 0x0 ordinal: 0x4
  ULONGLONG FileOnly : 1;      // offset: 0x0 ordinal: 0x5
  ULONGLONG PfnExists : 1;     // offset: 0x0 ordinal: 0x6
  ULONGLONG NodeFlinkHigh : 5; // offset: 0x0 ordinal: 0x7
  ULONGLONG PageIdentity : 3;  // offset: 0x0 ordinal: 0x8
  ULONGLONG PrototypePte : 1;  // offset: 0x0 ordinal: 0x9
  ULONGLONG EntireField;       // offset: 0x0 ordinal: 0xa
} __anon_2116;

// 0x8 bytes (sizeof)
typedef struct __anon_2110 {
  ULONGLONG Tradable : 1;               // offset: 0x0 ordinal: 0x0
  ULONGLONG WsleAge : 3;                // offset: 0x0 ordinal: 0x1
  ULONGLONG OldestWsleLeafEntries : 10; // offset: 0x0 ordinal: 0x2
  ULONGLONG OldestWsleLeafAge : 3;      // offset: 0x0 ordinal: 0x3
  ULONGLONG NonPagedBuddy : 43;         // offset: 0x0 ordinal: 0x4
} __anon_2110;

// 0x8 bytes (sizeof)
typedef struct __anon_2109 {
  ULONGLONG Tradable : 1;       // offset: 0x0 ordinal: 0x0
  ULONGLONG NonPagedBuddy : 43; // offset: 0x0 ordinal: 0x1
} __anon_2109;

// 0x8 bytes (sizeof)
typedef struct _MI_ACTIVE_PFN {
  union {
    struct __anon_2109 Leaf;      // offset: 0x0 ordinal: 0x0
    struct __anon_2110 PageTable; // offset: 0x0 ordinal: 0x1
    ULONGLONG EntireActiveField;  // offset: 0x0 ordinal: 0x2
  };
} _MI_ACTIVE_PFN;

// 0x8 bytes (sizeof)
typedef union __anon_2107 {
  struct _SINGLE_LIST_ENTRY NextSlistPfn; // offset: 0x0 ordinal: 0x0
  VOID *Next;                             // offset: 0x0 ordinal: 0x1
  ULONGLONG Flink : 40;                   // offset: 0x0 ordinal: 0x2
  ULONGLONG NodeFlinkLow : 24;            // offset: 0x0 ordinal: 0x3
  struct _MI_ACTIVE_PFN Active;           // offset: 0x0 ordinal: 0x4
} __anon_2107;

// 0x8 bytes (sizeof)
typedef union wil_details_FeatureStateCache {
  ULONG exchange;                  // offset: 0x0 ordinal: 0x0
  ULONG stateCached : 1;           // offset: 0x0 ordinal: 0x1
  ULONG hasNotificationCached : 1; // offset: 0x0 ordinal: 0x2
  ULONG variantCached : 1;         // offset: 0x0 ordinal: 0x3
  ULONG effectiveState : 1;        // offset: 0x0 ordinal: 0x4
  ULONG desiredState : 1;          // offset: 0x0 ordinal: 0x5
  ULONG configuredState : 2;       // offset: 0x0 ordinal: 0x6
  ULONG needsRefresh : 1;          // offset: 0x0 ordinal: 0x7
  ULONG hasNotification : 1;       // offset: 0x0 ordinal: 0x8
  ULONG isWexpConfiguration : 1;   // offset: 0x0 ordinal: 0x9
  ULONG variant : 6;               // offset: 0x0 ordinal: 0xa
  ULONG unused : 16;               // offset: 0x0 ordinal: 0xb
  ULONG payloadId;                 // offset: 0x4 ordinal: 0xc
  ULONGLONG exchange64;            // offset: 0x0 ordinal: 0xd
} wil_details_FeatureStateCache;

// 0x30 bytes (sizeof)
typedef struct wil_details_FeatureDescriptor {
  union wil_details_FeatureStateCache
      *featureStateCache; // offset: 0x0 ordinal: 0x0
  struct wil_details_FeatureReportingCache
      *featureReportingCache; // offset: 0x8 ordinal: 0x1
  ULONG featureId;            // offset: 0x10 ordinal: 0x2
  UCHAR changeTime;           // offset: 0x14 ordinal: 0x3
  UCHAR isAlwaysDisabled;     // offset: 0x15 ordinal: 0x4
  UCHAR isAlwaysEnabled;      // offset: 0x16 ordinal: 0x5
  UCHAR isEnabledByDefault;   // offset: 0x17 ordinal: 0x6
  struct wil_details_FeatureDescriptor *
      *requiresFeatures;                          // offset: 0x18 ordinal: 0x7
  UCHAR variant;                                  // offset: 0x20 ordinal: 0x8
  enum wil_FeatureVariantPayloadKind payloadKind; // offset: 0x24 ordinal: 0x9
  ULONG payload;                                  // offset: 0x28 ordinal: 0xa
} wil_details_FeatureDescriptor;

// 0x8 bytes (sizeof)
typedef union __m64 {
  ULONGLONG m64_u64; // offset: 0x0 ordinal: 0x0
  float m64_f32[2];  // offset: 0x0 ordinal: 0x1
  CHAR m64_i8[8];    // offset: 0x0 ordinal: 0x2
  SHORT m64_i16[4];  // offset: 0x0 ordinal: 0x3
  LONG m64_i32[2];   // offset: 0x0 ordinal: 0x4
  LONGLONG m64_i64;  // offset: 0x0 ordinal: 0x5
  UCHAR m64_u8[8];   // offset: 0x0 ordinal: 0x6
  USHORT m64_u16[4]; // offset: 0x0 ordinal: 0x7
  ULONG m64_u32[2];  // offset: 0x0 ordinal: 0x8
} __m64;

// 0x10 bytes (sizeof)
typedef struct _EVENT_FILTER_DESCRIPTOR {
  ULONGLONG Ptr; // offset: 0x0 ordinal: 0x0
  ULONG Size;    // offset: 0x8 ordinal: 0x1
  ULONG Type;    // offset: 0xc ordinal: 0x2
} _EVENT_FILTER_DESCRIPTOR;

typedef VOID (*__anon_2058)(struct _GUID *, ULONG, UCHAR, ULONGLONG, ULONGLONG,
                            struct _EVENT_FILTER_DESCRIPTOR *, VOID *);

// 0x38 bytes (sizeof)
typedef struct _tlgProvider_t {
  ULONG LevelPlus1;            // offset: 0x0 ordinal: 0x0
  USHORT *ProviderMetadataPtr; // offset: 0x8 ordinal: 0x1
  ULONGLONG KeywordAny;        // offset: 0x10 ordinal: 0x2
  ULONGLONG KeywordAll;        // offset: 0x18 ordinal: 0x3
  ULONGLONG RegHandle;         // offset: 0x20 ordinal: 0x4
  VOID(*EnableCallback)
  (struct _GUID *, ULONG, UCHAR, ULONGLONG, ULONGLONG,
   struct _EVENT_FILTER_DESCRIPTOR *, VOID *); // offset: 0x28 ordinal: 0x5
  VOID *CallbackContext;                       // offset: 0x30 ordinal: 0x6
} _tlgProvider_t;

// 0x8 bytes (sizeof)
typedef struct _RTL_CHASH_ENTRY {
  ULONGLONG Key; // offset: 0x0 ordinal: 0x0
} _RTL_CHASH_ENTRY;

// 0x18 bytes (sizeof)
typedef struct _RTL_CHASH_TABLE {
  struct _RTL_CHASH_ENTRY *Table; // offset: 0x0 ordinal: 0x0
  ULONG EntrySizeShift;           // offset: 0x8 ordinal: 0x1
  ULONG EntryMax;                 // offset: 0xc ordinal: 0x2
  ULONG EntryCount;               // offset: 0x10 ordinal: 0x3
} _RTL_CHASH_TABLE;

// 0x10 bytes (sizeof)
typedef struct _RTL_HASH_ENTRY {
  struct _SINGLE_LIST_ENTRY BucketLink; // offset: 0x0 ordinal: 0x0
  ULONGLONG Key;                        // offset: 0x8 ordinal: 0x1
} _RTL_HASH_ENTRY;

// 0x70 bytes (sizeof)
typedef struct _POOL_LIMIT_TABLE_ENTRY {
  union {
    struct _RTL_HASH_ENTRY HashEntry; // offset: 0x0 ordinal: 0x0
    ULONGLONG Reserved;               // offset: 0x0 ordinal: 0x1
  };
  struct _SINGLE_LIST_ENTRY SListEntry;      // offset: 0x8 ordinal: 0x2
  struct _POOL_LIMIT_INFO LimitInfo[2];      // offset: 0x10 ordinal: 0x3
  struct _WNF_STATE_NAME NotificationObject; // offset: 0x40 ordinal: 0x4
  struct _SLIST_ENTRY NotificationEntry;     // offset: 0x50 ordinal: 0x5
  ULONG Scheduled;                           // offset: 0x60 ordinal: 0x6
} _POOL_LIMIT_TABLE_ENTRY;

// 0x50 bytes (sizeof)
typedef struct _POOL_TRACKER_TABLE {
  LONG Key;                                  // offset: 0x0 ordinal: 0x0
  ULONGLONG NonPagedBytes;                   // offset: 0x8 ordinal: 0x1
  ULONGLONG NonPagedAllocs;                  // offset: 0x10 ordinal: 0x2
  ULONGLONG NonPagedFrees;                   // offset: 0x18 ordinal: 0x3
  ULONGLONG PagedBytes;                      // offset: 0x20 ordinal: 0x4
  ULONGLONG PagedAllocs;                     // offset: 0x28 ordinal: 0x5
  ULONGLONG PagedFrees;                      // offset: 0x30 ordinal: 0x6
  LONGLONG AvailableLimit[2];                // offset: 0x38 ordinal: 0x7
  struct _POOL_LIMIT_TABLE_ENTRY *LimitInfo; // offset: 0x48 ordinal: 0x8
} _POOL_TRACKER_TABLE;

// 0x18 bytes (sizeof)
typedef struct _RTL_HASH_TABLE_ITERATOR {
  struct _RTL_HASH_TABLE *Hash;      // offset: 0x0 ordinal: 0x0
  struct _RTL_HASH_ENTRY *HashEntry; // offset: 0x8 ordinal: 0x1
  struct _SINGLE_LIST_ENTRY *Bucket; // offset: 0x10 ordinal: 0x2
} _RTL_HASH_TABLE_ITERATOR;

// 0x8 bytes (sizeof)
typedef struct _MM_PAGE_ACCESS_INFO {
  union {
    union _MM_PAGE_ACCESS_INFO_FLAGS Flags; // offset: 0x0 ordinal: 0x0
    ULONGLONG FileOffset;                   // offset: 0x0 ordinal: 0x1
    VOID *VirtualAddress;                   // offset: 0x0 ordinal: 0x2
    VOID *PointerProtoPte;                  // offset: 0x0 ordinal: 0x3
  };
} _MM_PAGE_ACCESS_INFO;

// 0x10 bytes (sizeof)
typedef struct _EVENT_HEADER_EXTENDED_DATA_ITEM {
  USHORT Reserved1;      // offset: 0x0 ordinal: 0x0
  USHORT ExtType;        // offset: 0x2 ordinal: 0x1
  USHORT Linkage : 1;    // offset: 0x4 ordinal: 0x2
  USHORT Reserved2 : 15; // offset: 0x4 ordinal: 0x3
  USHORT DataSize;       // offset: 0x6 ordinal: 0x4
  ULONGLONG DataPtr;     // offset: 0x8 ordinal: 0x5
} _EVENT_HEADER_EXTENDED_DATA_ITEM;

// 0x8 bytes (sizeof)
typedef struct _EX_FAST_REF {
  union {
    VOID *Object;         // offset: 0x0 ordinal: 0x0
    ULONGLONG RefCnt : 4; // offset: 0x0 ordinal: 0x1
  };
  ULONGLONG Value; // offset: 0x0 ordinal: 0x2
} _EX_FAST_REF;

// 0x10 bytes (sizeof)
typedef struct _IO_STATUS_BLOCK {
  union {
    LONG Status;   // offset: 0x0 ordinal: 0x0
    VOID *Pointer; // offset: 0x0 ordinal: 0x1
  };
  ULONGLONG Information; // offset: 0x8 ordinal: 0x2
} _IO_STATUS_BLOCK;

// 0x8 bytes (sizeof)
typedef union _ULARGE_INTEGER {
  ULONG LowPart;      // offset: 0x0 ordinal: 0x0
  ULONG HighPart;     // offset: 0x4 ordinal: 0x1
  struct __anon_26 u; // offset: 0x0 ordinal: 0x2
  ULONGLONG QuadPart; // offset: 0x0 ordinal: 0x3
} _ULARGE_INTEGER;

// 0x10 bytes (sizeof)
typedef struct __anon_1986 {
  ULONGLONG Pcid : 12;     // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved : 52; // offset: 0x0 ordinal: 0x1
  ULONGLONG EntirePcid;    // offset: 0x0 ordinal: 0x2
  ULONGLONG Reserved2;     // offset: 0x8 ordinal: 0x3
} __anon_1986;

// 0x10 bytes (sizeof)
typedef struct __anon_1985 {
  ULONGLONG Pcid : 12;     // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved : 52; // offset: 0x0 ordinal: 0x1
  ULONGLONG EntirePcid;    // offset: 0x0 ordinal: 0x2
  ULONGLONG Virtual;       // offset: 0x8 ordinal: 0x3
} __anon_1985;

// 0xf0 bytes (sizeof)
typedef struct _IMAGE_OPTIONAL_HEADER64 {
  USHORT Magic;                                   // offset: 0x0 ordinal: 0x0
  UCHAR MajorLinkerVersion;                       // offset: 0x2 ordinal: 0x1
  UCHAR MinorLinkerVersion;                       // offset: 0x3 ordinal: 0x2
  ULONG SizeOfCode;                               // offset: 0x4 ordinal: 0x3
  ULONG SizeOfInitializedData;                    // offset: 0x8 ordinal: 0x4
  ULONG SizeOfUninitializedData;                  // offset: 0xc ordinal: 0x5
  ULONG AddressOfEntryPoint;                      // offset: 0x10 ordinal: 0x6
  ULONG BaseOfCode;                               // offset: 0x14 ordinal: 0x7
  ULONGLONG ImageBase;                            // offset: 0x18 ordinal: 0x8
  ULONG SectionAlignment;                         // offset: 0x20 ordinal: 0x9
  ULONG FileAlignment;                            // offset: 0x24 ordinal: 0xa
  USHORT MajorOperatingSystemVersion;             // offset: 0x28 ordinal: 0xb
  USHORT MinorOperatingSystemVersion;             // offset: 0x2a ordinal: 0xc
  USHORT MajorImageVersion;                       // offset: 0x2c ordinal: 0xd
  USHORT MinorImageVersion;                       // offset: 0x2e ordinal: 0xe
  USHORT MajorSubsystemVersion;                   // offset: 0x30 ordinal: 0xf
  USHORT MinorSubsystemVersion;                   // offset: 0x32 ordinal: 0x10
  ULONG Win32VersionValue;                        // offset: 0x34 ordinal: 0x11
  ULONG SizeOfImage;                              // offset: 0x38 ordinal: 0x12
  ULONG SizeOfHeaders;                            // offset: 0x3c ordinal: 0x13
  ULONG CheckSum;                                 // offset: 0x40 ordinal: 0x14
  USHORT Subsystem;                               // offset: 0x44 ordinal: 0x15
  USHORT DllCharacteristics;                      // offset: 0x46 ordinal: 0x16
  ULONGLONG SizeOfStackReserve;                   // offset: 0x48 ordinal: 0x17
  ULONGLONG SizeOfStackCommit;                    // offset: 0x50 ordinal: 0x18
  ULONGLONG SizeOfHeapReserve;                    // offset: 0x58 ordinal: 0x19
  ULONGLONG SizeOfHeapCommit;                     // offset: 0x60 ordinal: 0x1a
  ULONG LoaderFlags;                              // offset: 0x68 ordinal: 0x1b
  ULONG NumberOfRvaAndSizes;                      // offset: 0x6c ordinal: 0x1c
  struct _IMAGE_DATA_DIRECTORY DataDirectory[16]; // offset: 0x70 ordinal: 0x1d
} _IMAGE_OPTIONAL_HEADER64;

// 0x108 bytes (sizeof)
typedef struct _IMAGE_NT_HEADERS64 {
  ULONG Signature;                                // offset: 0x0 ordinal: 0x0
  struct _IMAGE_FILE_HEADER FileHeader;           // offset: 0x4 ordinal: 0x1
  struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader; // offset: 0x18 ordinal: 0x2
} _IMAGE_NT_HEADERS64;

// 0x4e8 bytes (sizeof)
typedef struct _GDI_TEB_BATCH {
  ULONG Offset : 31;             // offset: 0x0 ordinal: 0x0
  ULONG HasRenderingCommand : 1; // offset: 0x0 ordinal: 0x1
  ULONGLONG HDC;                 // offset: 0x8 ordinal: 0x2
  ULONG Buffer[310];             // offset: 0x10 ordinal: 0x3
} _GDI_TEB_BATCH;

// 0x348 bytes (sizeof)
typedef struct _XSTATE_CONFIGURATION {
  ULONGLONG EnabledFeatures;         // offset: 0x0 ordinal: 0x0
  ULONGLONG EnabledVolatileFeatures; // offset: 0x8 ordinal: 0x1
  ULONG Size;                        // offset: 0x10 ordinal: 0x2
  union {
    ULONG ControlFlags;      // offset: 0x14 ordinal: 0x3
    ULONG OptimizedSave : 1; // offset: 0x14 ordinal: 0x4
  };
  ULONG CompactionEnabled : 1;                    // offset: 0x14 ordinal: 0x5
  ULONG ExtendedFeatureDisable : 1;               // offset: 0x14 ordinal: 0x6
  struct _XSTATE_FEATURE Features[64];            // offset: 0x18 ordinal: 0x7
  ULONGLONG EnabledSupervisorFeatures;            // offset: 0x218 ordinal: 0x8
  ULONGLONG AlignedFeatures;                      // offset: 0x220 ordinal: 0x9
  ULONG AllFeatureSize;                           // offset: 0x228 ordinal: 0xa
  ULONG AllFeatures[64];                          // offset: 0x22c ordinal: 0xb
  ULONGLONG EnabledUserVisibleSupervisorFeatures; // offset: 0x330 ordinal: 0xc
  ULONGLONG ExtendedFeatureDisableFeatures;       // offset: 0x338 ordinal: 0xd
  ULONG AllNonLargeFeatureSize;                   // offset: 0x340 ordinal: 0xe
  ULONG Spare;                                    // offset: 0x344 ordinal: 0xf
} _XSTATE_CONFIGURATION;

// 0x8 bytes (sizeof)
typedef union _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS {
  ULONGLONG ProcessorType : 1;      // offset: 0x0 ordinal: 0x0
  ULONGLONG InstructionSet : 1;     // offset: 0x0 ordinal: 0x1
  ULONGLONG ErrorType : 1;          // offset: 0x0 ordinal: 0x2
  ULONGLONG Operation : 1;          // offset: 0x0 ordinal: 0x3
  ULONGLONG Flags : 1;              // offset: 0x0 ordinal: 0x4
  ULONGLONG Level : 1;              // offset: 0x0 ordinal: 0x5
  ULONGLONG CPUVersion : 1;         // offset: 0x0 ordinal: 0x6
  ULONGLONG CPUBrandString : 1;     // offset: 0x0 ordinal: 0x7
  ULONGLONG ProcessorId : 1;        // offset: 0x0 ordinal: 0x8
  ULONGLONG TargetAddress : 1;      // offset: 0x0 ordinal: 0x9
  ULONGLONG RequesterId : 1;        // offset: 0x0 ordinal: 0xa
  ULONGLONG ResponderId : 1;        // offset: 0x0 ordinal: 0xb
  ULONGLONG InstructionPointer : 1; // offset: 0x0 ordinal: 0xc
  ULONGLONG NativeModelId : 1;      // offset: 0x0 ordinal: 0xd
  ULONGLONG Reserved : 50;          // offset: 0x0 ordinal: 0xe
  ULONGLONG ValidBits;              // offset: 0x0 ordinal: 0xf
} _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS;

// 0xc0 bytes (sizeof)
typedef struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION {
  union _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS
      ValidBits;                // offset: 0x0 ordinal: 0x0
  UCHAR ProcessorType;          // offset: 0x8 ordinal: 0x1
  UCHAR InstructionSet;         // offset: 0x9 ordinal: 0x2
  UCHAR ErrorType;              // offset: 0xa ordinal: 0x3
  UCHAR Operation;              // offset: 0xb ordinal: 0x4
  UCHAR Flags;                  // offset: 0xc ordinal: 0x5
  UCHAR Level;                  // offset: 0xd ordinal: 0x6
  USHORT Reserved;              // offset: 0xe ordinal: 0x7
  ULONGLONG CPUVersion;         // offset: 0x10 ordinal: 0x8
  UCHAR CPUBrandString[128];    // offset: 0x18 ordinal: 0x9
  ULONGLONG ProcessorId;        // offset: 0x98 ordinal: 0xa
  ULONGLONG TargetAddress;      // offset: 0xa0 ordinal: 0xb
  ULONGLONG RequesterId;        // offset: 0xa8 ordinal: 0xc
  ULONGLONG ResponderId;        // offset: 0xb0 ordinal: 0xd
  ULONGLONG InstructionPointer; // offset: 0xb8 ordinal: 0xe
} _WHEA_PROCESSOR_GENERIC_ERROR_SECTION;

typedef LONG (*__anon_3253)(struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR *,
                            struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION *);

// 0x18 bytes (sizeof)
typedef struct _GIC_DISTRIBUTOR {
  UCHAR Type;                          // offset: 0x0 ordinal: 0x0
  UCHAR Length;                        // offset: 0x1 ordinal: 0x1
  USHORT Reserved1;                    // offset: 0x2 ordinal: 0x2
  ULONG Identifier;                    // offset: 0x4 ordinal: 0x3
  ULONGLONG ControllerPhysicalAddress; // offset: 0x8 ordinal: 0x4
  ULONG GsivBase;                      // offset: 0x10 ordinal: 0x5
  UCHAR Version;                       // offset: 0x14 ordinal: 0x6
  UCHAR Reserved[3];                   // offset: 0x15 ordinal: 0x7
} _GIC_DISTRIBUTOR;

// 0x8 bytes (sizeof)
typedef struct __anon_1899 {
  ULONGLONG PmemErrInfo; // offset: 0x0 ordinal: 0x0
} __anon_1899;

// 0x10 bytes (sizeof)
typedef struct __anon_1898 {
  ULONGLONG Address;    // offset: 0x0 ordinal: 0x0
  UCHAR Consumed;       // offset: 0x8 ordinal: 0x1
  USHORT ErrorCode;     // offset: 0xa ordinal: 0x2
  UCHAR ErrorIpValid;   // offset: 0xc ordinal: 0x3
  UCHAR RestartIpValid; // offset: 0xd ordinal: 0x4
  UCHAR ClearPoison;    // offset: 0xe ordinal: 0x5
} __anon_1898;

// 0x58 bytes (sizeof)
typedef struct _HAL_HV_DMA_HYBRID_PASSTHROUGH_RESERVED_REGIONS {
  ULONGLONG UnitSizePages;            // offset: 0x0 ordinal: 0x0
  struct _RTL_BITMAP ReservedUnitMap; // offset: 0x8 ordinal: 0x1
  ULONG ReservedUnitMapBuffer[16];    // offset: 0x18 ordinal: 0x2
} _HAL_HV_DMA_HYBRID_PASSTHROUGH_RESERVED_REGIONS;

typedef LONG (*__anon_1883)(
    struct _HAL_HV_DMA_HYBRID_PASSTHROUGH_RESERVED_REGIONS *);

// 0x20 bytes (sizeof)
typedef struct _WHEA_RECOVERY_CONTEXT {
  union {
    struct __anon_1898 MemoryError; // offset: 0x0 ordinal: 0x0
    struct __anon_1899 PmemError;   // offset: 0x0 ordinal: 0x1
  };
  ULONGLONG PartitionId;                            // offset: 0x10 ordinal: 0x2
  ULONG VpIndex;                                    // offset: 0x18 ordinal: 0x3
  enum _WHEA_RECOVERY_CONTEXT_ERROR_TYPE ErrorType; // offset: 0x1c ordinal: 0x4
} _WHEA_RECOVERY_CONTEXT;

typedef LONG (*__anon_1850)(struct _WHEA_RECOVERY_CONTEXT *, UCHAR, UCHAR);

typedef LONG (*__anon_1872)(ULONGLONG, struct _HAL_HV_DMA_DOMAIN_INFO *);

typedef LONG (*__anon_1868)(ULONGLONG, ULONG, ULONG);

typedef LONG (*__anon_1864)(ULONGLONG, ULONG);

typedef LONG (*__anon_1863)(ULONGLONG, ULONG, ULONG, ULONG);

typedef LONG (*__anon_1861)(ULONG, ULONG, ULONGLONG);

typedef LONG (*__anon_1849)(ULONGLONG);

typedef LONG (*__anon_1843)(ULONG, ULONGLONG, UCHAR, VOID *);

typedef LONG (*__anon_1841)(ULONGLONG, VOID *);

typedef ULONGLONG (*__anon_1836)();

// 0x24 bytes (sizeof)
typedef struct _RSDP {
  ULONGLONG Signature;              // offset: 0x0 ordinal: 0x0
  UCHAR Checksum;                   // offset: 0x8 ordinal: 0x1
  UCHAR OEMID[6];                   // offset: 0x9 ordinal: 0x2
  UCHAR Revision;                   // offset: 0xf ordinal: 0x3
  ULONG RsdtAddress;                // offset: 0x10 ordinal: 0x4
  ULONG Length;                     // offset: 0x14 ordinal: 0x5
  union _LARGE_INTEGER XsdtAddress; // offset: 0x18 ordinal: 0x6
  UCHAR XChecksum;                  // offset: 0x20 ordinal: 0x7
  UCHAR Reserved[3];                // offset: 0x21 ordinal: 0x8
} _RSDP;

// 0x8 bytes (sizeof)
typedef union __anon_1775 {
  ULONGLONG NumberOfEntries : 10; // offset: 0x0 ordinal: 0x0
  ULONGLONG PageSize : 2;         // offset: 0x0 ordinal: 0x1
  VOID *Va;                       // offset: 0x0 ordinal: 0x2
  ULONGLONG VaLong;               // offset: 0x0 ordinal: 0x3
} __anon_1775;

// 0x8 bytes (sizeof)
typedef struct _KTB_FLUSH_VA {
  union __anon_1775 u1; // offset: 0x0 ordinal: 0x0
} _KTB_FLUSH_VA;

typedef VOID (*__anon_3434)(VOID *, ULONG, struct _KTB_FLUSH_VA *);

typedef LONG (*__anon_1882)(struct _HAL_HV_DMA_DOMAIN_INFO *, ULONG,
                            struct _KTB_FLUSH_VA *);

typedef VOID (*__anon_1862)(ULONG, ULONG, ULONG, struct _KTB_FLUSH_VA *);

typedef VOID (*__anon_1712)(VOID *, ULONG, VOID *, struct _LIST_ENTRY *, ULONG,
                            struct _KTB_FLUSH_VA *);

// 0x10 bytes (sizeof)
typedef struct __anon_1773 {
  ULONG Status;              // offset: 0x0 ordinal: 0x0
  ULONGLONG PhysicalAddress; // offset: 0x8 ordinal: 0x1
} __anon_1773;

// 0x8 bytes (sizeof)
typedef struct __anon_1770 {
  ULONGLONG BroadcastTlbMaintenance : 1; // offset: 0x0 ordinal: 0x0
} __anon_1770;

// 0x18 bytes (sizeof)
typedef struct _EXT_IOMMU_SETTINGS {
  struct __anon_1770 EnabledCapabilities; // offset: 0x0 ordinal: 0x0
  enum _EXT_IOMMU_ADDRESS_TRANSLATION_POLICY
      TranslationPolicy; // offset: 0x8 ordinal: 0x1
  enum _EXT_IOMMU_INTERRUPT_REMAPPING_POLICY
      RemappingPolicy;         // offset: 0xc ordinal: 0x2
  ULONG RemappingTableEntries; // offset: 0x10 ordinal: 0x3
} _EXT_IOMMU_SETTINGS;

typedef LONG (*__anon_1692)(struct _EXT_IOMMU *, struct _EXT_IOMMU_SETTINGS *);

// 0x8 bytes (sizeof)
typedef struct _EXT_IOMMU_OUTPUT_MAPPING {
  ULONGLONG OutputId; // offset: 0x0 ordinal: 0x0
} _EXT_IOMMU_OUTPUT_MAPPING;

typedef LONG (*__anon_1759)(struct _IOMMU_DMA_LOGICAL_ALLOCATOR *, ULONGLONG,
                            ULONGLONG);

typedef LONG (*__anon_1758)(struct _IOMMU_DMA_LOGICAL_ALLOCATOR *, ULONGLONG);

// 0x10 bytes (sizeof)
typedef struct __anon_1754 {
  UCHAR PageTableRootLevel; // offset: 0x0 ordinal: 0x0
  UCHAR InputSize;          // offset: 0x1 ordinal: 0x1
  ULONGLONG PageTableRoot;  // offset: 0x8 ordinal: 0x2
} __anon_1754;

// 0x20 bytes (sizeof)
typedef struct _EXT_IOMMU_DOMAIN_SETTINGS {
  struct _EXT_IOMMU_S1_X64_DOMAIN_SETTINGS S1; // offset: 0x0 ordinal: 0x0
  struct __anon_1754 S2;                       // offset: 0x10 ordinal: 0x1
} _EXT_IOMMU_DOMAIN_SETTINGS;

// 0x10 bytes (sizeof)
typedef struct __anon_1738 {
  ULONGLONG Offset; // offset: 0x0 ordinal: 0x0
  ULONG Length;     // offset: 0x8 ordinal: 0x1
} __anon_1738;

// 0x50 bytes (sizeof)
typedef struct _DMA_ADAPTER_INFO_CRASHDUMP {
  struct _DEVICE_DESCRIPTION DeviceDescription; // offset: 0x0 ordinal: 0x0
  ULONGLONG DeviceIdSize;                       // offset: 0x40 ordinal: 0x1
  VOID *DeviceId;                               // offset: 0x48 ordinal: 0x2
} _DMA_ADAPTER_INFO_CRASHDUMP;

// 0x58 bytes (sizeof)
typedef struct _DMA_ADAPTER_INFO {
  ULONG Version; // offset: 0x0 ordinal: 0x0
  union {
    struct _DMA_ADAPTER_INFO_V1 V1;               // offset: 0x8 ordinal: 0x1
    struct _DMA_ADAPTER_INFO_CRASHDUMP Crashdump; // offset: 0x8 ordinal: 0x2
  };
} _DMA_ADAPTER_INFO;

typedef LONG (*__anon_1594)(struct _DMA_ADAPTER *, struct _DMA_ADAPTER_INFO *);

// 0x20 bytes (sizeof)
typedef struct _EXT_ENV_SPINLOCK {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  ULONGLONG Lock;               // offset: 0x10 ordinal: 0x1
  UCHAR OldIrql;                // offset: 0x18 ordinal: 0x2
} _EXT_ENV_SPINLOCK;

// 0x70 bytes (sizeof)
typedef struct _EXT_IOMMU_DOMAIN {
  enum _EXT_IOMMU_DOMAIN_TYPE DomainType;           // offset: 0x0 ordinal: 0x0
  enum _EXT_IOMMU_TRANSLATION_TYPE TranslationType; // offset: 0x4 ordinal: 0x1
  struct __anon_1728 Flags;                         // offset: 0x8 ordinal: 0x2
  USHORT FirmwareDomainId;                          // offset: 0xa ordinal: 0x3
  struct _EXT_IOMMU_DOMAIN_SETTINGS Settings;       // offset: 0x10 ordinal: 0x4
  ULONG ContextId;                                  // offset: 0x30 ordinal: 0x5
  ULONG DeviceCount;                                // offset: 0x34 ordinal: 0x6
  struct _LIST_ENTRY Devices;                       // offset: 0x38 ordinal: 0x7
  struct _EXT_ENV_SPINLOCK Lock;                    // offset: 0x48 ordinal: 0x8
  struct _EXT_IOMMU_DOMAIN *S2Domain;               // offset: 0x68 ordinal: 0x9
} _EXT_IOMMU_DOMAIN;

// 0x8 bytes (sizeof)
typedef union _EXT_IOMMU_CAPABILITIES {
  ULONGLONG AsUINT64;                            // offset: 0x0 ordinal: 0x0
  ULONGLONG GeneratesMsiInterrupts : 1;          // offset: 0x0 ordinal: 0x1
  ULONGLONG CoherentTableWalks : 1;              // offset: 0x0 ordinal: 0x2
  ULONGLONG InterruptsNotSubjectToRemapping : 1; // offset: 0x0 ordinal: 0x3
  ULONGLONG InterruptRemapping : 1;              // offset: 0x0 ordinal: 0x4
  ULONGLONG Stage2DmaRemapping : 1;              // offset: 0x0 ordinal: 0x5
  ULONGLONG Svm : 1;                             // offset: 0x0 ordinal: 0x6
  ULONGLONG PcieFunctionBased : 1;               // offset: 0x0 ordinal: 0x7
} _EXT_IOMMU_CAPABILITIES;

typedef VOID (*__anon_1714)(VOID *, ULONG, ULONGLONG, USHORT, LONG);

typedef VOID (*__anon_1713)(VOID *, ULONGLONG, ULONG);

typedef LONG (*__anon_1711)(VOID *, struct _IOMMU_PASID_TABLE_OBJECT *, ULONG,
                            ULONGLONG, UCHAR *);

typedef VOID (*__anon_1709)(VOID *, ULONGLONG,
                            struct _IOMMU_PASID_TABLE_OBJECT *);

typedef LONG (*__anon_1708)(VOID *, ULONGLONG, UCHAR);

// 0x50 bytes (sizeof)
typedef struct _DMA_COMMON_BUFFER_VECTOR {
  struct _LIST_ENTRY ListEntry;             // offset: 0x0 ordinal: 0x0
  ULONGLONG SizeOfEntries;                  // offset: 0x10 ordinal: 0x1
  ULONG NumberOfEntries;                    // offset: 0x18 ordinal: 0x2
  struct _HALP_DMA_DOMAIN_OBJECT *Domain;   // offset: 0x20 ordinal: 0x3
  struct _MDL *Mdl;                         // offset: 0x28 ordinal: 0x4
  VOID *BaseAddress;                        // offset: 0x30 ordinal: 0x5
  ULONGLONG BaseLogicalAddress;             // offset: 0x38 ordinal: 0x6
  struct _DMA_COMMON_BUFFER_ENTRY *Entries; // offset: 0x40 ordinal: 0x7
  UCHAR LogicalAddressMapped;               // offset: 0x48 ordinal: 0x8
} _DMA_COMMON_BUFFER_VECTOR;

typedef VOID (*__anon_1614)(struct _DMA_ADAPTER *,
                            struct _DMA_COMMON_BUFFER_VECTOR *);

typedef VOID (*__anon_1613)(struct _DMA_ADAPTER *,
                            struct _DMA_COMMON_BUFFER_VECTOR *, ULONG);

typedef VOID (*__anon_1612)(struct _DMA_ADAPTER *,
                            struct _DMA_COMMON_BUFFER_VECTOR *, ULONG, VOID **,
                            union _LARGE_INTEGER *);

typedef LONG (*__anon_1611)(struct _DMA_ADAPTER *, union _LARGE_INTEGER,
                            union _LARGE_INTEGER, enum _MEMORY_CACHING_TYPE,
                            ULONG, ULONG, ULONG, ULONGLONG,
                            struct _DMA_COMMON_BUFFER_VECTOR **);

typedef LONG (*__anon_1604)(struct _DMA_ADAPTER *, struct _MDL *, VOID *,
                            ULONGLONG, ULONG, UCHAR);

typedef LONG (*__anon_1595)(struct _DMA_ADAPTER *, struct _MDL *, ULONGLONG,
                            ULONG, UCHAR, struct _DMA_TRANSFER_INFO *);

// 0x28 bytes (sizeof)
typedef struct _EXT_IOMMU_DEVICE {
  VOID *Context;                    // offset: 0x0 ordinal: 0x0
  struct _EXT_IOMMU *Iommu;         // offset: 0x8 ordinal: 0x1
  struct _EXT_IOMMU_DOMAIN *Domain; // offset: 0x10 ordinal: 0x2
  ULONGLONG AssociatedDomainId;     // offset: 0x18 ordinal: 0x3
  USHORT FirmwareDomainId;          // offset: 0x20 ordinal: 0x4
  UCHAR FaultReportingEnabled;      // offset: 0x22 ordinal: 0x5
} _EXT_IOMMU_DEVICE;

typedef LONG (*__anon_1700)(struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE *,
                            struct _EXT_IOMMU_DOMAIN *, VOID *);

typedef VOID (*__anon_1699)(struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE *,
                            UCHAR);

typedef VOID (*__anon_1697)(struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE *,
                            VOID *);

// 0x8 bytes (sizeof)
typedef struct __anon_1558 {
  ULONGLONG BoundToMaster : 1;      // offset: 0x0 ordinal: 0x0
  ULONGLONG BoundToScatterPool : 1; // offset: 0x0 ordinal: 0x1
  ULONGLONG OwnedByMaster : 1;      // offset: 0x0 ordinal: 0x2
  ULONGLONG OwnedByScatterPool : 1; // offset: 0x0 ordinal: 0x3
  ULONGLONG TemporaryMapping : 1;   // offset: 0x0 ordinal: 0x4
  ULONGLONG ZeroBuffer : 1;         // offset: 0x0 ordinal: 0x5
  ULONGLONG Address : 58;           // offset: 0x0 ordinal: 0x6
} __anon_1558;

// 0x8 bytes (sizeof)
typedef union __anon_1506 {
  VOID *VirtualAddress;     // offset: 0x0 ordinal: 0x0
  struct __anon_1558 Flags; // offset: 0x0 ordinal: 0x1
} __anon_1506;

// 0x28 bytes (sizeof)
typedef struct _FAULT_INFORMATION_X64 {
  VOID *DomainHandle;                        // offset: 0x0 ordinal: 0x0
  VOID *FaultAddress;                        // offset: 0x8 ordinal: 0x1
  struct _FAULT_INFORMATION_X64_FLAGS Flags; // offset: 0x10 ordinal: 0x2
  enum _FAULT_INFORMATION_ARM64_TYPE Type;   // offset: 0x14 ordinal: 0x3
  ULONGLONG IommuBaseAddress;                // offset: 0x18 ordinal: 0x4
  ULONG PciSegment;                          // offset: 0x20 ordinal: 0x5
} _FAULT_INFORMATION_X64;

// 0x30 bytes (sizeof)
typedef struct _FAULT_INFORMATION_ARM64 {
  VOID *DomainHandle;                          // offset: 0x0 ordinal: 0x0
  VOID *FaultAddress;                          // offset: 0x8 ordinal: 0x1
  struct _DEVICE_OBJECT *PhysicalDeviceObject; // offset: 0x10 ordinal: 0x2
  ULONG InputMappingId;                        // offset: 0x18 ordinal: 0x3
  struct _FAULT_INFORMATION_ARM64_FLAGS Flags; // offset: 0x1c ordinal: 0x4
  enum _FAULT_INFORMATION_ARM64_TYPE Type;     // offset: 0x20 ordinal: 0x5
  ULONGLONG IommuBaseAddress;                  // offset: 0x28 ordinal: 0x6
} _FAULT_INFORMATION_ARM64;

// 0x38 bytes (sizeof)
typedef struct _FAULT_INFORMATION {
  enum _FAULT_INFORMATION_ARCH Type; // offset: 0x0 ordinal: 0x0
  UCHAR IsStage1;                    // offset: 0x4 ordinal: 0x1
  union {
    struct _FAULT_INFORMATION_ARM64 Arm64; // offset: 0x8 ordinal: 0x2
    struct _FAULT_INFORMATION_X64 X64;     // offset: 0x8 ordinal: 0x3
  };
} _FAULT_INFORMATION;

typedef VOID (*__anon_3304)(ULONGLONG, struct _FAULT_INFORMATION *);

typedef VOID (*__anon_1519)(VOID *, struct _FAULT_INFORMATION *);

// 0x10 bytes (sizeof)
typedef struct _DEVICE_FAULT_CONFIGURATION {
  VOID(*FaultHandler)
  (VOID *, struct _FAULT_INFORMATION *); // offset: 0x0 ordinal: 0x0
  VOID *FaultContext;                    // offset: 0x8 ordinal: 0x1
} _DEVICE_FAULT_CONFIGURATION;

typedef LONG (*__anon_3451)(struct _DEVICE_OBJECT *, ULONG, UCHAR,
                            struct _DEVICE_FAULT_CONFIGURATION *);

// 0x40 bytes (sizeof)
typedef struct _IOMMU_DMA_DOMAIN {
  struct _HALP_DMA_DOMAIN_OBJECT *DmaDomainOwner;   // offset: 0x0 ordinal: 0x0
  enum _IOMMU_DMA_DOMAIN_TYPE DomainType;           // offset: 0x8 ordinal: 0x1
  enum _EXT_IOMMU_TRANSLATION_TYPE TranslationType; // offset: 0xc ordinal: 0x2
  struct _LIST_ENTRY HardwareDomainListHead;        // offset: 0x10 ordinal: 0x3
  ULONGLONG HardwareDomainListLock;                 // offset: 0x20 ordinal: 0x4
  struct _DMAR_PAGE_TABLE_STATE *DmarptState;       // offset: 0x28 ordinal: 0x5
  ULONG DomainId;                                   // offset: 0x30 ordinal: 0x6
  UCHAR IsStage1;                                   // offset: 0x34 ordinal: 0x7
  USHORT Asid;                                      // offset: 0x36 ordinal: 0x8
  struct _IOMMU_DMA_LOGICAL_ALLOCATOR
      *LogicalAllocator; // offset: 0x38 ordinal: 0x9
} _IOMMU_DMA_DOMAIN;

typedef LONG (*__anon_3504)(enum _IOMMU_DMA_DOMAIN_TYPE,
                            union _IOMMU_DMA_DOMAIN_CREATION_FLAGS,
                            struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG *,
                            struct _IOMMU_DMA_RESERVED_REGION *,
                            struct _IOMMU_DMA_DOMAIN **);

typedef LONG (*__anon_3441)(UCHAR, struct _IOMMU_DMA_DOMAIN **);

typedef LONG (*__anon_3452)(struct _IOMMU_DMA_DOMAIN *,
                            struct _DOMAIN_CONFIGURATION *);

typedef LONG (*__anon_3450)(struct _IOMMU_DMA_DOMAIN *, struct _MDL *);

typedef LONG (*__anon_3449)(struct _IOMMU_DMA_DOMAIN *, ULONG, struct _MDL *);

typedef LONG (*__anon_3448)(struct _IOMMU_DMA_DOMAIN *, ULONGLONG, ULONGLONG);

typedef LONG (*__anon_3447)(struct _IOMMU_DMA_DOMAIN *, ULONG, struct _MDL *,
                            ULONGLONG);

typedef LONG (*__anon_3445)(struct _IOMMU_DMA_DOMAIN *, UCHAR, ULONG, VOID *);

typedef LONG (*__anon_3444)(struct _IOMMU_DMA_DOMAIN *, struct _DEVICE_OBJECT *,
                            ULONG);

typedef LONG (*__anon_3443)(struct _IOMMU_DMA_DOMAIN *, struct _DEVICE_OBJECT *,
                            ULONG, ULONG);

typedef LONG (*__anon_3442)(struct _IOMMU_DMA_DOMAIN *);

// 0x68 bytes (sizeof)
typedef struct _DMA_IOMMU_INTERFACE_V1 {
  LONG(*CreateDomain)
  (UCHAR, struct _IOMMU_DMA_DOMAIN **);             // offset: 0x0 ordinal: 0x0
  LONG (*DeleteDomain)(struct _IOMMU_DMA_DOMAIN *); // offset: 0x8 ordinal: 0x1
  LONG(*AttachDevice)
  (struct _IOMMU_DMA_DOMAIN *, struct _DEVICE_OBJECT *, ULONG,
   ULONG); // offset: 0x10 ordinal: 0x2
  LONG(*DetachDevice)
  (struct _IOMMU_DMA_DOMAIN *, struct _DEVICE_OBJECT *,
   ULONG);                                         // offset: 0x18 ordinal: 0x3
  LONG (*FlushDomain)(struct _IOMMU_DMA_DOMAIN *); // offset: 0x20 ordinal: 0x4
  LONG(*FlushDomainByVaList)
  (struct _IOMMU_DMA_DOMAIN *, UCHAR, ULONG,
   VOID *); // offset: 0x28 ordinal: 0x5
  LONG(*QueryInputMappings)
  (struct _DEVICE_OBJECT *, struct _INPUT_MAPPING_ELEMENT *, ULONG,
   ULONG *); // offset: 0x30 ordinal: 0x6
  LONG(*MapLogicalRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONG, struct _MDL *,
   ULONGLONG); // offset: 0x38 ordinal: 0x7
  LONG(*UnmapLogicalRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONGLONG,
   ULONGLONG); // offset: 0x40 ordinal: 0x8
  LONG(*MapIdentityRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONG,
   struct _MDL *); // offset: 0x48 ordinal: 0x9
  LONG(*UnmapIdentityRange)
  (struct _IOMMU_DMA_DOMAIN *, struct _MDL *); // offset: 0x50 ordinal: 0xa
  LONG(*SetDeviceFaultReporting)
  (struct _DEVICE_OBJECT *, ULONG, UCHAR,
   struct _DEVICE_FAULT_CONFIGURATION *); // offset: 0x58 ordinal: 0xb
  LONG(*ConfigureDomain)
  (struct _IOMMU_DMA_DOMAIN *,
   struct _DOMAIN_CONFIGURATION *); // offset: 0x60 ordinal: 0xc
} _DMA_IOMMU_INTERFACE_V1;

// 0x70 bytes (sizeof)
typedef struct _DMA_IOMMU_INTERFACE {
  ULONG Version; // offset: 0x0 ordinal: 0x0
  LONG(*CreateDomain)
  (UCHAR, struct _IOMMU_DMA_DOMAIN **);             // offset: 0x8 ordinal: 0x1
  LONG (*DeleteDomain)(struct _IOMMU_DMA_DOMAIN *); // offset: 0x10 ordinal: 0x2
  LONG(*AttachDevice)
  (struct _IOMMU_DMA_DOMAIN *, struct _DEVICE_OBJECT *, ULONG,
   ULONG); // offset: 0x18 ordinal: 0x3
  LONG(*DetachDevice)
  (struct _IOMMU_DMA_DOMAIN *, struct _DEVICE_OBJECT *,
   ULONG);                                         // offset: 0x20 ordinal: 0x4
  LONG (*FlushDomain)(struct _IOMMU_DMA_DOMAIN *); // offset: 0x28 ordinal: 0x5
  LONG(*FlushDomainByVaList)
  (struct _IOMMU_DMA_DOMAIN *, UCHAR, ULONG,
   VOID *); // offset: 0x30 ordinal: 0x6
  LONG(*QueryInputMappings)
  (struct _DEVICE_OBJECT *, struct _INPUT_MAPPING_ELEMENT *, ULONG,
   ULONG *); // offset: 0x38 ordinal: 0x7
  LONG(*MapLogicalRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONG, struct _MDL *,
   ULONGLONG); // offset: 0x40 ordinal: 0x8
  LONG(*UnmapLogicalRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONGLONG,
   ULONGLONG); // offset: 0x48 ordinal: 0x9
  LONG(*MapIdentityRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONG,
   struct _MDL *); // offset: 0x50 ordinal: 0xa
  LONG(*UnmapIdentityRange)
  (struct _IOMMU_DMA_DOMAIN *, struct _MDL *); // offset: 0x58 ordinal: 0xb
  LONG(*SetDeviceFaultReporting)
  (struct _DEVICE_OBJECT *, ULONG, UCHAR,
   struct _DEVICE_FAULT_CONFIGURATION *); // offset: 0x60 ordinal: 0xc
  LONG(*ConfigureDomain)
  (struct _IOMMU_DMA_DOMAIN *,
   struct _DOMAIN_CONFIGURATION *); // offset: 0x68 ordinal: 0xd
} _DMA_IOMMU_INTERFACE;

typedef LONG (*__anon_3300)(ULONG, struct _DMA_IOMMU_INTERFACE *);

// 0x18 bytes (sizeof)
typedef struct _SCATTER_GATHER_ELEMENT {
  union _LARGE_INTEGER Address; // offset: 0x0 ordinal: 0x0
  ULONG Length;                 // offset: 0x8 ordinal: 0x1
  ULONGLONG Reserved;           // offset: 0x10 ordinal: 0x2
} _SCATTER_GATHER_ELEMENT;

// 0x10 bytes (sizeof)
typedef struct _DMA_SCATTER_GATHER_LIST {
  ULONG NumberOfElements;                     // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved;                         // offset: 0x8 ordinal: 0x1
  struct _SCATTER_GATHER_ELEMENT Elements[0]; // offset: 0x10 ordinal: 0x2
} _DMA_SCATTER_GATHER_LIST;

typedef VOID (*__anon_1562)(VOID *, ULONG, ULONG,
                            struct _DMA_SCATTER_GATHER_LIST *,
                            union _LARGE_INTEGER, UCHAR, UCHAR);

// 0x50 bytes (sizeof)
typedef struct _DMA_FUNCTION_TABLE {
  VOID (*InitializeController)(VOID *); // offset: 0x0 ordinal: 0x0
  UCHAR(*ValidateRequestLineBinding)
  (VOID *,
   struct _DMA_REQUEST_LINE_BINDING_DESCRIPTION *); // offset: 0x8 ordinal: 0x1
  ULONG (*QueryMaxFragments)(VOID *, ULONG, ULONG); // offset: 0x10 ordinal: 0x2
  VOID(*ProgramChannel)
  (VOID *, ULONG, ULONG, struct _DMA_SCATTER_GATHER_LIST *,
   union _LARGE_INTEGER, UCHAR, UCHAR); // offset: 0x18 ordinal: 0x3
  LONG(*ConfigureChannel)
  (VOID *, ULONG, ULONG, VOID *);      // offset: 0x20 ordinal: 0x4
  VOID (*FlushChannel)(VOID *, ULONG); // offset: 0x28 ordinal: 0x5
  UCHAR(*HandleInterrupt)
  (VOID *, ULONG *, enum _DMA_INTERRUPT_TYPE *); // offset: 0x30 ordinal: 0x6
  ULONG (*ReadDmaCounter)(VOID *, ULONG);        // offset: 0x38 ordinal: 0x7
  VOID(*ReportCommonBuffer)
  (VOID *, ULONG, VOID *, union _LARGE_INTEGER); // offset: 0x40 ordinal: 0x8
  UCHAR (*CancelTransfer)(VOID *, ULONG);        // offset: 0x48 ordinal: 0x9
} _DMA_FUNCTION_TABLE;

// 0x8 bytes (sizeof)
typedef struct __anon_1497 {
  ULONGLONG LogicalId; // offset: 0x0 ordinal: 0x0
} __anon_1497;

// 0x8 bytes (sizeof)
typedef struct _EXT_IOMMU_DEVICE_ID_TEST {
  ULONGLONG UniqueId; // offset: 0x0 ordinal: 0x0
} _EXT_IOMMU_DEVICE_ID_TEST;

// 0x10 bytes (sizeof)
typedef struct _EXT_IOMMU_DEVICE_ID_PCI {
  union {
    ULONGLONG AsUINT64;      // offset: 0x0 ordinal: 0x0
    USHORT PciSegmentNumber; // offset: 0x0 ordinal: 0x1
  };
  USHORT PhantomFunctionBits : 2; // offset: 0x2 ordinal: 0x2
  USHORT Reserved : 6;            // offset: 0x2 ordinal: 0x3
  USHORT StartBusNumber : 8;      // offset: 0x2 ordinal: 0x4
  USHORT Bdf;                     // offset: 0x4 ordinal: 0x5
  USHORT DevicePathLength;        // offset: 0x6 ordinal: 0x6
  USHORT *DevicePath;             // offset: 0x8 ordinal: 0x7
} _EXT_IOMMU_DEVICE_ID_PCI;

// 0x10 bytes (sizeof)
typedef struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN {
  ULONGLONG LogicalAddressBase; // offset: 0x0 ordinal: 0x0
  ULONGLONG Size;               // offset: 0x8 ordinal: 0x1
} _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN;

typedef LONG (*__anon_3514)(struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN *);

// 0x18 bytes (sizeof)
typedef struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT {
  struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN
      *OwningToken; // offset: 0x0 ordinal: 0x0
  ULONGLONG Offset; // offset: 0x8 ordinal: 0x1
  ULONGLONG Size;   // offset: 0x10 ordinal: 0x2
} _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT;

typedef LONG (*__anon_3516)(
    struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT *);

// 0x48 bytes (sizeof)
typedef struct _HALP_DMA_TRANSLATION_ENTRY {
  ULONGLONG PhysicalAddress;                // offset: 0x0 ordinal: 0x0
  struct _HALP_DMA_TRANSLATION_ENTRY *Next; // offset: 0x8 ordinal: 0x1
  ULONG MappedLength;                       // offset: 0x10 ordinal: 0x2
  struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT
      RemappingAddress;                            // offset: 0x18 ordinal: 0x3
  union __anon_1506 u;                             // offset: 0x30 ordinal: 0x4
  struct _HALP_DMA_TRANSLATION_ENTRY *NextMapping; // offset: 0x38 ordinal: 0x5
  UCHAR LogicalBounceBufferPremapped;              // offset: 0x40 ordinal: 0x6
} _HALP_DMA_TRANSLATION_ENTRY;

// 0x18 bytes (sizeof)
typedef struct _EXT_IOMMU_DEVICE_ID {
  enum _EXT_IOMMU_DEVICE_TYPE DeviceType; // offset: 0x0 ordinal: 0x0
  union _EXT_IOMMU_DEVICE_ID_FLAGS Flags; // offset: 0x4 ordinal: 0x1
  union {
    struct _EXT_IOMMU_DEVICE_ID_PCI Pci;   // offset: 0x8 ordinal: 0x2
    struct _EXT_IOMMU_DEVICE_ID_ACPI Acpi; // offset: 0x8 ordinal: 0x3
    UCHAR IoApicId;                        // offset: 0x8 ordinal: 0x4
    ULONGLONG LogicalId;                   // offset: 0x8 ordinal: 0x5
    struct _EXT_IOMMU_DEVICE_ID_TEST Test; // offset: 0x8 ordinal: 0x6
    struct _EXT_IOMMU_DEVICE_ID_GIC Gic;   // offset: 0x8 ordinal: 0x7
  };
} _EXT_IOMMU_DEVICE_ID;

typedef LONG (*__anon_3440)(struct _EXT_IOMMU_DEVICE_ID *, UCHAR *);

typedef LONG (*__anon_3439)(struct _EXT_IOMMU_DEVICE_ID *,
                            struct _DEVICE_OBJECT *,
                            union _IOMMU_SVM_CAPABILITIES *, VOID **);

typedef LONG (*__anon_3438)(struct _EXT_IOMMU_DEVICE_ID *,
                            union _IOMMU_ATS_SETTINGS *);

typedef LONG (*__anon_3432)(VOID *, struct _EXT_IOMMU_DEVICE_ID *,
                            struct _DEVICE_OBJECT *,
                            union _IOMMU_SVM_CAPABILITIES *, VOID **);

// 0xb8 bytes (sizeof)
typedef struct _HAL_IOMMU_DISPATCH {
  UCHAR (*HalIommuSupportEnabled)(); // offset: 0x0 ordinal: 0x0
  LONG(*HalIommuGetConfiguration)
  (ULONG, ULONG *, ULONG *, VOID **); // offset: 0x8 ordinal: 0x1
  LONG(*HalIommuGetLibraryContext)
  (ULONG, ULONG, VOID **); // offset: 0x10 ordinal: 0x2
  LONG(*HalIommuMapDevice)
  (VOID *, struct _EXT_IOMMU_DEVICE_ID *, struct _DEVICE_OBJECT *,
   union _IOMMU_SVM_CAPABILITIES *, VOID **); // offset: 0x18 ordinal: 0x3
  LONG(*HalIommuEnableDevicePasid)
  (VOID *, VOID *); // offset: 0x20 ordinal: 0x4
  LONG(*HalIommuSetAddressSpace)
  (VOID *, ULONGLONG); // offset: 0x28 ordinal: 0x5
  LONG(*HalIommuDisableDevicePasid)
  (VOID *, VOID *);                            // offset: 0x30 ordinal: 0x6
  LONG (*HalIommuUnmapDevice)(VOID *, VOID *); // offset: 0x38 ordinal: 0x7
  LONG (*HalIommuFreeLibraryContext)(VOID *);  // offset: 0x40 ordinal: 0x8
  VOID(*HalIommuFlushTb)
  (VOID *, ULONG, struct _KTB_FLUSH_VA *); // offset: 0x48 ordinal: 0x9
  VOID(*HalIommuFlushAllPasid)
  (VOID *, ULONG, struct _KTB_FLUSH_VA *);         // offset: 0x50 ordinal: 0xa
  UCHAR (*HalIommuProcessPageRequestQueue)(ULONG); // offset: 0x58 ordinal: 0xb
  VOID (*HalIommuFaultRoutine)(ULONG);             // offset: 0x60 ordinal: 0xc
  VOID *(*HalIommuReferenceAsid)(ULONG);           // offset: 0x68 ordinal: 0xd
  VOID (*HalIommuDereferenceAsid)(ULONG);          // offset: 0x70 ordinal: 0xe
  LONG(*HalIommuServicePageFault)
  (ULONGLONG, VOID *, ULONG); // offset: 0x78 ordinal: 0xf
  LONG(*HalIommuDevicePowerChange)
  (VOID *, VOID *, UCHAR); // offset: 0x80 ordinal: 0x10
  LONG(*HalIommuBeginDeviceReset)
  (VOID *, ULONG *);                           // offset: 0x88 ordinal: 0x11
  LONG (*HalIommuFinalizeDeviceReset)(VOID *); // offset: 0x90 ordinal: 0x12
  LONG(*HalIommuGetAtsSettings)
  (struct _EXT_IOMMU_DEVICE_ID *,
   union _IOMMU_ATS_SETTINGS *); // offset: 0x98 ordinal: 0x13
  LONG(*HalIommuCreateAtsDevice)
  (struct _EXT_IOMMU_DEVICE_ID *, struct _DEVICE_OBJECT *,
   union _IOMMU_SVM_CAPABILITIES *, VOID **); // offset: 0xa0 ordinal: 0x14
  VOID (*HalIommuDeleteAtsDevice)(VOID *);    // offset: 0xa8 ordinal: 0x15
  LONG(*HalIommuGetDomainTransitionSupport)
  (struct _EXT_IOMMU_DEVICE_ID *, UCHAR *); // offset: 0xb0 ordinal: 0x16
} _HAL_IOMMU_DISPATCH;

typedef VOID (*__anon_3286)(struct _HAL_IOMMU_DISPATCH *);

typedef UCHAR (*__anon_3305)(struct _EXT_IOMMU_DEVICE_ID *, ULONG *);

typedef LONG (*__anon_1870)(struct _EXT_IOMMU_DEVICE_ID *, ULONGLONG);

typedef LONG (*__anon_1867)(struct _EXT_IOMMU_DEVICE_ID *, UCHAR);

typedef LONG (*__anon_1859)(struct _EXT_IOMMU_DEVICE_ID *, VOID *);

// 0x38 bytes (sizeof)
typedef struct _IOMMU_RESERVED_DEVICE {
  struct _EXT_IOMMU_DEVICE_ID *DeviceId;  // offset: 0x0 ordinal: 0x0
  VOID *PageTable;                        // offset: 0x8 ordinal: 0x1
  union _LARGE_INTEGER PageTablePhysical; // offset: 0x10 ordinal: 0x2
  ULONG RegionCount;                      // offset: 0x18 ordinal: 0x3
  struct _EXT_IOMMU_RESERVED_MEMORY_REGION
      Regions[1]; // offset: 0x20 ordinal: 0x4
} _IOMMU_RESERVED_DEVICE;

typedef LONG (*__anon_1720)(VOID *, ULONG, struct _IOMMU_RESERVED_DEVICE **);

typedef LONG (*__anon_1719)(VOID *, ULONG *, struct _IOMMU_RESERVED_DEVICE **);

// 0x10 bytes (sizeof)
typedef struct _IOMMU_RESERVED_DEVICE_LIST {
  ULONG Count;                               // offset: 0x0 ordinal: 0x0
  struct _IOMMU_RESERVED_DEVICE *Devices[1]; // offset: 0x8 ordinal: 0x1
} _IOMMU_RESERVED_DEVICE_LIST;

typedef ULONG (*__anon_1722)(VOID *, struct _EXT_IOMMU_DEVICE_ID *);

typedef LONG (*__anon_1721)(VOID *, struct _EXT_IOMMU_DEVICE_ID *,
                            struct _EXT_IOMMU_DEVICE_ID *);

typedef UCHAR (*__anon_1717)(struct _EXT_IOMMU_DEVICE_ID *);

typedef UCHAR (*__anon_1707)(VOID *, struct _EXT_IOMMU_DEVICE_ID *, UCHAR,
                             struct _EXT_IOMMU_OUTPUT_MAPPING *);

typedef LONG (*__anon_1703)(VOID *, ULONG, ULONG, ULONG, USHORT, UCHAR, UCHAR,
                            ULONG, struct _EXT_IOMMU_DEVICE_ID *);

typedef UCHAR (*__anon_1698)(struct _EXT_IOMMU *,
                             struct _EXT_IOMMU_DEVICE_ID *);

typedef LONG (*__anon_1696)(struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE_ID *,
                            union _EXT_IOMMU_CREATE_DEVICE_FLAGS, VOID *,
                            struct _EXT_IOMMU_DEVICE **, VOID *);

// 0x10 bytes (sizeof)
typedef struct _SCATTER_GATHER_LIST {
  ULONG NumberOfElements;                     // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved;                         // offset: 0x8 ordinal: 0x1
  struct _SCATTER_GATHER_ELEMENT Elements[0]; // offset: 0x10 ordinal: 0x2
} _SCATTER_GATHER_LIST;

typedef VOID (*__anon_1686)(struct _DEVICE_OBJECT *, struct _IRP *,
                            struct _SCATTER_GATHER_LIST *, VOID *);

typedef LONG (*__anon_1603)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *,
                            VOID *, struct _MDL *, ULONGLONG, ULONG, ULONG,
                            VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                     struct _SCATTER_GATHER_LIST *, VOID *),
                            VOID *, UCHAR, VOID *, ULONG,
                            VOID (*)(struct _DMA_ADAPTER *,
                                     struct _DEVICE_OBJECT *, VOID *,
                                     enum DMA_COMPLETION_STATUS),
                            VOID *, VOID *);

typedef LONG (*__anon_1592)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *,
                            struct _MDL *, VOID *, ULONG,
                            VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                     struct _SCATTER_GATHER_LIST *, VOID *),
                            VOID *, UCHAR, VOID *, ULONG);

typedef LONG (*__anon_1589)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *,
                            struct _MDL *, VOID *, ULONG,
                            VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                     struct _SCATTER_GATHER_LIST *, VOID *),
                            VOID *, UCHAR);

typedef LONG (*__anon_1602)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *,
                            VOID *, struct _MDL *, ULONGLONG, ULONG, ULONG,
                            VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                     struct _SCATTER_GATHER_LIST *, VOID *),
                            VOID *, UCHAR,
                            VOID (*)(struct _DMA_ADAPTER *,
                                     struct _DEVICE_OBJECT *, VOID *,
                                     enum DMA_COMPLETION_STATUS),
                            VOID *, struct _SCATTER_GATHER_LIST **);

typedef LONG (*__anon_1601)(struct _DMA_ADAPTER *, struct _MDL *, VOID *,
                            ULONGLONG, ULONG, ULONG *, UCHAR,
                            struct _SCATTER_GATHER_LIST *, ULONG,
                            VOID (*)(struct _DMA_ADAPTER *,
                                     struct _DEVICE_OBJECT *, VOID *,
                                     enum DMA_COMPLETION_STATUS),
                            VOID *);

typedef LONG (*__anon_1593)(struct _DMA_ADAPTER *,
                            struct _SCATTER_GATHER_LIST *, struct _MDL *,
                            struct _MDL **);

typedef VOID (*__anon_1590)(struct _DMA_ADAPTER *,
                            struct _SCATTER_GATHER_LIST *, UCHAR);

// 0xa0 bytes (sizeof)
typedef struct _HALP_DMA_ADAPTER_OBJECT {
  struct _DMA_ADAPTER DmaHeader;              // offset: 0x0 ordinal: 0x0
  ULONG Signature;                            // offset: 0x10 ordinal: 0x1
  struct _RTL_BITMAP *ContiguousMapRegisters; // offset: 0x18 ordinal: 0x2
  struct _HALP_DMA_TRANSLATION_ENTRY
      *ScatterBufferListHead;       // offset: 0x20 ordinal: 0x3
  ULONG NumberOfFreeScatterBuffers; // offset: 0x28 ordinal: 0x4
  struct _HALP_DMA_TRANSLATION_BUFFER
      *ContiguousTranslations; // offset: 0x30 ordinal: 0x5
  struct _HALP_DMA_TRANSLATION_BUFFER
      *ScatterTranslations; // offset: 0x38 ordinal: 0x6
  struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
      ContiguousTranslationEnd; // offset: 0x40 ordinal: 0x7
  struct _HALP_DMA_TRANSLATION_BUFFER_POSITION
      ScatterTranslationEnd;                   // offset: 0x50 ordinal: 0x8
  struct __anon_1473 CrashDump;                // offset: 0x60 ordinal: 0x9
  ULONGLONG SpinLock;                          // offset: 0x80 ordinal: 0xa
  ULONGLONG GrowLock;                          // offset: 0x88 ordinal: 0xb
  union _LARGE_INTEGER MaximumPhysicalAddress; // offset: 0x90 ordinal: 0xc
  UCHAR IsMasterAdapter;                       // offset: 0x98 ordinal: 0xd
  UCHAR DmaCanCross64K;                        // offset: 0x99 ordinal: 0xe
  ULONG LibraryVersion;                        // offset: 0x9c ordinal: 0xf
} _HALP_DMA_ADAPTER_OBJECT;

// 0xe0 bytes (sizeof)
typedef struct _HALP_DMA_MASTER_ADAPTER_OBJECT {
  struct _HALP_DMA_ADAPTER_OBJECT AdapterObject; // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY ContiguousAdapterQueue;     // offset: 0xa0 ordinal: 0x1
  struct _LIST_ENTRY ScatterAdapterQueue;        // offset: 0xb0 ordinal: 0x2
  ULONG MapBufferSize;                           // offset: 0xc0 ordinal: 0x3
  union _LARGE_INTEGER MapBufferPhysicalAddress; // offset: 0xc8 ordinal: 0x4
  ULONG ContiguousPageCount;                     // offset: 0xd0 ordinal: 0x5
  ULONG ContiguousPageLimit;                     // offset: 0xd4 ordinal: 0x6
  ULONG ScatterPageCount;                        // offset: 0xd8 ordinal: 0x7
  ULONG ScatterPageLimit;                        // offset: 0xdc ordinal: 0x8
} _HALP_DMA_MASTER_ADAPTER_OBJECT;

// 0x50 bytes (sizeof)
typedef struct _PROCLOCALGIC {
  UCHAR Type;                          // offset: 0x0 ordinal: 0x0
  UCHAR Length;                        // offset: 0x1 ordinal: 0x1
  USHORT Reserved;                     // offset: 0x2 ordinal: 0x2
  ULONG Identifier;                    // offset: 0x4 ordinal: 0x3
  ULONG AcpiProcessorId;               // offset: 0x8 ordinal: 0x4
  ULONG Flags;                         // offset: 0xc ordinal: 0x5
  ULONG ParkingProtocolVersion;        // offset: 0x10 ordinal: 0x6
  ULONG PerformanceInterruptGsi;       // offset: 0x14 ordinal: 0x7
  ULONGLONG ParkedPhysicalAddress;     // offset: 0x18 ordinal: 0x8
  ULONGLONG ControllerPhysicalAddress; // offset: 0x20 ordinal: 0x9
  ULONGLONG Gicv;                      // offset: 0x28 ordinal: 0xa
  ULONGLONG Gich;                      // offset: 0x30 ordinal: 0xb
  ULONG VgicMaintenanceInterrupt;      // offset: 0x38 ordinal: 0xc
  ULONGLONG GicrBaseAddress;           // offset: 0x3c ordinal: 0xd
  ULONGLONG Mpidr;                     // offset: 0x44 ordinal: 0xe
  UCHAR ProcessorPowerEfficiencyClass; // offset: 0x4c ordinal: 0xf
  UCHAR Reserved2[3];                  // offset: 0x4d ordinal: 0x10
} _PROCLOCALGIC;

// 0x114 bytes (sizeof)
typedef struct _FADT {
  struct _DESCRIPTION_HEADER Header;    // offset: 0x0 ordinal: 0x0
  ULONG facs;                           // offset: 0x24 ordinal: 0x1
  ULONG dsdt;                           // offset: 0x28 ordinal: 0x2
  UCHAR int_model;                      // offset: 0x2c ordinal: 0x3
  UCHAR pm_profile;                     // offset: 0x2d ordinal: 0x4
  USHORT sci_int_vector;                // offset: 0x2e ordinal: 0x5
  ULONG smi_cmd_io_port;                // offset: 0x30 ordinal: 0x6
  UCHAR acpi_on_value;                  // offset: 0x34 ordinal: 0x7
  UCHAR acpi_off_value;                 // offset: 0x35 ordinal: 0x8
  UCHAR s4bios_req;                     // offset: 0x36 ordinal: 0x9
  UCHAR pstate_control;                 // offset: 0x37 ordinal: 0xa
  ULONG pm1a_evt_blk_io_port;           // offset: 0x38 ordinal: 0xb
  ULONG pm1b_evt_blk_io_port;           // offset: 0x3c ordinal: 0xc
  ULONG pm1a_ctrl_blk_io_port;          // offset: 0x40 ordinal: 0xd
  ULONG pm1b_ctrl_blk_io_port;          // offset: 0x44 ordinal: 0xe
  ULONG pm2_ctrl_blk_io_port;           // offset: 0x48 ordinal: 0xf
  ULONG pm_tmr_blk_io_port;             // offset: 0x4c ordinal: 0x10
  ULONG gp0_blk_io_port;                // offset: 0x50 ordinal: 0x11
  ULONG gp1_blk_io_port;                // offset: 0x54 ordinal: 0x12
  UCHAR pm1_evt_len;                    // offset: 0x58 ordinal: 0x13
  UCHAR pm1_ctrl_len;                   // offset: 0x59 ordinal: 0x14
  UCHAR pm2_ctrl_len;                   // offset: 0x5a ordinal: 0x15
  UCHAR pm_tmr_len;                     // offset: 0x5b ordinal: 0x16
  UCHAR gp0_blk_len;                    // offset: 0x5c ordinal: 0x17
  UCHAR gp1_blk_len;                    // offset: 0x5d ordinal: 0x18
  UCHAR gp1_base;                       // offset: 0x5e ordinal: 0x19
  UCHAR cstate_control;                 // offset: 0x5f ordinal: 0x1a
  USHORT lvl2_latency;                  // offset: 0x60 ordinal: 0x1b
  USHORT lvl3_latency;                  // offset: 0x62 ordinal: 0x1c
  USHORT flush_size;                    // offset: 0x64 ordinal: 0x1d
  USHORT flush_stride;                  // offset: 0x66 ordinal: 0x1e
  UCHAR duty_offset;                    // offset: 0x68 ordinal: 0x1f
  UCHAR duty_width;                     // offset: 0x69 ordinal: 0x20
  UCHAR day_alarm_index;                // offset: 0x6a ordinal: 0x21
  UCHAR month_alarm_index;              // offset: 0x6b ordinal: 0x22
  UCHAR century_alarm_index;            // offset: 0x6c ordinal: 0x23
  USHORT boot_arch;                     // offset: 0x6d ordinal: 0x24
  UCHAR reserved3[1];                   // offset: 0x6f ordinal: 0x25
  ULONG flags;                          // offset: 0x70 ordinal: 0x26
  struct _GEN_ADDR reset_reg;           // offset: 0x74 ordinal: 0x27
  UCHAR reset_val;                      // offset: 0x80 ordinal: 0x28
  USHORT arm_boot_arch;                 // offset: 0x81 ordinal: 0x29
  UCHAR minor_version_number;           // offset: 0x83 ordinal: 0x2a
  union _LARGE_INTEGER x_firmware_ctrl; // offset: 0x84 ordinal: 0x2b
  union _LARGE_INTEGER x_dsdt;          // offset: 0x8c ordinal: 0x2c
  struct _GEN_ADDR x_pm1a_evt_blk;      // offset: 0x94 ordinal: 0x2d
  struct _GEN_ADDR x_pm1b_evt_blk;      // offset: 0xa0 ordinal: 0x2e
  struct _GEN_ADDR x_pm1a_ctrl_blk;     // offset: 0xac ordinal: 0x2f
  struct _GEN_ADDR x_pm1b_ctrl_blk;     // offset: 0xb8 ordinal: 0x30
  struct _GEN_ADDR x_pm2_ctrl_blk;      // offset: 0xc4 ordinal: 0x31
  struct _GEN_ADDR x_pm_tmr_blk;        // offset: 0xd0 ordinal: 0x32
  struct _GEN_ADDR x_gp0_blk;           // offset: 0xdc ordinal: 0x33
  struct _GEN_ADDR x_gp1_blk;           // offset: 0xe8 ordinal: 0x34
  struct _GEN_ADDR sleep_control_reg;   // offset: 0xf4 ordinal: 0x35
  struct _GEN_ADDR sleep_status_reg;    // offset: 0x100 ordinal: 0x36
  ULONGLONG hypervisor_vendor_identity; // offset: 0x10c ordinal: 0x37
} _FADT;

// 0x10 bytes (sizeof)
typedef struct _IOSAPIC {
  UCHAR Type;               // offset: 0x0 ordinal: 0x0
  UCHAR Length;             // offset: 0x1 ordinal: 0x1
  UCHAR IOSAPICID;          // offset: 0x2 ordinal: 0x2
  UCHAR Reserved;           // offset: 0x3 ordinal: 0x3
  ULONG SystemVectorBase;   // offset: 0x4 ordinal: 0x4
  ULONGLONG IOSAPICAddress; // offset: 0x8 ordinal: 0x5
} _IOSAPIC;

// 0x8 bytes (sizeof)
typedef struct _MCI_STATUS_INTEL_BITS {
  ULONGLONG McaErrorCode : 16;        // offset: 0x0 ordinal: 0x0
  ULONGLONG ModelErrorCode : 16;      // offset: 0x0 ordinal: 0x1
  ULONGLONG OtherInfo : 5;            // offset: 0x0 ordinal: 0x2
  ULONGLONG FirmwareUpdateError : 1;  // offset: 0x0 ordinal: 0x3
  ULONGLONG CorrectedErrorCount : 15; // offset: 0x0 ordinal: 0x4
  ULONGLONG ThresholdErrorStatus : 2; // offset: 0x0 ordinal: 0x5
  ULONGLONG ActionRequired : 1;       // offset: 0x0 ordinal: 0x6
  ULONGLONG Signalling : 1;           // offset: 0x0 ordinal: 0x7
  ULONGLONG ContextCorrupt : 1;       // offset: 0x0 ordinal: 0x8
  ULONGLONG AddressValid : 1;         // offset: 0x0 ordinal: 0x9
  ULONGLONG MiscValid : 1;            // offset: 0x0 ordinal: 0xa
  ULONGLONG ErrorEnabled : 1;         // offset: 0x0 ordinal: 0xb
  ULONGLONG UncorrectedError : 1;     // offset: 0x0 ordinal: 0xc
  ULONGLONG StatusOverFlow : 1;       // offset: 0x0 ordinal: 0xd
  ULONGLONG Valid : 1;                // offset: 0x0 ordinal: 0xe
} _MCI_STATUS_INTEL_BITS;

// 0x8 bytes (sizeof)
typedef struct _MCI_STATUS_AMD_BITS {
  ULONGLONG McaErrorCode : 16;            // offset: 0x0 ordinal: 0x0
  ULONGLONG ModelErrorCode : 16;          // offset: 0x0 ordinal: 0x1
  ULONGLONG ImplementationSpecific2 : 11; // offset: 0x0 ordinal: 0x2
  ULONGLONG Poison : 1;                   // offset: 0x0 ordinal: 0x3
  ULONGLONG Deferred : 1;                 // offset: 0x0 ordinal: 0x4
  ULONGLONG ImplementationSpecific1 : 12; // offset: 0x0 ordinal: 0x5
  ULONGLONG ContextCorrupt : 1;           // offset: 0x0 ordinal: 0x6
  ULONGLONG AddressValid : 1;             // offset: 0x0 ordinal: 0x7
  ULONGLONG MiscValid : 1;                // offset: 0x0 ordinal: 0x8
  ULONGLONG ErrorEnabled : 1;             // offset: 0x0 ordinal: 0x9
  ULONGLONG UncorrectedError : 1;         // offset: 0x0 ordinal: 0xa
  ULONGLONG StatusOverFlow : 1;           // offset: 0x0 ordinal: 0xb
  ULONGLONG Valid : 1;                    // offset: 0x0 ordinal: 0xc
} _MCI_STATUS_AMD_BITS;

// 0x8 bytes (sizeof)
typedef struct _MCI_STATUS_BITS_COMMON {
  ULONGLONG McaErrorCode : 16;    // offset: 0x0 ordinal: 0x0
  ULONGLONG ModelErrorCode : 16;  // offset: 0x0 ordinal: 0x1
  ULONGLONG Reserved : 25;        // offset: 0x0 ordinal: 0x2
  ULONGLONG ContextCorrupt : 1;   // offset: 0x0 ordinal: 0x3
  ULONGLONG AddressValid : 1;     // offset: 0x0 ordinal: 0x4
  ULONGLONG MiscValid : 1;        // offset: 0x0 ordinal: 0x5
  ULONGLONG ErrorEnabled : 1;     // offset: 0x0 ordinal: 0x6
  ULONGLONG UncorrectedError : 1; // offset: 0x0 ordinal: 0x7
  ULONGLONG StatusOverFlow : 1;   // offset: 0x0 ordinal: 0x8
  ULONGLONG Valid : 1;            // offset: 0x0 ordinal: 0x9
} _MCI_STATUS_BITS_COMMON;

// 0x8 bytes (sizeof)
typedef union _MCG_CAP {
  ULONGLONG CountField : 8;                     // offset: 0x0 ordinal: 0x0
  ULONGLONG ControlMsrPresent : 1;              // offset: 0x0 ordinal: 0x1
  ULONGLONG ExtendedMsrsPresent : 1;            // offset: 0x0 ordinal: 0x2
  ULONGLONG SignalingExtensionPresent : 1;      // offset: 0x0 ordinal: 0x3
  ULONGLONG ThresholdErrorStatusPresent : 1;    // offset: 0x0 ordinal: 0x4
  ULONGLONG Reserved : 4;                       // offset: 0x0 ordinal: 0x5
  ULONGLONG ExtendedRegisterCount : 8;          // offset: 0x0 ordinal: 0x6
  ULONGLONG SoftwareErrorRecoverySupported : 1; // offset: 0x0 ordinal: 0x7
  ULONGLONG EnhancedMachineCheckCapability : 1; // offset: 0x0 ordinal: 0x8
  ULONGLONG ExtendedErrorLogging : 1;           // offset: 0x0 ordinal: 0x9
  ULONGLONG LocalMachineCheckException : 1;     // offset: 0x0 ordinal: 0xa
  ULONGLONG QuadPart;                           // offset: 0x0 ordinal: 0xb
} _MCG_CAP;

// 0xc0 bytes (sizeof)
typedef struct _WHEA_AMD_EXTENDED_REGISTERS {
  ULONGLONG IPID;         // offset: 0x0 ordinal: 0x0
  ULONGLONG SYND;         // offset: 0x8 ordinal: 0x1
  ULONGLONG CONFIG;       // offset: 0x10 ordinal: 0x2
  ULONGLONG DESTAT;       // offset: 0x18 ordinal: 0x3
  ULONGLONG DEADDR;       // offset: 0x20 ordinal: 0x4
  ULONGLONG MISC1;        // offset: 0x28 ordinal: 0x5
  ULONGLONG MISC2;        // offset: 0x30 ordinal: 0x6
  ULONGLONG MISC3;        // offset: 0x38 ordinal: 0x7
  ULONGLONG MISC4;        // offset: 0x40 ordinal: 0x8
  ULONGLONG RasCap;       // offset: 0x48 ordinal: 0x9
  ULONGLONG Reserved[14]; // offset: 0x50 ordinal: 0xa
} _WHEA_AMD_EXTENDED_REGISTERS;

// 0x8 bytes (sizeof)
typedef union _MCI_STATUS {
  struct _MCI_STATUS_BITS_COMMON CommonBits; // offset: 0x0 ordinal: 0x0
  struct _MCI_STATUS_AMD_BITS AmdBits;       // offset: 0x0 ordinal: 0x1
  struct _MCI_STATUS_INTEL_BITS IntelBits;   // offset: 0x0 ordinal: 0x2
  ULONGLONG QuadPart;                        // offset: 0x0 ordinal: 0x3
} _MCI_STATUS;

// 0x8 bytes (sizeof)
typedef union _MCG_STATUS {
  ULONG RestartIpValid : 1;         // offset: 0x0 ordinal: 0x0
  ULONG ErrorIpValid : 1;           // offset: 0x0 ordinal: 0x1
  ULONG MachineCheckInProgress : 1; // offset: 0x0 ordinal: 0x2
  ULONG LocalMceValid : 1;          // offset: 0x0 ordinal: 0x3
  ULONG Reserved1 : 28;             // offset: 0x0 ordinal: 0x4
  ULONG Reserved2;                  // offset: 0x4 ordinal: 0x5
  ULONGLONG QuadPart;               // offset: 0x0 ordinal: 0x6
} _MCG_STATUS;

// 0x124 bytes (sizeof)
typedef struct _WHEA_XPF_MCA_SECTION {
  ULONG VersionNumber;             // offset: 0x0 ordinal: 0x0
  enum _WHEA_CPU_VENDOR CpuVendor; // offset: 0x4 ordinal: 0x1
  union _LARGE_INTEGER Timestamp;  // offset: 0x8 ordinal: 0x2
  ULONG ProcessorNumber;           // offset: 0x10 ordinal: 0x3
  union _MCG_STATUS GlobalStatus;  // offset: 0x14 ordinal: 0x4
  ULONGLONG InstructionPointer;    // offset: 0x1c ordinal: 0x5
  ULONG BankNumber;                // offset: 0x24 ordinal: 0x6
  union _MCI_STATUS Status;        // offset: 0x28 ordinal: 0x7
  ULONGLONG Address;               // offset: 0x30 ordinal: 0x8
  ULONGLONG Misc;                  // offset: 0x38 ordinal: 0x9
  ULONG ExtendedRegisterCount;     // offset: 0x40 ordinal: 0xa
  ULONG ApicId;                    // offset: 0x44 ordinal: 0xb
  union {
    ULONGLONG ExtendedRegisters[24]; // offset: 0x48 ordinal: 0xc
    struct _WHEA_AMD_EXTENDED_REGISTERS
        AMDExtendedRegisters; // offset: 0x48 ordinal: 0xd
  };
  union _MCG_CAP GlobalCapability;        // offset: 0x108 ordinal: 0xe
  struct _XPF_RECOVERY_INFO RecoveryInfo; // offset: 0x110 ordinal: 0xf
} _WHEA_XPF_MCA_SECTION;

// 0x10 bytes (sizeof)
typedef struct _GIC_REDISTRIBUTOR {
  UCHAR Type;                          // offset: 0x0 ordinal: 0x0
  UCHAR Length;                        // offset: 0x1 ordinal: 0x1
  USHORT Reserved;                     // offset: 0x2 ordinal: 0x2
  ULONGLONG DiscoveryRangeBaseAddress; // offset: 0x4 ordinal: 0x3
  ULONG DiscoveryRangeLength;          // offset: 0xc ordinal: 0x4
} _GIC_REDISTRIBUTOR;

// 0x14 bytes (sizeof)
typedef struct _GIC_ITS {
  UCHAR Type;                // offset: 0x0 ordinal: 0x0
  UCHAR Length;              // offset: 0x1 ordinal: 0x1
  USHORT Reserved1;          // offset: 0x2 ordinal: 0x2
  ULONG Identifier;          // offset: 0x4 ordinal: 0x3
  ULONGLONG PhysicalAddress; // offset: 0x8 ordinal: 0x4
  ULONG Reserved2;           // offset: 0x10 ordinal: 0x5
} _GIC_ITS;

// 0x10 bytes (sizeof)
typedef struct __anon_1420 {
  ULONG Low32;             // offset: 0x0 ordinal: 0x0
  ULONG High32;            // offset: 0x4 ordinal: 0x1
  ULONGLONG InterruptData; // offset: 0x8 ordinal: 0x2
} __anon_1420;

// 0x18 bytes (sizeof)
typedef struct _INTERRUPT_TARGET {
  enum _INTERRUPT_TARGET_TYPE Target; // offset: 0x0 ordinal: 0x0
  union {
    ULONG PhysicalTarget;    // offset: 0x8 ordinal: 0x1
    ULONG LogicalFlatTarget; // offset: 0x8 ordinal: 0x2
    ULONG RemapIndex;        // offset: 0x8 ordinal: 0x3
    ULONG ClusterId;         // offset: 0x8 ordinal: 0x4
  };
  ULONG ClusterMask;                   // offset: 0xc ordinal: 0x5
  struct __anon_1420 HypervisorTarget; // offset: 0x8 ordinal: 0x6
} _INTERRUPT_TARGET;

// 0x38 bytes (sizeof)
typedef struct _INTERRUPT_LINE_STATE {
  enum _KINTERRUPT_POLARITY Polarity;       // offset: 0x0 ordinal: 0x0
  UCHAR EmulateActiveBoth;                  // offset: 0x4 ordinal: 0x1
  enum _KINTERRUPT_MODE TriggerMode;        // offset: 0x8 ordinal: 0x2
  ULONG Flags;                              // offset: 0xc ordinal: 0x3
  struct _INTERRUPT_LINE Routing;           // offset: 0x10 ordinal: 0x4
  struct _INTERRUPT_TARGET ProcessorTarget; // offset: 0x18 ordinal: 0x5
  ULONG Vector;                             // offset: 0x30 ordinal: 0x6
  ULONG Priority;                           // offset: 0x34 ordinal: 0x7
} _INTERRUPT_LINE_STATE;

// 0x58 bytes (sizeof)
typedef struct _INTERRUPT_LINES {
  struct _LIST_ENTRY ListEntry;         // offset: 0x0 ordinal: 0x0
  ULONG ControllerId;                   // offset: 0x10 ordinal: 0x1
  LONG MinLine;                         // offset: 0x14 ordinal: 0x2
  LONG MaxLine;                         // offset: 0x18 ordinal: 0x3
  ULONG GsiBase;                        // offset: 0x1c ordinal: 0x4
  enum _INTERRUPT_LINE_TYPE Type;       // offset: 0x20 ordinal: 0x5
  enum _INTERRUPT_LINE_SUBTYPE SubType; // offset: 0x24 ordinal: 0x6
  struct _INTERRUPT_LINE_STATE *State;  // offset: 0x28 ordinal: 0x7
  struct _INTERRUPT_LINE_INTERNAL_STATE
      *InternalState;          // offset: 0x30 ordinal: 0x8
  ULONGLONG MsiAddress;        // offset: 0x38 ordinal: 0x9
  ULONG MsiData;               // offset: 0x40 ordinal: 0xa
  struct _RTL_BITMAP MsiInUse; // offset: 0x48 ordinal: 0xb
} _INTERRUPT_LINES;

typedef UCHAR (*__anon_1705)(VOID *, UCHAR, ULONG,
                             struct _INTERRUPT_LINE_STATE *);

typedef LONG (*__anon_1403)(VOID *, struct _INTERRUPT_LINE *,
                            struct _INTERRUPT_LINE_STATE *);

typedef LONG (*__anon_1407)(VOID *, ULONG *, struct _INTERRUPT_TARGET *, UCHAR);

typedef LONG (*__anon_1404)(VOID *, struct _INTERRUPT_LINE *,
                            struct _INTERRUPT_TARGET *, ULONG,
                            struct _INTERRUPT_LINE *);

typedef LONG (*__anon_1401)(VOID *, struct _INTERRUPT_TARGET *);

// 0x30 bytes (sizeof)
typedef struct _IO_APIC_DATA {
  ULONGLONG PhysicalAddress;              // offset: 0x0 ordinal: 0x0
  ULONG Identifier;                       // offset: 0x8 ordinal: 0x1
  struct _IO_APIC_REGISTERS *BaseAddress; // offset: 0x10 ordinal: 0x2
  UCHAR Version;                          // offset: 0x18 ordinal: 0x3
  UCHAR PinCount;                         // offset: 0x19 ordinal: 0x4
  UCHAR Initialized;                      // offset: 0x1a ordinal: 0x5
  UCHAR InitializedFirstLocalUnit;        // offset: 0x1b ordinal: 0x6
  ULONG GsiBase;                          // offset: 0x1c ordinal: 0x7
  ULONG CmciRegister;                     // offset: 0x20 ordinal: 0x8
  ULONG DeferredErrorRegister;            // offset: 0x24 ordinal: 0x9
  UCHAR IoUnitMissing;                    // offset: 0x28 ordinal: 0xa
} _IO_APIC_DATA;

// 0x18 bytes (sizeof)
typedef struct _GIC_MSIFRAME_ENTRY {
  UCHAR Type;                // offset: 0x0 ordinal: 0x0
  UCHAR Length;              // offset: 0x1 ordinal: 0x1
  USHORT Reserved1;          // offset: 0x2 ordinal: 0x2
  ULONG Identifier;          // offset: 0x4 ordinal: 0x3
  ULONGLONG PhysicalAddress; // offset: 0x8 ordinal: 0x4
  ULONG Flags;               // offset: 0x10 ordinal: 0x5
  USHORT SpiCount;           // offset: 0x14 ordinal: 0x6
  USHORT SpiBase;            // offset: 0x16 ordinal: 0x7
} _GIC_MSIFRAME_ENTRY;

// 0x8 bytes (sizeof)
typedef union _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS {
  ULONGLONG LocalAPICId : 1;      // offset: 0x0 ordinal: 0x0
  ULONGLONG CpuId : 1;            // offset: 0x0 ordinal: 0x1
  ULONGLONG ProcInfoCount : 6;    // offset: 0x0 ordinal: 0x2
  ULONGLONG ContextInfoCount : 6; // offset: 0x0 ordinal: 0x3
  ULONGLONG Reserved : 50;        // offset: 0x0 ordinal: 0x4
  ULONGLONG ValidBits;            // offset: 0x0 ordinal: 0x5
} _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS;

// 0x41 bytes (sizeof)
typedef struct _WHEA_XPF_PROCESSOR_ERROR_SECTION {
  union _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS
      ValidBits;         // offset: 0x0 ordinal: 0x0
  ULONGLONG LocalAPICId; // offset: 0x8 ordinal: 0x1
  UCHAR CpuId[48];       // offset: 0x10 ordinal: 0x2
  UCHAR VariableInfo[1]; // offset: 0x40 ordinal: 0x3
} _WHEA_XPF_PROCESSOR_ERROR_SECTION;

// 0x8 bytes (sizeof)
typedef struct _HARDWARE_PTE {
  ULONGLONG Valid : 1;            // offset: 0x0 ordinal: 0x0
  ULONGLONG Write : 1;            // offset: 0x0 ordinal: 0x1
  ULONGLONG Owner : 1;            // offset: 0x0 ordinal: 0x2
  ULONGLONG WriteThrough : 1;     // offset: 0x0 ordinal: 0x3
  ULONGLONG CacheDisable : 1;     // offset: 0x0 ordinal: 0x4
  ULONGLONG Accessed : 1;         // offset: 0x0 ordinal: 0x5
  ULONGLONG Dirty : 1;            // offset: 0x0 ordinal: 0x6
  ULONGLONG LargePage : 1;        // offset: 0x0 ordinal: 0x7
  ULONGLONG Global : 1;           // offset: 0x0 ordinal: 0x8
  ULONGLONG CopyOnWrite : 1;      // offset: 0x0 ordinal: 0x9
  ULONGLONG Prototype : 1;        // offset: 0x0 ordinal: 0xa
  ULONGLONG reserved0 : 1;        // offset: 0x0 ordinal: 0xb
  ULONGLONG PageFrameNumber : 40; // offset: 0x0 ordinal: 0xc
  ULONGLONG SoftwareWsIndex : 11; // offset: 0x0 ordinal: 0xd
  ULONGLONG NoExecute : 1;        // offset: 0x0 ordinal: 0xe
} _HARDWARE_PTE;

// 0x8 bytes (sizeof)
typedef union _AMD_MCA_IPID {
  ULONGLONG InstanceId : 32; // offset: 0x0 ordinal: 0x0
  ULONGLONG HardwareId : 12; // offset: 0x0 ordinal: 0x1
  ULONGLONG Reserved : 4;    // offset: 0x0 ordinal: 0x2
  ULONGLONG McaType : 16;    // offset: 0x0 ordinal: 0x3
  ULONGLONG AsUINT64;        // offset: 0x0 ordinal: 0x4
} _AMD_MCA_IPID;

// 0x18 bytes (sizeof)
typedef struct _HALP_ALLOC_CONTEXT {
  struct _LIST_ENTRY BufferList; // offset: 0x0 ordinal: 0x0
  ULONGLONG Lock;                // offset: 0x10 ordinal: 0x1
} _HALP_ALLOC_CONTEXT;

// 0x8 bytes (sizeof)
typedef union _WHEA_PERSISTENCE_INFO {
  ULONGLONG Signature : 16;  // offset: 0x0 ordinal: 0x0
  ULONGLONG Length : 24;     // offset: 0x0 ordinal: 0x1
  ULONGLONG Identifier : 16; // offset: 0x0 ordinal: 0x2
  ULONGLONG Attributes : 2;  // offset: 0x0 ordinal: 0x3
  ULONGLONG DoNotLog : 1;    // offset: 0x0 ordinal: 0x4
  ULONGLONG Reserved : 5;    // offset: 0x0 ordinal: 0x5
  ULONGLONG AsULONGLONG;     // offset: 0x0 ordinal: 0x6
} _WHEA_PERSISTENCE_INFO;

// 0x8 bytes (sizeof)
typedef union _WHEA_TIMESTAMP {
  ULONGLONG Seconds : 8;                // offset: 0x0 ordinal: 0x0
  ULONGLONG Minutes : 8;                // offset: 0x0 ordinal: 0x1
  ULONGLONG Hours : 8;                  // offset: 0x0 ordinal: 0x2
  ULONGLONG Precise : 1;                // offset: 0x0 ordinal: 0x3
  ULONGLONG Reserved : 7;               // offset: 0x0 ordinal: 0x4
  ULONGLONG Day : 8;                    // offset: 0x0 ordinal: 0x5
  ULONGLONG Month : 8;                  // offset: 0x0 ordinal: 0x6
  ULONGLONG Year : 8;                   // offset: 0x0 ordinal: 0x7
  ULONGLONG Century : 8;                // offset: 0x0 ordinal: 0x8
  union _LARGE_INTEGER AsLARGE_INTEGER; // offset: 0x0 ordinal: 0x9
} _WHEA_TIMESTAMP;

// 0x80 bytes (sizeof)
typedef struct _WHEA_ERROR_RECORD_HEADER {
  ULONG Signature;                    // offset: 0x0 ordinal: 0x0
  union _WHEA_REVISION Revision;      // offset: 0x4 ordinal: 0x1
  ULONG SignatureEnd;                 // offset: 0x6 ordinal: 0x2
  USHORT SectionCount;                // offset: 0xa ordinal: 0x3
  enum _WHEA_ERROR_SEVERITY Severity; // offset: 0xc ordinal: 0x4
  union _WHEA_ERROR_RECORD_HEADER_VALIDBITS
      ValidBits;                                // offset: 0x10 ordinal: 0x5
  ULONG Length;                                 // offset: 0x14 ordinal: 0x6
  union _WHEA_TIMESTAMP Timestamp;              // offset: 0x18 ordinal: 0x7
  struct _GUID PlatformId;                      // offset: 0x20 ordinal: 0x8
  struct _GUID PartitionId;                     // offset: 0x30 ordinal: 0x9
  struct _GUID CreatorId;                       // offset: 0x40 ordinal: 0xa
  struct _GUID NotifyType;                      // offset: 0x50 ordinal: 0xb
  ULONGLONG RecordId;                           // offset: 0x60 ordinal: 0xc
  union _WHEA_ERROR_RECORD_HEADER_FLAGS Flags;  // offset: 0x68 ordinal: 0xd
  union _WHEA_PERSISTENCE_INFO PersistenceInfo; // offset: 0x6c ordinal: 0xe
  ULONG OsBuildNumber;                          // offset: 0x74 ordinal: 0xf
  UCHAR Reserved2[8];                           // offset: 0x78 ordinal: 0x10
  UCHAR Reserved[12];                           // offset: 0x74 ordinal: 0x11
} _WHEA_ERROR_RECORD_HEADER;

// 0xc8 bytes (sizeof)
typedef struct _WHEA_ERROR_RECORD {
  struct _WHEA_ERROR_RECORD_HEADER Header; // offset: 0x0 ordinal: 0x0
  struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR
      SectionDescriptor[1]; // offset: 0x80 ordinal: 0x1
} _WHEA_ERROR_RECORD;

// 0x50 bytes (sizeof)
typedef struct _WHEA_ERROR_PACKET_V2 {
  ULONG Signature;                                // offset: 0x0 ordinal: 0x0
  ULONG Version;                                  // offset: 0x4 ordinal: 0x1
  ULONG Length;                                   // offset: 0x8 ordinal: 0x2
  union _WHEA_ERROR_PACKET_FLAGS Flags;           // offset: 0xc ordinal: 0x3
  enum _WHEA_ERROR_TYPE ErrorType;                // offset: 0x10 ordinal: 0x4
  enum _WHEA_ERROR_SEVERITY ErrorSeverity;        // offset: 0x14 ordinal: 0x5
  ULONG ErrorSourceId;                            // offset: 0x18 ordinal: 0x6
  enum _WHEA_ERROR_SOURCE_TYPE ErrorSourceType;   // offset: 0x1c ordinal: 0x7
  struct _GUID NotifyType;                        // offset: 0x20 ordinal: 0x8
  ULONGLONG Context;                              // offset: 0x30 ordinal: 0x9
  enum _WHEA_ERROR_PACKET_DATA_FORMAT DataFormat; // offset: 0x38 ordinal: 0xa
  ULONG Reserved1;                                // offset: 0x3c ordinal: 0xb
  ULONG DataOffset;                               // offset: 0x40 ordinal: 0xc
  ULONG DataLength;                               // offset: 0x44 ordinal: 0xd
  ULONG PshedDataOffset;                          // offset: 0x48 ordinal: 0xe
  ULONG PshedDataLength;                          // offset: 0x4c ordinal: 0xf
} _WHEA_ERROR_PACKET_V2;

// 0x1c bytes (sizeof)
typedef struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
  UCHAR BankNumber;               // offset: 0x0 ordinal: 0x0
  UCHAR ClearOnInitialization;    // offset: 0x1 ordinal: 0x1
  UCHAR StatusDataFormat;         // offset: 0x2 ordinal: 0x2
  union _XPF_MC_BANK_FLAGS Flags; // offset: 0x3 ordinal: 0x3
  ULONG ControlMsr;               // offset: 0x4 ordinal: 0x4
  ULONG StatusMsr;                // offset: 0x8 ordinal: 0x5
  ULONG AddressMsr;               // offset: 0xc ordinal: 0x6
  ULONG MiscMsr;                  // offset: 0x10 ordinal: 0x7
  ULONGLONG ControlData;          // offset: 0x14 ordinal: 0x8
} _WHEA_XPF_MC_BANK_DESCRIPTOR;

// 0x3a4 bytes (sizeof)
typedef struct _WHEA_XPF_CMC_DESCRIPTOR {
  USHORT Type;                                   // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;                                 // offset: 0x2 ordinal: 0x1
  UCHAR NumberOfBanks;                           // offset: 0x3 ordinal: 0x2
  ULONG Reserved;                                // offset: 0x4 ordinal: 0x3
  struct _WHEA_NOTIFICATION_DESCRIPTOR Notify;   // offset: 0x8 ordinal: 0x4
  struct _WHEA_XPF_MC_BANK_DESCRIPTOR Banks[32]; // offset: 0x24 ordinal: 0x5
} _WHEA_XPF_CMC_DESCRIPTOR;

// 0x50 bytes (sizeof)
typedef struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 {
  USHORT Type;                                 // offset: 0x0 ordinal: 0x0
  UCHAR Reserved;                              // offset: 0x2 ordinal: 0x1
  UCHAR Enabled;                               // offset: 0x3 ordinal: 0x2
  ULONG ErrStatusBlockLength;                  // offset: 0x4 ordinal: 0x3
  ULONG RelatedErrorSourceId;                  // offset: 0x8 ordinal: 0x4
  UCHAR ErrStatusAddressSpaceID;               // offset: 0xc ordinal: 0x5
  UCHAR ErrStatusAddressBitWidth;              // offset: 0xd ordinal: 0x6
  UCHAR ErrStatusAddressBitOffset;             // offset: 0xe ordinal: 0x7
  UCHAR ErrStatusAddressAccessSize;            // offset: 0xf ordinal: 0x8
  union _LARGE_INTEGER ErrStatusAddress;       // offset: 0x10 ordinal: 0x9
  struct _WHEA_NOTIFICATION_DESCRIPTOR Notify; // offset: 0x18 ordinal: 0xa
  UCHAR ReadAckAddressSpaceID;                 // offset: 0x34 ordinal: 0xb
  UCHAR ReadAckAddressBitWidth;                // offset: 0x35 ordinal: 0xc
  UCHAR ReadAckAddressBitOffset;               // offset: 0x36 ordinal: 0xd
  UCHAR ReadAckAddressAccessSize;              // offset: 0x37 ordinal: 0xe
  union _LARGE_INTEGER ReadAckAddress;         // offset: 0x38 ordinal: 0xf
  ULONGLONG ReadAckPreserveMask;               // offset: 0x40 ordinal: 0x10
  ULONGLONG ReadAckWriteMask;                  // offset: 0x48 ordinal: 0x11
} _WHEA_GENERIC_ERROR_DESCRIPTOR_V2;

// 0x398 bytes (sizeof)
typedef struct _WHEA_XPF_MCE_DESCRIPTOR {
  USHORT Type;                                   // offset: 0x0 ordinal: 0x0
  UCHAR Enabled;                                 // offset: 0x2 ordinal: 0x1
  UCHAR NumberOfBanks;                           // offset: 0x3 ordinal: 0x2
  union _XPF_MCE_FLAGS Flags;                    // offset: 0x4 ordinal: 0x3
  ULONGLONG MCG_Capability;                      // offset: 0x8 ordinal: 0x4
  ULONGLONG MCG_GlobalControl;                   // offset: 0x10 ordinal: 0x5
  struct _WHEA_XPF_MC_BANK_DESCRIPTOR Banks[32]; // offset: 0x18 ordinal: 0x6
} _WHEA_XPF_MCE_DESCRIPTOR;

// 0x3a4 bytes (sizeof)
typedef union __anon_1306 {
  struct _WHEA_XPF_MCE_DESCRIPTOR XpfMceDescriptor; // offset: 0x0 ordinal: 0x0
  struct _WHEA_XPF_CMC_DESCRIPTOR XpfCmcDescriptor; // offset: 0x0 ordinal: 0x1
  struct _WHEA_XPF_NMI_DESCRIPTOR XpfNmiDescriptor; // offset: 0x0 ordinal: 0x2
  struct _WHEA_IPF_MCA_DESCRIPTOR IpfMcaDescriptor; // offset: 0x0 ordinal: 0x3
  struct _WHEA_IPF_CMC_DESCRIPTOR IpfCmcDescriptor; // offset: 0x0 ordinal: 0x4
  struct _WHEA_IPF_CPE_DESCRIPTOR IpfCpeDescriptor; // offset: 0x0 ordinal: 0x5
  struct _WHEA_AER_ROOTPORT_DESCRIPTOR
      AerRootportDescriptor; // offset: 0x0 ordinal: 0x6
  struct _WHEA_AER_ENDPOINT_DESCRIPTOR
      AerEndpointDescriptor; // offset: 0x0 ordinal: 0x7
  struct _WHEA_AER_BRIDGE_DESCRIPTOR
      AerBridgeDescriptor; // offset: 0x0 ordinal: 0x8
  struct _WHEA_GENERIC_ERROR_DESCRIPTOR
      GenErrDescriptor; // offset: 0x0 ordinal: 0x9
  struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2
      GenErrDescriptorV2; // offset: 0x0 ordinal: 0xa
  struct _WHEA_DEVICE_DRIVER_DESCRIPTOR
      DeviceDriverDescriptor; // offset: 0x0 ordinal: 0xb
} __anon_1306;

// 0x3cc bytes (sizeof)
typedef struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
  ULONG Length;                        // offset: 0x0 ordinal: 0x0
  ULONG Version;                       // offset: 0x4 ordinal: 0x1
  enum _WHEA_ERROR_SOURCE_TYPE Type;   // offset: 0x8 ordinal: 0x2
  enum _WHEA_ERROR_SOURCE_STATE State; // offset: 0xc ordinal: 0x3
  ULONG MaxRawDataLength;              // offset: 0x10 ordinal: 0x4
  ULONG NumRecordsToPreallocate;       // offset: 0x14 ordinal: 0x5
  ULONG MaxSectionsPerRecord;          // offset: 0x18 ordinal: 0x6
  ULONG ErrorSourceId;                 // offset: 0x1c ordinal: 0x7
  ULONG PlatformErrorSourceId;         // offset: 0x20 ordinal: 0x8
  ULONG Flags;                         // offset: 0x24 ordinal: 0x9
  union __anon_1306 Info;              // offset: 0x28 ordinal: 0xa
} _WHEA_ERROR_SOURCE_DESCRIPTOR;

// 0x430 bytes (sizeof)
typedef struct _WHEAP_ERROR_SOURCE {
  struct _LIST_ENTRY ListEntry;                    // offset: 0x0 ordinal: 0x0
  ULONG FailedAllocations;                         // offset: 0x10 ordinal: 0x1
  ULONG PlatformErrorSourceId;                     // offset: 0x14 ordinal: 0x2
  LONG ErrorCount;                                 // offset: 0x18 ordinal: 0x3
  ULONG RecordCount;                               // offset: 0x1c ordinal: 0x4
  ULONG RecordLength;                              // offset: 0x20 ordinal: 0x5
  ULONG PoolTag;                                   // offset: 0x24 ordinal: 0x6
  enum _WHEA_ERROR_SOURCE_TYPE Type;               // offset: 0x28 ordinal: 0x7
  struct _WHEAP_ERROR_RECORD_WRAPPER *Records;     // offset: 0x30 ordinal: 0x8
  VOID *Context;                                   // offset: 0x38 ordinal: 0x9
  ULONG SectionCount;                              // offset: 0x40 ordinal: 0xa
  ULONG SectionLength;                             // offset: 0x44 ordinal: 0xb
  union _LARGE_INTEGER TickCountAtLastError;       // offset: 0x48 ordinal: 0xc
  ULONG AccumulatedErrors;                         // offset: 0x50 ordinal: 0xd
  ULONG TotalErrors;                               // offset: 0x54 ordinal: 0xe
  UCHAR Deferred;                                  // offset: 0x58 ordinal: 0xf
  LONG Busy;                                       // offset: 0x5c ordinal: 0x10
  struct _WHEA_ERROR_SOURCE_DESCRIPTOR Descriptor; // offset: 0x60 ordinal: 0x11
} _WHEAP_ERROR_SOURCE;

// 0xf0 bytes (sizeof)
typedef struct _WHEAP_ERROR_RECORD_WRAPPER {
  struct _LIST_ENTRY WorkEntry;                  // offset: 0x0 ordinal: 0x0
  ULONG Length;                                  // offset: 0x10 ordinal: 0x1
  ULONG ProcessorNumber;                         // offset: 0x14 ordinal: 0x2
  union _WHEAP_ERROR_RECORD_WRAPPER_FLAGS Flags; // offset: 0x18 ordinal: 0x3
  LONG InUse;                                    // offset: 0x1c ordinal: 0x4
  struct _WHEAP_ERROR_SOURCE *ErrorSource;       // offset: 0x20 ordinal: 0x5
  struct _WHEA_ERROR_RECORD ErrorRecord;         // offset: 0x28 ordinal: 0x6
} _WHEAP_ERROR_RECORD_WRAPPER;

// 0x98 bytes (sizeof)
typedef struct _EXCEPTION_RECORD64 {
  LONG ExceptionCode;                 // offset: 0x0 ordinal: 0x0
  ULONG ExceptionFlags;               // offset: 0x4 ordinal: 0x1
  ULONGLONG ExceptionRecord;          // offset: 0x8 ordinal: 0x2
  ULONGLONG ExceptionAddress;         // offset: 0x10 ordinal: 0x3
  ULONG NumberParameters;             // offset: 0x18 ordinal: 0x4
  ULONG __unusedAlignment;            // offset: 0x1c ordinal: 0x5
  ULONGLONG ExceptionInformation[15]; // offset: 0x20 ordinal: 0x6
} _EXCEPTION_RECORD64;

// 0xa0 bytes (sizeof)
typedef struct _DBGKM_EXCEPTION64 {
  struct _EXCEPTION_RECORD64 ExceptionRecord; // offset: 0x0 ordinal: 0x0
  ULONG FirstChance;                          // offset: 0x98 ordinal: 0x1
} _DBGKM_EXCEPTION64;

// 0x98 bytes (sizeof)
typedef struct _EXCEPTION_RECORD {
  LONG ExceptionCode;                        // offset: 0x0 ordinal: 0x0
  ULONG ExceptionFlags;                      // offset: 0x4 ordinal: 0x1
  struct _EXCEPTION_RECORD *ExceptionRecord; // offset: 0x8 ordinal: 0x2
  VOID *ExceptionAddress;                    // offset: 0x10 ordinal: 0x3
  ULONG NumberParameters;                    // offset: 0x18 ordinal: 0x4
  ULONGLONG ExceptionInformation[15];        // offset: 0x20 ordinal: 0x5
} _EXCEPTION_RECORD;

// 0x10 bytes (sizeof)
typedef union _KIDTENTRY64 {
  USHORT OffsetLow;     // offset: 0x0 ordinal: 0x0
  USHORT Selector;      // offset: 0x2 ordinal: 0x1
  USHORT IstIndex : 3;  // offset: 0x4 ordinal: 0x2
  USHORT Reserved0 : 5; // offset: 0x4 ordinal: 0x3
  USHORT Type : 5;      // offset: 0x4 ordinal: 0x4
  USHORT Dpl : 2;       // offset: 0x4 ordinal: 0x5
  USHORT Present : 1;   // offset: 0x4 ordinal: 0x6
  USHORT OffsetMiddle;  // offset: 0x6 ordinal: 0x7
  ULONG OffsetHigh;     // offset: 0x8 ordinal: 0x8
  ULONG Reserved1;      // offset: 0xc ordinal: 0x9
  ULONGLONG Alignment;  // offset: 0x0 ordinal: 0xa
} _KIDTENTRY64;

// 0x18 bytes (sizeof)
typedef struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
  struct _LIST_ENTRY Linkage; // offset: 0x0 ordinal: 0x0
  ULONGLONG Signature;        // offset: 0x10 ordinal: 0x1
} _RTL_DYNAMIC_HASH_TABLE_ENTRY;

// 0x38 bytes (sizeof)
typedef struct _SEP_LUID_TO_INDEX_MAP_ENTRY {
  struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 ordinal: 0x0
  LONGLONG ReferenceCount;                        // offset: 0x18 ordinal: 0x1
  ULONGLONG Luid;                                 // offset: 0x20 ordinal: 0x2
  ULONGLONG IndexIntoGlobalSingletonTable;        // offset: 0x28 ordinal: 0x3
  UCHAR MarkedForDeletion;                        // offset: 0x30 ordinal: 0x4
} _SEP_LUID_TO_INDEX_MAP_ENTRY;

// 0x48 bytes (sizeof)
typedef struct _SEP_CACHED_HANDLES_ENTRY {
  struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 ordinal: 0x0
  LONGLONG ReferenceCount;                        // offset: 0x18 ordinal: 0x1
  struct _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR
      EntryDescriptor; // offset: 0x20 ordinal: 0x2
  ULONG HandleCount;   // offset: 0x38 ordinal: 0x3
  VOID **Handles;      // offset: 0x40 ordinal: 0x4
} _SEP_CACHED_HANDLES_ENTRY;

// 0x38 bytes (sizeof)
typedef struct _SEP_LOWBOX_NUMBER_ENTRY {
  struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 ordinal: 0x0
  LONGLONG ReferenceCount;                        // offset: 0x18 ordinal: 0x1
  VOID *PackageSid;                               // offset: 0x20 ordinal: 0x2
  ULONG LowboxNumber;                             // offset: 0x28 ordinal: 0x3
  VOID *AtomTable;                                // offset: 0x30 ordinal: 0x4
} _SEP_LOWBOX_NUMBER_ENTRY;

// 0x28 bytes (sizeof)
typedef struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
  union {
    struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry; // offset: 0x0 ordinal: 0x0
    struct _LIST_ENTRY *CurEntry;                   // offset: 0x0 ordinal: 0x1
  };
  struct _LIST_ENTRY *ChainHead; // offset: 0x18 ordinal: 0x2
  ULONG BucketIndex;             // offset: 0x20 ordinal: 0x3
} _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;

// 0x18 bytes (sizeof)
typedef struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
  struct _LIST_ENTRY *ChainHead;   // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY *PrevLinkage; // offset: 0x8 ordinal: 0x1
  ULONGLONG Signature;             // offset: 0x10 ordinal: 0x2
} _RTL_DYNAMIC_HASH_TABLE_CONTEXT;

// 0x10 bytes (sizeof)
typedef struct _EVENT_DESCRIPTOR {
  USHORT Id;         // offset: 0x0 ordinal: 0x0
  UCHAR Version;     // offset: 0x2 ordinal: 0x1
  UCHAR Channel;     // offset: 0x3 ordinal: 0x2
  UCHAR Level;       // offset: 0x4 ordinal: 0x3
  UCHAR Opcode;      // offset: 0x5 ordinal: 0x4
  USHORT Task;       // offset: 0x6 ordinal: 0x5
  ULONGLONG Keyword; // offset: 0x8 ordinal: 0x6
} _EVENT_DESCRIPTOR;

// 0x50 bytes (sizeof)
typedef struct _EVENT_HEADER {
  USHORT Size;                              // offset: 0x0 ordinal: 0x0
  USHORT HeaderType;                        // offset: 0x2 ordinal: 0x1
  USHORT Flags;                             // offset: 0x4 ordinal: 0x2
  USHORT EventProperty;                     // offset: 0x6 ordinal: 0x3
  ULONG ThreadId;                           // offset: 0x8 ordinal: 0x4
  ULONG ProcessId;                          // offset: 0xc ordinal: 0x5
  union _LARGE_INTEGER TimeStamp;           // offset: 0x10 ordinal: 0x6
  struct _GUID ProviderId;                  // offset: 0x18 ordinal: 0x7
  struct _EVENT_DESCRIPTOR EventDescriptor; // offset: 0x28 ordinal: 0x8
  ULONG KernelTime;                         // offset: 0x38 ordinal: 0x9
  ULONG UserTime;                           // offset: 0x3c ordinal: 0xa
  ULONGLONG ProcessorTime;                  // offset: 0x38 ordinal: 0xb
  struct _GUID ActivityId;                  // offset: 0x40 ordinal: 0xc
} _EVENT_HEADER;

// 0x70 bytes (sizeof)
typedef struct _EVENT_RECORD {
  struct _EVENT_HEADER EventHeader;         // offset: 0x0 ordinal: 0x0
  struct _ETW_BUFFER_CONTEXT BufferContext; // offset: 0x50 ordinal: 0x1
  USHORT ExtendedDataCount;                 // offset: 0x54 ordinal: 0x2
  USHORT UserDataLength;                    // offset: 0x56 ordinal: 0x3
  struct _EVENT_HEADER_EXTENDED_DATA_ITEM
      *ExtendedData; // offset: 0x58 ordinal: 0x4
  VOID *UserData;    // offset: 0x60 ordinal: 0x5
  VOID *UserContext; // offset: 0x68 ordinal: 0x6
} _EVENT_RECORD;

// 0x10 bytes (sizeof)
typedef struct _EVENT_DATA_DESCRIPTOR {
  ULONGLONG Ptr; // offset: 0x0 ordinal: 0x0
  ULONG Size;    // offset: 0x8 ordinal: 0x1
  union {
    ULONG Reserved; // offset: 0xc ordinal: 0x2
    UCHAR Type;     // offset: 0xc ordinal: 0x3
  };
  UCHAR Reserved1;  // offset: 0xd ordinal: 0x4
  USHORT Reserved2; // offset: 0xe ordinal: 0x5
} _EVENT_DATA_DESCRIPTOR;

// 0x10 bytes (sizeof)
typedef struct _PO_FX_PERF_STATE {
  ULONGLONG Value; // offset: 0x0 ordinal: 0x0
  VOID *Context;   // offset: 0x8 ordinal: 0x1
} _PO_FX_PERF_STATE;

// 0x10 bytes (sizeof)
typedef struct __anon_1242 {
  ULONG Count;                      // offset: 0x0 ordinal: 0x0
  struct _PO_FX_PERF_STATE *States; // offset: 0x8 ordinal: 0x1
} __anon_1242;

// 0x10 bytes (sizeof)
typedef struct __anon_1260 {
  USHORT Group;        // offset: 0x0 ordinal: 0x0
  USHORT MessageCount; // offset: 0x2 ordinal: 0x1
  ULONG Vector;        // offset: 0x4 ordinal: 0x2
  ULONGLONG Affinity;  // offset: 0x8 ordinal: 0x3
} __anon_1260;

// 0x10 bytes (sizeof)
typedef struct __anon_1248 {
  USHORT Level;       // offset: 0x0 ordinal: 0x0
  USHORT Group;       // offset: 0x2 ordinal: 0x1
  ULONG Vector;       // offset: 0x4 ordinal: 0x2
  ULONGLONG Affinity; // offset: 0x8 ordinal: 0x3
} __anon_1248;

// 0x10 bytes (sizeof)
typedef struct __anon_1249 {
  union {
    struct __anon_1260 Raw;        // offset: 0x0 ordinal: 0x0
    struct __anon_1248 Translated; // offset: 0x0 ordinal: 0x1
  };
} __anon_1249;

// 0x10 bytes (sizeof)
typedef union __anon_1236 {
  struct __anon_1247 Generic;            // offset: 0x0 ordinal: 0x0
  struct __anon_1247 Port;               // offset: 0x0 ordinal: 0x1
  struct __anon_1248 Interrupt;          // offset: 0x0 ordinal: 0x2
  struct __anon_1249 MessageInterrupt;   // offset: 0x0 ordinal: 0x3
  struct __anon_1247 Memory;             // offset: 0x0 ordinal: 0x4
  struct __anon_1250 Dma;                // offset: 0x0 ordinal: 0x5
  struct __anon_1251 DmaV3;              // offset: 0x0 ordinal: 0x6
  struct __anon_1218 DevicePrivate;      // offset: 0x0 ordinal: 0x7
  struct __anon_1252 BusNumber;          // offset: 0x0 ordinal: 0x8
  struct __anon_1253 DeviceSpecificData; // offset: 0x0 ordinal: 0x9
  struct __anon_1254 Memory40;           // offset: 0x0 ordinal: 0xa
  struct __anon_1255 Memory48;           // offset: 0x0 ordinal: 0xb
  struct __anon_1256 Memory64;           // offset: 0x0 ordinal: 0xc
  struct __anon_1224 Connection;         // offset: 0x0 ordinal: 0xd
} __anon_1236;

// 0x14 bytes (sizeof)
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
  UCHAR Type;             // offset: 0x0 ordinal: 0x0
  UCHAR ShareDisposition; // offset: 0x1 ordinal: 0x1
  USHORT Flags;           // offset: 0x2 ordinal: 0x2
  union __anon_1236 u;    // offset: 0x4 ordinal: 0x3
} _CM_PARTIAL_RESOURCE_DESCRIPTOR;

// 0x18 bytes (sizeof)
typedef struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList; // offset: 0x0 ordinal: 0x0
  ULONG AllocateFromCount;             // offset: 0x8 ordinal: 0x1
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR
      *AllocateFrom; // offset: 0x10 ordinal: 0x2
} _ARBITER_RETEST_ALLOCATION_PARAMETERS;

// 0x18 bytes (sizeof)
typedef struct _ARBITER_TEST_ALLOCATION_PARAMETERS {
  struct _LIST_ENTRY *ArbitrationList; // offset: 0x0 ordinal: 0x0
  ULONG AllocateFromCount;             // offset: 0x8 ordinal: 0x1
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR
      *AllocateFrom; // offset: 0x10 ordinal: 0x2
} _ARBITER_TEST_ALLOCATION_PARAMETERS;

// 0x1c bytes (sizeof)
typedef struct _CM_PARTIAL_RESOURCE_LIST {
  USHORT Version;  // offset: 0x0 ordinal: 0x0
  USHORT Revision; // offset: 0x2 ordinal: 0x1
  ULONG Count;     // offset: 0x4 ordinal: 0x2
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR
      PartialDescriptors[1]; // offset: 0x8 ordinal: 0x3
} _CM_PARTIAL_RESOURCE_LIST;

// 0x8 bytes (sizeof)
typedef struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
  struct _CM_PARTIAL_RESOURCE_LIST *
      *AllocatedResources; // offset: 0x0 ordinal: 0x0
} _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;

// 0x24 bytes (sizeof)
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
  enum _INTERFACE_TYPE InterfaceType; // offset: 0x0 ordinal: 0x0
  ULONG BusNumber;                    // offset: 0x4 ordinal: 0x1
  struct _CM_PARTIAL_RESOURCE_LIST
      PartialResourceList; // offset: 0x8 ordinal: 0x2
} _CM_FULL_RESOURCE_DESCRIPTOR;

// 0x28 bytes (sizeof)
typedef struct _CM_RESOURCE_LIST {
  ULONG Count;                                 // offset: 0x0 ordinal: 0x0
  struct _CM_FULL_RESOURCE_DESCRIPTOR List[1]; // offset: 0x4 ordinal: 0x1
} _CM_RESOURCE_LIST;

// 0x10 bytes (sizeof)
typedef struct __anon_1021 {
  struct _CM_RESOURCE_LIST *AllocatedResources; // offset: 0x0 ordinal: 0x0
  struct _CM_RESOURCE_LIST
      *AllocatedResourcesTranslated; // offset: 0x8 ordinal: 0x1
} __anon_1021;

// 0x10 bytes (sizeof)
typedef struct __anon_1243 {
  ULONGLONG Minimum; // offset: 0x0 ordinal: 0x0
  ULONGLONG Maximum; // offset: 0x8 ordinal: 0x1
} __anon_1243;

// 0x30 bytes (sizeof)
typedef struct _PO_FX_COMPONENT_PERF_SET {
  struct _UNICODE_STRING Name;      // offset: 0x0 ordinal: 0x0
  ULONGLONG Flags;                  // offset: 0x10 ordinal: 0x1
  enum _PO_FX_PERF_STATE_UNIT Unit; // offset: 0x18 ordinal: 0x2
  enum _PO_FX_PERF_STATE_TYPE Type; // offset: 0x1c ordinal: 0x3
  union {
    struct __anon_1242 Discrete; // offset: 0x20 ordinal: 0x4
    struct __anon_1243 Range;    // offset: 0x20 ordinal: 0x5
  };
} _PO_FX_COMPONENT_PERF_SET;

// 0x18 bytes (sizeof)
typedef struct __anon_1215 {
  ULONG MinimumVector;               // offset: 0x0 ordinal: 0x0
  ULONG MaximumVector;               // offset: 0x4 ordinal: 0x1
  USHORT AffinityPolicy;             // offset: 0x8 ordinal: 0x2
  USHORT Group;                      // offset: 0xa ordinal: 0x3
  enum _IRQ_PRIORITY PriorityPolicy; // offset: 0xc ordinal: 0x4
  ULONGLONG TargetedProcessors;      // offset: 0x10 ordinal: 0x5
} __anon_1215;

// 0x18 bytes (sizeof)
typedef union __anon_1183 {
  struct __anon_1214 Port;          // offset: 0x0 ordinal: 0x0
  struct __anon_1214 Memory;        // offset: 0x0 ordinal: 0x1
  struct __anon_1215 Interrupt;     // offset: 0x0 ordinal: 0x2
  struct __anon_1216 Dma;           // offset: 0x0 ordinal: 0x3
  struct __anon_1217 DmaV3;         // offset: 0x0 ordinal: 0x4
  struct __anon_1214 Generic;       // offset: 0x0 ordinal: 0x5
  struct __anon_1218 DevicePrivate; // offset: 0x0 ordinal: 0x6
  struct __anon_1219 BusNumber;     // offset: 0x0 ordinal: 0x7
  struct __anon_1220 ConfigData;    // offset: 0x0 ordinal: 0x8
  struct __anon_1221 Memory40;      // offset: 0x0 ordinal: 0x9
  struct __anon_1222 Memory48;      // offset: 0x0 ordinal: 0xa
  struct __anon_1223 Memory64;      // offset: 0x0 ordinal: 0xb
  struct __anon_1224 Connection;    // offset: 0x0 ordinal: 0xc
} __anon_1183;

// 0x20 bytes (sizeof)
typedef struct _IO_RESOURCE_DESCRIPTOR {
  UCHAR Option;           // offset: 0x0 ordinal: 0x0
  UCHAR Type;             // offset: 0x1 ordinal: 0x1
  UCHAR ShareDisposition; // offset: 0x2 ordinal: 0x2
  UCHAR Spare1;           // offset: 0x3 ordinal: 0x3
  USHORT Flags;           // offset: 0x4 ordinal: 0x4
  USHORT Spare2;          // offset: 0x6 ordinal: 0x5
  union __anon_1183 u;    // offset: 0x8 ordinal: 0x6
} _IO_RESOURCE_DESCRIPTOR;

// 0x28 bytes (sizeof)
typedef struct _IO_RESOURCE_LIST {
  USHORT Version;                                // offset: 0x0 ordinal: 0x0
  USHORT Revision;                               // offset: 0x2 ordinal: 0x1
  ULONG Count;                                   // offset: 0x4 ordinal: 0x2
  struct _IO_RESOURCE_DESCRIPTOR Descriptors[1]; // offset: 0x8 ordinal: 0x3
} _IO_RESOURCE_LIST;

// 0x48 bytes (sizeof)
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
  ULONG ListSize;                     // offset: 0x0 ordinal: 0x0
  enum _INTERFACE_TYPE InterfaceType; // offset: 0x4 ordinal: 0x1
  ULONG BusNumber;                    // offset: 0x8 ordinal: 0x2
  ULONG SlotNumber;                   // offset: 0xc ordinal: 0x3
  ULONG Reserved[3];                  // offset: 0x10 ordinal: 0x4
  ULONG AlternativeLists;             // offset: 0x1c ordinal: 0x5
  struct _IO_RESOURCE_LIST List[1];   // offset: 0x20 ordinal: 0x6
} _IO_RESOURCE_REQUIREMENTS_LIST;

typedef LONG (*__anon_3417)(struct _BUS_HANDLER *, struct _BUS_HANDLER *,
                            struct _IO_RESOURCE_REQUIREMENTS_LIST **);

// 0x40 bytes (sizeof)
typedef struct _PNP_RESOURCE_REQUEST {
  struct _DEVICE_OBJECT *PhysicalDevice;       // offset: 0x0 ordinal: 0x0
  ULONG Flags;                                 // offset: 0x8 ordinal: 0x1
  enum _ARBITER_REQUEST_SOURCE AllocationType; // offset: 0xc ordinal: 0x2
  ULONG Priority;                              // offset: 0x10 ordinal: 0x3
  ULONG Position;                              // offset: 0x14 ordinal: 0x4
  struct _IO_RESOURCE_REQUIREMENTS_LIST
      *ResourceRequirements;                    // offset: 0x18 ordinal: 0x5
  VOID *ReqList;                                // offset: 0x20 ordinal: 0x6
  struct _CM_RESOURCE_LIST *ResourceAssignment; // offset: 0x28 ordinal: 0x7
  struct _CM_RESOURCE_LIST
      *TranslatedResourceAssignment; // offset: 0x30 ordinal: 0x8
  LONG Status;                       // offset: 0x38 ordinal: 0x9
} _PNP_RESOURCE_REQUEST;

// 0x8 bytes (sizeof)
typedef struct __anon_1012 {
  struct _IO_RESOURCE_REQUIREMENTS_LIST
      *IoResourceRequirementList; // offset: 0x0 ordinal: 0x0
} __anon_1012;

// 0x20 bytes (sizeof)
typedef struct _ARBITER_QUERY_CONFLICT_PARAMETERS {
  struct _DEVICE_OBJECT *PhysicalDeviceObject; // offset: 0x0 ordinal: 0x0
  struct _IO_RESOURCE_DESCRIPTOR
      *ConflictingResource;                  // offset: 0x8 ordinal: 0x1
  ULONG *ConflictCount;                      // offset: 0x10 ordinal: 0x2
  struct _ARBITER_CONFLICT_INFO **Conflicts; // offset: 0x18 ordinal: 0x3
} _ARBITER_QUERY_CONFLICT_PARAMETERS;

// 0x20 bytes (sizeof)
typedef union __anon_3790 {
  struct _ARBITER_TEST_ALLOCATION_PARAMETERS
      TestAllocation; // offset: 0x0 ordinal: 0x0
  struct _ARBITER_RETEST_ALLOCATION_PARAMETERS
      RetestAllocation; // offset: 0x0 ordinal: 0x1
  struct _ARBITER_BOOT_ALLOCATION_PARAMETERS
      BootAllocation; // offset: 0x0 ordinal: 0x2
  struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS
      QueryAllocatedResources; // offset: 0x0 ordinal: 0x3
  struct _ARBITER_QUERY_CONFLICT_PARAMETERS
      QueryConflict; // offset: 0x0 ordinal: 0x4
  struct _ARBITER_QUERY_ARBITRATE_PARAMETERS
      QueryArbitrate; // offset: 0x0 ordinal: 0x5
  struct _ARBITER_ADD_RESERVED_PARAMETERS
      AddReserved; // offset: 0x0 ordinal: 0x6
} __anon_3790;

// 0x20 bytes (sizeof)
typedef struct _ARBITER_PARAMETERS {
  union __anon_3790 Parameters; // offset: 0x0 ordinal: 0x0
} _ARBITER_PARAMETERS;

typedef LONG (*__anon_3774)(VOID *, enum _ARBITER_ACTION,
                            struct _ARBITER_PARAMETERS *);

// 0x30 bytes (sizeof)
typedef struct _ARBITER_INTERFACE {
  USHORT Size;                          // offset: 0x0 ordinal: 0x0
  USHORT Version;                       // offset: 0x2 ordinal: 0x1
  VOID *Context;                        // offset: 0x8 ordinal: 0x2
  VOID (*InterfaceReference)(VOID *);   // offset: 0x10 ordinal: 0x3
  VOID (*InterfaceDereference)(VOID *); // offset: 0x18 ordinal: 0x4
  LONG(*ArbiterHandler)
  (VOID *, enum _ARBITER_ACTION,
   struct _ARBITER_PARAMETERS *); // offset: 0x20 ordinal: 0x5
  ULONG Flags;                    // offset: 0x28 ordinal: 0x6
} _ARBITER_INTERFACE;

// 0x70 bytes (sizeof)
typedef struct _PI_RESOURCE_ARBITER_ENTRY {
  struct _LIST_ENTRY DeviceArbiterList;        // offset: 0x0 ordinal: 0x0
  UCHAR ResourceType;                          // offset: 0x10 ordinal: 0x1
  struct _ARBITER_INTERFACE *ArbiterInterface; // offset: 0x18 ordinal: 0x2
  struct _DEVICE_NODE *DeviceNode;             // offset: 0x20 ordinal: 0x3
  struct _LIST_ENTRY ResourceList;             // offset: 0x28 ordinal: 0x4
  struct _LIST_ENTRY BestResourceList;         // offset: 0x38 ordinal: 0x5
  struct _LIST_ENTRY BestConfig;               // offset: 0x48 ordinal: 0x6
  struct _LIST_ENTRY ActiveArbiterList;        // offset: 0x58 ordinal: 0x7
  UCHAR State;                                 // offset: 0x68 ordinal: 0x8
  UCHAR ResourcesChanged;                      // offset: 0x69 ordinal: 0x9
} _PI_RESOURCE_ARBITER_ENTRY;

// 0x40 bytes (sizeof)
typedef struct _ARBITER_ALTERNATIVE {
  ULONGLONG Minimum;                          // offset: 0x0 ordinal: 0x0
  ULONGLONG Maximum;                          // offset: 0x8 ordinal: 0x1
  ULONGLONG Length;                           // offset: 0x10 ordinal: 0x2
  ULONGLONG Alignment;                        // offset: 0x18 ordinal: 0x3
  LONG Priority;                              // offset: 0x20 ordinal: 0x4
  ULONG Flags;                                // offset: 0x24 ordinal: 0x5
  struct _IO_RESOURCE_DESCRIPTOR *Descriptor; // offset: 0x28 ordinal: 0x6
  ULONG Reserved[3];                          // offset: 0x30 ordinal: 0x7
} _ARBITER_ALTERNATIVE;

// 0x60 bytes (sizeof)
typedef struct _ARBITER_LIST_ENTRY {
  struct _LIST_ENTRY ListEntry;                 // offset: 0x0 ordinal: 0x0
  ULONG AlternativeCount;                       // offset: 0x10 ordinal: 0x1
  struct _IO_RESOURCE_DESCRIPTOR *Alternatives; // offset: 0x18 ordinal: 0x2
  struct _DEVICE_OBJECT *PhysicalDeviceObject;  // offset: 0x20 ordinal: 0x3
  enum _ARBITER_REQUEST_SOURCE RequestSource;   // offset: 0x28 ordinal: 0x4
  ULONG Flags;                                  // offset: 0x2c ordinal: 0x5
  LONGLONG WorkSpace;                           // offset: 0x30 ordinal: 0x6
  enum _INTERFACE_TYPE InterfaceType;           // offset: 0x38 ordinal: 0x7
  ULONG SlotNumber;                             // offset: 0x3c ordinal: 0x8
  ULONG BusNumber;                              // offset: 0x40 ordinal: 0x9
  struct _CM_PARTIAL_RESOURCE_DESCRIPTOR
      *Assignment; // offset: 0x48 ordinal: 0xa
  struct _IO_RESOURCE_DESCRIPTOR
      *SelectedAlternative;    // offset: 0x50 ordinal: 0xb
  enum _ARBITER_RESULT Result; // offset: 0x58 ordinal: 0xc
} _ARBITER_LIST_ENTRY;

// 0x50 bytes (sizeof)
typedef struct _ARBITER_ALLOCATION_STATE {
  ULONGLONG Start;                                 // offset: 0x0 ordinal: 0x0
  ULONGLONG End;                                   // offset: 0x8 ordinal: 0x1
  ULONGLONG CurrentMinimum;                        // offset: 0x10 ordinal: 0x2
  ULONGLONG CurrentMaximum;                        // offset: 0x18 ordinal: 0x3
  struct _ARBITER_LIST_ENTRY *Entry;               // offset: 0x20 ordinal: 0x4
  struct _ARBITER_ALTERNATIVE *CurrentAlternative; // offset: 0x28 ordinal: 0x5
  ULONG AlternativeCount;                          // offset: 0x30 ordinal: 0x6
  struct _ARBITER_ALTERNATIVE *Alternatives;       // offset: 0x38 ordinal: 0x7
  USHORT Flags;                                    // offset: 0x40 ordinal: 0x8
  UCHAR RangeAttributes;                           // offset: 0x42 ordinal: 0x9
  UCHAR RangeAvailableAttributes;                  // offset: 0x43 ordinal: 0xa
  ULONGLONG WorkSpace;                             // offset: 0x48 ordinal: 0xb
} _ARBITER_ALLOCATION_STATE;

typedef LONG (*__anon_3746)(struct _IO_RESOURCE_DESCRIPTOR *);

typedef LONG (*__anon_3744)(struct _IO_RESOURCE_DESCRIPTOR *, ULONGLONG,
                            struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *);

// 0x18 bytes (sizeof)
typedef struct _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT {
  UCHAR ResourceType;                               // offset: 0x0 ordinal: 0x0
  ULONG AlternativeCount;                           // offset: 0x4 ordinal: 0x1
  struct _IO_RESOURCE_DESCRIPTOR *ResourceRequests; // offset: 0x8 ordinal: 0x2
  VOID *ArbiterInstance;                            // offset: 0x10 ordinal: 0x3
} _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT;

// 0x40 bytes (sizeof)
typedef struct _PNP_WATCHDOG {
  ULONGLONG WatchdogStart;                     // offset: 0x0 ordinal: 0x0
  struct _WDT_HANDLE *WatchdogTimer;           // offset: 0x8 ordinal: 0x1
  enum _PNP_WATCHDOG_TYPE WatchdogContextType; // offset: 0x10 ordinal: 0x2
  VOID *WatchdogContext;                       // offset: 0x18 ordinal: 0x3
  UCHAR FirstChanceTriggered;                  // offset: 0x20 ordinal: 0x4
  UCHAR TelemetryGenerated;                    // offset: 0x21 ordinal: 0x5
  struct _UNICODE_STRING DriverToBlame;        // offset: 0x28 ordinal: 0x6
  WCHAR DriverToBlameBuffer[1];                // offset: 0x38 ordinal: 0x7
} _PNP_WATCHDOG;

// 0x48 bytes (sizeof)
typedef struct _PNP_DEVICE_COMPLETION_REQUEST {
  struct _LIST_ENTRY ListEntry;            // offset: 0x0 ordinal: 0x0
  struct _DEVICE_NODE *DeviceNode;         // offset: 0x10 ordinal: 0x1
  VOID *Context;                           // offset: 0x18 ordinal: 0x2
  enum _PNP_DEVNODE_STATE CompletionState; // offset: 0x20 ordinal: 0x3
  ULONG IrpPended;                         // offset: 0x24 ordinal: 0x4
  LONG Status;                             // offset: 0x28 ordinal: 0x5
  VOID *Information;                       // offset: 0x30 ordinal: 0x6
  LONG ReferenceCount;                     // offset: 0x38 ordinal: 0x7
  struct _PNP_WATCHDOG *Watchdog;          // offset: 0x40 ordinal: 0x8
} _PNP_DEVICE_COMPLETION_REQUEST;

// 0xc0 bytes (sizeof)
typedef struct _PNP_DEVICE_EVENT_ENTRY {
  struct _LIST_ENTRY ListEntry;           // offset: 0x0 ordinal: 0x0
  ULONG Argument;                         // offset: 0x10 ordinal: 0x1
  LONG ArgumentStatus;                    // offset: 0x14 ordinal: 0x2
  struct _KEVENT *CallerEvent;            // offset: 0x18 ordinal: 0x3
  VOID (*Callback)(VOID *);               // offset: 0x20 ordinal: 0x4
  VOID *Context;                          // offset: 0x28 ordinal: 0x5
  enum _PNP_VETO_TYPE *VetoType;          // offset: 0x30 ordinal: 0x6
  struct _UNICODE_STRING *VetoName;       // offset: 0x38 ordinal: 0x7
  ULONG RefCount;                         // offset: 0x40 ordinal: 0x8
  ULONG Lock;                             // offset: 0x44 ordinal: 0x9
  UCHAR Cancel;                           // offset: 0x48 ordinal: 0xa
  struct _PNP_DEVICE_EVENT_ENTRY *Parent; // offset: 0x50 ordinal: 0xb
  struct _GUID ActivityId;                // offset: 0x58 ordinal: 0xc
  struct _PNP_WATCHDOG *Watchdog;         // offset: 0x68 ordinal: 0xd
  struct _PLUGPLAY_EVENT_BLOCK Data;      // offset: 0x70 ordinal: 0xe
} _PNP_DEVICE_EVENT_ENTRY;

typedef LONG (*__anon_1172)(ULONGLONG, VOID **);

// 0x18 bytes (sizeof)
typedef struct _ETW_HW_TRACE_EXT_INTERFACE {
  LONG(*StartProcessorTraceOnEachCore)
  (ULONGLONG, VOID **);                         // offset: 0x0 ordinal: 0x0
  LONG (*StopProcessorTraceOnEachCore)(VOID *); // offset: 0x8 ordinal: 0x1
  LONG(*LogProcessorTraceOnCurrentCore)
  (VOID *, VOID *); // offset: 0x10 ordinal: 0x2
} _ETW_HW_TRACE_EXT_INTERFACE;

// 0x30 bytes (sizeof)
typedef struct _NT_IORING_OP_RESERVED {
  ULONGLONG Argument1; // offset: 0x0 ordinal: 0x0
  ULONGLONG Argument2; // offset: 0x8 ordinal: 0x1
  ULONGLONG Argument3; // offset: 0x10 ordinal: 0x2
  ULONGLONG Argument4; // offset: 0x18 ordinal: 0x3
  ULONGLONG Argument5; // offset: 0x20 ordinal: 0x4
  ULONGLONG Argument6; // offset: 0x28 ordinal: 0x5
} _NT_IORING_OP_RESERVED;

// 0x28 bytes (sizeof)
typedef struct _NT_IORING_OP_WRITE {
  enum _NT_IORING_OP_FLAGS CommonOpFlags; // offset: 0x0 ordinal: 0x0
  enum _NT_WRITE_FLAGS Flags;             // offset: 0x4 ordinal: 0x1
  union _NT_IORING_HANDLEREF File;        // offset: 0x8 ordinal: 0x2
  union _NT_IORING_BUFFERREF Buffer;      // offset: 0x10 ordinal: 0x3
  ULONGLONG Offset;                       // offset: 0x18 ordinal: 0x4
  ULONG Length;                           // offset: 0x20 ordinal: 0x5
  ULONG Key;                              // offset: 0x24 ordinal: 0x6
} _NT_IORING_OP_WRITE;

// 0x18 bytes (sizeof)
typedef struct _NT_IORING_OP_CANCEL {
  enum _NT_IORING_OP_FLAGS CommonOpFlags; // offset: 0x0 ordinal: 0x0
  union _NT_IORING_HANDLEREF File;        // offset: 0x8 ordinal: 0x1
  ULONGLONG CancelId;                     // offset: 0x10 ordinal: 0x2
} _NT_IORING_OP_CANCEL;

// 0x28 bytes (sizeof)
typedef struct _NT_IORING_OP_READ {
  enum _NT_IORING_OP_FLAGS CommonOpFlags; // offset: 0x0 ordinal: 0x0
  ULONG Padding;                          // offset: 0x4 ordinal: 0x1
  union _NT_IORING_HANDLEREF File;        // offset: 0x8 ordinal: 0x2
  union _NT_IORING_BUFFERREF Buffer;      // offset: 0x10 ordinal: 0x3
  ULONGLONG Offset;                       // offset: 0x18 ordinal: 0x4
  ULONG Length;                           // offset: 0x20 ordinal: 0x5
  ULONG Key;                              // offset: 0x24 ordinal: 0x6
} _NT_IORING_OP_READ;

// 0x20 bytes (sizeof)
typedef struct _POP_FX_PERF_SET {
  struct _PO_FX_COMPONENT_PERF_SET *PerfSet; // offset: 0x0 ordinal: 0x0
  ULONGLONG CurrentPerf;                     // offset: 0x8 ordinal: 0x1
  ULONGLONG CurrentPerfStamp;                // offset: 0x10 ordinal: 0x2
  UCHAR CurrentPerfNominal;                  // offset: 0x18 ordinal: 0x3
} _POP_FX_PERF_SET;

// 0x10 bytes (sizeof)
typedef struct _PO_FX_PERF_STATE_CHANGE {
  ULONG Set; // offset: 0x0 ordinal: 0x0
  union {
    ULONG StateIndex;     // offset: 0x8 ordinal: 0x1
    ULONGLONG StateValue; // offset: 0x8 ordinal: 0x2
  };
} _PO_FX_PERF_STATE_CHANGE;

// 0x40 bytes (sizeof)
typedef struct _NT_IORING_SQE {
  enum IORING_OP_CODE OpCode;      // offset: 0x0 ordinal: 0x0
  enum _NT_IORING_SQE_FLAGS Flags; // offset: 0x4 ordinal: 0x1
  union {
    ULONGLONG UserData;              // offset: 0x8 ordinal: 0x2
    ULONGLONG PaddingUserDataForWow; // offset: 0x8 ordinal: 0x3
  };
  union {
    struct _NT_IORING_OP_READ Read; // offset: 0x10 ordinal: 0x4
    struct _NT_IORING_OP_REGISTER_FILES
        RegisterFiles; // offset: 0x10 ordinal: 0x5
    struct _NT_IORING_OP_REGISTER_BUFFERS
        RegisterBuffers;                // offset: 0x10 ordinal: 0x6
    struct _NT_IORING_OP_CANCEL Cancel; // offset: 0x10 ordinal: 0x7
    struct _NT_IORING_OP_WRITE Write;   // offset: 0x10 ordinal: 0x8
    struct _NT_IORING_OP_FLUSH Flush;   // offset: 0x10 ordinal: 0x9
    struct _NT_IORING_OP_RESERVED
        ReservedMaxSizePadding; // offset: 0x10 ordinal: 0xa
  };
} _NT_IORING_SQE;

// 0x50 bytes (sizeof)
typedef struct _NT_IORING_SUBMISSION_QUEUE {
  ULONG Head;                       // offset: 0x0 ordinal: 0x0
  ULONG Tail;                       // offset: 0x4 ordinal: 0x1
  enum _NT_IORING_SQ_FLAGS Flags;   // offset: 0x8 ordinal: 0x2
  struct _NT_IORING_SQE Entries[1]; // offset: 0x10 ordinal: 0x3
} _NT_IORING_SUBMISSION_QUEUE;

// 0x28 bytes (sizeof)
typedef struct _POP_COMPONENT_POWER_PROFILE {
  struct _GUID ComponentGuid;                // offset: 0x0 ordinal: 0x0
  struct _POP_DEVICE_POWER_PROFILE *Device;  // offset: 0x10 ordinal: 0x1
  ULONGLONG FxCount;                         // offset: 0x18 ordinal: 0x2
  struct _PO_POWER_PLANE_PROFILE FxPower[1]; // offset: 0x20 ordinal: 0x3
} _POP_COMPONENT_POWER_PROFILE;

// 0x18 bytes (sizeof)
typedef struct _POP_FX_IDLE_STATE {
  ULONGLONG TransitionLatency;    // offset: 0x0 ordinal: 0x0
  ULONGLONG ResidencyRequirement; // offset: 0x8 ordinal: 0x1
  ULONG NominalPower;             // offset: 0x10 ordinal: 0x2
} _POP_FX_IDLE_STATE;

// 0x40 bytes (sizeof)
typedef struct _PPM_VETO_ENTRY {
  struct _LIST_ENTRY Link;      // offset: 0x0 ordinal: 0x0
  ULONG VetoReason;             // offset: 0x10 ordinal: 0x1
  ULONG ReferenceCount;         // offset: 0x14 ordinal: 0x2
  ULONGLONG HitCount;           // offset: 0x18 ordinal: 0x3
  ULONGLONG LastActivationTime; // offset: 0x20 ordinal: 0x4
  ULONGLONG TotalActiveTime;    // offset: 0x28 ordinal: 0x5
  ULONGLONG CsActivationTime;   // offset: 0x30 ordinal: 0x6
  ULONGLONG CsActiveTime;       // offset: 0x38 ordinal: 0x7
} _PPM_VETO_ENTRY;

// 0x28 bytes (sizeof)
typedef struct _PPM_VETO_ACCOUNTING {
  LONG VetoPresent;                             // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY VetoListHead;              // offset: 0x8 ordinal: 0x1
  UCHAR CsAccountingBlocks;                     // offset: 0x18 ordinal: 0x2
  UCHAR BlocksDrips;                            // offset: 0x19 ordinal: 0x3
  ULONG PreallocatedVetoCount;                  // offset: 0x1c ordinal: 0x4
  struct _PPM_VETO_ENTRY *PreallocatedVetoList; // offset: 0x20 ordinal: 0x5
} _PPM_VETO_ACCOUNTING;

// 0x20 bytes (sizeof)
typedef struct __anon_1022 {
  ULONGLONG ProviderId; // offset: 0x0 ordinal: 0x0
  VOID *DataPath;       // offset: 0x8 ordinal: 0x1
  ULONG BufferSize;     // offset: 0x10 ordinal: 0x2
  VOID *Buffer;         // offset: 0x18 ordinal: 0x3
} __anon_1022;

// 0x20 bytes (sizeof)
typedef union __anon_907 {
  struct __anon_989 Create;                      // offset: 0x0 ordinal: 0x0
  struct __anon_990 CreatePipe;                  // offset: 0x0 ordinal: 0x1
  struct __anon_991 CreateMailslot;              // offset: 0x0 ordinal: 0x2
  struct __anon_992 Read;                        // offset: 0x0 ordinal: 0x3
  struct __anon_992 Write;                       // offset: 0x0 ordinal: 0x4
  struct __anon_993 QueryDirectory;              // offset: 0x0 ordinal: 0x5
  struct __anon_994 NotifyDirectory;             // offset: 0x0 ordinal: 0x6
  struct __anon_995 NotifyDirectoryEx;           // offset: 0x0 ordinal: 0x7
  struct __anon_996 QueryFile;                   // offset: 0x0 ordinal: 0x8
  struct __anon_997 SetFile;                     // offset: 0x0 ordinal: 0x9
  struct __anon_998 QueryEa;                     // offset: 0x0 ordinal: 0xa
  struct __anon_999 SetEa;                       // offset: 0x0 ordinal: 0xb
  struct __anon_1000 QueryVolume;                // offset: 0x0 ordinal: 0xc
  struct __anon_1000 SetVolume;                  // offset: 0x0 ordinal: 0xd
  struct __anon_1001 FileSystemControl;          // offset: 0x0 ordinal: 0xe
  struct __anon_1002 LockControl;                // offset: 0x0 ordinal: 0xf
  struct __anon_1003 DeviceIoControl;            // offset: 0x0 ordinal: 0x10
  struct __anon_1004 QuerySecurity;              // offset: 0x0 ordinal: 0x11
  struct __anon_1005 SetSecurity;                // offset: 0x0 ordinal: 0x12
  struct __anon_1006 MountVolume;                // offset: 0x0 ordinal: 0x13
  struct __anon_1006 VerifyVolume;               // offset: 0x0 ordinal: 0x14
  struct __anon_1007 Scsi;                       // offset: 0x0 ordinal: 0x15
  struct __anon_1008 QueryQuota;                 // offset: 0x0 ordinal: 0x16
  struct __anon_999 SetQuota;                    // offset: 0x0 ordinal: 0x17
  struct __anon_1009 QueryDeviceRelations;       // offset: 0x0 ordinal: 0x18
  struct __anon_1010 QueryInterface;             // offset: 0x0 ordinal: 0x19
  struct __anon_1011 DeviceCapabilities;         // offset: 0x0 ordinal: 0x1a
  struct __anon_1012 FilterResourceRequirements; // offset: 0x0 ordinal: 0x1b
  struct __anon_1013 ReadWriteConfig;            // offset: 0x0 ordinal: 0x1c
  struct __anon_1014 SetLock;                    // offset: 0x0 ordinal: 0x1d
  struct __anon_1015 QueryId;                    // offset: 0x0 ordinal: 0x1e
  struct __anon_1016 QueryDeviceText;            // offset: 0x0 ordinal: 0x1f
  struct __anon_1017 UsageNotification;          // offset: 0x0 ordinal: 0x20
  struct __anon_1018 WaitWake;                   // offset: 0x0 ordinal: 0x21
  struct __anon_1019 PowerSequence;              // offset: 0x0 ordinal: 0x22
  struct __anon_1020 Power;                      // offset: 0x0 ordinal: 0x23
  struct __anon_1021 StartDevice;                // offset: 0x0 ordinal: 0x24
  struct __anon_1022 WMI;                        // offset: 0x0 ordinal: 0x25
  struct __anon_1023 Others;                     // offset: 0x0 ordinal: 0x26
} __anon_907;

// 0x48 bytes (sizeof)
typedef struct _IO_STACK_LOCATION {
  UCHAR MajorFunction;                 // offset: 0x0 ordinal: 0x0
  UCHAR MinorFunction;                 // offset: 0x1 ordinal: 0x1
  UCHAR Flags;                         // offset: 0x2 ordinal: 0x2
  UCHAR Control;                       // offset: 0x3 ordinal: 0x3
  union __anon_907 Parameters;         // offset: 0x8 ordinal: 0x4
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x28 ordinal: 0x5
  struct _FILE_OBJECT *FileObject;     // offset: 0x30 ordinal: 0x6
  LONG(*CompletionRoutine)
  (struct _DEVICE_OBJECT *, struct _IRP *, VOID *); // offset: 0x38 ordinal: 0x7
  VOID *Context;                                    // offset: 0x40 ordinal: 0x8
} _IO_STACK_LOCATION;

// 0x50 bytes (sizeof)
typedef struct __anon_1262 {
  union {
    struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry; // offset: 0x0 ordinal: 0x0
    VOID *DriverContext[4];                       // offset: 0x0 ordinal: 0x1
  };
  struct _ETHREAD *Thread;      // offset: 0x20 ordinal: 0x2
  CHAR *AuxiliaryBuffer;        // offset: 0x28 ordinal: 0x3
  struct _LIST_ENTRY ListEntry; // offset: 0x30 ordinal: 0x4
  union {
    struct _IO_STACK_LOCATION
        *CurrentStackLocation; // offset: 0x40 ordinal: 0x5
    ULONG PacketType;          // offset: 0x40 ordinal: 0x6
  };
  struct _FILE_OBJECT *OriginalFileObject; // offset: 0x48 ordinal: 0x7
} __anon_1262;

// 0x58 bytes (sizeof)
typedef union __anon_1263 {
  struct __anon_1262 Overlay; // offset: 0x0 ordinal: 0x0
  struct _KAPC Apc;           // offset: 0x0 ordinal: 0x1
  VOID *CompletionKey;        // offset: 0x0 ordinal: 0x2
} __anon_1263;

// 0x58 bytes (sizeof)
typedef struct __anon_577 {
  union {
    struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry; // offset: 0x0 ordinal: 0x0
    VOID *DriverContext[4];                       // offset: 0x0 ordinal: 0x1
  };
  struct _ETHREAD *Thread;      // offset: 0x20 ordinal: 0x2
  CHAR *AuxiliaryBuffer;        // offset: 0x28 ordinal: 0x3
  struct _LIST_ENTRY ListEntry; // offset: 0x30 ordinal: 0x4
  union {
    struct _IO_STACK_LOCATION
        *CurrentStackLocation; // offset: 0x40 ordinal: 0x5
    ULONG PacketType;          // offset: 0x40 ordinal: 0x6
  };
  struct _FILE_OBJECT *OriginalFileObject; // offset: 0x48 ordinal: 0x7
  VOID *IrpExtension;                      // offset: 0x50 ordinal: 0x8
} __anon_577;

// 0x58 bytes (sizeof)
typedef union __anon_492 {
  struct __anon_577 Overlay; // offset: 0x0 ordinal: 0x0
  struct _KAPC Apc;          // offset: 0x0 ordinal: 0x1
  VOID *CompletionKey;       // offset: 0x0 ordinal: 0x2
} __anon_492;

// 0x40 bytes (sizeof)
typedef struct _POP_POWER_PLANE {
  struct _UNICODE_STRING PowerPlaneId;          // offset: 0x0 ordinal: 0x0
  ULONGLONG Lock;                               // offset: 0x10 ordinal: 0x1
  UCHAR OldIrql;                                // offset: 0x18 ordinal: 0x2
  LONG DevicePowerMw;                           // offset: 0x1c ordinal: 0x3
  VOID *PmaxHandle;                             // offset: 0x20 ordinal: 0x4
  VOID (*NotifyDevicePowerDraw)(VOID *, ULONG); // offset: 0x28 ordinal: 0x5
  ULONGLONG DeviceCount;                        // offset: 0x30 ordinal: 0x6
  struct _POP_DEVICE_POWER_PROFILE **Devices;   // offset: 0x38 ordinal: 0x7
} _POP_POWER_PLANE;

// 0x28 bytes (sizeof)
typedef struct _PEP_WORK_ACPI_EVALUATE_CONTROL_METHOD_COMPLETE {
  struct POHANDLE__ *DeviceHandle;                  // offset: 0x0 ordinal: 0x0
  ULONG CompletionFlags;                            // offset: 0x8 ordinal: 0x1
  LONG MethodStatus;                                // offset: 0xc ordinal: 0x2
  VOID *CompletionContext;                          // offset: 0x10 ordinal: 0x3
  ULONGLONG OutputArgumentSize;                     // offset: 0x18 ordinal: 0x4
  struct _ACPI_METHOD_ARGUMENT_V1 *OutputArguments; // offset: 0x20 ordinal: 0x5
} _PEP_WORK_ACPI_EVALUATE_CONTROL_METHOD_COMPLETE;

// 0x38 bytes (sizeof)
typedef struct _PEP_WORK_POWER_CONTROL {
  struct POHANDLE__ *DeviceHandle; // offset: 0x0 ordinal: 0x0
  struct _GUID *PowerControlCode;  // offset: 0x8 ordinal: 0x1
  VOID *RequestContext;            // offset: 0x10 ordinal: 0x2
  VOID *InBuffer;                  // offset: 0x18 ordinal: 0x3
  ULONGLONG InBufferSize;          // offset: 0x20 ordinal: 0x4
  VOID *OutBuffer;                 // offset: 0x28 ordinal: 0x5
  ULONGLONG OutBufferSize;         // offset: 0x30 ordinal: 0x6
} _PEP_WORK_POWER_CONTROL;

// 0x40 bytes (sizeof)
typedef struct _PEP_WORK_INFORMATION {
  enum _PEP_WORK_TYPE WorkType; // offset: 0x0 ordinal: 0x0
  union {
    struct _PEP_WORK_ACTIVE_COMPLETE ActiveComplete; // offset: 0x8 ordinal: 0x1
    struct _PEP_WORK_IDLE_STATE IdleState;           // offset: 0x8 ordinal: 0x2
    struct _PEP_WORK_DEVICE_POWER DevicePower;       // offset: 0x8 ordinal: 0x3
    struct _PEP_WORK_POWER_CONTROL PowerControl;     // offset: 0x8 ordinal: 0x4
    struct _PEP_WORK_DEVICE_IDLE DeviceIdle;         // offset: 0x8 ordinal: 0x5
    struct _PEP_WORK_COMPLETE_IDLE_STATE
        CompleteIdleState; // offset: 0x8 ordinal: 0x6
    struct _PEP_WORK_COMPLETE_PERF_STATE
        CompletePerfState;                   // offset: 0x8 ordinal: 0x7
    struct _PEP_WORK_ACPI_NOTIFY AcpiNotify; // offset: 0x8 ordinal: 0x8
    struct _PEP_WORK_ACPI_EVALUATE_CONTROL_METHOD_COMPLETE
        ControlMethodComplete; // offset: 0x8 ordinal: 0x9
  };
} _PEP_WORK_INFORMATION;

typedef VOID (*__anon_941)(ULONGLONG, ULONG *);

// 0x20 bytes (sizeof)
typedef struct _PROC_IDLE_STATE_BUCKET {
  ULONGLONG TotalTime; // offset: 0x0 ordinal: 0x0
  ULONGLONG MinTime;   // offset: 0x8 ordinal: 0x1
  ULONGLONG MaxTime;   // offset: 0x10 ordinal: 0x2
  ULONG Count;         // offset: 0x18 ordinal: 0x3
} _PROC_IDLE_STATE_BUCKET;

// 0x28 bytes (sizeof)
typedef struct _ETW_IPT_SUPPORT {
  VOID *IptHandle;     // offset: 0x0 ordinal: 0x0
  ULONGLONG IptOption; // offset: 0x8 ordinal: 0x1
  struct _ETW_HW_TRACE_EXT_INTERFACE
      *EtwHwTraceExtInterface; // offset: 0x10 ordinal: 0x2
  ULONG HookIdCount;           // offset: 0x18 ordinal: 0x3
  USHORT HookId[4];            // offset: 0x1c ordinal: 0x4
} _ETW_IPT_SUPPORT;

// 0x48 bytes (sizeof)
typedef struct _WMI_BUFFER_HEADER {
  ULONG BufferSize;               // offset: 0x0 ordinal: 0x0
  ULONG SavedOffset;              // offset: 0x4 ordinal: 0x1
  ULONG CurrentOffset;            // offset: 0x8 ordinal: 0x2
  LONG ReferenceCount;            // offset: 0xc ordinal: 0x3
  union _LARGE_INTEGER TimeStamp; // offset: 0x10 ordinal: 0x4
  LONGLONG SequenceNumber;        // offset: 0x18 ordinal: 0x5
  ULONGLONG ClockType : 3;        // offset: 0x20 ordinal: 0x6
  ULONGLONG Frequency : 61;       // offset: 0x20 ordinal: 0x7
  union {
    struct _SINGLE_LIST_ENTRY SlistEntry;  // offset: 0x20 ordinal: 0x8
    struct _WMI_BUFFER_HEADER *NextBuffer; // offset: 0x20 ordinal: 0x9
  };
  struct _ETW_BUFFER_CONTEXT ClientContext; // offset: 0x28 ordinal: 0xa
  enum _ETW_BUFFER_STATE State;             // offset: 0x2c ordinal: 0xb
  ULONG Offset;                             // offset: 0x30 ordinal: 0xc
  USHORT BufferFlag;                        // offset: 0x34 ordinal: 0xd
  USHORT BufferType;                        // offset: 0x36 ordinal: 0xe
  union {
    ULONG Padding1[4];                   // offset: 0x38 ordinal: 0xf
    struct _ETW_REF_CLOCK ReferenceTime; // offset: 0x38 ordinal: 0x10
    struct _LIST_ENTRY GlobalEntry;      // offset: 0x38 ordinal: 0x11
    VOID *Pointer0;                      // offset: 0x38 ordinal: 0x12
  };
  VOID *Pointer1; // offset: 0x40 ordinal: 0x13
} _WMI_BUFFER_HEADER;

// 0x18 bytes (sizeof)
typedef struct _EVENT_FILTER_HEADER {
  USHORT Id;            // offset: 0x0 ordinal: 0x0
  UCHAR Version;        // offset: 0x2 ordinal: 0x1
  UCHAR Reserved[5];    // offset: 0x3 ordinal: 0x2
  ULONGLONG InstanceId; // offset: 0x8 ordinal: 0x3
  ULONG Size;           // offset: 0x10 ordinal: 0x4
  ULONG NextOffset;     // offset: 0x14 ordinal: 0x5
} _EVENT_FILTER_HEADER;

// 0x18 bytes (sizeof)
typedef struct _EVENT_FILTER_LEVEL_KW {
  ULONGLONG MatchAnyKeyword; // offset: 0x0 ordinal: 0x0
  ULONGLONG MatchAllKeyword; // offset: 0x8 ordinal: 0x1
  UCHAR Level;               // offset: 0x10 ordinal: 0x2
  UCHAR FilterIn;            // offset: 0x11 ordinal: 0x3
} _EVENT_FILTER_LEVEL_KW;

// 0x28 bytes (sizeof)
typedef struct _ETW_FILTER_EVENT_NAME_DATA {
  UCHAR FilterIn;                   // offset: 0x0 ordinal: 0x0
  UCHAR Level;                      // offset: 0x1 ordinal: 0x1
  ULONGLONG MatchAnyKeyword;        // offset: 0x8 ordinal: 0x2
  ULONGLONG MatchAllKeyword;        // offset: 0x10 ordinal: 0x3
  struct _RTL_HASH_TABLE NameTable; // offset: 0x18 ordinal: 0x4
} _ETW_FILTER_EVENT_NAME_DATA;

// 0x28 bytes (sizeof)
typedef struct _POP_FX_WORK_POOL_ITEM {
  struct _POP_FX_WORK_POOL *WorkPool; // offset: 0x0 ordinal: 0x0
  struct _WORK_QUEUE_ITEM WorkItem;   // offset: 0x8 ordinal: 0x1
} _POP_FX_WORK_POOL_ITEM;

// 0x130 bytes (sizeof)
typedef struct _POP_FX_WORK_POOL {
  struct _POP_FX_PLUGIN *Plugin;              // offset: 0x0 ordinal: 0x0
  ULONGLONG EmergencyWorkQueueLock;           // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY EmergencyWorkQueue;      // offset: 0x10 ordinal: 0x2
  struct _KSEMAPHORE WorkPoolQueues[2];       // offset: 0x20 ordinal: 0x3
  LONG WorkItemStatus;                        // offset: 0x60 ordinal: 0x4
  struct _POP_FX_WORK_POOL_ITEM WorkItems[4]; // offset: 0x68 ordinal: 0x5
  struct _KTHREAD *PoolWorkerThreads[5];      // offset: 0x108 ordinal: 0x6
} _POP_FX_WORK_POOL;

typedef VOID (*__anon_851)(ULONGLONG, ULONGLONG, UCHAR);

typedef VOID (*__anon_848)(ULONGLONG);

typedef VOID (*__anon_847)(ULONGLONG, ULONG);

// 0x88 bytes (sizeof)
typedef struct _PPM_SELECTION_STATISTICS {
  ULONGLONG SelectedCount;                        // offset: 0x0 ordinal: 0x0
  ULONGLONG VetoCount;                            // offset: 0x8 ordinal: 0x1
  ULONGLONG PreVetoCount;                         // offset: 0x10 ordinal: 0x2
  ULONGLONG WrongProcessorCount;                  // offset: 0x18 ordinal: 0x3
  ULONGLONG LatencyCount;                         // offset: 0x20 ordinal: 0x4
  ULONGLONG IdleDurationCount;                    // offset: 0x28 ordinal: 0x5
  ULONGLONG DeviceDependencyCount;                // offset: 0x30 ordinal: 0x6
  ULONGLONG ProcessorDependencyCount;             // offset: 0x38 ordinal: 0x7
  ULONGLONG PlatformOnlyCount;                    // offset: 0x40 ordinal: 0x8
  ULONGLONG InterruptibleCount;                   // offset: 0x48 ordinal: 0x9
  ULONGLONG LegacyOverrideCount;                  // offset: 0x50 ordinal: 0xa
  ULONGLONG CstateCheckCount;                     // offset: 0x58 ordinal: 0xb
  ULONGLONG NoCStateCount;                        // offset: 0x60 ordinal: 0xc
  ULONGLONG CoordinatedDependencyCount;           // offset: 0x68 ordinal: 0xd
  ULONGLONG NotClockOwnerCount;                   // offset: 0x70 ordinal: 0xe
  ULONGLONG DependencyIdleDurationCount;          // offset: 0x78 ordinal: 0xf
  struct _PPM_VETO_ACCOUNTING *PreVetoAccounting; // offset: 0x80 ordinal: 0x10
} _PPM_SELECTION_STATISTICS;

// 0x3f8 bytes (sizeof)
typedef struct _PLATFORM_IDLE_STATE_ACCOUNTING {
  ULONG CancelCount;        // offset: 0x0 ordinal: 0x0
  ULONG FailureCount;       // offset: 0x4 ordinal: 0x1
  ULONG SuccessCount;       // offset: 0x8 ordinal: 0x2
  ULONGLONG MaxTime;        // offset: 0x10 ordinal: 0x3
  ULONGLONG MinTime;        // offset: 0x18 ordinal: 0x4
  ULONGLONG TotalTime;      // offset: 0x20 ordinal: 0x5
  ULONG InvalidBucketIndex; // offset: 0x28 ordinal: 0x6
  struct _PPM_SELECTION_STATISTICS
      SelectionStatistics; // offset: 0x30 ordinal: 0x7
  struct _PROC_IDLE_STATE_BUCKET
      IdleTimeBuckets[26]; // offset: 0xb8 ordinal: 0x8
} _PLATFORM_IDLE_STATE_ACCOUNTING;

// 0x410 bytes (sizeof)
typedef struct _PLATFORM_IDLE_ACCOUNTING {
  ULONG ResetCount;                                // offset: 0x0 ordinal: 0x0
  ULONG StateCount;                                // offset: 0x4 ordinal: 0x1
  ULONG DeepSleepCount;                            // offset: 0x8 ordinal: 0x2
  enum PPM_IDLE_BUCKET_TIME_TYPE TimeUnit;         // offset: 0xc ordinal: 0x3
  ULONGLONG StartTime;                             // offset: 0x10 ordinal: 0x4
  struct _PLATFORM_IDLE_STATE_ACCOUNTING State[1]; // offset: 0x18 ordinal: 0x5
} _PLATFORM_IDLE_ACCOUNTING;

// 0x18 bytes (sizeof)
typedef struct _POP_FX_LOG_ENTRY {
  ULONGLONG Timestamp;   // offset: 0x0 ordinal: 0x0
  UCHAR Operation;       // offset: 0x8 ordinal: 0x1
  UCHAR Component;       // offset: 0x9 ordinal: 0x2
  USHORT Processor;      // offset: 0xa ordinal: 0x3
  USHORT Process;        // offset: 0xc ordinal: 0x4
  USHORT Thread;         // offset: 0xe ordinal: 0x5
  ULONGLONG Information; // offset: 0x10 ordinal: 0x6
} _POP_FX_LOG_ENTRY;

// 0x1a8 bytes (sizeof)
typedef struct _POP_FX_PLUGIN {
  struct _LIST_ENTRY Link;                          // offset: 0x0 ordinal: 0x0
  ULONG Version;                                    // offset: 0x10 ordinal: 0x1
  ULONGLONG Flags;                                  // offset: 0x18 ordinal: 0x2
  struct _KQUEUE WorkQueue;                         // offset: 0x20 ordinal: 0x3
  UCHAR (*AcceptDeviceNotification)(ULONG, VOID *); // offset: 0x60 ordinal: 0x4
  UCHAR(*AcceptProcessorNotification)
  (struct PEPHANDLE__ *, ULONG, VOID *);          // offset: 0x68 ordinal: 0x5
  UCHAR (*AcceptAcpiNotification)(ULONG, VOID *); // offset: 0x70 ordinal: 0x6
  struct _POP_FX_WORK_POOL PluginWorkPool;        // offset: 0x78 ordinal: 0x7
} _POP_FX_PLUGIN;

// 0x38 bytes (sizeof)
typedef struct _PROC_PERF_CHECK_SNAP {
  ULONGLONG Time;                          // offset: 0x0 ordinal: 0x0
  ULONGLONG Active;                        // offset: 0x8 ordinal: 0x1
  ULONGLONG Stall;                         // offset: 0x10 ordinal: 0x2
  ULONGLONG FrequencyScaledActive;         // offset: 0x18 ordinal: 0x3
  ULONGLONG PerformanceScaledActive;       // offset: 0x20 ordinal: 0x4
  ULONGLONG PerformanceScaledKernelActive; // offset: 0x28 ordinal: 0x5
  ULONG ResponsivenessEvents;              // offset: 0x30 ordinal: 0x6
} _PROC_PERF_CHECK_SNAP;

// 0x28 bytes (sizeof)
typedef struct _PERF_CONTROL_STATE_SELECTION {
  ULONGLONG SelectedState;        // offset: 0x0 ordinal: 0x0
  ULONG SelectedPercent;          // offset: 0x8 ordinal: 0x1
  ULONG SelectedFrequency;        // offset: 0xc ordinal: 0x2
  ULONG MinPercent;               // offset: 0x10 ordinal: 0x3
  ULONG MaxPercent;               // offset: 0x14 ordinal: 0x4
  ULONG TolerancePercent;         // offset: 0x18 ordinal: 0x5
  ULONG EppPercent;               // offset: 0x1c ordinal: 0x6
  ULONG AutonomousActivityWindow; // offset: 0x20 ordinal: 0x7
  UCHAR Autonomous;               // offset: 0x24 ordinal: 0x8
  UCHAR InheritFromDomain;        // offset: 0x25 ordinal: 0x9
} _PERF_CONTROL_STATE_SELECTION;

typedef VOID (*__anon_850)(ULONGLONG, struct _PERF_CONTROL_STATE_SELECTION *,
                           UCHAR, UCHAR);

// 0x3f0 bytes (sizeof)
typedef struct _PROC_IDLE_STATE_ACCOUNTING {
  ULONGLONG TotalTime;      // offset: 0x0 ordinal: 0x0
  ULONG CancelCount;        // offset: 0x8 ordinal: 0x1
  ULONG FailureCount;       // offset: 0xc ordinal: 0x2
  ULONG SuccessCount;       // offset: 0x10 ordinal: 0x3
  ULONG InvalidBucketIndex; // offset: 0x14 ordinal: 0x4
  ULONGLONG MinTime;        // offset: 0x18 ordinal: 0x5
  ULONGLONG MaxTime;        // offset: 0x20 ordinal: 0x6
  struct _PPM_SELECTION_STATISTICS
      SelectionStatistics; // offset: 0x28 ordinal: 0x7
  struct _PROC_IDLE_STATE_BUCKET
      IdleTimeBuckets[26]; // offset: 0xb0 ordinal: 0x8
} _PROC_IDLE_STATE_ACCOUNTING;

// 0x30 bytes (sizeof)
typedef struct _PROCESSOR_IDLE_CONSTRAINTS {
  ULONGLONG TotalTime;            // offset: 0x0 ordinal: 0x0
  ULONGLONG IdleTime;             // offset: 0x8 ordinal: 0x1
  ULONGLONG ExpectedIdleDuration; // offset: 0x10 ordinal: 0x2
  ULONGLONG MaxIdleDuration;      // offset: 0x18 ordinal: 0x3
  ULONG OverrideState;            // offset: 0x20 ordinal: 0x4
  ULONG TimeCheck;                // offset: 0x24 ordinal: 0x5
  UCHAR PromotePercent;           // offset: 0x28 ordinal: 0x6
  UCHAR DemotePercent;            // offset: 0x29 ordinal: 0x7
  UCHAR Parked;                   // offset: 0x2a ordinal: 0x8
  UCHAR Interruptible;            // offset: 0x2b ordinal: 0x9
  UCHAR PlatformIdle;             // offset: 0x2c ordinal: 0xa
  UCHAR ExpectedWakeReason;       // offset: 0x2d ordinal: 0xb
  UCHAR IdleStateMax;             // offset: 0x2e ordinal: 0xc
} _PROCESSOR_IDLE_CONSTRAINTS;

typedef ULONG (*__anon_713)(VOID *, struct _PROCESSOR_IDLE_CONSTRAINTS *);

// 0x58 bytes (sizeof)
typedef struct _PROCESSOR_IDLE_PREPARE_INFO {
  VOID *Context;                                  // offset: 0x0 ordinal: 0x0
  struct _PROCESSOR_IDLE_CONSTRAINTS Constraints; // offset: 0x8 ordinal: 0x1
  ULONG DependencyCount;                          // offset: 0x38 ordinal: 0x2
  ULONG DependencyUsed;                           // offset: 0x3c ordinal: 0x3
  struct _PROCESSOR_IDLE_DEPENDENCY
      *DependencyArray;          // offset: 0x40 ordinal: 0x4
  ULONG PlatformIdleStateIndex;  // offset: 0x48 ordinal: 0x5
  ULONG ProcessorIdleStateIndex; // offset: 0x4c ordinal: 0x6
  ULONG IdleSelectFailureMask;   // offset: 0x50 ordinal: 0x7
} _PROCESSOR_IDLE_PREPARE_INFO;

typedef VOID (*__anon_710)(struct _PROCESSOR_IDLE_PREPARE_INFO *);

typedef LONG (*__anon_712)(VOID *, ULONGLONG, ULONG, ULONG, ULONG, ULONG,
                           ULONG *);

// 0x20 bytes (sizeof)
typedef struct _SEP_SID_VALUES_BLOCK {
  ULONG BlockLength;        // offset: 0x0 ordinal: 0x0
  LONGLONG ReferenceCount;  // offset: 0x8 ordinal: 0x1
  ULONG SidCount;           // offset: 0x10 ordinal: 0x2
  ULONGLONG SidValuesStart; // offset: 0x18 ordinal: 0x3
} _SEP_SID_VALUES_BLOCK;

// 0x90 bytes (sizeof)
typedef struct _PROC_PERF_CONSTRAINT {
  struct _PROC_PERF_CHECK_CONTEXT *CheckContext;  // offset: 0x0 ordinal: 0x0
  ULONGLONG PerfContext;                          // offset: 0x8 ordinal: 0x1
  enum _PROCESSOR_PRESENCE Presence;              // offset: 0x10 ordinal: 0x2
  ULONG ProcessorId;                              // offset: 0x14 ordinal: 0x3
  ULONG PlatformCap;                              // offset: 0x18 ordinal: 0x4
  ULONG ThermalCap;                               // offset: 0x1c ordinal: 0x5
  ULONG LimitReasons;                             // offset: 0x20 ordinal: 0x6
  ULONGLONG PlatformCapStartTime;                 // offset: 0x28 ordinal: 0x7
  ULONG ProcCap;                                  // offset: 0x30 ordinal: 0x8
  ULONG ProcFloor;                                // offset: 0x34 ordinal: 0x9
  ULONG TargetPercent;                            // offset: 0x38 ordinal: 0xa
  UCHAR EngageResponsivenessOverrides;            // offset: 0x3c ordinal: 0xb
  UCHAR ResponsivenessChangeCount;                // offset: 0x3d ordinal: 0xc
  struct _PERF_CONTROL_STATE_SELECTION Selection; // offset: 0x40 ordinal: 0xd
  ULONG DomainSelectionGeneration;                // offset: 0x68 ordinal: 0xe
  ULONG PreviousFrequency;                        // offset: 0x6c ordinal: 0xf
  ULONG PreviousPercent;                          // offset: 0x70 ordinal: 0x10
  ULONG LatestFrequencyPercent;                   // offset: 0x74 ordinal: 0x11
  ULONG LatestPerformancePercent;                 // offset: 0x78 ordinal: 0x12
  UCHAR Force;                                    // offset: 0x7c ordinal: 0x13
  UCHAR UseQosUpdateLock;                         // offset: 0x7d ordinal: 0x14
  ULONGLONG QosUpdateLock;                        // offset: 0x80 ordinal: 0x15
  ULONG IncreasePerfCheckCount;                   // offset: 0x88 ordinal: 0x16
  ULONG DecreasePerfCheckCount;                   // offset: 0x8c ordinal: 0x17
} _PROC_PERF_CONSTRAINT;

typedef VOID *(*__anon_612)(enum _POOL_TYPE, ULONGLONG, ULONG);

// 0x18 bytes (sizeof)
typedef struct _KHETERO_PROCESSOR_SET {
  ULONGLONG IdealMask;     // offset: 0x0 ordinal: 0x0
  ULONGLONG PreferredMask; // offset: 0x8 ordinal: 0x1
  ULONGLONG AvailableMask; // offset: 0x10 ordinal: 0x2
} _KHETERO_PROCESSOR_SET;

// 0x20 bytes (sizeof)
typedef struct _KPRCB_TRACEPOINT_LOG_ENTRY {
  ULONGLONG OldPc; // offset: 0x0 ordinal: 0x0
  ULONGLONG OldSp; // offset: 0x8 ordinal: 0x1
  ULONGLONG NewPc; // offset: 0x10 ordinal: 0x2
  ULONGLONG NewSp; // offset: 0x18 ordinal: 0x3
} _KPRCB_TRACEPOINT_LOG_ENTRY;

// 0x2008 bytes (sizeof)
typedef struct _KPRCB_TRACEPOINT_LOG {
  struct _KPRCB_TRACEPOINT_LOG_ENTRY Entries[256]; // offset: 0x0 ordinal: 0x0
  ULONG LogIndex; // offset: 0x2000 ordinal: 0x1
} _KPRCB_TRACEPOINT_LOG;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY *(*__anon_607)(ULONGLONG, VOID *);

// 0x20 bytes (sizeof)
typedef struct _TRACE_ENABLE_INFO {
  ULONG IsEnabled;           // offset: 0x0 ordinal: 0x0
  UCHAR Level;               // offset: 0x4 ordinal: 0x1
  UCHAR Reserved1;           // offset: 0x5 ordinal: 0x2
  USHORT LoggerId;           // offset: 0x6 ordinal: 0x3
  ULONG EnableProperty;      // offset: 0x8 ordinal: 0x4
  ULONG Reserved2;           // offset: 0xc ordinal: 0x5
  ULONGLONG MatchAnyKeyword; // offset: 0x10 ordinal: 0x6
  ULONGLONG MatchAllKeyword; // offset: 0x18 ordinal: 0x7
} _TRACE_ENABLE_INFO;

// 0x28 bytes (sizeof)
typedef struct _MACHINE_FRAME {
  ULONGLONG Rip;   // offset: 0x0 ordinal: 0x0
  USHORT SegCs;    // offset: 0x8 ordinal: 0x1
  USHORT Fill1[3]; // offset: 0xa ordinal: 0x2
  ULONG EFlags;    // offset: 0x10 ordinal: 0x3
  ULONG Fill2;     // offset: 0x14 ordinal: 0x4
  ULONGLONG Rsp;   // offset: 0x18 ordinal: 0x5
  USHORT SegSs;    // offset: 0x20 ordinal: 0x6
  USHORT Fill3[3]; // offset: 0x22 ordinal: 0x7
} _MACHINE_FRAME;

// 0x20 bytes (sizeof)
typedef struct _KCLOCK_INCREMENT_TRACE {
  ULONG ActualIncrement;        // offset: 0x0 ordinal: 0x0
  ULONG RequestedIncrement;     // offset: 0x4 ordinal: 0x1
  ULONGLONG InterruptTime;      // offset: 0x8 ordinal: 0x2
  ULONGLONG PerformanceCounter; // offset: 0x10 ordinal: 0x3
  UCHAR OneShot;                // offset: 0x18 ordinal: 0x4
} _KCLOCK_INCREMENT_TRACE;

// 0x28 bytes (sizeof)
typedef struct _KCLOCK_TICK_TRACE {
  ULONGLONG PerformanceCounter; // offset: 0x0 ordinal: 0x0
  ULONGLONG PreInterruptTime;   // offset: 0x8 ordinal: 0x1
  ULONGLONG PostInterruptTime;  // offset: 0x10 ordinal: 0x2
  ULONGLONG TimeStampCounter;   // offset: 0x18 ordinal: 0x3
  UCHAR IsClockOwner;           // offset: 0x20 ordinal: 0x4
} _KCLOCK_TICK_TRACE;

// 0x10 bytes (sizeof)
typedef struct _KCLOCK_TIMER_DEADLINE_ENTRY {
  ULONGLONG DueTime;    // offset: 0x0 ordinal: 0x0
  ULONG TolerableDelay; // offset: 0x8 ordinal: 0x1
  union {
    UCHAR TypeFlags; // offset: 0xc ordinal: 0x2
    UCHAR Valid : 1; // offset: 0xc ordinal: 0x3
  };
  UCHAR NoWake : 1; // offset: 0xc ordinal: 0x4
  UCHAR Unused : 6; // offset: 0xc ordinal: 0x5
} _KCLOCK_TIMER_DEADLINE_ENTRY;

// 0x418 bytes (sizeof)
typedef struct _PROC_IDLE_ACCOUNTING {
  ULONG StateCount;                            // offset: 0x0 ordinal: 0x0
  ULONG TotalTransitions;                      // offset: 0x4 ordinal: 0x1
  ULONG ResetCount;                            // offset: 0x8 ordinal: 0x2
  ULONG AbortCount;                            // offset: 0xc ordinal: 0x3
  ULONGLONG StartTime;                         // offset: 0x10 ordinal: 0x4
  ULONGLONG PriorIdleTime;                     // offset: 0x18 ordinal: 0x5
  enum PPM_IDLE_BUCKET_TIME_TYPE TimeUnit;     // offset: 0x20 ordinal: 0x6
  struct _PROC_IDLE_STATE_ACCOUNTING State[1]; // offset: 0x28 ordinal: 0x7
} _PROC_IDLE_ACCOUNTING;

// 0x10 bytes (sizeof)
typedef struct _KSPIN_LOCK_QUEUE {
  struct _KSPIN_LOCK_QUEUE *Next; // offset: 0x0 ordinal: 0x0
  ULONGLONG *Lock;                // offset: 0x8 ordinal: 0x1
} _KSPIN_LOCK_QUEUE;

// 0x18 bytes (sizeof)
typedef struct _KLOCK_QUEUE_HANDLE {
  struct _KSPIN_LOCK_QUEUE LockQueue; // offset: 0x0 ordinal: 0x0
  UCHAR OldIrql;                      // offset: 0x10 ordinal: 0x1
} _KLOCK_QUEUE_HANDLE;

// 0x10 bytes (sizeof)
typedef union _KQOS_GROUPING_SETS {
  ULONGLONG SingleCoreSet; // offset: 0x0 ordinal: 0x0
  ULONGLONG SmtSet;        // offset: 0x8 ordinal: 0x1
} _KQOS_GROUPING_SETS;

// 0x10 bytes (sizeof)
typedef struct _GROUP_AFFINITY {
  ULONGLONG Mask;     // offset: 0x0 ordinal: 0x0
  USHORT Group;       // offset: 0x8 ordinal: 0x1
  USHORT Reserved[3]; // offset: 0xa ordinal: 0x2
} _GROUP_AFFINITY;

// 0x58 bytes (sizeof)
typedef struct _INTERRUPT_VECTOR_DATA {
  enum INTERRUPT_CONNECTION_TYPE Type;           // offset: 0x0 ordinal: 0x0
  ULONG Vector;                                  // offset: 0x4 ordinal: 0x1
  UCHAR Irql;                                    // offset: 0x8 ordinal: 0x2
  enum _KINTERRUPT_POLARITY Polarity;            // offset: 0xc ordinal: 0x3
  enum _KINTERRUPT_MODE Mode;                    // offset: 0x10 ordinal: 0x4
  struct _GROUP_AFFINITY TargetProcessors;       // offset: 0x18 ordinal: 0x5
  struct _INTERRUPT_REMAPPING_INFO IntRemapInfo; // offset: 0x28 ordinal: 0x6
  struct __anon_3075 ControllerInput;            // offset: 0x38 ordinal: 0x7
  ULONGLONG HvDeviceId;                          // offset: 0x40 ordinal: 0x8
  union {
    struct __anon_3076 XapicMessage;   // offset: 0x48 ordinal: 0x9
    struct __anon_3077 Hypertransport; // offset: 0x48 ordinal: 0xa
    struct __anon_3076 GenericMessage; // offset: 0x48 ordinal: 0xb
    struct __anon_3078 MessageRequest; // offset: 0x48 ordinal: 0xc
  };
} _INTERRUPT_VECTOR_DATA;

typedef VOID (*__anon_3266)(ULONG, ULONG, struct _PCI_BUSMASTER_DESCRIPTOR *,
                            UCHAR, struct _INTERRUPT_VECTOR_DATA *, ULONG);

typedef LONG (*__anon_3265)(ULONG, ULONG, struct _PCI_BUSMASTER_DESCRIPTOR *,
                            UCHAR, struct _INTERRUPT_VECTOR_DATA *, ULONG);

typedef LONG (*__anon_3262)(struct _INTERRUPT_VECTOR_DATA *, ULONG *);

// 0x60 bytes (sizeof)
typedef struct _INTERRUPT_CONNECTION_DATA {
  ULONG Count;                              // offset: 0x0 ordinal: 0x0
  struct _INTERRUPT_VECTOR_DATA Vectors[1]; // offset: 0x8 ordinal: 0x1
} _INTERRUPT_CONNECTION_DATA;

// 0xe0 bytes (sizeof)
typedef struct _INTERRUPT_TRACKING_ROOT {
  struct _LIST_ENTRY ListEntry;               // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY TrackingEntryList;       // offset: 0x10 ordinal: 0x1
  ULONG Gsiv;                                 // offset: 0x20 ordinal: 0x2
  struct _INTERRUPT_VECTOR_DATA VectorData;   // offset: 0x28 ordinal: 0x3
  enum _INTERRUPT_STEERING_MODE SteeringMode; // offset: 0x80 ordinal: 0x4
  UCHAR EnableSteering;                       // offset: 0x84 ordinal: 0x5
  struct _GROUP_AFFINITY CpuSetMask;          // offset: 0x88 ordinal: 0x6
  ULONGLONG AffinityEpoch;                    // offset: 0x98 ordinal: 0x7
  struct _GROUP_AFFINITY CurrentTarget;       // offset: 0xa0 ordinal: 0x8
  struct _GROUP_AFFINITY NextTarget;          // offset: 0xb0 ordinal: 0x9
  ULONGLONG TimeDelta;                        // offset: 0xc0 ordinal: 0xa
  VOID *RedirectHandle;                       // offset: 0xc8 ordinal: 0xb
  struct _LIST_ENTRY SteerQueueLink;          // offset: 0xd0 ordinal: 0xc
} _INTERRUPT_TRACKING_ROOT;

typedef LONG (*__anon_3281)(struct _INTERRUPT_VECTOR_DATA *,
                            struct _GROUP_AFFINITY *, ULONG *);

typedef VOID (*__anon_3248)(struct _DEVICE_OBJECT *, ULONG,
                            struct _GROUP_AFFINITY *);

typedef LONG (*__anon_3247)(struct _DEVICE_OBJECT *, struct _GROUP_AFFINITY *,
                            ULONG, enum _KINTERRUPT_MODE, UCHAR, ULONG *,
                            UCHAR *, ULONG *);

typedef LONG (*__anon_3246)(ULONG, struct _GROUP_AFFINITY *, ULONG *,
                            enum _KINTERRUPT_POLARITY *,
                            struct _INTERRUPT_REMAPPING_INFO *);

typedef LONG (*__anon_1842)(ULONGLONG, VOID *, VOID *, struct _GROUP_AFFINITY *,
                            VOID *);

typedef LONG (*__anon_1840)(ULONGLONG, VOID *, struct _GROUP_AFFINITY *,
                            VOID *);

// 0x8 bytes (sizeof)
typedef struct _EXHANDLE {
  ULONG TagBits : 2; // offset: 0x0 ordinal: 0x0
  ULONG Index : 30;  // offset: 0x0 ordinal: 0x1
  union {
    VOID *GenericHandleOverlay; // offset: 0x0 ordinal: 0x2
    ULONGLONG Value;            // offset: 0x0 ordinal: 0x3
  };
} _EXHANDLE;

// 0x40 bytes (sizeof)
typedef struct __anon_2720 {
  struct _CC_FLUSH_PACKET *FlushPacket;     // offset: 0x0 ordinal: 0x0
  struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x8 ordinal: 0x1
  struct _KEVENT FlushEvent;                // offset: 0x10 ordinal: 0x2
  struct _IO_STATUS_BLOCK IoStatus;         // offset: 0x28 ordinal: 0x3
  UCHAR DoWriteBehindPostProcessing;        // offset: 0x38 ordinal: 0x4
} __anon_2720;

// 0x10 bytes (sizeof)
typedef union __anon_2277 {
  struct _IO_STATUS_BLOCK IoStatus; // offset: 0x0 ordinal: 0x0
} __anon_2277;

// 0x18 bytes (sizeof)
typedef struct _NT_IORING_CQE {
  union {
    ULONGLONG UserData;              // offset: 0x0 ordinal: 0x0
    ULONGLONG PaddingUserDataForWow; // offset: 0x0 ordinal: 0x1
  };
  struct _IO_STATUS_BLOCK IoStatus; // offset: 0x8 ordinal: 0x2
} _NT_IORING_CQE;

// 0x20 bytes (sizeof)
typedef struct _NT_IORING_COMPLETION_QUEUE {
  ULONG Head;                       // offset: 0x0 ordinal: 0x0
  ULONG Tail;                       // offset: 0x4 ordinal: 0x1
  struct _NT_IORING_CQE Entries[1]; // offset: 0x8 ordinal: 0x2
} _NT_IORING_COMPLETION_QUEUE;

// 0x30 bytes (sizeof)
typedef struct _NT_IORING_INFO {
  enum IORING_VERSION IoRingVersion;    // offset: 0x0 ordinal: 0x0
  struct _NT_IORING_CREATE_FLAGS Flags; // offset: 0x4 ordinal: 0x1
  ULONG SubmissionQueueSize;            // offset: 0xc ordinal: 0x2
  ULONG SubmissionQueueRingMask;        // offset: 0x10 ordinal: 0x3
  ULONG CompletionQueueSize;            // offset: 0x14 ordinal: 0x4
  ULONG CompletionQueueRingMask;        // offset: 0x18 ordinal: 0x5
  struct _NT_IORING_SUBMISSION_QUEUE
      *SubmissionQueue; // offset: 0x20 ordinal: 0x6
  struct _NT_IORING_COMPLETION_QUEUE
      *CompletionQueue; // offset: 0x28 ordinal: 0x7
} _NT_IORING_INFO;

// 0x30 bytes (sizeof)
typedef struct __anon_2716 {
  struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x0 ordinal: 0x0
  struct _IO_STATUS_BLOCK *IoStatus;        // offset: 0x8 ordinal: 0x1
  struct _KEVENT CallerWaitEvent;           // offset: 0x10 ordinal: 0x2
  UCHAR IsLowPriWriteBehind;                // offset: 0x28 ordinal: 0x3
} __anon_2716;

typedef VOID (*__anon_886)(struct _DEVICE_OBJECT *, UCHAR, union _POWER_STATE,
                           VOID *, struct _IO_STATUS_BLOCK *);

// 0x40 bytes (sizeof)
typedef struct __anon_859 {
  VOID(*CallerCompletion)
  (struct _DEVICE_OBJECT *, UCHAR, union _POWER_STATE, VOID *,
   struct _IO_STATUS_BLOCK *);         // offset: 0x0 ordinal: 0x0
  VOID *CallerContext;                 // offset: 0x8 ordinal: 0x1
  struct _DEVICE_OBJECT *CallerDevice; // offset: 0x10 ordinal: 0x2
  UCHAR SystemWake;                    // offset: 0x18 ordinal: 0x3
  struct _WORK_QUEUE_ITEM
      PassiveCompletionWorkItem; // offset: 0x20 ordinal: 0x4
} __anon_859;

typedef VOID (*__anon_792)(VOID *, struct _IO_STATUS_BLOCK *, ULONG);

typedef UCHAR (*__anon_788)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                            ULONG, ULONG, VOID *, struct _MDL **,
                            struct _IO_STATUS_BLOCK *,
                            struct _COMPRESSED_DATA_INFO *, ULONG,
                            struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_785)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                            ULONG, ULONG, struct _MDL **,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_783)(struct _FILE_OBJECT *, UCHAR,
                            struct _FILE_NETWORK_OPEN_INFORMATION *,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_780)(struct _FILE_OBJECT *, UCHAR, VOID *, ULONG, VOID *,
                            ULONG, ULONG, struct _IO_STATUS_BLOCK *,
                            struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_779)(struct _FILE_OBJECT *, VOID *, ULONG,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_775)(struct _FILE_OBJECT *, UCHAR,
                            struct _FILE_STANDARD_INFORMATION *,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_774)(struct _FILE_OBJECT *, UCHAR,
                            struct _FILE_BASIC_INFORMATION *,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_773)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                            ULONG, UCHAR, ULONG, VOID *,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_772)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                            ULONG, UCHAR, ULONG, UCHAR,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

// 0x50 bytes (sizeof)
typedef struct _MACHINE_CHECK_CONTEXT {
  struct _MACHINE_FRAME MachineFrame; // offset: 0x0 ordinal: 0x0
  ULONGLONG Rax;                      // offset: 0x28 ordinal: 0x1
  ULONGLONG Rcx;                      // offset: 0x30 ordinal: 0x2
  ULONGLONG Rdx;                      // offset: 0x38 ordinal: 0x3
  ULONGLONG GsBase;                   // offset: 0x40 ordinal: 0x4
  ULONGLONG Cr3;                      // offset: 0x48 ordinal: 0x5
} _MACHINE_CHECK_CONTEXT;

// 0x40 bytes (sizeof)
typedef struct _REQUEST_MAILBOX {
  struct _REQUEST_MAILBOX *Next;         // offset: 0x0 ordinal: 0x0
  ULONGLONG RequestSummary;              // offset: 0x8 ordinal: 0x1
  struct _KREQUEST_PACKET RequestPacket; // offset: 0x10 ordinal: 0x2
  LONG *SubNodeTargetCountAddr;          // offset: 0x30 ordinal: 0x3
  LONG SubNodeTargetCount;               // offset: 0x38 ordinal: 0x4
} _REQUEST_MAILBOX;

// 0x10 bytes (sizeof)
typedef struct _KTIMER_EXPIRATION_TRACE {
  ULONGLONG InterruptTime;                 // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER PerformanceCounter; // offset: 0x8 ordinal: 0x1
} _KTIMER_EXPIRATION_TRACE;

// 0x10 bytes (sizeof)
typedef struct _PROC_IDLE_SNAP {
  ULONGLONG Time; // offset: 0x0 ordinal: 0x0
  ULONGLONG Idle; // offset: 0x8 ordinal: 0x1
} _PROC_IDLE_SNAP;

// 0x20 bytes (sizeof)
typedef struct _PPM_FFH_THROTTLE_STATE_INFO {
  UCHAR EnableLogging;                   // offset: 0x0 ordinal: 0x0
  ULONG MismatchCount;                   // offset: 0x4 ordinal: 0x1
  UCHAR Initialized;                     // offset: 0x8 ordinal: 0x2
  ULONGLONG LastValue;                   // offset: 0x10 ordinal: 0x3
  union _LARGE_INTEGER LastLogTickCount; // offset: 0x18 ordinal: 0x4
} _PPM_FFH_THROTTLE_STATE_INFO;

// 0x40 bytes (sizeof)
typedef struct _XSAVE_AREA_HEADER {
  ULONGLONG Mask;           // offset: 0x0 ordinal: 0x0
  ULONGLONG CompactionMask; // offset: 0x8 ordinal: 0x1
  ULONGLONG Reserved2[6];   // offset: 0x10 ordinal: 0x2
} _XSAVE_AREA_HEADER;

// 0xf0 bytes (sizeof)
typedef struct _KSPECIAL_REGISTERS {
  ULONGLONG Cr0;                  // offset: 0x0 ordinal: 0x0
  ULONGLONG Cr2;                  // offset: 0x8 ordinal: 0x1
  ULONGLONG Cr3;                  // offset: 0x10 ordinal: 0x2
  ULONGLONG Cr4;                  // offset: 0x18 ordinal: 0x3
  ULONGLONG KernelDr0;            // offset: 0x20 ordinal: 0x4
  ULONGLONG KernelDr1;            // offset: 0x28 ordinal: 0x5
  ULONGLONG KernelDr2;            // offset: 0x30 ordinal: 0x6
  ULONGLONG KernelDr3;            // offset: 0x38 ordinal: 0x7
  ULONGLONG KernelDr6;            // offset: 0x40 ordinal: 0x8
  ULONGLONG KernelDr7;            // offset: 0x48 ordinal: 0x9
  struct _KDESCRIPTOR Gdtr;       // offset: 0x50 ordinal: 0xa
  struct _KDESCRIPTOR Idtr;       // offset: 0x60 ordinal: 0xb
  USHORT Tr;                      // offset: 0x70 ordinal: 0xc
  USHORT Ldtr;                    // offset: 0x72 ordinal: 0xd
  ULONG MxCsr;                    // offset: 0x74 ordinal: 0xe
  ULONGLONG DebugControl;         // offset: 0x78 ordinal: 0xf
  ULONGLONG LastBranchToRip;      // offset: 0x80 ordinal: 0x10
  ULONGLONG LastBranchFromRip;    // offset: 0x88 ordinal: 0x11
  ULONGLONG LastExceptionToRip;   // offset: 0x90 ordinal: 0x12
  ULONGLONG LastExceptionFromRip; // offset: 0x98 ordinal: 0x13
  ULONGLONG Cr8;                  // offset: 0xa0 ordinal: 0x14
  ULONGLONG MsrGsBase;            // offset: 0xa8 ordinal: 0x15
  ULONGLONG MsrGsSwap;            // offset: 0xb0 ordinal: 0x16
  ULONGLONG MsrStar;              // offset: 0xb8 ordinal: 0x17
  ULONGLONG MsrLStar;             // offset: 0xc0 ordinal: 0x18
  ULONGLONG MsrCStar;             // offset: 0xc8 ordinal: 0x19
  ULONGLONG MsrSyscallMask;       // offset: 0xd0 ordinal: 0x1a
  ULONGLONG Xcr0;                 // offset: 0xd8 ordinal: 0x1b
  ULONGLONG MsrFsBase;            // offset: 0xe0 ordinal: 0x1c
  ULONGLONG SpecialPadding0;      // offset: 0xe8 ordinal: 0x1d
} _KSPECIAL_REGISTERS;

// 0x18 bytes (sizeof)
typedef struct _COUNTER_READING {
  enum _HARDWARE_COUNTER_TYPE Type; // offset: 0x0 ordinal: 0x0
  ULONG Index;                      // offset: 0x4 ordinal: 0x1
  ULONGLONG Start;                  // offset: 0x8 ordinal: 0x2
  ULONGLONG Total;                  // offset: 0x10 ordinal: 0x3
} _COUNTER_READING;

// 0x1c0 bytes (sizeof)
typedef struct _THREAD_PERFORMANCE_DATA {
  USHORT Size;                              // offset: 0x0 ordinal: 0x0
  USHORT Version;                           // offset: 0x2 ordinal: 0x1
  struct _PROCESSOR_NUMBER ProcessorNumber; // offset: 0x4 ordinal: 0x2
  ULONG ContextSwitches;                    // offset: 0x8 ordinal: 0x3
  ULONG HwCountersCount;                    // offset: 0xc ordinal: 0x4
  ULONGLONG UpdateCount;                    // offset: 0x10 ordinal: 0x5
  ULONGLONG WaitReasonBitMap;               // offset: 0x18 ordinal: 0x6
  ULONGLONG HardwareCounters;               // offset: 0x20 ordinal: 0x7
  struct _COUNTER_READING CycleTime;        // offset: 0x28 ordinal: 0x8
  struct _COUNTER_READING HwCounters[16];   // offset: 0x40 ordinal: 0x9
} _THREAD_PERFORMANCE_DATA;

// 0x10 bytes (sizeof)
typedef union _HANDLE_TABLE_ENTRY {
  LONGLONG VolatileLowValue;                      // offset: 0x0 ordinal: 0x0
  LONGLONG LowValue;                              // offset: 0x0 ordinal: 0x1
  struct _HANDLE_TABLE_ENTRY_INFO *InfoTable;     // offset: 0x0 ordinal: 0x2
  LONGLONG HighValue;                             // offset: 0x8 ordinal: 0x3
  union _HANDLE_TABLE_ENTRY *NextFreeHandleEntry; // offset: 0x8 ordinal: 0x4
  struct _EXHANDLE LeafHandleValue;               // offset: 0x8 ordinal: 0x5
  LONGLONG RefCountField;                         // offset: 0x0 ordinal: 0x6
  ULONGLONG Unlocked : 1;                         // offset: 0x0 ordinal: 0x7
  ULONGLONG RefCnt : 16;                          // offset: 0x0 ordinal: 0x8
  ULONGLONG Attributes : 3;                       // offset: 0x0 ordinal: 0x9
  ULONGLONG ObjectPointerBits : 44;               // offset: 0x0 ordinal: 0xa
  ULONG GrantedAccessBits : 25;                   // offset: 0x8 ordinal: 0xb
  ULONG NoRightsUpgrade : 1;                      // offset: 0x8 ordinal: 0xc
  ULONG Spare1 : 6;                               // offset: 0x8 ordinal: 0xd
  ULONG Spare2;                                   // offset: 0xc ordinal: 0xe
} _HANDLE_TABLE_ENTRY;

// 0x8 bytes (sizeof)
typedef struct _MMPTE_LIST {
  ULONGLONG Valid : 1;      // offset: 0x0 ordinal: 0x0
  ULONGLONG OneEntry : 1;   // offset: 0x0 ordinal: 0x1
  ULONGLONG filler0 : 2;    // offset: 0x0 ordinal: 0x2
  ULONGLONG SwizzleBit : 1; // offset: 0x0 ordinal: 0x3
  ULONGLONG Protection : 5; // offset: 0x0 ordinal: 0x4
  ULONGLONG Prototype : 1;  // offset: 0x0 ordinal: 0x5
  ULONGLONG Transition : 1; // offset: 0x0 ordinal: 0x6
  ULONGLONG filler1 : 16;   // offset: 0x0 ordinal: 0x7
  ULONGLONG NextEntry : 36; // offset: 0x0 ordinal: 0x8
} _MMPTE_LIST;

// 0x8 bytes (sizeof)
typedef struct _MMPTE_SUBSECTION {
  ULONGLONG Valid : 1;              // offset: 0x0 ordinal: 0x0
  ULONGLONG Unused0 : 2;            // offset: 0x0 ordinal: 0x1
  ULONGLONG OnStandbyLookaside : 1; // offset: 0x0 ordinal: 0x2
  ULONGLONG SwizzleBit : 1;         // offset: 0x0 ordinal: 0x3
  ULONGLONG Protection : 5;         // offset: 0x0 ordinal: 0x4
  ULONGLONG Prototype : 1;          // offset: 0x0 ordinal: 0x5
  ULONGLONG ColdPage : 1;           // offset: 0x0 ordinal: 0x6
  ULONGLONG Unused2 : 3;            // offset: 0x0 ordinal: 0x7
  ULONGLONG ExecutePrivilege : 1;   // offset: 0x0 ordinal: 0x8
  LONGLONG SubsectionAddress : 48;  // offset: 0x0 ordinal: 0x9
} _MMPTE_SUBSECTION;

// 0x8 bytes (sizeof)
typedef struct _MMPTE_TRANSITION {
  ULONGLONG Valid : 1;              // offset: 0x0 ordinal: 0x0
  ULONGLONG Write : 1;              // offset: 0x0 ordinal: 0x1
  ULONGLONG OnStandbyLookaside : 1; // offset: 0x0 ordinal: 0x2
  ULONGLONG IoTracker : 1;          // offset: 0x0 ordinal: 0x3
  ULONGLONG SwizzleBit : 1;         // offset: 0x0 ordinal: 0x4
  ULONGLONG Protection : 5;         // offset: 0x0 ordinal: 0x5
  ULONGLONG Prototype : 1;          // offset: 0x0 ordinal: 0x6
  ULONGLONG Transition : 1;         // offset: 0x0 ordinal: 0x7
  ULONGLONG PageFrameNumber : 40;   // offset: 0x0 ordinal: 0x8
  ULONGLONG Unused : 12;            // offset: 0x0 ordinal: 0x9
} _MMPTE_TRANSITION;

// 0x8 bytes (sizeof)
typedef struct _MMPTE_TIMESTAMP {
  ULONGLONG MustBeZero : 1;       // offset: 0x0 ordinal: 0x0
  ULONGLONG Unused : 3;           // offset: 0x0 ordinal: 0x1
  ULONGLONG SwizzleBit : 1;       // offset: 0x0 ordinal: 0x2
  ULONGLONG Protection : 5;       // offset: 0x0 ordinal: 0x3
  ULONGLONG Prototype : 1;        // offset: 0x0 ordinal: 0x4
  ULONGLONG Transition : 1;       // offset: 0x0 ordinal: 0x5
  ULONGLONG PageFileLow : 4;      // offset: 0x0 ordinal: 0x6
  ULONGLONG Reserved : 16;        // offset: 0x0 ordinal: 0x7
  ULONGLONG GlobalTimeStamp : 32; // offset: 0x0 ordinal: 0x8
} _MMPTE_TIMESTAMP;

// 0x8 bytes (sizeof)
typedef struct _MMPTE_SOFTWARE {
  ULONGLONG Valid : 1;                 // offset: 0x0 ordinal: 0x0
  ULONGLONG PageFileReserved : 1;      // offset: 0x0 ordinal: 0x1
  ULONGLONG PageFileAllocated : 1;     // offset: 0x0 ordinal: 0x2
  ULONGLONG ColdPage : 1;              // offset: 0x0 ordinal: 0x3
  ULONGLONG SwizzleBit : 1;            // offset: 0x0 ordinal: 0x4
  ULONGLONG Protection : 5;            // offset: 0x0 ordinal: 0x5
  ULONGLONG Prototype : 1;             // offset: 0x0 ordinal: 0x6
  ULONGLONG Transition : 1;            // offset: 0x0 ordinal: 0x7
  ULONGLONG PageFileLow : 4;           // offset: 0x0 ordinal: 0x8
  ULONGLONG UsedPageTableEntries : 10; // offset: 0x0 ordinal: 0x9
  ULONGLONG ShadowStack : 1;           // offset: 0x0 ordinal: 0xa
  ULONGLONG OnStandbyLookaside : 1;    // offset: 0x0 ordinal: 0xb
  ULONGLONG Unused : 4;                // offset: 0x0 ordinal: 0xc
  ULONGLONG PageFileHigh : 32;         // offset: 0x0 ordinal: 0xd
} _MMPTE_SOFTWARE;

// 0x8 bytes (sizeof)
typedef struct _MMPTE_PROTOTYPE {
  ULONGLONG Valid : 1;                // offset: 0x0 ordinal: 0x0
  ULONGLONG DemandFillProto : 1;      // offset: 0x0 ordinal: 0x1
  ULONGLONG HiberVerifyConverted : 1; // offset: 0x0 ordinal: 0x2
  ULONGLONG ReadOnly : 1;             // offset: 0x0 ordinal: 0x3
  ULONGLONG SwizzleBit : 1;           // offset: 0x0 ordinal: 0x4
  ULONGLONG Protection : 5;           // offset: 0x0 ordinal: 0x5
  ULONGLONG Prototype : 1;            // offset: 0x0 ordinal: 0x6
  ULONGLONG Combined : 1;             // offset: 0x0 ordinal: 0x7
  ULONGLONG Unused1 : 4;              // offset: 0x0 ordinal: 0x8
  LONGLONG ProtoAddress : 48;         // offset: 0x0 ordinal: 0x9
} _MMPTE_PROTOTYPE;

// 0x8 bytes (sizeof)
typedef struct _MMPTE_HARDWARE {
  ULONGLONG Valid : 1;               // offset: 0x0 ordinal: 0x0
  ULONGLONG Dirty1 : 1;              // offset: 0x0 ordinal: 0x1
  ULONGLONG Owner : 1;               // offset: 0x0 ordinal: 0x2
  ULONGLONG WriteThrough : 1;        // offset: 0x0 ordinal: 0x3
  ULONGLONG CacheDisable : 1;        // offset: 0x0 ordinal: 0x4
  ULONGLONG Accessed : 1;            // offset: 0x0 ordinal: 0x5
  ULONGLONG Dirty : 1;               // offset: 0x0 ordinal: 0x6
  ULONGLONG LargePage : 1;           // offset: 0x0 ordinal: 0x7
  ULONGLONG Global : 1;              // offset: 0x0 ordinal: 0x8
  ULONGLONG CopyOnWrite : 1;         // offset: 0x0 ordinal: 0x9
  ULONGLONG Unused : 1;              // offset: 0x0 ordinal: 0xa
  ULONGLONG Write : 1;               // offset: 0x0 ordinal: 0xb
  ULONGLONG PageFrameNumber : 40;    // offset: 0x0 ordinal: 0xc
  ULONGLONG ReservedForSoftware : 4; // offset: 0x0 ordinal: 0xd
  ULONGLONG WsleAge : 4;             // offset: 0x0 ordinal: 0xe
  ULONGLONG WsleProtection : 3;      // offset: 0x0 ordinal: 0xf
  ULONGLONG NoExecute : 1;           // offset: 0x0 ordinal: 0x10
} _MMPTE_HARDWARE;

// 0x8 bytes (sizeof)
typedef union _ENERGY_STATE_DURATION {
  ULONGLONG Value;      // offset: 0x0 ordinal: 0x0
  ULONG LastChangeTime; // offset: 0x0 ordinal: 0x1
  ULONG Duration : 31;  // offset: 0x4 ordinal: 0x2
  ULONG IsInState : 1;  // offset: 0x4 ordinal: 0x3
} _ENERGY_STATE_DURATION;

// 0x518 bytes (sizeof)
typedef struct _KCLOCK_TIMER_STATE {
  ULONGLONG NextTickDueTime;                      // offset: 0x0 ordinal: 0x0
  ULONG TimeIncrement;                            // offset: 0x8 ordinal: 0x1
  ULONG LastRequestedTimeIncrement;               // offset: 0xc ordinal: 0x2
  enum _KCLOCK_TIMER_ONE_SHOT_STATE OneShotState; // offset: 0x10 ordinal: 0x3
  enum _KCLOCK_TIMER_DEADLINE_TYPE
      ExpectedWakeReason; // offset: 0x14 ordinal: 0x4
  struct _KCLOCK_TIMER_DEADLINE_ENTRY
      ClockTimerEntries[7];                      // offset: 0x18 ordinal: 0x5
  UCHAR ClockActive;                             // offset: 0x88 ordinal: 0x6
  ULONG ClockTickTraceIndex;                     // offset: 0x8c ordinal: 0x7
  ULONG ClockIncrementTraceIndex;                // offset: 0x90 ordinal: 0x8
  struct _KCLOCK_TICK_TRACE ClockTickTraces[16]; // offset: 0x98 ordinal: 0x9
  struct _KCLOCK_INCREMENT_TRACE
      ClockIncrementTraces[16]; // offset: 0x318 ordinal: 0xa
} _KCLOCK_TIMER_STATE;

// 0x18 bytes (sizeof)
typedef struct _KSECURE_FAULT_INFORMATION {
  ULONGLONG FaultCode; // offset: 0x0 ordinal: 0x0
  ULONGLONG FaultVa;   // offset: 0x8 ordinal: 0x1
  ULONGLONG FaultPa;   // offset: 0x10 ordinal: 0x2
} _KSECURE_FAULT_INFORMATION;

// 0x38 bytes (sizeof)
typedef struct __anon_381 {
  ULONG UpdateCycle; // offset: 0x0 ordinal: 0x0
  union {
    SHORT PairLocal;    // offset: 0x4 ordinal: 0x1
    UCHAR PairLocalLow; // offset: 0x4 ordinal: 0x2
  };
  UCHAR PairLocalForceStibp : 1; // offset: 0x5 ordinal: 0x3
  UCHAR Reserved : 4;            // offset: 0x5 ordinal: 0x4
  UCHAR Frozen : 1;              // offset: 0x5 ordinal: 0x5
  UCHAR ForceUntrusted : 1;      // offset: 0x5 ordinal: 0x6
  UCHAR SynchIpi : 1;            // offset: 0x5 ordinal: 0x7
  union {
    SHORT PairRemote;    // offset: 0x6 ordinal: 0x8
    UCHAR PairRemoteLow; // offset: 0x6 ordinal: 0x9
  };
  UCHAR Reserved2;         // offset: 0x7 ordinal: 0xa
  UCHAR Trace[24];         // offset: 0x8 ordinal: 0xb
  ULONGLONG LocalDomain;   // offset: 0x20 ordinal: 0xc
  ULONGLONG RemoteDomain;  // offset: 0x28 ordinal: 0xd
  struct _KTHREAD *Thread; // offset: 0x30 ordinal: 0xe
} __anon_381;

// 0x20 bytes (sizeof)
typedef struct _PS_TRUSTLET_TKSESSION_ID {
  ULONGLONG SessionId[4]; // offset: 0x0 ordinal: 0x0
} _PS_TRUSTLET_TKSESSION_ID;

// 0x28 bytes (sizeof)
typedef struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION {
  enum _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE
      ConfigType; // offset: 0x0 ordinal: 0x0
  union {
    struct __anon_1737 LogicalAddressLimits; // offset: 0x8 ordinal: 0x1
    struct __anon_1738 SubSection;           // offset: 0x8 ordinal: 0x2
    enum _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE
        HardwareAccessType; // offset: 0x8 ordinal: 0x3
    ULONGLONG Reserved[4];  // offset: 0x8 ordinal: 0x4
  };
} _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;

typedef LONG (*__anon_1615)(struct _DMA_ADAPTER *, struct _MDL *,
                            struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION *,
                            ULONG, union _LARGE_INTEGER *);

// 0x140 bytes (sizeof)
typedef struct _DMA_OPERATIONS {
  ULONG Size;                                   // offset: 0x0 ordinal: 0x0
  VOID (*PutDmaAdapter)(struct _DMA_ADAPTER *); // offset: 0x8 ordinal: 0x1
  VOID *(*AllocateCommonBuffer)(struct _DMA_ADAPTER *, ULONG,
                                union _LARGE_INTEGER *,
                                UCHAR); // offset: 0x10 ordinal: 0x2
  VOID(*FreeCommonBuffer)
  (struct _DMA_ADAPTER *, ULONG, union _LARGE_INTEGER, VOID *,
   UCHAR); // offset: 0x18 ordinal: 0x3
  LONG(*AllocateAdapterChannel)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, ULONG,
   enum _IO_ALLOCATION_ACTION (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                  VOID *, VOID *),
   VOID *); // offset: 0x20 ordinal: 0x4
  UCHAR(*FlushAdapterBuffers)
  (struct _DMA_ADAPTER *, struct _MDL *, VOID *, VOID *, ULONG,
   UCHAR); // offset: 0x28 ordinal: 0x5
  VOID(*FreeAdapterChannel)
  (struct _DMA_ADAPTER *); // offset: 0x30 ordinal: 0x6
  VOID(*FreeMapRegisters)
  (struct _DMA_ADAPTER *, VOID *, ULONG); // offset: 0x38 ordinal: 0x7
  union _LARGE_INTEGER (*MapTransfer)(struct _DMA_ADAPTER *, struct _MDL *,
                                      VOID *, VOID *, ULONG *,
                                      UCHAR);      // offset: 0x40 ordinal: 0x8
  ULONG (*GetDmaAlignment)(struct _DMA_ADAPTER *); // offset: 0x48 ordinal: 0x9
  ULONG (*ReadDmaCounter)(struct _DMA_ADAPTER *);  // offset: 0x50 ordinal: 0xa
  LONG(*GetScatterGatherList)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, struct _MDL *, VOID *, ULONG,
   VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
            struct _SCATTER_GATHER_LIST *, VOID *),
   VOID *, UCHAR); // offset: 0x58 ordinal: 0xb
  VOID(*PutScatterGatherList)
  (struct _DMA_ADAPTER *, struct _SCATTER_GATHER_LIST *,
   UCHAR); // offset: 0x60 ordinal: 0xc
  LONG(*CalculateScatterGatherList)
  (struct _DMA_ADAPTER *, struct _MDL *, VOID *, ULONG, ULONG *,
   ULONG *); // offset: 0x68 ordinal: 0xd
  LONG(*BuildScatterGatherList)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, struct _MDL *, VOID *, ULONG,
   VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
            struct _SCATTER_GATHER_LIST *, VOID *),
   VOID *, UCHAR, VOID *, ULONG); // offset: 0x70 ordinal: 0xe
  LONG(*BuildMdlFromScatterGatherList)
  (struct _DMA_ADAPTER *, struct _SCATTER_GATHER_LIST *, struct _MDL *,
   struct _MDL **); // offset: 0x78 ordinal: 0xf
  LONG(*GetDmaAdapterInfo)
  (struct _DMA_ADAPTER *,
   struct _DMA_ADAPTER_INFO *); // offset: 0x80 ordinal: 0x10
  LONG(*GetDmaTransferInfo)
  (struct _DMA_ADAPTER *, struct _MDL *, ULONGLONG, ULONG, UCHAR,
   struct _DMA_TRANSFER_INFO *); // offset: 0x88 ordinal: 0x11
  LONG(*InitializeDmaTransferContext)
  (struct _DMA_ADAPTER *, VOID *); // offset: 0x90 ordinal: 0x12
  VOID *(*AllocateCommonBufferEx)(struct _DMA_ADAPTER *, union _LARGE_INTEGER *,
                                  ULONG, union _LARGE_INTEGER *, UCHAR,
                                  ULONG); // offset: 0x98 ordinal: 0x13
  LONG(*AllocateAdapterChannelEx)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *, ULONG, ULONG,
   enum _IO_ALLOCATION_ACTION (*)(struct _DEVICE_OBJECT *, struct _IRP *,
                                  VOID *, VOID *),
   VOID *, VOID **); // offset: 0xa0 ordinal: 0x14
  LONG(*ConfigureAdapterChannel)
  (struct _DMA_ADAPTER *, ULONG, VOID *); // offset: 0xa8 ordinal: 0x15
  UCHAR(*CancelAdapterChannel)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *,
   VOID *); // offset: 0xb0 ordinal: 0x16
  LONG(*MapTransferEx)
  (struct _DMA_ADAPTER *, struct _MDL *, VOID *, ULONGLONG, ULONG, ULONG *,
   UCHAR, struct _SCATTER_GATHER_LIST *, ULONG,
   VOID (*)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *,
            enum DMA_COMPLETION_STATUS),
   VOID *); // offset: 0xb8 ordinal: 0x17
  LONG(*GetScatterGatherListEx)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *, struct _MDL *,
   ULONGLONG, ULONG, ULONG,
   VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
            struct _SCATTER_GATHER_LIST *, VOID *),
   VOID *, UCHAR,
   VOID (*)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *,
            enum DMA_COMPLETION_STATUS),
   VOID *, struct _SCATTER_GATHER_LIST **); // offset: 0xc0 ordinal: 0x18
  LONG(*BuildScatterGatherListEx)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *, struct _MDL *,
   ULONGLONG, ULONG, ULONG,
   VOID (*)(struct _DEVICE_OBJECT *, struct _IRP *,
            struct _SCATTER_GATHER_LIST *, VOID *),
   VOID *, UCHAR, VOID *, ULONG,
   VOID (*)(struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *,
            enum DMA_COMPLETION_STATUS),
   VOID *, VOID *); // offset: 0xc8 ordinal: 0x19
  LONG(*FlushAdapterBuffersEx)
  (struct _DMA_ADAPTER *, struct _MDL *, VOID *, ULONGLONG, ULONG,
   UCHAR); // offset: 0xd0 ordinal: 0x1a
  VOID(*FreeAdapterObject)
  (struct _DMA_ADAPTER *,
   enum _IO_ALLOCATION_ACTION); // offset: 0xd8 ordinal: 0x1b
  LONG(*CancelMappedTransfer)
  (struct _DMA_ADAPTER *, VOID *); // offset: 0xe0 ordinal: 0x1c
  LONG(*AllocateDomainCommonBuffer)
  (struct _DMA_ADAPTER *, VOID *, union _LARGE_INTEGER *, ULONG, ULONG,
   enum _MEMORY_CACHING_TYPE *, ULONG, union _LARGE_INTEGER *,
   VOID **); // offset: 0xe8 ordinal: 0x1d
  LONG(*FlushDmaBuffer)
  (struct _DMA_ADAPTER *, struct _MDL *, UCHAR); // offset: 0xf0 ordinal: 0x1e
  LONG(*JoinDmaDomain)
  (struct _DMA_ADAPTER *, VOID *);               // offset: 0xf8 ordinal: 0x1f
  LONG (*LeaveDmaDomain)(struct _DMA_ADAPTER *); // offset: 0x100 ordinal: 0x20
  VOID *(*GetDmaDomain)(struct _DMA_ADAPTER *);  // offset: 0x108 ordinal: 0x21
  VOID *(*AllocateCommonBufferWithBounds)(
      struct _DMA_ADAPTER *, union _LARGE_INTEGER *, union _LARGE_INTEGER *,
      ULONG, ULONG, enum _MEMORY_CACHING_TYPE *, ULONG,
      union _LARGE_INTEGER *); // offset: 0x110 ordinal: 0x22
  LONG(*AllocateCommonBufferVector)
  (struct _DMA_ADAPTER *, union _LARGE_INTEGER, union _LARGE_INTEGER,
   enum _MEMORY_CACHING_TYPE, ULONG, ULONG, ULONG, ULONGLONG,
   struct _DMA_COMMON_BUFFER_VECTOR **); // offset: 0x118 ordinal: 0x23
  VOID(*GetCommonBufferFromVectorByIndex)
  (struct _DMA_ADAPTER *, struct _DMA_COMMON_BUFFER_VECTOR *, ULONG, VOID **,
   union _LARGE_INTEGER *); // offset: 0x120 ordinal: 0x24
  VOID(*FreeCommonBufferFromVector)
  (struct _DMA_ADAPTER *, struct _DMA_COMMON_BUFFER_VECTOR *,
   ULONG); // offset: 0x128 ordinal: 0x25
  VOID(*FreeCommonBufferVector)
  (struct _DMA_ADAPTER *,
   struct _DMA_COMMON_BUFFER_VECTOR *); // offset: 0x130 ordinal: 0x26
  LONG(*CreateCommonBufferFromMdl)
  (struct _DMA_ADAPTER *, struct _MDL *,
   struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION *, ULONG,
   union _LARGE_INTEGER *); // offset: 0x138 ordinal: 0x27
} _DMA_OPERATIONS;

// 0x40 bytes (sizeof)
typedef struct _VSM_PERFORMANCE_DATA {
  ULONGLONG LaunchVsmMark[8]; // offset: 0x0 ordinal: 0x0
} _VSM_PERFORMANCE_DATA;

// 0x68 bytes (sizeof)
typedef struct _KTSS64 {
  ULONG Reserved0;     // offset: 0x0 ordinal: 0x0
  ULONGLONG Rsp0;      // offset: 0x4 ordinal: 0x1
  ULONGLONG Rsp1;      // offset: 0xc ordinal: 0x2
  ULONGLONG Rsp2;      // offset: 0x14 ordinal: 0x3
  ULONGLONG Ist[8];    // offset: 0x1c ordinal: 0x4
  ULONGLONG Reserved1; // offset: 0x5c ordinal: 0x5
  USHORT Reserved2;    // offset: 0x64 ordinal: 0x6
  USHORT IoMapBase;    // offset: 0x66 ordinal: 0x7
} _KTSS64;

// 0x380 bytes (sizeof)
typedef struct _KSHARED_READY_QUEUE_HETERO_STATISTICS {
  ULONGLONG ExpectedRuntimeByClass[7][2][8]; // offset: 0x0 ordinal: 0x0
} _KSHARED_READY_QUEUE_HETERO_STATISTICS;

// 0xa0 bytes (sizeof)
typedef struct _PEBS_DS_SAVE_AREA64 {
  ULONGLONG BtsBufferBase;            // offset: 0x0 ordinal: 0x0
  ULONGLONG BtsIndex;                 // offset: 0x8 ordinal: 0x1
  ULONGLONG BtsAbsoluteMaximum;       // offset: 0x10 ordinal: 0x2
  ULONGLONG BtsInterruptThreshold;    // offset: 0x18 ordinal: 0x3
  ULONGLONG PebsBufferBase;           // offset: 0x20 ordinal: 0x4
  ULONGLONG PebsIndex;                // offset: 0x28 ordinal: 0x5
  ULONGLONG PebsAbsoluteMaximum;      // offset: 0x30 ordinal: 0x6
  ULONGLONG PebsInterruptThreshold;   // offset: 0x38 ordinal: 0x7
  ULONGLONG PebsGpCounterReset[8];    // offset: 0x40 ordinal: 0x8
  ULONGLONG PebsFixedCounterReset[4]; // offset: 0x80 ordinal: 0x9
} _PEBS_DS_SAVE_AREA64;

// 0x80 bytes (sizeof)
typedef struct _PEBS_DS_SAVE_AREA32 {
  ULONG BtsBufferBase;                // offset: 0x0 ordinal: 0x0
  ULONG BtsIndex;                     // offset: 0x4 ordinal: 0x1
  ULONG BtsAbsoluteMaximum;           // offset: 0x8 ordinal: 0x2
  ULONG BtsInterruptThreshold;        // offset: 0xc ordinal: 0x3
  ULONG PebsBufferBase;               // offset: 0x10 ordinal: 0x4
  ULONG PebsIndex;                    // offset: 0x14 ordinal: 0x5
  ULONG PebsAbsoluteMaximum;          // offset: 0x18 ordinal: 0x6
  ULONG PebsInterruptThreshold;       // offset: 0x1c ordinal: 0x7
  ULONGLONG PebsGpCounterReset[8];    // offset: 0x20 ordinal: 0x8
  ULONGLONG PebsFixedCounterReset[4]; // offset: 0x60 ordinal: 0x9
} _PEBS_DS_SAVE_AREA32;

// 0xa0 bytes (sizeof)
typedef struct _PEBS_DS_SAVE_AREA {
  union {
    struct _PEBS_DS_SAVE_AREA32 As32Bit; // offset: 0x0 ordinal: 0x0
    struct _PEBS_DS_SAVE_AREA64 As64Bit; // offset: 0x0 ordinal: 0x1
  };
} _PEBS_DS_SAVE_AREA;

// 0xa0 bytes (sizeof)
typedef struct _PROCESSOR_PROFILE_CONTROL_AREA {
  struct _PEBS_DS_SAVE_AREA PebsDsSaveArea; // offset: 0x0 ordinal: 0x0
} _PROCESSOR_PROFILE_CONTROL_AREA;

// 0x60 bytes (sizeof)
typedef struct _POP_FX_ACTIVE_TIME_ACCOUNTING {
  ULONGLONG Total;        // offset: 0x0 ordinal: 0x0
  ULONGLONG Unattributed; // offset: 0x8 ordinal: 0x1
  ULONGLONG Buckets[5];   // offset: 0x10 ordinal: 0x2
  ULONGLONG PerBucket[5]; // offset: 0x38 ordinal: 0x3
} _POP_FX_ACTIVE_TIME_ACCOUNTING;

// 0xe0 bytes (sizeof)
typedef struct _POP_FX_ACCOUNTING {
  ULONGLONG Lock;                              // offset: 0x0 ordinal: 0x0
  UCHAR Active;                                // offset: 0x8 ordinal: 0x1
  ULONG DripsRequiredState;                    // offset: 0xc ordinal: 0x2
  enum _POP_FX_ACCOUNTING_MODE AccountingMode; // offset: 0x10 ordinal: 0x3
  ULONGLONG ActiveStamp;                       // offset: 0x18 ordinal: 0x4
  struct _POP_FX_ACTIVE_TIME_ACCOUNTING
      CsActiveTimeAccounting; // offset: 0x20 ordinal: 0x5
  struct _POP_FX_ACTIVE_TIME_ACCOUNTING
      CsCriticalActiveTimeAccounting; // offset: 0x80 ordinal: 0x6
} _POP_FX_ACCOUNTING;

// 0x8 bytes (sizeof)
typedef union __anon_323 {
  ULONGLONG Long;                    // offset: 0x0 ordinal: 0x0
  ULONGLONG VolatileLong;            // offset: 0x0 ordinal: 0x1
  struct _MMPTE_HARDWARE Hard;       // offset: 0x0 ordinal: 0x2
  struct _MMPTE_PROTOTYPE Proto;     // offset: 0x0 ordinal: 0x3
  struct _MMPTE_SOFTWARE Soft;       // offset: 0x0 ordinal: 0x4
  struct _MMPTE_TIMESTAMP TimeStamp; // offset: 0x0 ordinal: 0x5
  struct _MMPTE_TRANSITION Trans;    // offset: 0x0 ordinal: 0x6
  struct _MMPTE_SUBSECTION Subsect;  // offset: 0x0 ordinal: 0x7
  struct _MMPTE_LIST List;           // offset: 0x0 ordinal: 0x8
} __anon_323;

// 0x8 bytes (sizeof)
typedef struct _MMPTE {
  union __anon_323 u; // offset: 0x0 ordinal: 0x0
} _MMPTE;

// 0x20 bytes (sizeof)
typedef struct _MMCLONE_BLOCK {
  struct _MMPTE ProtoPte;             // offset: 0x0 ordinal: 0x0
  ULONGLONG CrossPartitionReferences; // offset: 0x8 ordinal: 0x1
  union __anon_2135 u1;               // offset: 0x10 ordinal: 0x2
  ULONGLONG UseCount;                 // offset: 0x18 ordinal: 0x3
} _MMCLONE_BLOCK;

// 0x28 bytes (sizeof)
typedef struct _MI_DRIVER_VA {
  struct _MI_DRIVER_VA *Next; // offset: 0x0 ordinal: 0x0
  struct _MMPTE *PointerPte;  // offset: 0x8 ordinal: 0x1
  struct _RTL_BITMAP BitMap;  // offset: 0x10 ordinal: 0x2
  ULONG Hint;                 // offset: 0x20 ordinal: 0x3
  ULONG Flags;                // offset: 0x24 ordinal: 0x4
} _MI_DRIVER_VA;

// 0x48 bytes (sizeof)
typedef struct _MI_PROCESS_STATE {
  VOID *SystemDllBase;                         // offset: 0x0 ordinal: 0x0
  ULONG ColorSeed;                             // offset: 0x8 ordinal: 0x1
  LONG RotatingUniprocessorNumber;             // offset: 0xc ordinal: 0x2
  union _LARGE_INTEGER CriticalSectionTimeout; // offset: 0x10 ordinal: 0x3
  struct _LIST_ENTRY ProcessList;              // offset: 0x18 ordinal: 0x4
  struct _MMPTE *SharedUserDataPte[2];         // offset: 0x28 ordinal: 0x5
  VOID *HypervisorSharedVa;                    // offset: 0x38 ordinal: 0x6
  ULONGLONG VadSecureCookie;                   // offset: 0x40 ordinal: 0x7
} _MI_PROCESS_STATE;

// 0x118 bytes (sizeof)
typedef struct _MI_DEBUGGER_STATE {
  UCHAR TransientWrite;    // offset: 0x0 ordinal: 0x0
  UCHAR CodePageEdited;    // offset: 0x1 ordinal: 0x1
  struct _MMPTE *DebugPte; // offset: 0x8 ordinal: 0x2
  ULONG PoisonedTb;        // offset: 0x10 ordinal: 0x3
  LONG InDebugger;         // offset: 0x14 ordinal: 0x4
  VOID *Pfns[32];          // offset: 0x18 ordinal: 0x5
} _MI_DEBUGGER_STATE;

// 0x10 bytes (sizeof)
typedef struct _MI_PAGE_HASH {
  ULONG HashValue;          // offset: 0x0 ordinal: 0x0
  ULONG PageFileOffset;     // offset: 0x4 ordinal: 0x1
  struct _MMPTE *OwningPte; // offset: 0x8 ordinal: 0x2
} _MI_PAGE_HASH;

// 0x10 bytes (sizeof)
typedef struct __anon_320 {
  ULONGLONG Depth : 16;     // offset: 0x0 ordinal: 0x0
  ULONGLONG Sequence : 48;  // offset: 0x0 ordinal: 0x1
  ULONGLONG Reserved : 4;   // offset: 0x8 ordinal: 0x2
  ULONGLONG NextEntry : 60; // offset: 0x8 ordinal: 0x3
} __anon_320;

// 0x8 bytes (sizeof)
typedef union _KLOCK_ENTRY_BOOST_BITMAP {
  ULONGLONG AllFields;                   // offset: 0x0 ordinal: 0x0
  ULONG AllBoosts;                       // offset: 0x0 ordinal: 0x1
  ULONG WaiterCounts;                    // offset: 0x4 ordinal: 0x2
  ULONG CpuBoostsBitmap : 30;            // offset: 0x0 ordinal: 0x3
  ULONG IoBoost : 1;                     // offset: 0x0 ordinal: 0x4
  ULONG IoQoSBoost : 1;                  // offset: 0x0 ordinal: 0x5
  ULONG IoNormalPriorityWaiterCount : 8; // offset: 0x4 ordinal: 0x6
  ULONG IoQoSWaiterCount : 7;            // offset: 0x4 ordinal: 0x7
} _KLOCK_ENTRY_BOOST_BITMAP;

// 0x10 bytes (sizeof)
typedef struct _KLOCK_ENTRY_LOCK_STATE {
  ULONGLONG CrossThreadReleasable : 1; // offset: 0x0 ordinal: 0x0
  ULONGLONG Busy : 1;                  // offset: 0x0 ordinal: 0x1
  ULONGLONG Reserved : 61;             // offset: 0x0 ordinal: 0x2
  ULONGLONG InTree : 1;                // offset: 0x0 ordinal: 0x3
  VOID *LockState;                     // offset: 0x0 ordinal: 0x4
  union {
    VOID *SessionState; // offset: 0x8 ordinal: 0x5
    ULONG SessionId;    // offset: 0x8 ordinal: 0x6
  };
  ULONG SessionPad; // offset: 0xc ordinal: 0x7
} _KLOCK_ENTRY_LOCK_STATE;

// 0x10 bytes (sizeof)
typedef struct _M128A {
  ULONGLONG Low; // offset: 0x0 ordinal: 0x0
  LONGLONG High; // offset: 0x8 ordinal: 0x1
} _M128A;

// 0x140 bytes (sizeof)
typedef struct _KEXCEPTION_FRAME {
  ULONGLONG P1Home;       // offset: 0x0 ordinal: 0x0
  ULONGLONG P2Home;       // offset: 0x8 ordinal: 0x1
  ULONGLONG P3Home;       // offset: 0x10 ordinal: 0x2
  ULONGLONG P4Home;       // offset: 0x18 ordinal: 0x3
  ULONGLONG P5;           // offset: 0x20 ordinal: 0x4
  ULONGLONG Spare1;       // offset: 0x28 ordinal: 0x5
  struct _M128A Xmm6;     // offset: 0x30 ordinal: 0x6
  struct _M128A Xmm7;     // offset: 0x40 ordinal: 0x7
  struct _M128A Xmm8;     // offset: 0x50 ordinal: 0x8
  struct _M128A Xmm9;     // offset: 0x60 ordinal: 0x9
  struct _M128A Xmm10;    // offset: 0x70 ordinal: 0xa
  struct _M128A Xmm11;    // offset: 0x80 ordinal: 0xb
  struct _M128A Xmm12;    // offset: 0x90 ordinal: 0xc
  struct _M128A Xmm13;    // offset: 0xa0 ordinal: 0xd
  struct _M128A Xmm14;    // offset: 0xb0 ordinal: 0xe
  struct _M128A Xmm15;    // offset: 0xc0 ordinal: 0xf
  ULONGLONG TrapFrame;    // offset: 0xd0 ordinal: 0x10
  ULONGLONG OutputBuffer; // offset: 0xd8 ordinal: 0x11
  ULONGLONG OutputLength; // offset: 0xe0 ordinal: 0x12
  ULONGLONG Spare2;       // offset: 0xe8 ordinal: 0x13
  ULONGLONG MxCsr;        // offset: 0xf0 ordinal: 0x14
  ULONGLONG Rbp;          // offset: 0xf8 ordinal: 0x15
  ULONGLONG Rbx;          // offset: 0x100 ordinal: 0x16
  ULONGLONG Rdi;          // offset: 0x108 ordinal: 0x17
  ULONGLONG Rsi;          // offset: 0x110 ordinal: 0x18
  ULONGLONG R12;          // offset: 0x118 ordinal: 0x19
  ULONGLONG R13;          // offset: 0x120 ordinal: 0x1a
  ULONGLONG R14;          // offset: 0x128 ordinal: 0x1b
  ULONGLONG R15;          // offset: 0x130 ordinal: 0x1c
  ULONGLONG Return;       // offset: 0x138 ordinal: 0x1d
} _KEXCEPTION_FRAME;

// 0x200 bytes (sizeof)
typedef struct _XSAVE_FORMAT {
  USHORT ControlWord;              // offset: 0x0 ordinal: 0x0
  USHORT StatusWord;               // offset: 0x2 ordinal: 0x1
  UCHAR TagWord;                   // offset: 0x4 ordinal: 0x2
  UCHAR Reserved1;                 // offset: 0x5 ordinal: 0x3
  USHORT ErrorOpcode;              // offset: 0x6 ordinal: 0x4
  ULONG ErrorOffset;               // offset: 0x8 ordinal: 0x5
  USHORT ErrorSelector;            // offset: 0xc ordinal: 0x6
  USHORT Reserved2;                // offset: 0xe ordinal: 0x7
  ULONG DataOffset;                // offset: 0x10 ordinal: 0x8
  USHORT DataSelector;             // offset: 0x14 ordinal: 0x9
  USHORT Reserved3;                // offset: 0x16 ordinal: 0xa
  ULONG MxCsr;                     // offset: 0x18 ordinal: 0xb
  ULONG MxCsr_Mask;                // offset: 0x1c ordinal: 0xc
  struct _M128A FloatRegisters[8]; // offset: 0x20 ordinal: 0xd
  struct _M128A XmmRegisters[16];  // offset: 0xa0 ordinal: 0xe
  UCHAR Reserved4[96];             // offset: 0x1a0 ordinal: 0xf
} _XSAVE_FORMAT;

// 0x240 bytes (sizeof)
typedef struct _XSAVE_AREA {
  struct _XSAVE_FORMAT LegacyState; // offset: 0x0 ordinal: 0x0
  struct _XSAVE_AREA_HEADER Header; // offset: 0x200 ordinal: 0x1
} _XSAVE_AREA;

// 0x20 bytes (sizeof)
typedef struct _XSTATE_CONTEXT {
  ULONGLONG Mask;           // offset: 0x0 ordinal: 0x0
  ULONG Length;             // offset: 0x8 ordinal: 0x1
  ULONG Reserved1;          // offset: 0xc ordinal: 0x2
  struct _XSAVE_AREA *Area; // offset: 0x10 ordinal: 0x3
  VOID *Buffer;             // offset: 0x18 ordinal: 0x4
} _XSTATE_CONTEXT;

// 0x38 bytes (sizeof)
typedef struct _XSTATE_SAVE {
  struct _XSTATE_SAVE *Prev;            // offset: 0x0 ordinal: 0x0
  struct _KTHREAD *Thread;              // offset: 0x8 ordinal: 0x1
  UCHAR Level;                          // offset: 0x10 ordinal: 0x2
  struct _XSTATE_CONTEXT XStateContext; // offset: 0x18 ordinal: 0x3
} _XSTATE_SAVE;

// 0x8 bytes (sizeof)
typedef union _TIMELINE_BITMAP {
  ULONGLONG Value; // offset: 0x0 ordinal: 0x0
  ULONG EndTime;   // offset: 0x0 ordinal: 0x1
  ULONG Bitmap;    // offset: 0x4 ordinal: 0x2
} _TIMELINE_BITMAP;

// 0xa0 bytes (sizeof)
typedef struct _PROCESS_ENERGY_VALUES_EXTENSION {
  union {
    union _TIMELINE_BITMAP Timelines[14]; // offset: 0x0 ordinal: 0x0
    union _TIMELINE_BITMAP CpuTimeline;   // offset: 0x0 ordinal: 0x1
  };
  union _TIMELINE_BITMAP DiskTimeline;           // offset: 0x8 ordinal: 0x2
  union _TIMELINE_BITMAP NetworkTimeline;        // offset: 0x10 ordinal: 0x3
  union _TIMELINE_BITMAP MBBTimeline;            // offset: 0x18 ordinal: 0x4
  union _TIMELINE_BITMAP ForegroundTimeline;     // offset: 0x20 ordinal: 0x5
  union _TIMELINE_BITMAP DesktopVisibleTimeline; // offset: 0x28 ordinal: 0x6
  union _TIMELINE_BITMAP
      CompositionRenderedTimeline; // offset: 0x30 ordinal: 0x7
  union _TIMELINE_BITMAP
      CompositionDirtyGeneratedTimeline; // offset: 0x38 ordinal: 0x8
  union _TIMELINE_BITMAP
      CompositionDirtyPropagatedTimeline;         // offset: 0x40 ordinal: 0x9
  union _TIMELINE_BITMAP InputTimeline;           // offset: 0x48 ordinal: 0xa
  union _TIMELINE_BITMAP AudioInTimeline;         // offset: 0x50 ordinal: 0xb
  union _TIMELINE_BITMAP AudioOutTimeline;        // offset: 0x58 ordinal: 0xc
  union _TIMELINE_BITMAP DisplayRequiredTimeline; // offset: 0x60 ordinal: 0xd
  union _TIMELINE_BITMAP KeyboardInputTimeline;   // offset: 0x68 ordinal: 0xe
  union {
    union _ENERGY_STATE_DURATION Durations[5];  // offset: 0x70 ordinal: 0xf
    union _ENERGY_STATE_DURATION InputDuration; // offset: 0x70 ordinal: 0x10
  };
  union _ENERGY_STATE_DURATION AudioInDuration;  // offset: 0x78 ordinal: 0x11
  union _ENERGY_STATE_DURATION AudioOutDuration; // offset: 0x80 ordinal: 0x12
  union _ENERGY_STATE_DURATION
      DisplayRequiredDuration; // offset: 0x88 ordinal: 0x13
  union _ENERGY_STATE_DURATION
      PSMBackgroundDuration; // offset: 0x90 ordinal: 0x14
  ULONG KeyboardInput;       // offset: 0x98 ordinal: 0x15
  ULONG MouseInput;          // offset: 0x9c ordinal: 0x16
} _PROCESS_ENERGY_VALUES_EXTENSION;

// 0x28 bytes (sizeof)
typedef struct _KDEVICE_QUEUE {
  SHORT Type;                        // offset: 0x0 ordinal: 0x0
  SHORT Size;                        // offset: 0x2 ordinal: 0x1
  struct _LIST_ENTRY DeviceListHead; // offset: 0x8 ordinal: 0x2
  ULONGLONG Lock;                    // offset: 0x18 ordinal: 0x3
  union {
    UCHAR Busy;            // offset: 0x20 ordinal: 0x4
    LONGLONG Reserved : 8; // offset: 0x20 ordinal: 0x5
  };
  LONGLONG Hint : 56; // offset: 0x20 ordinal: 0x6
} _KDEVICE_QUEUE;

// 0x48 bytes (sizeof)
typedef struct _CONTROLLER_OBJECT {
  SHORT Type;                            // offset: 0x0 ordinal: 0x0
  SHORT Size;                            // offset: 0x2 ordinal: 0x1
  VOID *ControllerExtension;             // offset: 0x8 ordinal: 0x2
  struct _KDEVICE_QUEUE DeviceWaitQueue; // offset: 0x10 ordinal: 0x3
  ULONG Spare1;                          // offset: 0x38 ordinal: 0x4
  union _LARGE_INTEGER Spare2;           // offset: 0x40 ordinal: 0x5
} _CONTROLLER_OBJECT;

// 0x1a8 bytes (sizeof)
typedef struct _KTHREAD_COUNTERS {
  ULONGLONG WaitReasonBitMap;                // offset: 0x0 ordinal: 0x0
  struct _THREAD_PERFORMANCE_DATA *UserData; // offset: 0x8 ordinal: 0x1
  ULONG Flags;                               // offset: 0x10 ordinal: 0x2
  ULONG ContextSwitches;                     // offset: 0x14 ordinal: 0x3
  ULONGLONG CycleTimeBias;                   // offset: 0x18 ordinal: 0x4
  ULONGLONG HardwareCounters;                // offset: 0x20 ordinal: 0x5
  struct _COUNTER_READING HwCounter[16];     // offset: 0x28 ordinal: 0x6
} _KTHREAD_COUNTERS;

// 0x190 bytes (sizeof)
typedef struct _KTRAP_FRAME {
  ULONGLONG P1Home; // offset: 0x0 ordinal: 0x0
  ULONGLONG P2Home; // offset: 0x8 ordinal: 0x1
  ULONGLONG P3Home; // offset: 0x10 ordinal: 0x2
  ULONGLONG P4Home; // offset: 0x18 ordinal: 0x3
  ULONGLONG P5;     // offset: 0x20 ordinal: 0x4
  union {
    CHAR PreviousMode;             // offset: 0x28 ordinal: 0x5
    UCHAR InterruptRetpolineState; // offset: 0x28 ordinal: 0x6
  };
  UCHAR PreviousIrql; // offset: 0x29 ordinal: 0x7
  union {
    UCHAR FaultIndicator; // offset: 0x2a ordinal: 0x8
    UCHAR NmiMsrIbrs;     // offset: 0x2a ordinal: 0x9
  };
  UCHAR ExceptionActive; // offset: 0x2b ordinal: 0xa
  ULONG MxCsr;           // offset: 0x2c ordinal: 0xb
  ULONGLONG Rax;         // offset: 0x30 ordinal: 0xc
  ULONGLONG Rcx;         // offset: 0x38 ordinal: 0xd
  ULONGLONG Rdx;         // offset: 0x40 ordinal: 0xe
  ULONGLONG R8;          // offset: 0x48 ordinal: 0xf
  ULONGLONG R9;          // offset: 0x50 ordinal: 0x10
  ULONGLONG R10;         // offset: 0x58 ordinal: 0x11
  ULONGLONG R11;         // offset: 0x60 ordinal: 0x12
  union {
    ULONGLONG GsBase; // offset: 0x68 ordinal: 0x13
    ULONGLONG GsSwap; // offset: 0x68 ordinal: 0x14
  };
  struct _M128A Xmm0; // offset: 0x70 ordinal: 0x15
  struct _M128A Xmm1; // offset: 0x80 ordinal: 0x16
  struct _M128A Xmm2; // offset: 0x90 ordinal: 0x17
  struct _M128A Xmm3; // offset: 0xa0 ordinal: 0x18
  struct _M128A Xmm4; // offset: 0xb0 ordinal: 0x19
  struct _M128A Xmm5; // offset: 0xc0 ordinal: 0x1a
  union {
    ULONGLONG FaultAddress;  // offset: 0xd0 ordinal: 0x1b
    ULONGLONG ContextRecord; // offset: 0xd0 ordinal: 0x1c
  };
  ULONGLONG Dr0;                  // offset: 0xd8 ordinal: 0x1d
  ULONGLONG Dr1;                  // offset: 0xe0 ordinal: 0x1e
  ULONGLONG Dr2;                  // offset: 0xe8 ordinal: 0x1f
  ULONGLONG Dr3;                  // offset: 0xf0 ordinal: 0x20
  ULONGLONG Dr6;                  // offset: 0xf8 ordinal: 0x21
  ULONGLONG Dr7;                  // offset: 0x100 ordinal: 0x22
  ULONGLONG ShadowStackFrame;     // offset: 0xd8 ordinal: 0x23
  ULONGLONG Spare[5];             // offset: 0xe0 ordinal: 0x24
  ULONGLONG DebugControl;         // offset: 0x108 ordinal: 0x25
  ULONGLONG LastBranchToRip;      // offset: 0x110 ordinal: 0x26
  ULONGLONG LastBranchFromRip;    // offset: 0x118 ordinal: 0x27
  ULONGLONG LastExceptionToRip;   // offset: 0x120 ordinal: 0x28
  ULONGLONG LastExceptionFromRip; // offset: 0x128 ordinal: 0x29
  USHORT SegDs;                   // offset: 0x130 ordinal: 0x2a
  USHORT SegEs;                   // offset: 0x132 ordinal: 0x2b
  USHORT SegFs;                   // offset: 0x134 ordinal: 0x2c
  USHORT SegGs;                   // offset: 0x136 ordinal: 0x2d
  ULONGLONG TrapFrame;            // offset: 0x138 ordinal: 0x2e
  ULONGLONG Rbx;                  // offset: 0x140 ordinal: 0x2f
  ULONGLONG Rdi;                  // offset: 0x148 ordinal: 0x30
  ULONGLONG Rsi;                  // offset: 0x150 ordinal: 0x31
  ULONGLONG Rbp;                  // offset: 0x158 ordinal: 0x32
  union {
    ULONGLONG ErrorCode;      // offset: 0x160 ordinal: 0x33
    ULONGLONG ExceptionFrame; // offset: 0x160 ordinal: 0x34
  };
  ULONGLONG Rip;   // offset: 0x168 ordinal: 0x35
  USHORT SegCs;    // offset: 0x170 ordinal: 0x36
  UCHAR Fill0;     // offset: 0x172 ordinal: 0x37
  UCHAR Logging;   // offset: 0x173 ordinal: 0x38
  USHORT Fill1[2]; // offset: 0x174 ordinal: 0x39
  ULONG EFlags;    // offset: 0x178 ordinal: 0x3a
  ULONG Fill2;     // offset: 0x17c ordinal: 0x3b
  ULONGLONG Rsp;   // offset: 0x180 ordinal: 0x3c
  USHORT SegSs;    // offset: 0x188 ordinal: 0x3d
  USHORT Fill3;    // offset: 0x18a ordinal: 0x3e
  ULONG Fill4;     // offset: 0x18c ordinal: 0x3f
} _KTRAP_FRAME;

// 0x40 bytes (sizeof)
typedef struct _KDPC {
  union {
    ULONG TargetInfoAsUlong; // offset: 0x0 ordinal: 0x0
    UCHAR Type;              // offset: 0x0 ordinal: 0x1
  };
  UCHAR Importance;                       // offset: 0x1 ordinal: 0x2
  USHORT Number;                          // offset: 0x2 ordinal: 0x3
  struct _SINGLE_LIST_ENTRY DpcListEntry; // offset: 0x8 ordinal: 0x4
  ULONGLONG ProcessorHistory;             // offset: 0x10 ordinal: 0x5
  VOID(*DeferredRoutine)
  (struct _KDPC *, VOID *, VOID *, VOID *); // offset: 0x18 ordinal: 0x6
  VOID *DeferredContext;                    // offset: 0x20 ordinal: 0x7
  VOID *SystemArgument1;                    // offset: 0x28 ordinal: 0x8
  VOID *SystemArgument2;                    // offset: 0x30 ordinal: 0x9
  VOID *DpcData;                            // offset: 0x38 ordinal: 0xa
} _KDPC;

// 0x88 bytes (sizeof)
typedef struct _WHEAP_WORK_QUEUE {
  struct _LIST_ENTRY ListHead;      // offset: 0x0 ordinal: 0x0
  ULONGLONG ListLock;               // offset: 0x10 ordinal: 0x1
  LONG ItemCount;                   // offset: 0x18 ordinal: 0x2
  struct _KDPC Dpc;                 // offset: 0x20 ordinal: 0x3
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x60 ordinal: 0x4
  VOID(*WorkRoutine)
  (struct _WHEAP_WORK_QUEUE *,
   struct _LIST_ENTRY *); // offset: 0x80 ordinal: 0x5
} _WHEAP_WORK_QUEUE;

typedef VOID (*__anon_3015)(struct _WHEAP_WORK_QUEUE *, struct _LIST_ENTRY *);

// 0x18 bytes (sizeof)
typedef struct _WHEAP_INFO_BLOCK {
  ULONG ErrorSourceCount; // offset: 0x0 ordinal: 0x0
  struct _WHEAP_ERROR_SOURCE_TABLE
      *ErrorSourceTable;               // offset: 0x8 ordinal: 0x1
  struct _WHEAP_WORK_QUEUE *WorkQueue; // offset: 0x10 ordinal: 0x2
} _WHEAP_INFO_BLOCK;

// 0x30 bytes (sizeof)
typedef struct _KDPC_DATA {
  struct _KDPC_LIST DpcList; // offset: 0x0 ordinal: 0x0
  ULONGLONG DpcLock;         // offset: 0x10 ordinal: 0x1
  LONG DpcQueueDepth;        // offset: 0x18 ordinal: 0x2
  ULONG DpcCount;            // offset: 0x1c ordinal: 0x3
  struct _KDPC *ActiveDpc;   // offset: 0x20 ordinal: 0x4
  ULONG LongDpcPresent;      // offset: 0x28 ordinal: 0x5
  ULONG Padding;             // offset: 0x2c ordinal: 0x6
} _KDPC_DATA;

// 0x680 bytes (sizeof)
typedef struct _KSHARED_READY_QUEUE {
  ULONGLONG Lock;                                // offset: 0x0 ordinal: 0x0
  ULONG ReadySummary;                            // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY ReadyListHead[32];          // offset: 0x10 ordinal: 0x2
  union _KPRIORITY_STATE RunningSummary[64];     // offset: 0x210 ordinal: 0x3
  union _KHETERO_STATE HeteroRunningSummary[64]; // offset: 0x250 ordinal: 0x4
  UCHAR Span;                                    // offset: 0x290 ordinal: 0x5
  UCHAR LowProcIndex;                            // offset: 0x291 ordinal: 0x6
  UCHAR QueueIndex;                              // offset: 0x292 ordinal: 0x7
  UCHAR NormalPriorityQueueIndex;                // offset: 0x293 ordinal: 0x8
  UCHAR ProcCount;                               // offset: 0x294 ordinal: 0x9
  UCHAR ScanOwner;                               // offset: 0x295 ordinal: 0xa
  UCHAR Spare1[2];                               // offset: 0x296 ordinal: 0xb
  ULONGLONG Affinity;                            // offset: 0x298 ordinal: 0xc
  ULONG ReadyThreadCount;                        // offset: 0x2a0 ordinal: 0xd
  UCHAR SoftParkElectionScheduled;               // offset: 0x2a4 ordinal: 0xe
  UCHAR Spare2[3];                               // offset: 0x2a5 ordinal: 0xf
  ULONGLONG ReadyQueueExpectedRunTime;           // offset: 0x2a8 ordinal: 0x10
  ULONGLONG SoftParkElectionGeneration;          // offset: 0x2b0 ordinal: 0x11
  ULONGLONG SoftParkElectionRunTime;             // offset: 0x2b8 ordinal: 0x12
  struct _KDPC SoftParkElectionDpc;              // offset: 0x2c0 ordinal: 0x13
  struct _KSHARED_READY_QUEUE_HETERO_STATISTICS
      SoftParkElectionHeteroStats; // offset: 0x300 ordinal: 0x14
} _KSHARED_READY_QUEUE;

// 0x50 bytes (sizeof)
typedef struct _KSINGLE_DPC_SOFT_TIMEOUT_EVENT_INFO {
  struct _KDPC EventDpc; // offset: 0x0 ordinal: 0x0
  VOID *DeferredRoutine; // offset: 0x40 ordinal: 0x1
  ULONG TickCount;       // offset: 0x48 ordinal: 0x2
} _KSINGLE_DPC_SOFT_TIMEOUT_EVENT_INFO;

// 0x158 bytes (sizeof)
typedef struct _KENTROPY_TIMING_STATE {
  ULONG EntropyCount;          // offset: 0x0 ordinal: 0x0
  ULONG Buffer[64];            // offset: 0x4 ordinal: 0x1
  struct _KDPC Dpc;            // offset: 0x108 ordinal: 0x2
  ULONG LastDeliveredBuffer;   // offset: 0x148 ordinal: 0x3
  VOID *ReservedRawDataBuffer; // offset: 0x150 ordinal: 0x4
} _KENTROPY_TIMING_STATE;

typedef VOID (*__anon_432)(struct _KDPC *, VOID *, VOID *, VOID *);

// 0x48 bytes (sizeof)
typedef struct _WAIT_CONTEXT_BLOCK {
  union {
    struct _KDEVICE_QUEUE_ENTRY WaitQueueEntry; // offset: 0x0 ordinal: 0x0
    struct _LIST_ENTRY DmaWaitEntry;            // offset: 0x0 ordinal: 0x1
  };
  ULONG NumberOfChannels;        // offset: 0x10 ordinal: 0x2
  ULONG SyncCallback : 1;        // offset: 0x14 ordinal: 0x3
  ULONG DmaContext : 1;          // offset: 0x14 ordinal: 0x4
  ULONG ZeroMapRegisters : 1;    // offset: 0x14 ordinal: 0x5
  ULONG Reserved : 9;            // offset: 0x14 ordinal: 0x6
  ULONG NumberOfRemapPages : 20; // offset: 0x14 ordinal: 0x7
  enum _IO_ALLOCATION_ACTION (*DeviceRoutine)(
      struct _DEVICE_OBJECT *, struct _IRP *, VOID *,
      VOID *);                     // offset: 0x18 ordinal: 0x8
  VOID *DeviceContext;             // offset: 0x20 ordinal: 0x9
  ULONG NumberOfMapRegisters;      // offset: 0x28 ordinal: 0xa
  VOID *DeviceObject;              // offset: 0x30 ordinal: 0xb
  VOID *CurrentIrp;                // offset: 0x38 ordinal: 0xc
  struct _KDPC *BufferChainingDpc; // offset: 0x40 ordinal: 0xd
} _WAIT_CONTEXT_BLOCK;

// 0x58 bytes (sizeof)
typedef struct _DMA_TRANSFER_CONTEXT_V1 {
  LONG DmaState;                  // offset: 0x0 ordinal: 0x0
  ULONG TransferState;            // offset: 0x4 ordinal: 0x1
  struct _WAIT_CONTEXT_BLOCK Wcb; // offset: 0x8 ordinal: 0x2
  VOID *HalWcb;                   // offset: 0x50 ordinal: 0x3
} _DMA_TRANSFER_CONTEXT_V1;

// 0x60 bytes (sizeof)
typedef struct _DMA_TRANSFER_CONTEXT {
  ULONG Version;                      // offset: 0x0 ordinal: 0x0
  struct _DMA_TRANSFER_CONTEXT_V1 V1; // offset: 0x8 ordinal: 0x1
} _DMA_TRANSFER_CONTEXT;

// 0x48 bytes (sizeof)
typedef union __anon_289 {
  struct _LIST_ENTRY ListEntry;   // offset: 0x0 ordinal: 0x0
  struct _WAIT_CONTEXT_BLOCK Wcb; // offset: 0x0 ordinal: 0x1
} __anon_289;

// 0x30 bytes (sizeof)
typedef struct _KWAIT_BLOCK {
  struct _LIST_ENTRY WaitListEntry; // offset: 0x0 ordinal: 0x0
  UCHAR WaitType;                   // offset: 0x10 ordinal: 0x1
  UCHAR BlockState;                 // offset: 0x11 ordinal: 0x2
  USHORT WaitKey;                   // offset: 0x12 ordinal: 0x3
  LONG SpareLong;                   // offset: 0x14 ordinal: 0x4
  union {
    struct _KTHREAD *Thread;           // offset: 0x18 ordinal: 0x5
    struct _KQUEUE *NotificationQueue; // offset: 0x18 ordinal: 0x6
    struct _KDPC *Dpc;                 // offset: 0x18 ordinal: 0x7
  };
  VOID *Object;   // offset: 0x20 ordinal: 0x8
  VOID *SparePtr; // offset: 0x28 ordinal: 0x9
} _KWAIT_BLOCK;

// 0x10 bytes (sizeof)
typedef union _SLIST_HEADER {
  ULONGLONG Alignment;         // offset: 0x0 ordinal: 0x0
  ULONGLONG Region;            // offset: 0x8 ordinal: 0x1
  struct __anon_320 HeaderX64; // offset: 0x0 ordinal: 0x2
} _SLIST_HEADER;

// 0x40 bytes (sizeof)
typedef struct _MI_ALIGNED_SLIST {
  union _SLIST_HEADER SList; // offset: 0x0 ordinal: 0x0
} _MI_ALIGNED_SLIST;

// 0x200 bytes (sizeof)
typedef struct _MI_ULTRA_MDL_NODE {
  struct _MI_ALIGNED_SLIST UltraMdlMaps[8]; // offset: 0x0 ordinal: 0x0
} _MI_ULTRA_MDL_NODE;

// 0x130 bytes (sizeof)
typedef struct _VF_TARGET_VERIFIED_DRIVER_DATA {
  struct _VF_SUSPECT_DRIVER_ENTRY
      *SuspectDriverEntry;               // offset: 0x0 ordinal: 0x0
  VOID *WMICallback;                     // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY EtwHandlesListHead; // offset: 0x10 ordinal: 0x2
  union __anon_3134 u1;                  // offset: 0x20 ordinal: 0x3
  ULONGLONG Signature;                   // offset: 0x28 ordinal: 0x4
  UCHAR SeSigningLevel;                  // offset: 0x30 ordinal: 0x5
  union _SLIST_HEADER PoolPageHeaders;   // offset: 0x40 ordinal: 0x6
  union _SLIST_HEADER PoolTrackers;      // offset: 0x50 ordinal: 0x7
  struct _LIST_ENTRY
      DifPluginPerDriverDataContextHead;       // offset: 0x60 ordinal: 0x8
  ULONG CurrentPagedPoolAllocations;           // offset: 0x70 ordinal: 0x9
  ULONG CurrentNonPagedPoolAllocations;        // offset: 0x74 ordinal: 0xa
  ULONG PeakPagedPoolAllocations;              // offset: 0x78 ordinal: 0xb
  ULONG PeakNonPagedPoolAllocations;           // offset: 0x7c ordinal: 0xc
  ULONGLONG PagedBytes;                        // offset: 0x80 ordinal: 0xd
  ULONGLONG NonPagedBytes;                     // offset: 0x88 ordinal: 0xe
  ULONGLONG PeakPagedBytes;                    // offset: 0x90 ordinal: 0xf
  ULONGLONG PeakNonPagedBytes;                 // offset: 0x98 ordinal: 0x10
  ULONG RaiseIrqls;                            // offset: 0xa0 ordinal: 0x11
  ULONG AcquireSpinLocks;                      // offset: 0xa4 ordinal: 0x12
  ULONG SynchronizeExecutions;                 // offset: 0xa8 ordinal: 0x13
  ULONG AllocationsWithNoTag;                  // offset: 0xac ordinal: 0x14
  ULONG AllocationsFailed;                     // offset: 0xb0 ordinal: 0x15
  ULONG AllocationsFailedDeliberately;         // offset: 0xb4 ordinal: 0x16
  ULONGLONG LockedBytes;                       // offset: 0xb8 ordinal: 0x17
  ULONGLONG PeakLockedBytes;                   // offset: 0xc0 ordinal: 0x18
  ULONGLONG MappedLockedBytes;                 // offset: 0xc8 ordinal: 0x19
  ULONGLONG PeakMappedLockedBytes;             // offset: 0xd0 ordinal: 0x1a
  ULONGLONG MappedIoSpaceBytes;                // offset: 0xd8 ordinal: 0x1b
  ULONGLONG PeakMappedIoSpaceBytes;            // offset: 0xe0 ordinal: 0x1c
  ULONGLONG PagesForMdlBytes;                  // offset: 0xe8 ordinal: 0x1d
  ULONGLONG PeakPagesForMdlBytes;              // offset: 0xf0 ordinal: 0x1e
  ULONGLONG ContiguousMemoryBytes;             // offset: 0xf8 ordinal: 0x1f
  ULONGLONG PeakContiguousMemoryBytes;         // offset: 0x100 ordinal: 0x20
  struct _LIST_ENTRY ContiguousMemoryListHead; // offset: 0x108 ordinal: 0x21
  ULONG ExecutePoolTypes;                      // offset: 0x118 ordinal: 0x22
  ULONG ExecutePageProtections;                // offset: 0x11c ordinal: 0x23
  ULONG ExecutePageMappings;                   // offset: 0x120 ordinal: 0x24
  ULONG ExecuteWriteSections;                  // offset: 0x124 ordinal: 0x25
  ULONG SectionAlignmentFailures;              // offset: 0x128 ordinal: 0x26
  ULONG IATInExecutableSection;                // offset: 0x12c ordinal: 0x27
} _VF_TARGET_VERIFIED_DRIVER_DATA;

// 0x40 bytes (sizeof)
typedef struct _RTL_LOOKASIDE {
  union _SLIST_HEADER ListHead; // offset: 0x0 ordinal: 0x0
  USHORT Depth;                 // offset: 0x10 ordinal: 0x1
  USHORT MaximumDepth;          // offset: 0x12 ordinal: 0x2
  ULONG TotalAllocates;         // offset: 0x14 ordinal: 0x3
  ULONG AllocateMisses;         // offset: 0x18 ordinal: 0x4
  ULONG TotalFrees;             // offset: 0x1c ordinal: 0x5
  ULONG FreeMisses;             // offset: 0x20 ordinal: 0x6
  ULONG LastTotalAllocates;     // offset: 0x24 ordinal: 0x7
  ULONG LastAllocateMisses;     // offset: 0x28 ordinal: 0x8
  ULONG LastTotalFrees;         // offset: 0x2c ordinal: 0x9
} _RTL_LOOKASIDE;

// 0x1040 bytes (sizeof)
typedef struct _RTL_DYNAMIC_LOOKASIDE {
  ULONGLONG EnabledBucketBitmap;     // offset: 0x0 ordinal: 0x0
  ULONG BucketCount;                 // offset: 0x8 ordinal: 0x1
  ULONG ActiveBucketCount;           // offset: 0xc ordinal: 0x2
  struct _RTL_LOOKASIDE Buckets[64]; // offset: 0x40 ordinal: 0x3
} _RTL_DYNAMIC_LOOKASIDE;

// 0x10 bytes (sizeof)
typedef struct _HEAP_VS_DELAY_FREE_CONTEXT {
  union _SLIST_HEADER ListHead; // offset: 0x0 ordinal: 0x0
} _HEAP_VS_DELAY_FREE_CONTEXT;

// 0xc0 bytes (sizeof)
typedef struct _HEAP_VS_CONTEXT {
  ULONGLONG Lock;                    // offset: 0x0 ordinal: 0x0
  enum _RTLP_HP_LOCK_TYPE LockType;  // offset: 0x8 ordinal: 0x1
  struct _RTL_RB_TREE FreeChunkTree; // offset: 0x10 ordinal: 0x2
  struct _LIST_ENTRY SubsegmentList; // offset: 0x20 ordinal: 0x3
  ULONGLONG TotalCommittedUnits;     // offset: 0x30 ordinal: 0x4
  ULONGLONG FreeCommittedUnits;      // offset: 0x38 ordinal: 0x5
  struct _HEAP_VS_DELAY_FREE_CONTEXT
      DelayFreeContext;                          // offset: 0x40 ordinal: 0x6
  VOID *BackendCtx;                              // offset: 0x80 ordinal: 0x7
  struct _HEAP_SUBALLOCATOR_CALLBACKS Callbacks; // offset: 0x88 ordinal: 0x8
  struct _RTL_HP_VS_CONFIG Config;               // offset: 0xb0 ordinal: 0x9
  ULONG Flags;                                   // offset: 0xb4 ordinal: 0xa
} _HEAP_VS_CONTEXT;

// 0x840 bytes (sizeof)
typedef struct _SEGMENT_HEAP {
  struct RTL_HP_ENV_HANDLE EnvHandle; // offset: 0x0 ordinal: 0x0
  ULONG Signature;                    // offset: 0x10 ordinal: 0x1
  ULONG GlobalFlags;                  // offset: 0x14 ordinal: 0x2
  ULONG Interceptor;                  // offset: 0x18 ordinal: 0x3
  USHORT ProcessHeapListIndex;        // offset: 0x1c ordinal: 0x4
  USHORT AllocatedFromMetadata : 1;   // offset: 0x1e ordinal: 0x5
  union {
    struct _RTL_HEAP_MEMORY_LIMIT_DATA
        CommitLimitData;           // offset: 0x20 ordinal: 0x6
    ULONGLONG ReservedMustBeZero1; // offset: 0x20 ordinal: 0x7
  };
  VOID *UserContext;                          // offset: 0x28 ordinal: 0x8
  ULONGLONG ReservedMustBeZero2;              // offset: 0x30 ordinal: 0x9
  VOID *Spare;                                // offset: 0x38 ordinal: 0xa
  ULONGLONG LargeMetadataLock;                // offset: 0x40 ordinal: 0xb
  struct _RTL_RB_TREE LargeAllocMetadata;     // offset: 0x48 ordinal: 0xc
  ULONGLONG LargeReservedPages;               // offset: 0x58 ordinal: 0xd
  ULONGLONG LargeCommittedPages;              // offset: 0x60 ordinal: 0xe
  ULONGLONG Tag;                              // offset: 0x68 ordinal: 0xf
  union _RTL_RUN_ONCE StackTraceInitVar;      // offset: 0x70 ordinal: 0x10
  struct _HEAP_RUNTIME_MEMORY_STATS MemStats; // offset: 0x80 ordinal: 0x11
  USHORT GlobalLockCount;                     // offset: 0xd8 ordinal: 0x12
  ULONG GlobalLockOwner;                      // offset: 0xdc ordinal: 0x13
  ULONGLONG ContextExtendLock;                // offset: 0xe0 ordinal: 0x14
  UCHAR *AllocatedBase;                       // offset: 0xe8 ordinal: 0x15
  UCHAR *UncommittedBase;                     // offset: 0xf0 ordinal: 0x16
  UCHAR *ReservedLimit;                       // offset: 0xf8 ordinal: 0x17
  UCHAR *ReservedRegionEnd;                   // offset: 0x100 ordinal: 0x18
  struct _RTL_HP_HEAP_VA_CALLBACKS_ENCODED
      CallbacksEncoded;                    // offset: 0x108 ordinal: 0x19
  struct _HEAP_SEG_CONTEXT SegContexts[2]; // offset: 0x140 ordinal: 0x1a
  struct _HEAP_VS_CONTEXT VsContext;       // offset: 0x2c0 ordinal: 0x1b
  struct _HEAP_LFH_CONTEXT LfhContext;     // offset: 0x380 ordinal: 0x1c
} _SEGMENT_HEAP;

// 0x20c0 bytes (sizeof)
typedef struct _EX_HEAP_POOL_NODE {
  struct _SEGMENT_HEAP *Heaps[4];              // offset: 0x0 ordinal: 0x0
  struct _RTL_DYNAMIC_LOOKASIDE Lookasides[2]; // offset: 0x40 ordinal: 0x1
} _EX_HEAP_POOL_NODE;

// 0x10 bytes (sizeof)
typedef struct _RTLP_HP_METADATA_HEAP_CTX {
  struct _SEGMENT_HEAP *Heap;   // offset: 0x0 ordinal: 0x0
  union _RTL_RUN_ONCE InitOnce; // offset: 0x8 ordinal: 0x1
} _RTLP_HP_METADATA_HEAP_CTX;

// 0x20 bytes (sizeof)
typedef struct _CACHED_KSTACK_LIST {
  union _SLIST_HEADER SListHead; // offset: 0x0 ordinal: 0x0
  LONG MinimumFree;              // offset: 0x10 ordinal: 0x1
  ULONG Misses;                  // offset: 0x14 ordinal: 0x2
  ULONG MissesLast;              // offset: 0x18 ordinal: 0x3
  UCHAR AllStacksInUse;          // offset: 0x1c ordinal: 0x4
  UCHAR NonIdealStacksPresent;   // offset: 0x1d ordinal: 0x5
  UCHAR Spare[2];                // offset: 0x1e ordinal: 0x6
} _CACHED_KSTACK_LIST;

// 0xa0 bytes (sizeof)
typedef struct _ETW_STACK_TRACE_BLOCK {
  union _LARGE_INTEGER RelatedTimestamp; // offset: 0x0 ordinal: 0x0
  struct _ETHREAD *Thread;               // offset: 0x8 ordinal: 0x1
  struct _KDPC StackWalkDpc;             // offset: 0x10 ordinal: 0x2
  ULONGLONG ApcSpinLock;                 // offset: 0x50 ordinal: 0x3
  union _SLIST_HEADER ApcFreeListHead;   // offset: 0x60 ordinal: 0x4
  union _SLIST_HEADER ApcGlobalListHead; // offset: 0x70 ordinal: 0x5
  LONG ApcCount;                         // offset: 0x80 ordinal: 0x6
  ULONG MinimumApcCount;                 // offset: 0x84 ordinal: 0x7
  ULONG MaximumApcCount;                 // offset: 0x88 ordinal: 0x8
  LONG Flags;                            // offset: 0x8c ordinal: 0x9
  LONG OutstandingApcCount;              // offset: 0x90 ordinal: 0xa
  LONG MaxOutstandingApcCount;           // offset: 0x94 ordinal: 0xb
} _ETW_STACK_TRACE_BLOCK;

// 0x80 bytes (sizeof)
typedef struct _GENERAL_LOOKASIDE {
  union {
    union _SLIST_HEADER ListHead;             // offset: 0x0 ordinal: 0x0
    struct _SINGLE_LIST_ENTRY SingleListHead; // offset: 0x0 ordinal: 0x1
  };
  USHORT Depth;         // offset: 0x10 ordinal: 0x2
  USHORT MaximumDepth;  // offset: 0x12 ordinal: 0x3
  ULONG TotalAllocates; // offset: 0x14 ordinal: 0x4
  union {
    ULONG AllocateMisses; // offset: 0x18 ordinal: 0x5
    ULONG AllocateHits;   // offset: 0x18 ordinal: 0x6
  };
  ULONG TotalFrees; // offset: 0x1c ordinal: 0x7
  union {
    ULONG FreeMisses; // offset: 0x20 ordinal: 0x8
    ULONG FreeHits;   // offset: 0x20 ordinal: 0x9
  };
  enum _POOL_TYPE Type; // offset: 0x24 ordinal: 0xa
  ULONG Tag;            // offset: 0x28 ordinal: 0xb
  ULONG Size;           // offset: 0x2c ordinal: 0xc
  union {
    VOID *(*AllocateEx)(
        enum _POOL_TYPE, ULONGLONG, ULONG,
        struct _LOOKASIDE_LIST_EX *); // offset: 0x30 ordinal: 0xd
    VOID *(*Allocate)(enum _POOL_TYPE, ULONGLONG,
                      ULONG); // offset: 0x30 ordinal: 0xe
  };
  union {
    VOID(*FreeEx)
    (VOID *, struct _LOOKASIDE_LIST_EX *); // offset: 0x38 ordinal: 0xf
    VOID (*Free)(VOID *);                  // offset: 0x38 ordinal: 0x10
  };
  struct _LIST_ENTRY ListEntry; // offset: 0x40 ordinal: 0x11
  ULONG LastTotalAllocates;     // offset: 0x50 ordinal: 0x12
  union {
    ULONG LastAllocateMisses; // offset: 0x54 ordinal: 0x13
    ULONG LastAllocateHits;   // offset: 0x54 ordinal: 0x14
  };
  ULONG Future[2]; // offset: 0x58 ordinal: 0x15
} _GENERAL_LOOKASIDE;

// 0x80 bytes (sizeof)
typedef struct _PAGED_LOOKASIDE_LIST {
  struct _GENERAL_LOOKASIDE L; // offset: 0x0 ordinal: 0x0
} _PAGED_LOOKASIDE_LIST;

// 0x80 bytes (sizeof)
typedef struct _NPAGED_LOOKASIDE_LIST {
  struct _GENERAL_LOOKASIDE L; // offset: 0x0 ordinal: 0x0
} _NPAGED_LOOKASIDE_LIST;

// 0x10 bytes (sizeof)
typedef struct _PP_LOOKASIDE_LIST {
  struct _GENERAL_LOOKASIDE *P; // offset: 0x0 ordinal: 0x0
  struct _GENERAL_LOOKASIDE *L; // offset: 0x8 ordinal: 0x1
} _PP_LOOKASIDE_LIST;

// 0x60 bytes (sizeof)
typedef struct _GENERAL_LOOKASIDE_POOL {
  union {
    union _SLIST_HEADER ListHead;             // offset: 0x0 ordinal: 0x0
    struct _SINGLE_LIST_ENTRY SingleListHead; // offset: 0x0 ordinal: 0x1
  };
  USHORT Depth;         // offset: 0x10 ordinal: 0x2
  USHORT MaximumDepth;  // offset: 0x12 ordinal: 0x3
  ULONG TotalAllocates; // offset: 0x14 ordinal: 0x4
  union {
    ULONG AllocateMisses; // offset: 0x18 ordinal: 0x5
    ULONG AllocateHits;   // offset: 0x18 ordinal: 0x6
  };
  ULONG TotalFrees; // offset: 0x1c ordinal: 0x7
  union {
    ULONG FreeMisses; // offset: 0x20 ordinal: 0x8
    ULONG FreeHits;   // offset: 0x20 ordinal: 0x9
  };
  enum _POOL_TYPE Type; // offset: 0x24 ordinal: 0xa
  ULONG Tag;            // offset: 0x28 ordinal: 0xb
  ULONG Size;           // offset: 0x2c ordinal: 0xc
  union {
    VOID *(*AllocateEx)(
        enum _POOL_TYPE, ULONGLONG, ULONG,
        struct _LOOKASIDE_LIST_EX *); // offset: 0x30 ordinal: 0xd
    VOID *(*Allocate)(enum _POOL_TYPE, ULONGLONG,
                      ULONG); // offset: 0x30 ordinal: 0xe
  };
  union {
    VOID(*FreeEx)
    (VOID *, struct _LOOKASIDE_LIST_EX *); // offset: 0x38 ordinal: 0xf
    VOID (*Free)(VOID *);                  // offset: 0x38 ordinal: 0x10
  };
  struct _LIST_ENTRY ListEntry; // offset: 0x40 ordinal: 0x11
  ULONG LastTotalAllocates;     // offset: 0x50 ordinal: 0x12
  union {
    ULONG LastAllocateMisses; // offset: 0x54 ordinal: 0x13
    ULONG LastAllocateHits;   // offset: 0x54 ordinal: 0x14
  };
  ULONG Future[2]; // offset: 0x58 ordinal: 0x15
} _GENERAL_LOOKASIDE_POOL;

// 0x60 bytes (sizeof)
typedef struct _LOOKASIDE_LIST_EX {
  struct _GENERAL_LOOKASIDE_POOL L; // offset: 0x0 ordinal: 0x0
} _LOOKASIDE_LIST_EX;

typedef VOID (*__anon_613)(VOID *, struct _LOOKASIDE_LIST_EX *);

typedef VOID *(*__anon_611)(enum _POOL_TYPE, ULONGLONG, ULONG,
                            struct _LOOKASIDE_LIST_EX *);

// 0x28 bytes (sizeof)
typedef struct _RTL_CRITICAL_SECTION {
  struct _RTL_CRITICAL_SECTION_DEBUG *DebugInfo; // offset: 0x0 ordinal: 0x0
  LONG LockCount;                                // offset: 0x8 ordinal: 0x1
  LONG RecursionCount;                           // offset: 0xc ordinal: 0x2
  VOID *OwningThread;                            // offset: 0x10 ordinal: 0x3
  VOID *LockSemaphore;                           // offset: 0x18 ordinal: 0x4
  ULONGLONG SpinCount;                           // offset: 0x20 ordinal: 0x5
} _RTL_CRITICAL_SECTION;

// 0x30 bytes (sizeof)
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
  USHORT Type;                                   // offset: 0x0 ordinal: 0x0
  USHORT CreatorBackTraceIndex;                  // offset: 0x2 ordinal: 0x1
  struct _RTL_CRITICAL_SECTION *CriticalSection; // offset: 0x8 ordinal: 0x2
  struct _LIST_ENTRY ProcessLocksList;           // offset: 0x10 ordinal: 0x3
  ULONG EntryCount;                              // offset: 0x20 ordinal: 0x4
  ULONG ContentionCount;                         // offset: 0x24 ordinal: 0x5
  ULONG Flags;                                   // offset: 0x28 ordinal: 0x6
  USHORT CreatorBackTraceIndexHigh;              // offset: 0x2c ordinal: 0x7
  USHORT Identifier;                             // offset: 0x2e ordinal: 0x8
} _RTL_CRITICAL_SECTION_DEBUG;

// 0x50 bytes (sizeof)
typedef struct _IO_MINI_COMPLETION_PACKET_USER {
  struct _LIST_ENTRY ListEntry;  // offset: 0x0 ordinal: 0x0
  ULONG PacketType;              // offset: 0x10 ordinal: 0x1
  VOID *KeyContext;              // offset: 0x18 ordinal: 0x2
  VOID *ApcContext;              // offset: 0x20 ordinal: 0x3
  LONG IoStatus;                 // offset: 0x28 ordinal: 0x4
  ULONGLONG IoStatusInformation; // offset: 0x30 ordinal: 0x5
  VOID(*MiniPacketCallback)
  (struct _IO_MINI_COMPLETION_PACKET_USER *,
   VOID *);        // offset: 0x38 ordinal: 0x6
  VOID *Context;   // offset: 0x40 ordinal: 0x7
  UCHAR Allocated; // offset: 0x48 ordinal: 0x8
} _IO_MINI_COMPLETION_PACKET_USER;

// 0x18 bytes (sizeof)
typedef struct _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY {
  struct _SINGLE_LIST_ENTRY ListEntry;            // offset: 0x0 ordinal: 0x0
  struct _IO_MINI_COMPLETION_PACKET_USER *Packet; // offset: 0x8 ordinal: 0x1
  struct _ALPC_COMPLETION_PACKET_LOOKASIDE
      *Lookaside; // offset: 0x10 ordinal: 0x2
} _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY;

// 0x50 bytes (sizeof)
typedef struct _ALPC_COMPLETION_PACKET_LOOKASIDE {
  ULONGLONG Lock;                         // offset: 0x0 ordinal: 0x0
  ULONG Size;                             // offset: 0x8 ordinal: 0x1
  ULONG ActiveCount;                      // offset: 0xc ordinal: 0x2
  ULONG PendingNullCount;                 // offset: 0x10 ordinal: 0x3
  ULONG PendingCheckCompletionListCount;  // offset: 0x14 ordinal: 0x4
  ULONG PendingDelete;                    // offset: 0x18 ordinal: 0x5
  struct _SINGLE_LIST_ENTRY FreeListHead; // offset: 0x20 ordinal: 0x6
  struct _KQUEUE *CompletionPort;         // offset: 0x28 ordinal: 0x7
  VOID *CompletionKey;                    // offset: 0x30 ordinal: 0x8
  struct _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY
      Entry[1]; // offset: 0x38 ordinal: 0x9
} _ALPC_COMPLETION_PACKET_LOOKASIDE;

typedef VOID (*__anon_400)(struct _IO_MINI_COMPLETION_PACKET_USER *, VOID *);

// 0x10 bytes (sizeof)
typedef struct _OWNER_ENTRY {
  ULONGLONG OwnerThread;          // offset: 0x0 ordinal: 0x0
  ULONG IoPriorityBoosted : 1;    // offset: 0x8 ordinal: 0x1
  ULONG OwnerReferenced : 1;      // offset: 0x8 ordinal: 0x2
  ULONG IoQoSPriorityBoosted : 1; // offset: 0x8 ordinal: 0x3
  ULONG OwnerCount : 29;          // offset: 0x8 ordinal: 0x4
  ULONG TableSize;                // offset: 0x8 ordinal: 0x5
} _OWNER_ENTRY;

// 0x4d0 bytes (sizeof)
typedef struct _CONTEXT {
  ULONGLONG P1Home;   // offset: 0x0 ordinal: 0x0
  ULONGLONG P2Home;   // offset: 0x8 ordinal: 0x1
  ULONGLONG P3Home;   // offset: 0x10 ordinal: 0x2
  ULONGLONG P4Home;   // offset: 0x18 ordinal: 0x3
  ULONGLONG P5Home;   // offset: 0x20 ordinal: 0x4
  ULONGLONG P6Home;   // offset: 0x28 ordinal: 0x5
  ULONG ContextFlags; // offset: 0x30 ordinal: 0x6
  ULONG MxCsr;        // offset: 0x34 ordinal: 0x7
  USHORT SegCs;       // offset: 0x38 ordinal: 0x8
  USHORT SegDs;       // offset: 0x3a ordinal: 0x9
  USHORT SegEs;       // offset: 0x3c ordinal: 0xa
  USHORT SegFs;       // offset: 0x3e ordinal: 0xb
  USHORT SegGs;       // offset: 0x40 ordinal: 0xc
  USHORT SegSs;       // offset: 0x42 ordinal: 0xd
  ULONG EFlags;       // offset: 0x44 ordinal: 0xe
  ULONGLONG Dr0;      // offset: 0x48 ordinal: 0xf
  ULONGLONG Dr1;      // offset: 0x50 ordinal: 0x10
  ULONGLONG Dr2;      // offset: 0x58 ordinal: 0x11
  ULONGLONG Dr3;      // offset: 0x60 ordinal: 0x12
  ULONGLONG Dr6;      // offset: 0x68 ordinal: 0x13
  ULONGLONG Dr7;      // offset: 0x70 ordinal: 0x14
  ULONGLONG Rax;      // offset: 0x78 ordinal: 0x15
  ULONGLONG Rcx;      // offset: 0x80 ordinal: 0x16
  ULONGLONG Rdx;      // offset: 0x88 ordinal: 0x17
  ULONGLONG Rbx;      // offset: 0x90 ordinal: 0x18
  ULONGLONG Rsp;      // offset: 0x98 ordinal: 0x19
  ULONGLONG Rbp;      // offset: 0xa0 ordinal: 0x1a
  ULONGLONG Rsi;      // offset: 0xa8 ordinal: 0x1b
  ULONGLONG Rdi;      // offset: 0xb0 ordinal: 0x1c
  ULONGLONG R8;       // offset: 0xb8 ordinal: 0x1d
  ULONGLONG R9;       // offset: 0xc0 ordinal: 0x1e
  ULONGLONG R10;      // offset: 0xc8 ordinal: 0x1f
  ULONGLONG R11;      // offset: 0xd0 ordinal: 0x20
  ULONGLONG R12;      // offset: 0xd8 ordinal: 0x21
  ULONGLONG R13;      // offset: 0xe0 ordinal: 0x22
  ULONGLONG R14;      // offset: 0xe8 ordinal: 0x23
  ULONGLONG R15;      // offset: 0xf0 ordinal: 0x24
  ULONGLONG Rip;      // offset: 0xf8 ordinal: 0x25
  union {
    struct _XSAVE_FORMAT FltSave; // offset: 0x100 ordinal: 0x26
    struct _M128A Header[2];      // offset: 0x100 ordinal: 0x27
  };
  struct _M128A Legacy[8];          // offset: 0x120 ordinal: 0x28
  struct _M128A Xmm0;               // offset: 0x1a0 ordinal: 0x29
  struct _M128A Xmm1;               // offset: 0x1b0 ordinal: 0x2a
  struct _M128A Xmm2;               // offset: 0x1c0 ordinal: 0x2b
  struct _M128A Xmm3;               // offset: 0x1d0 ordinal: 0x2c
  struct _M128A Xmm4;               // offset: 0x1e0 ordinal: 0x2d
  struct _M128A Xmm5;               // offset: 0x1f0 ordinal: 0x2e
  struct _M128A Xmm6;               // offset: 0x200 ordinal: 0x2f
  struct _M128A Xmm7;               // offset: 0x210 ordinal: 0x30
  struct _M128A Xmm8;               // offset: 0x220 ordinal: 0x31
  struct _M128A Xmm9;               // offset: 0x230 ordinal: 0x32
  struct _M128A Xmm10;              // offset: 0x240 ordinal: 0x33
  struct _M128A Xmm11;              // offset: 0x250 ordinal: 0x34
  struct _M128A Xmm12;              // offset: 0x260 ordinal: 0x35
  struct _M128A Xmm13;              // offset: 0x270 ordinal: 0x36
  struct _M128A Xmm14;              // offset: 0x280 ordinal: 0x37
  struct _M128A Xmm15;              // offset: 0x290 ordinal: 0x38
  struct _M128A VectorRegister[26]; // offset: 0x300 ordinal: 0x39
  ULONGLONG VectorControl;          // offset: 0x4a0 ordinal: 0x3a
  ULONGLONG DebugControl;           // offset: 0x4a8 ordinal: 0x3b
  ULONGLONG LastBranchToRip;        // offset: 0x4b0 ordinal: 0x3c
  ULONGLONG LastBranchFromRip;      // offset: 0x4b8 ordinal: 0x3d
  ULONGLONG LastExceptionToRip;     // offset: 0x4c0 ordinal: 0x3e
  ULONGLONG LastExceptionFromRip;   // offset: 0x4c8 ordinal: 0x3f
} _CONTEXT;

// 0x6d0 bytes (sizeof)
typedef struct _HEAP_FAILURE_INFORMATION {
  ULONG Version;                                // offset: 0x0 ordinal: 0x0
  ULONG StructureSize;                          // offset: 0x4 ordinal: 0x1
  enum _HEAP_FAILURE_TYPE FailureType;          // offset: 0x8 ordinal: 0x2
  VOID *HeapAddress;                            // offset: 0x10 ordinal: 0x3
  VOID *Address;                                // offset: 0x18 ordinal: 0x4
  VOID *Param1;                                 // offset: 0x20 ordinal: 0x5
  VOID *Param2;                                 // offset: 0x28 ordinal: 0x6
  VOID *Param3;                                 // offset: 0x30 ordinal: 0x7
  VOID *PreviousBlock;                          // offset: 0x38 ordinal: 0x8
  VOID *NextBlock;                              // offset: 0x40 ordinal: 0x9
  struct _FAKE_HEAP_ENTRY ExpectedDecodedEntry; // offset: 0x48 ordinal: 0xa
  VOID *StackTrace[32];                         // offset: 0x58 ordinal: 0xb
  UCHAR HeapMajorVersion;                       // offset: 0x158 ordinal: 0xc
  UCHAR HeapMinorVersion;                       // offset: 0x159 ordinal: 0xd
  struct _EXCEPTION_RECORD ExceptionRecord;     // offset: 0x160 ordinal: 0xe
  struct _CONTEXT ContextRecord;                // offset: 0x200 ordinal: 0xf
} _HEAP_FAILURE_INFORMATION;

// 0x40 bytes (sizeof)
typedef struct _RTLP_HP_HEAP_GLOBALS {
  ULONGLONG HeapKey;                             // offset: 0x0 ordinal: 0x0
  ULONGLONG LfhKey;                              // offset: 0x8 ordinal: 0x1
  struct _HEAP_FAILURE_INFORMATION *FailureInfo; // offset: 0x10 ordinal: 0x2
  struct _RTL_HEAP_MEMORY_LIMIT_DATA
      CommitLimitData; // offset: 0x18 ordinal: 0x3
  union {
    ULONG Flags;                  // offset: 0x38 ordinal: 0x4
    struct __anon_2757 FlagsBits; // offset: 0x38 ordinal: 0x5
  };
} _RTLP_HP_HEAP_GLOBALS;

// 0x5c0 bytes (sizeof)
typedef struct _KPROCESSOR_STATE {
  struct _KSPECIAL_REGISTERS SpecialRegisters; // offset: 0x0 ordinal: 0x0
  struct _CONTEXT ContextFrame;                // offset: 0xf0 ordinal: 0x1
} _KPROCESSOR_STATE;

// 0x10 bytes (sizeof)
typedef struct _EXCEPTION_POINTERS {
  struct _EXCEPTION_RECORD *ExceptionRecord; // offset: 0x0 ordinal: 0x0
  struct _CONTEXT *ContextRecord;            // offset: 0x8 ordinal: 0x1
} _EXCEPTION_POINTERS;

typedef enum _EXCEPTION_DISPOSITION (*__anon_1296)(struct _EXCEPTION_RECORD *,
                                                   VOID *, struct _CONTEXT *,
                                                   VOID *);

// 0x10 bytes (sizeof)
typedef struct _EXCEPTION_REGISTRATION_RECORD {
  struct _EXCEPTION_REGISTRATION_RECORD *Next; // offset: 0x0 ordinal: 0x0
  enum _EXCEPTION_DISPOSITION (*Handler)(struct _EXCEPTION_RECORD *, VOID *,
                                         struct _CONTEXT *,
                                         VOID *); // offset: 0x8 ordinal: 0x1
} _EXCEPTION_REGISTRATION_RECORD;

// 0x18 bytes (sizeof)
typedef struct _PS_MITIGATION_AUDIT_OPTIONS_MAP {
  ULONGLONG Map[3]; // offset: 0x0 ordinal: 0x0
} _PS_MITIGATION_AUDIT_OPTIONS_MAP;

// 0x18 bytes (sizeof)
typedef struct _PS_MITIGATION_OPTIONS_MAP {
  ULONGLONG Map[3]; // offset: 0x0 ordinal: 0x0
} _PS_MITIGATION_OPTIONS_MAP;

// 0x8 bytes (sizeof)
typedef union _KERNEL_SHADOW_STACK_LIMIT {
  ULONGLONG AllFields;                // offset: 0x0 ordinal: 0x0
  ULONGLONG ShadowStackType : 3;      // offset: 0x0 ordinal: 0x1
  ULONGLONG Unused : 9;               // offset: 0x0 ordinal: 0x2
  ULONGLONG ShadowStackLimitPfn : 52; // offset: 0x0 ordinal: 0x3
} _KERNEL_SHADOW_STACK_LIMIT;

// 0x40 bytes (sizeof)
typedef struct _KERNEL_STACK_SEGMENT {
  ULONGLONG StackBase;             // offset: 0x0 ordinal: 0x0
  ULONGLONG StackLimit;            // offset: 0x8 ordinal: 0x1
  ULONGLONG KernelStack;           // offset: 0x10 ordinal: 0x2
  ULONGLONG InitialStack;          // offset: 0x18 ordinal: 0x3
  ULONGLONG KernelShadowStackBase; // offset: 0x20 ordinal: 0x4
  union _KERNEL_SHADOW_STACK_LIMIT
      KernelShadowStackLimit;         // offset: 0x28 ordinal: 0x5
  ULONGLONG KernelShadowStack;        // offset: 0x30 ordinal: 0x6
  ULONGLONG KernelShadowStackInitial; // offset: 0x38 ordinal: 0x7
} _KERNEL_STACK_SEGMENT;

// 0x50 bytes (sizeof)
typedef struct _KSTACK_CONTROL {
  ULONGLONG StackBase; // offset: 0x0 ordinal: 0x0
  union {
    ULONGLONG ActualLimit;        // offset: 0x8 ordinal: 0x1
    ULONGLONG StackExpansion : 1; // offset: 0x8 ordinal: 0x2
  };
  struct _KERNEL_STACK_SEGMENT Previous; // offset: 0x10 ordinal: 0x3
} _KSTACK_CONTROL;

// 0x8 bytes (sizeof)
typedef struct _MI_SESSION_DRIVER_UNLOAD {
  union {
    VOID (*Function)(struct _DRIVER_OBJECT *); // offset: 0x0 ordinal: 0x0
    ULONGLONG FunctionValue;                   // offset: 0x0 ordinal: 0x1
  };
} _MI_SESSION_DRIVER_UNLOAD;

// 0x20 bytes (sizeof)
typedef struct _MMSUPPORT_AGGREGATION {
  ULONG PageFaultCount;         // offset: 0x0 ordinal: 0x0
  ULONGLONG WorkingSetSize;     // offset: 0x8 ordinal: 0x1
  ULONGLONG WorkingSetLeafSize; // offset: 0x10 ordinal: 0x2
  ULONGLONG PeakWorkingSetSize; // offset: 0x18 ordinal: 0x3
} _MMSUPPORT_AGGREGATION;

// 0x28 bytes (sizeof)
typedef struct _MMWSL_INSTANCE {
  struct _MMPTE *NextPteToTrim;        // offset: 0x0 ordinal: 0x0
  struct _MMPTE *NextPteToAge;         // offset: 0x8 ordinal: 0x1
  struct _MMPTE *NextPteToAccessClear; // offset: 0x10 ordinal: 0x2
  ULONG LastAccessClearingRemainder;   // offset: 0x18 ordinal: 0x3
  ULONG LastAgingRemainder;            // offset: 0x1c ordinal: 0x4
  ULONGLONG LockedEntries;             // offset: 0x20 ordinal: 0x5
} _MMWSL_INSTANCE;

// 0x18 bytes (sizeof)
typedef struct _RTL_BALANCED_NODE {
  union {
    struct _RTL_BALANCED_NODE *Children[2]; // offset: 0x0 ordinal: 0x0
    struct _RTL_BALANCED_NODE *Left;        // offset: 0x0 ordinal: 0x1
  };
  struct _RTL_BALANCED_NODE *Right; // offset: 0x8 ordinal: 0x2
  UCHAR Red : 1;                    // offset: 0x10 ordinal: 0x3
  UCHAR Balance : 2;                // offset: 0x10 ordinal: 0x4
  ULONGLONG ParentValue;            // offset: 0x10 ordinal: 0x5
} _RTL_BALANCED_NODE;

// 0x138 bytes (sizeof)
typedef struct _LDR_DATA_TABLE_ENTRY {
  struct _LIST_ENTRY InLoadOrderLinks;           // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY InMemoryOrderLinks;         // offset: 0x10 ordinal: 0x1
  struct _LIST_ENTRY InInitializationOrderLinks; // offset: 0x20 ordinal: 0x2
  VOID *DllBase;                                 // offset: 0x30 ordinal: 0x3
  VOID *EntryPoint;                              // offset: 0x38 ordinal: 0x4
  ULONG SizeOfImage;                             // offset: 0x40 ordinal: 0x5
  struct _UNICODE_STRING FullDllName;            // offset: 0x48 ordinal: 0x6
  struct _UNICODE_STRING BaseDllName;            // offset: 0x58 ordinal: 0x7
  union {
    UCHAR FlagGroup[4];       // offset: 0x68 ordinal: 0x8
    ULONG Flags;              // offset: 0x68 ordinal: 0x9
    ULONG PackagedBinary : 1; // offset: 0x68 ordinal: 0xa
  };
  ULONG MarkedForRemoval : 1;        // offset: 0x68 ordinal: 0xb
  ULONG ImageDll : 1;                // offset: 0x68 ordinal: 0xc
  ULONG LoadNotificationsSent : 1;   // offset: 0x68 ordinal: 0xd
  ULONG TelemetryEntryProcessed : 1; // offset: 0x68 ordinal: 0xe
  ULONG ProcessStaticImport : 1;     // offset: 0x68 ordinal: 0xf
  ULONG InLegacyLists : 1;           // offset: 0x68 ordinal: 0x10
  ULONG InIndexes : 1;               // offset: 0x68 ordinal: 0x11
  ULONG ShimDll : 1;                 // offset: 0x68 ordinal: 0x12
  ULONG InExceptionTable : 1;        // offset: 0x68 ordinal: 0x13
  ULONG ReservedFlags1 : 2;          // offset: 0x68 ordinal: 0x14
  ULONG LoadInProgress : 1;          // offset: 0x68 ordinal: 0x15
  ULONG LoadConfigProcessed : 1;     // offset: 0x68 ordinal: 0x16
  ULONG EntryProcessed : 1;          // offset: 0x68 ordinal: 0x17
  ULONG ProtectDelayLoad : 1;        // offset: 0x68 ordinal: 0x18
  ULONG ReservedFlags3 : 2;          // offset: 0x68 ordinal: 0x19
  ULONG DontCallForThreads : 1;      // offset: 0x68 ordinal: 0x1a
  ULONG ProcessAttachCalled : 1;     // offset: 0x68 ordinal: 0x1b
  ULONG ProcessAttachFailed : 1;     // offset: 0x68 ordinal: 0x1c
  ULONG CorDeferredValidate : 1;     // offset: 0x68 ordinal: 0x1d
  ULONG CorImage : 1;                // offset: 0x68 ordinal: 0x1e
  ULONG DontRelocate : 1;            // offset: 0x68 ordinal: 0x1f
  ULONG CorILOnly : 1;               // offset: 0x68 ordinal: 0x20
  ULONG ChpeImage : 1;               // offset: 0x68 ordinal: 0x21
  ULONG ChpeEmulatorImage : 1;       // offset: 0x68 ordinal: 0x22
  ULONG ReservedFlags5 : 1;          // offset: 0x68 ordinal: 0x23
  ULONG Redirected : 1;              // offset: 0x68 ordinal: 0x24
  ULONG ReservedFlags6 : 2;          // offset: 0x68 ordinal: 0x25
  ULONG CompatDatabaseProcessed : 1; // offset: 0x68 ordinal: 0x26
  USHORT ObsoleteLoadCount;          // offset: 0x6c ordinal: 0x27
  USHORT TlsIndex;                   // offset: 0x6e ordinal: 0x28
  struct _LIST_ENTRY HashLinks;      // offset: 0x70 ordinal: 0x29
  ULONG TimeDateStamp;               // offset: 0x80 ordinal: 0x2a
  struct _ACTIVATION_CONTEXT
      *EntryPointActivationContext;               // offset: 0x88 ordinal: 0x2b
  VOID *Lock;                                     // offset: 0x90 ordinal: 0x2c
  struct _LDR_DDAG_NODE *DdagNode;                // offset: 0x98 ordinal: 0x2d
  struct _LIST_ENTRY NodeModuleLink;              // offset: 0xa0 ordinal: 0x2e
  struct _LDRP_LOAD_CONTEXT *LoadContext;         // offset: 0xb0 ordinal: 0x2f
  VOID *ParentDllBase;                            // offset: 0xb8 ordinal: 0x30
  VOID *SwitchBackContext;                        // offset: 0xc0 ordinal: 0x31
  struct _RTL_BALANCED_NODE BaseAddressIndexNode; // offset: 0xc8 ordinal: 0x32
  struct _RTL_BALANCED_NODE MappingInfoIndexNode; // offset: 0xe0 ordinal: 0x33
  ULONGLONG OriginalBase;                         // offset: 0xf8 ordinal: 0x34
  union _LARGE_INTEGER LoadTime;                  // offset: 0x100 ordinal: 0x35
  ULONG BaseNameHashValue;                        // offset: 0x108 ordinal: 0x36
  enum _LDR_DLL_LOAD_REASON LoadReason;           // offset: 0x10c ordinal: 0x37
  ULONG ImplicitPathOptions;                      // offset: 0x110 ordinal: 0x38
  ULONG ReferenceCount;                           // offset: 0x114 ordinal: 0x39
  ULONG DependentLoadFlags;                       // offset: 0x118 ordinal: 0x3a
  UCHAR SigningLevel;                             // offset: 0x11c ordinal: 0x3b
  ULONG CheckSum;                                 // offset: 0x120 ordinal: 0x3c
  VOID *ActivePatchImageBase;                     // offset: 0x128 ordinal: 0x3d
  enum _LDR_HOT_PATCH_STATE HotPatchState;        // offset: 0x130 ordinal: 0x3e
} _LDR_DATA_TABLE_ENTRY;

// 0x20 bytes (sizeof)
typedef struct _ETW_PROVIDER_TRAITS {
  struct _RTL_BALANCED_NODE Node; // offset: 0x0 ordinal: 0x0
  ULONG ReferenceCount;           // offset: 0x18 ordinal: 0x1
  UCHAR Traits[1];                // offset: 0x1c ordinal: 0x2
} _ETW_PROVIDER_TRAITS;

// 0x40 bytes (sizeof)
typedef struct _SECTION {
  struct _RTL_BALANCED_NODE SectionNode; // offset: 0x0 ordinal: 0x0
  ULONGLONG StartingVpn;                 // offset: 0x18 ordinal: 0x1
  ULONGLONG EndingVpn;                   // offset: 0x20 ordinal: 0x2
  union __anon_3666 u1;                  // offset: 0x28 ordinal: 0x3
  ULONGLONG SizeOfSection;               // offset: 0x30 ordinal: 0x4
  union __anon_2262 u;                   // offset: 0x38 ordinal: 0x5
  ULONG InitialPageProtection : 12;      // offset: 0x3c ordinal: 0x6
  ULONG SessionId : 19;                  // offset: 0x3c ordinal: 0x7
  ULONG NoValidationNeeded : 1;          // offset: 0x3c ordinal: 0x8
} _SECTION;

// 0x28 bytes (sizeof)
typedef struct _MI_ACCESS_VIOLATION_RANGE {
  struct _RTL_BALANCED_NODE Node; // offset: 0x0 ordinal: 0x0
  VOID *Va;                       // offset: 0x18 ordinal: 0x1
  VOID *EndVaInclusive;           // offset: 0x20 ordinal: 0x2
} _MI_ACCESS_VIOLATION_RANGE;

// 0xa0 bytes (sizeof)
typedef struct _MI_POOL_STATE {
  ULONGLONG MaximumNonPagedPoolThreshold;   // offset: 0x0 ordinal: 0x0
  ULONGLONG AllocatedNonPagedPool;          // offset: 0x8 ordinal: 0x1
  ULONGLONG AllocatedSecureNonPagedPool;    // offset: 0x10 ordinal: 0x2
  ULONG HighEventSets;                      // offset: 0x18 ordinal: 0x3
  UCHAR HighEventSetsValid;                 // offset: 0x1c ordinal: 0x4
  ULONGLONG LowPagedPoolThreshold;          // offset: 0x20 ordinal: 0x5
  ULONGLONG HighPagedPoolThreshold;         // offset: 0x28 ordinal: 0x6
  LONG PermittedFaultsLock;                 // offset: 0x30 ordinal: 0x7
  struct _RTL_AVL_TREE PermittedFaultsTree; // offset: 0x38 ordinal: 0x8
  struct _MI_ACCESS_VIOLATION_RANGE
      PermittedFaultsInitialNode[2]; // offset: 0x40 ordinal: 0x9
  ULONGLONG TotalPagedPoolQuota;     // offset: 0x90 ordinal: 0xa
  ULONGLONG TotalNonPagedPoolQuota;  // offset: 0x98 ordinal: 0xb
} _MI_POOL_STATE;

// 0x30 bytes (sizeof)
typedef struct _MEMORY_ALLOCATION_DESCRIPTOR {
  union {
    struct _LIST_ENTRY ListEntry;   // offset: 0x0 ordinal: 0x0
    struct _RTL_BALANCED_NODE Node; // offset: 0x0 ordinal: 0x1
  };
  enum _TYPE_OF_MEMORY MemoryType; // offset: 0x18 ordinal: 0x2
  ULONGLONG BasePage;              // offset: 0x20 ordinal: 0x3
  ULONGLONG PageCount;             // offset: 0x28 ordinal: 0x4
} _MEMORY_ALLOCATION_DESCRIPTOR;

// 0x28 bytes (sizeof)
typedef struct _HEAP_LARGE_ALLOC_DATA {
  struct _RTL_BALANCED_NODE TreeNode; // offset: 0x0 ordinal: 0x0
  union {
    ULONGLONG VirtualAddress;   // offset: 0x18 ordinal: 0x1
    ULONGLONG UnusedBytes : 16; // offset: 0x18 ordinal: 0x2
  };
  ULONGLONG ExtraPresent : 1;       // offset: 0x20 ordinal: 0x3
  ULONGLONG GuardPageCount : 1;     // offset: 0x20 ordinal: 0x4
  ULONGLONG GuardPageAlignment : 6; // offset: 0x20 ordinal: 0x5
  ULONGLONG Spare : 4;              // offset: 0x20 ordinal: 0x6
  ULONGLONG AllocatedPages : 52;    // offset: 0x20 ordinal: 0x7
} _HEAP_LARGE_ALLOC_DATA;

// 0x20 bytes (sizeof)
typedef struct _HEAP_PAGE_RANGE_DESCRIPTOR {
  union {
    struct _RTL_BALANCED_NODE TreeNode; // offset: 0x0 ordinal: 0x0
    ULONG TreeSignature;                // offset: 0x0 ordinal: 0x1
  };
  ULONG UnusedBytes;        // offset: 0x4 ordinal: 0x2
  USHORT ExtraPresent : 1;  // offset: 0x8 ordinal: 0x3
  USHORT Spare0 : 15;       // offset: 0x8 ordinal: 0x4
  UCHAR RangeFlags;         // offset: 0x18 ordinal: 0x5
  UCHAR CommittedPageCount; // offset: 0x19 ordinal: 0x6
  USHORT Spare;             // offset: 0x1a ordinal: 0x7
  union {
    struct _HEAP_DESCRIPTOR_KEY Key; // offset: 0x1c ordinal: 0x8
    UCHAR Align[3];                  // offset: 0x1c ordinal: 0x9
  };
  union {
    UCHAR UnitOffset; // offset: 0x1f ordinal: 0xa
    UCHAR UnitSize;   // offset: 0x1f ordinal: 0xb
  };
} _HEAP_PAGE_RANGE_DESCRIPTOR;

// 0x2000 bytes (sizeof)
typedef union _HEAP_PAGE_SEGMENT {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  ULONGLONG Signature;          // offset: 0x10 ordinal: 0x1
  union _HEAP_SEGMENT_MGR_COMMIT_STATE
      *SegmentCommitState; // offset: 0x18 ordinal: 0x2
  UCHAR UnusedWatermark;   // offset: 0x20 ordinal: 0x3
  struct _HEAP_PAGE_RANGE_DESCRIPTOR DescArray[256]; // offset: 0x0 ordinal: 0x4
} _HEAP_PAGE_SEGMENT;

// 0x20 bytes (sizeof)
typedef struct _HEAP_VS_CHUNK_FREE_HEADER {
  union {
    struct _HEAP_VS_CHUNK_HEADER Header; // offset: 0x0 ordinal: 0x0
    ULONGLONG OverlapsHeader;            // offset: 0x0 ordinal: 0x1
  };
  struct _RTL_BALANCED_NODE Node; // offset: 0x8 ordinal: 0x2
} _HEAP_VS_CHUNK_FREE_HEADER;

// 0x20 bytes (sizeof)
typedef struct _MI_PROTOTYPE_PTES_NODE {
  struct _RTL_BALANCED_NODE Node; // offset: 0x0 ordinal: 0x0
  union __anon_2285 u1;           // offset: 0x18 ordinal: 0x1
} _MI_PROTOTYPE_PTES_NODE;

// 0x58 bytes (sizeof)
typedef struct _MI_PER_SESSION_PROTOS {
  union {
    struct _RTL_BALANCED_NODE SessionProtoNode; // offset: 0x0 ordinal: 0x0
    struct _SINGLE_LIST_ENTRY FreeList;         // offset: 0x0 ordinal: 0x1
    VOID *DriverAddress;                        // offset: 0x0 ordinal: 0x2
  };
  struct _MI_PROTOTYPE_PTES_NODE ProtosNode; // offset: 0x18 ordinal: 0x3
  ULONGLONG NumberOfPtes;                    // offset: 0x38 ordinal: 0x4
  union {
    ULONG SessionId;                // offset: 0x40 ordinal: 0x5
    struct _SUBSECTION *Subsection; // offset: 0x40 ordinal: 0x6
  };
  struct _MMPTE *SubsectionBase; // offset: 0x48 ordinal: 0x7
  union __anon_3127 u2;          // offset: 0x50 ordinal: 0x8
} _MI_PER_SESSION_PROTOS;

// 0x38 bytes (sizeof)
typedef struct _SUBSECTION {
  struct _CONTROL_AREA *ControlArea;  // offset: 0x0 ordinal: 0x0
  struct _MMPTE *SubsectionBase;      // offset: 0x8 ordinal: 0x1
  struct _SUBSECTION *NextSubsection; // offset: 0x10 ordinal: 0x2
  union {
    struct _RTL_AVL_TREE GlobalPerSessionHead; // offset: 0x18 ordinal: 0x3
    struct _MI_CONTROL_AREA_WAIT_BLOCK
        *CreationWaitList; // offset: 0x18 ordinal: 0x4
    struct _MI_PER_SESSION_PROTOS
        *SessionDriverProtos; // offset: 0x18 ordinal: 0x5
  };
  union __anon_3119 u;         // offset: 0x20 ordinal: 0x6
  ULONG StartingSector;        // offset: 0x24 ordinal: 0x7
  ULONG NumberOfFullSectors;   // offset: 0x28 ordinal: 0x8
  ULONG PtesInSubsection;      // offset: 0x2c ordinal: 0x9
  union __anon_3121 u1;        // offset: 0x30 ordinal: 0xa
  ULONG UnusedPtes : 30;       // offset: 0x34 ordinal: 0xb
  ULONG ExtentQueryNeeded : 1; // offset: 0x34 ordinal: 0xc
  ULONG DirtyPages : 1;        // offset: 0x34 ordinal: 0xd
} _SUBSECTION;

// 0x98 bytes (sizeof)
typedef struct _MSUBSECTION {
  struct _SUBSECTION Core;                   // offset: 0x0 ordinal: 0x0
  struct _RTL_BALANCED_NODE SubsectionNode;  // offset: 0x38 ordinal: 0x1
  struct _LIST_ENTRY DereferenceList;        // offset: 0x50 ordinal: 0x2
  ULONGLONG NumberOfMappedViews;             // offset: 0x60 ordinal: 0x3
  ULONG NumberOfPfnReferences;               // offset: 0x68 ordinal: 0x4
  ULONG LargeViews;                          // offset: 0x6c ordinal: 0x5
  VOID *SubsectionExtentList;                // offset: 0x70 ordinal: 0x6
  struct _MI_PROTOTYPE_PTES_NODE ProtosNode; // offset: 0x78 ordinal: 0x7
} _MSUBSECTION;

// 0x40 bytes (sizeof)
typedef struct _MI_IMAGE_SECURITY_REFERENCE {
  struct _MI_PROTOTYPE_PTES_NODE ProtosNode;      // offset: 0x0 ordinal: 0x0
  VOID *DynamicRelocations;                       // offset: 0x20 ordinal: 0x1
  struct _IMAGE_SECURITY_CONTEXT SecurityContext; // offset: 0x28 ordinal: 0x2
  union __anon_2284 u1;                           // offset: 0x30 ordinal: 0x3
  ULONGLONG StrongImageReference;                 // offset: 0x38 ordinal: 0x4
} _MI_IMAGE_SECURITY_REFERENCE;

// 0x10 bytes (sizeof)
typedef struct __anon_2274 {
  union {
    ULONG NumberOfSystemCacheViews; // offset: 0x0 ordinal: 0x0
    ULONG ImageRelocationStartBit;  // offset: 0x0 ordinal: 0x1
  };
  union {
    LONG WritableUserReferences;         // offset: 0x4 ordinal: 0x2
    ULONG ImageRelocationSizeIn64k : 16; // offset: 0x4 ordinal: 0x3
  };
  ULONG SystemImage : 1;        // offset: 0x4 ordinal: 0x4
  ULONG CantMove : 1;           // offset: 0x4 ordinal: 0x5
  ULONG StrongCode : 2;         // offset: 0x4 ordinal: 0x6
  ULONG BitMap : 2;             // offset: 0x4 ordinal: 0x7
  ULONG ImageActive : 1;        // offset: 0x4 ordinal: 0x8
  ULONG ImageBaseOkToReuse : 1; // offset: 0x4 ordinal: 0x9
  union {
    ULONG FlushInProgressCount; // offset: 0x8 ordinal: 0xa
    ULONG NumberOfSubsections;  // offset: 0x8 ordinal: 0xb
    struct _MI_IMAGE_SECURITY_REFERENCE
        *SeImageStub; // offset: 0x8 ordinal: 0xc
  };
} __anon_2274;

// 0x10 bytes (sizeof)
typedef union __anon_2265 {
  struct __anon_2274 e2; // offset: 0x0 ordinal: 0x0
} __anon_2265;

// 0x38 bytes (sizeof)
typedef struct _MI_PAGEFILE_BITMAPS_CACHE_ENTRY {
  union {
    struct _RTL_BALANCED_NODE LengthTreeNode; // offset: 0x0 ordinal: 0x0
    struct _LIST_ENTRY FreeListEntry;         // offset: 0x0 ordinal: 0x1
  };
  struct _RTL_BALANCED_NODE LocationTreeNode; // offset: 0x18 ordinal: 0x2
  ULONG StartingIndex;                        // offset: 0x30 ordinal: 0x3
  ULONG Length;                               // offset: 0x34 ordinal: 0x4
} _MI_PAGEFILE_BITMAPS_CACHE_ENTRY;

// 0x30 bytes (sizeof)
typedef struct _MMPFN {
  union {
    struct _LIST_ENTRY ListEntry;       // offset: 0x0 ordinal: 0x0
    struct _RTL_BALANCED_NODE TreeNode; // offset: 0x0 ordinal: 0x1
    union __anon_2107 u1;               // offset: 0x0 ordinal: 0x2
  };
  union {
    struct _MMPTE *PteAddress; // offset: 0x8 ordinal: 0x3
    ULONGLONG PteLong;         // offset: 0x8 ordinal: 0x4
  };
  struct _MMPTE OriginalPte; // offset: 0x10 ordinal: 0x5
  struct _MIPFNBLINK u2;     // offset: 0x18 ordinal: 0x6
  union __anon_2113 u3;      // offset: 0x20 ordinal: 0x7
  struct _MI_PFN_ULONG5 u5;  // offset: 0x24 ordinal: 0x8
  union __anon_2116 u4;      // offset: 0x28 ordinal: 0x9
} _MMPFN;

// 0x110 bytes (sizeof)
typedef struct _MI_PAGELIST_STATE {
  LONG ActiveSpinLock;                        // offset: 0x0 ordinal: 0x0
  struct _RTL_AVL_TREE ActiveThreadTree;      // offset: 0x8 ordinal: 0x1
  LONG ActiveZeroSpinLock;                    // offset: 0x10 ordinal: 0x2
  struct _RTL_AVL_TREE ActiveZeroThreadTree;  // offset: 0x18 ordinal: 0x3
  struct _MMPFN LargePfnTemplate;             // offset: 0x20 ordinal: 0x4
  struct _MMPFN LargePfnBasePageTemplate;     // offset: 0x50 ordinal: 0x5
  ULONG NumberOfLargePageListHeads;           // offset: 0x80 ordinal: 0x6
  struct _KEVENT Phase1BootComplete;          // offset: 0x88 ordinal: 0x7
  struct _RTL_AVL_TREE PendingBadPageTree;    // offset: 0xa0 ordinal: 0x8
  ULONGLONG PendingBadPageCount;              // offset: 0xa8 ordinal: 0x9
  LONG PendingBadPageTreeLock;                // offset: 0xb0 ordinal: 0xa
  ULONGLONG PendingBadPagesWithoutNodesCount; // offset: 0xb8 ordinal: 0xb
  struct _LIST_ENTRY
      PendingBadPageNodesAwaitingDeleteList;        // offset: 0xc0 ordinal: 0xc
  ULONGLONG PendingBadPageNodesAwaitingDeleteCount; // offset: 0xd0 ordinal: 0xd
  UCHAR PendingBadPageNodeDeleteActive;             // offset: 0xd8 ordinal: 0xe
  struct _WORK_QUEUE_ITEM
      PendingBadPageNodeDeleteWorkItem; // offset: 0xe0 ordinal: 0xf
  struct _RTL_AVL_TREE BadHugePageTree; // offset: 0x100 ordinal: 0x10
  ULONGLONG BadHugePageCount;           // offset: 0x108 ordinal: 0x11
} _MI_PAGELIST_STATE;

// 0x58 bytes (sizeof)
typedef struct _MMPFNLIST {
  ULONGLONG Total;           // offset: 0x0 ordinal: 0x0
  enum _MMLISTS ListName;    // offset: 0x8 ordinal: 0x1
  ULONGLONG Flink;           // offset: 0x10 ordinal: 0x2
  ULONGLONG Blink;           // offset: 0x18 ordinal: 0x3
  LONG Lock;                 // offset: 0x20 ordinal: 0x4
  struct _MMPFN EmbeddedPfn; // offset: 0x28 ordinal: 0x5
} _MMPFNLIST;

// 0x10 bytes (sizeof)
typedef struct _MI_HARD_FAULT_STATE {
  struct _MMPFN *SwapPfn;                            // offset: 0x0 ordinal: 0x0
  struct _MI_STORE_INPAGE_COMPLETE_FLAGS StoreFlags; // offset: 0x8 ordinal: 0x1
} _MI_HARD_FAULT_STATE;

// 0xa8 bytes (sizeof)
typedef struct _MI_COMMON_PAGE_STATE {
  struct _MMPFN *PageOfOnesPfn; // offset: 0x0 ordinal: 0x0
  ULONGLONG PageOfOnes;         // offset: 0x8 ordinal: 0x1
  struct _MMPFN *DummyPagePfn;  // offset: 0x10 ordinal: 0x2
  ULONGLONG DummyPage;          // offset: 0x18 ordinal: 0x3
  ULONGLONG PageOfZeroes;       // offset: 0x20 ordinal: 0x4
  VOID *ZeroMapping;            // offset: 0x28 ordinal: 0x5
  VOID *OnesMapping;            // offset: 0x30 ordinal: 0x6
  ULONGLONG ZeroCrc;            // offset: 0x38 ordinal: 0x7
  ULONGLONG OnesCrc;            // offset: 0x40 ordinal: 0x8
  ULONGLONG OnesGapFrames[4];   // offset: 0x48 ordinal: 0x9
  ULONGLONG ZeroesGapFrames[4]; // offset: 0x68 ordinal: 0xa
  ULONGLONG PageTableOfZeroes;  // offset: 0x88 ordinal: 0xb
  struct _MMPTE PdeOfZeroes;    // offset: 0x90 ordinal: 0xc
  ULONGLONG PageTableOfOnes;    // offset: 0x98 ordinal: 0xd
  struct _MMPTE PdeOfOnes;      // offset: 0xa0 ordinal: 0xe
} _MI_COMMON_PAGE_STATE;

// 0x20 bytes (sizeof)
typedef struct _MI_REMOVAL_REQUESTED_PAGE {
  union {
    struct _RTL_BALANCED_NODE TreeNode; // offset: 0x0 ordinal: 0x0
    struct _LIST_ENTRY Link;            // offset: 0x0 ordinal: 0x1
  };
  struct _MMPFN *Pfn; // offset: 0x18 ordinal: 0x2
} _MI_REMOVAL_REQUESTED_PAGE;

// 0x20 bytes (sizeof)
typedef struct _IOP_MC_BE_PAGE_NODE {
  struct _RTL_BALANCED_NODE Node; // offset: 0x0 ordinal: 0x0
  ULONG PageIndex;                // offset: 0x18 ordinal: 0x1
} _IOP_MC_BE_PAGE_NODE;

// 0x88 bytes (sizeof)
typedef struct _DYNAMIC_FUNCTION_TABLE {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY
      *FunctionTable;             // offset: 0x10 ordinal: 0x1
  union _LARGE_INTEGER TimeStamp; // offset: 0x18 ordinal: 0x2
  ULONGLONG MinimumAddress;       // offset: 0x20 ordinal: 0x3
  ULONGLONG MaximumAddress;       // offset: 0x28 ordinal: 0x4
  ULONGLONG BaseAddress;          // offset: 0x30 ordinal: 0x5
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY *(*Callback)(
      ULONGLONG, VOID *);                // offset: 0x38 ordinal: 0x6
  VOID *Context;                         // offset: 0x40 ordinal: 0x7
  WCHAR *OutOfProcessCallbackDll;        // offset: 0x48 ordinal: 0x8
  enum _FUNCTION_TABLE_TYPE Type;        // offset: 0x50 ordinal: 0x9
  ULONG EntryCount;                      // offset: 0x54 ordinal: 0xa
  struct _RTL_BALANCED_NODE TreeNodeMin; // offset: 0x58 ordinal: 0xb
  struct _RTL_BALANCED_NODE TreeNodeMax; // offset: 0x70 ordinal: 0xc
} _DYNAMIC_FUNCTION_TABLE;

// 0x18 bytes (sizeof)
typedef struct _INVERTED_FUNCTION_TABLE_ENTRY {
  union {
    struct _IMAGE_RUNTIME_FUNCTION_ENTRY
        *FunctionTable;                           // offset: 0x0 ordinal: 0x0
    struct _DYNAMIC_FUNCTION_TABLE *DynamicTable; // offset: 0x0 ordinal: 0x1
  };
  VOID *ImageBase;   // offset: 0x8 ordinal: 0x2
  ULONG SizeOfImage; // offset: 0x10 ordinal: 0x3
  ULONG SizeOfTable; // offset: 0x14 ordinal: 0x4
} _INVERTED_FUNCTION_TABLE_ENTRY;

// 0x1810 bytes (sizeof)
typedef struct _INVERTED_FUNCTION_TABLE_KERNEL_MODE {
  ULONG CurrentSize; // offset: 0x0 ordinal: 0x0
  ULONG MaximumSize; // offset: 0x4 ordinal: 0x1
  ULONG Epoch;       // offset: 0x8 ordinal: 0x2
  UCHAR Overflow;    // offset: 0xc ordinal: 0x3
  struct _INVERTED_FUNCTION_TABLE_ENTRY
      TableEntry[256]; // offset: 0x10 ordinal: 0x4
} _INVERTED_FUNCTION_TABLE_KERNEL_MODE;

// 0x1a8 bytes (sizeof)
typedef struct _KSCB {
  ULONGLONG GenerationCycles;           // offset: 0x0 ordinal: 0x0
  ULONGLONG MinQuotaCycleTarget;        // offset: 0x8 ordinal: 0x1
  ULONGLONG MaxQuotaCycleTarget;        // offset: 0x10 ordinal: 0x2
  ULONGLONG RankCycleTarget;            // offset: 0x18 ordinal: 0x3
  ULONGLONG LongTermCycles;             // offset: 0x20 ordinal: 0x4
  ULONGLONG LastReportedCycles;         // offset: 0x28 ordinal: 0x5
  ULONGLONG OverQuotaHistory;           // offset: 0x30 ordinal: 0x6
  ULONGLONG ReadyTime;                  // offset: 0x38 ordinal: 0x7
  ULONGLONG InsertTime;                 // offset: 0x40 ordinal: 0x8
  struct _LIST_ENTRY PerProcessorList;  // offset: 0x48 ordinal: 0x9
  struct _RTL_BALANCED_NODE QueueNode;  // offset: 0x58 ordinal: 0xa
  UCHAR Inserted : 1;                   // offset: 0x70 ordinal: 0xb
  UCHAR MaxOverQuota : 1;               // offset: 0x70 ordinal: 0xc
  UCHAR MinOverQuota : 1;               // offset: 0x70 ordinal: 0xd
  UCHAR RankBias : 1;                   // offset: 0x70 ordinal: 0xe
  UCHAR UnconstrainedMaxQuota : 1;      // offset: 0x70 ordinal: 0xf
  UCHAR UnconstrainedMinQuota : 1;      // offset: 0x70 ordinal: 0x10
  UCHAR ShareRankOwner : 1;             // offset: 0x70 ordinal: 0x11
  UCHAR Spare1 : 1;                     // offset: 0x70 ordinal: 0x12
  UCHAR Depth;                          // offset: 0x71 ordinal: 0x13
  USHORT ReadySummary;                  // offset: 0x72 ordinal: 0x14
  ULONG Rank;                           // offset: 0x74 ordinal: 0x15
  ULONG *ShareRank;                     // offset: 0x78 ordinal: 0x16
  ULONG OwnerShareRank;                 // offset: 0x80 ordinal: 0x17
  struct _LIST_ENTRY ReadyListHead[16]; // offset: 0x88 ordinal: 0x18
  struct _RTL_RB_TREE ChildScbQueue;    // offset: 0x188 ordinal: 0x19
  struct _KSCB *Parent;                 // offset: 0x198 ordinal: 0x1a
  struct _KSCB *Root;                   // offset: 0x1a0 ordinal: 0x1b
} _KSCB;

// 0x60 bytes (sizeof)
typedef struct _KLOCK_ENTRY {
  union {
    struct _KLOCK_ENTRY_LOCK_STATE LockState; // offset: 0x0 ordinal: 0x0
    VOID *LockUnsafe;                         // offset: 0x0 ordinal: 0x1
    UCHAR CrossThreadReleasableAndBusyByte;   // offset: 0x0 ordinal: 0x2
  };
  UCHAR Reserved[6]; // offset: 0x1 ordinal: 0x3
  UCHAR InTreeByte;  // offset: 0x7 ordinal: 0x4
  union {
    VOID *SessionState; // offset: 0x8 ordinal: 0x5
    ULONG SessionId;    // offset: 0x8 ordinal: 0x6
  };
  ULONG SessionPad; // offset: 0xc ordinal: 0x7
  union {
    ULONG EntryFlags; // offset: 0x10 ordinal: 0x8
    UCHAR EntryIndex; // offset: 0x10 ordinal: 0x9
  };
  UCHAR WaitingByte;  // offset: 0x11 ordinal: 0xa
  UCHAR AcquiredByte; // offset: 0x12 ordinal: 0xb
  union {
    UCHAR CrossThreadFlags; // offset: 0x13 ordinal: 0xc
    UCHAR HeadNodeBit : 1;  // offset: 0x13 ordinal: 0xd
  };
  UCHAR IoPriorityBit : 1;                     // offset: 0x13 ordinal: 0xe
  UCHAR IoQoSWaiter : 1;                       // offset: 0x13 ordinal: 0xf
  UCHAR Spare1 : 5;                            // offset: 0x13 ordinal: 0x10
  ULONG StaticState : 8;                       // offset: 0x10 ordinal: 0x11
  ULONG AllFlags : 24;                         // offset: 0x10 ordinal: 0x12
  ULONG SpareFlags;                            // offset: 0x14 ordinal: 0x13
  struct _RTL_BALANCED_NODE TreeNode;          // offset: 0x18 ordinal: 0x14
  struct _RTL_RB_TREE OwnerTree;               // offset: 0x30 ordinal: 0x15
  struct _RTL_RB_TREE WaiterTree;              // offset: 0x40 ordinal: 0x16
  CHAR CpuPriorityKey;                         // offset: 0x30 ordinal: 0x17
  ULONGLONG EntryLock;                         // offset: 0x50 ordinal: 0x18
  union _KLOCK_ENTRY_BOOST_BITMAP BoostBitmap; // offset: 0x58 ordinal: 0x19
} _KLOCK_ENTRY;

// 0x8 bytes (sizeof)
typedef union _JOBOBJECT_ENERGY_TRACKING_STATE {
  ULONGLONG Value;    // offset: 0x0 ordinal: 0x0
  ULONG UpdateMask;   // offset: 0x0 ordinal: 0x1
  ULONG DesiredState; // offset: 0x4 ordinal: 0x2
} _JOBOBJECT_ENERGY_TRACKING_STATE;

// 0x28 bytes (sizeof)
typedef struct _JOB_RATE_CONTROL_HEADER {
  VOID *RateControlQuotaReference;     // offset: 0x0 ordinal: 0x0
  struct _RTL_BITMAP OverQuotaHistory; // offset: 0x8 ordinal: 0x1
  UCHAR *BitMapBuffer;                 // offset: 0x18 ordinal: 0x2
  ULONGLONG BitMapBufferSize;          // offset: 0x20 ordinal: 0x3
} _JOB_RATE_CONTROL_HEADER;

// 0x68 bytes (sizeof)
typedef struct _EPROCESS_VALUES {
  ULONGLONG KernelTime;         // offset: 0x0 ordinal: 0x0
  ULONGLONG UserTime;           // offset: 0x8 ordinal: 0x1
  ULONGLONG ReadyTime;          // offset: 0x10 ordinal: 0x2
  ULONGLONG CycleTime;          // offset: 0x18 ordinal: 0x3
  ULONGLONG ContextSwitches;    // offset: 0x20 ordinal: 0x4
  LONGLONG ReadOperationCount;  // offset: 0x28 ordinal: 0x5
  LONGLONG WriteOperationCount; // offset: 0x30 ordinal: 0x6
  LONGLONG OtherOperationCount; // offset: 0x38 ordinal: 0x7
  LONGLONG ReadTransferCount;   // offset: 0x40 ordinal: 0x8
  LONGLONG WriteTransferCount;  // offset: 0x48 ordinal: 0x9
  LONGLONG OtherTransferCount;  // offset: 0x50 ordinal: 0xa
  ULONGLONG KernelWaitTime;     // offset: 0x58 ordinal: 0xb
  ULONGLONG UserWaitTime;       // offset: 0x60 ordinal: 0xc
} _EPROCESS_VALUES;

// 0x48 bytes (sizeof)
typedef struct _PS_JOB_WAKE_INFORMATION {
  ULONGLONG NotificationChannel; // offset: 0x0 ordinal: 0x0
  ULONGLONG WakeCounters[7];     // offset: 0x8 ordinal: 0x1
  ULONGLONG NoWakeCounter;       // offset: 0x40 ordinal: 0x2
} _PS_JOB_WAKE_INFORMATION;

// 0x68 bytes (sizeof)
typedef struct _ERESOURCE {
  struct _LIST_ENTRY SystemResourcesList; // offset: 0x0 ordinal: 0x0
  struct _OWNER_ENTRY *OwnerTable;        // offset: 0x10 ordinal: 0x1
  SHORT ActiveCount;                      // offset: 0x18 ordinal: 0x2
  union {
    USHORT Flag;            // offset: 0x1a ordinal: 0x3
    UCHAR ReservedLowFlags; // offset: 0x1a ordinal: 0x4
  };
  UCHAR WaiterPriority;           // offset: 0x1b ordinal: 0x5
  VOID *SharedWaiters;            // offset: 0x20 ordinal: 0x6
  VOID *ExclusiveWaiters;         // offset: 0x28 ordinal: 0x7
  struct _OWNER_ENTRY OwnerEntry; // offset: 0x30 ordinal: 0x8
  ULONG ActiveEntries;            // offset: 0x40 ordinal: 0x9
  ULONG ContentionCount;          // offset: 0x44 ordinal: 0xa
  ULONG NumberOfSharedWaiters;    // offset: 0x48 ordinal: 0xb
  ULONG NumberOfExclusiveWaiters; // offset: 0x4c ordinal: 0xc
  VOID *Reserved2;                // offset: 0x50 ordinal: 0xd
  union {
    VOID *Address;                   // offset: 0x58 ordinal: 0xe
    ULONGLONG CreatorBackTraceIndex; // offset: 0x58 ordinal: 0xf
  };
  ULONGLONG SpinLock; // offset: 0x60 ordinal: 0x10
} _ERESOURCE;

// 0x68 bytes (sizeof)
typedef union __anon_2838 {
  struct _RTL_CRITICAL_SECTION CriticalSection; // offset: 0x0 ordinal: 0x0
  struct _ERESOURCE Resource;                   // offset: 0x0 ordinal: 0x1
} __anon_2838;

// 0x68 bytes (sizeof)
typedef struct _HEAP_LOCK {
  union __anon_2838 Lock; // offset: 0x0 ordinal: 0x0
} _HEAP_LOCK;

// 0xc0 bytes (sizeof)
typedef struct _BCB {
  union {
    struct _MBCB Dummy; // offset: 0x0 ordinal: 0x0
    SHORT NodeTypeCode; // offset: 0x0 ordinal: 0x1
  };
  UCHAR Dirty;                              // offset: 0x2 ordinal: 0x2
  UCHAR Reserved;                           // offset: 0x3 ordinal: 0x3
  ULONG ByteLength;                         // offset: 0x4 ordinal: 0x4
  union _LARGE_INTEGER FileOffset;          // offset: 0x8 ordinal: 0x5
  struct _LIST_ENTRY BcbLinks;              // offset: 0x10 ordinal: 0x6
  union _LARGE_INTEGER BeyondLastByte;      // offset: 0x20 ordinal: 0x7
  union _LARGE_INTEGER OldestLsn;           // offset: 0x28 ordinal: 0x8
  union _LARGE_INTEGER NewestLsn;           // offset: 0x30 ordinal: 0x9
  struct _VACB *Vacb;                       // offset: 0x38 ordinal: 0xa
  ULONG PinCount;                           // offset: 0x40 ordinal: 0xb
  struct _ERESOURCE Resource;               // offset: 0x48 ordinal: 0xc
  struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0xb0 ordinal: 0xd
  VOID *BaseAddress;                        // offset: 0xb8 ordinal: 0xe
} _BCB;

// 0x30 bytes (sizeof)
typedef struct _FSRTL_COMMON_FCB_HEADER {
  SHORT NodeTypeCode;                   // offset: 0x0 ordinal: 0x0
  SHORT NodeByteSize;                   // offset: 0x2 ordinal: 0x1
  UCHAR Flags;                          // offset: 0x4 ordinal: 0x2
  UCHAR IsFastIoPossible;               // offset: 0x5 ordinal: 0x3
  UCHAR Flags2;                         // offset: 0x6 ordinal: 0x4
  UCHAR Reserved : 4;                   // offset: 0x7 ordinal: 0x5
  UCHAR Version : 4;                    // offset: 0x7 ordinal: 0x6
  struct _ERESOURCE *Resource;          // offset: 0x8 ordinal: 0x7
  struct _ERESOURCE *PagingIoResource;  // offset: 0x10 ordinal: 0x8
  union _LARGE_INTEGER AllocationSize;  // offset: 0x18 ordinal: 0x9
  union _LARGE_INTEGER FileSize;        // offset: 0x20 ordinal: 0xa
  union _LARGE_INTEGER ValidDataLength; // offset: 0x28 ordinal: 0xb
} _FSRTL_COMMON_FCB_HEADER;

// 0x8 bytes (sizeof)
typedef struct __anon_1186 {
  struct _ERESOURCE *ResourceToRelease; // offset: 0x0 ordinal: 0x0
} __anon_1186;

// 0x10 bytes (sizeof)
typedef struct __anon_1185 {
  union _LARGE_INTEGER *EndingOffset;    // offset: 0x0 ordinal: 0x0
  struct _ERESOURCE **ResourceToRelease; // offset: 0x8 ordinal: 0x1
} __anon_1185;

// 0x28 bytes (sizeof)
typedef union _FS_FILTER_PARAMETERS {
  struct __anon_1185 AcquireForModifiedPageWriter; // offset: 0x0 ordinal: 0x0
  struct __anon_1186 ReleaseForModifiedPageWriter; // offset: 0x0 ordinal: 0x1
  struct __anon_1187
      AcquireForSectionSynchronization; // offset: 0x0 ordinal: 0x2
  struct __anon_1188 QueryOpen;         // offset: 0x0 ordinal: 0x3
  struct __anon_1189 Others;            // offset: 0x0 ordinal: 0x4
} _FS_FILTER_PARAMETERS;

// 0x40 bytes (sizeof)
typedef struct _FS_FILTER_CALLBACK_DATA {
  ULONG SizeOfFsFilterCallbackData;       // offset: 0x0 ordinal: 0x0
  UCHAR Operation;                        // offset: 0x4 ordinal: 0x1
  UCHAR Reserved;                         // offset: 0x5 ordinal: 0x2
  struct _DEVICE_OBJECT *DeviceObject;    // offset: 0x8 ordinal: 0x3
  struct _FILE_OBJECT *FileObject;        // offset: 0x10 ordinal: 0x4
  union _FS_FILTER_PARAMETERS Parameters; // offset: 0x18 ordinal: 0x5
} _FS_FILTER_CALLBACK_DATA;

typedef VOID (*__anon_979)(struct _FS_FILTER_CALLBACK_DATA *, LONG, VOID *);

typedef LONG (*__anon_978)(struct _FS_FILTER_CALLBACK_DATA *, VOID **);

// 0x78 bytes (sizeof)
typedef struct _FS_FILTER_CALLBACKS {
  ULONG SizeOfFsFilterCallbacks; // offset: 0x0 ordinal: 0x0
  ULONG Reserved;                // offset: 0x4 ordinal: 0x1
  LONG(*PreAcquireForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *, VOID **); // offset: 0x8 ordinal: 0x2
  VOID(*PostAcquireForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *, LONG,
   VOID *); // offset: 0x10 ordinal: 0x3
  LONG(*PreReleaseForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *, VOID **); // offset: 0x18 ordinal: 0x4
  VOID(*PostReleaseForSectionSynchronization)
  (struct _FS_FILTER_CALLBACK_DATA *, LONG,
   VOID *); // offset: 0x20 ordinal: 0x5
  LONG(*PreAcquireForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *, VOID **); // offset: 0x28 ordinal: 0x6
  VOID(*PostAcquireForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *, LONG,
   VOID *); // offset: 0x30 ordinal: 0x7
  LONG(*PreReleaseForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *, VOID **); // offset: 0x38 ordinal: 0x8
  VOID(*PostReleaseForCcFlush)
  (struct _FS_FILTER_CALLBACK_DATA *, LONG,
   VOID *); // offset: 0x40 ordinal: 0x9
  LONG(*PreAcquireForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *, VOID **); // offset: 0x48 ordinal: 0xa
  VOID(*PostAcquireForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *, LONG,
   VOID *); // offset: 0x50 ordinal: 0xb
  LONG(*PreReleaseForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *, VOID **); // offset: 0x58 ordinal: 0xc
  VOID(*PostReleaseForModifiedPageWriter)
  (struct _FS_FILTER_CALLBACK_DATA *, LONG,
   VOID *); // offset: 0x60 ordinal: 0xd
  LONG(*PreQueryOpen)
  (struct _FS_FILTER_CALLBACK_DATA *, VOID **); // offset: 0x68 ordinal: 0xe
  VOID(*PostQueryOpen)
  (struct _FS_FILTER_CALLBACK_DATA *, LONG,
   VOID *); // offset: 0x70 ordinal: 0xf
} _FS_FILTER_CALLBACKS;

typedef LONG (*__anon_784)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                           struct _ERESOURCE **, struct _DEVICE_OBJECT *);

typedef LONG (*__anon_790)(struct _FILE_OBJECT *, struct _ERESOURCE *,
                           struct _DEVICE_OBJECT *);

// 0x18 bytes (sizeof)
typedef struct _PS_PROPERTY_SET {
  struct _LIST_ENTRY ListHead; // offset: 0x0 ordinal: 0x0
  ULONGLONG Lock;              // offset: 0x10 ordinal: 0x1
} _PS_PROPERTY_SET;

// 0x8 bytes (sizeof)
typedef union _PS_CLIENT_SECURITY_CONTEXT {
  ULONGLONG ImpersonationData;      // offset: 0x0 ordinal: 0x0
  VOID *ImpersonationToken;         // offset: 0x0 ordinal: 0x1
  ULONGLONG ImpersonationLevel : 2; // offset: 0x0 ordinal: 0x2
  ULONGLONG EffectiveOnly : 1;      // offset: 0x0 ordinal: 0x3
} _PS_CLIENT_SECURITY_CONTEXT;

// 0x8 bytes (sizeof)
typedef struct __anon_123 {
  ULONGLONG SecureProcess : 1; // offset: 0x0 ordinal: 0x0
  ULONGLONG Unused : 1;        // offset: 0x0 ordinal: 0x1
} __anon_123;

// 0x240 bytes (sizeof)
typedef struct _KSCHEDULING_GROUP {
  struct _KSCHEDULING_GROUP_POLICY Policy; // offset: 0x0 ordinal: 0x0
  ULONG RelativeWeight;                    // offset: 0x8 ordinal: 0x1
  ULONG ChildMinRate;                      // offset: 0xc ordinal: 0x2
  ULONG ChildMinWeight;                    // offset: 0x10 ordinal: 0x3
  ULONG ChildTotalWeight;                  // offset: 0x14 ordinal: 0x4
  ULONGLONG QueryHistoryTimeStamp;         // offset: 0x18 ordinal: 0x5
  LONGLONG NotificationCycles;             // offset: 0x20 ordinal: 0x6
  LONGLONG MaxQuotaLimitCycles;            // offset: 0x28 ordinal: 0x7
  LONGLONG MaxQuotaCyclesRemaining;        // offset: 0x30 ordinal: 0x8
  union {
    struct _LIST_ENTRY SchedulingGroupList; // offset: 0x38 ordinal: 0x9
    struct _LIST_ENTRY Sibling;             // offset: 0x38 ordinal: 0xa
  };
  struct _KDPC *NotificationDpc;     // offset: 0x48 ordinal: 0xb
  struct _LIST_ENTRY ChildList;      // offset: 0x50 ordinal: 0xc
  struct _KSCHEDULING_GROUP *Parent; // offset: 0x60 ordinal: 0xd
  struct _KSCB PerProcessor[1];      // offset: 0x80 ordinal: 0xe
} _KSCHEDULING_GROUP;

// 0x100 bytes (sizeof)
typedef union _LFH_RANDOM_DATA {
  UCHAR Bytes[256];        // offset: 0x0 ordinal: 0x0
  USHORT Words[128];       // offset: 0x0 ordinal: 0x1
  ULONGLONG Quadwords[32]; // offset: 0x0 ordinal: 0x2
} _LFH_RANDOM_DATA;

// 0x110 bytes (sizeof)
typedef struct _SID_AND_ATTRIBUTES_HASH {
  ULONG SidCount;                      // offset: 0x0 ordinal: 0x0
  struct _SID_AND_ATTRIBUTES *SidAttr; // offset: 0x8 ordinal: 0x1
  ULONGLONG Hash[32];                  // offset: 0x10 ordinal: 0x2
} _SID_AND_ATTRIBUTES_HASH;

// 0x58 bytes (sizeof)
typedef struct _TOKEN_ACCESS_INFORMATION {
  struct _SID_AND_ATTRIBUTES_HASH *SidHash; // offset: 0x0 ordinal: 0x0
  struct _SID_AND_ATTRIBUTES_HASH
      *RestrictedSidHash;               // offset: 0x8 ordinal: 0x1
  struct _TOKEN_PRIVILEGES *Privileges; // offset: 0x10 ordinal: 0x2
  struct _LUID AuthenticationId;        // offset: 0x18 ordinal: 0x3
  enum _TOKEN_TYPE TokenType;           // offset: 0x20 ordinal: 0x4
  enum _SECURITY_IMPERSONATION_LEVEL
      ImpersonationLevel;                         // offset: 0x24 ordinal: 0x5
  struct _TOKEN_MANDATORY_POLICY MandatoryPolicy; // offset: 0x28 ordinal: 0x6
  ULONG Flags;                                    // offset: 0x2c ordinal: 0x7
  ULONG AppContainerNumber;                       // offset: 0x30 ordinal: 0x8
  VOID *PackageSid;                               // offset: 0x38 ordinal: 0x9
  struct _SID_AND_ATTRIBUTES_HASH
      *CapabilitiesHash;    // offset: 0x40 ordinal: 0xa
  VOID *TrustLevelSid;      // offset: 0x48 ordinal: 0xb
  VOID *SecurityAttributes; // offset: 0x50 ordinal: 0xc
} _TOKEN_ACCESS_INFORMATION;

// 0x260 bytes (sizeof)
typedef struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION {
  ULONG DeviceGroupsCount;                   // offset: 0x0 ordinal: 0x0
  struct _SID_AND_ATTRIBUTES *pDeviceGroups; // offset: 0x8 ordinal: 0x1
  ULONG RestrictedDeviceGroupsCount;         // offset: 0x10 ordinal: 0x2
  struct _SID_AND_ATTRIBUTES
      *pRestrictedDeviceGroups;                     // offset: 0x18 ordinal: 0x3
  struct _SID_AND_ATTRIBUTES_HASH DeviceGroupsHash; // offset: 0x20 ordinal: 0x4
  struct _SID_AND_ATTRIBUTES_HASH
      RestrictedDeviceGroupsHash; // offset: 0x130 ordinal: 0x5
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pUserSecurityAttributes; // offset: 0x240 ordinal: 0x6
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pDeviceSecurityAttributes; // offset: 0x248 ordinal: 0x7
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pRestrictedUserSecurityAttributes; // offset: 0x250 ordinal: 0x8
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pRestrictedDeviceSecurityAttributes; // offset: 0x258 ordinal: 0x9
} _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION;

// 0x498 bytes (sizeof)
typedef struct _TOKEN {
  struct _TOKEN_SOURCE TokenSource;           // offset: 0x0 ordinal: 0x0
  struct _LUID TokenId;                       // offset: 0x10 ordinal: 0x1
  struct _LUID AuthenticationId;              // offset: 0x18 ordinal: 0x2
  struct _LUID ParentTokenId;                 // offset: 0x20 ordinal: 0x3
  union _LARGE_INTEGER ExpirationTime;        // offset: 0x28 ordinal: 0x4
  struct _ERESOURCE *TokenLock;               // offset: 0x30 ordinal: 0x5
  struct _LUID ModifiedId;                    // offset: 0x38 ordinal: 0x6
  struct _SEP_TOKEN_PRIVILEGES Privileges;    // offset: 0x40 ordinal: 0x7
  struct _SEP_AUDIT_POLICY AuditPolicy;       // offset: 0x58 ordinal: 0x8
  ULONG SessionId;                            // offset: 0x78 ordinal: 0x9
  ULONG UserAndGroupCount;                    // offset: 0x7c ordinal: 0xa
  ULONG RestrictedSidCount;                   // offset: 0x80 ordinal: 0xb
  ULONG VariableLength;                       // offset: 0x84 ordinal: 0xc
  ULONG DynamicCharged;                       // offset: 0x88 ordinal: 0xd
  ULONG DynamicAvailable;                     // offset: 0x8c ordinal: 0xe
  ULONG DefaultOwnerIndex;                    // offset: 0x90 ordinal: 0xf
  struct _SID_AND_ATTRIBUTES *UserAndGroups;  // offset: 0x98 ordinal: 0x10
  struct _SID_AND_ATTRIBUTES *RestrictedSids; // offset: 0xa0 ordinal: 0x11
  VOID *PrimaryGroup;                         // offset: 0xa8 ordinal: 0x12
  ULONG *DynamicPart;                         // offset: 0xb0 ordinal: 0x13
  struct _ACL *DefaultDacl;                   // offset: 0xb8 ordinal: 0x14
  enum _TOKEN_TYPE TokenType;                 // offset: 0xc0 ordinal: 0x15
  enum _SECURITY_IMPERSONATION_LEVEL
      ImpersonationLevel;    // offset: 0xc4 ordinal: 0x16
  ULONG TokenFlags;          // offset: 0xc8 ordinal: 0x17
  UCHAR TokenInUse;          // offset: 0xcc ordinal: 0x18
  ULONG IntegrityLevelIndex; // offset: 0xd0 ordinal: 0x19
  ULONG MandatoryPolicy;     // offset: 0xd4 ordinal: 0x1a
  struct _SEP_LOGON_SESSION_REFERENCES
      *LogonSession;                       // offset: 0xd8 ordinal: 0x1b
  struct _LUID OriginatingLogonSession;    // offset: 0xe0 ordinal: 0x1c
  struct _SID_AND_ATTRIBUTES_HASH SidHash; // offset: 0xe8 ordinal: 0x1d
  struct _SID_AND_ATTRIBUTES_HASH
      RestrictedSidHash; // offset: 0x1f8 ordinal: 0x1e
  struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
      *pSecurityAttributes;                 // offset: 0x308 ordinal: 0x1f
  VOID *Package;                            // offset: 0x310 ordinal: 0x20
  struct _SID_AND_ATTRIBUTES *Capabilities; // offset: 0x318 ordinal: 0x21
  ULONG CapabilityCount;                    // offset: 0x320 ordinal: 0x22
  struct _SID_AND_ATTRIBUTES_HASH
      CapabilitiesHash; // offset: 0x328 ordinal: 0x23
  struct _SEP_LOWBOX_NUMBER_ENTRY
      *LowboxNumberEntry; // offset: 0x438 ordinal: 0x24
  struct _SEP_CACHED_HANDLES_ENTRY
      *LowboxHandlesEntry; // offset: 0x440 ordinal: 0x25
  struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION
      *pClaimAttributes;                        // offset: 0x448 ordinal: 0x26
  VOID *TrustLevelSid;                          // offset: 0x450 ordinal: 0x27
  struct _TOKEN *TrustLinkedToken;              // offset: 0x458 ordinal: 0x28
  VOID *IntegrityLevelSidValue;                 // offset: 0x460 ordinal: 0x29
  struct _SEP_SID_VALUES_BLOCK *TokenSidValues; // offset: 0x468 ordinal: 0x2a
  struct _SEP_LUID_TO_INDEX_MAP_ENTRY
      *IndexEntry; // offset: 0x470 ordinal: 0x2b
  struct _SEP_TOKEN_DIAG_TRACK_ENTRY
      *DiagnosticInfo; // offset: 0x478 ordinal: 0x2c
  struct _SEP_CACHED_HANDLES_ENTRY
      *BnoIsolationHandlesEntry; // offset: 0x480 ordinal: 0x2d
  VOID *SessionObject;           // offset: 0x488 ordinal: 0x2e
  ULONGLONG VariablePart;        // offset: 0x490 ordinal: 0x2f
} _TOKEN;

// 0x28 bytes (sizeof)
typedef struct _PROCESS_DISK_COUNTERS {
  ULONGLONG BytesRead;           // offset: 0x0 ordinal: 0x0
  ULONGLONG BytesWritten;        // offset: 0x8 ordinal: 0x1
  ULONGLONG ReadOperationCount;  // offset: 0x10 ordinal: 0x2
  ULONGLONG WriteOperationCount; // offset: 0x18 ordinal: 0x3
  ULONGLONG FlushOperationCount; // offset: 0x20 ordinal: 0x4
} _PROCESS_DISK_COUNTERS;

// 0x80 bytes (sizeof)
typedef struct _MMSUPPORT_SHARED {
  LONG WorkingSetLock;                 // offset: 0x0 ordinal: 0x0
  LONG GoodCitizenWaiting;             // offset: 0x4 ordinal: 0x1
  ULONGLONG ReleasedCommitDebt;        // offset: 0x8 ordinal: 0x2
  ULONGLONG ResetPagesRepurposedCount; // offset: 0x10 ordinal: 0x3
  VOID *WsSwapSupport;                 // offset: 0x18 ordinal: 0x4
  VOID *CommitReleaseContext;          // offset: 0x20 ordinal: 0x5
  VOID *AccessLog;                     // offset: 0x28 ordinal: 0x6
  ULONGLONG ChargedWslePages;          // offset: 0x30 ordinal: 0x7
  ULONGLONG ActualWslePages;           // offset: 0x38 ordinal: 0x8
  LONG WorkingSetCoreLock;             // offset: 0x40 ordinal: 0x9
  VOID *ShadowMapping;                 // offset: 0x48 ordinal: 0xa
} _MMSUPPORT_SHARED;

// 0xc0 bytes (sizeof)
typedef struct _MMSUPPORT_INSTANCE {
  ULONG NextPageColor;                         // offset: 0x0 ordinal: 0x0
  ULONG PageFaultCount;                        // offset: 0x4 ordinal: 0x1
  ULONGLONG TrimmedPageCount;                  // offset: 0x8 ordinal: 0x2
  struct _MMWSL_INSTANCE *VmWorkingSetList;    // offset: 0x10 ordinal: 0x3
  struct _LIST_ENTRY WorkingSetExpansionLinks; // offset: 0x18 ordinal: 0x4
  ULONGLONG AgeDistribution[8];                // offset: 0x28 ordinal: 0x5
  struct _KGATE *ExitOutswapGate;              // offset: 0x68 ordinal: 0x6
  ULONGLONG MinimumWorkingSetSize;             // offset: 0x70 ordinal: 0x7
  ULONGLONG MaximumWorkingSetSize;             // offset: 0x78 ordinal: 0x8
  ULONGLONG WorkingSetLeafSize;                // offset: 0x80 ordinal: 0x9
  ULONGLONG WorkingSetLeafPrivateSize;         // offset: 0x88 ordinal: 0xa
  ULONGLONG WorkingSetSize;                    // offset: 0x90 ordinal: 0xb
  ULONGLONG WorkingSetPrivateSize;             // offset: 0x98 ordinal: 0xc
  ULONGLONG PeakWorkingSetSize;                // offset: 0xa0 ordinal: 0xd
  ULONG HardFaultCount;                        // offset: 0xa8 ordinal: 0xe
  USHORT LastTrimStamp;                        // offset: 0xac ordinal: 0xf
  USHORT PartitionId;                          // offset: 0xae ordinal: 0x10
  ULONGLONG SelfmapLock;                       // offset: 0xb0 ordinal: 0x11
  struct _MMSUPPORT_FLAGS Flags;               // offset: 0xb8 ordinal: 0x12
  LONG InterlockedFlags;                       // offset: 0xbc ordinal: 0x13
} _MMSUPPORT_INSTANCE;

// 0x140 bytes (sizeof)
typedef struct _MMSUPPORT_FULL {
  struct _MMSUPPORT_INSTANCE Instance; // offset: 0x0 ordinal: 0x0
  struct _MMSUPPORT_SHARED Shared;     // offset: 0xc0 ordinal: 0x1
} _MMSUPPORT_FULL;

// 0xd8 bytes (sizeof)
typedef struct _FILE_OBJECT {
  SHORT Type;                          // offset: 0x0 ordinal: 0x0
  SHORT Size;                          // offset: 0x2 ordinal: 0x1
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 ordinal: 0x2
  struct _VPB *Vpb;                    // offset: 0x10 ordinal: 0x3
  VOID *FsContext;                     // offset: 0x18 ordinal: 0x4
  VOID *FsContext2;                    // offset: 0x20 ordinal: 0x5
  struct _SECTION_OBJECT_POINTERS
      *SectionObjectPointer;              // offset: 0x28 ordinal: 0x6
  VOID *PrivateCacheMap;                  // offset: 0x30 ordinal: 0x7
  LONG FinalStatus;                       // offset: 0x38 ordinal: 0x8
  struct _FILE_OBJECT *RelatedFileObject; // offset: 0x40 ordinal: 0x9
  UCHAR LockOperation;                    // offset: 0x48 ordinal: 0xa
  UCHAR DeletePending;                    // offset: 0x49 ordinal: 0xb
  UCHAR ReadAccess;                       // offset: 0x4a ordinal: 0xc
  UCHAR WriteAccess;                      // offset: 0x4b ordinal: 0xd
  UCHAR DeleteAccess;                     // offset: 0x4c ordinal: 0xe
  UCHAR SharedRead;                       // offset: 0x4d ordinal: 0xf
  UCHAR SharedWrite;                      // offset: 0x4e ordinal: 0x10
  UCHAR SharedDelete;                     // offset: 0x4f ordinal: 0x11
  ULONG Flags;                            // offset: 0x50 ordinal: 0x12
  struct _UNICODE_STRING FileName;        // offset: 0x58 ordinal: 0x13
  union _LARGE_INTEGER CurrentByteOffset; // offset: 0x68 ordinal: 0x14
  ULONG Waiters;                          // offset: 0x70 ordinal: 0x15
  ULONG Busy;                             // offset: 0x74 ordinal: 0x16
  VOID *LastLock;                         // offset: 0x78 ordinal: 0x17
  struct _KEVENT Lock;                    // offset: 0x80 ordinal: 0x18
  struct _KEVENT Event;                   // offset: 0x98 ordinal: 0x19
  struct _IO_COMPLETION_CONTEXT
      *CompletionContext;     // offset: 0xb0 ordinal: 0x1a
  ULONGLONG IrpListLock;      // offset: 0xb8 ordinal: 0x1b
  struct _LIST_ENTRY IrpList; // offset: 0xc0 ordinal: 0x1c
  VOID *FileObjectExtension;  // offset: 0xd0 ordinal: 0x1d
} _FILE_OBJECT;

// 0x10 bytes (sizeof)
typedef struct _EXP_PULLED_FILE_TABLE {
  LONG NumberOfFiles;  // offset: 0x0 ordinal: 0x0
  LONG TableSize;      // offset: 0x4 ordinal: 0x1
  ULONGLONG Hashes[1]; // offset: 0x8 ordinal: 0x2
} _EXP_PULLED_FILE_TABLE;

// 0x38 bytes (sizeof)
typedef struct _HEAP_LFH_SUBSEGMENT {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  union {
    struct _HEAP_LFH_SUBSEGMENT_OWNER *Owner; // offset: 0x10 ordinal: 0x1
    union _HEAP_LFH_SUBSEGMENT_DELAY_FREE
        DelayFree; // offset: 0x10 ordinal: 0x2
  };
  ULONGLONG CommitLock; // offset: 0x18 ordinal: 0x3
  USHORT FreeCount;     // offset: 0x20 ordinal: 0x4
  USHORT BlockCount;    // offset: 0x22 ordinal: 0x5
  union {
    SHORT InterlockedShort; // offset: 0x20 ordinal: 0x6
    LONG InterlockedLong;   // offset: 0x20 ordinal: 0x7
  };
  USHORT FreeHint;         // offset: 0x24 ordinal: 0x8
  UCHAR Location;          // offset: 0x26 ordinal: 0x9
  UCHAR WitheldBlockCount; // offset: 0x27 ordinal: 0xa
  struct _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS
      BlockOffsets;         // offset: 0x28 ordinal: 0xb
  UCHAR CommitUnitShift;    // offset: 0x2c ordinal: 0xc
  UCHAR CommitUnitCount;    // offset: 0x2d ordinal: 0xd
  USHORT CommitStateOffset; // offset: 0x2e ordinal: 0xe
  ULONGLONG BlockBitmap[1]; // offset: 0x30 ordinal: 0xf
} _HEAP_LFH_SUBSEGMENT;

// 0x10 bytes (sizeof)
typedef struct _PS_TRUSTLET_ATTRIBUTE_DATA {
  struct _PS_TRUSTLET_ATTRIBUTE_HEADER Header; // offset: 0x0 ordinal: 0x0
  ULONGLONG Data[1];                           // offset: 0x8 ordinal: 0x1
} _PS_TRUSTLET_ATTRIBUTE_DATA;

// 0x18 bytes (sizeof)
typedef struct _PS_TRUSTLET_CREATE_ATTRIBUTES {
  ULONGLONG TrustletIdentity;                       // offset: 0x0 ordinal: 0x0
  struct _PS_TRUSTLET_ATTRIBUTE_DATA Attributes[1]; // offset: 0x8 ordinal: 0x1
} _PS_TRUSTLET_CREATE_ATTRIBUTES;

// 0x40 bytes (sizeof)
typedef struct _PROC_PERF_CHECK_CYCLE_SNAP {
  ULONGLONG CyclesActive;          // offset: 0x0 ordinal: 0x0
  ULONGLONG CyclesAffinitized;     // offset: 0x8 ordinal: 0x1
  ULONGLONG TaggedThreadCycles[4]; // offset: 0x10 ordinal: 0x2
  ULONG WorkloadClasses;           // offset: 0x30 ordinal: 0x3
  ULONGLONG ThreadTypeCycles[1];   // offset: 0x38 ordinal: 0x4
} _PROC_PERF_CHECK_CYCLE_SNAP;

// 0x578 bytes (sizeof)
typedef struct _PROC_PERF_CHECK {
  ULONGLONG LastActive;                           // offset: 0x0 ordinal: 0x0
  ULONGLONG LastTime;                             // offset: 0x8 ordinal: 0x1
  ULONGLONG LastStall;                            // offset: 0x10 ordinal: 0x2
  ULONG LastResponsivenessEvents;                 // offset: 0x18 ordinal: 0x3
  struct _PROC_PERF_CHECK_SNAP LastPerfCheckSnap; // offset: 0x20 ordinal: 0x4
  struct _PROC_PERF_CHECK_CYCLE_SNAP
      *LastPerfCheckCycleSnap;              // offset: 0x58 ordinal: 0x5
  struct _PROC_PERF_CHECK_SNAP CurrentSnap; // offset: 0x60 ordinal: 0x6
  struct _PROC_PERF_CHECK_CYCLE_SNAP
      *CurrentCycleSnap;                          // offset: 0x98 ordinal: 0x7
  struct _PROC_PERF_CHECK_SNAP LastDeliveredSnap; // offset: 0xa0 ordinal: 0x8
  struct _PROC_PERF_CHECK_CYCLE_SNAP
      *LastDeliveredCycleSnap;       // offset: 0xd8 ordinal: 0x9
  ULONG LastDeliveredPerformance;    // offset: 0xe0 ordinal: 0xa
  ULONG LastDeliveredFrequency;      // offset: 0xe4 ordinal: 0xb
  UCHAR TaggedThreadPercent[4];      // offset: 0xe8 ordinal: 0xc
  UCHAR ImportantPercent;            // offset: 0xec ordinal: 0xd
  UCHAR IdealPercent;                // offset: 0xed ordinal: 0xe
  UCHAR Class0FloorPerfSelection;    // offset: 0xee ordinal: 0xf
  UCHAR Class1MinimumPerfSelection;  // offset: 0xef ordinal: 0x10
  ULONG CurrentResponsivenessEvents; // offset: 0xf0 ordinal: 0x11
  ULONGLONG CyclesByFreqBand[3][48]; // offset: 0xf8 ordinal: 0x12
} _PROC_PERF_CHECK;

// 0x10 bytes (sizeof)
typedef struct _PROCESSOR_CYCLES_WORKLOAD_CLASS {
  ULONG Count;                       // offset: 0x0 ordinal: 0x0
  ULONGLONG ProcessorCyclesClass[1]; // offset: 0x8 ordinal: 0x1
} _PROCESSOR_CYCLES_WORKLOAD_CLASS;

// 0x150 bytes (sizeof)
typedef struct _PPM_CONCURRENCY_ACCOUNTING {
  ULONGLONG Lock;                  // offset: 0x0 ordinal: 0x0
  ULONG Processors;                // offset: 0x8 ordinal: 0x1
  ULONG ActiveProcessors;          // offset: 0xc ordinal: 0x2
  ULONGLONG LastUpdateTime;        // offset: 0x10 ordinal: 0x3
  ULONGLONG TotalTime;             // offset: 0x18 ordinal: 0x4
  ULONGLONG IdleIntervalStats[37]; // offset: 0x20 ordinal: 0x5
  ULONGLONG AccumulatedTime[1];    // offset: 0x148 ordinal: 0x6
} _PPM_CONCURRENCY_ACCOUNTING;

// 0x108 bytes (sizeof)
typedef struct _KAFFINITY_EX {
  USHORT Count;   // offset: 0x0 ordinal: 0x0
  USHORT Size;    // offset: 0x2 ordinal: 0x1
  ULONG Reserved; // offset: 0x4 ordinal: 0x2
  union {
    ULONGLONG Bitmap[1];        // offset: 0x8 ordinal: 0x3
    ULONGLONG StaticBitmap[32]; // offset: 0x8 ordinal: 0x4
  };
} _KAFFINITY_EX;

// 0x1c0 bytes (sizeof)
typedef struct _PPM_PLATFORM_STATE {
  ULONGLONG LevelId;                          // offset: 0x0 ordinal: 0x0
  ULONG Latency;                              // offset: 0x8 ordinal: 0x1
  ULONG BreakEvenDuration;                    // offset: 0xc ordinal: 0x2
  struct _PPM_VETO_ACCOUNTING VetoAccounting; // offset: 0x10 ordinal: 0x3
  UCHAR TransitionDebugger;                   // offset: 0x38 ordinal: 0x4
  UCHAR Platform;                             // offset: 0x39 ordinal: 0x5
  ULONG DependencyListCount;                  // offset: 0x3c ordinal: 0x6
  struct _KAFFINITY_EX Processors;            // offset: 0x40 ordinal: 0x7
  struct _UNICODE_STRING Name;                // offset: 0x148 ordinal: 0x8
  struct _PPM_SELECTION_DEPENDENCY
      *DependencyLists; // offset: 0x158 ordinal: 0x9
  union _PPM_COORDINATED_SYNCHRONIZATION
      Synchronization; // offset: 0x160 ordinal: 0xa
  ULONGLONG EnterTime; // offset: 0x168 ordinal: 0xb
  union {
    LONG RefCount;         // offset: 0x180 ordinal: 0xc
    UCHAR CacheAlign0[64]; // offset: 0x180 ordinal: 0xd
  };
} _PPM_PLATFORM_STATE;

// 0x200 bytes (sizeof)
typedef struct _PPM_PLATFORM_STATES {
  ULONG StateCount;                        // offset: 0x0 ordinal: 0x0
  ULONG InterfaceVersion;                  // offset: 0x4 ordinal: 0x1
  ULONG ProcessorCount;                    // offset: 0x8 ordinal: 0x2
  UCHAR CoordinatedInterface;              // offset: 0xc ordinal: 0x3
  ULONG (*IdleTest)(VOID *, ULONG, ULONG); // offset: 0x10 ordinal: 0x4
  LONG(*IdlePreExecute)
  (VOID *, ULONG, ULONG, ULONG, ULONG *); // offset: 0x18 ordinal: 0x5
  VOID(*IdleComplete)
  (VOID *, ULONG, ULONG, ULONG, ULONG *); // offset: 0x20 ordinal: 0x6
  LONG(*QueryPlatformStateResidency)
  (VOID *,
   struct _PROCESSOR_PLATFORM_STATE_RESIDENCIES *); // offset: 0x28 ordinal: 0x7
  struct _PLATFORM_IDLE_ACCOUNTING *Accounting;     // offset: 0x30 ordinal: 0x8
  UCHAR DeepSleepEnabled;                           // offset: 0x38 ordinal: 0x9
  struct _PPM_PLATFORM_STATE State[1];              // offset: 0x40 ordinal: 0xa
} _PPM_PLATFORM_STATES;

// 0x158 bytes (sizeof)
typedef struct _PPM_IDLE_STATE {
  struct _KAFFINITY_EX DomainMembers;         // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING Name;                // offset: 0x108 ordinal: 0x1
  ULONG Latency;                              // offset: 0x118 ordinal: 0x2
  ULONG BreakEvenDuration;                    // offset: 0x11c ordinal: 0x3
  ULONG Power;                                // offset: 0x120 ordinal: 0x4
  ULONG StateFlags;                           // offset: 0x124 ordinal: 0x5
  struct _PPM_VETO_ACCOUNTING VetoAccounting; // offset: 0x128 ordinal: 0x6
  UCHAR StateType;                            // offset: 0x150 ordinal: 0x7
  UCHAR InterruptsEnabled;                    // offset: 0x151 ordinal: 0x8
  UCHAR Interruptible;                        // offset: 0x152 ordinal: 0x9
  UCHAR ContextRetained;                      // offset: 0x153 ordinal: 0xa
  UCHAR CacheCoherent;                        // offset: 0x154 ordinal: 0xb
  UCHAR WakesSpuriously;                      // offset: 0x155 ordinal: 0xc
  UCHAR PlatformOnly;                         // offset: 0x156 ordinal: 0xd
  UCHAR NoCState;                             // offset: 0x157 ordinal: 0xe
} _PPM_IDLE_STATE;

// 0x5b0 bytes (sizeof)
typedef struct _PPM_IDLE_STATES {
  UCHAR InterfaceVersion;                      // offset: 0x0 ordinal: 0x0
  UCHAR IdleOverride;                          // offset: 0x1 ordinal: 0x1
  UCHAR EstimateIdleDuration;                  // offset: 0x2 ordinal: 0x2
  UCHAR ExitLatencyTraceEnabled;               // offset: 0x3 ordinal: 0x3
  UCHAR NonInterruptibleTransition;            // offset: 0x4 ordinal: 0x4
  UCHAR UnaccountedTransition;                 // offset: 0x5 ordinal: 0x5
  UCHAR IdleDurationLimited;                   // offset: 0x6 ordinal: 0x6
  UCHAR IdleCheckLimited;                      // offset: 0x7 ordinal: 0x7
  ULONGLONG IdleReevaluationDuration;          // offset: 0x8 ordinal: 0x8
  UCHAR StrictVetoBias;                        // offset: 0x10 ordinal: 0x9
  ULONG ExitLatencyCountdown;                  // offset: 0x14 ordinal: 0xa
  ULONG TargetState;                           // offset: 0x18 ordinal: 0xb
  ULONG ActualState;                           // offset: 0x1c ordinal: 0xc
  ULONG OldState;                              // offset: 0x20 ordinal: 0xd
  ULONG OverrideIndex;                         // offset: 0x24 ordinal: 0xe
  ULONG ProcessorIdleCount;                    // offset: 0x28 ordinal: 0xf
  ULONG Type;                                  // offset: 0x2c ordinal: 0x10
  ULONGLONG LevelId;                           // offset: 0x30 ordinal: 0x11
  USHORT ReasonFlags;                          // offset: 0x38 ordinal: 0x12
  ULONGLONG InitiateWakeStamp;                 // offset: 0x40 ordinal: 0x13
  LONG PreviousStatus;                         // offset: 0x48 ordinal: 0x14
  ULONG PreviousCancelReason;                  // offset: 0x4c ordinal: 0x15
  struct _KAFFINITY_EX PrimaryProcessorMask;   // offset: 0x50 ordinal: 0x16
  struct _KAFFINITY_EX SecondaryProcessorMask; // offset: 0x158 ordinal: 0x17
  VOID(*IdlePrepare)
  (struct _PROCESSOR_IDLE_PREPARE_INFO *); // offset: 0x260 ordinal: 0x18
  LONG(*IdlePreExecute)
  (VOID *, ULONG, ULONG, ULONG, ULONG *); // offset: 0x268 ordinal: 0x19
  LONG(*IdleExecute)
  (VOID *, ULONGLONG, ULONG, ULONG, ULONG, ULONG,
   ULONG *); // offset: 0x270 ordinal: 0x1a
  ULONG(*IdlePreselect)
  (VOID *, struct _PROCESSOR_IDLE_CONSTRAINTS *); // offset: 0x278 ordinal: 0x1b
  ULONG (*IdleTest)(VOID *, ULONG, ULONG);        // offset: 0x280 ordinal: 0x1c
  ULONG (*IdleAvailabilityCheck)(VOID *, ULONG);  // offset: 0x288 ordinal: 0x1d
  VOID(*IdleComplete)
  (VOID *, ULONG, ULONG, ULONG, ULONG *); // offset: 0x290 ordinal: 0x1e
  VOID (*IdleCancel)(VOID *, ULONG);      // offset: 0x298 ordinal: 0x1f
  UCHAR (*IdleIsHalted)(VOID *);          // offset: 0x2a0 ordinal: 0x20
  UCHAR (*IdleInitiateWake)(VOID *);      // offset: 0x2a8 ordinal: 0x21
  struct _PROCESSOR_IDLE_PREPARE_INFO
      PrepareInfo;                               // offset: 0x2b0 ordinal: 0x22
  struct _KAFFINITY_EX DeepIdleSnapshot;         // offset: 0x308 ordinal: 0x23
  struct _PERFINFO_PPM_STATE_SELECTION *Tracing; // offset: 0x410 ordinal: 0x24
  struct _PERFINFO_PPM_STATE_SELECTION
      *CoordinatedTracing;                    // offset: 0x418 ordinal: 0x25
  struct _PPM_SELECTION_MENU ProcessorMenu;   // offset: 0x420 ordinal: 0x26
  struct _PPM_SELECTION_MENU CoordinatedMenu; // offset: 0x430 ordinal: 0x27
  struct _PPM_COORDINATED_SELECTION
      CoordinatedSelection;        // offset: 0x440 ordinal: 0x28
  struct _PPM_IDLE_STATE State[1]; // offset: 0x458 ordinal: 0x29
} _PPM_IDLE_STATES;

// 0x110 bytes (sizeof)
typedef struct _KSOFTWARE_INTERRUPT_BATCH {
  UCHAR Level;                                 // offset: 0x0 ordinal: 0x0
  UCHAR TargetType;                            // offset: 0x1 ordinal: 0x1
  UCHAR ReservedBatchInProgress;               // offset: 0x2 ordinal: 0x2
  UCHAR Spare;                                 // offset: 0x3 ordinal: 0x3
  ULONG SingleTargetIndex;                     // offset: 0x4 ordinal: 0x4
  struct _KAFFINITY_EX MultipleTargetAffinity; // offset: 0x8 ordinal: 0x5
} _KSOFTWARE_INTERRUPT_BATCH;

// 0x420 bytes (sizeof)
typedef struct _KSTATIC_AFFINITY_BLOCK {
  union {
    struct _KAFFINITY_EX KeFlushTbAffinity;     // offset: 0x0 ordinal: 0x0
    struct _KAFFINITY_EX KeFlushWbAffinity;     // offset: 0x0 ordinal: 0x1
    struct _KAFFINITY_EX KeSyncContextAffinity; // offset: 0x0 ordinal: 0x2
  };
  struct _KAFFINITY_EX KeFlushTbDeepIdleAffinity; // offset: 0x108 ordinal: 0x3
  struct _KAFFINITY_EX KeIpiSendAffinity;         // offset: 0x210 ordinal: 0x4
  struct _KAFFINITY_EX KeIpiSendIpiSet;           // offset: 0x318 ordinal: 0x5
} _KSTATIC_AFFINITY_BLOCK;

typedef VOID (*__anon_3251)(UCHAR, struct _KAFFINITY_EX *);

typedef LONG (*__anon_1852)(struct _KAFFINITY_EX *, ULONG);

// 0x118 bytes (sizeof)
typedef struct _KE_IDEAL_PROCESSOR_ASSIGNMENT_BLOCK {
  union _KE_PROCESS_CONCURRENCY_COUNT
      ExpectedConcurrencyCount; // offset: 0x0 ordinal: 0x0
  struct _KE_IDEAL_PROCESSOR_SET_BREAKPOINTS
      Breakpoints;                         // offset: 0x4 ordinal: 0x1
  union __anon_119 AssignmentFlags;        // offset: 0xc ordinal: 0x2
  struct _KAFFINITY_EX IdealProcessorSets; // offset: 0x10 ordinal: 0x3
} _KE_IDEAL_PROCESSOR_ASSIGNMENT_BLOCK;

// 0x8 bytes (sizeof)
typedef union __anon_94 {
  ULONGLONG SecureHandle;  // offset: 0x0 ordinal: 0x0
  struct __anon_123 Flags; // offset: 0x0 ordinal: 0x1
} __anon_94;

// 0x30 bytes (sizeof)
typedef struct _PS_PROCESS_WAKE_INFORMATION {
  ULONGLONG NotificationChannel;            // offset: 0x0 ordinal: 0x0
  ULONG WakeCounters[7];                    // offset: 0x8 ordinal: 0x1
  struct _JOBOBJECT_WAKE_FILTER WakeFilter; // offset: 0x24 ordinal: 0x2
  ULONG NoWakeCounter;                      // offset: 0x2c ordinal: 0x3
} _PS_PROCESS_WAKE_INFORMATION;

typedef LONG (*__anon_3745)(struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *,
                            ULONGLONG *, ULONGLONG *);

typedef LONG (*__anon_3743)(struct _IO_RESOURCE_DESCRIPTOR *, ULONGLONG *,
                            ULONGLONG *, ULONGLONG *, ULONGLONG *);

// 0x158 bytes (sizeof)
typedef struct _ARBITER_INSTANCE {
  ULONG Signature;                            // offset: 0x0 ordinal: 0x0
  struct _KEVENT *MutexEvent;                 // offset: 0x8 ordinal: 0x1
  WCHAR *Name;                                // offset: 0x10 ordinal: 0x2
  WCHAR *OrderingName;                        // offset: 0x18 ordinal: 0x3
  LONG ResourceType;                          // offset: 0x20 ordinal: 0x4
  struct _RTL_RANGE_LIST *Allocation;         // offset: 0x28 ordinal: 0x5
  struct _RTL_RANGE_LIST *PossibleAllocation; // offset: 0x30 ordinal: 0x6
  struct _ARBITER_ORDERING_LIST OrderingList; // offset: 0x38 ordinal: 0x7
  struct _ARBITER_ORDERING_LIST ReservedList; // offset: 0x48 ordinal: 0x8
  LONG ReferenceCount;                        // offset: 0x58 ordinal: 0x9
  struct _ARBITER_INTERFACE *Interface;       // offset: 0x60 ordinal: 0xa
  ULONG AllocationStackMaxSize;               // offset: 0x68 ordinal: 0xb
  struct _ARBITER_ALLOCATION_STATE
      *AllocationStack; // offset: 0x70 ordinal: 0xc
  LONG(*UnpackRequirement)
  (struct _IO_RESOURCE_DESCRIPTOR *, ULONGLONG *, ULONGLONG *, ULONGLONG *,
   ULONGLONG *); // offset: 0x78 ordinal: 0xd
  LONG(*PackResource)
  (struct _IO_RESOURCE_DESCRIPTOR *, ULONGLONG,
   struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *); // offset: 0x80 ordinal: 0xe
  LONG(*UnpackResource)
  (struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *, ULONGLONG *,
   ULONGLONG *); // offset: 0x88 ordinal: 0xf
  LONG(*ScoreRequirement)
  (struct _IO_RESOURCE_DESCRIPTOR *); // offset: 0x90 ordinal: 0x10
  LONG(*TestAllocation)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_TEST_ALLOCATION_PARAMETERS *); // offset: 0x98 ordinal: 0x11
  LONG(*RetestAllocation)
  (struct _ARBITER_INSTANCE *, struct _ARBITER_RETEST_ALLOCATION_PARAMETERS
                                   *); // offset: 0xa0 ordinal: 0x12
  LONG(*CommitAllocation)
  (struct _ARBITER_INSTANCE *); // offset: 0xa8 ordinal: 0x13
  LONG(*RollbackAllocation)
  (struct _ARBITER_INSTANCE *); // offset: 0xb0 ordinal: 0x14
  LONG(*BootAllocation)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_BOOT_ALLOCATION_PARAMETERS *); // offset: 0xb8 ordinal: 0x15
  LONG(*QueryArbitrate)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_QUERY_ARBITRATE_PARAMETERS *); // offset: 0xc0 ordinal: 0x16
  LONG(*QueryConflict)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_QUERY_CONFLICT_PARAMETERS *); // offset: 0xc8 ordinal: 0x17
  LONG(*AddReserved)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ADD_RESERVED_PARAMETERS *); // offset: 0xd0 ordinal: 0x18
  LONG(*StartArbiter)
  (struct _ARBITER_INSTANCE *,
   struct _CM_RESOURCE_LIST *); // offset: 0xd8 ordinal: 0x19
  LONG(*PreprocessEntry)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ALLOCATION_STATE *); // offset: 0xe0 ordinal: 0x1a
  LONG(*AllocateEntry)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ALLOCATION_STATE *); // offset: 0xe8 ordinal: 0x1b
  UCHAR(*GetNextAllocationRange)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ALLOCATION_STATE *); // offset: 0xf0 ordinal: 0x1c
  UCHAR(*FindSuitableRange)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ALLOCATION_STATE *); // offset: 0xf8 ordinal: 0x1d
  VOID(*AddAllocation)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ALLOCATION_STATE *); // offset: 0x100 ordinal: 0x1e
  VOID(*BacktrackAllocation)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ALLOCATION_STATE *); // offset: 0x108 ordinal: 0x1f
  UCHAR(*OverrideConflict)
  (struct _ARBITER_INSTANCE *,
   struct _ARBITER_ALLOCATION_STATE *); // offset: 0x110 ordinal: 0x20
  LONG(*InitializeRangeList)
  (struct _ARBITER_INSTANCE *, ULONG, struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *,
   struct _RTL_RANGE_LIST *); // offset: 0x118 ordinal: 0x21
  LONG(*DeleteOwnerRanges)
  (struct _ARBITER_INSTANCE *, VOID *);   // offset: 0x120 ordinal: 0x22
  UCHAR TransactionInProgress;            // offset: 0x128 ordinal: 0x23
  struct _KEVENT *TransactionEvent;       // offset: 0x130 ordinal: 0x24
  VOID *Extension;                        // offset: 0x138 ordinal: 0x25
  struct _DEVICE_OBJECT *BusDeviceObject; // offset: 0x140 ordinal: 0x26
  VOID *ConflictCallbackContext;          // offset: 0x148 ordinal: 0x27
  UCHAR(*ConflictCallback)
  (VOID *, struct _RTL_RANGE *); // offset: 0x150 ordinal: 0x28
} _ARBITER_INSTANCE;

typedef LONG (*__anon_3759)(struct _ARBITER_INSTANCE *, VOID *);

typedef LONG (*__anon_3758)(struct _ARBITER_INSTANCE *, ULONG,
                            struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *,
                            struct _RTL_RANGE_LIST *);

typedef VOID (*__anon_3757)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_ALLOCATION_STATE *);

typedef UCHAR (*__anon_3756)(struct _ARBITER_INSTANCE *,
                             struct _ARBITER_ALLOCATION_STATE *);

typedef LONG (*__anon_3755)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_ALLOCATION_STATE *);

typedef LONG (*__anon_3754)(struct _ARBITER_INSTANCE *,
                            struct _CM_RESOURCE_LIST *);

typedef LONG (*__anon_3753)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_ADD_RESERVED_PARAMETERS *);

typedef LONG (*__anon_3752)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_QUERY_CONFLICT_PARAMETERS *);

typedef LONG (*__anon_3751)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_QUERY_ARBITRATE_PARAMETERS *);

typedef LONG (*__anon_3750)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_BOOT_ALLOCATION_PARAMETERS *);

typedef LONG (*__anon_3749)(struct _ARBITER_INSTANCE *);

typedef LONG (*__anon_3748)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_RETEST_ALLOCATION_PARAMETERS *);

typedef LONG (*__anon_3747)(struct _ARBITER_INSTANCE *,
                            struct _ARBITER_TEST_ALLOCATION_PARAMETERS *);

// 0x10 bytes (sizeof)
typedef struct __anon_3566 {
  ULONGLONG *PageFrame;    // offset: 0x0 ordinal: 0x0
  ULONGLONG NumberOfPages; // offset: 0x8 ordinal: 0x1
} __anon_3566;

// 0x18 bytes (sizeof)
typedef struct _IOMMU_MAP_PHYSICAL_ADDRESS {
  enum _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE MapType; // offset: 0x0 ordinal: 0x0
  union {
    struct __anon_3564 Mdl;             // offset: 0x8 ordinal: 0x1
    struct __anon_3565 ContiguousRange; // offset: 0x8 ordinal: 0x2
    struct __anon_3566 PfnArray;        // offset: 0x8 ordinal: 0x3
  };
} _IOMMU_MAP_PHYSICAL_ADDRESS;

typedef LONG (*__anon_3515)(
    struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN *, ULONGLONG, ULONG,
    struct _IOMMU_MAP_PHYSICAL_ADDRESS *,
    struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT *);

typedef LONG (*__anon_3508)(struct _IOMMU_DMA_DOMAIN *,
                            struct _IOMMU_MAP_PHYSICAL_ADDRESS *);

typedef LONG (*__anon_3507)(struct _IOMMU_DMA_DOMAIN *, ULONG,
                            struct _IOMMU_MAP_PHYSICAL_ADDRESS *);

typedef LONG (*__anon_3513)(struct _IOMMU_DMA_DOMAIN *, ULONGLONG, ULONGLONG *,
                            ULONGLONG *, ULONGLONG *,
                            struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN **);

typedef LONG (*__anon_3506)(struct _IOMMU_DMA_DOMAIN *, ULONG,
                            struct _IOMMU_MAP_PHYSICAL_ADDRESS *, ULONGLONG *,
                            ULONGLONG *, ULONGLONG *, ULONGLONG *);

typedef LONG (*__anon_3453)(ULONG, ULONG, ULONGLONG *);

// 0x28 bytes (sizeof)
typedef struct _HIDDEN_PROCESSOR_POWER_INTERFACE {
  ULONG Version;                                  // offset: 0x0 ordinal: 0x0
  LONG (*ReadPerfMsr)(ULONG, ULONG, ULONGLONG *); // offset: 0x8 ordinal: 0x1
  LONG(*WritePerfMsr)
  (ULONG, ULONG, ULONGLONG, ULONGLONG); // offset: 0x10 ordinal: 0x2
  LONG(*ReadPerfIoPort)
  (ULONG, USHORT, USHORT, ULONG *); // offset: 0x18 ordinal: 0x3
  LONG(*WritePerfIoPort)
  (ULONG, USHORT, USHORT, ULONG, ULONG); // offset: 0x20 ordinal: 0x4
} _HIDDEN_PROCESSOR_POWER_INTERFACE;

typedef LONG (*__anon_3302)(struct _HIDDEN_PROCESSOR_POWER_INTERFACE *);

// 0x18 bytes (sizeof)
typedef struct _PNP_REPLACE_PROCESSOR_LIST {
  ULONGLONG *Affinity;  // offset: 0x0 ordinal: 0x0
  ULONG GroupCount;     // offset: 0x8 ordinal: 0x1
  ULONG AllocatedCount; // offset: 0xc ordinal: 0x2
  ULONG Count;          // offset: 0x10 ordinal: 0x3
  ULONG ApicIds[1];     // offset: 0x14 ordinal: 0x4
} _PNP_REPLACE_PROCESSOR_LIST;

// 0x18 bytes (sizeof)
typedef struct _HAL_DP_REPLACE_PARAMETERS {
  ULONG Flags; // offset: 0x0 ordinal: 0x0
  struct _PNP_REPLACE_PROCESSOR_LIST
      *TargetProcessors; // offset: 0x8 ordinal: 0x1
  struct _PNP_REPLACE_PROCESSOR_LIST
      *SpareProcessors; // offset: 0x10 ordinal: 0x2
} _HAL_DP_REPLACE_PARAMETERS;

typedef LONG (*__anon_3249)(struct _HAL_DP_REPLACE_PARAMETERS *, VOID **);

typedef VOID (*__anon_3311)(ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG,
                            ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG *,
                            ULONGLONG *, ULONGLONG *, ULONGLONG *);

typedef LONG (*__anon_3293)(enum _HAL_PROCESSOR_STAT_TYPE, ULONG, ULONG,
                            ULONGLONG *);

typedef LONG (*__anon_3290)(ULONGLONG *);

typedef LONG (*__anon_3289)(ULONGLONG, ULONGLONG *, ULONGLONG *);

typedef LONG (*__anon_3283)(enum _HAL_CLOCK_TIMER_MODE, ULONGLONG, ULONGLONG *);

typedef LONG (*__anon_3279)(VOID *, ULONG, ULONGLONG *, ULONG *);

typedef ULONGLONG (*__anon_3273)(ULONGLONG *);

typedef VOID (*__anon_3270)(struct _HAL_PMC_COUNTERS *, ULONGLONG *);

typedef UCHAR (*__anon_3250)(ULONGLONG *, ULONGLONG *);

typedef ULONG (*__anon_3245)(enum _INTERFACE_TYPE, ULONG, ULONG, ULONG, UCHAR *,
                             ULONGLONG *);

typedef UCHAR (*__anon_3237)(union _LARGE_INTEGER, ULONG *,
                             union _LARGE_INTEGER *, ULONGLONG *, UCHAR);

typedef LONG (*__anon_2836)(VOID *, VOID **, ULONGLONG *);

// 0x2c0 bytes (sizeof)
typedef struct _HEAP {
  union {
    struct _HEAP_SEGMENT Segment; // offset: 0x0 ordinal: 0x0
    struct _HEAP_ENTRY Entry;     // offset: 0x0 ordinal: 0x1
  };
  ULONG SegmentSignature;                 // offset: 0x10 ordinal: 0x2
  ULONG SegmentFlags;                     // offset: 0x14 ordinal: 0x3
  struct _LIST_ENTRY SegmentListEntry;    // offset: 0x18 ordinal: 0x4
  struct _HEAP *Heap;                     // offset: 0x28 ordinal: 0x5
  VOID *BaseAddress;                      // offset: 0x30 ordinal: 0x6
  ULONG NumberOfPages;                    // offset: 0x38 ordinal: 0x7
  struct _HEAP_ENTRY *FirstEntry;         // offset: 0x40 ordinal: 0x8
  struct _HEAP_ENTRY *LastValidEntry;     // offset: 0x48 ordinal: 0x9
  ULONG NumberOfUnCommittedPages;         // offset: 0x50 ordinal: 0xa
  ULONG NumberOfUnCommittedRanges;        // offset: 0x54 ordinal: 0xb
  USHORT SegmentAllocatorBackTraceIndex;  // offset: 0x58 ordinal: 0xc
  USHORT Reserved;                        // offset: 0x5a ordinal: 0xd
  struct _LIST_ENTRY UCRSegmentList;      // offset: 0x60 ordinal: 0xe
  ULONG Flags;                            // offset: 0x70 ordinal: 0xf
  ULONG ForceFlags;                       // offset: 0x74 ordinal: 0x10
  ULONG CompatibilityFlags;               // offset: 0x78 ordinal: 0x11
  ULONG EncodeFlagMask;                   // offset: 0x7c ordinal: 0x12
  struct _HEAP_ENTRY Encoding;            // offset: 0x80 ordinal: 0x13
  ULONG Interceptor;                      // offset: 0x90 ordinal: 0x14
  ULONG VirtualMemoryThreshold;           // offset: 0x94 ordinal: 0x15
  ULONG Signature;                        // offset: 0x98 ordinal: 0x16
  ULONGLONG SegmentReserve;               // offset: 0xa0 ordinal: 0x17
  ULONGLONG SegmentCommit;                // offset: 0xa8 ordinal: 0x18
  ULONGLONG DeCommitFreeBlockThreshold;   // offset: 0xb0 ordinal: 0x19
  ULONGLONG DeCommitTotalFreeThreshold;   // offset: 0xb8 ordinal: 0x1a
  ULONGLONG TotalFreeSize;                // offset: 0xc0 ordinal: 0x1b
  ULONGLONG MaximumAllocationSize;        // offset: 0xc8 ordinal: 0x1c
  USHORT ProcessHeapsListIndex;           // offset: 0xd0 ordinal: 0x1d
  USHORT HeaderValidateLength;            // offset: 0xd2 ordinal: 0x1e
  VOID *HeaderValidateCopy;               // offset: 0xd8 ordinal: 0x1f
  USHORT NextAvailableTagIndex;           // offset: 0xe0 ordinal: 0x20
  USHORT MaximumTagIndex;                 // offset: 0xe2 ordinal: 0x21
  struct _HEAP_TAG_ENTRY *TagEntries;     // offset: 0xe8 ordinal: 0x22
  struct _LIST_ENTRY UCRList;             // offset: 0xf0 ordinal: 0x23
  ULONGLONG AlignRound;                   // offset: 0x100 ordinal: 0x24
  ULONGLONG AlignMask;                    // offset: 0x108 ordinal: 0x25
  struct _LIST_ENTRY VirtualAllocdBlocks; // offset: 0x110 ordinal: 0x26
  struct _LIST_ENTRY SegmentList;         // offset: 0x120 ordinal: 0x27
  USHORT AllocatorBackTraceIndex;         // offset: 0x130 ordinal: 0x28
  ULONG NonDedicatedListLength;           // offset: 0x134 ordinal: 0x29
  VOID *BlocksIndex;                      // offset: 0x138 ordinal: 0x2a
  VOID *UCRIndex;                         // offset: 0x140 ordinal: 0x2b
  struct _HEAP_PSEUDO_TAG_ENTRY
      *PseudoTagEntries;           // offset: 0x148 ordinal: 0x2c
  struct _LIST_ENTRY FreeLists;    // offset: 0x150 ordinal: 0x2d
  struct _HEAP_LOCK *LockVariable; // offset: 0x160 ordinal: 0x2e
  LONG(*CommitRoutine)
  (VOID *, VOID **, ULONGLONG *);        // offset: 0x168 ordinal: 0x2f
  union _RTL_RUN_ONCE StackTraceInitVar; // offset: 0x170 ordinal: 0x30
  struct _RTL_HEAP_MEMORY_LIMIT_DATA
      CommitLimitData;                 // offset: 0x178 ordinal: 0x31
  VOID *FrontEndHeap;                  // offset: 0x198 ordinal: 0x32
  USHORT FrontHeapLockCount;           // offset: 0x1a0 ordinal: 0x33
  UCHAR FrontEndHeapType;              // offset: 0x1a2 ordinal: 0x34
  UCHAR RequestedFrontEndHeapType;     // offset: 0x1a3 ordinal: 0x35
  USHORT *FrontEndHeapUsageData;       // offset: 0x1a8 ordinal: 0x36
  USHORT FrontEndHeapMaximumIndex;     // offset: 0x1b0 ordinal: 0x37
  UCHAR FrontEndHeapStatusBitmap[129]; // offset: 0x1b2 ordinal: 0x38
  struct _HEAP_COUNTERS Counters;      // offset: 0x238 ordinal: 0x39
  struct _HEAP_TUNING_PARAMETERS
      TuningParameters; // offset: 0x2b0 ordinal: 0x3a
} _HEAP;

// 0x40 bytes (sizeof)
typedef struct _RTL_CSPARSE_BITMAP {
  ULONGLONG *CommitBitmap;             // offset: 0x0 ordinal: 0x0
  ULONGLONG *UserBitmap;               // offset: 0x8 ordinal: 0x1
  ULONGLONG BitCount;                  // offset: 0x10 ordinal: 0x2
  ULONGLONG BitmapLock;                // offset: 0x18 ordinal: 0x3
  ULONGLONG DecommitPageIndex;         // offset: 0x20 ordinal: 0x4
  ULONGLONG RtlpCSparseBitmapWakeLock; // offset: 0x28 ordinal: 0x5
  UCHAR LockType;                      // offset: 0x30 ordinal: 0x6
  UCHAR AddressSpace;                  // offset: 0x31 ordinal: 0x7
  UCHAR MemType;                       // offset: 0x32 ordinal: 0x8
  UCHAR AllocAlignment;                // offset: 0x33 ordinal: 0x9
  ULONG CommitDirectoryMaxSize;        // offset: 0x34 ordinal: 0xa
  ULONGLONG CommitDirectory[1];        // offset: 0x38 ordinal: 0xb
} _RTL_CSPARSE_BITMAP;

// 0x50 bytes (sizeof)
typedef struct _RTLP_HP_ALLOC_TRACKER {
  ULONGLONG BaseAddress; // offset: 0x0 ordinal: 0x0
  union {
    struct _RTL_CSPARSE_BITMAP AllocTrackerBitmap; // offset: 0x8 ordinal: 0x1
    UCHAR AllocTrackerBitmapBuffer[72];            // offset: 0x8 ordinal: 0x2
  };
} _RTLP_HP_ALLOC_TRACKER;

// 0x50 bytes (sizeof)
typedef struct _RTL_SPARSE_ARRAY {
  ULONGLONG ElementCount;            // offset: 0x0 ordinal: 0x0
  ULONG ElementSizeShift;            // offset: 0x8 ordinal: 0x1
  struct _RTL_CSPARSE_BITMAP Bitmap; // offset: 0x10 ordinal: 0x2
} _RTL_SPARSE_ARRAY;

// 0x860 bytes (sizeof)
typedef struct _HEAP_VAMGR_VASPACE {
  enum _RTLP_HP_ADDRESS_SPACE_TYPE AddressSpaceType; // offset: 0x0 ordinal: 0x0
  ULONGLONG BaseAddress;                             // offset: 0x8 ordinal: 0x1
  union {
    struct _RTL_SPARSE_ARRAY VaRangeArray; // offset: 0x10 ordinal: 0x2
    UCHAR VaRangeArrayBuffer[2128];        // offset: 0x10 ordinal: 0x3
  };
} _HEAP_VAMGR_VASPACE;

// 0x30 bytes (sizeof)
typedef struct _HEAP_VAMGR_ALLOCATOR {
  ULONGLONG TreeLock;                  // offset: 0x0 ordinal: 0x0
  struct _RTL_RB_TREE FreeRanges;      // offset: 0x8 ordinal: 0x1
  struct _HEAP_VAMGR_VASPACE *VaSpace; // offset: 0x18 ordinal: 0x2
  VOID *ContextHandle;                 // offset: 0x20 ordinal: 0x3
  USHORT ChunksPerRegion;              // offset: 0x28 ordinal: 0x4
  USHORT RefCount;                     // offset: 0x2a ordinal: 0x5
  UCHAR AllocatorIndex;                // offset: 0x2c ordinal: 0x6
  UCHAR NumaNode;                      // offset: 0x2d ordinal: 0x7
  UCHAR LockType : 1;                  // offset: 0x2e ordinal: 0x8
  UCHAR MemoryType : 3;                // offset: 0x2e ordinal: 0x9
  UCHAR ConstrainedVA : 1;             // offset: 0x2e ordinal: 0xa
  UCHAR AllowFreeHead : 1;             // offset: 0x2e ordinal: 0xb
  UCHAR Spare0 : 2;                    // offset: 0x2e ordinal: 0xc
  UCHAR Spare1;                        // offset: 0x2f ordinal: 0xd
} _HEAP_VAMGR_ALLOCATOR;

// 0x3840 bytes (sizeof)
typedef struct _HEAP_VAMGR_CTX {
  struct _HEAP_VAMGR_VASPACE VaSpace;           // offset: 0x0 ordinal: 0x0
  ULONGLONG AllocatorLock;                      // offset: 0x860 ordinal: 0x1
  ULONG AllocatorCount;                         // offset: 0x868 ordinal: 0x2
  struct _HEAP_VAMGR_ALLOCATOR Allocators[255]; // offset: 0x870 ordinal: 0x3
} _HEAP_VAMGR_CTX;

// 0x38e0 bytes (sizeof)
typedef struct _RTLP_HP_HEAP_MANAGER {
  struct _RTLP_HP_HEAP_GLOBALS *Globals;      // offset: 0x0 ordinal: 0x0
  struct _RTLP_HP_ALLOC_TRACKER AllocTracker; // offset: 0x8 ordinal: 0x1
  struct _HEAP_VAMGR_CTX VaMgr;               // offset: 0x58 ordinal: 0x2
  struct _RTLP_HP_METADATA_HEAP_CTX
      MetadataHeaps[4]; // offset: 0x3898 ordinal: 0x3
  struct _RTL_HP_SUB_ALLOCATOR_CONFIGS
      SubAllocConfigs; // offset: 0x38d8 ordinal: 0x4
} _RTLP_HP_HEAP_MANAGER;

// 0x86940 bytes (sizeof)
typedef struct _EX_POOL_HEAP_MANAGER_STATE {
  struct _RTLP_HP_HEAP_MANAGER HeapManager; // offset: 0x0 ordinal: 0x0
  ULONG NumberOfPools;                      // offset: 0x38e0 ordinal: 0x1
  struct _EX_HEAP_POOL_NODE PoolNode[64];   // offset: 0x3900 ordinal: 0x2
  struct _SEGMENT_HEAP *SpecialHeaps[4];    // offset: 0x86900 ordinal: 0x3
} _EX_POOL_HEAP_MANAGER_STATE;

// 0x3900 bytes (sizeof)
typedef struct _EX_HEAP_SESSION_STATE {
  struct _RTLP_HP_HEAP_MANAGER HeapManager; // offset: 0x0 ordinal: 0x0
  struct RTL_HP_ENV_HANDLE PagedEnv;        // offset: 0x38e0 ordinal: 0x1
  struct _SEGMENT_HEAP *PagedHeap;          // offset: 0x38f0 ordinal: 0x2
  struct _SEGMENT_HEAP *SpecialPoolHeap;    // offset: 0x38f8 ordinal: 0x3
} _EX_HEAP_SESSION_STATE;

// 0x10 bytes (sizeof)
typedef struct _RTL_BITMAP_EX {
  ULONGLONG SizeOfBitMap; // offset: 0x0 ordinal: 0x0
  ULONGLONG *Buffer;      // offset: 0x8 ordinal: 0x1
} _RTL_BITMAP_EX;

// 0x40 bytes (sizeof)
typedef struct _MI_SECTION_WOW_STATE {
  struct _RTL_BITMAP_EX ImageBitMap;          // offset: 0x0 ordinal: 0x0
  struct _MI_DLL_OVERFLOW_AREA OverflowArea;  // offset: 0x10 ordinal: 0x1
  struct _SECTION *CfgBitMapSection;          // offset: 0x30 ordinal: 0x2
  struct _CONTROL_AREA *CfgBitMapControlArea; // offset: 0x38 ordinal: 0x3
} _MI_SECTION_WOW_STATE;

// 0x48 bytes (sizeof)
typedef struct _MI_DYNAMIC_BITMAP {
  struct _RTL_BITMAP_EX Bitmap; // offset: 0x0 ordinal: 0x0
  ULONGLONG MaximumSize;        // offset: 0x10 ordinal: 0x1
  ULONGLONG Hint;               // offset: 0x18 ordinal: 0x2
  VOID *BaseVa;                 // offset: 0x20 ordinal: 0x3
  ULONGLONG SizeTopDown;        // offset: 0x28 ordinal: 0x4
  ULONGLONG HintTopDown;        // offset: 0x30 ordinal: 0x5
  VOID *BaseVaTopDown;          // offset: 0x38 ordinal: 0x6
  ULONGLONG SpinLock;           // offset: 0x40 ordinal: 0x7
} _MI_DYNAMIC_BITMAP;

// 0x58 bytes (sizeof)
typedef struct _MI_SYSTEM_PTE_TYPE {
  struct _RTL_BITMAP_EX Bitmap;       // offset: 0x0 ordinal: 0x0
  struct _MMPTE *BasePte;             // offset: 0x10 ordinal: 0x1
  ULONG Flags;                        // offset: 0x18 ordinal: 0x2
  enum _MI_SYSTEM_VA_TYPE VaType;     // offset: 0x1c ordinal: 0x3
  ULONG PteFailures;                  // offset: 0x20 ordinal: 0x4
  ULONGLONG SpinLock;                 // offset: 0x28 ordinal: 0x5
  ULONGLONG TotalSystemPtes;          // offset: 0x30 ordinal: 0x6
  ULONGLONG Hint;                     // offset: 0x38 ordinal: 0x7
  ULONGLONG LowestBitEverAllocated;   // offset: 0x40 ordinal: 0x8
  struct _MI_CACHED_PTES *CachedPtes; // offset: 0x48 ordinal: 0x9
  ULONGLONG TotalFreeSystemPtes;      // offset: 0x50 ordinal: 0xa
} _MI_SYSTEM_PTE_TYPE;

// 0x40 bytes (sizeof)
typedef struct _MI_ULTRA_VA_CONTEXT {
  ULONGLONG Lock;                  // offset: 0x0 ordinal: 0x0
  VOID *ZeroMapping;               // offset: 0x8 ordinal: 0x1
  ULONGLONG AllocationHintBit;     // offset: 0x10 ordinal: 0x2
  struct _RTL_BITMAP_EX Bitmap[2]; // offset: 0x18 ordinal: 0x3
  LONG ConcurrencyMaximum;         // offset: 0x38 ordinal: 0x4
  LONG ConcurrencyCount;           // offset: 0x3c ordinal: 0x5
} _MI_ULTRA_VA_CONTEXT;

// 0x78 bytes (sizeof)
typedef struct _MI_SHUTDOWN_STATE {
  UCHAR CrashDumpInitialized;             // offset: 0x0 ordinal: 0x0
  UCHAR ConnectedStandbyActive;           // offset: 0x1 ordinal: 0x1
  UCHAR ZeroPageFileAtShutdown;           // offset: 0x2 ordinal: 0x2
  ULONG SystemShutdown;                   // offset: 0x4 ordinal: 0x3
  LONG ShutdownFlushInProgress;           // offset: 0x8 ordinal: 0x4
  ULONG MirroringActive;                  // offset: 0xc ordinal: 0x5
  struct _MI_RESUME_WORKITEM ResumeItem;  // offset: 0x10 ordinal: 0x6
  struct _ETHREAD *MirrorHoldsPfn;        // offset: 0x48 ordinal: 0x7
  struct _RTL_BITMAP_EX MirrorBitMaps[2]; // offset: 0x50 ordinal: 0x8
  struct _MMPTE *CrashDumpPte;            // offset: 0x70 ordinal: 0x9
} _MI_SHUTDOWN_STATE;

// 0x3640 bytes (sizeof)
typedef struct _MI_PARTITION_PAGE_LISTS {
  struct _MMPFNLIST *FreePagesByColor[2];          // offset: 0x0 ordinal: 0x0
  struct _MMPFNLIST ZeroedPageListHead;            // offset: 0x40 ordinal: 0x1
  struct _MMPFNLIST FreePageListHead;              // offset: 0xc0 ordinal: 0x2
  struct _MMPFNLIST StandbyPageListHead;           // offset: 0x140 ordinal: 0x3
  struct _MMPFNLIST StandbyPageListByPriority[8];  // offset: 0x1c0 ordinal: 0x4
  struct _MMPFNLIST ModifiedPageListNoReservation; // offset: 0x480 ordinal: 0x5
  struct _MMPFNLIST
      ModifiedPageListNoReservationCompress; // offset: 0x500 ordinal: 0x6
  struct _MMPFNLIST
      ModifiedPageListByReservation[16];      // offset: 0x580 ordinal: 0x7
  struct _MMPFNLIST MappedPageListHead[16];   // offset: 0xb00 ordinal: 0x8
  struct _MMPFNLIST BadPageListHead;          // offset: 0x1080 ordinal: 0x9
  union _SLIST_HEADER *FreePageSlist[2];      // offset: 0x10d8 ordinal: 0xa
  struct _MMPFNLIST *PageLocationList[8];     // offset: 0x10e8 ordinal: 0xb
  ULONG StandbyRepurposedByPriority[8];       // offset: 0x1128 ordinal: 0xc
  ULONGLONG TransitionSharedPages;            // offset: 0x1180 ordinal: 0xd
  ULONGLONG TransitionSharedPagesPeak[6];     // offset: 0x1188 ordinal: 0xe
  struct _KEVENT MappedPageListHeadEvent[16]; // offset: 0x11b8 ordinal: 0xf
  struct _MI_STANDBY_LOOKASIDE
      OldestStandbyPageCache[8]; // offset: 0x1340 ordinal: 0x10
  struct _MI_STANDBY_LOOKASIDE
      NewestStandbyPageCache[8];                 // offset: 0x2340 ordinal: 0x11
  ULONGLONG NewestStandbyPageCacheInserts[2][8]; // offset: 0x3340 ordinal: 0x12
  struct _MI_DECAY_TIMER_LINK
      DecayClusterTimerHeads[4];     // offset: 0x33c0 ordinal: 0x13
  ULONG DecayHand;                   // offset: 0x33e0 ordinal: 0x14
  UCHAR StandbyListDiscard;          // offset: 0x33e4 ordinal: 0x15
  UCHAR FreeListDiscard;             // offset: 0x33e5 ordinal: 0x16
  UCHAR PfnBitMapsReady;             // offset: 0x33e6 ordinal: 0x17
  ULONGLONG LastDecayHandUpdateTime; // offset: 0x33e8 ordinal: 0x18
  struct _MI_LDW_WORK_CONTEXT
      LastChanceLdwContext;      // offset: 0x33f0 ordinal: 0x19
  ULONGLONG AvailableEventsLock; // offset: 0x3440 ordinal: 0x1a
  struct _MI_AVAILABLE_PAGE_WAIT_STATES
      AvailablePageWaitStates[3];          // offset: 0x3448 ordinal: 0x1b
  ULONGLONG TransitionPrivatePages;        // offset: 0x34c0 ordinal: 0x1c
  struct _RTL_BITMAP_EX LargePfnBitMap[2]; // offset: 0x34c8 ordinal: 0x1d
  struct _MI_FREE_LARGE_PAGE_LIST
      *LargePageListHeads;         // offset: 0x34e8 ordinal: 0x1e
  CHAR *MediumPagesOnFreeZeroList; // offset: 0x34f0 ordinal: 0x1f
  struct _RTL_BITMAP_EX
      LargePageRebuildCandidates;                // offset: 0x34f8 ordinal: 0x20
  SHORT *LargePagesOnFreeZeroList;               // offset: 0x3508 ordinal: 0x21
  LONG HugePageRebuildCandidatesExist;           // offset: 0x3510 ordinal: 0x22
  LONG ProcessLargePageCacheLock;                // offset: 0x3514 ordinal: 0x23
  struct _LIST_ENTRY ProcessLargePageCacheLinks; // offset: 0x3518 ordinal: 0x24
  ULONG ProcessLargePageCachePeriodicCount;      // offset: 0x3528 ordinal: 0x25
  struct _KEVENT LargePageCandidatesExistEvent;  // offset: 0x3530 ordinal: 0x26
  ULONGLONG LowMemoryConfiguredThreshold;        // offset: 0x3548 ordinal: 0x27
  ULONGLONG HighMemoryConfiguredThreshold;       // offset: 0x3550 ordinal: 0x28
  ULONGLONG LowMemoryThreshold;                  // offset: 0x3558 ordinal: 0x29
  ULONGLONG HighMemoryThreshold;                 // offset: 0x3560 ordinal: 0x2a
  struct _RTL_BITMAP_EX SlabPfnBitMap[2];        // offset: 0x3568 ordinal: 0x2b
  UCHAR SlabPagesNotAvailable[7];                // offset: 0x3588 ordinal: 0x2c
  VOID *HugePfnLists;                            // offset: 0x3590 ordinal: 0x2d
  ULONGLONG AvailableHugeIoRanges;               // offset: 0x3598 ordinal: 0x2e
  ULONGLONG SlabEntriesDemoted;                  // offset: 0x35a0 ordinal: 0x2f
  LONG SlabDemoteInProgress;                     // offset: 0x35a8 ordinal: 0x30
  ULONG SlabTypeAcquiresCharges;                 // offset: 0x35ac ordinal: 0x31
  ULONGLONG DriverPageCount;                     // offset: 0x35b0 ordinal: 0x32
  ULONGLONG DriverLastPage;                      // offset: 0x35b8 ordinal: 0x33
  ULONGLONG DriverNonSlabAttempted;              // offset: 0x35c0 ordinal: 0x34
  ULONGLONG DriverSlabLastFailTime;              // offset: 0x35c8 ordinal: 0x35
  ULONGLONG MdlPagesByListsTotal;                // offset: 0x35d0 ordinal: 0x36
  ULONGLONG MdlPagesByListsFromSlab;             // offset: 0x35d8 ordinal: 0x37
  ULONGLONG MdlPagesByListsSlabNotEligible;      // offset: 0x35e0 ordinal: 0x38
  ULONGLONG
  MdlPagesPreferContiguousSlabEligible;       // offset: 0x35e8 ordinal: 0x39
  ULONGLONG MdlPagesPreferContiguousFromSlab; // offset: 0x35f0 ordinal: 0x3a
  ULONGLONG MdlSlabPagesFreeZeroedTotal;      // offset: 0x35f8 ordinal: 0x3b
  ULONG MdlSlabPagesFreeZeroedBuckets[4];     // offset: 0x3600 ordinal: 0x3c
  ULONGLONG SystemPageTablePagesNoSlab;       // offset: 0x3610 ordinal: 0x3d
} _MI_PARTITION_PAGE_LISTS;

typedef LONG (*__anon_1877)(struct _HAL_HV_DMA_DOMAIN_INFO *, ULONGLONG *,
                            ULONGLONG *);

typedef LONG (*__anon_1876)(struct _HAL_HV_DMA_DOMAIN_INFO *, ULONG,
                            ULONGLONG *, ULONGLONG *);

typedef LONG (*__anon_1875)(struct _HAL_HV_DMA_DOMAIN_INFO *, ULONGLONG,
                            ULONGLONG *);

typedef LONG (*__anon_1874)(struct _HAL_HV_DMA_DOMAIN_INFO *, ULONG, ULONGLONG,
                            ULONGLONG *, ULONGLONG *, UCHAR);

typedef ULONGLONG (*__anon_1857)(ULONG, VOID *, ULONGLONG, ULONGLONG *);

typedef LONG (*__anon_1848)(ULONG, ULONG *, ULONGLONG *, ULONG *);

typedef LONG (*__anon_1845)(ULONG, ULONG, ULONG *, ULONGLONG *);

// 0x220 bytes (sizeof)
typedef struct _HAL_INTEL_ENLIGHTENMENT_INFORMATION {
  ULONG Enlightenments;               // offset: 0x0 ordinal: 0x0
  ULONG HypervisorConnected;          // offset: 0x4 ordinal: 0x1
  VOID (*EndOfInterrupt)();           // offset: 0x8 ordinal: 0x2
  VOID (*ApicWriteIcr)(ULONG, ULONG); // offset: 0x10 ordinal: 0x3
  ULONG Reserved0;                    // offset: 0x18 ordinal: 0x4
  ULONG SpinCountMask;                // offset: 0x1c ordinal: 0x5
  VOID (*LongSpinWait)(ULONG);        // offset: 0x20 ordinal: 0x6
  ULONGLONG (*GetReferenceTime)();    // offset: 0x28 ordinal: 0x7
  LONG(*SetSystemSleepProperty)
  (ULONG, UCHAR, UCHAR);                // offset: 0x30 ordinal: 0x8
  LONG (*EnterSleepState)(ULONG);       // offset: 0x38 ordinal: 0x9
  LONG (*NotifyDebugDeviceAvailable)(); // offset: 0x40 ordinal: 0xa
  LONG(*MapDeviceInterrupt)
  (ULONGLONG, VOID *, struct _GROUP_AFFINITY *,
   VOID *);                                        // offset: 0x48 ordinal: 0xb
  LONG (*UnmapDeviceInterrupt)(ULONGLONG, VOID *); // offset: 0x50 ordinal: 0xc
  LONG(*RetargetDeviceInterrupt)
  (ULONGLONG, VOID *, VOID *, struct _GROUP_AFFINITY *,
   VOID *); // offset: 0x58 ordinal: 0xd
  LONG(*SetHpetConfig)
  (ULONG, ULONGLONG, UCHAR, VOID *); // offset: 0x60 ordinal: 0xe
  LONG (*NotifyHpetEnabled)();       // offset: 0x68 ordinal: 0xf
  LONG(*QueryAssociatedProcessors)
  (ULONG, ULONG *, ULONG *); // offset: 0x70 ordinal: 0x10
  LONG(*ReadMultipleMsr)
  (ULONG, ULONG, ULONG *, ULONGLONG *); // offset: 0x78 ordinal: 0x11
  LONG(*WriteMultipleMsr)
  (ULONG, ULONG, ULONG *, ULONGLONG *); // offset: 0x80 ordinal: 0x12
  LONG(*ReadCpuid)
  (ULONG, ULONG, ULONG *, ULONG *, ULONG *,
   ULONG *);                            // offset: 0x88 ordinal: 0x13
  LONG (*LpWritebackInvalidate)(ULONG); // offset: 0x90 ordinal: 0x14
  LONG(*GetMachineCheckContext)
  (ULONG, ULONG *, ULONGLONG *, ULONG *);        // offset: 0x98 ordinal: 0x15
  LONG (*SuspendPartition)(ULONGLONG);           // offset: 0xa0 ordinal: 0x16
  LONG (*ResumePartition)(ULONGLONG);            // offset: 0xa8 ordinal: 0x17
  LONG (*SetSystemMachineCheckProperty)(VOID *); // offset: 0xb0 ordinal: 0x18
  LONG(*WheaErrorNotification)
  (struct _WHEA_RECOVERY_CONTEXT *, UCHAR, UCHAR); // offset: 0xb8 ordinal: 0x19
  ULONG (*GetProcessorIndexFromVpIndex)(ULONG);    // offset: 0xc0 ordinal: 0x1a
  LONG(*SyntheticClusterIpi)
  (struct _KAFFINITY_EX *, ULONG);              // offset: 0xc8 ordinal: 0x1b
  UCHAR (*VpStartEnabled)();                    // offset: 0xd0 ordinal: 0x1c
  LONG (*StartVirtualProcessor)(ULONG, VOID *); // offset: 0xd8 ordinal: 0x1d
  LONG (*GetVpIndexFromApicId)(ULONG, ULONG *); // offset: 0xe0 ordinal: 0x1e
  LONG(*IumAccessPciDevice)
  (UCHAR, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG,
   VOID *); // offset: 0xe8 ordinal: 0x1f
  ULONGLONG(*IumEfiRuntimeService)
  (ULONG, VOID *, ULONGLONG, ULONGLONG *); // offset: 0xf0 ordinal: 0x20
  VOID(*SvmGetSystemCapabilities)
  (struct _HAL_HV_SVM_SYSTEM_CAPABILITIES *); // offset: 0xf8 ordinal: 0x21
  LONG(*GetDeviceCapabilities)
  (struct _EXT_IOMMU_DEVICE_ID *, VOID *);   // offset: 0x100 ordinal: 0x22
  LONG (*SvmCreatePasidSpace)(ULONG, ULONG); // offset: 0x108 ordinal: 0x23
  LONG(*SvmSetPasidAddressSpace)
  (ULONG, ULONG, ULONGLONG); // offset: 0x110 ordinal: 0x24
  VOID(*SvmFlushPasid)
  (ULONG, ULONG, ULONG, struct _KTB_FLUSH_VA *); // offset: 0x118 ordinal: 0x25
  LONG(*SvmAttachPasidSpace)
  (ULONGLONG, ULONG, ULONG, ULONG);          // offset: 0x120 ordinal: 0x26
  LONG (*SvmDetachPasidSpace)(ULONGLONG);    // offset: 0x128 ordinal: 0x27
  LONG (*SvmEnablePasid)(ULONGLONG, ULONG);  // offset: 0x130 ordinal: 0x28
  LONG (*SvmDisablePasid)(ULONGLONG, ULONG); // offset: 0x138 ordinal: 0x29
  LONG(*SvmAcknowledgePageRequest)
  (ULONG, VOID *, ULONG *); // offset: 0x140 ordinal: 0x2a
  LONG(*SvmCreatePrQueue)
  (ULONG, ULONG, union _LARGE_INTEGER, ULONG,
   ULONG);                           // offset: 0x148 ordinal: 0x2b
  LONG (*SvmDeletePrQueue)(ULONG);   // offset: 0x150 ordinal: 0x2c
  LONG (*SvmClearPrqStalled)(ULONG); // offset: 0x158 ordinal: 0x2d
  LONG(*SetDeviceAtsEnabled)
  (struct _EXT_IOMMU_DEVICE_ID *, UCHAR); // offset: 0x160 ordinal: 0x2e
  LONG(*SetDeviceCapabilities)
  (ULONGLONG, ULONG, ULONG);             // offset: 0x168 ordinal: 0x2f
  LONG (*HvDebuggerPowerHandler)(UCHAR); // offset: 0x170 ordinal: 0x30
  LONG (*SetQpcBias)(ULONGLONG);         // offset: 0x178 ordinal: 0x31
  ULONGLONG (*GetQpcBias)();             // offset: 0x180 ordinal: 0x32
  LONG(*RegisterDeviceId)
  (struct _EXT_IOMMU_DEVICE_ID *, ULONGLONG); // offset: 0x188 ordinal: 0x33
  LONG (*UnregisterDeviceId)(ULONGLONG);      // offset: 0x190 ordinal: 0x34
  LONG(*AllocateDeviceDomain)
  (struct _HAL_HV_DMA_CREATE_DOMAIN_INFO *); // offset: 0x198 ordinal: 0x35
  LONG(*AttachDeviceDomain)
  (ULONGLONG, struct _HAL_HV_DMA_DOMAIN_INFO *); // offset: 0x1a0 ordinal: 0x36
  LONG (*DetachDeviceDomain)(ULONGLONG);         // offset: 0x1a8 ordinal: 0x37
  LONG(*DeleteDeviceDomain)
  (struct _HAL_HV_DMA_DOMAIN_INFO *); // offset: 0x1b0 ordinal: 0x38
  LONG(*MapDeviceLogicalRange)
  (struct _HAL_HV_DMA_DOMAIN_INFO *, ULONG, ULONGLONG, ULONGLONG *, ULONGLONG *,
   UCHAR); // offset: 0x1b8 ordinal: 0x39
  LONG(*UnmapDeviceLogicalRange)
  (struct _HAL_HV_DMA_DOMAIN_INFO *, ULONGLONG,
   ULONGLONG *); // offset: 0x1c0 ordinal: 0x3a
  LONG(*MapDeviceSparsePages)
  (struct _HAL_HV_DMA_DOMAIN_INFO *, ULONG, ULONGLONG *,
   ULONGLONG *); // offset: 0x1c8 ordinal: 0x3b
  LONG(*UnmapDeviceSparsePages)
  (struct _HAL_HV_DMA_DOMAIN_INFO *, ULONGLONG *,
   ULONGLONG *);                                 // offset: 0x1d0 ordinal: 0x3c
  LONG (*GetDmaGuardEnabled)(UCHAR *);           // offset: 0x1d8 ordinal: 0x3d
  LONG (*UpdateMicrocode)(VOID *, ULONG, UCHAR); // offset: 0x1e0 ordinal: 0x3e
  LONG (*GetSintMessage)(UCHAR, VOID **);        // offset: 0x1e8 ordinal: 0x3f
  LONG (*SetRootFaultReportingReady)();          // offset: 0x1f0 ordinal: 0x40
  LONG(*ConfigureDeviceDomain)
  (struct _HAL_HV_DMA_DOMAIN_INFO *,
   struct _HAL_HV_DMA_DOMAIN_CONFIG *); // offset: 0x1f8 ordinal: 0x41
  LONG (*UnblockDefaultDma)();          // offset: 0x200 ordinal: 0x42
  LONG(*FlushDeviceDomain)
  (struct _HAL_HV_DMA_DOMAIN_INFO *); // offset: 0x208 ordinal: 0x43
  LONG(*FlushDeviceDomainVaList)
  (struct _HAL_HV_DMA_DOMAIN_INFO *, ULONG,
   struct _KTB_FLUSH_VA *); // offset: 0x210 ordinal: 0x44
  LONG(*GetHybridPassthroughReservedRegions)
  (struct _HAL_HV_DMA_HYBRID_PASSTHROUGH_RESERVED_REGIONS
       *); // offset: 0x218 ordinal: 0x45
} _HAL_INTEL_ENLIGHTENMENT_INFORMATION;

typedef VOID (*__anon_3257)(struct _HAL_INTEL_ENLIGHTENMENT_INFORMATION *);

// 0x10 bytes (sizeof)
typedef struct __anon_1774 {
  ULONGLONG *StatusAddr; // offset: 0x0 ordinal: 0x0
  ULONGLONG OldStatus;   // offset: 0x8 ordinal: 0x1
} __anon_1774;

// 0x10 bytes (sizeof)
typedef struct _EXT_IOMMU_FLUSH_CONTEXT {
  union {
    struct __anon_1773 Intel; // offset: 0x0 ordinal: 0x0
    struct __anon_1774 Amd;   // offset: 0x0 ordinal: 0x1
  };
} _EXT_IOMMU_FLUSH_CONTEXT;

typedef VOID (*__anon_1702)(struct _EXT_IOMMU *,
                            struct _EXT_IOMMU_FLUSH_CONTEXT *);

typedef VOID (*__anon_1701)(struct _EXT_IOMMU *, struct _EXT_IOMMU_DOMAIN *,
                            struct _EXT_IOMMU_FLUSH_CONTEXT *, ULONG,
                            struct _KTB_FLUSH_VA *);

// 0x98 bytes (sizeof)
typedef struct _EXT_IOMMU_FUNCTION_TABLE {
  LONG(*ConfigureSettings)
  (struct _EXT_IOMMU *,
   struct _EXT_IOMMU_SETTINGS *); // offset: 0x0 ordinal: 0x0
  LONG(*Initialize)
  (struct _EXT_IOMMU *, ULONG, UCHAR); // offset: 0x8 ordinal: 0x1
  LONG(*AllocateDomain)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DOMAIN *, struct _EXT_IOMMU_DOMAIN *,
   VOID *); // offset: 0x10 ordinal: 0x2
  VOID(*FreeDomain)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DOMAIN *,
   VOID *); // offset: 0x18 ordinal: 0x3
  LONG(*CreateDevice)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE_ID *,
   union _EXT_IOMMU_CREATE_DEVICE_FLAGS, VOID *, struct _EXT_IOMMU_DEVICE **,
   VOID *); // offset: 0x20 ordinal: 0x4
  VOID(*DeleteDevice)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE *,
   VOID *); // offset: 0x28 ordinal: 0x5
  UCHAR(*OwnDevice)
  (struct _EXT_IOMMU *,
   struct _EXT_IOMMU_DEVICE_ID *); // offset: 0x30 ordinal: 0x6
  VOID(*ConfigureDeviceFaultReporting)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE *,
   UCHAR); // offset: 0x38 ordinal: 0x7
  LONG(*AttachDeviceDomain)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE *, struct _EXT_IOMMU_DOMAIN *,
   VOID *); // offset: 0x40 ordinal: 0x8
  VOID(*DetachDeviceDomain)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DEVICE *,
   VOID *); // offset: 0x48 ordinal: 0x9
  VOID(*FlushDomainTb)
  (struct _EXT_IOMMU *, struct _EXT_IOMMU_DOMAIN *,
   struct _EXT_IOMMU_FLUSH_CONTEXT *, ULONG,
   struct _KTB_FLUSH_VA *); // offset: 0x50 ordinal: 0xa
  VOID(*SyncFlush)
  (struct _EXT_IOMMU *,
   struct _EXT_IOMMU_FLUSH_CONTEXT *); // offset: 0x58 ordinal: 0xb
  VOID(*CompleteFlush)
  (struct _EXT_IOMMU *,
   struct _EXT_IOMMU_FLUSH_CONTEXT *); // offset: 0x60 ordinal: 0xc
  LONG(*AllocateRemappingTableEntry)
  (VOID *, ULONG, ULONG, ULONG, USHORT, UCHAR, UCHAR, ULONG,
   struct _EXT_IOMMU_DEVICE_ID *); // offset: 0x68 ordinal: 0xd
  LONG(*FreeRemappingTableEntry)
  (VOID *, ULONG, ULONG); // offset: 0x70 ordinal: 0xe
  UCHAR(*UpdateRemappingTableEntry)
  (VOID *, UCHAR, ULONG,
   struct _INTERRUPT_LINE_STATE *); // offset: 0x78 ordinal: 0xf
  VOID(*InvalidateRemappingTableEntry)
  (VOID *, ULONG); // offset: 0x80 ordinal: 0x10
  VOID(*UpdateRemappingDestination)
  (VOID *, UCHAR, ULONG *, ULONG *, ULONG);    // offset: 0x88 ordinal: 0x11
  VOID (*CaptureGlobalCrashdumpState)(VOID *); // offset: 0x90 ordinal: 0x12
} _EXT_IOMMU_FUNCTION_TABLE;

// 0xb8 bytes (sizeof)
typedef struct _EXT_IOMMU {
  VOID *Context;                                  // offset: 0x0 ordinal: 0x0
  enum _EXT_IOMMU_KNOWN_IOMMU_TYPE Type;          // offset: 0x8 ordinal: 0x1
  union _EXT_IOMMU_CAPABILITIES Capabilities;     // offset: 0x10 ordinal: 0x2
  ULONG MaxOutputAddressWidth;                    // offset: 0x18 ordinal: 0x3
  struct __anon_1726 Flags;                       // offset: 0x1c ordinal: 0x4
  USHORT PciSegmentNumber;                        // offset: 0x1e ordinal: 0x5
  struct _EXT_IOMMU_FUNCTION_TABLE FunctionTable; // offset: 0x20 ordinal: 0x6
} _EXT_IOMMU;

typedef LONG (*__anon_1757)(struct _IOMMU_DMA_LOGICAL_ALLOCATOR *, ULONGLONG *,
                            ULONGLONG, ULONGLONG *, ULONGLONG *, ULONGLONG *);

// 0x28 bytes (sizeof)
typedef struct _IOMMU_DMA_LOGICAL_ALLOCATOR_OPERATIONS_V1 {
  LONG(*AllocateLogicalAddress)
  (struct _IOMMU_DMA_LOGICAL_ALLOCATOR *, ULONGLONG *, ULONGLONG, ULONGLONG *,
   ULONGLONG *, ULONGLONG *); // offset: 0x0 ordinal: 0x0
  LONG(*FreeLogicalAddress)
  (struct _IOMMU_DMA_LOGICAL_ALLOCATOR *,
   ULONGLONG); // offset: 0x8 ordinal: 0x1
  LONG(*ReserveLogicalAddress)
  (struct _IOMMU_DMA_LOGICAL_ALLOCATOR *, ULONGLONG,
   ULONGLONG); // offset: 0x10 ordinal: 0x2
  struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CAPABILITIES (*QueryCapabilities)(
      struct _IOMMU_DMA_LOGICAL_ALLOCATOR *); // offset: 0x18 ordinal: 0x3
  VOID(*CleanUp)
  (struct _IOMMU_DMA_LOGICAL_ALLOCATOR *); // offset: 0x20 ordinal: 0x4
} _IOMMU_DMA_LOGICAL_ALLOCATOR_OPERATIONS_V1;

// 0x18 bytes (sizeof)
typedef struct _IOMMU_DMA_LOGICAL_ALLOCATOR {
  struct _IOMMU_DMA_LOGICAL_ALLOCATOR_OPERATIONS_V1
      *Operations; // offset: 0x0 ordinal: 0x0
  ULONG Version;   // offset: 0x8 ordinal: 0x1
  ULONG Size;      // offset: 0xc ordinal: 0x2
  enum _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE
      AllocatorType; // offset: 0x10 ordinal: 0x3
} _IOMMU_DMA_LOGICAL_ALLOCATOR;

typedef ULONG (*__anon_1715)(VOID *, ULONG *, ULONGLONG *, USHORT *, VOID **,
                             ULONGLONG *);

// 0xb8 bytes (sizeof)
typedef struct _EXT_IOMMU_FUNCTION_TABLE_EXTENDED {
  UCHAR(*FindDevice)
  (VOID *, struct _EXT_IOMMU_DEVICE_ID *, UCHAR,
   struct _EXT_IOMMU_OUTPUT_MAPPING *); // offset: 0x0 ordinal: 0x0
  LONG(*SetDeviceSvmCapabilities)
  (VOID *, ULONGLONG, UCHAR); // offset: 0x8 ordinal: 0x1
  VOID(*SetDevicePasidTable)
  (VOID *, ULONGLONG,
   struct _IOMMU_PASID_TABLE_OBJECT *); // offset: 0x10 ordinal: 0x2
  LONG(*GrowPasidTable)
  (VOID *, struct _IOMMU_PASID_TABLE_OBJECT *,
   ULONG); // offset: 0x18 ordinal: 0x3
  LONG(*SetPasidAddressSpace)
  (VOID *, struct _IOMMU_PASID_TABLE_OBJECT *, ULONG, ULONGLONG,
   UCHAR *); // offset: 0x20 ordinal: 0x4
  VOID(*FlushTb)
  (VOID *, ULONG, VOID *, struct _LIST_ENTRY *, ULONG,
   struct _KTB_FLUSH_VA *); // offset: 0x28 ordinal: 0x5
  VOID(*FlushDeviceTbOnly)
  (VOID *, ULONGLONG, ULONG); // offset: 0x30 ordinal: 0x6
  VOID(*DismissPageFault)
  (VOID *, ULONG, ULONGLONG, USHORT, LONG); // offset: 0x38 ordinal: 0x7
  ULONG(*GetPageFault)
  (VOID *, ULONG *, ULONGLONG *, USHORT *, VOID **,
   ULONGLONG *); // offset: 0x40 ordinal: 0x8
  LONG(*SetMessageInterruptRouting)
  (VOID *, UCHAR, union _LARGE_INTEGER, ULONG); // offset: 0x48 ordinal: 0x9
  VOID (*EnableInterrupt)(VOID *);              // offset: 0x50 ordinal: 0xa
  VOID (*DisableInterrupt)(VOID *);             // offset: 0x58 ordinal: 0xb
  UCHAR (*HandleInterrupt)(VOID *);             // offset: 0x60 ordinal: 0xc
  UCHAR(*CheckForReservedRegion)
  (struct _EXT_IOMMU_DEVICE_ID *); // offset: 0x68 ordinal: 0xd
  VOID(*MarkHiberRegions)
  (VOID *, VOID *, struct _LIST_ENTRY *); // offset: 0x70 ordinal: 0xe
  VOID(*DrainSvmPageRequests)
  (VOID *, ULONGLONG, ULONG); // offset: 0x78 ordinal: 0xf
  VOID(*CancelPageRequests)
  (VOID *, ULONGLONG, ULONG); // offset: 0x80 ordinal: 0x10
  LONG(*EnumerateReservedDevices)
  (VOID *, ULONG *,
   struct _IOMMU_RESERVED_DEVICE **); // offset: 0x88 ordinal: 0x11
  LONG(*ProcessReservedDomains)
  (VOID *, ULONG,
   struct _IOMMU_RESERVED_DEVICE **); // offset: 0x90 ordinal: 0x12
  LONG(*QueryAcpiDeviceMapping)
  (VOID *, struct _EXT_IOMMU_DEVICE_ID *,
   struct _EXT_IOMMU_DEVICE_ID *); // offset: 0x98 ordinal: 0x13
  ULONG(*GetRidAcpiMapCount)
  (VOID *, struct _EXT_IOMMU_DEVICE_ID *); // offset: 0xa0 ordinal: 0x14
  VOID(*FreePasidTable)
  (VOID *, struct _IOMMU_PASID_TABLE_OBJECT *,
   VOID *);                                       // offset: 0xa8 ordinal: 0x15
  LONG (*ConfigureAts)(VOID *, ULONGLONG, UCHAR); // offset: 0xb0 ordinal: 0x16
} _EXT_IOMMU_FUNCTION_TABLE_EXTENDED;

typedef LONG (*__anon_1406)(VOID *, struct _INTERRUPT_LINE_STATE *, ULONGLONG *,
                            ULONGLONG *);

// 0xd0 bytes (sizeof)
typedef struct _INTERRUPT_FUNCTION_TABLE {
  LONG(*InitializeLocalUnit)
  (VOID *, ULONG, ULONG, ULONG, ULONG, ULONG *); // offset: 0x0 ordinal: 0x0
  LONG (*InitializeIoUnit)(VOID *);              // offset: 0x8 ordinal: 0x1
  VOID (*SetPriority)(VOID *, ULONG);            // offset: 0x10 ordinal: 0x2
  ULONG (*GetLocalUnitError)(VOID *);            // offset: 0x18 ordinal: 0x3
  VOID (*ClearLocalUnitError)(VOID *);           // offset: 0x20 ordinal: 0x4
  LONG(*GetLogicalId)
  (VOID *, struct _INTERRUPT_TARGET *); // offset: 0x28 ordinal: 0x5
  LONG(*SetLogicalId)
  (VOID *, struct _INTERRUPT_TARGET *); // offset: 0x30 ordinal: 0x6
  enum _INTERRUPT_RESULT (*AcceptAndGetSource)(
      VOID *, LONG *, ULONG *);   // offset: 0x38 ordinal: 0x7
  VOID (*EndOfInterrupt)(VOID *); // offset: 0x40 ordinal: 0x8
  VOID (*FastEndOfInterrupt)();   // offset: 0x48 ordinal: 0x9
  LONG(*SetLineState)
  (VOID *, struct _INTERRUPT_LINE *,
   struct _INTERRUPT_LINE_STATE *); // offset: 0x50 ordinal: 0xa
  LONG(*RequestInterrupt)
  (VOID *, struct _INTERRUPT_LINE *, struct _INTERRUPT_TARGET *, ULONG,
   struct _INTERRUPT_LINE *); // offset: 0x58 ordinal: 0xb
  LONG(*StartProcessor)
  (VOID *, ULONG, VOID *, ULONG); // offset: 0x60 ordinal: 0xc
  LONG(*GenerateMessage)
  (VOID *, struct _INTERRUPT_LINE_STATE *, ULONGLONG *,
   ULONGLONG *); // offset: 0x68 ordinal: 0xd
  LONG(*ConvertId)
  (VOID *, ULONG *, struct _INTERRUPT_TARGET *,
   UCHAR);                                       // offset: 0x70 ordinal: 0xe
  LONG (*SaveLocalInterrupts)(VOID *, VOID *);   // offset: 0x78 ordinal: 0xf
  LONG (*ReplayLocalInterrupts)(VOID *, VOID *); // offset: 0x80 ordinal: 0x10
  LONG (*DeinitializeLocalUnit)(VOID *);         // offset: 0x88 ordinal: 0x11
  LONG (*DeinitializeIoUnit)(VOID *);            // offset: 0x90 ordinal: 0x12
  enum _INTERRUPT_RESULT (*QueryAndGetSource)(
      VOID *, LONG *, ULONG *, UCHAR *);      // offset: 0x98 ordinal: 0x13
  VOID (*DeactivateInterrupt)(VOID *, ULONG); // offset: 0xa0 ordinal: 0x14
  VOID(*DirectedEndOfInterrupt)
  (VOID *, ULONG, ULONG); // offset: 0xa8 ordinal: 0x15
  LONG(*QueryLocalUnitInfo)
  (VOID *, ULONG, ULONG *, ULONG *, enum _KINTERRUPT_MODE *,
   enum _KINTERRUPT_MODE *); // offset: 0xb0 ordinal: 0x16
  LONG(*QueryPendingState)
  (VOID *, struct _INTERRUPT_LINE *, UCHAR *,
   UCHAR *);                                   // offset: 0xb8 ordinal: 0x17
  VOID (*CaptureGlobalCrashdumpState)(VOID *); // offset: 0xc0 ordinal: 0x18
  VOID(*CaptureProcessorCrashdumpState)
  (VOID *, ULONG); // offset: 0xc8 ordinal: 0x19
} _INTERRUPT_FUNCTION_TABLE;

// 0x178 bytes (sizeof)
typedef struct _REGISTERED_INTERRUPT_CONTROLLER {
  struct _LIST_ENTRY ListEntry;                   // offset: 0x0 ordinal: 0x0
  VOID *InternalData;                             // offset: 0x10 ordinal: 0x1
  ULONG InternalDataSize;                         // offset: 0x18 ordinal: 0x2
  struct _INTERRUPT_FUNCTION_TABLE FunctionTable; // offset: 0x20 ordinal: 0x3
  enum _KNOWN_CONTROLLER_TYPE KnownType;          // offset: 0xf0 ordinal: 0x4
  ULONG Capabilities;                             // offset: 0xf4 ordinal: 0x5
  ULONG Flags;                                    // offset: 0xf8 ordinal: 0x6
  ULONG MaxPriority;                              // offset: 0xfc ordinal: 0x7
  ULONG UnitId;                                   // offset: 0x100 ordinal: 0x8
  struct _LIST_ENTRY LinesHead;                   // offset: 0x108 ordinal: 0x9
  struct _LIST_ENTRY OutputLinesHead;             // offset: 0x118 ordinal: 0xa
  LONG MinLine;                                   // offset: 0x128 ordinal: 0xb
  LONG MaxLine;                                   // offset: 0x12c ordinal: 0xc
  ULONG MaxClusterSize;                           // offset: 0x130 ordinal: 0xd
  ULONG MaxClusters;                              // offset: 0x134 ordinal: 0xe
  ULONG InterruptReplayDataSize;                  // offset: 0x138 ordinal: 0xf
  enum _INTERRUPT_PROBLEM Problem;                // offset: 0x13c ordinal: 0x10
  LONG ProblemStatus;                             // offset: 0x140 ordinal: 0x11
  CHAR *ProblemSourceFile;                        // offset: 0x148 ordinal: 0x12
  ULONG ProblemSourceLine;                        // offset: 0x150 ordinal: 0x13
  ULONG CustomProblem;                            // offset: 0x154 ordinal: 0x14
  LONG CustomProblemStatus;                       // offset: 0x158 ordinal: 0x15
  struct _UNICODE_STRING ResourceId;              // offset: 0x160 ordinal: 0x16
  struct POHANDLE__ *PowerHandle;                 // offset: 0x170 ordinal: 0x17
} _REGISTERED_INTERRUPT_CONTROLLER;

// 0x80 bytes (sizeof)
typedef struct _IOP_MC_BUFFER_ENTRY {
  USHORT Type;                              // offset: 0x0 ordinal: 0x0
  USHORT Reserved;                          // offset: 0x2 ordinal: 0x1
  ULONG Size;                               // offset: 0x4 ordinal: 0x2
  LONG ReferenceCount;                      // offset: 0x8 ordinal: 0x3
  enum _IOP_MC_BUFFER_ENTRY_FLAGS Flags;    // offset: 0xc ordinal: 0x4
  struct _LIST_ENTRY GlobalDataLink;        // offset: 0x10 ordinal: 0x5
  VOID *Address;                            // offset: 0x20 ordinal: 0x6
  ULONG Length;                             // offset: 0x28 ordinal: 0x7
  CHAR AccessMode;                          // offset: 0x2c ordinal: 0x8
  LONG MdlRef;                              // offset: 0x30 ordinal: 0x9
  struct _MDL *Mdl;                         // offset: 0x38 ordinal: 0xa
  struct _KEVENT MdlRundownEvent;           // offset: 0x40 ordinal: 0xb
  ULONGLONG *PfnArray;                      // offset: 0x58 ordinal: 0xc
  struct _IOP_MC_BE_PAGE_NODE PageNodes[1]; // offset: 0x60 ordinal: 0xd
} _IOP_MC_BUFFER_ENTRY;

// 0xd0 bytes (sizeof)
typedef struct _IORING_OBJECT {
  SHORT Type;                      // offset: 0x0 ordinal: 0x0
  SHORT Size;                      // offset: 0x2 ordinal: 0x1
  struct _NT_IORING_INFO UserInfo; // offset: 0x8 ordinal: 0x2
  VOID *Section;                   // offset: 0x38 ordinal: 0x3
  struct _NT_IORING_SUBMISSION_QUEUE
      *SubmissionQueue;            // offset: 0x40 ordinal: 0x4
  struct _MDL *CompletionQueueMdl; // offset: 0x48 ordinal: 0x5
  struct _NT_IORING_COMPLETION_QUEUE
      *CompletionQueue;                     // offset: 0x50 ordinal: 0x6
  ULONGLONG ViewSize;                       // offset: 0x58 ordinal: 0x7
  LONG InSubmit;                            // offset: 0x60 ordinal: 0x8
  ULONGLONG CompletionLock;                 // offset: 0x68 ordinal: 0x9
  ULONGLONG SubmitCount;                    // offset: 0x70 ordinal: 0xa
  ULONGLONG CompletionCount;                // offset: 0x78 ordinal: 0xb
  ULONGLONG CompletionWaitUntil;            // offset: 0x80 ordinal: 0xc
  struct _KEVENT CompletionEvent;           // offset: 0x88 ordinal: 0xd
  UCHAR SignalCompletionEvent;              // offset: 0xa0 ordinal: 0xe
  struct _KEVENT *CompletionUserEvent;      // offset: 0xa8 ordinal: 0xf
  ULONG RegBuffersCount;                    // offset: 0xb0 ordinal: 0x10
  struct _IOP_MC_BUFFER_ENTRY **RegBuffers; // offset: 0xb8 ordinal: 0x11
  ULONG RegFilesCount;                      // offset: 0xc0 ordinal: 0x12
  VOID **RegFiles;                          // offset: 0xc8 ordinal: 0x13
} _IORING_OBJECT;

// 0x10 bytes (sizeof)
typedef struct __anon_576 {
  union {
    VOID(*UserApcRoutine)
    (VOID *, struct _IO_STATUS_BLOCK *, ULONG); // offset: 0x0 ordinal: 0x0
    VOID *IssuingProcess;                       // offset: 0x0 ordinal: 0x1
  };
  union {
    VOID *UserApcContext;          // offset: 0x8 ordinal: 0x2
    struct _IORING_OBJECT *IoRing; // offset: 0x8 ordinal: 0x3
  };
} __anon_576;

// 0x10 bytes (sizeof)
typedef union __anon_491 {
  struct __anon_576 AsynchronousParameters; // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER AllocationSize;      // offset: 0x0 ordinal: 0x1
} __anon_491;

// 0xd0 bytes (sizeof)
typedef struct _IRP {
  SHORT Type;                         // offset: 0x0 ordinal: 0x0
  USHORT Size;                        // offset: 0x2 ordinal: 0x1
  struct _MDL *MdlAddress;            // offset: 0x8 ordinal: 0x2
  ULONG Flags;                        // offset: 0x10 ordinal: 0x3
  union __anon_488 AssociatedIrp;     // offset: 0x18 ordinal: 0x4
  struct _LIST_ENTRY ThreadListEntry; // offset: 0x20 ordinal: 0x5
  struct _IO_STATUS_BLOCK IoStatus;   // offset: 0x30 ordinal: 0x6
  CHAR RequestorMode;                 // offset: 0x40 ordinal: 0x7
  UCHAR PendingReturned;              // offset: 0x41 ordinal: 0x8
  CHAR StackCount;                    // offset: 0x42 ordinal: 0x9
  CHAR CurrentLocation;               // offset: 0x43 ordinal: 0xa
  UCHAR Cancel;                       // offset: 0x44 ordinal: 0xb
  UCHAR CancelIrql;                   // offset: 0x45 ordinal: 0xc
  CHAR ApcEnvironment;                // offset: 0x46 ordinal: 0xd
  UCHAR AllocationFlags;              // offset: 0x47 ordinal: 0xe
  union {
    struct _IO_STATUS_BLOCK *UserIosb; // offset: 0x48 ordinal: 0xf
    VOID *IoRingContext;               // offset: 0x48 ordinal: 0x10
  };
  struct _KEVENT *UserEvent; // offset: 0x50 ordinal: 0x11
  union __anon_491 Overlay;  // offset: 0x58 ordinal: 0x12
  VOID(*CancelRoutine)
  (struct _DEVICE_OBJECT *, struct _IRP *); // offset: 0x68 ordinal: 0x13
  VOID *UserBuffer;                         // offset: 0x70 ordinal: 0x14
  union __anon_1263 Tail;                   // offset: 0x78 ordinal: 0x15
} _IRP;

typedef VOID (*__anon_942)(ULONGLONG, UCHAR, ULONGLONG *, ULONGLONG *);

// 0x30 bytes (sizeof)
typedef struct _PROC_FEEDBACK_COUNTER {
  union {
    VOID (*InstantaneousRead)(ULONGLONG, ULONG *); // offset: 0x0 ordinal: 0x0
    VOID(*DifferentialRead)
    (ULONGLONG, UCHAR, ULONGLONG *, ULONGLONG *); // offset: 0x0 ordinal: 0x1
  };
  ULONGLONG LastActualCount;    // offset: 0x8 ordinal: 0x2
  ULONGLONG LastReferenceCount; // offset: 0x10 ordinal: 0x3
  ULONG CachedValue;            // offset: 0x18 ordinal: 0x4
  UCHAR Affinitized;            // offset: 0x20 ordinal: 0x5
  UCHAR Differential;           // offset: 0x21 ordinal: 0x6
  UCHAR DiscardIdleTime;        // offset: 0x22 ordinal: 0x7
  UCHAR Scaling;                // offset: 0x23 ordinal: 0x8
  ULONGLONG Context;            // offset: 0x28 ordinal: 0x9
} _PROC_FEEDBACK_COUNTER;

typedef LONG (*__anon_882)(VOID *, struct _GUID *, VOID *, ULONGLONG, VOID *,
                           ULONGLONG, ULONGLONG *);

// 0x50 bytes (sizeof)
typedef struct _POP_FX_DRIVER_CALLBACKS {
  VOID (*ComponentActive)(VOID *, ULONG);           // offset: 0x0 ordinal: 0x0
  VOID (*ComponentIdle)(VOID *, ULONG);             // offset: 0x8 ordinal: 0x1
  VOID (*ComponentIdleState)(VOID *, ULONG, ULONG); // offset: 0x10 ordinal: 0x2
  VOID (*DevicePowerRequired)(VOID *);              // offset: 0x18 ordinal: 0x3
  VOID (*DevicePowerNotRequired)(VOID *);           // offset: 0x20 ordinal: 0x4
  LONG(*PowerControl)
  (VOID *, struct _GUID *, VOID *, ULONGLONG, VOID *, ULONGLONG,
   ULONGLONG *); // offset: 0x28 ordinal: 0x5
  VOID(*ComponentCriticalTransition)
  (VOID *, ULONG, UCHAR); // offset: 0x30 ordinal: 0x6
  VOID(*DripsWatchdogCallback)
  (VOID *, struct _DEVICE_OBJECT *, ULONG);         // offset: 0x38 ordinal: 0x7
  VOID (*DirectedPowerUpCallback)(VOID *, ULONG);   // offset: 0x40 ordinal: 0x8
  VOID (*DirectedPowerDownCallback)(VOID *, ULONG); // offset: 0x48 ordinal: 0x9
} _POP_FX_DRIVER_CALLBACKS;

typedef ULONG (*__anon_849)(ULONGLONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG,
                            ULONG *, ULONGLONG *);

typedef VOID (*__anon_846)(ULONGLONG *);

// 0x428 bytes (sizeof)
typedef struct _PROC_PERF_DOMAIN {
  struct _LIST_ENTRY Link;                      // offset: 0x0 ordinal: 0x0
  struct _PROC_PERF_CHECK_CONTEXT *Master;      // offset: 0x10 ordinal: 0x1
  struct _KAFFINITY_EX Members;                 // offset: 0x18 ordinal: 0x2
  ULONGLONG DomainContext;                      // offset: 0x120 ordinal: 0x3
  ULONG ProcessorCount;                         // offset: 0x128 ordinal: 0x4
  UCHAR EfficiencyClass;                        // offset: 0x12c ordinal: 0x5
  UCHAR NominalPerformanceClass;                // offset: 0x12d ordinal: 0x6
  UCHAR HighestPerformanceClass;                // offset: 0x12e ordinal: 0x7
  enum _PROCESSOR_PRESENCE Presence;            // offset: 0x130 ordinal: 0x8
  struct _PROC_PERF_CONSTRAINT *Processors;     // offset: 0x138 ordinal: 0x9
  VOID (*GetFFHThrottleState)(ULONGLONG *);     // offset: 0x140 ordinal: 0xa
  VOID (*TimeWindowHandler)(ULONGLONG, ULONG);  // offset: 0x148 ordinal: 0xb
  VOID (*BoostPolicyHandler)(ULONGLONG, ULONG); // offset: 0x150 ordinal: 0xc
  VOID (*BoostModeHandler)(ULONGLONG, ULONG);   // offset: 0x158 ordinal: 0xd
  VOID(*AutonomousActivityWindowHandler)
  (ULONGLONG, ULONG);                              // offset: 0x160 ordinal: 0xe
  VOID (*AutonomousModeHandler)(ULONGLONG, ULONG); // offset: 0x168 ordinal: 0xf
  VOID (*ReinitializeHandler)(ULONGLONG); // offset: 0x170 ordinal: 0x10
  ULONG(*PerfSelectionHandler)
  (ULONGLONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG *,
   ULONGLONG *); // offset: 0x178 ordinal: 0x11
  VOID(*PerfControlHandler)
  (ULONGLONG, struct _PERF_CONTROL_STATE_SELECTION *, UCHAR,
   UCHAR); // offset: 0x180 ordinal: 0x12
  VOID(*PerfControlHandlerHidden)
  (ULONGLONG, struct _PERF_CONTROL_STATE_SELECTION *, UCHAR,
   UCHAR); // offset: 0x188 ordinal: 0x13
  VOID(*DomainPerfControlHandler)
  (ULONGLONG, struct _PERF_CONTROL_STATE_SELECTION *, UCHAR,
   UCHAR); // offset: 0x190 ordinal: 0x14
  VOID(*PerfUpdateHwDebugData)
  (ULONGLONG, ULONGLONG, UCHAR); // offset: 0x198 ordinal: 0x15
  ULONG(*PerfQueryProcMeasurementCapabilities)
  (); // offset: 0x1a0 ordinal: 0x16
  LONG(*PerfQueryProcMeasurementValues)
  (ULONG, ULONG *, VOID *, ULONG);         // offset: 0x1a8 ordinal: 0x17
  ULONG Id;                                // offset: 0x1b0 ordinal: 0x18
  ULONG MaxFrequency;                      // offset: 0x1b4 ordinal: 0x19
  ULONG NominalFrequency;                  // offset: 0x1b8 ordinal: 0x1a
  ULONG MaxPercent;                        // offset: 0x1bc ordinal: 0x1b
  ULONG MinPerfPercent;                    // offset: 0x1c0 ordinal: 0x1c
  ULONG MinThrottlePercent;                // offset: 0x1c4 ordinal: 0x1d
  ULONG AdvertizedMaximumFrequency;        // offset: 0x1c8 ordinal: 0x1e
  ULONGLONG MinimumRelativePerformance;    // offset: 0x1d0 ordinal: 0x1f
  ULONGLONG NominalRelativePerformance;    // offset: 0x1d8 ordinal: 0x20
  UCHAR NominalRelativePerformancePercent; // offset: 0x1e0 ordinal: 0x21
  UCHAR Coordination;                      // offset: 0x1e1 ordinal: 0x22
  UCHAR HardPlatformCap;                   // offset: 0x1e2 ordinal: 0x23
  UCHAR AffinitizeControl;                 // offset: 0x1e3 ordinal: 0x24
  UCHAR EfficientThrottle;                 // offset: 0x1e4 ordinal: 0x25
  UCHAR AllowSchedulerDirectedPerfStates;  // offset: 0x1e5 ordinal: 0x26
  UCHAR InitiateAllProcessors;             // offset: 0x1e6 ordinal: 0x27
  UCHAR AllowVmPerfSelection;              // offset: 0x1e7 ordinal: 0x28
  ULONG VmFrequencyStepMhz;                // offset: 0x1e8 ordinal: 0x29
  ULONG VmHighestFrequencyMhz;             // offset: 0x1ec ordinal: 0x2a
  ULONG VmNominalFrequencyMhz;             // offset: 0x1f0 ordinal: 0x2b
  ULONG VmLowestFrequencyMhz;              // offset: 0x1f4 ordinal: 0x2c
  UCHAR AutonomousMode;                    // offset: 0x1f8 ordinal: 0x2d
  UCHAR AutonomousCapability;              // offset: 0x1f9 ordinal: 0x2e
  UCHAR ProvideGuidance;                   // offset: 0x1fa ordinal: 0x2f
  ULONG DesiredPercent;                    // offset: 0x1fc ordinal: 0x30
  ULONG GuaranteedPercent;                 // offset: 0x200 ordinal: 0x31
  UCHAR EngageResponsivenessOverrides;     // offset: 0x204 ordinal: 0x32
  struct _PROC_PERF_QOS_CLASS_POLICY
      QosPolicies[7];            // offset: 0x208 ordinal: 0x33
  ULONG QosDisableReasons[7];    // offset: 0x2cc ordinal: 0x34
  USHORT QosEquivalencyMasks[7]; // offset: 0x2e8 ordinal: 0x35
  UCHAR QosSupported;            // offset: 0x2f6 ordinal: 0x36
  ULONG SelectionGeneration;     // offset: 0x2f8 ordinal: 0x37
  struct _PERF_CONTROL_STATE_SELECTION
      QosSelection[7];           // offset: 0x300 ordinal: 0x38
  ULONGLONG PerfChangeTime;      // offset: 0x418 ordinal: 0x39
  ULONG PerfChangeIntervalCount; // offset: 0x420 ordinal: 0x3a
  UCHAR Force;                   // offset: 0x424 ordinal: 0x3b
  UCHAR Update;                  // offset: 0x425 ordinal: 0x3c
  UCHAR Apply;                   // offset: 0x426 ordinal: 0x3d
} _PROC_PERF_DOMAIN;

// 0x48 bytes (sizeof)
typedef struct _PROC_PERF_CHECK_CONTEXT {
  struct _PROC_PERF_DOMAIN *Domain;         // offset: 0x0 ordinal: 0x0
  struct _PROC_PERF_CONSTRAINT *Constraint; // offset: 0x8 ordinal: 0x1
  struct _PROC_PERF_CHECK *PerfCheck;       // offset: 0x10 ordinal: 0x2
  struct _PROC_PERF_LOAD *Load;             // offset: 0x18 ordinal: 0x3
  struct _PROC_PERF_HISTORY *PerfHistory;   // offset: 0x20 ordinal: 0x4
  ULONG Utility;                            // offset: 0x28 ordinal: 0x5
  ULONG AffinitizedUtility;                 // offset: 0x2c ordinal: 0x6
  ULONG MediaUtility;                       // offset: 0x30 ordinal: 0x7
  ULONG ImportantUtility;                   // offset: 0x34 ordinal: 0x8
  ULONG IdealUtility;                       // offset: 0x38 ordinal: 0x9
  USHORT LatestAffinitizedPercent;          // offset: 0x3c ordinal: 0xa
  USHORT AveragePerformancePercent;         // offset: 0x3e ordinal: 0xb
  ULONG RelativePerformance;                // offset: 0x40 ordinal: 0xc
  UCHAR NtProcessor;                        // offset: 0x44 ordinal: 0xd
} _PROC_PERF_CHECK_CONTEXT;

// 0x448 bytes (sizeof)
typedef struct _RTL_USER_PROCESS_PARAMETERS {
  ULONG MaximumLength;                  // offset: 0x0 ordinal: 0x0
  ULONG Length;                         // offset: 0x4 ordinal: 0x1
  ULONG Flags;                          // offset: 0x8 ordinal: 0x2
  ULONG DebugFlags;                     // offset: 0xc ordinal: 0x3
  VOID *ConsoleHandle;                  // offset: 0x10 ordinal: 0x4
  ULONG ConsoleFlags;                   // offset: 0x18 ordinal: 0x5
  VOID *StandardInput;                  // offset: 0x20 ordinal: 0x6
  VOID *StandardOutput;                 // offset: 0x28 ordinal: 0x7
  VOID *StandardError;                  // offset: 0x30 ordinal: 0x8
  struct _CURDIR CurrentDirectory;      // offset: 0x38 ordinal: 0x9
  struct _UNICODE_STRING DllPath;       // offset: 0x50 ordinal: 0xa
  struct _UNICODE_STRING ImagePathName; // offset: 0x60 ordinal: 0xb
  struct _UNICODE_STRING CommandLine;   // offset: 0x70 ordinal: 0xc
  VOID *Environment;                    // offset: 0x80 ordinal: 0xd
  ULONG StartingX;                      // offset: 0x88 ordinal: 0xe
  ULONG StartingY;                      // offset: 0x8c ordinal: 0xf
  ULONG CountX;                         // offset: 0x90 ordinal: 0x10
  ULONG CountY;                         // offset: 0x94 ordinal: 0x11
  ULONG CountCharsX;                    // offset: 0x98 ordinal: 0x12
  ULONG CountCharsY;                    // offset: 0x9c ordinal: 0x13
  ULONG FillAttribute;                  // offset: 0xa0 ordinal: 0x14
  ULONG WindowFlags;                    // offset: 0xa4 ordinal: 0x15
  ULONG ShowWindowFlags;                // offset: 0xa8 ordinal: 0x16
  struct _UNICODE_STRING WindowTitle;   // offset: 0xb0 ordinal: 0x17
  struct _UNICODE_STRING DesktopInfo;   // offset: 0xc0 ordinal: 0x18
  struct _UNICODE_STRING ShellInfo;     // offset: 0xd0 ordinal: 0x19
  struct _UNICODE_STRING RuntimeData;   // offset: 0xe0 ordinal: 0x1a
  struct _RTL_DRIVE_LETTER_CURDIR
      CurrentDirectores[32];                 // offset: 0xf0 ordinal: 0x1b
  ULONGLONG EnvironmentSize;                 // offset: 0x3f0 ordinal: 0x1c
  ULONGLONG EnvironmentVersion;              // offset: 0x3f8 ordinal: 0x1d
  VOID *PackageDependencyData;               // offset: 0x400 ordinal: 0x1e
  ULONG ProcessGroupId;                      // offset: 0x408 ordinal: 0x1f
  ULONG LoaderThreads;                       // offset: 0x40c ordinal: 0x20
  struct _UNICODE_STRING RedirectionDllName; // offset: 0x410 ordinal: 0x21
  struct _UNICODE_STRING HeapPartitionName;  // offset: 0x420 ordinal: 0x22
  ULONGLONG *DefaultThreadpoolCpuSetMasks;   // offset: 0x430 ordinal: 0x23
  ULONG DefaultThreadpoolCpuSetMaskCount;    // offset: 0x438 ordinal: 0x24
  ULONG DefaultThreadpoolThreadMaximum;      // offset: 0x43c ordinal: 0x25
  ULONG HeapMemoryTypeMask;                  // offset: 0x440 ordinal: 0x26
} _RTL_USER_PROCESS_PARAMETERS;

// 0x128 bytes (sizeof)
typedef struct _DEVICE_MAP {
  struct _OBJECT_DIRECTORY *DosDevicesDirectory; // offset: 0x0 ordinal: 0x0
  struct _OBJECT_DIRECTORY
      *GlobalDosDevicesDirectory;      // offset: 0x8 ordinal: 0x1
  struct _EJOB *ServerSilo;            // offset: 0x10 ordinal: 0x2
  struct _DEVICE_MAP *GlobalDeviceMap; // offset: 0x18 ordinal: 0x3
  struct _EX_FAST_REF DriveObject[26]; // offset: 0x20 ordinal: 0x4
  LONGLONG ReferenceCount;             // offset: 0xf0 ordinal: 0x5
  VOID *DosDevicesDirectoryHandle;     // offset: 0xf8 ordinal: 0x6
  ULONG DriveMap;                      // offset: 0x100 ordinal: 0x7
  UCHAR DriveType[32];                 // offset: 0x104 ordinal: 0x8
} _DEVICE_MAP;

// 0x40 bytes (sizeof)
typedef struct _ETW_SILO_TRACING_BLOCK {
  struct _EX_FAST_REF *ProcessorBuffers; // offset: 0x0 ordinal: 0x0
  ULONGLONG *EventsLoggedCount;          // offset: 0x8 ordinal: 0x1
  LONGLONG *QpcDelta;                    // offset: 0x10 ordinal: 0x2
} _ETW_SILO_TRACING_BLOCK;

// 0x260 bytes (sizeof)
typedef struct _PO_HIBER_PERF {
  ULONGLONG HiberIoTicks;                          // offset: 0x0 ordinal: 0x0
  ULONGLONG HiberIoCpuTicks;                       // offset: 0x8 ordinal: 0x1
  ULONGLONG HiberInitTicks;                        // offset: 0x10 ordinal: 0x2
  ULONGLONG HiberHiberFileTicks;                   // offset: 0x18 ordinal: 0x3
  ULONGLONG HiberCompressTicks;                    // offset: 0x20 ordinal: 0x4
  ULONGLONG HiberSharedBufferTicks;                // offset: 0x28 ordinal: 0x5
  ULONGLONG HiberChecksumTicks;                    // offset: 0x30 ordinal: 0x6
  ULONGLONG HiberChecksumIoTicks;                  // offset: 0x38 ordinal: 0x7
  union _LARGE_INTEGER TotalHibernateTime;         // offset: 0x40 ordinal: 0x8
  union _LARGE_INTEGER HibernateCompleteTimestamp; // offset: 0x48 ordinal: 0x9
  ULONG POSTTime;                                  // offset: 0x50 ordinal: 0xa
  ULONG ResumeBootMgrTime;                         // offset: 0x54 ordinal: 0xb
  ULONG BootmgrUserInputTime;                      // offset: 0x58 ordinal: 0xc
  ULONGLONG ResumeAppTicks;                        // offset: 0x60 ordinal: 0xd
  ULONGLONG ResumeAppStartTimestamp;               // offset: 0x68 ordinal: 0xe
  ULONGLONG ResumeLibraryInitTicks;                // offset: 0x70 ordinal: 0xf
  ULONGLONG ResumeInitTicks;                       // offset: 0x78 ordinal: 0x10
  ULONGLONG ResumeRestoreImageStartTimestamp;      // offset: 0x80 ordinal: 0x11
  ULONGLONG ResumeHiberFileTicks;                  // offset: 0x88 ordinal: 0x12
  ULONGLONG ResumeIoTicks;                         // offset: 0x90 ordinal: 0x13
  ULONGLONG ResumeDecompressTicks;                 // offset: 0x98 ordinal: 0x14
  ULONGLONG ResumeAllocateTicks;                   // offset: 0xa0 ordinal: 0x15
  ULONGLONG ResumeUserInOutTicks;                  // offset: 0xa8 ordinal: 0x16
  ULONGLONG ResumeMapTicks;                        // offset: 0xb0 ordinal: 0x17
  ULONGLONG ResumeUnmapTicks;                      // offset: 0xb8 ordinal: 0x18
  ULONGLONG ResumeChecksumTicks;                   // offset: 0xc0 ordinal: 0x19
  ULONGLONG ResumeChecksumIoTicks;                 // offset: 0xc8 ordinal: 0x1a
  ULONGLONG ResumeKernelSwitchTimestamp;           // offset: 0xd0 ordinal: 0x1b
  ULONGLONG CyclesPerMs;                           // offset: 0xd8 ordinal: 0x1c
  ULONGLONG WriteLogDataTimestamp;                 // offset: 0xe0 ordinal: 0x1d
  ULONGLONG KernelReturnFromHandler;               // offset: 0xe8 ordinal: 0x1e
  ULONGLONG TimeStampCounterAtSwitchTime;          // offset: 0xf0 ordinal: 0x1f
  ULONGLONG Reserved[2];                           // offset: 0xf8 ordinal: 0x20
  ULONGLONG SleeperThreadEnd;        // offset: 0x108 ordinal: 0x21
  ULONGLONG PostCmosUpdateTimestamp; // offset: 0x110 ordinal: 0x22
  ULONGLONG
  KernelReturnSystemPowerStateTimestamp; // offset: 0x118 ordinal: 0x23
  ULONGLONG IoBoundedness;               // offset: 0x120 ordinal: 0x24
  ULONGLONG KernelDecompressTicks;       // offset: 0x128 ordinal: 0x25
  ULONGLONG KernelIoTicks;               // offset: 0x130 ordinal: 0x26
  ULONGLONG KernelCopyTicks;             // offset: 0x138 ordinal: 0x27
  ULONGLONG ReadCheckCount;              // offset: 0x140 ordinal: 0x28
  ULONGLONG KernelInitTicks;             // offset: 0x148 ordinal: 0x29
  ULONGLONG KernelResumeHiberFileTicks;  // offset: 0x150 ordinal: 0x2a
  ULONGLONG KernelIoCpuTicks;            // offset: 0x158 ordinal: 0x2b
  ULONGLONG KernelSharedBufferTicks;     // offset: 0x160 ordinal: 0x2c
  ULONGLONG KernelAnimationTicks;        // offset: 0x168 ordinal: 0x2d
  ULONGLONG KernelChecksumTicks;         // offset: 0x170 ordinal: 0x2e
  ULONGLONG KernelChecksumIoTicks;       // offset: 0x178 ordinal: 0x2f
  union _LARGE_INTEGER AnimationStart;   // offset: 0x180 ordinal: 0x30
  union _LARGE_INTEGER AnimationStop;    // offset: 0x188 ordinal: 0x31
  ULONG DeviceResumeTime;                // offset: 0x190 ordinal: 0x32
  ULONGLONG SecurePagesProcessed;        // offset: 0x198 ordinal: 0x33
  ULONGLONG BootPagesProcessed;          // offset: 0x1a0 ordinal: 0x34
  ULONGLONG KernelPagesProcessed;        // offset: 0x1a8 ordinal: 0x35
  ULONGLONG BootBytesWritten;            // offset: 0x1b0 ordinal: 0x36
  ULONGLONG KernelBytesWritten;          // offset: 0x1b8 ordinal: 0x37
  ULONGLONG BootPagesWritten;            // offset: 0x1c0 ordinal: 0x38
  ULONGLONG KernelPagesWritten;          // offset: 0x1c8 ordinal: 0x39
  ULONGLONG BytesWritten;                // offset: 0x1d0 ordinal: 0x3a
  ULONG PagesWritten;                    // offset: 0x1d8 ordinal: 0x3b
  ULONG FileRuns;                        // offset: 0x1dc ordinal: 0x3c
  ULONG NoMultiStageResumeReason;        // offset: 0x1e0 ordinal: 0x3d
  ULONG MaxHuffRatio;                    // offset: 0x1e4 ordinal: 0x3e
  ULONGLONG AdjustedTotalResumeTime;     // offset: 0x1e8 ordinal: 0x3f
  ULONGLONG ResumeCompleteTimestamp;     // offset: 0x1f0 ordinal: 0x40
  ULONGLONG WinresumeExitTimestamp;      // offset: 0x1f8 ordinal: 0x41
  ULONGLONG TcbLoaderStartTimestamp;     // offset: 0x200 ordinal: 0x42
  ULONGLONG TcbLoaderEndTimestamp;       // offset: 0x208 ordinal: 0x43
  ULONGLONG RemappedPageLookupCycles;    // offset: 0x210 ordinal: 0x44
  ULONGLONG TcbLaunchPrepareCycles;      // offset: 0x218 ordinal: 0x45
  ULONGLONG TcbLaunchPrepareDataCycles;  // offset: 0x220 ordinal: 0x46
  ULONGLONG TcbRestoreStateCycles;       // offset: 0x228 ordinal: 0x47
  ULONGLONG DecryptVsmPagesPhase0Cycles; // offset: 0x230 ordinal: 0x48
  ULONGLONG DecryptVsmPagesPhase1Cycles; // offset: 0x238 ordinal: 0x49
  ULONGLONG DecryptVsmPagesPhase2Cycles; // offset: 0x240 ordinal: 0x4a
  ULONGLONG TcbLoaderAuthenticateCycles; // offset: 0x248 ordinal: 0x4b
  ULONGLONG TcbLoaderDecryptCycles;      // offset: 0x250 ordinal: 0x4c
  ULONGLONG TcbLoaderValidateCycles;     // offset: 0x258 ordinal: 0x4d
} _PO_HIBER_PERF;

// 0x448 bytes (sizeof)
typedef struct PO_MEMORY_IMAGE {
  ULONG Signature;                           // offset: 0x0 ordinal: 0x0
  ULONG ImageType;                           // offset: 0x4 ordinal: 0x1
  ULONG CheckSum;                            // offset: 0x8 ordinal: 0x2
  ULONG LengthSelf;                          // offset: 0xc ordinal: 0x3
  ULONGLONG PageSelf;                        // offset: 0x10 ordinal: 0x4
  ULONG PageSize;                            // offset: 0x18 ordinal: 0x5
  union _LARGE_INTEGER SystemTime;           // offset: 0x20 ordinal: 0x6
  ULONGLONG InterruptTime;                   // offset: 0x28 ordinal: 0x7
  ULONGLONG FeatureFlags;                    // offset: 0x30 ordinal: 0x8
  UCHAR HiberFlags;                          // offset: 0x38 ordinal: 0x9
  UCHAR HiberSimulateFlags;                  // offset: 0x39 ordinal: 0xa
  UCHAR spare[2];                            // offset: 0x3a ordinal: 0xb
  ULONG NoHiberPtes;                         // offset: 0x3c ordinal: 0xc
  ULONGLONG HiberVa;                         // offset: 0x40 ordinal: 0xd
  ULONG NoFreePages;                         // offset: 0x48 ordinal: 0xe
  ULONG FreeMapCheck;                        // offset: 0x4c ordinal: 0xf
  ULONG WakeCheck;                           // offset: 0x50 ordinal: 0x10
  ULONGLONG NumPagesForLoader;               // offset: 0x58 ordinal: 0x11
  ULONGLONG FirstSecureRestorePage;          // offset: 0x60 ordinal: 0x12
  ULONGLONG FirstBootRestorePage;            // offset: 0x68 ordinal: 0x13
  ULONGLONG FirstKernelRestorePage;          // offset: 0x70 ordinal: 0x14
  ULONGLONG FirstChecksumRestorePage;        // offset: 0x78 ordinal: 0x15
  ULONGLONG NoChecksumEntries;               // offset: 0x80 ordinal: 0x16
  struct _PO_HIBER_PERF PerfInfo;            // offset: 0x88 ordinal: 0x17
  ULONG FirmwareRuntimeInformationPages;     // offset: 0x2e8 ordinal: 0x18
  ULONGLONG FirmwareRuntimeInformation[1];   // offset: 0x2f0 ordinal: 0x19
  ULONG SpareUlong;                          // offset: 0x2f8 ordinal: 0x1a
  ULONG NoBootLoaderLogPages;                // offset: 0x2fc ordinal: 0x1b
  ULONGLONG BootLoaderLogPages[24];          // offset: 0x300 ordinal: 0x1c
  ULONG NotUsed;                             // offset: 0x3c0 ordinal: 0x1d
  ULONG ResumeContextCheck;                  // offset: 0x3c4 ordinal: 0x1e
  ULONG ResumeContextPages;                  // offset: 0x3c8 ordinal: 0x1f
  UCHAR Hiberboot;                           // offset: 0x3cc ordinal: 0x20
  UCHAR SecureLaunched;                      // offset: 0x3cd ordinal: 0x21
  UCHAR SecureBoot;                          // offset: 0x3ce ordinal: 0x22
  UCHAR Fasr;                                // offset: 0x3cf ordinal: 0x23
  ULONGLONG HvPageTableRoot;                 // offset: 0x3d0 ordinal: 0x24
  ULONGLONG HvEntryPoint;                    // offset: 0x3d8 ordinal: 0x25
  ULONGLONG HvReservedTransitionAddress;     // offset: 0x3e0 ordinal: 0x26
  ULONGLONG HvReservedTransitionAddressSize; // offset: 0x3e8 ordinal: 0x27
  ULONGLONG BootFlags;                       // offset: 0x3f0 ordinal: 0x28
  ULONGLONG RestoreProcessorStateRoutine;    // offset: 0x3f8 ordinal: 0x29
  ULONGLONG HighestPhysicalPage;             // offset: 0x400 ordinal: 0x2a
  ULONGLONG BitlockerKeyPfns[4];             // offset: 0x408 ordinal: 0x2b
  ULONG HardwareSignature;                   // offset: 0x428 ordinal: 0x2c
  union _LARGE_INTEGER
      SMBiosTablePhysicalAddress;   // offset: 0x430 ordinal: 0x2d
  ULONG SMBiosTableLength;          // offset: 0x438 ordinal: 0x2e
  UCHAR SMBiosMajorVersion;         // offset: 0x43c ordinal: 0x2f
  UCHAR SMBiosMinorVersion;         // offset: 0x43d ordinal: 0x30
  UCHAR HiberResumeXhciHandoffSkip; // offset: 0x43e ordinal: 0x31
  UCHAR InitializeUSBCore;          // offset: 0x43f ordinal: 0x32
  UCHAR ValidUSBCoreId;             // offset: 0x440 ordinal: 0x33
  UCHAR USBCoreId;                  // offset: 0x441 ordinal: 0x34
  UCHAR SkipMemoryMapValidation;    // offset: 0x442 ordinal: 0x35
  UCHAR SuppressResumePrompt;       // offset: 0x443 ordinal: 0x36
} PO_MEMORY_IMAGE;

// 0x80 bytes (sizeof)
typedef struct _POP_PER_PROCESSOR_CONTEXT {
  UCHAR *UncompressedData;              // offset: 0x0 ordinal: 0x0
  VOID *MappingVa;                      // offset: 0x8 ordinal: 0x1
  VOID *XpressEncodeWorkspace;          // offset: 0x10 ordinal: 0x2
  UCHAR *CompressedDataBuffer;          // offset: 0x18 ordinal: 0x3
  ULONGLONG CopyTicks;                  // offset: 0x20 ordinal: 0x4
  ULONGLONG CompressTicks;              // offset: 0x28 ordinal: 0x5
  ULONGLONG BytesCopied;                // offset: 0x30 ordinal: 0x6
  ULONGLONG PagesProcessed;             // offset: 0x38 ordinal: 0x7
  ULONGLONG DecompressTicks;            // offset: 0x40 ordinal: 0x8
  ULONGLONG ResumeCopyTicks;            // offset: 0x48 ordinal: 0x9
  ULONGLONG SharedBufferTicks;          // offset: 0x50 ordinal: 0xa
  ULONGLONG DecompressTicksByMethod[2]; // offset: 0x58 ordinal: 0xb
  ULONGLONG DecompressSizeByMethod[2];  // offset: 0x68 ordinal: 0xc
  ULONG CompressCount;                  // offset: 0x78 ordinal: 0xd
  ULONG HuffCompressCount;              // offset: 0x7c ordinal: 0xe
} _POP_PER_PROCESSOR_CONTEXT;

// 0x20 bytes (sizeof)
typedef struct _VI_VERIFIER_ISSUE {
  ULONGLONG IssueType;     // offset: 0x0 ordinal: 0x0
  VOID *Address;           // offset: 0x8 ordinal: 0x1
  ULONGLONG Parameters[2]; // offset: 0x10 ordinal: 0x2
} _VI_VERIFIER_ISSUE;

// 0x88 bytes (sizeof)
typedef struct _KTIMER2 {
  struct _DISPATCHER_HEADER Header; // offset: 0x0 ordinal: 0x0
  union {
    struct _RTL_BALANCED_NODE RbNodes[2]; // offset: 0x18 ordinal: 0x1
    struct _LIST_ENTRY ListEntry;         // offset: 0x18 ordinal: 0x2
  };
  ULONGLONG DueTime[2];                        // offset: 0x48 ordinal: 0x3
  LONGLONG Period;                             // offset: 0x58 ordinal: 0x4
  VOID (*Callback)(struct _KTIMER2 *, VOID *); // offset: 0x60 ordinal: 0x5
  VOID *CallbackContext;                       // offset: 0x68 ordinal: 0x6
  VOID (*DisableCallback)(VOID *);             // offset: 0x70 ordinal: 0x7
  VOID *DisableContext;                        // offset: 0x78 ordinal: 0x8
  UCHAR AbsoluteSystemTime;                    // offset: 0x80 ordinal: 0x9
  union {
    UCHAR TypeFlags;  // offset: 0x81 ordinal: 0xa
    UCHAR Unused : 1; // offset: 0x81 ordinal: 0xb
  };
  UCHAR IdleResilient : 1;  // offset: 0x81 ordinal: 0xc
  UCHAR HighResolution : 1; // offset: 0x81 ordinal: 0xd
  UCHAR NoWake : 1;         // offset: 0x81 ordinal: 0xe
  UCHAR PseudoHighRes : 1;  // offset: 0x81 ordinal: 0xf
  UCHAR Unused1 : 3;        // offset: 0x81 ordinal: 0x10
  UCHAR CollectionIndex[2]; // offset: 0x82 ordinal: 0x11
} _KTIMER2;

typedef VOID (*__anon_3815)(struct _KTIMER2 *, VOID *);

// 0x10 bytes (sizeof)
typedef struct _MI_WRITE_MODES {
  ULONGLONG WriteType[2]; // offset: 0x0 ordinal: 0x0
} _MI_WRITE_MODES;

// 0x20 bytes (sizeof)
typedef struct _MI_WRITE_CALIBRATION {
  ULONG MaximumNumberProcessors;       // offset: 0x0 ordinal: 0x0
  UCHAR OptimalWriteType;              // offset: 0x4 ordinal: 0x1
  UCHAR CalibrationCompleted;          // offset: 0x5 ordinal: 0x2
  UCHAR CalibrationFinal[2];           // offset: 0x6 ordinal: 0x3
  ULONGLONG PerProcessorNumberOfBytes; // offset: 0x8 ordinal: 0x4
  ULONG OptimalWriteProcessors[2];     // offset: 0x10 ordinal: 0x5
  struct _MI_WRITE_MODES *PureZeroing; // offset: 0x18 ordinal: 0x6
} _MI_WRITE_CALIBRATION;

// 0x240 bytes (sizeof)
typedef struct _MI_SYSTEM_NODE_INFORMATION {
  struct _GROUP_AFFINITY *GroupAffinity;           // offset: 0x0 ordinal: 0x0
  USHORT GroupAffinityCount;                       // offset: 0x8 ordinal: 0x1
  USHORT ProcessorCount[3];                        // offset: 0xa ordinal: 0x2
  USHORT UsableProcessorCount[3];                  // offset: 0x10 ordinal: 0x3
  struct _MI_NODE_NUMBER_ZERO_BASED ProcessorNode; // offset: 0x18 ordinal: 0x4
  struct _GROUP_AFFINITY
      ForwardProgressGroupAffinity; // offset: 0x20 ordinal: 0x5
  LONG LargePageListOpLock;         // offset: 0x30 ordinal: 0x6
  struct _MI_WRITE_CALIBRATION WriteCalibration[3]
                                               [3]; // offset: 0x38 ordinal: 0x7
  LONG IoPfnLock; // offset: 0x180 ordinal: 0x8
  struct _MI_DEFERRED_PFNS_TO_FREE
      DeferredPfnsToFree[4]; // offset: 0x188 ordinal: 0x9
  struct _MI_DEFERRED_PFNS_TO_FREE
      DeferredPfnsReady;       // offset: 0x208 ordinal: 0xa
  LONG DeferredPfnsToFreeLock; // offset: 0x228 ordinal: 0xb
} _MI_SYSTEM_NODE_INFORMATION;

// 0x178 bytes (sizeof)
typedef struct _MI_SYSTEM_NODE_NONPAGED_POOL {
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapNonPagedPool;     // offset: 0x0 ordinal: 0x0
  ULONGLONG CachedNonPagedPoolCount; // offset: 0x48 ordinal: 0x1
  ULONGLONG NonPagedPoolSpinLock;    // offset: 0x50 ordinal: 0x2
  struct _MMPFN *CachedNonPagedPool; // offset: 0x58 ordinal: 0x3
  VOID *NonPagedPoolFirstVa;         // offset: 0x60 ordinal: 0x4
  VOID *NonPagedPoolLastVa;          // offset: 0x68 ordinal: 0x5
  enum _MI_PFN_CACHE_ATTRIBUTE
      OptimalZeroingAttribute[4][4]; // offset: 0x70 ordinal: 0x6
  struct _MI_ZERO_COST_COUNTS ZeroCostCounts[3][2]
                                            [2]; // offset: 0xb0 ordinal: 0x7
  struct _MI_SYSTEM_NODE_INFORMATION
      *SystemNodeInformation; // offset: 0x170 ordinal: 0x8
} _MI_SYSTEM_NODE_NONPAGED_POOL;

// 0x1180 bytes (sizeof)
typedef struct _MI_HARDWARE_STATE {
  ULONG NodeMask;                               // offset: 0x0 ordinal: 0x0
  ULONG NumaHintIndex;                          // offset: 0x4 ordinal: 0x1
  ULONG NumaLastRangeIndexInclusive;            // offset: 0x8 ordinal: 0x2
  UCHAR MemoryNodeWithNoProcessorsFound;        // offset: 0xc ordinal: 0x3
  UCHAR NodeShift;                              // offset: 0xd ordinal: 0x4
  UCHAR ChannelShift;                           // offset: 0xe ordinal: 0x5
  UCHAR AccessBitReplacementHonored;            // offset: 0xf ordinal: 0x6
  ULONG ChannelHintIndex;                       // offset: 0x10 ordinal: 0x7
  ULONG ChannelLastRangeIndexInclusive;         // offset: 0x14 ordinal: 0x8
  struct _MI_NODE_NUMBER_ZERO_BASED *NodeGraph; // offset: 0x18 ordinal: 0x9
  struct _MI_SYSTEM_NODE_NONPAGED_POOL
      *SystemNodeNonPagedPool;                   // offset: 0x20 ordinal: 0xa
  struct _HAL_NODE_RANGE TemporaryNumaRanges[2]; // offset: 0x28 ordinal: 0xb
  struct _HAL_NODE_RANGE *NumaMemoryRanges;      // offset: 0x48 ordinal: 0xc
  struct _HAL_CHANNEL_MEMORY_RANGES
      *ChannelMemoryRanges;                      // offset: 0x50 ordinal: 0xd
  ULONG SecondLevelCacheSize;                    // offset: 0x58 ordinal: 0xe
  ULONG FirstLevelCacheSize;                     // offset: 0x5c ordinal: 0xf
  ULONG PhysicalAddressBits;                     // offset: 0x60 ordinal: 0x10
  ULONG PfnDatabasePageBits;                     // offset: 0x64 ordinal: 0x11
  UCHAR ProcessorCachesFlushedOnPowerLoss;       // offset: 0x68 ordinal: 0x12
  UCHAR PageTableReuseRequiresFlush;             // offset: 0x69 ordinal: 0x13
  ULONGLONG TotalPagesAllowed;                   // offset: 0x70 ordinal: 0x14
  ULONG SecondaryColorMask;                      // offset: 0x78 ordinal: 0x15
  ULONG SecondaryColors;                         // offset: 0x7c ordinal: 0x16
  ULONG FlushTbForAttributeChange;               // offset: 0x80 ordinal: 0x17
  ULONG FlushCacheForAttributeChange;            // offset: 0x84 ordinal: 0x18
  ULONG FlushCacheForPageAttributeChange;        // offset: 0x88 ordinal: 0x19
  ULONG CacheFlushPromoteThreshold;              // offset: 0x8c ordinal: 0x1a
  ULONGLONG InvalidPteMask;                      // offset: 0xc0 ordinal: 0x1b
  ULONG LargePageColors[3];                      // offset: 0x100 ordinal: 0x1c
  ULONGLONG FlushTbThreshold;                    // offset: 0x110 ordinal: 0x1d
  UCHAR AttributeChangeRequiresReZero;           // offset: 0x118 ordinal: 0x1e
  ULONGLONG HighestPossiblePhysicalPage;         // offset: 0x120 ordinal: 0x1f
  ULONGLONG VsmKernelPageCount;                  // offset: 0x128 ordinal: 0x20
  ULONGLONG HugePageRemoveTracker[512];          // offset: 0x130 ordinal: 0x21
  ULONGLONG HotAddSequenceNumber;                // offset: 0x1130 ordinal: 0x22
  ULONGLONG SpecialPurposeMemoryTypeId;          // offset: 0x1138 ordinal: 0x23
  ULONG SpecialPurposeMemoryQueryTypeExtraSpace; // offset: 0x1140 ordinal: 0x24
} _MI_HARDWARE_STATE;

// 0xc0 bytes (sizeof)
typedef struct _MI_IO_PAGE_STATE {
  struct _RTL_AVL_TREE IoPfnRoot[2];            // offset: 0x0 ordinal: 0x0
  ULONGLONG UnmappedNodeCount[2];               // offset: 0x10 ordinal: 0x1
  ULONGLONG UnmappedHugeIoSpaceNodeCount;       // offset: 0x20 ordinal: 0x2
  ULONGLONG UnmappedNodeCountMaximum;           // offset: 0x40 ordinal: 0x3
  ULONGLONG TotalNodeCount[2];                  // offset: 0x48 ordinal: 0x4
  struct _RTL_AVL_TREE InvariantIoSpace;        // offset: 0x58 ordinal: 0x5
  LONG IoPfnPruneLock;                          // offset: 0x60 ordinal: 0x6
  ULONGLONG ResumePageForDeleteScans[2];        // offset: 0x68 ordinal: 0x7
  struct _WORK_QUEUE_ITEM UnmappedNodeWorkItem; // offset: 0x78 ordinal: 0x8
  struct _MI_IO_CACHE_STATS IoCacheStats;       // offset: 0x98 ordinal: 0x9
} _MI_IO_PAGE_STATE;

// 0x500 bytes (sizeof)
typedef struct _MI_SYSTEM_VA_STATE {
  ULONGLONG SystemTablesLock;       // offset: 0x0 ordinal: 0x0
  ULONGLONG AvailableSystemCacheVa; // offset: 0x8 ordinal: 0x1
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapKernelStacks; // offset: 0x10 ordinal: 0x2
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapKernelShadowStacks; // offset: 0x58 ordinal: 0x3
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapSystemPtes; // offset: 0xa0 ordinal: 0x4
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapDriverImages[2]; // offset: 0xe8 ordinal: 0x5
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapPagedPool; // offset: 0x178 ordinal: 0x6
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapSystemCache; // offset: 0x1c0 ordinal: 0x7
  struct _MI_DYNAMIC_BITMAP
      DynamicBitMapSecureNonPagedPool;            // offset: 0x208 ordinal: 0x8
  VOID *HalPrivateVaStart;                        // offset: 0x250 ordinal: 0x9
  ULONGLONG HalPrivateVaSize;                     // offset: 0x258 ordinal: 0xa
  ULONG SystemVaAssignment[8];                    // offset: 0x260 ordinal: 0xb
  ULONG SystemVaAssignmentHint;                   // offset: 0x280 ordinal: 0xc
  ULONG TopLevelPteLockBits[32];                  // offset: 0x284 ordinal: 0xd
  LONG DeleteKvaLock;                             // offset: 0x304 ordinal: 0xe
  struct _MI_WSLE *WsleArrays[8];                 // offset: 0x308 ordinal: 0xf
  VOID *PagableHyperSpace;                        // offset: 0x348 ordinal: 0x10
  VOID *HyperSpaceEnd;                            // offset: 0x350 ordinal: 0x11
  ULONGLONG PagableHyperSpaceBytes;               // offset: 0x358 ordinal: 0x12
  ULONGLONG PageTableCommitmentOffset[2];         // offset: 0x360 ordinal: 0x13
  struct _KEVENT FreeSystemCacheVa;               // offset: 0x370 ordinal: 0x14
  ULONGLONG SystemVaLock;                         // offset: 0x388 ordinal: 0x15
  ULONGLONG SystemCacheViewLock;                  // offset: 0x390 ordinal: 0x16
  struct _MMWSL_INSTANCE SystemWorkingSetList[8]; // offset: 0x398 ordinal: 0x17
  ULONGLONG SelfmapLock[4];                       // offset: 0x4d8 ordinal: 0x18
} _MI_SYSTEM_VA_STATE;

// 0xf20 bytes (sizeof)
typedef struct _LOADER_PARAMETER_EXTENSION {
  ULONG Size;                              // offset: 0x0 ordinal: 0x0
  struct _PROFILE_PARAMETER_BLOCK Profile; // offset: 0x4 ordinal: 0x1
  VOID *EmInfFileImage;                    // offset: 0x18 ordinal: 0x2
  ULONG EmInfFileSize;                     // offset: 0x20 ordinal: 0x3
  VOID *TriageDumpBlock;                   // offset: 0x28 ordinal: 0x4
  struct _HEADLESS_LOADER_BLOCK
      *HeadlessLoaderBlock;                         // offset: 0x30 ordinal: 0x5
  struct _SMBIOS3_TABLE_HEADER *SMBiosEPSHeader;    // offset: 0x38 ordinal: 0x6
  VOID *DrvDBImage;                                 // offset: 0x40 ordinal: 0x7
  ULONG DrvDBSize;                                  // offset: 0x48 ordinal: 0x8
  VOID *DrvDBPatchImage;                            // offset: 0x50 ordinal: 0x9
  ULONG DrvDBPatchSize;                             // offset: 0x58 ordinal: 0xa
  struct _NETWORK_LOADER_BLOCK *NetworkLoaderBlock; // offset: 0x60 ordinal: 0xb
  struct _LIST_ENTRY FirmwareDescriptorListHead;    // offset: 0x68 ordinal: 0xc
  VOID *AcpiTable;                                  // offset: 0x78 ordinal: 0xd
  ULONG AcpiTableSize;                              // offset: 0x80 ordinal: 0xe
  ULONG LastBootSucceeded : 1;                      // offset: 0x84 ordinal: 0xf
  ULONG LastBootShutdown : 1;           // offset: 0x84 ordinal: 0x10
  ULONG IoPortAccessSupported : 1;      // offset: 0x84 ordinal: 0x11
  ULONG BootDebuggerActive : 1;         // offset: 0x84 ordinal: 0x12
  ULONG StrongCodeGuarantees : 1;       // offset: 0x84 ordinal: 0x13
  ULONG HardStrongCodeGuarantees : 1;   // offset: 0x84 ordinal: 0x14
  ULONG SidSharingDisabled : 1;         // offset: 0x84 ordinal: 0x15
  ULONG TpmInitialized : 1;             // offset: 0x84 ordinal: 0x16
  ULONG VsmConfigured : 1;              // offset: 0x84 ordinal: 0x17
  ULONG IumEnabled : 1;                 // offset: 0x84 ordinal: 0x18
  ULONG IsSmbboot : 1;                  // offset: 0x84 ordinal: 0x19
  ULONG BootLogEnabled : 1;             // offset: 0x84 ordinal: 0x1a
  ULONG DriverVerifierEnabled : 1;      // offset: 0x84 ordinal: 0x1b
  ULONG SuppressMonitorX : 1;           // offset: 0x84 ordinal: 0x1c
  ULONG KernelCetEnabled : 1;           // offset: 0x84 ordinal: 0x1d
  ULONG SuppressSmap : 1;               // offset: 0x84 ordinal: 0x1e
  ULONG PointerAuthKernelIpEnabled : 1; // offset: 0x84 ordinal: 0x1f
  ULONG SplitLargeNumaNodes : 1;        // offset: 0x84 ordinal: 0x20
  ULONG KernelCetAuditModeEnabled : 1;  // offset: 0x84 ordinal: 0x21
  ULONG VerboseSELEnabled : 1;          // offset: 0x84 ordinal: 0x22
  ULONG EarlyCrashDumpEnabled : 1;      // offset: 0x84 ordinal: 0x23
  ULONG FeatureSimulations : 6;         // offset: 0x84 ordinal: 0x24
  ULONG MicrocodeSelfHosting : 1;       // offset: 0x84 ordinal: 0x25
  ULONG XhciLegacyHandoffSkip : 1;      // offset: 0x84 ordinal: 0x26
  ULONG DisableInsiderOptInHVCI : 1;    // offset: 0x84 ordinal: 0x27
  ULONG MicrocodeMinVerSupported : 1;   // offset: 0x84 ordinal: 0x28
  ULONG GpuIommuEnabled : 1;            // offset: 0x84 ordinal: 0x29
  struct _LOADER_PERFORMANCE_DATA
      LoaderPerformanceData; // offset: 0x88 ordinal: 0x2a
  struct _LIST_ENTRY
      BootApplicationPersistentData;    // offset: 0xe8 ordinal: 0x2b
  VOID *WmdTestResult;                  // offset: 0xf8 ordinal: 0x2c
  struct _GUID BootIdentifier;          // offset: 0x100 ordinal: 0x2d
  ULONG ResumePages;                    // offset: 0x110 ordinal: 0x2e
  VOID *DumpHeader;                     // offset: 0x118 ordinal: 0x2f
  VOID *BgContext;                      // offset: 0x120 ordinal: 0x30
  VOID *NumaLocalityInfo;               // offset: 0x128 ordinal: 0x31
  VOID *NumaGroupAssignment;            // offset: 0x130 ordinal: 0x32
  struct _LIST_ENTRY AttachedHives;     // offset: 0x138 ordinal: 0x33
  ULONG MemoryCachingRequirementsCount; // offset: 0x148 ordinal: 0x34
  VOID *MemoryCachingRequirements;      // offset: 0x150 ordinal: 0x35
  struct _BOOT_ENTROPY_LDR_RESULT
      BootEntropyResult;               // offset: 0x158 ordinal: 0x36
  ULONGLONG ProcessorCounterFrequency; // offset: 0x9c0 ordinal: 0x37
  struct _LOADER_PARAMETER_HYPERVISOR_EXTENSION
      HypervisorExtension;                   // offset: 0x9c8 ordinal: 0x38
  struct _GUID HardwareConfigurationId;      // offset: 0xa08 ordinal: 0x39
  struct _LIST_ENTRY HalExtensionModuleList; // offset: 0xa18 ordinal: 0x3a
  struct _LIST_ENTRY PrmUpdateModuleList;    // offset: 0xa28 ordinal: 0x3b
  struct _LIST_ENTRY PrmFirmwareModuleList;  // offset: 0xa38 ordinal: 0x3c
  union _LARGE_INTEGER SystemTime;           // offset: 0xa48 ordinal: 0x3d
  ULONGLONG TimeStampAtSystemTimeRead;       // offset: 0xa50 ordinal: 0x3e
  union {
    ULONGLONG BootFlags;              // offset: 0xa58 ordinal: 0x3f
    ULONGLONG DbgMenuOsSelection : 1; // offset: 0xa58 ordinal: 0x40
  };
  ULONGLONG DbgHiberBoot : 1;      // offset: 0xa58 ordinal: 0x41
  ULONGLONG DbgSoftRestart : 1;    // offset: 0xa58 ordinal: 0x42
  ULONGLONG DbgMeasuredLaunch : 1; // offset: 0xa58 ordinal: 0x43
  union {
    ULONGLONG InternalBootFlags;  // offset: 0xa60 ordinal: 0x44
    ULONGLONG DbgUtcBootTime : 1; // offset: 0xa60 ordinal: 0x45
  };
  ULONGLONG DbgRtcBootTime : 1;      // offset: 0xa60 ordinal: 0x46
  ULONGLONG DbgNoLegacyServices : 1; // offset: 0xa60 ordinal: 0x47
  VOID *WfsFPData;                   // offset: 0xa68 ordinal: 0x48
  ULONG WfsFPDataSize;               // offset: 0xa70 ordinal: 0x49
  struct _LOADER_BUGCHECK_PARAMETERS
      BugcheckParameters;                         // offset: 0xa78 ordinal: 0x4a
  VOID *ApiSetSchema;                             // offset: 0xaa0 ordinal: 0x4b
  ULONG ApiSetSchemaSize;                         // offset: 0xaa8 ordinal: 0x4c
  struct _LIST_ENTRY ApiSetSchemaExtensions;      // offset: 0xab0 ordinal: 0x4d
  struct _UNICODE_STRING AcpiBiosVersion;         // offset: 0xac0 ordinal: 0x4e
  struct _UNICODE_STRING SmbiosVersion;           // offset: 0xad0 ordinal: 0x4f
  struct _UNICODE_STRING EfiVersion;              // offset: 0xae0 ordinal: 0x50
  struct _DEBUG_DEVICE_DESCRIPTOR *KdDebugDevice; // offset: 0xaf0 ordinal: 0x51
  struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
      OfflineCrashdumpConfigurationTable;      // offset: 0xaf8 ordinal: 0x52
  struct _UNICODE_STRING ManufacturingProfile; // offset: 0xb18 ordinal: 0x53
  VOID *BbtBuffer;                             // offset: 0xb28 ordinal: 0x54
  ULONGLONG XsaveAllowedFeatures;              // offset: 0xb30 ordinal: 0x55
  ULONG XsaveFlags;                            // offset: 0xb38 ordinal: 0x56
  VOID *BootOptions;                           // offset: 0xb40 ordinal: 0x57
  ULONG IumEnablement;                         // offset: 0xb48 ordinal: 0x58
  ULONG IumPolicy;                             // offset: 0xb4c ordinal: 0x59
  LONG IumStatus;                              // offset: 0xb50 ordinal: 0x5a
  ULONG BootId;                                // offset: 0xb54 ordinal: 0x5b
  struct _LOADER_PARAMETER_CI_EXTENSION
      *CodeIntegrityData;      // offset: 0xb58 ordinal: 0x5c
  ULONG CodeIntegrityDataSize; // offset: 0xb60 ordinal: 0x5d
  struct _LOADER_HIVE_RECOVERY_INFO
      SystemHiveRecoveryInfo;               // offset: 0xb64 ordinal: 0x5e
  ULONG SoftRestartCount;                   // offset: 0xb78 ordinal: 0x5f
  LONGLONG SoftRestartTime;                 // offset: 0xb80 ordinal: 0x60
  VOID *HypercallCodeVa;                    // offset: 0xb88 ordinal: 0x61
  VOID *HalVirtualAddress;                  // offset: 0xb90 ordinal: 0x62
  ULONGLONG HalNumberOfBytes;               // offset: 0xb98 ordinal: 0x63
  struct _LEAP_SECOND_DATA *LeapSecondData; // offset: 0xba0 ordinal: 0x64
  ULONG MajorRelease;                       // offset: 0xba8 ordinal: 0x65
  ULONG Reserved1;                          // offset: 0xbac ordinal: 0x66
  CHAR NtBuildLab[224];                     // offset: 0xbb0 ordinal: 0x67
  CHAR NtBuildLabEx[224];                   // offset: 0xc90 ordinal: 0x68
  struct _LOADER_RESET_REASON ResetReason;  // offset: 0xd70 ordinal: 0x69
  ULONG MaxPciBusNumber;                    // offset: 0xda0 ordinal: 0x6a
  ULONG FeatureSettings;                    // offset: 0xda4 ordinal: 0x6b
  ULONG HotPatchReserveSize;                // offset: 0xda8 ordinal: 0x6c
  ULONG RetpolineReserveSize;               // offset: 0xdac ordinal: 0x6d
  struct __anon_3487 MiniExecutive;         // offset: 0xdb0 ordinal: 0x6e
  struct _VSM_PERFORMANCE_DATA
      VsmPerformanceData;                      // offset: 0xdc0 ordinal: 0x6f
  struct _NUMA_MEMORY_RANGE *NumaMemoryRanges; // offset: 0xe00 ordinal: 0x70
  ULONG NumaMemoryRangeCount;                  // offset: 0xe08 ordinal: 0x71
  ULONG IommuFaultPolicy;                      // offset: 0xe0c ordinal: 0x72
  struct _LOADER_FEATURE_CONFIGURATION_INFORMATION
      FeatureConfigurationInformation;   // offset: 0xe10 ordinal: 0x73
  struct _ETW_BOOT_CONFIG EtwBootConfig; // offset: 0xe58 ordinal: 0x74
  struct _BOOT_FIRMWARE_RAMDISK_INFO
      *FwRamdiskInfo;                           // offset: 0xe70 ordinal: 0x75
  VOID *IpmiHwContext;                          // offset: 0xe78 ordinal: 0x76
  ULONGLONG IdleThreadShadowStack;              // offset: 0xe80 ordinal: 0x77
  ULONGLONG TransitionShadowStack;              // offset: 0xe88 ordinal: 0x78
  ULONGLONG *IstShadowStacksTable;              // offset: 0xe90 ordinal: 0x79
  ULONGLONG ReservedForKernelCet[2];            // offset: 0xe98 ordinal: 0x7a
  struct _MEMORY_MIRRORING_DATA *MirroringData; // offset: 0xea8 ordinal: 0x7b
  union _LARGE_INTEGER Luid;                    // offset: 0xeb0 ordinal: 0x7c
  struct __anon_3494 InstalledMemory;           // offset: 0xeb8 ordinal: 0x7d
  struct _LIST_ENTRY HotPatchList;              // offset: 0xec8 ordinal: 0x7e
  VOID *BSPMicrocodeData;                       // offset: 0xed8 ordinal: 0x7f
  ULONG BSPMicrocodeDataSize;                   // offset: 0xee0 ordinal: 0x80
  struct __anon_3495 CimfsInformation;          // offset: 0xee8 ordinal: 0x81
  union _LARGE_INTEGER HalSoftRebootDatabase;   // offset: 0xf08 ordinal: 0x82
  ULONG KasanEnabled : 1;                       // offset: 0xf10 ordinal: 0x83
  ULONG Unused2 : 31;                           // offset: 0xf10 ordinal: 0x84
  ULONGLONG PerformanceDataFrequency;           // offset: 0xf18 ordinal: 0x85
} _LOADER_PARAMETER_EXTENSION;

// 0x170 bytes (sizeof)
typedef struct _LOADER_PARAMETER_BLOCK {
  ULONG OsMajorVersion;                            // offset: 0x0 ordinal: 0x0
  ULONG OsMinorVersion;                            // offset: 0x4 ordinal: 0x1
  ULONG Size;                                      // offset: 0x8 ordinal: 0x2
  ULONG OsLoaderSecurityVersion;                   // offset: 0xc ordinal: 0x3
  struct _LIST_ENTRY LoadOrderListHead;            // offset: 0x10 ordinal: 0x4
  struct _LIST_ENTRY MemoryDescriptorListHead;     // offset: 0x20 ordinal: 0x5
  struct _LIST_ENTRY BootDriverListHead;           // offset: 0x30 ordinal: 0x6
  struct _LIST_ENTRY EarlyLaunchListHead;          // offset: 0x40 ordinal: 0x7
  struct _LIST_ENTRY CoreDriverListHead;           // offset: 0x50 ordinal: 0x8
  struct _LIST_ENTRY CoreExtensionsDriverListHead; // offset: 0x60 ordinal: 0x9
  struct _LIST_ENTRY TpmCoreDriverListHead;        // offset: 0x70 ordinal: 0xa
  ULONGLONG KernelStack;                           // offset: 0x80 ordinal: 0xb
  ULONGLONG Prcb;                                  // offset: 0x88 ordinal: 0xc
  ULONGLONG Process;                               // offset: 0x90 ordinal: 0xd
  ULONGLONG Thread;                                // offset: 0x98 ordinal: 0xe
  ULONG KernelStackSize;                           // offset: 0xa0 ordinal: 0xf
  ULONG RegistryLength;                            // offset: 0xa4 ordinal: 0x10
  VOID *RegistryBase;                              // offset: 0xa8 ordinal: 0x11
  struct _CONFIGURATION_COMPONENT_DATA
      *ConfigurationRoot;          // offset: 0xb0 ordinal: 0x12
  CHAR *ArcBootDeviceName;         // offset: 0xb8 ordinal: 0x13
  CHAR *ArcHalDeviceName;          // offset: 0xc0 ordinal: 0x14
  CHAR *NtBootPathName;            // offset: 0xc8 ordinal: 0x15
  CHAR *NtHalPathName;             // offset: 0xd0 ordinal: 0x16
  CHAR *LoadOptions;               // offset: 0xd8 ordinal: 0x17
  struct _NLS_DATA_BLOCK *NlsData; // offset: 0xe0 ordinal: 0x18
  struct _ARC_DISK_INFORMATION
      *ArcDiskInformation;                       // offset: 0xe8 ordinal: 0x19
  struct _LOADER_PARAMETER_EXTENSION *Extension; // offset: 0xf0 ordinal: 0x1a
  union __anon_3377 u;                           // offset: 0xf8 ordinal: 0x1b
  struct _FIRMWARE_INFORMATION_LOADER_BLOCK
      FirmwareInformation;                  // offset: 0x108 ordinal: 0x1c
  CHAR *OsBootstatPathName;                 // offset: 0x148 ordinal: 0x1d
  CHAR *ArcOSDataDeviceName;                // offset: 0x150 ordinal: 0x1e
  CHAR *ArcWindowsSysPartName;              // offset: 0x158 ordinal: 0x1f
  struct _RTL_RB_TREE MemoryDescriptorTree; // offset: 0x160 ordinal: 0x20
} _LOADER_PARAMETER_BLOCK;

typedef VOID *(*__anon_3258)(struct _LOADER_PARAMETER_BLOCK *, ULONG,
                             ULONGLONG *, ULONG);

typedef VOID *(*__anon_3241)(struct _LOADER_PARAMETER_BLOCK *, ULONG);

// 0x20 bytes (sizeof)
typedef struct _HEAP_VAMGR_RANGE {
  union {
    struct _RTL_BALANCED_NODE RbNode; // offset: 0x0 ordinal: 0x0
    struct _SINGLE_LIST_ENTRY Next;   // offset: 0x0 ordinal: 0x1
    UCHAR Allocated : 1;              // offset: 0x0 ordinal: 0x2
  };
  UCHAR Internal : 1;    // offset: 0x0 ordinal: 0x3
  UCHAR Standalone : 1;  // offset: 0x0 ordinal: 0x4
  UCHAR Spare0 : 5;      // offset: 0x0 ordinal: 0x5
  UCHAR AllocatorIndex;  // offset: 0x1 ordinal: 0x6
  ULONGLONG OwnerCtx[2]; // offset: 0x8 ordinal: 0x7
  union {
    ULONGLONG SizeInChunks; // offset: 0x18 ordinal: 0x8
    USHORT ChunkCount;      // offset: 0x18 ordinal: 0x9
  };
  USHORT PrevChunkCount; // offset: 0x1a ordinal: 0xa
  ULONGLONG Signature;   // offset: 0x18 ordinal: 0xb
} _HEAP_VAMGR_RANGE;

// 0x20 bytes (sizeof)
typedef struct _KIST_LINK_FRAME {
  struct _KIST_BASE_FRAME *IstBaseFrame; // offset: 0x0 ordinal: 0x0
  ULONG Signature;                       // offset: 0x8 ordinal: 0x1
  ULONG Reserved0;                       // offset: 0xc ordinal: 0x2
  ULONGLONG Reserved[2];                 // offset: 0x10 ordinal: 0x3
} _KIST_LINK_FRAME;

// 0x30 bytes (sizeof)
typedef struct _KIST_BASE_FRAME {
  struct _KPCR *KernelGsBase;        // offset: 0x0 ordinal: 0x0
  struct _KIST_LINK_FRAME *IstStack; // offset: 0x8 ordinal: 0x1
  ULONGLONG PreviousGsBase;          // offset: 0x10 ordinal: 0x2
  ULONGLONG PreviousCr3;             // offset: 0x18 ordinal: 0x3
  ULONGLONG IstPad;                  // offset: 0x20 ordinal: 0x4
  ULONGLONG Reserved;                // offset: 0x28 ordinal: 0x5
} _KIST_BASE_FRAME;

// 0x430 bytes (sizeof)
typedef struct _MI_FREE_LARGE_PAGES {
  ULONGLONG LargePageFreeCount[2];         // offset: 0x0 ordinal: 0x0
  ULONGLONG LargePageFreeCountHiLow[2][2]; // offset: 0x10 ordinal: 0x1
  ULONGLONG LargePagesCount[2][2][4][4];   // offset: 0x30 ordinal: 0x2
  struct _MI_FREE_LARGE_PAGE_LIST
      *LargePageEntries[2][2][4][4]; // offset: 0x230 ordinal: 0x3
} _MI_FREE_LARGE_PAGES;

// 0x10 bytes (sizeof)
typedef union __m128 {
  float m128_f32[4];     // offset: 0x0 ordinal: 0x0
  ULONGLONG m128_u64[2]; // offset: 0x0 ordinal: 0x1
  CHAR m128_i8[16];      // offset: 0x0 ordinal: 0x2
  SHORT m128_i16[8];     // offset: 0x0 ordinal: 0x3
  LONG m128_i32[4];      // offset: 0x0 ordinal: 0x4
  LONGLONG m128_i64[2];  // offset: 0x0 ordinal: 0x5
  UCHAR m128_u8[16];     // offset: 0x0 ordinal: 0x6
  USHORT m128_u16[8];    // offset: 0x0 ordinal: 0x7
  ULONG m128_u32[4];     // offset: 0x0 ordinal: 0x8
} __m128;

// 0x10 bytes (sizeof)
typedef struct _TRUSTLET_COLLABORATION_ID {
  ULONGLONG Value[2]; // offset: 0x0 ordinal: 0x0
} _TRUSTLET_COLLABORATION_ID;

// 0x10 bytes (sizeof)
typedef struct _TRUSTLET_MAILBOX_KEY {
  ULONGLONG SecretValue[2]; // offset: 0x0 ordinal: 0x0
} _TRUSTLET_MAILBOX_KEY;

// 0x10 bytes (sizeof)
typedef struct __anon_1987 {
  ULONGLONG Reserved[2]; // offset: 0x0 ordinal: 0x0
} __anon_1987;

// 0x10 bytes (sizeof)
typedef union _INVPCID_DESCRIPTOR {
  struct __anon_1985 IndividualAddress;    // offset: 0x0 ordinal: 0x0
  struct __anon_1986 SingleContext;        // offset: 0x0 ordinal: 0x1
  struct __anon_1987 AllContextAndGlobals; // offset: 0x0 ordinal: 0x2
  struct __anon_1987 AllContext;           // offset: 0x0 ordinal: 0x3
} _INVPCID_DESCRIPTOR;

// 0x738 bytes (sizeof)
typedef struct _KUSER_SHARED_DATA {
  ULONG TickCountLowDeprecated;        // offset: 0x0 ordinal: 0x0
  ULONG TickCountMultiplier;           // offset: 0x4 ordinal: 0x1
  struct _KSYSTEM_TIME InterruptTime;  // offset: 0x8 ordinal: 0x2
  struct _KSYSTEM_TIME SystemTime;     // offset: 0x14 ordinal: 0x3
  struct _KSYSTEM_TIME TimeZoneBias;   // offset: 0x20 ordinal: 0x4
  USHORT ImageNumberLow;               // offset: 0x2c ordinal: 0x5
  USHORT ImageNumberHigh;              // offset: 0x2e ordinal: 0x6
  WCHAR NtSystemRoot[260];             // offset: 0x30 ordinal: 0x7
  ULONG MaxStackTraceDepth;            // offset: 0x238 ordinal: 0x8
  ULONG CryptoExponent;                // offset: 0x23c ordinal: 0x9
  ULONG TimeZoneId;                    // offset: 0x240 ordinal: 0xa
  ULONG LargePageMinimum;              // offset: 0x244 ordinal: 0xb
  ULONG AitSamplingValue;              // offset: 0x248 ordinal: 0xc
  ULONG AppCompatFlag;                 // offset: 0x24c ordinal: 0xd
  ULONGLONG RNGSeedVersion;            // offset: 0x250 ordinal: 0xe
  ULONG GlobalValidationRunlevel;      // offset: 0x258 ordinal: 0xf
  LONG TimeZoneBiasStamp;              // offset: 0x25c ordinal: 0x10
  ULONG NtBuildNumber;                 // offset: 0x260 ordinal: 0x11
  enum _NT_PRODUCT_TYPE NtProductType; // offset: 0x264 ordinal: 0x12
  UCHAR ProductTypeIsValid;            // offset: 0x268 ordinal: 0x13
  UCHAR Reserved0[1];                  // offset: 0x269 ordinal: 0x14
  USHORT NativeProcessorArchitecture;  // offset: 0x26a ordinal: 0x15
  ULONG NtMajorVersion;                // offset: 0x26c ordinal: 0x16
  ULONG NtMinorVersion;                // offset: 0x270 ordinal: 0x17
  UCHAR ProcessorFeatures[64];         // offset: 0x274 ordinal: 0x18
  ULONG Reserved1;                     // offset: 0x2b4 ordinal: 0x19
  ULONG Reserved3;                     // offset: 0x2b8 ordinal: 0x1a
  ULONG TimeSlip;                      // offset: 0x2bc ordinal: 0x1b
  enum _ALTERNATIVE_ARCHITECTURE_TYPE
      AlternativeArchitecture;               // offset: 0x2c0 ordinal: 0x1c
  ULONG BootId;                              // offset: 0x2c4 ordinal: 0x1d
  union _LARGE_INTEGER SystemExpirationDate; // offset: 0x2c8 ordinal: 0x1e
  ULONG SuiteMask;                           // offset: 0x2d0 ordinal: 0x1f
  UCHAR KdDebuggerEnabled;                   // offset: 0x2d4 ordinal: 0x20
  union {
    UCHAR MitigationPolicies;  // offset: 0x2d5 ordinal: 0x21
    UCHAR NXSupportPolicy : 2; // offset: 0x2d5 ordinal: 0x22
  };
  UCHAR SEHValidationPolicy : 2;         // offset: 0x2d5 ordinal: 0x23
  UCHAR CurDirDevicesSkippedForDlls : 2; // offset: 0x2d5 ordinal: 0x24
  UCHAR Reserved : 2;                    // offset: 0x2d5 ordinal: 0x25
  USHORT CyclesPerYield;                 // offset: 0x2d6 ordinal: 0x26
  ULONG ActiveConsoleId;                 // offset: 0x2d8 ordinal: 0x27
  ULONG DismountCount;                   // offset: 0x2dc ordinal: 0x28
  ULONG ComPlusPackage;                  // offset: 0x2e0 ordinal: 0x29
  ULONG LastSystemRITEventTickCount;     // offset: 0x2e4 ordinal: 0x2a
  ULONG NumberOfPhysicalPages;           // offset: 0x2e8 ordinal: 0x2b
  UCHAR SafeBootMode;                    // offset: 0x2ec ordinal: 0x2c
  UCHAR VirtualizationFlags;             // offset: 0x2ed ordinal: 0x2d
  UCHAR Reserved12[2];                   // offset: 0x2ee ordinal: 0x2e
  union {
    ULONG SharedDataFlags;         // offset: 0x2f0 ordinal: 0x2f
    ULONG DbgErrorPortPresent : 1; // offset: 0x2f0 ordinal: 0x30
  };
  ULONG DbgElevationEnabled : 1;       // offset: 0x2f0 ordinal: 0x31
  ULONG DbgVirtEnabled : 1;            // offset: 0x2f0 ordinal: 0x32
  ULONG DbgInstallerDetectEnabled : 1; // offset: 0x2f0 ordinal: 0x33
  ULONG DbgLkgEnabled : 1;             // offset: 0x2f0 ordinal: 0x34
  ULONG DbgDynProcessorEnabled : 1;    // offset: 0x2f0 ordinal: 0x35
  ULONG DbgConsoleBrokerEnabled : 1;   // offset: 0x2f0 ordinal: 0x36
  ULONG DbgSecureBootEnabled : 1;      // offset: 0x2f0 ordinal: 0x37
  ULONG DbgMultiSessionSku : 1;        // offset: 0x2f0 ordinal: 0x38
  ULONG DbgMultiUsersInSessionSku : 1; // offset: 0x2f0 ordinal: 0x39
  ULONG DbgStateSeparationEnabled : 1; // offset: 0x2f0 ordinal: 0x3a
  ULONG SpareBits : 21;                // offset: 0x2f0 ordinal: 0x3b
  ULONG DataFlagsPad[1];               // offset: 0x2f4 ordinal: 0x3c
  ULONGLONG TestRetInstruction;        // offset: 0x2f8 ordinal: 0x3d
  LONGLONG QpcFrequency;               // offset: 0x300 ordinal: 0x3e
  ULONG SystemCall;                    // offset: 0x308 ordinal: 0x3f
  ULONG Reserved2;                     // offset: 0x30c ordinal: 0x40
  ULONGLONG SystemCallPad[2];          // offset: 0x310 ordinal: 0x41
  union {
    struct _KSYSTEM_TIME TickCount;    // offset: 0x320 ordinal: 0x42
    ULONGLONG TickCountQuad;           // offset: 0x320 ordinal: 0x43
    ULONG ReservedTickCountOverlay[3]; // offset: 0x320 ordinal: 0x44
  };
  ULONG TickCountPad[1];                      // offset: 0x32c ordinal: 0x45
  ULONG Cookie;                               // offset: 0x330 ordinal: 0x46
  ULONG CookiePad[1];                         // offset: 0x334 ordinal: 0x47
  LONGLONG ConsoleSessionForegroundProcessId; // offset: 0x338 ordinal: 0x48
  ULONGLONG TimeUpdateLock;                   // offset: 0x340 ordinal: 0x49
  ULONGLONG BaselineSystemTimeQpc;            // offset: 0x348 ordinal: 0x4a
  ULONGLONG BaselineInterruptTimeQpc;         // offset: 0x350 ordinal: 0x4b
  ULONGLONG QpcSystemTimeIncrement;           // offset: 0x358 ordinal: 0x4c
  ULONGLONG QpcInterruptTimeIncrement;        // offset: 0x360 ordinal: 0x4d
  UCHAR QpcSystemTimeIncrementShift;          // offset: 0x368 ordinal: 0x4e
  UCHAR QpcInterruptTimeIncrementShift;       // offset: 0x369 ordinal: 0x4f
  USHORT UnparkedProcessorCount;              // offset: 0x36a ordinal: 0x50
  ULONG EnclaveFeatureMask[4];                // offset: 0x36c ordinal: 0x51
  ULONG TelemetryCoverageRound;               // offset: 0x37c ordinal: 0x52
  USHORT UserModeGlobalLogger[16];            // offset: 0x380 ordinal: 0x53
  ULONG ImageFileExecutionOptions;            // offset: 0x3a0 ordinal: 0x54
  ULONG LangGenerationCount;                  // offset: 0x3a4 ordinal: 0x55
  ULONGLONG Reserved4;                        // offset: 0x3a8 ordinal: 0x56
  ULONGLONG InterruptTimeBias;                // offset: 0x3b0 ordinal: 0x57
  ULONGLONG QpcBias;                          // offset: 0x3b8 ordinal: 0x58
  ULONG ActiveProcessorCount;                 // offset: 0x3c0 ordinal: 0x59
  UCHAR ActiveGroupCount;                     // offset: 0x3c4 ordinal: 0x5a
  UCHAR Reserved9;                            // offset: 0x3c5 ordinal: 0x5b
  union {
    USHORT QpcData;         // offset: 0x3c6 ordinal: 0x5c
    UCHAR QpcBypassEnabled; // offset: 0x3c6 ordinal: 0x5d
  };
  UCHAR QpcShift; // offset: 0x3c7 ordinal: 0x5e
  union _LARGE_INTEGER
      TimeZoneBiasEffectiveStart;                // offset: 0x3c8 ordinal: 0x5f
  union _LARGE_INTEGER TimeZoneBiasEffectiveEnd; // offset: 0x3d0 ordinal: 0x60
  struct _XSTATE_CONFIGURATION XState;           // offset: 0x3d8 ordinal: 0x61
  struct _KSYSTEM_TIME
      FeatureConfigurationChangeStamp; // offset: 0x720 ordinal: 0x62
  ULONG Spare;                         // offset: 0x72c ordinal: 0x63
  ULONGLONG UserPointerAuthMask;       // offset: 0x730 ordinal: 0x64
} _KUSER_SHARED_DATA;

// 0x30 bytes (sizeof)
typedef struct _MCUPDATE_INFO {
  struct _LIST_ENTRY List;    // offset: 0x0 ordinal: 0x0
  ULONG Status;               // offset: 0x10 ordinal: 0x1
  ULONGLONG Id;               // offset: 0x18 ordinal: 0x2
  ULONGLONG VendorScratch[2]; // offset: 0x20 ordinal: 0x3
} _MCUPDATE_INFO;

// 0x178 bytes (sizeof)
typedef struct _KPCR {
  union {
    struct _NT_TIB NtTib;        // offset: 0x0 ordinal: 0x0
    union _KGDTENTRY64 *GdtBase; // offset: 0x0 ordinal: 0x1
  };
  struct _KTSS64 *TssBase;             // offset: 0x8 ordinal: 0x2
  ULONGLONG UserRsp;                   // offset: 0x10 ordinal: 0x3
  struct _KPCR *Self;                  // offset: 0x18 ordinal: 0x4
  struct _KPRCB *CurrentPrcb;          // offset: 0x20 ordinal: 0x5
  struct _KSPIN_LOCK_QUEUE *LockArray; // offset: 0x28 ordinal: 0x6
  VOID *Used_Self;                     // offset: 0x30 ordinal: 0x7
  union _KIDTENTRY64 *IdtBase;         // offset: 0x38 ordinal: 0x8
  ULONGLONG Unused[2];                 // offset: 0x40 ordinal: 0x9
  UCHAR Irql;                          // offset: 0x50 ordinal: 0xa
  UCHAR SecondLevelCacheAssociativity; // offset: 0x51 ordinal: 0xb
  UCHAR ObsoleteNumber;                // offset: 0x52 ordinal: 0xc
  UCHAR Fill0;                         // offset: 0x53 ordinal: 0xd
  ULONG Unused0[3];                    // offset: 0x54 ordinal: 0xe
  USHORT MajorVersion;                 // offset: 0x60 ordinal: 0xf
  USHORT MinorVersion;                 // offset: 0x62 ordinal: 0x10
  ULONG StallScaleFactor;              // offset: 0x64 ordinal: 0x11
  VOID *Unused1[3];                    // offset: 0x68 ordinal: 0x12
  ULONG KernelReserved[15];            // offset: 0x80 ordinal: 0x13
  ULONG SecondLevelCacheSize;          // offset: 0xbc ordinal: 0x14
  ULONG HalReserved[16];               // offset: 0xc0 ordinal: 0x15
  ULONG Unused2;                       // offset: 0x100 ordinal: 0x16
  VOID *KdVersionBlock;                // offset: 0x108 ordinal: 0x17
  VOID *Unused3;                       // offset: 0x110 ordinal: 0x18
  ULONG PcrAlign1[24];                 // offset: 0x118 ordinal: 0x19
} _KPCR;

// 0x18 bytes (sizeof)
typedef struct _EVENT_PAYLOAD_PREDICATE {
  USHORT FieldIndex;  // offset: 0x0 ordinal: 0x0
  USHORT CompareOp;   // offset: 0x2 ordinal: 0x1
  ULONGLONG Value[2]; // offset: 0x8 ordinal: 0x2
} _EVENT_PAYLOAD_PREDICATE;

// 0x50 bytes (sizeof)
typedef struct _AGGREGATED_PAYLOAD_FILTER {
  USHORT MagicValue : 12;           // offset: 0x0 ordinal: 0x0
  USHORT DescriptorVersion : 4;     // offset: 0x0 ordinal: 0x1
  USHORT Size;                      // offset: 0x2 ordinal: 0x2
  USHORT PredicateCount;            // offset: 0x4 ordinal: 0x3
  USHORT Reserved;                  // offset: 0x6 ordinal: 0x4
  ULONGLONG HashedEventIdBitmap;    // offset: 0x8 ordinal: 0x5
  struct _GUID ProviderGuid;        // offset: 0x10 ordinal: 0x6
  USHORT EachEventTableOffset;      // offset: 0x20 ordinal: 0x7
  USHORT EachEventTableLength;      // offset: 0x22 ordinal: 0x8
  USHORT PayloadDecoderTableOffset; // offset: 0x24 ordinal: 0x9
  USHORT PayloadDecoderTableLength; // offset: 0x26 ordinal: 0xa
  USHORT EventFilterTableOffset;    // offset: 0x28 ordinal: 0xb
  USHORT EventFilterTableLength;    // offset: 0x2a ordinal: 0xc
  USHORT UNICODEStringTableOffset;  // offset: 0x2c ordinal: 0xd
  USHORT UNICODEStringTableLength;  // offset: 0x2e ordinal: 0xe
  USHORT ANSIStringTableOffset;     // offset: 0x30 ordinal: 0xf
  USHORT ANSIStringTableLength;     // offset: 0x32 ordinal: 0x10
  struct _EVENT_PAYLOAD_PREDICATE
      PredicateTable[1]; // offset: 0x38 ordinal: 0x11
} _AGGREGATED_PAYLOAD_FILTER;

// 0x58 bytes (sizeof)
typedef struct _ETW_PAYLOAD_FILTER {
  LONG RefCount;                                   // offset: 0x0 ordinal: 0x0
  struct _AGGREGATED_PAYLOAD_FILTER PayloadFilter; // offset: 0x8 ordinal: 0x1
} _ETW_PAYLOAD_FILTER;

// 0x68 bytes (sizeof)
typedef struct _ETW_FILTER_HEADER {
  LONG FilterFlags;                                 // offset: 0x0 ordinal: 0x0
  struct _ETW_FILTER_PID *PidFilter;                // offset: 0x8 ordinal: 0x1
  struct _ETW_FILTER_STRING_TOKEN *ExeFilter;       // offset: 0x10 ordinal: 0x2
  struct _ETW_FILTER_STRING_TOKEN *PkgIdFilter;     // offset: 0x18 ordinal: 0x3
  struct _ETW_FILTER_STRING_TOKEN *PkgAppIdFilter;  // offset: 0x20 ordinal: 0x4
  struct _ETW_FILTER_STRING_TOKEN *ContainerFilter; // offset: 0x28 ordinal: 0x5
  struct _ETW_PERFECT_HASH_FUNCTION
      *StackWalkIdFilter; // offset: 0x30 ordinal: 0x6
  struct _ETW_FILTER_EVENT_NAME_DATA
      *StackWalkNameFilter; // offset: 0x38 ordinal: 0x7
  struct _EVENT_FILTER_LEVEL_KW
      *StackWalkLevelKwFilter;                      // offset: 0x40 ordinal: 0x8
  struct _ETW_PERFECT_HASH_FUNCTION *EventIdFilter; // offset: 0x48 ordinal: 0x9
  struct _ETW_PAYLOAD_FILTER *PayloadFilter;        // offset: 0x50 ordinal: 0xa
  struct _EVENT_FILTER_HEADER *ProviderSideFilter;  // offset: 0x58 ordinal: 0xb
  struct _ETW_FILTER_EVENT_NAME_DATA
      *EventNameFilter; // offset: 0x60 ordinal: 0xc
} _ETW_FILTER_HEADER;

// 0x80 bytes (sizeof)
typedef struct _PNP_REBALANCE_TRACE_CONTEXT {
  ULONG DeviceCount[2];                   // offset: 0x0 ordinal: 0x0
  ULONG RebalancePhase;                   // offset: 0x8 ordinal: 0x1
  enum _PNP_REBALANCE_REASON Reason;      // offset: 0xc ordinal: 0x2
  enum _PNP_REBALANCE_FAILURE Failure[2]; // offset: 0x10 ordinal: 0x3
  struct _DEVICE_NODE *SubtreeRoot[2];    // offset: 0x18 ordinal: 0x4
  UCHAR SubtreeIncludesRoot[2];           // offset: 0x28 ordinal: 0x5
  struct _DEVICE_NODE *TriggerRoot;       // offset: 0x30 ordinal: 0x6
  union _PNP_REBALANCE_FLAGS Flags;       // offset: 0x38 ordinal: 0x7
  ULONGLONG BeginTime[2];                 // offset: 0x40 ordinal: 0x8
  struct _DEVICE_NODE *VetoNode[2];       // offset: 0x50 ordinal: 0x9
  enum _PNP_DEVNODE_QUERY_REBALANCE_VETO_REASON
      VetoQueryRebalanceReason[2]; // offset: 0x60 ordinal: 0xa
  struct _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT
      ConflictContext; // offset: 0x68 ordinal: 0xb
} _PNP_REBALANCE_TRACE_CONTEXT;

// 0x90 bytes (sizeof)
typedef struct _PROC_FEEDBACK {
  ULONGLONG Lock;                             // offset: 0x0 ordinal: 0x0
  ULONGLONG CyclesLast;                       // offset: 0x8 ordinal: 0x1
  ULONGLONG CyclesActive;                     // offset: 0x10 ordinal: 0x2
  struct _PROC_FEEDBACK_COUNTER *Counters[2]; // offset: 0x18 ordinal: 0x3
  ULONGLONG LastUpdateTime;                   // offset: 0x28 ordinal: 0x4
  ULONGLONG UnscaledTime;                     // offset: 0x30 ordinal: 0x5
  LONGLONG UnaccountedTime;                   // offset: 0x38 ordinal: 0x6
  ULONGLONG ScaledTime[2];                    // offset: 0x40 ordinal: 0x7
  ULONGLONG UnaccountedKernelTime;            // offset: 0x50 ordinal: 0x8
  ULONGLONG PerformanceScaledKernelTime;      // offset: 0x58 ordinal: 0x9
  ULONG UserTimeLast;                         // offset: 0x60 ordinal: 0xa
  ULONG KernelTimeLast;                       // offset: 0x64 ordinal: 0xb
  ULONGLONG IdleGenerationNumberLast;         // offset: 0x68 ordinal: 0xc
  ULONGLONG HvActiveTimeLast;                 // offset: 0x70 ordinal: 0xd
  ULONGLONG StallCyclesLast;                  // offset: 0x78 ordinal: 0xe
  ULONGLONG StallTime;                        // offset: 0x80 ordinal: 0xf
  UCHAR KernelTimesIndex;                     // offset: 0x88 ordinal: 0x10
  UCHAR CounterDiscardsIdleTime;              // offset: 0x89 ordinal: 0x11
  UCHAR CounterReadOptimize;                  // offset: 0x8a ordinal: 0x12
} _PROC_FEEDBACK;

// 0x18 bytes (sizeof)
typedef struct _KTIMER_TABLE_STATE {
  ULONGLONG LastTimerExpiration[2]; // offset: 0x0 ordinal: 0x0
  ULONG LastTimerHand[2];           // offset: 0x10 ordinal: 0x1
} _KTIMER_TABLE_STATE;

// 0x180 bytes (sizeof)
typedef struct _KSCHEDULER_SUBNODE {
  ULONGLONG SubNodeLock;             // offset: 0x0 ordinal: 0x0
  ULONGLONG IdleNonParkedCpuSet;     // offset: 0x8 ordinal: 0x1
  ULONGLONG IdleCpuSet;              // offset: 0x10 ordinal: 0x2
  ULONGLONG IdleSmtSet;              // offset: 0x18 ordinal: 0x3
  ULONGLONG IdleModuleSet;           // offset: 0x20 ordinal: 0x4
  ULONGLONG IdleIsolationUnitSet[2]; // offset: 0x10 ordinal: 0x5
  ULONGLONG NonPairedSmtSet;         // offset: 0x28 ordinal: 0x6
  ULONGLONG DeepIdleSet;             // offset: 0x40 ordinal: 0x7
  ULONGLONG IdleConstrainedSet;      // offset: 0x48 ordinal: 0x8
  ULONGLONG NonParkedSet;            // offset: 0x50 ordinal: 0x9
  ULONGLONG ParkRequestSet;          // offset: 0x58 ordinal: 0xa
  ULONGLONG SoftParkRequestSet;      // offset: 0x60 ordinal: 0xb
  ULONGLONG NonIsrTargetedSet;       // offset: 0x68 ordinal: 0xc
  LONG ParkLock;                     // offset: 0x70 ordinal: 0xd
  UCHAR ProcessSeed;                 // offset: 0x74 ordinal: 0xe
  UCHAR Spare5[3];                   // offset: 0x75 ordinal: 0xf
  union {
    struct _GROUP_AFFINITY Affinity; // offset: 0x80 ordinal: 0x10
    UCHAR AffinityFill[10];          // offset: 0x80 ordinal: 0x11
  };
  USHORT ParentNodeNumber;                   // offset: 0x8a ordinal: 0x12
  USHORT SubNodeNumber;                      // offset: 0x8c ordinal: 0x13
  USHORT Spare;                              // offset: 0x8e ordinal: 0x14
  ULONGLONG SiblingMask;                     // offset: 0x90 ordinal: 0x15
  ULONGLONG SharedReadyQueueMask;            // offset: 0x98 ordinal: 0x16
  ULONGLONG StrideMask;                      // offset: 0xa0 ordinal: 0x17
  ULONGLONG LLCLeaders;                      // offset: 0xa8 ordinal: 0x18
  ULONG Lowest;                              // offset: 0xb0 ordinal: 0x19
  ULONG Highest;                             // offset: 0xb4 ordinal: 0x1a
  struct _flags Flags;                       // offset: 0xb8 ordinal: 0x1b
  UCHAR WorkloadClasses;                     // offset: 0xb9 ordinal: 0x1c
  struct _KHETERO_PROCESSOR_SET *HeteroSets; // offset: 0xc0 ordinal: 0x1d
  ULONGLONG PpmConfiguredQosSets[7];         // offset: 0xc8 ordinal: 0x1e
  union _KQOS_GROUPING_SETS QosGroupingSets; // offset: 0x100 ordinal: 0x1f
  UCHAR SoftParkRanks[64];                   // offset: 0x140 ordinal: 0x20
} _KSCHEDULER_SUBNODE;

// 0x130 bytes (sizeof)
typedef struct _KNODE {
  USHORT NodeNumber;        // offset: 0x0 ordinal: 0x0
  USHORT PrimaryNodeNumber; // offset: 0x2 ordinal: 0x1
  ULONG ProximityId;        // offset: 0x4 ordinal: 0x2
  USHORT MaximumProcessors; // offset: 0x8 ordinal: 0x3
  struct __anon_2005 Flags; // offset: 0xa ordinal: 0x4
  UCHAR GroupSeed;          // offset: 0xb ordinal: 0x5
  UCHAR PrimaryGroup;       // offset: 0xc ordinal: 0x6
  UCHAR Padding[3];         // offset: 0xd ordinal: 0x7
  ULONG ActiveGroups;       // offset: 0x10 ordinal: 0x8
  struct _KSCHEDULER_SUBNODE
      *SchedulerSubNodes[32];      // offset: 0x18 ordinal: 0x9
  ULONG ActiveTopologyElements[5]; // offset: 0x118 ordinal: 0xa
} _KNODE;

// 0x180 bytes (sizeof)
typedef struct _ENODE {
  struct _KNODE Ncb;                               // offset: 0x0 ordinal: 0x0
  struct _WORK_QUEUE_ITEM HotAddProcessorWorkItem; // offset: 0x130 ordinal: 0x1
} _ENODE;

// 0x2e0 bytes (sizeof)
typedef struct _EX_WORK_QUEUE {
  struct _KPRIQUEUE WorkPriQueue;        // offset: 0x0 ordinal: 0x0
  struct _EX_PARTITION *Partition;       // offset: 0x2b0 ordinal: 0x1
  struct _ENODE *Node;                   // offset: 0x2b8 ordinal: 0x2
  ULONG WorkItemsProcessed;              // offset: 0x2c0 ordinal: 0x3
  ULONG WorkItemsProcessedLastPass;      // offset: 0x2c4 ordinal: 0x4
  LONG ThreadCount;                      // offset: 0x2c8 ordinal: 0x5
  LONG MinThreads : 31;                  // offset: 0x2cc ordinal: 0x6
  ULONG TryFailed : 1;                   // offset: 0x2cc ordinal: 0x7
  LONG MaxThreads;                       // offset: 0x2d0 ordinal: 0x8
  enum _EXQUEUEINDEX QueueIndex;         // offset: 0x2d4 ordinal: 0x9
  struct _KEVENT *AllThreadsExitedEvent; // offset: 0x2d8 ordinal: 0xa
} _EX_WORK_QUEUE;

// 0x700 bytes (sizeof)
typedef struct _KPRCB {
  ULONG MxCsr;                    // offset: 0x0 ordinal: 0x0
  UCHAR LegacyNumber;             // offset: 0x4 ordinal: 0x1
  UCHAR ReservedMustBeZero;       // offset: 0x5 ordinal: 0x2
  UCHAR InterruptRequest;         // offset: 0x6 ordinal: 0x3
  UCHAR IdleHalt;                 // offset: 0x7 ordinal: 0x4
  struct _KTHREAD *CurrentThread; // offset: 0x8 ordinal: 0x5
  struct _KTHREAD *NextThread;    // offset: 0x10 ordinal: 0x6
  struct _KTHREAD *IdleThread;    // offset: 0x18 ordinal: 0x7
  UCHAR NestingLevel;             // offset: 0x20 ordinal: 0x8
  UCHAR ClockOwner;               // offset: 0x21 ordinal: 0x9
  union {
    UCHAR PendingTickFlags; // offset: 0x22 ordinal: 0xa
    UCHAR PendingTick : 1;  // offset: 0x22 ordinal: 0xb
  };
  UCHAR PendingBackupTick : 1;           // offset: 0x22 ordinal: 0xc
  UCHAR IdleState;                       // offset: 0x23 ordinal: 0xd
  ULONG Number;                          // offset: 0x24 ordinal: 0xe
  ULONGLONG RspBase;                     // offset: 0x28 ordinal: 0xf
  ULONGLONG PrcbLock;                    // offset: 0x30 ordinal: 0x10
  union _KPRIORITY_STATE *PriorityState; // offset: 0x38 ordinal: 0x11
  CHAR CpuType;                          // offset: 0x40 ordinal: 0x12
  CHAR CpuID;                            // offset: 0x41 ordinal: 0x13
  union {
    USHORT CpuStep;    // offset: 0x42 ordinal: 0x14
    UCHAR CpuStepping; // offset: 0x42 ordinal: 0x15
  };
  UCHAR CpuModel;                               // offset: 0x43 ordinal: 0x16
  ULONG MHz;                                    // offset: 0x44 ordinal: 0x17
  ULONGLONG HalReserved[8];                     // offset: 0x48 ordinal: 0x18
  USHORT MinorVersion;                          // offset: 0x88 ordinal: 0x19
  USHORT MajorVersion;                          // offset: 0x8a ordinal: 0x1a
  UCHAR BuildType;                              // offset: 0x8c ordinal: 0x1b
  UCHAR CpuVendor;                              // offset: 0x8d ordinal: 0x1c
  UCHAR LegacyCoresPerPhysicalProcessor;        // offset: 0x8e ordinal: 0x1d
  UCHAR LegacyLogicalProcessorsPerCore;         // offset: 0x8f ordinal: 0x1e
  ULONGLONG TscFrequency;                       // offset: 0x90 ordinal: 0x1f
  struct _KPRCB_TRACEPOINT_LOG *TracepointLog;  // offset: 0x98 ordinal: 0x20
  ULONG CoresPerPhysicalProcessor;              // offset: 0xa0 ordinal: 0x21
  ULONG LogicalProcessorsPerCore;               // offset: 0xa4 ordinal: 0x22
  ULONGLONG PrcbPad04[3];                       // offset: 0xa8 ordinal: 0x23
  struct _KSCHEDULER_SUBNODE *SchedulerSubNode; // offset: 0xc0 ordinal: 0x24
  ULONGLONG GroupSetMember;                     // offset: 0xc8 ordinal: 0x25
  UCHAR Group;                                  // offset: 0xd0 ordinal: 0x26
  UCHAR GroupIndex;                             // offset: 0xd1 ordinal: 0x27
  UCHAR PrcbPad05[2];                           // offset: 0xd2 ordinal: 0x28
  ULONG InitialApicId;                          // offset: 0xd4 ordinal: 0x29
  ULONG ScbOffset;                              // offset: 0xd8 ordinal: 0x2a
  ULONG ApicMask;                               // offset: 0xdc ordinal: 0x2b
  VOID *AcpiReserved;                           // offset: 0xe0 ordinal: 0x2c
  ULONG CFlushSize;                             // offset: 0xe8 ordinal: 0x2d
  ULONGLONG PrcbPad11[2];                       // offset: 0xf0 ordinal: 0x2e
  struct _KPROCESSOR_STATE ProcessorState;      // offset: 0x100 ordinal: 0x2f
  struct _XSAVE_AREA_HEADER
      *ExtendedSupervisorState; // offset: 0x6c0 ordinal: 0x30
  ULONG ProcessorSignature;     // offset: 0x6c8 ordinal: 0x31
  ULONG ProcessorFlags;         // offset: 0x6cc ordinal: 0x32
  ULONGLONG PrcbPad12a;         // offset: 0x6d0 ordinal: 0x33
  ULONGLONG PrcbPad12[3];       // offset: 0x6d8 ordinal: 0x34
} _KPRCB;

// 0x110 bytes (sizeof)
typedef struct _PROCESS_ENERGY_VALUES {
  ULONGLONG Cycles[4][2];      // offset: 0x0 ordinal: 0x0
  ULONGLONG DiskEnergy;        // offset: 0x40 ordinal: 0x1
  ULONGLONG NetworkTailEnergy; // offset: 0x48 ordinal: 0x2
  ULONGLONG MBBTailEnergy;     // offset: 0x50 ordinal: 0x3
  ULONGLONG NetworkTxRxBytes;  // offset: 0x58 ordinal: 0x4
  ULONGLONG MBBTxRxBytes;      // offset: 0x60 ordinal: 0x5
  union {
    union _ENERGY_STATE_DURATION Durations[3]; // offset: 0x68 ordinal: 0x6
    union _ENERGY_STATE_DURATION
        ForegroundDuration; // offset: 0x68 ordinal: 0x7
  };
  union _ENERGY_STATE_DURATION
      DesktopVisibleDuration; // offset: 0x70 ordinal: 0x8
  union _ENERGY_STATE_DURATION
      PSMForegroundDuration;          // offset: 0x78 ordinal: 0x9
  ULONG CompositionRendered;          // offset: 0x80 ordinal: 0xa
  ULONG CompositionDirtyGenerated;    // offset: 0x84 ordinal: 0xb
  ULONG CompositionDirtyPropagated;   // offset: 0x88 ordinal: 0xc
  ULONG Reserved1;                    // offset: 0x8c ordinal: 0xd
  ULONGLONG AttributedCycles[4][2];   // offset: 0x90 ordinal: 0xe
  ULONGLONG WorkOnBehalfCycles[4][2]; // offset: 0xd0 ordinal: 0xf
} _PROCESS_ENERGY_VALUES;

// 0x1b0 bytes (sizeof)
typedef struct _PROCESS_EXTENDED_ENERGY_VALUES {
  struct _PROCESS_ENERGY_VALUES Base; // offset: 0x0 ordinal: 0x0
  struct _PROCESS_ENERGY_VALUES_EXTENSION
      Extension; // offset: 0x110 ordinal: 0x1
} _PROCESS_EXTENDED_ENERGY_VALUES;

// 0xc8 bytes (sizeof)
typedef struct _THREAD_ENERGY_VALUES {
  ULONGLONG Cycles[4][2];             // offset: 0x0 ordinal: 0x0
  ULONGLONG AttributedCycles[4][2];   // offset: 0x40 ordinal: 0x1
  ULONGLONG WorkOnBehalfCycles[4][2]; // offset: 0x80 ordinal: 0x2
  union _TIMELINE_BITMAP CpuTimeline; // offset: 0xc0 ordinal: 0x3
} _THREAD_ENERGY_VALUES;

// 0x8 bytes (sizeof)
typedef struct _EX_RUNDOWN_REF {
  union {
    ULONGLONG Count; // offset: 0x0 ordinal: 0x0
    VOID *Ptr;       // offset: 0x0 ordinal: 0x1
  };
} _EX_RUNDOWN_REF;

// 0x60 bytes (sizeof)
typedef struct _PF_KERNEL_GLOBALS {
  ULONGLONG AccessBufferAgeThreshold;     // offset: 0x0 ordinal: 0x0
  struct _EX_RUNDOWN_REF AccessBufferRef; // offset: 0x8 ordinal: 0x1
  struct _KEVENT AccessBufferExistsEvent; // offset: 0x10 ordinal: 0x2
  ULONG AccessBufferMax;                  // offset: 0x28 ordinal: 0x3
  union _SLIST_HEADER AccessBufferList;   // offset: 0x40 ordinal: 0x4
  LONG StreamSequenceNumber;              // offset: 0x50 ordinal: 0x5
  ULONG Flags;                            // offset: 0x54 ordinal: 0x6
  LONG ScenarioPrefetchCount;             // offset: 0x58 ordinal: 0x7
} _PF_KERNEL_GLOBALS;

// 0x18 bytes (sizeof)
typedef struct _EX_RUNDOWN_REF_CACHE_AWARE {
  struct _EX_RUNDOWN_REF *RunRefs; // offset: 0x0 ordinal: 0x0
  VOID *PoolToFree;                // offset: 0x8 ordinal: 0x1
  ULONG RunRefSize;                // offset: 0x10 ordinal: 0x2
  ULONG Number;                    // offset: 0x14 ordinal: 0x3
} _EX_RUNDOWN_REF_CACHE_AWARE;

// 0x38 bytes (sizeof)
typedef struct _PS_IO_CONTROL_ENTRY {
  union {
    struct _RTL_BALANCED_NODE VolumeTreeNode; // offset: 0x0 ordinal: 0x0
    struct _LIST_ENTRY FreeListEntry;         // offset: 0x0 ordinal: 0x1
  };
  ULONGLONG ReservedForParentValue; // offset: 0x10 ordinal: 0x2
  ULONGLONG VolumeKey;              // offset: 0x18 ordinal: 0x3
  struct _EX_RUNDOWN_REF Rundown;   // offset: 0x20 ordinal: 0x4
  VOID *IoControl;                  // offset: 0x28 ordinal: 0x5
  VOID *VolumeIoAttribution;        // offset: 0x30 ordinal: 0x6
} _PS_IO_CONTROL_ENTRY;

// 0x8 bytes (sizeof)
typedef struct _EX_PUSH_LOCK {
  ULONGLONG Locked : 1;         // offset: 0x0 ordinal: 0x0
  ULONGLONG Waiting : 1;        // offset: 0x0 ordinal: 0x1
  ULONGLONG Waking : 1;         // offset: 0x0 ordinal: 0x2
  ULONGLONG MultipleShared : 1; // offset: 0x0 ordinal: 0x3
  ULONGLONG Shared : 60;        // offset: 0x0 ordinal: 0x4
  union {
    ULONGLONG Value; // offset: 0x0 ordinal: 0x5
    VOID *Ptr;       // offset: 0x0 ordinal: 0x6
  };
} _EX_PUSH_LOCK;

// 0x30 bytes (sizeof)
typedef struct _MAPPED_FILE_SEGMENT {
  struct _CONTROL_AREA *ControlArea;  // offset: 0x0 ordinal: 0x0
  ULONG TotalNumberOfPtes;            // offset: 0x8 ordinal: 0x1
  struct _SEGMENT_FLAGS SegmentFlags; // offset: 0xc ordinal: 0x2
  ULONGLONG NumberOfCommittedPages;   // offset: 0x10 ordinal: 0x3
  ULONGLONG SizeOfSegment;            // offset: 0x18 ordinal: 0x4
  union {
    struct _MMEXTEND_INFO *ExtendInfo; // offset: 0x20 ordinal: 0x5
    VOID *BasedAddress;                // offset: 0x20 ordinal: 0x6
  };
  struct _EX_PUSH_LOCK SegmentLock; // offset: 0x28 ordinal: 0x7
} _MAPPED_FILE_SEGMENT;

// 0x28 bytes (sizeof)
typedef struct _SEP_LOWBOX_NUMBER_MAPPING {
  struct _EX_PUSH_LOCK Lock;                 // offset: 0x0 ordinal: 0x0
  struct _RTL_BITMAP Bitmap;                 // offset: 0x8 ordinal: 0x1
  struct _RTL_DYNAMIC_HASH_TABLE *HashTable; // offset: 0x18 ordinal: 0x2
  UCHAR Active;                              // offset: 0x20 ordinal: 0x3
} _SEP_LOWBOX_NUMBER_MAPPING;

// 0x40 bytes (sizeof)
typedef struct _SESSION_LOWBOX_MAP {
  struct _LIST_ENTRY ListEntry;                // offset: 0x0 ordinal: 0x0
  ULONG SessionId;                             // offset: 0x10 ordinal: 0x1
  struct _SEP_LOWBOX_NUMBER_MAPPING LowboxMap; // offset: 0x18 ordinal: 0x2
} _SESSION_LOWBOX_MAP;

// 0x60 bytes (sizeof)
typedef struct _PNP_DEVICE_ACTION_ENTRY {
  struct _LIST_ENTRY ListEntry;                // offset: 0x0 ordinal: 0x0
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x10 ordinal: 0x1
  enum _PNP_DEVICE_ACTION_REQUEST RequestType; // offset: 0x18 ordinal: 0x2
  UCHAR ReorderingBarrier;                     // offset: 0x1c ordinal: 0x3
  union _PNP_DEVICE_ACTION_REQUEST_ARGUMENT
      RequestArgument;             // offset: 0x20 ordinal: 0x4
  struct _KEVENT *CompletionEvent; // offset: 0x28 ordinal: 0x5
  LONG *CompletionStatus;          // offset: 0x30 ordinal: 0x6
  struct _GUID ActivityId;         // offset: 0x38 ordinal: 0x7
  LONG RefCount;                   // offset: 0x48 ordinal: 0x8
  UCHAR Dequeued;                  // offset: 0x4c ordinal: 0x9
  struct _EX_PUSH_LOCK CancelLock; // offset: 0x50 ordinal: 0xa
  UCHAR CancelRequested;           // offset: 0x58 ordinal: 0xb
} _PNP_DEVICE_ACTION_ENTRY;

// 0x28 bytes (sizeof)
typedef struct _RTL_ATOM_TABLE {
  ULONG Signature;                          // offset: 0x0 ordinal: 0x0
  LONG ReferenceCount;                      // offset: 0x4 ordinal: 0x1
  struct _EX_PUSH_LOCK PushLock;            // offset: 0x8 ordinal: 0x2
  struct _HANDLE_TABLE *ExHandleTable;      // offset: 0x10 ordinal: 0x3
  ULONG Flags;                              // offset: 0x18 ordinal: 0x4
  ULONG NumberOfBuckets;                    // offset: 0x1c ordinal: 0x5
  struct _RTL_ATOM_TABLE_ENTRY *Buckets[1]; // offset: 0x20 ordinal: 0x6
} _RTL_ATOM_TABLE;

// 0x48 bytes (sizeof)
typedef struct _MI_ENCLAVE_STATE {
  struct _RTL_AVL_TREE EnclaveRegions;           // offset: 0x0 ordinal: 0x0
  VOID *EnclaveMetadataPage;                     // offset: 0x8 ordinal: 0x1
  struct _RTL_BITMAP *EnclaveMetadataBitMap;     // offset: 0x10 ordinal: 0x2
  struct _EX_PUSH_LOCK EnclaveMetadataEntryLock; // offset: 0x18 ordinal: 0x3
  LONG EnclaveMetadataPageLock;                  // offset: 0x20 ordinal: 0x4
  struct _LIST_ENTRY EnclaveList;                // offset: 0x28 ordinal: 0x5
  struct _EX_PUSH_LOCK EnclaveListLock;          // offset: 0x38 ordinal: 0x6
  struct _EX_RUNDOWN_REF ShutdownRundown;        // offset: 0x40 ordinal: 0x7
} _MI_ENCLAVE_STATE;

// 0x1280 bytes (sizeof)
typedef struct _MI_SYSTEM_PTE_STATE {
  struct _NPAGED_LOOKASIDE_LIST MdlTrackerLookaside; // offset: 0x0 ordinal: 0x0
  union _SLIST_HEADER DeadPteTrackerSListHead;  // offset: 0x80 ordinal: 0x1
  ULONGLONG PteTrackerLock;                     // offset: 0x90 ordinal: 0x2
  struct _RTL_BITMAP_EX PteTrackingBitmap;      // offset: 0x98 ordinal: 0x3
  struct _MI_CACHED_PTES *CachedPteHeads;       // offset: 0xa8 ordinal: 0x4
  struct _MI_SYSTEM_PTE_TYPE SystemViewPteInfo; // offset: 0xb0 ordinal: 0x5
  struct _MI_SYSTEM_PTE_TYPE
      KernelStackPteInfo[2];                      // offset: 0x108 ordinal: 0x6
  ULONG StackGrowthFailures;                      // offset: 0x1b8 ordinal: 0x7
  UCHAR KernelStackPages;                         // offset: 0x1bc ordinal: 0x8
  UCHAR TrackPtesAborted;                         // offset: 0x1bd ordinal: 0x9
  UCHAR AdjustCounter;                            // offset: 0x1be ordinal: 0xa
  LONG ReservedMappingLock;                       // offset: 0x1c0 ordinal: 0xb
  struct _RTL_AVL_TREE ReservedMappingTree;       // offset: 0x1c8 ordinal: 0xc
  struct _MMPFN *ReservedMappingPageTablePfns;    // offset: 0x1d0 ordinal: 0xd
  struct _RTL_AVL_TREE OutswappedKernelStackRoot; // offset: 0x1d8 ordinal: 0xe
  LONG OutswappedKernelStackLock;                 // offset: 0x1e0 ordinal: 0xf
  struct _MMPTE *BreakMakePte;                    // offset: 0x1e8 ordinal: 0x10
  struct _MI_ULTRA_VA_CONTEXT UltraSpaceContext;  // offset: 0x1f0 ordinal: 0x11
  ULONG NumberOfUltraMdlMaps;                     // offset: 0x230 ordinal: 0x12
  struct _MI_ULTRA_MDL_NODE
      *UltraMdlNodeMappings;                // offset: 0x238 ordinal: 0x13
  struct _EX_PUSH_LOCK SystemSpaceViewLock; // offset: 0x240 ordinal: 0x14
  struct _RTL_AVL_TREE ViewRoot;            // offset: 0x248 ordinal: 0x15
  ULONG ViewCount;                          // offset: 0x250 ordinal: 0x16
  UCHAR CodePageEdited;                     // offset: 0x254 ordinal: 0x17
  struct _MI_HUGE_SYSTEM_VIEW_HEAD
      SystemViewBuckets[256]; // offset: 0x258 ordinal: 0x18
} _MI_SYSTEM_PTE_STATE;

// 0x110 bytes (sizeof)
typedef struct _MI_SYSTEM_IMAGE_STATE {
  struct _LIST_ENTRY FixupList;                 // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK LoadLock;                // offset: 0x10 ordinal: 0x1
  struct _ETHREAD *LoadLockOwner;               // offset: 0x18 ordinal: 0x2
  ULONG LoadLockCount;                          // offset: 0x20 ordinal: 0x3
  LONG FixupLock;                               // offset: 0x24 ordinal: 0x4
  struct _EX_PUSH_LOCK EncodeDecodeLock;        // offset: 0x28 ordinal: 0x5
  ULONG EncodeDecodeDepth;                      // offset: 0x30 ordinal: 0x6
  UCHAR FirstLoadEver;                          // offset: 0x34 ordinal: 0x7
  UCHAR LargePageAll;                           // offset: 0x35 ordinal: 0x8
  UCHAR SystemImagesLoaded;                     // offset: 0x36 ordinal: 0x9
  struct _LIST_ENTRY LargePageList;             // offset: 0x38 ordinal: 0xa
  struct _LIST_ENTRY StrongCodeLoadFailureList; // offset: 0x48 ordinal: 0xb
  struct _KLDR_DATA_TABLE_ENTRY *SystemBase[1]; // offset: 0x58 ordinal: 0xc
  struct _RTL_BITMAP_EX
      BaseImageDiscardedBitmaps[1];              // offset: 0x60 ordinal: 0xd
  struct _KLDR_DATA_TABLE_ENTRY *BeingDeleted;   // offset: 0x70 ordinal: 0xe
  struct _EX_PUSH_LOCK MappingRangesPushLock;    // offset: 0x78 ordinal: 0xf
  struct _MI_DRIVER_VA *MappingRanges[2];        // offset: 0x80 ordinal: 0x10
  struct _MM_SYSTEM_PAGE_COUNTS PageCounts;      // offset: 0x90 ordinal: 0x11
  struct _EX_PUSH_LOCK CollidedLock;             // offset: 0xa0 ordinal: 0x12
  struct _RTL_AVL_TREE ImageTree;                // offset: 0xa8 ordinal: 0x13
  struct _KLDR_DATA_TABLE_ENTRY *LoadInProgress; // offset: 0xb0 ordinal: 0x14
  ULONGLONG ImportEntriesReplaced;               // offset: 0xb8 ordinal: 0x15
  struct _RTL_FUNCTION_OVERRIDE_CAPABILITIES
      FunctionOverrideCapabilities; // offset: 0xc0 ordinal: 0x16
} _MI_SYSTEM_IMAGE_STATE;

// 0x18 bytes (sizeof)
typedef struct _MM_PAGED_POOL_INFO {
  struct _EX_PUSH_LOCK Lock;    // offset: 0x0 ordinal: 0x0
  ULONGLONG MaximumSize;        // offset: 0x8 ordinal: 0x1
  ULONGLONG AllocatedPagedPool; // offset: 0x10 ordinal: 0x2
} _MM_PAGED_POOL_INFO;

// 0xd00 bytes (sizeof)
typedef struct _MI_VISIBLE_STATE {
  struct _LIST_ENTRY SessionWsList;           // offset: 0x0 ordinal: 0x0
  struct _RTL_BITMAP *SessionIdBitmap;        // offset: 0x10 ordinal: 0x1
  struct _MM_PAGED_POOL_INFO PagedPoolInfo;   // offset: 0x18 ordinal: 0x2
  ULONGLONG MaximumNonPagedPoolInPages;       // offset: 0x30 ordinal: 0x3
  ULONGLONG SizeOfPagedPoolInPages;           // offset: 0x38 ordinal: 0x4
  struct _MI_SYSTEM_PTE_TYPE SystemPteInfo;   // offset: 0x40 ordinal: 0x5
  ULONGLONG NonPagedPoolCommit;               // offset: 0x98 ordinal: 0x6
  ULONGLONG SmallNonPagedPtesCommit;          // offset: 0xa0 ordinal: 0x7
  ULONGLONG BootCommit;                       // offset: 0xa8 ordinal: 0x8
  ULONGLONG MdlPagesAllocated;                // offset: 0xb0 ordinal: 0x9
  ULONGLONG ContiguousPagesAllocated;         // offset: 0xb8 ordinal: 0xa
  ULONGLONG SystemPageTableCommit;            // offset: 0xc0 ordinal: 0xb
  ULONGLONG ProcessCommit;                    // offset: 0xc8 ordinal: 0xc
  LONG DriverCommit;                          // offset: 0xd0 ordinal: 0xd
  UCHAR PagingLevels;                         // offset: 0xd4 ordinal: 0xe
  ULONGLONG PfnDatabaseCommit;                // offset: 0xd8 ordinal: 0xf
  struct _MMSUPPORT_FULL SystemWs[6];         // offset: 0x100 ordinal: 0x10
  struct _MMSUPPORT_SHARED SystemCacheShared; // offset: 0x880 ordinal: 0x11
  struct _MMSUPPORT_AGGREGATION
      AggregateSystemWs[1];         // offset: 0x900 ordinal: 0x12
  ULONG MapCacheFailures;           // offset: 0x920 ordinal: 0x13
  ULONGLONG PagefileHashPages;      // offset: 0x928 ordinal: 0x14
  struct _SYSPTES_HEADER PteHeader; // offset: 0x930 ordinal: 0x15
  ULONGLONG SystemVaTypeCount[18];  // offset: 0xa48 ordinal: 0x16
  UCHAR SystemVaType[256];          // offset: 0xad8 ordinal: 0x17
  struct _MI_SYSTEM_VA_ASSIGNMENT
      SystemVaRegions[15]; // offset: 0xbd8 ordinal: 0x18
} _MI_VISIBLE_STATE;

// 0x38 bytes (sizeof)
typedef struct _OBJECT_HEADER {
  LONGLONG PointerCount; // offset: 0x0 ordinal: 0x0
  union {
    LONGLONG HandleCount; // offset: 0x8 ordinal: 0x1
    VOID *NextToFree;     // offset: 0x8 ordinal: 0x2
  };
  struct _EX_PUSH_LOCK Lock; // offset: 0x10 ordinal: 0x3
  UCHAR TypeIndex;           // offset: 0x18 ordinal: 0x4
  union {
    UCHAR TraceFlags;      // offset: 0x19 ordinal: 0x5
    UCHAR DbgRefTrace : 1; // offset: 0x19 ordinal: 0x6
  };
  UCHAR DbgTracePermanent : 1; // offset: 0x19 ordinal: 0x7
  UCHAR InfoMask;              // offset: 0x1a ordinal: 0x8
  union {
    UCHAR Flags;         // offset: 0x1b ordinal: 0x9
    UCHAR NewObject : 1; // offset: 0x1b ordinal: 0xa
  };
  UCHAR KernelObject : 1;         // offset: 0x1b ordinal: 0xb
  UCHAR KernelOnlyAccess : 1;     // offset: 0x1b ordinal: 0xc
  UCHAR ExclusiveObject : 1;      // offset: 0x1b ordinal: 0xd
  UCHAR PermanentObject : 1;      // offset: 0x1b ordinal: 0xe
  UCHAR DefaultSecurityQuota : 1; // offset: 0x1b ordinal: 0xf
  UCHAR SingleHandleEntry : 1;    // offset: 0x1b ordinal: 0x10
  UCHAR DeletedInline : 1;        // offset: 0x1b ordinal: 0x11
  ULONG Reserved;                 // offset: 0x1c ordinal: 0x12
  union {
    struct _OBJECT_CREATE_INFORMATION
        *ObjectCreateInfo;   // offset: 0x20 ordinal: 0x13
    VOID *QuotaBlockCharged; // offset: 0x20 ordinal: 0x14
  };
  VOID *SecurityDescriptor; // offset: 0x28 ordinal: 0x15
  struct _QUAD Body;        // offset: 0x30 ordinal: 0x16
} _OBJECT_HEADER;

// 0x28 bytes (sizeof)
typedef struct _OBJECT_REF_INFO {
  struct _OBJECT_HEADER *ObjectHeader;        // offset: 0x0 ordinal: 0x0
  VOID *NextRef;                              // offset: 0x8 ordinal: 0x1
  UCHAR ImageFileName[16];                    // offset: 0x10 ordinal: 0x2
  USHORT NextPos;                             // offset: 0x20 ordinal: 0x3
  USHORT MaxStacks;                           // offset: 0x22 ordinal: 0x4
  struct _OBJECT_REF_STACK_INFO StackInfo[0]; // offset: 0x24 ordinal: 0x5
} _OBJECT_REF_INFO;

// 0x110 bytes (sizeof)
typedef struct _DUMMY_FILE_OBJECT {
  struct _OBJECT_HEADER ObjectHeader; // offset: 0x0 ordinal: 0x0
  CHAR FileObjectBody[216];           // offset: 0x38 ordinal: 0x1
} _DUMMY_FILE_OBJECT;

// 0xe0 bytes (sizeof)
typedef struct _OPEN_PACKET {
  SHORT Type;                      // offset: 0x0 ordinal: 0x0
  SHORT Size;                      // offset: 0x2 ordinal: 0x1
  struct _FILE_OBJECT *FileObject; // offset: 0x8 ordinal: 0x2
  LONG FinalStatus;                // offset: 0x10 ordinal: 0x3
  ULONGLONG Information;           // offset: 0x18 ordinal: 0x4
  ULONG ParseCheck;                // offset: 0x20 ordinal: 0x5
  union {
    struct _FILE_OBJECT *RelatedFileObject;        // offset: 0x28 ordinal: 0x6
    struct _DEVICE_OBJECT *ReferencedDeviceObject; // offset: 0x28 ordinal: 0x7
  };
  struct _OBJECT_ATTRIBUTES *OriginalAttributes; // offset: 0x30 ordinal: 0x8
  union _LARGE_INTEGER AllocationSize;           // offset: 0x38 ordinal: 0x9
  ULONG CreateOptions;                           // offset: 0x40 ordinal: 0xa
  USHORT FileAttributes;                         // offset: 0x44 ordinal: 0xb
  USHORT ShareAccess;                            // offset: 0x46 ordinal: 0xc
  VOID *EaBuffer;                                // offset: 0x48 ordinal: 0xd
  ULONG EaLength;                                // offset: 0x50 ordinal: 0xe
  ULONG Options;                                 // offset: 0x54 ordinal: 0xf
  ULONG Disposition;                             // offset: 0x58 ordinal: 0x10
  struct _FILE_BASIC_INFORMATION
      *BasicInformation; // offset: 0x60 ordinal: 0x11
  struct _FILE_NETWORK_OPEN_INFORMATION
      *NetworkInformation;                    // offset: 0x68 ordinal: 0x12
  VOID *FileInformation;                      // offset: 0x70 ordinal: 0x13
  enum _CREATE_FILE_TYPE CreateFileType;      // offset: 0x78 ordinal: 0x14
  VOID *MailslotOrPipeParameters;             // offset: 0x80 ordinal: 0x15
  UCHAR Override;                             // offset: 0x88 ordinal: 0x16
  UCHAR QueryOnly;                            // offset: 0x89 ordinal: 0x17
  UCHAR DeleteOnly;                           // offset: 0x8a ordinal: 0x18
  UCHAR FullAttributes;                       // offset: 0x8b ordinal: 0x19
  struct _DUMMY_FILE_OBJECT *LocalFileObject; // offset: 0x90 ordinal: 0x1a
  ULONG InternalFlags;                        // offset: 0x98 ordinal: 0x1b
  CHAR AccessMode;                            // offset: 0x9c ordinal: 0x1c
  struct _IO_DRIVER_CREATE_CONTEXT
      DriverCreateContext; // offset: 0xa0 ordinal: 0x1d
  enum _FILE_INFORMATION_CLASS
      FileInformationClass;     // offset: 0xc8 ordinal: 0x1e
  ULONG FileInformationLength;  // offset: 0xcc ordinal: 0x1f
  UCHAR FilterQuery;            // offset: 0xd0 ordinal: 0x20
  LONGLONG ExtendedCreateFlags; // offset: 0xd8 ordinal: 0x21
} _OPEN_PACKET;

// 0x20 bytes (sizeof)
typedef struct _ALPC_HANDLE_TABLE {
  struct _ALPC_HANDLE_ENTRY *Handles; // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK Lock;          // offset: 0x8 ordinal: 0x1
  ULONGLONG TotalHandles;             // offset: 0x10 ordinal: 0x2
  ULONG Flags;                        // offset: 0x18 ordinal: 0x3
} _ALPC_HANDLE_TABLE;

// 0x30 bytes (sizeof)
typedef struct _BLOB {
  union {
    struct _LIST_ENTRY ResourceList;   // offset: 0x0 ordinal: 0x0
    struct _SLIST_ENTRY FreeListEntry; // offset: 0x0 ordinal: 0x1
  };
  union __anon_2856 u1;      // offset: 0x10 ordinal: 0x2
  UCHAR ResourceId;          // offset: 0x11 ordinal: 0x3
  SHORT CachedReferences;    // offset: 0x12 ordinal: 0x4
  LONGLONG ReferenceCount;   // offset: 0x18 ordinal: 0x5
  struct _EX_PUSH_LOCK Lock; // offset: 0x20 ordinal: 0x6
} _BLOB;

// 0x18 bytes (sizeof)
typedef struct _CM_KEY_HASH_TABLE_ENTRY {
  struct _EX_PUSH_LOCK Lock;  // offset: 0x0 ordinal: 0x0
  struct _KTHREAD *Owner;     // offset: 0x8 ordinal: 0x1
  struct _CM_KEY_HASH *Entry; // offset: 0x10 ordinal: 0x2
} _CM_KEY_HASH_TABLE_ENTRY;

// 0x12d8 bytes (sizeof)
typedef struct _CMHIVE {
  struct _HHIVE Hive;                             // offset: 0x0 ordinal: 0x0
  VOID *FileHandles[6];                           // offset: 0x608 ordinal: 0x1
  struct _LIST_ENTRY NotifyList;                  // offset: 0x638 ordinal: 0x2
  struct _LIST_ENTRY HiveList;                    // offset: 0x648 ordinal: 0x3
  struct _LIST_ENTRY PreloadedHiveList;           // offset: 0x658 ordinal: 0x4
  struct _EX_RUNDOWN_REF HiveRundown;             // offset: 0x668 ordinal: 0x5
  struct _CM_KEY_HASH_TABLE_ENTRY *KcbCacheTable; // offset: 0x670 ordinal: 0x6
  ULONG KcbCacheTableSize;                        // offset: 0x678 ordinal: 0x7
  struct _CM_KEY_HASH_TABLE_ENTRY
      *DeletedKcbTable;                // offset: 0x680 ordinal: 0x8
  ULONG DeletedKcbTableSize;           // offset: 0x688 ordinal: 0x9
  ULONG Identity;                      // offset: 0x68c ordinal: 0xa
  struct _CMSI_RW_LOCK HiveLock;       // offset: 0x690 ordinal: 0xb
  struct _RTL_BITMAP FlushDirtyVector; // offset: 0x698 ordinal: 0xc
  ULONG FlushDirtyVectorSize;          // offset: 0x6a8 ordinal: 0xd
  struct CMP_OFFSET_ARRAY
      *FlushLogEntryOffsetArray;                 // offset: 0x6b0 ordinal: 0xe
  ULONG FlushLogEntryOffsetArrayCount;           // offset: 0x6b8 ordinal: 0xf
  ULONG FlushLogEntrySize;                       // offset: 0x6bc ordinal: 0x10
  ULONG FlushHiveTruncated;                      // offset: 0x6c0 ordinal: 0x11
  UCHAR FlushBaseBlockDirty;                     // offset: 0x6c4 ordinal: 0x12
  struct _RTL_BITMAP CapturedUnreconciledVector; // offset: 0x6c8 ordinal: 0x13
  ULONG CapturedUnreconciledVectorSize;          // offset: 0x6d8 ordinal: 0x14
  struct CMP_OFFSET_ARRAY
      *UnreconciledOffsetArray;               // offset: 0x6e0 ordinal: 0x15
  ULONG UnreconciledOffsetArrayCount;         // offset: 0x6e8 ordinal: 0x16
  struct _HBASE_BLOCK *UnreconciledBaseBlock; // offset: 0x6f0 ordinal: 0x17
  struct _EX_PUSH_LOCK SecurityLock;          // offset: 0x6f8 ordinal: 0x18
  ULONG LastShrinkHiveSize;                   // offset: 0x700 ordinal: 0x19
  union _LARGE_INTEGER ActualFileSize;        // offset: 0x708 ordinal: 0x1a
  union _LARGE_INTEGER LogFileSizes[2];       // offset: 0x710 ordinal: 0x1b
  struct _UNICODE_STRING FileFullPath;        // offset: 0x720 ordinal: 0x1c
  struct _UNICODE_STRING FileUserName;        // offset: 0x730 ordinal: 0x1d
  struct _UNICODE_STRING HiveRootPath;        // offset: 0x740 ordinal: 0x1e
  ULONG SecurityCount;                        // offset: 0x750 ordinal: 0x1f
  ULONG SecurityCacheSize;                    // offset: 0x754 ordinal: 0x20
  LONG SecurityHitHint;                       // offset: 0x758 ordinal: 0x21
  struct _CM_KEY_SECURITY_CACHE_ENTRY
      *SecurityCache;                           // offset: 0x760 ordinal: 0x22
  struct _LIST_ENTRY SecurityHash[64];          // offset: 0x768 ordinal: 0x23
  ULONG UnloadEventCount;                       // offset: 0xb68 ordinal: 0x24
  struct _KEVENT **UnloadEventArray;            // offset: 0xb70 ordinal: 0x25
  struct _CM_KEY_CONTROL_BLOCK *RootKcb;        // offset: 0xb78 ordinal: 0x26
  UCHAR Frozen;                                 // offset: 0xb80 ordinal: 0x27
  struct _CM_DIRTY_VECTOR_LOG DirtyVectorLog;   // offset: 0xb88 ordinal: 0x28
  ULONG Flags;                                  // offset: 0x1010 ordinal: 0x29
  struct _LIST_ENTRY TrustClassEntry;           // offset: 0x1018 ordinal: 0x2a
  ULONGLONG DirtyTime;                          // offset: 0x1028 ordinal: 0x2b
  ULONGLONG UnreconciledTime;                   // offset: 0x1030 ordinal: 0x2c
  struct _CM_RM *CmRm;                          // offset: 0x1038 ordinal: 0x2d
  ULONG CmRmInitFailPoint;                      // offset: 0x1040 ordinal: 0x2e
  LONG CmRmInitFailStatus;                      // offset: 0x1044 ordinal: 0x2f
  struct _KTHREAD *CreatorOwner;                // offset: 0x1048 ordinal: 0x30
  struct _KTHREAD *RundownThread;               // offset: 0x1050 ordinal: 0x31
  union _LARGE_INTEGER LastWriteTime;           // offset: 0x1058 ordinal: 0x32
  struct _HIVE_WRITE_WAIT_QUEUE FlushQueue;     // offset: 0x1060 ordinal: 0x33
  struct _HIVE_WRITE_WAIT_QUEUE ReconcileQueue; // offset: 0x1070 ordinal: 0x34
  union {
    ULONG FlushFlags;            // offset: 0x1080 ordinal: 0x35
    ULONG PrimaryFilePurged : 1; // offset: 0x1080 ordinal: 0x36
  };
  ULONG DiskFileBad : 1;                        // offset: 0x1080 ordinal: 0x37
  ULONG PrimaryFileSizeBeforeLastFlush;         // offset: 0x1084 ordinal: 0x38
  LONG ReferenceCount;                          // offset: 0x1088 ordinal: 0x39
  LONG UnloadHistoryIndex;                      // offset: 0x108c ordinal: 0x3a
  ULONG UnloadHistory[128];                     // offset: 0x1090 ordinal: 0x3b
  ULONG BootStart;                              // offset: 0x1290 ordinal: 0x3c
  ULONG UnaccessedStart;                        // offset: 0x1294 ordinal: 0x3d
  ULONG UnaccessedEnd;                          // offset: 0x1298 ordinal: 0x3e
  ULONG LoadedKeyCount;                         // offset: 0x129c ordinal: 0x3f
  ULONG HandleClosePending;                     // offset: 0x12a0 ordinal: 0x40
  struct _EX_PUSH_LOCK HandleClosePendingEvent; // offset: 0x12a8 ordinal: 0x41
  UCHAR FinalFlushSucceeded;                    // offset: 0x12b0 ordinal: 0x42
  struct _CMP_VOLUME_CONTEXT *VolumeContext;    // offset: 0x12b8 ordinal: 0x43
  ULONG LateUnloadWorkItemState;                // offset: 0x12c0 ordinal: 0x44
  struct _EX_PUSH_LOCK LateUnloadFinishedEvent; // offset: 0x12c8 ordinal: 0x45
  struct _WORK_QUEUE_ITEM *LateUnloadWorkItem;  // offset: 0x12d0 ordinal: 0x46
} _CMHIVE;

// 0xb8 bytes (sizeof)
typedef struct _HIVE_LIST_ENTRY {
  WCHAR *FileName;                        // offset: 0x0 ordinal: 0x0
  WCHAR *BaseName;                        // offset: 0x8 ordinal: 0x1
  WCHAR *RegRootName;                     // offset: 0x10 ordinal: 0x2
  struct _CMHIVE *CmHive;                 // offset: 0x18 ordinal: 0x3
  ULONG HHiveFlags;                       // offset: 0x20 ordinal: 0x4
  ULONG CmHiveFlags;                      // offset: 0x24 ordinal: 0x5
  ULONG CmKcbCacheSize;                   // offset: 0x28 ordinal: 0x6
  struct _CMHIVE *CmHive2;                // offset: 0x30 ordinal: 0x7
  UCHAR HiveMounted;                      // offset: 0x38 ordinal: 0x8
  UCHAR ThreadFinished;                   // offset: 0x39 ordinal: 0x9
  UCHAR ThreadStarted;                    // offset: 0x3a ordinal: 0xa
  UCHAR Allocate;                         // offset: 0x3b ordinal: 0xb
  UCHAR WinPERequired;                    // offset: 0x3c ordinal: 0xc
  struct _KEVENT StartEvent;              // offset: 0x40 ordinal: 0xd
  struct _KEVENT FinishedEvent;           // offset: 0x58 ordinal: 0xe
  struct _KEVENT MountLock;               // offset: 0x70 ordinal: 0xf
  struct _EX_PUSH_LOCK MountCallbackLock; // offset: 0x88 ordinal: 0x10
  struct _EX_PUSH_LOCK CallbackListLock;  // offset: 0x90 ordinal: 0x11
  struct _LIST_ENTRY CallbackListHead;    // offset: 0x98 ordinal: 0x12
  struct _UNICODE_STRING FilePath;        // offset: 0xa8 ordinal: 0x13
} _HIVE_LIST_ENTRY;

// 0x88 bytes (sizeof)
typedef struct _CM_RM {
  struct _LIST_ENTRY RmListEntry;         // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY TransactionListHead; // offset: 0x10 ordinal: 0x1
  VOID *TmHandle;                         // offset: 0x20 ordinal: 0x2
  VOID *Tm;                               // offset: 0x28 ordinal: 0x3
  VOID *RmHandle;                         // offset: 0x30 ordinal: 0x4
  VOID *KtmRm;                            // offset: 0x38 ordinal: 0x5
  ULONG RefCount;                         // offset: 0x40 ordinal: 0x6
  ULONG ContainerNum;                     // offset: 0x44 ordinal: 0x7
  ULONGLONG ContainerSize;                // offset: 0x48 ordinal: 0x8
  struct _CMHIVE *CmHive;                 // offset: 0x50 ordinal: 0x9
  VOID *LogFileObject;                    // offset: 0x58 ordinal: 0xa
  VOID *MarshallingContext;               // offset: 0x60 ordinal: 0xb
  ULONG RmFlags;                          // offset: 0x68 ordinal: 0xc
  LONG LogStartStatus1;                   // offset: 0x6c ordinal: 0xd
  LONG LogStartStatus2;                   // offset: 0x70 ordinal: 0xe
  ULONGLONG BaseLsn;                      // offset: 0x78 ordinal: 0xf
  struct _ERESOURCE *RmLock;              // offset: 0x80 ordinal: 0x10
} _CM_RM;

// 0xb8 bytes (sizeof)
typedef struct _CM_TRANS {
  struct _LIST_ENTRY TransactionListEntry;  // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY KCBUoWListHead;        // offset: 0x10 ordinal: 0x1
  struct _LIST_ENTRY LazyCommitListEntry;   // offset: 0x20 ordinal: 0x2
  ULONG Prepared : 1;                       // offset: 0x30 ordinal: 0x3
  ULONG Aborted : 1;                        // offset: 0x30 ordinal: 0x4
  ULONG Committed : 1;                      // offset: 0x30 ordinal: 0x5
  ULONG Initializing : 1;                   // offset: 0x30 ordinal: 0x6
  ULONG Invalid : 1;                        // offset: 0x30 ordinal: 0x7
  ULONG UseReservation : 1;                 // offset: 0x30 ordinal: 0x8
  ULONG TmCallbacksActive : 1;              // offset: 0x30 ordinal: 0x9
  ULONG LightWeight : 1;                    // offset: 0x30 ordinal: 0xa
  ULONG Freed1 : 1;                         // offset: 0x30 ordinal: 0xb
  ULONG Freed2 : 1;                         // offset: 0x30 ordinal: 0xc
  ULONG Spare1 : 2;                         // offset: 0x30 ordinal: 0xd
  ULONG Freed : 1;                          // offset: 0x30 ordinal: 0xe
  ULONG Spare : 19;                         // offset: 0x30 ordinal: 0xf
  ULONG TransState;                         // offset: 0x30 ordinal: 0x10
  union _CM_TRANS_PTR Trans;                // offset: 0x38 ordinal: 0x11
  struct _CM_RM *CmRm;                      // offset: 0x40 ordinal: 0x12
  struct _KENLISTMENT *KtmEnlistmentObject; // offset: 0x48 ordinal: 0x13
  VOID *KtmEnlistmentHandle;                // offset: 0x50 ordinal: 0x14
  struct _GUID KtmUow;                      // offset: 0x58 ordinal: 0x15
  ULONGLONG StartLsn;                       // offset: 0x68 ordinal: 0x16
  ULONG HiveCount;                          // offset: 0x70 ordinal: 0x17
  struct _CMHIVE *HiveArray[8];             // offset: 0x78 ordinal: 0x18
} _CM_TRANS;

// 0x78 bytes (sizeof)
typedef struct _CM_KCB_UOW {
  struct _LIST_ENTRY TransactionListEntry;       // offset: 0x0 ordinal: 0x0
  struct _CM_INTENT_LOCK *KCBLock;               // offset: 0x10 ordinal: 0x1
  struct _CM_INTENT_LOCK *KeyLock;               // offset: 0x18 ordinal: 0x2
  struct _LIST_ENTRY KCBListEntry;               // offset: 0x20 ordinal: 0x3
  struct _CM_KEY_CONTROL_BLOCK *KeyControlBlock; // offset: 0x30 ordinal: 0x4
  struct _CM_TRANS *Transaction;                 // offset: 0x38 ordinal: 0x5
  ULONG UoWState;                                // offset: 0x40 ordinal: 0x6
  enum UoWActionType ActionType;                 // offset: 0x44 ordinal: 0x7
  enum HSTORAGE_TYPE StorageType;                // offset: 0x48 ordinal: 0x8
  struct _CM_KCB_UOW *ParentUoW;                 // offset: 0x50 ordinal: 0x9
  union {
    struct _CM_KEY_CONTROL_BLOCK *ChildKCB; // offset: 0x58 ordinal: 0xa
    ULONG VolatileKeyCell;                  // offset: 0x58 ordinal: 0xb
    ULONG OldValueCell;                     // offset: 0x58 ordinal: 0xc
  };
  ULONG NewValueCell; // offset: 0x5c ordinal: 0xd
  union {
    ULONG UserFlags;                    // offset: 0x58 ordinal: 0xe
    union _LARGE_INTEGER LastWriteTime; // offset: 0x58 ordinal: 0xf
    struct _CM_KEY_SECURITY_CACHE
        *TxCachedSecurity; // offset: 0x58 ordinal: 0x10
  };
  ULONG TxSecurityCell;                        // offset: 0x60 ordinal: 0x11
  struct _CM_KEY_CONTROL_BLOCK *OldChildKCB;   // offset: 0x58 ordinal: 0x12
  struct _CM_KEY_CONTROL_BLOCK *NewChildKCB;   // offset: 0x60 ordinal: 0x13
  struct _CM_KEY_CONTROL_BLOCK *OtherChildKCB; // offset: 0x58 ordinal: 0x14
  ULONG ThisVolatileKeyCell;                   // offset: 0x60 ordinal: 0x15
  union {
    VOID *PrepareDataPointer;                 // offset: 0x68 ordinal: 0x16
    struct _CM_UOW_SET_SD_DATA *SecurityData; // offset: 0x68 ordinal: 0x17
    struct _CM_UOW_KEY_STATE_MODIFICATION
        *ModifyKeysData; // offset: 0x68 ordinal: 0x18
    struct _CM_UOW_SET_VALUE_LIST_DATA
        *SetValueData; // offset: 0x68 ordinal: 0x19
  };
  union {
    struct _CM_UOW_SET_VALUE_KEY_DATA *ValueData; // offset: 0x70 ordinal: 0x1a
    struct _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT
        *DiscardReplaceContext; // offset: 0x70 ordinal: 0x1b
  };
} _CM_KCB_UOW;

// 0x138 bytes (sizeof)
typedef struct _CM_KEY_CONTROL_BLOCK {
  ULONGLONG RefCount;       // offset: 0x0 ordinal: 0x0
  ULONG ExtFlags : 16;      // offset: 0x8 ordinal: 0x1
  ULONG Freed : 1;          // offset: 0x8 ordinal: 0x2
  ULONG Discarded : 1;      // offset: 0x8 ordinal: 0x3
  ULONG HiveUnloaded : 1;   // offset: 0x8 ordinal: 0x4
  ULONG Decommissioned : 1; // offset: 0x8 ordinal: 0x5
  ULONG SpareExtFlag : 1;   // offset: 0x8 ordinal: 0x6
  ULONG TotalLevels : 10;   // offset: 0x8 ordinal: 0x7
  union {
    struct _CM_KEY_HASH KeyHash;  // offset: 0x10 ordinal: 0x8
    struct _CM_PATH_HASH ConvKey; // offset: 0x10 ordinal: 0x9
  };
  struct _CM_KEY_HASH *NextHash;    // offset: 0x18 ordinal: 0xa
  struct _HHIVE *KeyHive;           // offset: 0x20 ordinal: 0xb
  ULONG KeyCell;                    // offset: 0x28 ordinal: 0xc
  struct _EX_PUSH_LOCK KcbPushlock; // offset: 0x30 ordinal: 0xd
  union {
    struct _KTHREAD *Owner; // offset: 0x38 ordinal: 0xe
    LONG SharedCount;       // offset: 0x38 ordinal: 0xf
  };
  UCHAR DelayedDeref : 1;                        // offset: 0x40 ordinal: 0x10
  UCHAR DelayedClose : 1;                        // offset: 0x40 ordinal: 0x11
  UCHAR Parking : 1;                             // offset: 0x40 ordinal: 0x12
  UCHAR LayerSemantics;                          // offset: 0x41 ordinal: 0x13
  SHORT LayerHeight;                             // offset: 0x42 ordinal: 0x14
  ULONG Spare1;                                  // offset: 0x44 ordinal: 0x15
  struct _CM_KEY_CONTROL_BLOCK *ParentKcb;       // offset: 0x48 ordinal: 0x16
  struct _CM_NAME_CONTROL_BLOCK *NameBlock;      // offset: 0x50 ordinal: 0x17
  struct _CM_KEY_SECURITY_CACHE *CachedSecurity; // offset: 0x58 ordinal: 0x18
  struct _CHILD_LIST ValueList;                  // offset: 0x60 ordinal: 0x19
  struct _CM_KEY_CONTROL_BLOCK *LinkTarget;      // offset: 0x68 ordinal: 0x1a
  union {
    struct _CM_INDEX_HINT_BLOCK *IndexHint; // offset: 0x70 ordinal: 0x1b
    ULONG HashKey;                          // offset: 0x70 ordinal: 0x1c
    ULONG SubKeyCount;                      // offset: 0x70 ordinal: 0x1d
  };
  union {
    struct _LIST_ENTRY KeyBodyListHead; // offset: 0x78 ordinal: 0x1e
    struct _LIST_ENTRY ClonedListEntry; // offset: 0x78 ordinal: 0x1f
  };
  struct _CM_KEY_BODY *KeyBodyArray[4];  // offset: 0x88 ordinal: 0x20
  union _LARGE_INTEGER KcbLastWriteTime; // offset: 0xa8 ordinal: 0x21
  USHORT KcbMaxNameLen;                  // offset: 0xb0 ordinal: 0x22
  USHORT KcbMaxValueNameLen;             // offset: 0xb2 ordinal: 0x23
  ULONG KcbMaxValueDataLen;              // offset: 0xb4 ordinal: 0x24
  ULONG KcbUserFlags : 4;                // offset: 0xb8 ordinal: 0x25
  ULONG KcbVirtControlFlags : 4;         // offset: 0xb8 ordinal: 0x26
  ULONG KcbDebug : 8;                    // offset: 0xb8 ordinal: 0x27
  ULONG Flags : 16;                      // offset: 0xb8 ordinal: 0x28
  ULONG Spare3;                          // offset: 0xbc ordinal: 0x29
  struct _CM_KCB_LAYER_INFO *LayerInfo;  // offset: 0xc0 ordinal: 0x2a
  CHAR *RealKeyName;                     // offset: 0xc8 ordinal: 0x2b
  struct _LIST_ENTRY KCBUoWListHead;     // offset: 0xd0 ordinal: 0x2c
  union {
    struct _LIST_ENTRY DelayQueueEntry; // offset: 0xe0 ordinal: 0x2d
    UCHAR *Stolen;                      // offset: 0xe0 ordinal: 0x2e
  };
  struct _CM_TRANS *TransKCBOwner;       // offset: 0xf0 ordinal: 0x2f
  struct _CM_INTENT_LOCK KCBLock;        // offset: 0xf8 ordinal: 0x30
  struct _CM_INTENT_LOCK KeyLock;        // offset: 0x108 ordinal: 0x31
  struct _CHILD_LIST TransValueCache;    // offset: 0x118 ordinal: 0x32
  struct _CM_TRANS *TransValueListOwner; // offset: 0x120 ordinal: 0x33
  union {
    struct _UNICODE_STRING *FullKCBName; // offset: 0x128 ordinal: 0x34
    ULONGLONG FullKCBNameStale : 1;      // offset: 0x128 ordinal: 0x35
  };
  ULONGLONG Reserved : 63;  // offset: 0x128 ordinal: 0x36
  ULONGLONG SequenceNumber; // offset: 0x130 ordinal: 0x37
} _CM_KEY_CONTROL_BLOCK;

// 0x40 bytes (sizeof)
typedef struct _MMVAD_SHORT {
  struct _MMVAD_SHORT *NextVad;      // offset: 0x0 ordinal: 0x0
  VOID *ExtraCreateInfo;             // offset: 0x8 ordinal: 0x1
  struct _RTL_BALANCED_NODE VadNode; // offset: 0x0 ordinal: 0x2
  ULONG StartingVpn;                 // offset: 0x18 ordinal: 0x3
  ULONG EndingVpn;                   // offset: 0x1c ordinal: 0x4
  UCHAR StartingVpnHigh;             // offset: 0x20 ordinal: 0x5
  UCHAR EndingVpnHigh;               // offset: 0x21 ordinal: 0x6
  UCHAR CommitChargeHigh;            // offset: 0x22 ordinal: 0x7
  UCHAR SpareNT64VadUChar;           // offset: 0x23 ordinal: 0x8
  LONG ReferenceCount;               // offset: 0x24 ordinal: 0x9
  struct _EX_PUSH_LOCK PushLock;     // offset: 0x28 ordinal: 0xa
  union __anon_2293 u;               // offset: 0x30 ordinal: 0xb
  union __anon_2298 u1;              // offset: 0x34 ordinal: 0xc
  union __anon_2300 u5;              // offset: 0x38 ordinal: 0xd
} _MMVAD_SHORT;

// 0x48 bytes (sizeof)
typedef struct _SEGMENT {
  struct _CONTROL_AREA *ControlArea;  // offset: 0x0 ordinal: 0x0
  ULONG TotalNumberOfPtes;            // offset: 0x8 ordinal: 0x1
  struct _SEGMENT_FLAGS SegmentFlags; // offset: 0xc ordinal: 0x2
  ULONGLONG NumberOfCommittedPages;   // offset: 0x10 ordinal: 0x3
  ULONGLONG SizeOfSegment;            // offset: 0x18 ordinal: 0x4
  union {
    struct _MMEXTEND_INFO *ExtendInfo; // offset: 0x20 ordinal: 0x5
    VOID *BasedAddress;                // offset: 0x20 ordinal: 0x6
  };
  struct _EX_PUSH_LOCK SegmentLock; // offset: 0x28 ordinal: 0x7
  union __anon_2238 u1;             // offset: 0x30 ordinal: 0x8
  union __anon_2239 u2;             // offset: 0x38 ordinal: 0x9
  struct _MMPTE *PrototypePte;      // offset: 0x40 ordinal: 0xa
} _SEGMENT;

// 0x80 bytes (sizeof)
typedef struct _CONTROL_AREA {
  struct _SEGMENT *Segment; // offset: 0x0 ordinal: 0x0
  union {
    struct _LIST_ENTRY ListHead; // offset: 0x8 ordinal: 0x1
    VOID *AweContext;            // offset: 0x8 ordinal: 0x2
  };
  ULONGLONG NumberOfSectionReferences;          // offset: 0x18 ordinal: 0x3
  ULONGLONG NumberOfPfnReferences;              // offset: 0x20 ordinal: 0x4
  ULONGLONG NumberOfMappedViews;                // offset: 0x28 ordinal: 0x5
  ULONGLONG NumberOfUserReferences;             // offset: 0x30 ordinal: 0x6
  union __anon_2262 u;                          // offset: 0x38 ordinal: 0x7
  union __anon_2263 u1;                         // offset: 0x3c ordinal: 0x8
  struct _EX_FAST_REF FilePointer;              // offset: 0x40 ordinal: 0x9
  LONG ControlAreaLock;                         // offset: 0x48 ordinal: 0xa
  ULONG ModifiedWriteCount;                     // offset: 0x4c ordinal: 0xb
  struct _MI_CONTROL_AREA_WAIT_BLOCK *WaitList; // offset: 0x50 ordinal: 0xc
  union __anon_2265 u2;                         // offset: 0x58 ordinal: 0xd
  struct _EX_PUSH_LOCK FileObjectLock;          // offset: 0x68 ordinal: 0xe
  ULONGLONG LockedPages;                        // offset: 0x70 ordinal: 0xf
  union __anon_2266 u3;                         // offset: 0x78 ordinal: 0x10
} _CONTROL_AREA;

// 0x380 bytes (sizeof)
typedef struct _MI_SECTION_STATE {
  LONG SectionObjectPointersLock;                  // offset: 0x0 ordinal: 0x0
  struct _RTL_AVL_TREE SectionBasedRoot;           // offset: 0x8 ordinal: 0x1
  struct _EX_PUSH_LOCK SectionBasedLock;           // offset: 0x10 ordinal: 0x2
  ULONGLONG UnusedSegmentPagedPool;                // offset: 0x18 ordinal: 0x3
  ULONG DataSectionProtectionMask;                 // offset: 0x20 ordinal: 0x4
  VOID *HighSectionBase;                           // offset: 0x28 ordinal: 0x5
  struct _MSUBSECTION PhysicalSubsection;          // offset: 0x30 ordinal: 0x6
  struct _CONTROL_AREA PhysicalControlArea;        // offset: 0xc8 ordinal: 0x7
  struct _MMPFNLIST PurgingExtentPages;            // offset: 0x148 ordinal: 0x8
  struct _MMPFN *DanglingExtentPages;              // offset: 0x1a0 ordinal: 0x9
  struct _WORK_QUEUE_ITEM DanglingExtentsWorkItem; // offset: 0x1a8 ordinal: 0xa
  struct _MI_EXTENT_DELETION_WAIT_BLOCK
      DanglingExtentsDeletionWaitList;         // offset: 0x1c8 ordinal: 0xb
  UCHAR FileOnlyMemoryPfnsCreated;             // offset: 0x1e8 ordinal: 0xc
  UCHAR DanglingExtentsWorkerActive;           // offset: 0x1e9 ordinal: 0xd
  UCHAR PurgingExtentsNeedWatchdog;            // offset: 0x1ea ordinal: 0xe
  struct _RTL_AVL_TREE PrototypePtesTree;      // offset: 0x1f0 ordinal: 0xf
  LONG PrototypePtesTreeSpinLock;              // offset: 0x1f8 ordinal: 0x10
  struct _EX_PUSH_LOCK RelocateBitmapsLock;    // offset: 0x200 ordinal: 0x11
  struct _RTL_BITMAP_EX ImageBitMapNative;     // offset: 0x208 ordinal: 0x12
  ULONGLONG ImageBiasNative;                   // offset: 0x218 ordinal: 0x13
  struct _MI_DLL_OVERFLOW_AREA OverflowArea;   // offset: 0x220 ordinal: 0x14
  struct _MI_SECTION_WOW_STATE Wow[1];         // offset: 0x240 ordinal: 0x15
  ULONGLONG ImageBiasWow;                      // offset: 0x280 ordinal: 0x16
  struct _RTL_BITMAP_EX ImageBitMapWowScratch; // offset: 0x288 ordinal: 0x17
  struct _RTL_BITMAP_EX ImageBitMap64Low;      // offset: 0x298 ordinal: 0x18
  ULONGLONG ImageBias64Low;                    // offset: 0x2a8 ordinal: 0x19
  VOID *ApiSetSection;                         // offset: 0x2b0 ordinal: 0x1a
  VOID *ApiSetSchema;                          // offset: 0x2b8 ordinal: 0x1b
  ULONGLONG ApiSetSchemaSize;                  // offset: 0x2c0 ordinal: 0x1c
  ULONG LostDataFiles;                         // offset: 0x2c8 ordinal: 0x1d
  ULONG LostDataPages;                         // offset: 0x2cc ordinal: 0x1e
  ULONG ImageFailureReason;                    // offset: 0x2d0 ordinal: 0x1f
  struct _SECTION *CfgBitMapSection;           // offset: 0x2d8 ordinal: 0x20
  struct _CONTROL_AREA *CfgBitMapControlArea;  // offset: 0x2e0 ordinal: 0x21
  struct _RTL_BITMAP_EX KernelCfgBitMap;       // offset: 0x2e8 ordinal: 0x22
  struct _EX_PUSH_LOCK KernelCfgBitMapLock;    // offset: 0x2f8 ordinal: 0x23
  ULONG ImageCfgFailure;                       // offset: 0x300 ordinal: 0x24
  ULONG RetpolineReservePages;                 // offset: 0x304 ordinal: 0x25
  struct _MDL *RetpolineStubMdl;               // offset: 0x308 ordinal: 0x26
  struct _RTL_BITMAP_EX KernelRetpolineBitMap; // offset: 0x310 ordinal: 0x27
  struct _RTL_RETPOLINE_ROUTINES
      *RetpolineRoutines;                       // offset: 0x320 ordinal: 0x28
  struct _MMPTE *RetpolineRevertPte;            // offset: 0x328 ordinal: 0x29
  struct _LIST_ENTRY NonRetpolineImageLoadList; // offset: 0x330 ordinal: 0x2a
  ULONG RetpolineStubPages;                     // offset: 0x340 ordinal: 0x2b
  LONG RetpolineBootStatus;                     // offset: 0x344 ordinal: 0x2c
  ULONG ImageBreakpointEnabled;                 // offset: 0x348 ordinal: 0x2d
  ULONG ImageBreakpointChecksum;                // offset: 0x34c ordinal: 0x2e
  ULONG ImageBreakpointSize;                    // offset: 0x350 ordinal: 0x2f
  LONG ImageValidationFailed;                   // offset: 0x354 ordinal: 0x30
  struct _RTL_AVL_TREE ExtentTree[2];           // offset: 0x358 ordinal: 0x31
  struct _EX_PUSH_LOCK ExtentTreeLock;          // offset: 0x368 ordinal: 0x32
  struct _EX_PUSH_LOCK
      ExtentForwardProgressMappingLock; // offset: 0x370 ordinal: 0x33
} _MI_SECTION_STATE;

// 0x38 bytes (sizeof)
typedef struct _MI_SPECIAL_PURPOSE_MEMORY_STATE {
  struct _LIST_ENTRY TypesList;         // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY CacheEligibleList; // offset: 0x10 ordinal: 0x1
  struct _EPARTITION
      *RegularMemoryParentPartitionObject; // offset: 0x0 ordinal: 0x2
  VOID *SpecialPurposeMemoryParentHandle;  // offset: 0x8 ordinal: 0x3
  ULONGLONG Attributes[4];                 // offset: 0x10 ordinal: 0x4
  struct _EX_PUSH_LOCK Lock;               // offset: 0x30 ordinal: 0x5
} _MI_SPECIAL_PURPOSE_MEMORY_STATE;

// 0x58 bytes (sizeof)
typedef struct _MMPAGE_FILE_EXPANSION {
  struct _SEGMENT *Segment;           // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY DereferenceList; // offset: 0x8 ordinal: 0x1
  struct _MI_PARTITION *Partition;    // offset: 0x18 ordinal: 0x2
  ULONGLONG RequestedExpansionSize;   // offset: 0x20 ordinal: 0x3
  ULONGLONG ActualExpansion;          // offset: 0x28 ordinal: 0x4
  struct _KEVENT Event;               // offset: 0x30 ordinal: 0x5
  LONG InProgress;                    // offset: 0x48 ordinal: 0x6
  union __anon_2193 u1;               // offset: 0x4c ordinal: 0x7
  VOID **ActiveEntry;                 // offset: 0x50 ordinal: 0x8
} _MMPAGE_FILE_EXPANSION;

// 0x2c0 bytes (sizeof)
typedef struct _MI_PARTITION_MODWRITES {
  struct _MMPAGE_FILE_EXPANSION
      AttemptForCantExtend;                       // offset: 0x0 ordinal: 0x0
  struct _MMPAGE_FILE_EXPANSION PageFileContract; // offset: 0x58 ordinal: 0x1
  ULONGLONG NumberOfMappedMdls;                   // offset: 0xb0 ordinal: 0x2
  LONG NumberOfMappedMdlsInUse;                   // offset: 0xb8 ordinal: 0x3
  ULONG NumberOfMappedMdlsInUsePeak;              // offset: 0xbc ordinal: 0x4
  struct _MMMOD_WRITER_LISTHEAD MappedFileHeader; // offset: 0xc0 ordinal: 0x5
  UCHAR NeedMappedMdl;                            // offset: 0xe8 ordinal: 0x6
  UCHAR NeedPageFileMdl;                          // offset: 0xe9 ordinal: 0x7
  UCHAR ModwriterActive;                          // offset: 0xea ordinal: 0x8
  UCHAR TransitionInserted;                       // offset: 0xeb ordinal: 0x9
  LONG LastModifiedWriteError;                    // offset: 0xec ordinal: 0xa
  LONG LastMappedWriteError;                      // offset: 0xf0 ordinal: 0xb
  ULONG MappedFileWriteSucceeded;                 // offset: 0xf4 ordinal: 0xc
  ULONG MappedWriteBurstCount;                    // offset: 0xf8 ordinal: 0xd
  ULONG LowPriorityModWritesOutstanding;          // offset: 0xfc ordinal: 0xe
  struct _KEVENT BoostModWriteIoPriorityEvent;    // offset: 0x100 ordinal: 0xf
  LONG ModifiedWriterThreadPriority;              // offset: 0x118 ordinal: 0x10
  ULONGLONG ModifiedPagesLowPriorityGoal;         // offset: 0x120 ordinal: 0x11
  struct _KEVENT ModifiedPageWriterEvent;         // offset: 0x128 ordinal: 0x12
  struct _KEVENT ModifiedWriterExitedEvent;       // offset: 0x140 ordinal: 0x13
  LONG WriteAllPagefilePages;                     // offset: 0x158 ordinal: 0x14
  LONG WriteAllMappedPages;                       // offset: 0x15c ordinal: 0x15
  struct _KEVENT MappedPageWriterEvent;           // offset: 0x160 ordinal: 0x16
  struct _MI_MODWRITE_DATA ModWriteData;          // offset: 0x178 ordinal: 0x17
  struct _KEVENT RescanPageFilesEvent;            // offset: 0x1b8 ordinal: 0x18
  struct _MMMOD_WRITER_LISTHEAD PagingFileHeader; // offset: 0x1d0 ordinal: 0x19
  struct _ETHREAD *ModifiedPageWriterThread;      // offset: 0x1f8 ordinal: 0x1a
  struct _EX_RUNDOWN_REF
      ModifiedPageWriterRundown;                // offset: 0x200 ordinal: 0x1b
  struct _WORK_QUEUE_ITEM PagefileScanWorkItem; // offset: 0x208 ordinal: 0x1c
  ULONG PagefileScanCount;                      // offset: 0x228 ordinal: 0x1d
  LONG ClusterRestrictionLock;                  // offset: 0x22c ordinal: 0x1e
  struct _MI_RESTRICTED_MODWRITES
      ClusterRestrictions[2];                   // offset: 0x230 ordinal: 0x1f
  struct _KEVENT NotifyStoreMemoryConditions;   // offset: 0x238 ordinal: 0x20
  UCHAR DelayMappedWrite;                       // offset: 0x250 ordinal: 0x21
  ULONG PagefileReservationsEnabled;            // offset: 0x254 ordinal: 0x22
  struct _EX_PUSH_LOCK PageFileCreationLock;    // offset: 0x258 ordinal: 0x23
  struct _WORK_QUEUE_ITEM TrimPagefileWorkItem; // offset: 0x260 ordinal: 0x24
  ULONGLONG LastTrimPagefileTime;               // offset: 0x280 ordinal: 0x25
  struct _WORK_QUEUE_ITEM
      WsSwapPagefileContractWorkItem;       // offset: 0x288 ordinal: 0x26
  LONG WsSwapPageFileContractionInProgress; // offset: 0x2a8 ordinal: 0x27
  struct _EX_PUSH_LOCK WorkingSetSwapLock;  // offset: 0x2b0 ordinal: 0x28
  LONG WorkingSetInswapLock;                // offset: 0x2b8 ordinal: 0x29
} _MI_PARTITION_MODWRITES;

// 0x1e0 bytes (sizeof)
typedef struct _MI_PARTITION_CORE {
  USHORT PartitionId;                           // offset: 0x0 ordinal: 0x0
  union __anon_2150 u;                          // offset: 0x4 ordinal: 0x1
  ULONG Signature;                              // offset: 0x8 ordinal: 0x2
  UCHAR MemoryConfigurationChanged;             // offset: 0xc ordinal: 0x3
  struct _MI_NODE_INFORMATION *NodeInformation; // offset: 0x10 ordinal: 0x4
  struct _RTL_AVL_TREE PageRoot;                // offset: 0x18 ordinal: 0x5
  struct _PHYSICAL_MEMORY_DESCRIPTOR
      *MemoryNodeRuns;                             // offset: 0x20 ordinal: 0x6
  ULONGLONG MemoryBlockReferences;                 // offset: 0x28 ordinal: 0x7
  struct _WORK_QUEUE_ITEM PfnUnmapWorkItem;        // offset: 0x30 ordinal: 0x8
  ULONGLONG PfnUnmapCount;                         // offset: 0x50 ordinal: 0x9
  VOID *PfnUnmapWaitList;                          // offset: 0x58 ordinal: 0xa
  struct _PHYSICAL_MEMORY_DESCRIPTOR *MemoryRuns;  // offset: 0x60 ordinal: 0xb
  struct _KEVENT ExitEvent;                        // offset: 0x68 ordinal: 0xc
  struct _KEVENT ConductorNeededEvent;             // offset: 0x80 ordinal: 0xd
  VOID *SystemThreadHandles[6];                    // offset: 0x98 ordinal: 0xe
  struct _EPARTITION *PartitionObject;             // offset: 0xc8 ordinal: 0xf
  struct _EX_PUSH_LOCK PartitionSystemThreadsLock; // offset: 0xd0 ordinal: 0x10
  struct _EX_PUSH_LOCK DynamicMemoryPushLock;      // offset: 0xd8 ordinal: 0x11
  LONG DynamicMemoryLock;                          // offset: 0xe0 ordinal: 0x12
  UCHAR PfnUnmapActive;                            // offset: 0xe4 ordinal: 0x13
  struct _KEVENT TemporaryMemoryEvent;             // offset: 0xe8 ordinal: 0x14
  VOID *RootDirectory;              // offset: 0x100 ordinal: 0x15
  VOID *KernelObjectsDirectory;     // offset: 0x108 ordinal: 0x16
  struct _KEVENT *MemoryEvents[11]; // offset: 0x110 ordinal: 0x17
  VOID *MemoryEventHandles[11];     // offset: 0x168 ordinal: 0x18
  ULONGLONG TotalHugeIoRanges;      // offset: 0x1c0 ordinal: 0x19
  ULONGLONG NonChargedSecurePages;  // offset: 0x1c8 ordinal: 0x1a
  union _SLIST_HEADER
      FreeKernelShadowStackCacheEntries; // offset: 0x1d0 ordinal: 0x1b
} _MI_PARTITION_CORE;

// 0x10 bytes (sizeof)
typedef struct _EX_PUSH_LOCK_AUTO_EXPAND {
  struct _EX_PUSH_LOCK LocalLock;               // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE State; // offset: 0x8 ordinal: 0x1
  ULONG Stats;                                  // offset: 0xc ordinal: 0x2
} _EX_PUSH_LOCK_AUTO_EXPAND;

// 0x70 bytes (sizeof)
typedef struct _FSRTL_ADVANCED_FCB_HEADER {
  SHORT NodeTypeCode;                   // offset: 0x0 ordinal: 0x0
  SHORT NodeByteSize;                   // offset: 0x2 ordinal: 0x1
  UCHAR Flags;                          // offset: 0x4 ordinal: 0x2
  UCHAR IsFastIoPossible;               // offset: 0x5 ordinal: 0x3
  UCHAR Flags2;                         // offset: 0x6 ordinal: 0x4
  UCHAR Reserved : 4;                   // offset: 0x7 ordinal: 0x5
  UCHAR Version : 4;                    // offset: 0x7 ordinal: 0x6
  struct _ERESOURCE *Resource;          // offset: 0x8 ordinal: 0x7
  struct _ERESOURCE *PagingIoResource;  // offset: 0x10 ordinal: 0x8
  union _LARGE_INTEGER AllocationSize;  // offset: 0x18 ordinal: 0x9
  union _LARGE_INTEGER FileSize;        // offset: 0x20 ordinal: 0xa
  union _LARGE_INTEGER ValidDataLength; // offset: 0x28 ordinal: 0xb
  struct _FAST_MUTEX *FastMutex;        // offset: 0x30 ordinal: 0xc
  struct _LIST_ENTRY FilterContexts;    // offset: 0x38 ordinal: 0xd
  struct _EX_PUSH_LOCK PushLock;        // offset: 0x48 ordinal: 0xe
  VOID **FileContextSupportPointer;     // offset: 0x50 ordinal: 0xf
  union {
    VOID *Oplock;            // offset: 0x58 ordinal: 0x10
    VOID *ReservedForRemote; // offset: 0x58 ordinal: 0x11
  };
  VOID *AePushLock;        // offset: 0x60 ordinal: 0x12
  ULONG BypassIoOpenCount; // offset: 0x68 ordinal: 0x13
} _FSRTL_ADVANCED_FCB_HEADER;

// 0x28 bytes (sizeof)
typedef struct _IOMMU_PAGE_HANDLING_DATA {
  struct _EX_PUSH_LOCK ResetLock;      // offset: 0x0 ordinal: 0x0
  ULONGLONG Lock;                      // offset: 0x8 ordinal: 0x1
  ULONG ValidGroupFaultSequenceNumber; // offset: 0x10 ordinal: 0x2
  ULONG(*GetPageFault)
  (VOID *, ULONG *, ULONGLONG *, USHORT *, VOID **,
   ULONGLONG *); // offset: 0x18 ordinal: 0x3
  VOID(*DismissPageFault)
  (VOID *, ULONG, ULONGLONG, USHORT, LONG); // offset: 0x20 ordinal: 0x4
} _IOMMU_PAGE_HANDLING_DATA;

// 0x230 bytes (sizeof)
typedef struct _REGISTERED_IOMMU {
  struct _LIST_ENTRY ListEntry;                   // offset: 0x0 ordinal: 0x0
  VOID *InternalData;                             // offset: 0x10 ordinal: 0x1
  ULONG InternalDataSize;                         // offset: 0x18 ordinal: 0x2
  VOID *InterruptContext;                         // offset: 0x20 ordinal: 0x3
  UCHAR Irql;                                     // offset: 0x28 ordinal: 0x4
  LONG Gsi;                                       // offset: 0x2c ordinal: 0x5
  enum _KINTERRUPT_POLARITY InterruptPolarity;    // offset: 0x30 ordinal: 0x6
  enum _KINTERRUPT_MODE InterruptMode;            // offset: 0x34 ordinal: 0x7
  struct _EXT_IOMMU_FUNCTION_TABLE FunctionTable; // offset: 0x38 ordinal: 0x8
  struct _EXT_IOMMU_FUNCTION_TABLE_EXTENDED
      FunctionTableExtended;                     // offset: 0xd0 ordinal: 0x9
  ULONG Flags;                                   // offset: 0x188 ordinal: 0xa
  struct _LIST_ENTRY PasidTableListHead;         // offset: 0x190 ordinal: 0xb
  struct _IOMMU_PAGE_HANDLING_DATA PageHandling; // offset: 0x1a0 ordinal: 0xc
  ULONG MaximumDomainIds;                        // offset: 0x1c8 ordinal: 0xd
  ULONGLONG DomainIdBitmapLock;                  // offset: 0x1d0 ordinal: 0xe
  struct _RTL_BITMAP DomainIdBitmap;             // offset: 0x1d8 ordinal: 0xf
  ULONG Capabilities;                            // offset: 0x1e8 ordinal: 0x10
  enum _EXT_IOMMU_KNOWN_IOMMU_TYPE KnownType;    // offset: 0x1ec ordinal: 0x11
  ULONG PciSegment;                              // offset: 0x1f0 ordinal: 0x12
  ULONG PciBus;                                  // offset: 0x1f4 ordinal: 0x13
  struct _PCI_SLOT_NUMBER PciSlot;               // offset: 0x1f8 ordinal: 0x14
  union _LARGE_INTEGER MsiAddress;               // offset: 0x200 ordinal: 0x15
  ULONGLONG MsiData;                             // offset: 0x208 ordinal: 0x16
  ULONG MaximumAsids;                            // offset: 0x210 ordinal: 0x17
  ULONG Identifier;                              // offset: 0x214 ordinal: 0x18
  struct _UNICODE_STRING ResourceId;             // offset: 0x218 ordinal: 0x19
  struct _IOMMU_RESERVED_DEVICE_LIST
      *ReservedDevices; // offset: 0x228 ordinal: 0x1a
} _REGISTERED_IOMMU;

// 0x28 bytes (sizeof)
typedef struct __anon_1498 {
  struct _REGISTERED_IOMMU *Iommu;     // offset: 0x0 ordinal: 0x0
  struct _EXT_IOMMU_DEVICE *ExtDevice; // offset: 0x8 ordinal: 0x1
  ULONGLONG SourceId;                  // offset: 0x10 ordinal: 0x2
  ULONG AtsReferenceCount;             // offset: 0x18 ordinal: 0x3
  ULONG InvalidationQueueDepth;        // offset: 0x1c ordinal: 0x4
  struct _EX_RUNDOWN_REF DeviceActive; // offset: 0x20 ordinal: 0x5
} __anon_1498;

// 0x108 bytes (sizeof)
typedef struct _IOMMU_DMA_DEVICE {
  struct _EXT_IOMMU_DEVICE_ID *DeviceId; // offset: 0x0 ordinal: 0x0
  struct _DEVICE_OBJECT *DeviceObject;   // offset: 0x8 ordinal: 0x1
  LONG DeviceState;                      // offset: 0x10 ordinal: 0x2
  struct _IOMMU_DMA_DOMAIN *DomainOwner; // offset: 0x18 ordinal: 0x3
  union {
    struct __anon_1497 Hypervisor; // offset: 0x20 ordinal: 0x4
    struct __anon_1498 Native;     // offset: 0x20 ordinal: 0x5
  };
  struct _IOMMU_INTERFACE_CALLBACK_RECORD
      *InterfaceCallbackRecord;            // offset: 0x48 ordinal: 0x6
  UCHAR DpptException;                     // offset: 0x50 ordinal: 0x7
  struct _IOMMU_TRACKED_DEVICE *SvmDevice; // offset: 0x58 ordinal: 0x8
  VOID(*FaultHandler)
  (VOID *, struct _FAULT_INFORMATION *); // offset: 0x60 ordinal: 0x9
  VOID *FaultContext;                    // offset: 0x68 ordinal: 0xa
  struct _FAULT_INFORMATION FaultInfo;   // offset: 0x70 ordinal: 0xb
  struct _KDPC FaultDpc;                 // offset: 0xa8 ordinal: 0xc
  struct _WORK_QUEUE_ITEM FaultWorkItem; // offset: 0xe8 ordinal: 0xd
} _IOMMU_DMA_DEVICE;

typedef LONG (*__anon_3512)(VOID (*)(struct _IOMMU_INTERFACE_STATE_CHANGE *,
                                     VOID *),
                            struct _IOMMU_DMA_DEVICE *);

typedef LONG (*__anon_3511)(VOID (*)(struct _IOMMU_INTERFACE_STATE_CHANGE *,
                                     VOID *),
                            VOID *, struct _IOMMU_DMA_DEVICE *,
                            union _IOMMU_INTERFACE_STATE_CHANGE_FIELDS *);

typedef VOID (*__anon_3510)(struct _IOMMU_DMA_DEVICE *, ULONG *);

typedef LONG (*__anon_3509)(struct _IOMMU_DMA_DEVICE *, ULONG, UCHAR,
                            struct _DEVICE_FAULT_CONFIGURATION *);

typedef LONG (*__anon_3505)(struct _IOMMU_DMA_DOMAIN *,
                            struct _IOMMU_DMA_DEVICE *);

typedef LONG (*__anon_3517)(struct _DEVICE_OBJECT *,
                            struct _IOMMU_DEVICE_CREATION_CONFIGURATION *,
                            struct _IOMMU_DMA_DEVICE **);

typedef LONG (*__anon_3299)(struct _EXT_IOMMU_DEVICE_ID *,
                            struct _DEVICE_OBJECT *,
                            struct _IOMMU_DMA_DEVICE **);

typedef LONG (*__anon_3298)(struct _IOMMU_DMA_DEVICE *);

// 0xb0 bytes (sizeof)
typedef struct _DMA_IOMMU_INTERFACE_V2 {
  LONG(*CreateDomainEx)
  (enum _IOMMU_DMA_DOMAIN_TYPE, union _IOMMU_DMA_DOMAIN_CREATION_FLAGS,
   struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG *,
   struct _IOMMU_DMA_RESERVED_REGION *,
   struct _IOMMU_DMA_DOMAIN **);                    // offset: 0x0 ordinal: 0x0
  LONG (*DeleteDomain)(struct _IOMMU_DMA_DOMAIN *); // offset: 0x8 ordinal: 0x1
  LONG(*AttachDeviceEx)
  (struct _IOMMU_DMA_DOMAIN *,
   struct _IOMMU_DMA_DEVICE *); // offset: 0x10 ordinal: 0x2
  LONG(*DetachDeviceEx)
  (struct _IOMMU_DMA_DEVICE *);                    // offset: 0x18 ordinal: 0x3
  LONG (*FlushDomain)(struct _IOMMU_DMA_DOMAIN *); // offset: 0x20 ordinal: 0x4
  LONG(*FlushDomainByVaList)
  (struct _IOMMU_DMA_DOMAIN *, UCHAR, ULONG,
   VOID *); // offset: 0x28 ordinal: 0x5
  LONG(*QueryInputMappings)
  (struct _DEVICE_OBJECT *, struct _INPUT_MAPPING_ELEMENT *, ULONG,
   ULONG *); // offset: 0x30 ordinal: 0x6
  LONG(*MapLogicalRangeEx)
  (struct _IOMMU_DMA_DOMAIN *, ULONG, struct _IOMMU_MAP_PHYSICAL_ADDRESS *,
   ULONGLONG *, ULONGLONG *, ULONGLONG *,
   ULONGLONG *); // offset: 0x38 ordinal: 0x7
  LONG(*UnmapLogicalRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONGLONG,
   ULONGLONG); // offset: 0x40 ordinal: 0x8
  LONG(*MapIdentityRangeEx)
  (struct _IOMMU_DMA_DOMAIN *, ULONG,
   struct _IOMMU_MAP_PHYSICAL_ADDRESS *); // offset: 0x48 ordinal: 0x9
  LONG(*UnmapIdentityRangeEx)
  (struct _IOMMU_DMA_DOMAIN *,
   struct _IOMMU_MAP_PHYSICAL_ADDRESS *); // offset: 0x50 ordinal: 0xa
  LONG(*SetDeviceFaultReportingEx)
  (struct _IOMMU_DMA_DEVICE *, ULONG, UCHAR,
   struct _DEVICE_FAULT_CONFIGURATION *); // offset: 0x58 ordinal: 0xb
  LONG(*ConfigureDomain)
  (struct _IOMMU_DMA_DOMAIN *,
   struct _DOMAIN_CONFIGURATION *); // offset: 0x60 ordinal: 0xc
  VOID(*QueryAvailableDomainTypes)
  (struct _IOMMU_DMA_DEVICE *, ULONG *); // offset: 0x68 ordinal: 0xd
  LONG(*RegisterInterfaceStateChangeCallback)
  (VOID (*)(struct _IOMMU_INTERFACE_STATE_CHANGE *, VOID *), VOID *,
   struct _IOMMU_DMA_DEVICE *,
   union _IOMMU_INTERFACE_STATE_CHANGE_FIELDS *); // offset: 0x70 ordinal: 0xe
  LONG(*UnregisterInterfaceStateChangeCallback)
  (VOID (*)(struct _IOMMU_INTERFACE_STATE_CHANGE *, VOID *),
   struct _IOMMU_DMA_DEVICE *); // offset: 0x78 ordinal: 0xf
  LONG(*ReserveLogicalAddressRange)
  (struct _IOMMU_DMA_DOMAIN *, ULONGLONG, ULONGLONG *, ULONGLONG *, ULONGLONG *,
   struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN **); // offset: 0x80 ordinal: 0x10
  LONG(*FreeReservedLogicalAddressRange)
  (struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN *); // offset: 0x88 ordinal: 0x11
  LONG(*MapReservedLogicalRange)
  (struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN *, ULONGLONG, ULONG,
   struct _IOMMU_MAP_PHYSICAL_ADDRESS *,
   struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT
       *); // offset: 0x90 ordinal: 0x12
  LONG(*UnmapReservedLogicalRange)
  (struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT
       *); // offset: 0x98 ordinal: 0x13
  LONG(*CreateDevice)
  (struct _DEVICE_OBJECT *, struct _IOMMU_DEVICE_CREATION_CONFIGURATION *,
   struct _IOMMU_DMA_DEVICE **); // offset: 0xa0 ordinal: 0x14
  LONG(*DeleteDevice)
  (struct _IOMMU_DMA_DEVICE *); // offset: 0xa8 ordinal: 0x15
} _DMA_IOMMU_INTERFACE_V2;

// 0xc0 bytes (sizeof)
typedef struct _DMA_IOMMU_INTERFACE_EX {
  ULONGLONG Size; // offset: 0x0 ordinal: 0x0
  ULONG Version;  // offset: 0x8 ordinal: 0x1
  union {
    struct _DMA_IOMMU_INTERFACE_V1 V1; // offset: 0x10 ordinal: 0x2
    struct _DMA_IOMMU_INTERFACE_V2 V2; // offset: 0x10 ordinal: 0x3
  };
} _DMA_IOMMU_INTERFACE_EX;

typedef LONG (*__anon_3308)(ULONG, ULONGLONG, struct _DMA_IOMMU_INTERFACE_EX *);

// 0x70 bytes (sizeof)
typedef struct _IOMMU_TRACKED_DEVICE {
  struct _LIST_ENTRY ListEntry;               // offset: 0x0 ordinal: 0x0
  ULONGLONG Lock;                             // offset: 0x10 ordinal: 0x1
  VOID *Iommu;                                // offset: 0x18 ordinal: 0x2
  ULONG IommuCapabilities;                    // offset: 0x20 ordinal: 0x3
  ULONG ReferenceCount;                       // offset: 0x24 ordinal: 0x4
  ULONGLONG SourceId;                         // offset: 0x28 ordinal: 0x5
  union _IOMMU_SVM_CAPABILITIES Capabilities; // offset: 0x30 ordinal: 0x6
  ULONG Flags;                                // offset: 0x3c ordinal: 0x7
  struct _IOMMU_PASID_TABLE_OBJECT
      *CurrentPasidTable;                  // offset: 0x40 ordinal: 0x8
  struct _LIST_ENTRY PasidTableDeviceList; // offset: 0x48 ordinal: 0x9
  struct _LIST_ENTRY ActiveDeviceListHead; // offset: 0x58 ordinal: 0xa
  struct _IOMMU_DMA_DEVICE *DmaDevice;     // offset: 0x68 ordinal: 0xb
} _IOMMU_TRACKED_DEVICE;

// 0x30 bytes (sizeof)
typedef struct _IOMMU_INTERFACE_CALLBACK_RECORD {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  VOID(*CallbackRoutine)
  (struct _IOMMU_INTERFACE_STATE_CHANGE *, VOID *); // offset: 0x10 ordinal: 0x1
  VOID *CallbackContext;                            // offset: 0x18 ordinal: 0x2
  struct _IOMMU_DMA_DEVICE *DmaDevice;              // offset: 0x20 ordinal: 0x3
  struct _IOMMU_INTERFACE_STATE_CHANGE
      LastReportedState; // offset: 0x28 ordinal: 0x4
} _IOMMU_INTERFACE_CALLBACK_RECORD;

// 0x288 bytes (sizeof)
typedef struct _ADAPTER_OBJECT {
  struct _HALP_DMA_ADAPTER_OBJECT AdapterObject; // offset: 0x0 ordinal: 0x0
  struct _HALP_DMA_MASTER_ADAPTER_OBJECT
      *MasterAdapter;                // offset: 0xa0 ordinal: 0x1
  struct _LIST_ENTRY WaitQueueEntry; // offset: 0xa8 ordinal: 0x2
  union {
    struct _KDEVICE_QUEUE ChannelWaitQueue; // offset: 0xb8 ordinal: 0x3
    ULONGLONG ResourceWaitLock;             // offset: 0xb8 ordinal: 0x4
  };
  struct _LIST_ENTRY ResourceWaitQueue;        // offset: 0xc0 ordinal: 0x5
  struct _LIST_ENTRY ChannelResourceWaitQueue; // offset: 0xd0 ordinal: 0x6
  UCHAR ResourceQueueBusy;                     // offset: 0xe0 ordinal: 0x7
  ULONG MapRegistersPerChannel;                // offset: 0xe8 ordinal: 0x8
  VOID *MapRegisterBase;                       // offset: 0xf0 ordinal: 0x9
  ULONG NumberOfMapRegisters;                  // offset: 0xf8 ordinal: 0xa
  ULONG MaxTransferLength;                     // offset: 0xfc ordinal: 0xb
  VOID *CrashDumpRegisterBase[2];              // offset: 0x100 ordinal: 0xc
  ULONG NumberOfCrashDumpRegisters[2];         // offset: 0x110 ordinal: 0xd
  ULONG CrashDumpRegisterRefCount[2];          // offset: 0x118 ordinal: 0xe
  struct _LIST_ENTRY AdapterCrashDumpList;     // offset: 0x120 ordinal: 0xf
  struct _MDL *MapRegisterMdl;                 // offset: 0x130 ordinal: 0x10
  ULONGLONG MapRegisterMdlLock;                // offset: 0x138 ordinal: 0x11
  struct _EX_PUSH_LOCK ExpiredLock;            // offset: 0x140 ordinal: 0x12
  VOID *AllocationHandle;                      // offset: 0x148 ordinal: 0x13
  VOID *VirtualAddress;                        // offset: 0x150 ordinal: 0x14
  UCHAR IsAllocationMdlBased;                  // offset: 0x158 ordinal: 0x15
  UCHAR NoLocalPool;                           // offset: 0x159 ordinal: 0x16
  UCHAR ExpiredFlag;                           // offset: 0x15a ordinal: 0x17
  struct _WAIT_CONTEXT_BLOCK *CurrentWcb;      // offset: 0x160 ordinal: 0x18
  struct _DMA_TRANSFER_CONTEXT
      *CurrentTransferContext;                   // offset: 0x168 ordinal: 0x19
  struct _HALP_DMA_CONTROLLER *DmaController;    // offset: 0x170 ordinal: 0x1a
  ULONG Controller;                              // offset: 0x178 ordinal: 0x1b
  ULONG ChannelNumber;                           // offset: 0x17c ordinal: 0x1c
  ULONG RequestLine;                             // offset: 0x180 ordinal: 0x1d
  ULONG RequestedChannelCount;                   // offset: 0x184 ordinal: 0x1e
  ULONG AllocatedChannelCount;                   // offset: 0x188 ordinal: 0x1f
  ULONG AllocatedChannels[8];                    // offset: 0x18c ordinal: 0x20
  VOID *ChannelAdapter;                          // offset: 0x1b0 ordinal: 0x21
  UCHAR NeedsMapRegisters;                       // offset: 0x1b8 ordinal: 0x22
  UCHAR MasterDevice;                            // offset: 0x1b9 ordinal: 0x23
  UCHAR ScatterGather;                           // offset: 0x1ba ordinal: 0x24
  UCHAR AutoInitialize;                          // offset: 0x1bb ordinal: 0x25
  UCHAR IgnoreCount;                             // offset: 0x1bc ordinal: 0x26
  UCHAR CacheCoherent;                           // offset: 0x1bd ordinal: 0x27
  UCHAR Dma32BitAddresses;                       // offset: 0x1c0 ordinal: 0x28
  UCHAR Dma64BitAddresses;                       // offset: 0x1c1 ordinal: 0x29
  ULONG DmaAddressWidth;                         // offset: 0x1c0 ordinal: 0x2a
  enum _DMA_WIDTH DmaPortWidth;                  // offset: 0x1c4 ordinal: 0x2b
  union _LARGE_INTEGER DeviceAddress;            // offset: 0x1c8 ordinal: 0x2c
  struct _LIST_ENTRY AdapterList;                // offset: 0x1d0 ordinal: 0x2d
  struct _WORK_QUEUE_ITEM WorkItem;              // offset: 0x1e0 ordinal: 0x2e
  struct _HALP_DMA_DOMAIN_OBJECT *DomainPointer; // offset: 0x200 ordinal: 0x2f
  enum _HALP_DMA_TRANSLATION_TYPE
      TranslationType;                   // offset: 0x208 ordinal: 0x30
  UCHAR AdapterInUse;                    // offset: 0x20c ordinal: 0x31
  struct _DEVICE_OBJECT *DeviceObject;   // offset: 0x210 ordinal: 0x32
  struct _EXT_IOMMU_DEVICE_ID *DeviceId; // offset: 0x218 ordinal: 0x33
  struct _IOMMU_DMA_DEVICE *IommuDevice; // offset: 0x220 ordinal: 0x34
  struct _MDL *ScatterGatherMdl;         // offset: 0x228 ordinal: 0x35
  struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN
      *LowMemoryLogicalAddressToken;          // offset: 0x230 ordinal: 0x36
  ULONGLONG LowMemoryLogicalAddressQueueLock; // offset: 0x238 ordinal: 0x37
  struct _LIST_ENTRY
      LowMemoryLogicalAddressQueue;        // offset: 0x240 ordinal: 0x38
  UCHAR LowMemoryLogicalAddressQueueInUse; // offset: 0x250 ordinal: 0x39
  struct _HALP_EMERGENCY_LA_QUEUE_ENTRY
      LowMemoryLogicalAddressQueueEntry; // offset: 0x258 ordinal: 0x3a
  enum _HALP_DMA_ADAPTER_ALLOCATION_STATE
      AllocationState;             // offset: 0x270 ordinal: 0x3b
  ULONG ScatterGatherBufferLength; // offset: 0x274 ordinal: 0x3c
  struct _SCATTER_GATHER_LIST
      ScatterGatherBuffer; // offset: 0x278 ordinal: 0x3d
} _ADAPTER_OBJECT;

// 0x108 bytes (sizeof)
typedef struct _DUMP_INITIALIZATION_CONTEXT {
  ULONG Length;                               // offset: 0x0 ordinal: 0x0
  ULONG Reserved;                             // offset: 0x4 ordinal: 0x1
  VOID *MemoryBlock;                          // offset: 0x8 ordinal: 0x2
  VOID *CommonBuffer[2];                      // offset: 0x10 ordinal: 0x3
  union _LARGE_INTEGER PhysicalAddress[2];    // offset: 0x20 ordinal: 0x4
  VOID (*StallRoutine)(ULONG);                // offset: 0x30 ordinal: 0x5
  UCHAR (*OpenRoutine)(union _LARGE_INTEGER); // offset: 0x38 ordinal: 0x6
  LONG(*WriteRoutine)
  (union _LARGE_INTEGER *, struct _MDL *); // offset: 0x40 ordinal: 0x7
  VOID (*FinishRoutine)();                 // offset: 0x48 ordinal: 0x8
  struct _ADAPTER_OBJECT *AdapterObject;   // offset: 0x50 ordinal: 0x9
  VOID *MappedRegisterBase;                // offset: 0x58 ordinal: 0xa
  VOID *PortConfiguration;                 // offset: 0x60 ordinal: 0xb
  UCHAR CrashDump;                         // offset: 0x68 ordinal: 0xc
  UCHAR MarkMemoryOnly;                    // offset: 0x69 ordinal: 0xd
  UCHAR HiberResume;                       // offset: 0x6a ordinal: 0xe
  UCHAR Reserved1;                         // offset: 0x6b ordinal: 0xf
  ULONG MaximumTransferSize;               // offset: 0x6c ordinal: 0x10
  ULONG CommonBufferSize;                  // offset: 0x70 ordinal: 0x11
  VOID *TargetAddress;                     // offset: 0x78 ordinal: 0x12
  LONG(*WritePendingRoutine)
  (LONG, union _LARGE_INTEGER *, struct _MDL *,
   VOID *);                   // offset: 0x80 ordinal: 0x13
  ULONG PartitionStyle;       // offset: 0x88 ordinal: 0x14
  union __anon_3973 DiskInfo; // offset: 0x8c ordinal: 0x15
  LONG(*ReadRoutine)
  (LONG, union _LARGE_INTEGER *, struct _MDL *); // offset: 0xa0 ordinal: 0x16
  LONG(*GetDriveTelemetryRoutine)
  (ULONG, ULONG, VOID *, ULONG); // offset: 0xa8 ordinal: 0x17
  ULONG LogSectionTruncateSize;  // offset: 0xb0 ordinal: 0x18
  ULONG Parameters[16];          // offset: 0xb4 ordinal: 0x19
  VOID(*GetTransferSizesRoutine)
  (ULONG *, ULONG *); // offset: 0xf8 ordinal: 0x1a
  VOID(*DumpNotifyRoutine)
  (enum _DUMP_EVENTS, VOID *, ULONG); // offset: 0x100 ordinal: 0x1b
} _DUMP_INITIALIZATION_CONTEXT;

// 0x178 bytes (sizeof)
typedef struct _DUMP_STACK_CONTEXT {
  struct _DUMP_INITIALIZATION_CONTEXT Init; // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER PartitionOffset;     // offset: 0x108 ordinal: 0x1
  union {
    VOID *DumpPointers; // offset: 0x110 ordinal: 0x2
    VOID *StorageInfo;  // offset: 0x110 ordinal: 0x3
  };
  UCHAR UseStorageInfo;                           // offset: 0x118 ordinal: 0x4
  ULONG PointersLength;                           // offset: 0x11c ordinal: 0x5
  WCHAR *ModulePrefix;                            // offset: 0x120 ordinal: 0x6
  struct _LIST_ENTRY DriverList;                  // offset: 0x128 ordinal: 0x7
  struct _STRING InitMsg;                         // offset: 0x138 ordinal: 0x8
  struct _STRING ProgMsg;                         // offset: 0x148 ordinal: 0x9
  struct _STRING DoneMsg;                         // offset: 0x158 ordinal: 0xa
  VOID *FileObject;                               // offset: 0x168 ordinal: 0xb
  enum _DEVICE_USAGE_NOTIFICATION_TYPE UsageType; // offset: 0x170 ordinal: 0xc
} _DUMP_STACK_CONTEXT;

// 0x1c8 bytes (sizeof)
typedef struct _POP_HIBER_CONTEXT {
  UCHAR Reset;                         // offset: 0x0 ordinal: 0x0
  UCHAR HiberFlags;                    // offset: 0x1 ordinal: 0x1
  UCHAR WroteHiberFile;                // offset: 0x2 ordinal: 0x2
  UCHAR KernelPhaseVerificationActive; // offset: 0x3 ordinal: 0x3
  UCHAR InitializationFinished;        // offset: 0x4 ordinal: 0x4
  LONG NextTableLockHeld;              // offset: 0x8 ordinal: 0x5
  LONG BootPhaseFinishedBarrier;       // offset: 0xc ordinal: 0x6
  LONG KernelResumeFinishedBarrier;    // offset: 0x10 ordinal: 0x7
  LONG HvCaptureReadyBarrier;          // offset: 0x14 ordinal: 0x8
  LONG HvCaptureCompletedBarrier;      // offset: 0x18 ordinal: 0x9
  UCHAR MapFrozen;                     // offset: 0x1c ordinal: 0xa
  union {
    struct _RTL_BITMAP DiscardMap;     // offset: 0x20 ordinal: 0xb
    struct _RTL_BITMAP KernelPhaseMap; // offset: 0x20 ordinal: 0xc
  };
  struct _RTL_BITMAP BootPhaseMap;            // offset: 0x30 ordinal: 0xd
  struct _LIST_ENTRY ClonedRanges;            // offset: 0x40 ordinal: 0xe
  ULONG ClonedRangeCount;                     // offset: 0x50 ordinal: 0xf
  ULONGLONG ClonedPageCount;                  // offset: 0x58 ordinal: 0x10
  struct _RTL_BITMAP *CurrentMap;             // offset: 0x60 ordinal: 0x11
  struct _LIST_ENTRY *NextCloneRange;         // offset: 0x68 ordinal: 0x12
  ULONGLONG NextPreserve;                     // offset: 0x70 ordinal: 0x13
  struct _MDL *LoaderMdl;                     // offset: 0x78 ordinal: 0x14
  struct _MDL *AllocatedMdl;                  // offset: 0x80 ordinal: 0x15
  ULONGLONG PagesOut;                         // offset: 0x88 ordinal: 0x16
  VOID *IoPages;                              // offset: 0x90 ordinal: 0x17
  ULONG IoPagesCount;                         // offset: 0x98 ordinal: 0x18
  VOID *CurrentMcb;                           // offset: 0xa0 ordinal: 0x19
  struct _DUMP_STACK_CONTEXT *DumpStack;      // offset: 0xa8 ordinal: 0x1a
  struct _KPROCESSOR_STATE *WakeState;        // offset: 0xb0 ordinal: 0x1b
  ULONG IoProgress;                           // offset: 0xb8 ordinal: 0x1c
  LONG Status;                                // offset: 0xbc ordinal: 0x1d
  ULONG GraphicsProc;                         // offset: 0xc0 ordinal: 0x1e
  struct PO_MEMORY_IMAGE *MemoryImage;        // offset: 0xc8 ordinal: 0x1f
  ULONG *PerformanceStats;                    // offset: 0xd0 ordinal: 0x20
  struct _MDL *BootLoaderLogMdl;              // offset: 0xd8 ordinal: 0x21
  struct _MDL *FirmwareRuntimeInformationMdl; // offset: 0xe0 ordinal: 0x22
  VOID *FirmwareRuntimeInformationVa;         // offset: 0xe8 ordinal: 0x23
  VOID *ResumeContext;                        // offset: 0xf0 ordinal: 0x24
  ULONG ResumeContextPages;                   // offset: 0xf8 ordinal: 0x25
  ULONG SecurePages;                          // offset: 0xfc ordinal: 0x26
  ULONG ProcessorCount;                       // offset: 0x100 ordinal: 0x27
  struct _POP_PER_PROCESSOR_CONTEXT
      *ProcessorContext;                // offset: 0x108 ordinal: 0x28
  CHAR *ProdConsBuffer;                 // offset: 0x110 ordinal: 0x29
  ULONG ProdConsSize;                   // offset: 0x118 ordinal: 0x2a
  ULONG MaxDataPages;                   // offset: 0x11c ordinal: 0x2b
  VOID *ExtraBuffer;                    // offset: 0x120 ordinal: 0x2c
  ULONGLONG ExtraBufferSize;            // offset: 0x128 ordinal: 0x2d
  VOID *ExtraMapVa;                     // offset: 0x130 ordinal: 0x2e
  ULONGLONG BitlockerKeyPFN;            // offset: 0x138 ordinal: 0x2f
  struct _POP_IO_INFO IoInfo;           // offset: 0x140 ordinal: 0x30
  USHORT *IoChecksums;                  // offset: 0x1b0 ordinal: 0x31
  ULONGLONG IoChecksumsSize;            // offset: 0x1b8 ordinal: 0x32
  ULONG HardwareConfigurationSignature; // offset: 0x1c0 ordinal: 0x33
  UCHAR IumEnabled;                     // offset: 0x1c4 ordinal: 0x34
  UCHAR SecureBoot;                     // offset: 0x1c5 ordinal: 0x35
} _POP_HIBER_CONTEXT;

typedef LONG (*__anon_3238)(struct _ADAPTER_OBJECT *, ULONG, ULONG,
                            struct _MAP_REGISTER_ENTRY *);

// 0xa0 bytes (sizeof)
typedef struct _HALP_DMA_CHANNEL {
  ULONG ChannelNumber; // offset: 0x0 ordinal: 0x0
  UCHAR Initialized;   // offset: 0x4 ordinal: 0x1
  UCHAR Busy;          // offset: 0x5 ordinal: 0x2
  UCHAR Complete;      // offset: 0x6 ordinal: 0x3
  VOID(*CurrentCompletionRoutine)
  (struct _DMA_ADAPTER *, struct _DEVICE_OBJECT *, VOID *,
   enum DMA_COMPLETION_STATUS);                    // offset: 0x8 ordinal: 0x4
  VOID *CurrentCompletionContext;                  // offset: 0x10 ordinal: 0x5
  struct _ADAPTER_OBJECT *CurrentChildAdapter;     // offset: 0x18 ordinal: 0x6
  enum _DMA_INTERRUPT_TYPE CurrentInterruptType;   // offset: 0x20 ordinal: 0x7
  struct _KDPC Dpc;                                // offset: 0x28 ordinal: 0x8
  UCHAR GeneratesInterrupt;                        // offset: 0x68 ordinal: 0x9
  LONG Gsi;                                        // offset: 0x6c ordinal: 0xa
  enum _KINTERRUPT_POLARITY InterruptPolarity;     // offset: 0x70 ordinal: 0xb
  enum _KINTERRUPT_MODE InterruptMode;             // offset: 0x74 ordinal: 0xc
  ULONG CommonBufferLength;                        // offset: 0x78 ordinal: 0xd
  VOID *CommonBufferVirtualAddress;                // offset: 0x80 ordinal: 0xe
  union _LARGE_INTEGER CommonBufferLogicalAddress; // offset: 0x88 ordinal: 0xf
  struct _LIST_ENTRY AdapterQueue;                 // offset: 0x90 ordinal: 0x10
} _HALP_DMA_CHANNEL;

// 0xe0 bytes (sizeof)
typedef struct _HALP_DMA_CONTROLLER {
  struct _LIST_ENTRY Controllers;              // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY AdapterList;              // offset: 0x10 ordinal: 0x1
  ULONG ControllerId;                          // offset: 0x20 ordinal: 0x2
  ULONG MinimumRequestLine;                    // offset: 0x24 ordinal: 0x3
  ULONG MaximumRequestLine;                    // offset: 0x28 ordinal: 0x4
  ULONG ChannelCount;                          // offset: 0x2c ordinal: 0x5
  ULONG ScatterGatherLimit;                    // offset: 0x30 ordinal: 0x6
  struct _HALP_DMA_CHANNEL *Channels;          // offset: 0x38 ordinal: 0x7
  VOID *ExtensionData;                         // offset: 0x40 ordinal: 0x8
  UCHAR CacheCoherent;                         // offset: 0x48 ordinal: 0x9
  ULONG DmaAddressWidth;                       // offset: 0x4c ordinal: 0xa
  struct _DMA_FUNCTION_TABLE Operations;       // offset: 0x50 ordinal: 0xb
  ULONG SupportedPortWidths;                   // offset: 0xa0 ordinal: 0xc
  ULONG MinimumTransferUnit;                   // offset: 0xa4 ordinal: 0xd
  ULONGLONG Lock;                              // offset: 0xa8 ordinal: 0xe
  UCHAR Irql;                                  // offset: 0xb0 ordinal: 0xf
  UCHAR GeneratesInterrupt;                    // offset: 0xb1 ordinal: 0x10
  LONG Gsi;                                    // offset: 0xb4 ordinal: 0x11
  enum _KINTERRUPT_POLARITY InterruptPolarity; // offset: 0xb8 ordinal: 0x12
  enum _KINTERRUPT_MODE InterruptMode;         // offset: 0xbc ordinal: 0x13
  struct _UNICODE_STRING ResourceId;           // offset: 0xc0 ordinal: 0x14
  struct POHANDLE__ *PowerHandle;              // offset: 0xd0 ordinal: 0x15
  UCHAR PowerActive;                           // offset: 0xd8 ordinal: 0x16
} _HALP_DMA_CONTROLLER;

// 0x78 bytes (sizeof)
typedef struct _HALP_DMA_DOMAIN_OBJECT {
  struct _LIST_ENTRY ListEntry;                    // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER MaximumPhysicalAddress;     // offset: 0x10 ordinal: 0x1
  union _LARGE_INTEGER BoundaryAddressMultiple;    // offset: 0x18 ordinal: 0x2
  UCHAR CacheCoherent;                             // offset: 0x20 ordinal: 0x3
  UCHAR FirmwareReserved;                          // offset: 0x21 ordinal: 0x4
  struct _IOMMU_DMA_DOMAIN *IommuDomainPointer;    // offset: 0x28 ordinal: 0x5
  enum _HALP_DMA_TRANSLATION_TYPE TranslationType; // offset: 0x30 ordinal: 0x6
  struct _ADAPTER_OBJECT *OwningAdapter;           // offset: 0x38 ordinal: 0x7
  struct _RTL_RB_TREE CommonBufferRoot;            // offset: 0x40 ordinal: 0x8
  ULONGLONG CommonBufferTreeLock;                  // offset: 0x50 ordinal: 0x9
  struct _LIST_ENTRY VectorCommonBufferListHead;   // offset: 0x58 ordinal: 0xa
  ULONGLONG VectorCommonBufferLock;                // offset: 0x68 ordinal: 0xb
  ULONG DomainRefCount;                            // offset: 0x70 ordinal: 0xc
} _HALP_DMA_DOMAIN_OBJECT;

// 0x158 bytes (sizeof)
typedef struct _OBJECT_DIRECTORY {
  struct _OBJECT_DIRECTORY_ENTRY *HashBuckets[37]; // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK Lock;                       // offset: 0x128 ordinal: 0x1
  struct _DEVICE_MAP *DeviceMap;                   // offset: 0x130 ordinal: 0x2
  struct _OBJECT_DIRECTORY *ShadowDirectory;       // offset: 0x138 ordinal: 0x3
  VOID *NamespaceEntry;                            // offset: 0x140 ordinal: 0x4
  VOID *SessionObject;                             // offset: 0x148 ordinal: 0x5
  ULONG Flags;                                     // offset: 0x150 ordinal: 0x6
  ULONG SessionId;                                 // offset: 0x154 ordinal: 0x7
} _OBJECT_DIRECTORY;

// 0x10 bytes (sizeof)
typedef struct _POP_RW_LOCK {
  struct _EX_PUSH_LOCK Lock; // offset: 0x0 ordinal: 0x0
  struct _KTHREAD *Thread;   // offset: 0x8 ordinal: 0x1
} _POP_RW_LOCK;

// 0x420 bytes (sizeof)
typedef struct _POP_THERMAL_ZONE {
  union {
    struct _POP_POLICY_DEVICE PolicyDevice; // offset: 0x0 ordinal: 0x0
    struct _LIST_ENTRY Link;                // offset: 0x0 ordinal: 0x1
  };
  enum POWER_POLICY_DEVICE_TYPE DeviceType; // offset: 0x10 ordinal: 0x2
  VOID *Notification;                       // offset: 0x18 ordinal: 0x3
  struct _UNICODE_STRING Name;              // offset: 0x20 ordinal: 0x4
  struct _DEVICE_OBJECT *Device;            // offset: 0x30 ordinal: 0x5
  struct _IRP *Irp;                         // offset: 0x38 ordinal: 0x6
  UCHAR State;                              // offset: 0x40 ordinal: 0x7
  UCHAR Flags;                              // offset: 0x41 ordinal: 0x8
  UCHAR Removing;                           // offset: 0x42 ordinal: 0x9
  UCHAR Mode;                               // offset: 0x43 ordinal: 0xa
  UCHAR PendingMode;                        // offset: 0x44 ordinal: 0xb
  UCHAR ActivePoint;                        // offset: 0x45 ordinal: 0xc
  UCHAR PendingActivePoint;                 // offset: 0x46 ordinal: 0xd
  UCHAR Critical;                           // offset: 0x47 ordinal: 0xe
  UCHAR ThermalStandby;                     // offset: 0x48 ordinal: 0xf
  UCHAR OverThrottled;                      // offset: 0x49 ordinal: 0x10
  LONG HighPrecisionThrottle;               // offset: 0x4c ordinal: 0x11
  LONG Throttle;                            // offset: 0x50 ordinal: 0x12
  LONG PendingThrottle;                     // offset: 0x54 ordinal: 0x13
  ULONG ThrottleReasons;                    // offset: 0x58 ordinal: 0x14
  ULONGLONG LastPassiveTime;                // offset: 0x60 ordinal: 0x15
  ULONG SampleRate;                         // offset: 0x68 ordinal: 0x16
  ULONG LastTemp;                           // offset: 0x6c ordinal: 0x17
  struct _THERMAL_INFORMATION_EX Info;      // offset: 0x70 ordinal: 0x18
  struct _THERMAL_POLICY Policy;            // offset: 0xcc ordinal: 0x19
  UCHAR PolicyDriver;                       // offset: 0xe4 ordinal: 0x1a
  ULONG PollingRate;                        // offset: 0xe8 ordinal: 0x1b
  ULONGLONG LastTemperatureTime;            // offset: 0xf0 ordinal: 0x1c
  ULONGLONG LastActiveStartTime;            // offset: 0xf8 ordinal: 0x1d
  ULONGLONG LastPassiveStartTime;           // offset: 0x100 ordinal: 0x1e
  struct _WORK_QUEUE_ITEM WorkItem;         // offset: 0x108 ordinal: 0x1f
  struct _KTIMER2 ZoneUpdateTimer;          // offset: 0x128 ordinal: 0x20
  struct _POP_RW_LOCK Lock;                 // offset: 0x1b0 ordinal: 0x21
  struct _KEVENT ZoneStopped;               // offset: 0x1c0 ordinal: 0x22
  struct _KEVENT TemperatureUpdated;        // offset: 0x1d8 ordinal: 0x23
  ULONG InstanceId;                         // offset: 0x1f0 ordinal: 0x24
  struct _POP_THERMAL_TELEMETRY_TRACKER
      TelemetryTracker;               // offset: 0x1f8 ordinal: 0x25
  struct _UNICODE_STRING Description; // offset: 0x410 ordinal: 0x26
} _POP_THERMAL_ZONE;

// 0x90 bytes (sizeof)
typedef struct _POP_COOLING_EXTENSION {
  struct _LIST_ENTRY Link;                     // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY RequestListHead;          // offset: 0x10 ordinal: 0x1
  struct _POP_RW_LOCK Lock;                    // offset: 0x20 ordinal: 0x2
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x30 ordinal: 0x3
  VOID *NotificationEntry;                     // offset: 0x38 ordinal: 0x4
  UCHAR Enabled;                               // offset: 0x40 ordinal: 0x5
  UCHAR ActiveEngaged;                         // offset: 0x41 ordinal: 0x6
  UCHAR ThrottleLimit;                         // offset: 0x42 ordinal: 0x7
  UCHAR UpdatingToCurrent;                     // offset: 0x43 ordinal: 0x8
  struct _KEVENT *RemovalFlushEvent;           // offset: 0x48 ordinal: 0x9
  struct _KEVENT *PnpFlushEvent;               // offset: 0x50 ordinal: 0xa
  struct _THERMAL_COOLING_INTERFACE Interface; // offset: 0x58 ordinal: 0xb
} _POP_COOLING_EXTENSION;

// 0x60 bytes (sizeof)
typedef struct _DEVICE_OBJECT_POWER_EXTENSION {
  ULONG IdleCount;                                 // offset: 0x0 ordinal: 0x0
  ULONG BusyCount;                                 // offset: 0x4 ordinal: 0x1
  ULONG BusyReference;                             // offset: 0x8 ordinal: 0x2
  ULONG TotalBusyCount;                            // offset: 0xc ordinal: 0x3
  ULONG ConservationIdleTime;                      // offset: 0x10 ordinal: 0x4
  ULONG PerformanceIdleTime;                       // offset: 0x14 ordinal: 0x5
  struct _DEVICE_OBJECT *DeviceObject;             // offset: 0x18 ordinal: 0x6
  struct _LIST_ENTRY IdleList;                     // offset: 0x20 ordinal: 0x7
  enum _POP_DEVICE_IDLE_TYPE IdleType;             // offset: 0x30 ordinal: 0x8
  enum _DEVICE_POWER_STATE IdleState;              // offset: 0x34 ordinal: 0x9
  enum _DEVICE_POWER_STATE CurrentState;           // offset: 0x38 ordinal: 0xa
  struct _POP_COOLING_EXTENSION *CoolingExtension; // offset: 0x40 ordinal: 0xb
  struct _LIST_ENTRY Volume;                       // offset: 0x48 ordinal: 0xc
  union __anon_695 Specific;                       // offset: 0x58 ordinal: 0xd
} _DEVICE_OBJECT_POWER_EXTENSION;

// 0x70 bytes (sizeof)
typedef struct _DEVOBJ_EXTENSION {
  SHORT Type;                                  // offset: 0x0 ordinal: 0x0
  USHORT Size;                                 // offset: 0x2 ordinal: 0x1
  struct _DEVICE_OBJECT *DeviceObject;         // offset: 0x8 ordinal: 0x2
  ULONG PowerFlags;                            // offset: 0x10 ordinal: 0x3
  struct _DEVICE_OBJECT_POWER_EXTENSION *Dope; // offset: 0x18 ordinal: 0x4
  ULONG ExtensionFlags;                        // offset: 0x20 ordinal: 0x5
  VOID *DeviceNode;                            // offset: 0x28 ordinal: 0x6
  struct _DEVICE_OBJECT *AttachedTo;           // offset: 0x30 ordinal: 0x7
  LONG StartIoCount;                           // offset: 0x38 ordinal: 0x8
  LONG StartIoKey;                             // offset: 0x3c ordinal: 0x9
  ULONG StartIoFlags;                          // offset: 0x40 ordinal: 0xa
  struct _VPB *Vpb;                            // offset: 0x48 ordinal: 0xb
  VOID *DependencyNode;                        // offset: 0x50 ordinal: 0xc
  VOID *InterruptContext;                      // offset: 0x58 ordinal: 0xd
  LONG InterruptCount;                         // offset: 0x60 ordinal: 0xe
  VOID *VerifierContext;                       // offset: 0x68 ordinal: 0xf
} _DEVOBJ_EXTENSION;

// 0x38 bytes (sizeof)
typedef struct _ETW_HASH_BUCKET {
  struct _LIST_ENTRY ListHead[3];  // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK BucketLock; // offset: 0x30 ordinal: 0x1
} _ETW_HASH_BUCKET;

// 0x20 bytes (sizeof)
typedef struct _OB_HANDLE_REVOCATION_BLOCK {
  struct _LIST_ENTRY RevocationInfos; // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK Lock;          // offset: 0x10 ordinal: 0x1
  struct _EX_RUNDOWN_REF Rundown;     // offset: 0x18 ordinal: 0x2
} _OB_HANDLE_REVOCATION_BLOCK;

// 0x20 bytes (sizeof)
typedef struct _HANDLE_REVOCATION_INFO {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  struct _OB_HANDLE_REVOCATION_BLOCK
      *RevocationBlock;        // offset: 0x10 ordinal: 0x1
  UCHAR AllowHandleRevocation; // offset: 0x18 ordinal: 0x2
  UCHAR Padding1[3];           // offset: 0x19 ordinal: 0x3
  UCHAR Padding2[4];           // offset: 0x1c ordinal: 0x4
} _HANDLE_REVOCATION_INFO;

// 0x30 bytes (sizeof)
typedef struct _OBJECT_FOOTER {
  struct _HANDLE_REVOCATION_INFO
      HandleRevocationInfo;                       // offset: 0x0 ordinal: 0x0
  struct _OB_EXTENDED_USER_INFO ExtendedUserInfo; // offset: 0x20 ordinal: 0x1
} _OBJECT_FOOTER;

// 0x10 bytes (sizeof)
typedef struct _OBJECT_HEADER_EXTENDED_INFO {
  struct _OBJECT_FOOTER *Footer; // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved;            // offset: 0x8 ordinal: 0x1
} _OBJECT_HEADER_EXTENDED_INFO;

// 0x10 bytes (sizeof)
typedef struct _SEP_CACHED_HANDLES_TABLE {
  struct _EX_PUSH_LOCK Lock;                 // offset: 0x0 ordinal: 0x0
  struct _RTL_DYNAMIC_HASH_TABLE *HashTable; // offset: 0x8 ordinal: 0x1
} _SEP_CACHED_HANDLES_TABLE;

// 0x20 bytes (sizeof)
typedef struct _ETW_PRIV_HANDLE_DEMUX_TABLE {
  struct _RTL_RB_TREE Tree;  // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK Lock; // offset: 0x10 ordinal: 0x1
  USHORT SequenceNumber;     // offset: 0x18 ordinal: 0x2
} _ETW_PRIV_HANDLE_DEMUX_TABLE;

// 0x1a8 bytes (sizeof)
typedef struct _ETW_GUID_ENTRY {
  struct _LIST_ENTRY GuidList;     // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY SiloGuidList; // offset: 0x10 ordinal: 0x1
  LONGLONG RefCount;               // offset: 0x20 ordinal: 0x2
  struct _GUID Guid;               // offset: 0x28 ordinal: 0x3
  struct _LIST_ENTRY RegListHead;  // offset: 0x38 ordinal: 0x4
  VOID *SecurityDescriptor;        // offset: 0x48 ordinal: 0x5
  union {
    struct _ETW_LAST_ENABLE_INFO LastEnable; // offset: 0x50 ordinal: 0x6
    ULONGLONG MatchId;                       // offset: 0x50 ordinal: 0x7
  };
  struct _TRACE_ENABLE_INFO ProviderEnableInfo; // offset: 0x60 ordinal: 0x8
  struct _TRACE_ENABLE_INFO EnableInfo[8];      // offset: 0x80 ordinal: 0x9
  struct _ETW_FILTER_HEADER *FilterData;        // offset: 0x180 ordinal: 0xa
  struct _ETW_SILODRIVERSTATE *SiloState;       // offset: 0x188 ordinal: 0xb
  struct _ETW_GUID_ENTRY *HostEntry;            // offset: 0x190 ordinal: 0xc
  struct _EX_PUSH_LOCK Lock;                    // offset: 0x198 ordinal: 0xd
  struct _ETHREAD *LockOwner;                   // offset: 0x1a0 ordinal: 0xe
} _ETW_GUID_ENTRY;

// 0xc0 bytes (sizeof)
typedef struct _SEP_LOGON_SESSION_REFERENCES {
  struct _SEP_LOGON_SESSION_REFERENCES *Next; // offset: 0x0 ordinal: 0x0
  struct _LUID LogonId;                       // offset: 0x8 ordinal: 0x1
  struct _LUID BuddyLogonId;                  // offset: 0x10 ordinal: 0x2
  LONGLONG ReferenceCount;                    // offset: 0x18 ordinal: 0x3
  ULONG Flags;                                // offset: 0x20 ordinal: 0x4
  struct _DEVICE_MAP *pDeviceMap;             // offset: 0x28 ordinal: 0x5
  VOID *Token;                                // offset: 0x30 ordinal: 0x6
  struct _UNICODE_STRING AccountName;         // offset: 0x38 ordinal: 0x7
  struct _UNICODE_STRING AuthorityName;       // offset: 0x48 ordinal: 0x8
  struct _SEP_CACHED_HANDLES_TABLE
      CachedHandlesTable;              // offset: 0x58 ordinal: 0x9
  struct _EX_PUSH_LOCK SharedDataLock; // offset: 0x68 ordinal: 0xa
  struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION
      *SharedClaimAttributes;                    // offset: 0x70 ordinal: 0xb
  struct _SEP_SID_VALUES_BLOCK *SharedSidValues; // offset: 0x78 ordinal: 0xc
  struct _OB_HANDLE_REVOCATION_BLOCK
      RevocationBlock;          // offset: 0x80 ordinal: 0xd
  struct _EJOB *ServerSilo;     // offset: 0xa0 ordinal: 0xe
  struct _LUID SiblingAuthId;   // offset: 0xa8 ordinal: 0xf
  struct _LIST_ENTRY TokenList; // offset: 0xb0 ordinal: 0x10
} _SEP_LOGON_SESSION_REFERENCES;

// 0x8 bytes (sizeof)
typedef struct _WNF_LOCK {
  struct _EX_PUSH_LOCK PushLock; // offset: 0x0 ordinal: 0x0
} _WNF_LOCK;

// 0x30 bytes (sizeof)
typedef struct _WNF_PERMANENT_DATA_STORE {
  struct _WNF_NODE_HEADER Header;     // offset: 0x0 ordinal: 0x0
  struct _WNF_LOCK Lock;              // offset: 0x8 ordinal: 0x1
  VOID *Handle;                       // offset: 0x10 ordinal: 0x2
  struct _LIST_ENTRY Links;           // offset: 0x18 ordinal: 0x3
  enum _WNF_DATA_SCOPE DataScopeType; // offset: 0x28 ordinal: 0x4
  ULONG ScopeInstanceIdSize;          // offset: 0x2c ordinal: 0x5
} _WNF_PERMANENT_DATA_STORE;

// 0x18 bytes (sizeof)
typedef struct _WNF_SCOPE_MAP_ENTRY {
  struct _WNF_LOCK MapEntryLock;   // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY MapEntryHead; // offset: 0x8 ordinal: 0x1
} _WNF_SCOPE_MAP_ENTRY;

// 0x50 bytes (sizeof)
typedef struct _WNF_SCOPE_INSTANCE {
  struct _WNF_NODE_HEADER Header;       // offset: 0x0 ordinal: 0x0
  struct _EX_RUNDOWN_REF RunRef;        // offset: 0x8 ordinal: 0x1
  enum _WNF_DATA_SCOPE DataScope;       // offset: 0x10 ordinal: 0x2
  ULONG InstanceIdSize;                 // offset: 0x14 ordinal: 0x3
  VOID *InstanceIdData;                 // offset: 0x18 ordinal: 0x4
  struct _LIST_ENTRY ResolverListEntry; // offset: 0x20 ordinal: 0x5
  struct _WNF_LOCK NameSetLock;         // offset: 0x30 ordinal: 0x6
  struct _RTL_AVL_TREE NameSet;         // offset: 0x38 ordinal: 0x7
  struct _WNF_PERMANENT_DATA_STORE
      *PermanentDataStore; // offset: 0x40 ordinal: 0x8
  struct _WNF_PERMANENT_DATA_STORE
      *VolatilePermanentDataStore; // offset: 0x48 ordinal: 0x9
} _WNF_SCOPE_INSTANCE;

// 0xb0 bytes (sizeof)
typedef struct _WNF_SCOPE_MAP {
  struct _WNF_NODE_HEADER Header;                   // offset: 0x0 ordinal: 0x0
  struct _WNF_SCOPE_INSTANCE *SystemScopeInstance;  // offset: 0x8 ordinal: 0x1
  struct _WNF_SCOPE_INSTANCE *MachineScopeInstance; // offset: 0x10 ordinal: 0x2
  struct _WNF_SCOPE_INSTANCE
      *PhysicalMachineScopeInstance;          // offset: 0x18 ordinal: 0x3
  struct _WNF_SCOPE_MAP_ENTRY ByDataScope[6]; // offset: 0x20 ordinal: 0x4
} _WNF_SCOPE_MAP;

// 0x38 bytes (sizeof)
typedef struct _WNF_SILODRIVERSTATE {
  struct _WNF_SCOPE_MAP *ScopeMap;                  // offset: 0x0 ordinal: 0x0
  VOID *PermanentNameStoreRootKey;                  // offset: 0x8 ordinal: 0x1
  VOID *PersistentNameStoreRootKey;                 // offset: 0x10 ordinal: 0x2
  LONGLONG PermanentNameSequenceNumber;             // offset: 0x18 ordinal: 0x3
  struct _WNF_LOCK PermanentNameSequenceNumberLock; // offset: 0x20 ordinal: 0x4
  LONGLONG PermanentNameSequenceNumberPool;         // offset: 0x28 ordinal: 0x5
  LONGLONG RuntimeNameSequenceNumber;               // offset: 0x30 ordinal: 0x6
} _WNF_SILODRIVERSTATE;

// 0x260 bytes (sizeof)
typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE {
  struct _LIST_ENTRY HashBuckets[37]; // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK Lock;          // offset: 0x250 ordinal: 0x1
  ULONG NumberOfPrivateSpaces;        // offset: 0x258 ordinal: 0x2
} _OBJECT_NAMESPACE_LOOKUPTABLE;

// 0x2e0 bytes (sizeof)
typedef struct _OBP_SILODRIVERSTATE {
  struct _EX_FAST_REF SystemDeviceMap; // offset: 0x0 ordinal: 0x0
  struct _OBP_SYSTEM_DOS_DEVICE_STATE
      SystemDosDeviceState;           // offset: 0x8 ordinal: 0x1
  struct _EX_PUSH_LOCK DeviceMapLock; // offset: 0x78 ordinal: 0x2
  struct _OBJECT_NAMESPACE_LOOKUPTABLE
      PrivateNamespaceLookupTable; // offset: 0x80 ordinal: 0x3
} _OBP_SILODRIVERSTATE;

// 0x40 bytes (sizeof)
typedef struct _HANDLE_TABLE_FREE_LIST {
  struct _EX_PUSH_LOCK FreeListLock;               // offset: 0x0 ordinal: 0x0
  union _HANDLE_TABLE_ENTRY *FirstFreeHandleEntry; // offset: 0x8 ordinal: 0x1
  union _HANDLE_TABLE_ENTRY *LastFreeHandleEntry;  // offset: 0x10 ordinal: 0x2
  LONG HandleCount;                                // offset: 0x18 ordinal: 0x3
  ULONG HighWaterMark;                             // offset: 0x1c ordinal: 0x4
} _HANDLE_TABLE_FREE_LIST;

// 0x10 bytes (sizeof)
typedef struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES {
  struct _RTL_AVL_TREE Tree; // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK Lock; // offset: 0x8 ordinal: 0x1
} _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES;

// 0x20 bytes (sizeof)
typedef struct _ALPC_PROCESS_CONTEXT {
  struct _EX_PUSH_LOCK Lock;       // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY ViewListHead; // offset: 0x8 ordinal: 0x1
  ULONGLONG PagedPoolQuotaCache;   // offset: 0x18 ordinal: 0x2
} _ALPC_PROCESS_CONTEXT;

// 0x438 bytes (sizeof)
typedef struct _KPROCESS {
  struct _DISPATCHER_HEADER Header;           // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY ProfileListHead;         // offset: 0x18 ordinal: 0x1
  ULONGLONG DirectoryTableBase;               // offset: 0x28 ordinal: 0x2
  struct _LIST_ENTRY ThreadListHead;          // offset: 0x30 ordinal: 0x3
  ULONG ProcessLock;                          // offset: 0x40 ordinal: 0x4
  ULONG ProcessTimerDelay;                    // offset: 0x44 ordinal: 0x5
  ULONGLONG DeepFreezeStartTime;              // offset: 0x48 ordinal: 0x6
  struct _KAFFINITY_EX Affinity;              // offset: 0x50 ordinal: 0x7
  struct _LIST_ENTRY ReadyListHead;           // offset: 0x158 ordinal: 0x8
  struct _SINGLE_LIST_ENTRY SwapListEntry;    // offset: 0x168 ordinal: 0x9
  struct _KAFFINITY_EX ActiveProcessors;      // offset: 0x170 ordinal: 0xa
  ULONG AutoAlignment : 1;                    // offset: 0x278 ordinal: 0xb
  ULONG DisableBoost : 1;                     // offset: 0x278 ordinal: 0xc
  ULONG DisableQuantum : 1;                   // offset: 0x278 ordinal: 0xd
  ULONG DeepFreeze : 1;                       // offset: 0x278 ordinal: 0xe
  ULONG TimerVirtualization : 1;              // offset: 0x278 ordinal: 0xf
  ULONG CheckStackExtents : 1;                // offset: 0x278 ordinal: 0x10
  ULONG CacheIsolationEnabled : 1;            // offset: 0x278 ordinal: 0x11
  ULONG PpmPolicy : 4;                        // offset: 0x278 ordinal: 0x12
  ULONG VaSpaceDeleted : 1;                   // offset: 0x278 ordinal: 0x13
  ULONG MultiGroup : 1;                       // offset: 0x278 ordinal: 0x14
  ULONG ReservedFlags : 19;                   // offset: 0x278 ordinal: 0x15
  LONG ProcessFlags;                          // offset: 0x278 ordinal: 0x16
  ULONG ActiveGroupsMask;                     // offset: 0x27c ordinal: 0x17
  CHAR BasePriority;                          // offset: 0x280 ordinal: 0x18
  CHAR QuantumReset;                          // offset: 0x281 ordinal: 0x19
  CHAR Visited;                               // offset: 0x282 ordinal: 0x1a
  union _KEXECUTE_OPTIONS Flags;              // offset: 0x283 ordinal: 0x1b
  USHORT ThreadSeed[32];                      // offset: 0x284 ordinal: 0x1c
  USHORT IdealProcessor[32];                  // offset: 0x2c4 ordinal: 0x1d
  USHORT IdealNode[32];                       // offset: 0x304 ordinal: 0x1e
  USHORT IdealGlobalNode;                     // offset: 0x344 ordinal: 0x1f
  USHORT Spare1;                              // offset: 0x346 ordinal: 0x20
  union _KSTACK_COUNT StackCount;             // offset: 0x348 ordinal: 0x21
  struct _LIST_ENTRY ProcessListEntry;        // offset: 0x350 ordinal: 0x22
  ULONGLONG CycleTime;                        // offset: 0x360 ordinal: 0x23
  ULONGLONG ContextSwitches;                  // offset: 0x368 ordinal: 0x24
  struct _KSCHEDULING_GROUP *SchedulingGroup; // offset: 0x370 ordinal: 0x25
  ULONG FreezeCount;                          // offset: 0x378 ordinal: 0x26
  ULONG KernelTime;                           // offset: 0x37c ordinal: 0x27
  ULONG UserTime;                             // offset: 0x380 ordinal: 0x28
  ULONG ReadyTime;                            // offset: 0x384 ordinal: 0x29
  ULONGLONG UserDirectoryTableBase;           // offset: 0x388 ordinal: 0x2a
  UCHAR AddressPolicy;                        // offset: 0x390 ordinal: 0x2b
  UCHAR Spare2[71];                           // offset: 0x391 ordinal: 0x2c
  VOID *InstrumentationCallback;              // offset: 0x3d8 ordinal: 0x2d
  union __anon_94 SecureState;                // offset: 0x3e0 ordinal: 0x2e
  ULONGLONG KernelWaitTime;                   // offset: 0x3e8 ordinal: 0x2f
  ULONGLONG UserWaitTime;                     // offset: 0x3f0 ordinal: 0x30
  ULONGLONG LastRebalanceQpc;                 // offset: 0x3f8 ordinal: 0x31
  VOID *PerProcessorCycleTimes;               // offset: 0x400 ordinal: 0x32
  ULONGLONG ExtendedFeatureDisableMask;       // offset: 0x408 ordinal: 0x33
  USHORT PrimaryGroup;                        // offset: 0x410 ordinal: 0x34
  USHORT Spare3[3];                           // offset: 0x412 ordinal: 0x35
  VOID *UserCetLogging;                       // offset: 0x418 ordinal: 0x36
  struct _LIST_ENTRY CpuPartitionList;        // offset: 0x420 ordinal: 0x37
  ULONGLONG EndPadding[1];                    // offset: 0x430 ordinal: 0x38
} _KPROCESS;

typedef UCHAR (*__anon_1929)(struct _FILE_OBJECT *, struct _KPROCESS *,
                             struct _IO_STATUS_BLOCK *,
                             struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_1928)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                             union _LARGE_INTEGER *, struct _KPROCESS *, ULONG,
                             struct _IO_STATUS_BLOCK *,
                             struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_1927)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                             union _LARGE_INTEGER *, struct _KPROCESS *, ULONG,
                             UCHAR, UCHAR, struct _IO_STATUS_BLOCK *,
                             struct _DEVICE_OBJECT *);

// 0xe0 bytes (sizeof)
typedef struct _FAST_IO_DISPATCH {
  ULONG SizeOfFastIoDispatch; // offset: 0x0 ordinal: 0x0
  UCHAR(*FastIoCheckIfPossible)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, ULONG, UCHAR, ULONG, UCHAR,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x8 ordinal: 0x1
  UCHAR(*FastIoRead)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, ULONG, UCHAR, ULONG, VOID *,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x10 ordinal: 0x2
  UCHAR(*FastIoWrite)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, ULONG, UCHAR, ULONG, VOID *,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x18 ordinal: 0x3
  UCHAR(*FastIoQueryBasicInfo)
  (struct _FILE_OBJECT *, UCHAR, struct _FILE_BASIC_INFORMATION *,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x20 ordinal: 0x4
  UCHAR(*FastIoQueryStandardInfo)
  (struct _FILE_OBJECT *, UCHAR, struct _FILE_STANDARD_INFORMATION *,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x28 ordinal: 0x5
  UCHAR(*FastIoLock)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, union _LARGE_INTEGER *,
   struct _KPROCESS *, ULONG, UCHAR, UCHAR, struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x30 ordinal: 0x6
  UCHAR(*FastIoUnlockSingle)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, union _LARGE_INTEGER *,
   struct _KPROCESS *, ULONG, struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x38 ordinal: 0x7
  UCHAR(*FastIoUnlockAll)
  (struct _FILE_OBJECT *, struct _KPROCESS *, struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x40 ordinal: 0x8
  UCHAR(*FastIoUnlockAllByKey)
  (struct _FILE_OBJECT *, VOID *, ULONG, struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x48 ordinal: 0x9
  UCHAR(*FastIoDeviceControl)
  (struct _FILE_OBJECT *, UCHAR, VOID *, ULONG, VOID *, ULONG, ULONG,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x50 ordinal: 0xa
  VOID(*AcquireFileForNtCreateSection)
  (struct _FILE_OBJECT *); // offset: 0x58 ordinal: 0xb
  VOID(*ReleaseFileForNtCreateSection)
  (struct _FILE_OBJECT *); // offset: 0x60 ordinal: 0xc
  VOID(*FastIoDetachDevice)
  (struct _DEVICE_OBJECT *,
   struct _DEVICE_OBJECT *); // offset: 0x68 ordinal: 0xd
  UCHAR(*FastIoQueryNetworkOpenInfo)
  (struct _FILE_OBJECT *, UCHAR, struct _FILE_NETWORK_OPEN_INFORMATION *,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x70 ordinal: 0xe
  LONG(*AcquireForModWrite)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, struct _ERESOURCE **,
   struct _DEVICE_OBJECT *); // offset: 0x78 ordinal: 0xf
  UCHAR(*MdlRead)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, ULONG, ULONG, struct _MDL **,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x80 ordinal: 0x10
  UCHAR(*MdlReadComplete)
  (struct _FILE_OBJECT *, struct _MDL *,
   struct _DEVICE_OBJECT *); // offset: 0x88 ordinal: 0x11
  UCHAR(*PrepareMdlWrite)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, ULONG, ULONG, struct _MDL **,
   struct _IO_STATUS_BLOCK *,
   struct _DEVICE_OBJECT *); // offset: 0x90 ordinal: 0x12
  UCHAR(*MdlWriteComplete)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, struct _MDL *,
   struct _DEVICE_OBJECT *); // offset: 0x98 ordinal: 0x13
  UCHAR(*FastIoReadCompressed)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, ULONG, ULONG, VOID *,
   struct _MDL **, struct _IO_STATUS_BLOCK *, struct _COMPRESSED_DATA_INFO *,
   ULONG, struct _DEVICE_OBJECT *); // offset: 0xa0 ordinal: 0x14
  UCHAR(*FastIoWriteCompressed)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, ULONG, ULONG, VOID *,
   struct _MDL **, struct _IO_STATUS_BLOCK *, struct _COMPRESSED_DATA_INFO *,
   ULONG, struct _DEVICE_OBJECT *); // offset: 0xa8 ordinal: 0x15
  UCHAR(*MdlReadCompleteCompressed)
  (struct _FILE_OBJECT *, struct _MDL *,
   struct _DEVICE_OBJECT *); // offset: 0xb0 ordinal: 0x16
  UCHAR(*MdlWriteCompleteCompressed)
  (struct _FILE_OBJECT *, union _LARGE_INTEGER *, struct _MDL *,
   struct _DEVICE_OBJECT *); // offset: 0xb8 ordinal: 0x17
  UCHAR(*FastIoQueryOpen)
  (struct _IRP *, struct _FILE_NETWORK_OPEN_INFORMATION *,
   struct _DEVICE_OBJECT *); // offset: 0xc0 ordinal: 0x18
  LONG(*ReleaseForModWrite)
  (struct _FILE_OBJECT *, struct _ERESOURCE *,
   struct _DEVICE_OBJECT *); // offset: 0xc8 ordinal: 0x19
  LONG(*AcquireForCcFlush)
  (struct _FILE_OBJECT *,
   struct _DEVICE_OBJECT *); // offset: 0xd0 ordinal: 0x1a
  LONG(*ReleaseForCcFlush)
  (struct _FILE_OBJECT *,
   struct _DEVICE_OBJECT *); // offset: 0xd8 ordinal: 0x1b
} _FAST_IO_DISPATCH;

// 0x30 bytes (sizeof)
typedef struct _KAPC_STATE {
  struct _LIST_ENTRY ApcListHead[2]; // offset: 0x0 ordinal: 0x0
  struct _KPROCESS *Process;         // offset: 0x20 ordinal: 0x1
  union {
    UCHAR InProgressFlags;         // offset: 0x28 ordinal: 0x2
    UCHAR KernelApcInProgress : 1; // offset: 0x28 ordinal: 0x3
  };
  UCHAR SpecialApcInProgress : 1; // offset: 0x28 ordinal: 0x4
  UCHAR KernelApcPending;         // offset: 0x29 ordinal: 0x5
  union {
    UCHAR UserApcPendingAll;         // offset: 0x2a ordinal: 0x6
    UCHAR SpecialUserApcPending : 1; // offset: 0x2a ordinal: 0x7
  };
  UCHAR UserApcPending : 1; // offset: 0x2a ordinal: 0x8
} _KAPC_STATE;

// 0x30 bytes (sizeof)
typedef union __anon_3688 {
  struct _KAPC_STATE ApcState;                // offset: 0x0 ordinal: 0x0
  struct _MI_HARD_FAULT_STATE HardFaultState; // offset: 0x0 ordinal: 0x1
} __anon_3688;

// 0x488 bytes (sizeof)
typedef struct _PEB32 {
  UCHAR InheritedAddressSpace;    // offset: 0x0 ordinal: 0x0
  UCHAR ReadImageFileExecOptions; // offset: 0x1 ordinal: 0x1
  UCHAR BeingDebugged;            // offset: 0x2 ordinal: 0x2
  union {
    UCHAR BitField;                // offset: 0x3 ordinal: 0x3
    UCHAR ImageUsesLargePages : 1; // offset: 0x3 ordinal: 0x4
  };
  UCHAR IsProtectedProcess : 1;           // offset: 0x3 ordinal: 0x5
  UCHAR IsImageDynamicallyRelocated : 1;  // offset: 0x3 ordinal: 0x6
  UCHAR SkipPatchingUser32Forwarders : 1; // offset: 0x3 ordinal: 0x7
  UCHAR IsPackagedProcess : 1;            // offset: 0x3 ordinal: 0x8
  UCHAR IsAppContainer : 1;               // offset: 0x3 ordinal: 0x9
  UCHAR IsProtectedProcessLight : 1;      // offset: 0x3 ordinal: 0xa
  UCHAR IsLongPathAwareProcess : 1;       // offset: 0x3 ordinal: 0xb
  ULONG Mutant;                           // offset: 0x4 ordinal: 0xc
  ULONG ImageBaseAddress;                 // offset: 0x8 ordinal: 0xd
  ULONG Ldr;                              // offset: 0xc ordinal: 0xe
  ULONG ProcessParameters;                // offset: 0x10 ordinal: 0xf
  ULONG SubSystemData;                    // offset: 0x14 ordinal: 0x10
  ULONG ProcessHeap;                      // offset: 0x18 ordinal: 0x11
  ULONG FastPebLock;                      // offset: 0x1c ordinal: 0x12
  ULONG AtlThunkSListPtr;                 // offset: 0x20 ordinal: 0x13
  ULONG IFEOKey;                          // offset: 0x24 ordinal: 0x14
  union {
    ULONG CrossProcessFlags; // offset: 0x28 ordinal: 0x15
    ULONG ProcessInJob : 1;  // offset: 0x28 ordinal: 0x16
  };
  ULONG ProcessInitializing : 1;        // offset: 0x28 ordinal: 0x17
  ULONG ProcessUsingVEH : 1;            // offset: 0x28 ordinal: 0x18
  ULONG ProcessUsingVCH : 1;            // offset: 0x28 ordinal: 0x19
  ULONG ProcessUsingFTH : 1;            // offset: 0x28 ordinal: 0x1a
  ULONG ProcessPreviouslyThrottled : 1; // offset: 0x28 ordinal: 0x1b
  ULONG ProcessCurrentlyThrottled : 1;  // offset: 0x28 ordinal: 0x1c
  ULONG ProcessImagesHotPatched : 1;    // offset: 0x28 ordinal: 0x1d
  ULONG ReservedBits0 : 24;             // offset: 0x28 ordinal: 0x1e
  union {
    ULONG KernelCallbackTable; // offset: 0x2c ordinal: 0x1f
    ULONG UserSharedInfoPtr;   // offset: 0x2c ordinal: 0x20
  };
  ULONG SystemReserved;                        // offset: 0x30 ordinal: 0x21
  ULONG AtlThunkSListPtr32;                    // offset: 0x34 ordinal: 0x22
  ULONG ApiSetMap;                             // offset: 0x38 ordinal: 0x23
  ULONG TlsExpansionCounter;                   // offset: 0x3c ordinal: 0x24
  ULONG TlsBitmap;                             // offset: 0x40 ordinal: 0x25
  ULONG TlsBitmapBits[2];                      // offset: 0x44 ordinal: 0x26
  ULONG ReadOnlySharedMemoryBase;              // offset: 0x4c ordinal: 0x27
  ULONG SharedData;                            // offset: 0x50 ordinal: 0x28
  ULONG ReadOnlyStaticServerData;              // offset: 0x54 ordinal: 0x29
  ULONG AnsiCodePageData;                      // offset: 0x58 ordinal: 0x2a
  ULONG OemCodePageData;                       // offset: 0x5c ordinal: 0x2b
  ULONG UnicodeCaseTableData;                  // offset: 0x60 ordinal: 0x2c
  ULONG NumberOfProcessors;                    // offset: 0x64 ordinal: 0x2d
  ULONG NtGlobalFlag;                          // offset: 0x68 ordinal: 0x2e
  union _LARGE_INTEGER CriticalSectionTimeout; // offset: 0x70 ordinal: 0x2f
  ULONG HeapSegmentReserve;                    // offset: 0x78 ordinal: 0x30
  ULONG HeapSegmentCommit;                     // offset: 0x7c ordinal: 0x31
  ULONG HeapDeCommitTotalFreeThreshold;        // offset: 0x80 ordinal: 0x32
  ULONG HeapDeCommitFreeBlockThreshold;        // offset: 0x84 ordinal: 0x33
  ULONG NumberOfHeaps;                         // offset: 0x88 ordinal: 0x34
  ULONG MaximumNumberOfHeaps;                  // offset: 0x8c ordinal: 0x35
  ULONG ProcessHeaps;                          // offset: 0x90 ordinal: 0x36
  ULONG GdiSharedHandleTable;                  // offset: 0x94 ordinal: 0x37
  ULONG ProcessStarterHelper;                  // offset: 0x98 ordinal: 0x38
  ULONG GdiDCAttributeList;                    // offset: 0x9c ordinal: 0x39
  ULONG LoaderLock;                            // offset: 0xa0 ordinal: 0x3a
  ULONG OSMajorVersion;                        // offset: 0xa4 ordinal: 0x3b
  ULONG OSMinorVersion;                        // offset: 0xa8 ordinal: 0x3c
  USHORT OSBuildNumber;                        // offset: 0xac ordinal: 0x3d
  USHORT OSCSDVersion;                         // offset: 0xae ordinal: 0x3e
  ULONG OSPlatformId;                          // offset: 0xb0 ordinal: 0x3f
  ULONG ImageSubsystem;                        // offset: 0xb4 ordinal: 0x40
  ULONG ImageSubsystemMajorVersion;            // offset: 0xb8 ordinal: 0x41
  ULONG ImageSubsystemMinorVersion;            // offset: 0xbc ordinal: 0x42
  ULONG ActiveProcessAffinityMask;             // offset: 0xc0 ordinal: 0x43
  ULONG GdiHandleBuffer[34];                   // offset: 0xc4 ordinal: 0x44
  ULONG PostProcessInitRoutine;                // offset: 0x14c ordinal: 0x45
  ULONG TlsExpansionBitmap;                    // offset: 0x150 ordinal: 0x46
  ULONG TlsExpansionBitmapBits[32];            // offset: 0x154 ordinal: 0x47
  ULONG SessionId;                             // offset: 0x1d4 ordinal: 0x48
  union _ULARGE_INTEGER AppCompatFlags;        // offset: 0x1d8 ordinal: 0x49
  union _ULARGE_INTEGER AppCompatFlagsUser;    // offset: 0x1e0 ordinal: 0x4a
  ULONG pShimData;                             // offset: 0x1e8 ordinal: 0x4b
  ULONG AppCompatInfo;                         // offset: 0x1ec ordinal: 0x4c
  struct _STRING32 CSDVersion;                 // offset: 0x1f0 ordinal: 0x4d
  ULONG ActivationContextData;                 // offset: 0x1f8 ordinal: 0x4e
  ULONG ProcessAssemblyStorageMap;             // offset: 0x1fc ordinal: 0x4f
  ULONG SystemDefaultActivationContextData;    // offset: 0x200 ordinal: 0x50
  ULONG SystemAssemblyStorageMap;              // offset: 0x204 ordinal: 0x51
  ULONG MinimumStackCommit;                    // offset: 0x208 ordinal: 0x52
  ULONG SparePointers[2];                      // offset: 0x20c ordinal: 0x53
  ULONG PatchLoaderData;                       // offset: 0x214 ordinal: 0x54
  ULONG ChpeV2ProcessInfo;                     // offset: 0x218 ordinal: 0x55
  ULONG AppModelFeatureState;                  // offset: 0x21c ordinal: 0x56
  ULONG SpareUlongs[2];                        // offset: 0x220 ordinal: 0x57
  USHORT ActiveCodePage;                       // offset: 0x228 ordinal: 0x58
  USHORT OemCodePage;                          // offset: 0x22a ordinal: 0x59
  USHORT UseCaseMapping;                       // offset: 0x22c ordinal: 0x5a
  USHORT UnusedNlsField;                       // offset: 0x22e ordinal: 0x5b
  ULONG WerRegistrationData;                   // offset: 0x230 ordinal: 0x5c
  ULONG WerShipAssertPtr;                      // offset: 0x234 ordinal: 0x5d
  ULONG Spare;                                 // offset: 0x238 ordinal: 0x5e
  ULONG pImageHeaderHash;                      // offset: 0x23c ordinal: 0x5f
  union {
    ULONG TracingFlags;           // offset: 0x240 ordinal: 0x60
    ULONG HeapTracingEnabled : 1; // offset: 0x240 ordinal: 0x61
  };
  ULONG CritSecTracingEnabled : 1;              // offset: 0x240 ordinal: 0x62
  ULONG LibLoaderTracingEnabled : 1;            // offset: 0x240 ordinal: 0x63
  ULONG SpareTracingBits : 29;                  // offset: 0x240 ordinal: 0x64
  ULONGLONG CsrServerReadOnlySharedMemoryBase;  // offset: 0x248 ordinal: 0x65
  ULONG TppWorkerpListLock;                     // offset: 0x250 ordinal: 0x66
  struct LIST_ENTRY32 TppWorkerpList;           // offset: 0x254 ordinal: 0x67
  ULONG WaitOnAddressHashTable[128];            // offset: 0x25c ordinal: 0x68
  ULONG TelemetryCoverageHeader;                // offset: 0x45c ordinal: 0x69
  ULONG CloudFileFlags;                         // offset: 0x460 ordinal: 0x6a
  ULONG CloudFileDiagFlags;                     // offset: 0x464 ordinal: 0x6b
  CHAR PlaceholderCompatibilityMode;            // offset: 0x468 ordinal: 0x6c
  CHAR PlaceholderCompatibilityModeReserved[7]; // offset: 0x469 ordinal: 0x6d
  ULONG LeapSecondData;                         // offset: 0x470 ordinal: 0x6e
  union {
    ULONG LeapSecondFlags;        // offset: 0x474 ordinal: 0x6f
    ULONG SixtySecondEnabled : 1; // offset: 0x474 ordinal: 0x70
  };
  ULONG Reserved : 31;                  // offset: 0x474 ordinal: 0x71
  ULONG NtGlobalFlag2;                  // offset: 0x478 ordinal: 0x72
  ULONGLONG ExtendedFeatureDisableMask; // offset: 0x480 ordinal: 0x73
} _PEB32;

// 0x20 bytes (sizeof)
typedef struct _KTIMER_TABLE_ENTRY {
  ULONGLONG Lock;             // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY Entry;   // offset: 0x8 ordinal: 0x1
  union _ULARGE_INTEGER Time; // offset: 0x18 ordinal: 0x2
} _KTIMER_TABLE_ENTRY;

// 0x40 bytes (sizeof)
typedef struct _KTIMER {
  struct _DISPATCHER_HEADER Header;  // offset: 0x0 ordinal: 0x0
  union _ULARGE_INTEGER DueTime;     // offset: 0x18 ordinal: 0x1
  struct _LIST_ENTRY TimerListEntry; // offset: 0x20 ordinal: 0x2
  struct _KDPC *Dpc;                 // offset: 0x30 ordinal: 0x3
  USHORT Processor;                  // offset: 0x38 ordinal: 0x4
  USHORT TimerType;                  // offset: 0x3a ordinal: 0x5
  ULONG Period;                      // offset: 0x3c ordinal: 0x6
} _KTIMER;

// 0x118 bytes (sizeof)
typedef struct _EX_WORK_QUEUE_MANAGER {
  struct _EX_PARTITION *Partition; // offset: 0x0 ordinal: 0x0
  struct _ENODE *Node;             // offset: 0x8 ordinal: 0x1
  struct _KEVENT Event;            // offset: 0x10 ordinal: 0x2
  struct _KTIMER DeadlockTimer;    // offset: 0x28 ordinal: 0x3
  struct _KEVENT ReaperEvent;      // offset: 0x68 ordinal: 0x4
  struct _KTIMER2 ReaperTimer;     // offset: 0x80 ordinal: 0x5
  VOID *ThreadHandle;              // offset: 0x108 ordinal: 0x6
  ULONG ExitThread;                // offset: 0x110 ordinal: 0x7
  USHORT ThreadSeed;               // offset: 0x114 ordinal: 0x8
} _EX_WORK_QUEUE_MANAGER;

// 0x20 bytes (sizeof)
typedef struct _EX_PARTITION {
  struct _EPARTITION *PartitionObject; // offset: 0x0 ordinal: 0x0
  struct _EX_WORK_QUEUE ***WorkQueues; // offset: 0x8 ordinal: 0x1
  struct _EX_WORK_QUEUE_MANAGER *
      *WorkQueueManagers;   // offset: 0x10 ordinal: 0x2
  LONG QueueAllocationMask; // offset: 0x18 ordinal: 0x3
} _EX_PARTITION;

// 0x48 bytes (sizeof)
typedef struct _LAZY_WRITER {
  struct _KTIMER ScanTimer;         // offset: 0x0 ordinal: 0x0
  UCHAR TimerInitialized;           // offset: 0x40 ordinal: 0x1
  UCHAR ScanActive;                 // offset: 0x41 ordinal: 0x2
  UCHAR OtherWork;                  // offset: 0x42 ordinal: 0x3
  UCHAR PendingTeardownScan;        // offset: 0x43 ordinal: 0x4
  UCHAR PendingPeriodicScan;        // offset: 0x44 ordinal: 0x5
  UCHAR PendingLowMemoryScan;       // offset: 0x45 ordinal: 0x6
  UCHAR PendingPowerScan;           // offset: 0x46 ordinal: 0x7
  UCHAR PendingCoalescingFlushScan; // offset: 0x47 ordinal: 0x8
} _LAZY_WRITER;

// 0x580 bytes (sizeof)
typedef struct _CC_PARTITION {
  SHORT NodeTypeCode;                            // offset: 0x0 ordinal: 0x0
  SHORT NodeByteSize;                            // offset: 0x2 ordinal: 0x1
  struct _EPARTITION *PartitionObject;           // offset: 0x8 ordinal: 0x2
  struct _LIST_ENTRY NumaNodeList;               // offset: 0x10 ordinal: 0x3
  struct _LIST_ENTRY VolumeList;                 // offset: 0x20 ordinal: 0x4
  ULONG VolumeCount;                             // offset: 0x30 ordinal: 0x5
  struct _KEVENT LastVolumeEvent;                // offset: 0x38 ordinal: 0x6
  struct _LIST_ENTRY DeletedVolumeList;          // offset: 0x50 ordinal: 0x7
  struct _LIST_ENTRY DeletePVCMWorkerThreadList; // offset: 0x60 ordinal: 0x8
  struct _CC_NUMA_NODE *NumaNodeBlock[64];       // offset: 0x70 ordinal: 0x9
  struct _LIST_ENTRY CleanSharedCacheMapList;    // offset: 0x270 ordinal: 0xa
  struct _LIST_ENTRY
      CleanSharedCacheMapWithLogHandleList; // offset: 0x280 ordinal: 0xb
  struct _SHARED_CACHE_MAP_LIST_CURSOR
      DirtySharedCacheMapList; // offset: 0x290 ordinal: 0xc
  struct _SHARED_CACHE_MAP_LIST_CURSOR
      LazyWriteCursor; // offset: 0x2a8 ordinal: 0xd
  struct _LIST_ENTRY
      DirtySharedCacheMapWithLogHandleList; // offset: 0x2c0 ordinal: 0xe
  ULONGLONG PrivateLock;                    // offset: 0x300 ordinal: 0xf
  ULONG ConsecutiveWorklessLazyScanCount;   // offset: 0x308 ordinal: 0x10
  UCHAR ForcedDisableLazywriteScan;         // offset: 0x30c ordinal: 0x11
  ULONGLONG WorkQueueLock;                  // offset: 0x340 ordinal: 0x12
  ULONG NumberWorkerThreads;                // offset: 0x348 ordinal: 0x13
  struct _LIST_ENTRY PostTickWorkQueue;     // offset: 0x350 ordinal: 0x14
  ULONG MaxExtraWriteBehindThreads;         // offset: 0x360 ordinal: 0x15
  ULONG MaxCacheMapUninitThreads;           // offset: 0x364 ordinal: 0x16
  UCHAR QueueThrottle;                      // offset: 0x368 ordinal: 0x17
  ULONG PostTickWorkItemCount;              // offset: 0x36c ordinal: 0x18
  struct _KEVENT LowMemoryEvent;            // offset: 0x370 ordinal: 0x19
  struct _KEVENT PowerEvent;                // offset: 0x388 ordinal: 0x1a
  struct _KEVENT WaitingForTeardownEvent;   // offset: 0x3a0 ordinal: 0x1b
  struct _KEVENT CoalescingFlushEvent;      // offset: 0x3b8 ordinal: 0x1c
  ULONG PagesYetToWrite;                    // offset: 0x3d0 ordinal: 0x1d
  struct _LAZY_WRITER LazyWriter;           // offset: 0x3d8 ordinal: 0x1e
  struct _DIRTY_PAGE_STATISTICS
      DirtyPageStatistics; // offset: 0x420 ordinal: 0x1f
  struct _DIRTY_PAGE_THRESHOLDS
      DirtyPageThresholds; // offset: 0x438 ordinal: 0x20
  struct _WRITE_BEHIND_THROUGHPUT
      *ThroughputStats;                           // offset: 0x470 ordinal: 0x21
  ULONGLONG AverageAvailablePages;                // offset: 0x478 ordinal: 0x22
  ULONGLONG AverageDirtyPages;                    // offset: 0x480 ordinal: 0x23
  ULONGLONG PagesSkippedDueToHotSpot;             // offset: 0x488 ordinal: 0x24
  struct _LIST_ENTRY DeferredWrites;              // offset: 0x490 ordinal: 0x25
  ULONGLONG DeferredWriteSpinLock;                // offset: 0x4c0 ordinal: 0x26
  struct _EX_PUSH_LOCK AsyncReadWorkQueueLock;    // offset: 0x4c8 ordinal: 0x27
  struct _LIST_ENTRY VacbFreeHighPriorityList;    // offset: 0x4d0 ordinal: 0x28
  ULONG NumberOfFreeHighPriorityVacbs;            // offset: 0x4e0 ordinal: 0x29
  struct _ETHREAD *LowPriWorkerThread;            // offset: 0x4e8 ordinal: 0x2a
  struct _SHARED_CACHE_MAP *LowPriSharedCacheMap; // offset: 0x4f0 ordinal: 0x2b
  LONG LowPriOldCpuPriority;                      // offset: 0x4f8 ordinal: 0x2c
  enum _IO_PRIORITY_HINT LowPriOldIoPriority;     // offset: 0x4fc ordinal: 0x2d
  struct _EX_PUSH_LOCK
      LowPriorityWorkerThreadLock;      // offset: 0x500 ordinal: 0x2e
  ULONG MaxNumberOfWriteBehindThreads;  // offset: 0x508 ordinal: 0x2f
  UCHAR CoalescingState;                // offset: 0x50c ordinal: 0x30
  UCHAR ActivePartition;                // offset: 0x50d ordinal: 0x31
  UCHAR RundownPhase;                   // offset: 0x50e ordinal: 0x32
  LONGLONG RefCount;                    // offset: 0x510 ordinal: 0x33
  struct _KEVENT ExitEvent;             // offset: 0x518 ordinal: 0x34
  struct _KEVENT FinalDereferenceEvent; // offset: 0x530 ordinal: 0x35
  VOID *LazyWriteScanThreadHandle;      // offset: 0x548 ordinal: 0x36
  struct _CC_LWS_PACKET LWSPacket;      // offset: 0x550 ordinal: 0x37
} _CC_PARTITION;

// 0x680 bytes (sizeof)
typedef struct _PRIVATE_VOLUME_CACHEMAP {
  SHORT NodeTypeCode;                         // offset: 0x0 ordinal: 0x0
  SHORT NodeByteSize;                         // offset: 0x2 ordinal: 0x1
  ULONG UseCount;                             // offset: 0x4 ordinal: 0x2
  LONGLONG RefCount;                          // offset: 0x8 ordinal: 0x3
  struct _DEVICE_OBJECT *DeviceObject;        // offset: 0x10 ordinal: 0x4
  ULONG VolumeId;                             // offset: 0x18 ordinal: 0x5
  struct _CC_PARTITION *Partition;            // offset: 0x20 ordinal: 0x6
  struct _VOLUME_CACHE_MAP *VolumeCacheMap;   // offset: 0x28 ordinal: 0x7
  struct _LIST_ENTRY NumaNodeList;            // offset: 0x30 ordinal: 0x8
  struct _CC_NUMA_NODE *NumaNodeBlock[64];    // offset: 0x40 ordinal: 0x9
  struct _LIST_ENTRY PartitionVolumeLinks;    // offset: 0x240 ordinal: 0xa
  struct _LIST_ENTRY VolumeCacheMapLinks;     // offset: 0x250 ordinal: 0xb
  struct _LIST_ENTRY CleanSharedCacheMapList; // offset: 0x260 ordinal: 0xc
  struct _LIST_ENTRY
      CleanSharedCacheMapWithLogHandleList; // offset: 0x270 ordinal: 0xd
  struct _SHARED_CACHE_MAP_LIST_CURSOR
      DirtySharedCacheMapList; // offset: 0x280 ordinal: 0xe
  struct _SHARED_CACHE_MAP_LIST_CURSOR
      LazyWriteCursor; // offset: 0x298 ordinal: 0xf
  struct _LIST_ENTRY
      DirtySharedCacheMapWithLogHandleList; // offset: 0x2b0 ordinal: 0x10
  ULONG ConsecutiveWorklessLazyScanCount;   // offset: 0x2c0 ordinal: 0x11
  UCHAR ForcedDisableLazywriteScan;         // offset: 0x2c4 ordinal: 0x12
  ULONGLONG WorkQueueLock;                  // offset: 0x300 ordinal: 0x13
  ULONG NumberWorkerThreads;                // offset: 0x308 ordinal: 0x14
  struct _LIST_ENTRY PostTickWorkQueue;     // offset: 0x310 ordinal: 0x15
  ULONG MaxExtraWriteBehindThreads;         // offset: 0x320 ordinal: 0x16
  ULONG MaxCacheMapUninitThreads;           // offset: 0x324 ordinal: 0x17
  UCHAR QueueThrottle;                      // offset: 0x328 ordinal: 0x18
  ULONG PostTickWorkItemCount;              // offset: 0x32c ordinal: 0x19
  struct _KEVENT LowMemoryEvent;            // offset: 0x330 ordinal: 0x1a
  struct _KEVENT PowerEvent;                // offset: 0x348 ordinal: 0x1b
  struct _KEVENT WaitingForTeardownEvent;   // offset: 0x360 ordinal: 0x1c
  struct _KEVENT CoalescingFlushEvent;      // offset: 0x378 ordinal: 0x1d
  ULONG PagesYetToWrite;                    // offset: 0x390 ordinal: 0x1e
  struct _LAZY_WRITER LazyWriter;           // offset: 0x398 ordinal: 0x1f
  struct _DIRTY_PAGE_STATISTICS
      DirtyPageStatistics; // offset: 0x3e0 ordinal: 0x20
  struct _DIRTY_PAGE_THRESHOLDS
      DirtyPageThresholds; // offset: 0x3f8 ordinal: 0x21
  struct _WRITE_BEHIND_THROUGHPUT
      *ThroughputStats;                        // offset: 0x430 ordinal: 0x22
  ULONGLONG AverageAvailablePages;             // offset: 0x438 ordinal: 0x23
  ULONGLONG AverageDirtyPages;                 // offset: 0x440 ordinal: 0x24
  ULONGLONG PagesSkippedDueToHotSpot;          // offset: 0x448 ordinal: 0x25
  struct _LIST_ENTRY DeferredWrites;           // offset: 0x450 ordinal: 0x26
  ULONGLONG DeferredWriteSpinLock;             // offset: 0x480 ordinal: 0x27
  struct _EX_PUSH_LOCK AsyncReadWorkQueueLock; // offset: 0x488 ordinal: 0x28
  ULONG MaxNumberOfWriteBehindThreads;         // offset: 0x490 ordinal: 0x29
  UCHAR CoalescingState;                       // offset: 0x494 ordinal: 0x2a
  UCHAR InitComplete;                          // offset: 0x495 ordinal: 0x2b
  struct _KEVENT ExitEvent;                    // offset: 0x498 ordinal: 0x2c
  struct _KEVENT FinalDereferenceEvent;        // offset: 0x4b0 ordinal: 0x2d
  VOID *LazyWriteScanThreadHandle;             // offset: 0x4c8 ordinal: 0x2e
  struct _CC_LWS_PACKET LWSPacket;             // offset: 0x4d0 ordinal: 0x2f
  struct _LIST_ENTRY ExternalCacheList;        // offset: 0x4e0 ordinal: 0x30
  ULONG ThroughputIdx;                         // offset: 0x4f0 ordinal: 0x31
  ULONGLONG AvgPagesPerSecond;                 // offset: 0x4f8 ordinal: 0x32
  ULONGLONG ThroughputHistory[32];             // offset: 0x500 ordinal: 0x33
  ULONG DirtyThresholdInSeconds;               // offset: 0x600 ordinal: 0x34
  ULONG DirtyPageTargetInSeconds;              // offset: 0x604 ordinal: 0x35
  struct _LIST_ENTRY QuickLWSThreadList;       // offset: 0x608 ordinal: 0x36
  struct _KEVENT QuickLazyScanEvent;           // offset: 0x618 ordinal: 0x37
  union _LARGE_INTEGER PrevLazyWriteScanTime;  // offset: 0x630 ordinal: 0x38
  ULONG AsyncLazywriteQueueDepth;              // offset: 0x638 ordinal: 0x39
  ULONG MaxAsyncLazywriteCompletionWorkers;    // offset: 0x63c ordinal: 0x3a
  ULONG Flags;                                 // offset: 0x640 ordinal: 0x3b
} _PRIVATE_VOLUME_CACHEMAP;

// 0x68 bytes (sizeof)
typedef struct _DEFERRED_WRITE {
  SHORT NodeTypeCode;                    // offset: 0x0 ordinal: 0x0
  SHORT NodeByteSize;                    // offset: 0x2 ordinal: 0x1
  struct _FILE_OBJECT *FileObject;       // offset: 0x8 ordinal: 0x2
  ULONG BytesToWrite;                    // offset: 0x10 ordinal: 0x3
  struct _LIST_ENTRY DeferredWriteLinks; // offset: 0x18 ordinal: 0x4
  struct _KEVENT *Event;                 // offset: 0x28 ordinal: 0x5
  VOID (*PostRoutine)(VOID *, VOID *);   // offset: 0x30 ordinal: 0x6
  VOID *Context1;                        // offset: 0x38 ordinal: 0x7
  VOID *Context2;                        // offset: 0x40 ordinal: 0x8
  struct _CC_PARTITION *Partition;       // offset: 0x48 ordinal: 0x9
  struct _PRIVATE_VOLUME_CACHEMAP
      *PrivateVolumeCacheMap;     // offset: 0x50 ordinal: 0xa
  UCHAR SoftThrottle;             // offset: 0x58 ordinal: 0xb
  union _LARGE_INTEGER TimeAdded; // offset: 0x60 ordinal: 0xc
} _DEFERRED_WRITE;

// 0x1b0 bytes (sizeof)
typedef struct _CC_NUMA_NODE {
  SHORT NodeTypeCode;              // offset: 0x0 ordinal: 0x0
  SHORT NodeByteSize;              // offset: 0x2 ordinal: 0x1
  enum _CC_NUMA_TYPE NumaNodeType; // offset: 0x4 ordinal: 0x2
  struct _CC_PARTITION *Partition; // offset: 0x8 ordinal: 0x3
  struct _PRIVATE_VOLUME_CACHEMAP
      *PrivateVolumeCacheMap;                      // offset: 0x10 ordinal: 0x4
  ULONG NodeNumber;                                // offset: 0x18 ordinal: 0x5
  struct _LIST_ENTRY NodeList;                     // offset: 0x20 ordinal: 0x6
  ULONG NumberActiveWorkerThreads;                 // offset: 0x30 ordinal: 0x7
  struct _LIST_ENTRY IdleWorkerThreadList;         // offset: 0x38 ordinal: 0x8
  struct _LIST_ENTRY FastTeardownWorkQueue;        // offset: 0x48 ordinal: 0x9
  struct _LIST_ENTRY ExpressWorkQueue;             // offset: 0x58 ordinal: 0xa
  struct _LIST_ENTRY RegularWorkQueue;             // offset: 0x68 ordinal: 0xb
  struct _LIST_ENTRY CleanCachemapUninitWorkQueue; // offset: 0x78 ordinal: 0xc
  struct _LIST_ENTRY
      IdleExtraWriteBehindThreadList;              // offset: 0x88 ordinal: 0xd
  ULONG ActiveExtraWriteBehindThreads;             // offset: 0x98 ordinal: 0xe
  struct _LIST_ENTRY IdleCacheMapUninitThreadList; // offset: 0xa0 ordinal: 0xf
  ULONG ActiveCacheMapUninitThreads;               // offset: 0xb0 ordinal: 0x10
  ULONG ThreadsActiveBeforeThrottle;               // offset: 0xb4 ordinal: 0x11
  ULONG ExtraWBThreadsActiveBeforeThrottle;        // offset: 0xb8 ordinal: 0x12
  ULONG ExecutingWriteBehindWorkItems;             // offset: 0xbc ordinal: 0x13
  ULONG ExecutingHighPriorityWorkItem;             // offset: 0xc0 ordinal: 0x14
  LONG ThroughputTrend;                            // offset: 0xc4 ordinal: 0x15
  union _LARGE_INTEGER
      PrevRegularQueueItemRunTime;                 // offset: 0xc8 ordinal: 0x16
  union _LARGE_INTEGER PrevExtraWBThreadCheckTime; // offset: 0xd0 ordinal: 0x17
  UCHAR AddExtraWriteBehindThreads;                // offset: 0xd8 ordinal: 0x18
  UCHAR RemoveExtraThreadPending;                  // offset: 0xd9 ordinal: 0x19
  struct _LIST_ENTRY
      *IdleAsyncReadWorkerThreadList;            // offset: 0xe0 ordinal: 0x1a
  ULONG *NumberActiveAsyncReadWorkerThreads;     // offset: 0xe8 ordinal: 0x1b
  ULONG *NumberActiveCompleteAsyncReadWorkItems; // offset: 0xf0 ordinal: 0x1c
  struct _LIST_ENTRY *AsyncReadWorkQueue;        // offset: 0xf8 ordinal: 0x1d
  struct _LIST_ENTRY
      *AsyncReadCompletionWorkQueue;        // offset: 0x100 ordinal: 0x1e
  struct _KEVENT *NewAsyncReadRequestEvent; // offset: 0x108 ordinal: 0x1f
  struct _ASYNC_READ_THREAD_STATS
      *ReaderThreadsStats; // offset: 0x110 ordinal: 0x20
  struct _LIST_ENTRY
      IdleAsyncLazywriteWorkerThreadList;        // offset: 0x118 ordinal: 0x21
  ULONG NumberActiveAsyncLazywriteWorkerThreads; // offset: 0x128 ordinal: 0x22
  struct _LIST_ENTRY AsyncLazywriteWorkQueue;    // offset: 0x130 ordinal: 0x23
  struct _KEVENT NewAsyncLazywriteRequestEvent;  // offset: 0x140 ordinal: 0x24
  struct _ASYNC_LAZYWRITE_THREAD_STATS
      LazywriterThreadsStats; // offset: 0x158 ordinal: 0x25
  struct _LIST_ENTRY
      IdleCompleteAsyncLazywriteWorkerThreadList; // offset: 0x188 ordinal: 0x26
  ULONG
  NumberActiveCompleteAsyncLazywriteWorkers; // offset: 0x198 ordinal: 0x27
  struct _LIST_ENTRY
      AsyncLazywriteCompletionWorkQueue; // offset: 0x1a0 ordinal: 0x28
} _CC_NUMA_NODE;

// 0x260 bytes (sizeof)
typedef struct _SHARED_CACHE_MAP {
  SHORT NodeTypeCode;                     // offset: 0x0 ordinal: 0x0
  SHORT NodeByteSize;                     // offset: 0x2 ordinal: 0x1
  ULONG OpenCount;                        // offset: 0x4 ordinal: 0x2
  union _LARGE_INTEGER FileSize;          // offset: 0x8 ordinal: 0x3
  struct _LIST_ENTRY BcbList;             // offset: 0x10 ordinal: 0x4
  union _LARGE_INTEGER SectionSize;       // offset: 0x20 ordinal: 0x5
  union _LARGE_INTEGER ValidDataLength;   // offset: 0x28 ordinal: 0x6
  union _LARGE_INTEGER ValidDataGoal;     // offset: 0x30 ordinal: 0x7
  struct _VACB *InitialVacbs[4];          // offset: 0x38 ordinal: 0x8
  struct _VACB **Vacbs;                   // offset: 0x58 ordinal: 0x9
  struct _EX_FAST_REF FileObjectFastRef;  // offset: 0x60 ordinal: 0xa
  struct _EX_PUSH_LOCK VacbLock;          // offset: 0x68 ordinal: 0xb
  ULONG DirtyPages;                       // offset: 0x70 ordinal: 0xc
  struct _LIST_ENTRY LoggedStreamLinks;   // offset: 0x78 ordinal: 0xd
  struct _LIST_ENTRY SharedCacheMapLinks; // offset: 0x88 ordinal: 0xe
  ULONG Flags;                            // offset: 0x98 ordinal: 0xf
  ULONG Flags2;                           // offset: 0x9c ordinal: 0x10
  LONG Status;                            // offset: 0xa0 ordinal: 0x11
  struct _MBCB *Mbcb;                     // offset: 0xa8 ordinal: 0x12
  VOID *Section;                          // offset: 0xb0 ordinal: 0x13
  struct _KEVENT *CreateEvent;            // offset: 0xb8 ordinal: 0x14
  struct _KEVENT *WaitOnActiveCount;      // offset: 0xc0 ordinal: 0x15
  ULONG PagesToWrite;                     // offset: 0xc8 ordinal: 0x16
  LONGLONG BeyondLastFlush;               // offset: 0xd0 ordinal: 0x17
  union {
    struct _CACHE_MANAGER_CALLBACKS *Callbacks; // offset: 0xd8 ordinal: 0x18
    struct _CACHE_MANAGER_CALLBACKS_EX
        *CallbacksEx; // offset: 0xd8 ordinal: 0x19
  };
  VOID *LazyWriteContext;         // offset: 0xe0 ordinal: 0x1a
  struct _LIST_ENTRY PrivateList; // offset: 0xe8 ordinal: 0x1b
  union {
    struct _LOGGED_STREAM_CALLBACK_V1 V1; // offset: 0xf8 ordinal: 0x1c
    struct _LOGGED_STREAM_CALLBACK_V2 V2; // offset: 0xf8 ordinal: 0x1d
  };
  union _LARGE_INTEGER LargestLSN; // offset: 0x108 ordinal: 0x1e
  ULONG DirtyPageThreshold;        // offset: 0x110 ordinal: 0x1f
  ULONG LazyWritePassCount;        // offset: 0x114 ordinal: 0x20
  struct _CACHE_UNINITIALIZE_EVENT
      *UninitializeEvent;                      // offset: 0x118 ordinal: 0x21
  struct _FAST_MUTEX BcbLock;                  // offset: 0x120 ordinal: 0x22
  union _LARGE_INTEGER LastUnmapBehindOffset;  // offset: 0x158 ordinal: 0x23
  struct _KEVENT Event;                        // offset: 0x160 ordinal: 0x24
  union _LARGE_INTEGER HighWaterMappingOffset; // offset: 0x178 ordinal: 0x25
  struct _PRIVATE_CACHE_MAP PrivateCacheMap;   // offset: 0x180 ordinal: 0x26
  VOID *WriteBehindWorkQueueEntry;             // offset: 0x1f8 ordinal: 0x27
  struct _VOLUME_CACHE_MAP *VolumeCacheMap;    // offset: 0x200 ordinal: 0x28
  ULONG ProcImagePathHash;                     // offset: 0x208 ordinal: 0x29
  ULONG WritesInProgress;                      // offset: 0x20c ordinal: 0x2a
  ULONG AsyncReadRequestCount;                 // offset: 0x210 ordinal: 0x2b
  struct _CC_PARTITION *Partition;             // offset: 0x218 ordinal: 0x2c
  ULONG InternalRefCount;                      // offset: 0x220 ordinal: 0x2d
  ULONG NumMappedVacb;                         // offset: 0x224 ordinal: 0x2e
  ULONG NumActiveVacb;                         // offset: 0x228 ordinal: 0x2f
  ULONG IdealNodeForWriteBehind;               // offset: 0x22c ordinal: 0x30
  ULONG IdealNodeNumber;                       // offset: 0x230 ordinal: 0x31
  struct _LIST_ENTRY VolSharedCacheMapLinks;   // offset: 0x238 ordinal: 0x32
  struct _LIST_ENTRY VolLoggedStreamLinks;     // offset: 0x248 ordinal: 0x33
  struct _PRIVATE_VOLUME_CACHEMAP
      *PrivateVolumeCacheMap; // offset: 0x258 ordinal: 0x34
} _SHARED_CACHE_MAP;

// 0x2d8 bytes (sizeof)
typedef struct _KTRANSACTION {
  struct _KEVENT OutcomeEvent;  // offset: 0x0 ordinal: 0x0
  ULONG cookie;                 // offset: 0x18 ordinal: 0x1
  struct _KMUTANT Mutex;        // offset: 0x20 ordinal: 0x2
  struct _KTRANSACTION *TreeTx; // offset: 0x58 ordinal: 0x3
  struct _KTMOBJECT_NAMESPACE_LINK
      GlobalNamespaceLink;                          // offset: 0x60 ordinal: 0x4
  struct _KTMOBJECT_NAMESPACE_LINK TmNamespaceLink; // offset: 0x88 ordinal: 0x5
  struct _GUID UOW;                                 // offset: 0xb0 ordinal: 0x6
  enum _KTRANSACTION_STATE State;                   // offset: 0xc0 ordinal: 0x7
  ULONG Flags;                                      // offset: 0xc4 ordinal: 0x8
  struct _LIST_ENTRY EnlistmentHead;                // offset: 0xc8 ordinal: 0x9
  ULONG EnlistmentCount;                            // offset: 0xd8 ordinal: 0xa
  ULONG RecoverableEnlistmentCount;                 // offset: 0xdc ordinal: 0xb
  ULONG PrePrepareRequiredEnlistmentCount;          // offset: 0xe0 ordinal: 0xc
  ULONG PrepareRequiredEnlistmentCount;             // offset: 0xe4 ordinal: 0xd
  ULONG OutcomeRequiredEnlistmentCount;             // offset: 0xe8 ordinal: 0xe
  ULONG PendingResponses;                           // offset: 0xec ordinal: 0xf
  struct _KENLISTMENT *SuperiorEnlistment;   // offset: 0xf0 ordinal: 0x10
  union _CLS_LSN LastLsn;                    // offset: 0xf8 ordinal: 0x11
  struct _LIST_ENTRY PromotedEntry;          // offset: 0x100 ordinal: 0x12
  struct _KTRANSACTION *PromoterTransaction; // offset: 0x110 ordinal: 0x13
  VOID *PromotePropagation;                  // offset: 0x118 ordinal: 0x14
  ULONG IsolationLevel;                      // offset: 0x120 ordinal: 0x15
  ULONG IsolationFlags;                      // offset: 0x124 ordinal: 0x16
  union _LARGE_INTEGER Timeout;              // offset: 0x128 ordinal: 0x17
  struct _UNICODE_STRING Description;        // offset: 0x130 ordinal: 0x18
  struct _KTHREAD *RollbackThread;           // offset: 0x140 ordinal: 0x19
  struct _WORK_QUEUE_ITEM RollbackWorkItem;  // offset: 0x148 ordinal: 0x1a
  struct _KDPC RollbackDpc;                  // offset: 0x168 ordinal: 0x1b
  struct _KTIMER RollbackTimer;              // offset: 0x1a8 ordinal: 0x1c
  struct _LIST_ENTRY LsnOrderedEntry;        // offset: 0x1e8 ordinal: 0x1d
  enum _KTRANSACTION_OUTCOME Outcome;        // offset: 0x1f8 ordinal: 0x1e
  struct _KTM *Tm;                           // offset: 0x200 ordinal: 0x1f
  LONGLONG CommitReservation;                // offset: 0x208 ordinal: 0x20
  struct _KTRANSACTION_HISTORY
      TransactionHistory[10];                 // offset: 0x210 ordinal: 0x21
  ULONG TransactionHistoryCount;              // offset: 0x260 ordinal: 0x22
  VOID *DTCPrivateInformation;                // offset: 0x268 ordinal: 0x23
  ULONG DTCPrivateInformationLength;          // offset: 0x270 ordinal: 0x24
  struct _KMUTANT DTCPrivateInformationMutex; // offset: 0x278 ordinal: 0x25
  VOID *PromotedTxSelfHandle;                 // offset: 0x2b0 ordinal: 0x26
  ULONG PendingPromotionCount;                // offset: 0x2b8 ordinal: 0x27
  struct _KEVENT PromotionCompletedEvent;     // offset: 0x2c0 ordinal: 0x28
} _KTRANSACTION;

// 0x440 bytes (sizeof)
typedef struct _MI_PARTITION_SEGMENTS {
  LONG SegmentListLock;                   // offset: 0x0 ordinal: 0x0
  ULONG DeleteOnCloseCount;               // offset: 0x4 ordinal: 0x1
  LONGLONG FsControlAreaCount;            // offset: 0x8 ordinal: 0x2
  LONGLONG PfControlAreaCount;            // offset: 0x10 ordinal: 0x3
  LONGLONG CloneHeaderCount;              // offset: 0x18 ordinal: 0x4
  struct _KEVENT DeleteSubsectionCleanup; // offset: 0x20 ordinal: 0x5
  struct _KEVENT UnusedSegmentCleanup;    // offset: 0x38 ordinal: 0x6
  ULONGLONG SubsectionDeletePtes;         // offset: 0x50 ordinal: 0x7
  struct _MMPAGE_FILE_EXPANSION
      AttemptForCantExtend; // offset: 0x58 ordinal: 0x8
  struct _MMDEREFERENCE_SEGMENT_HEADER
      DereferenceSegmentHeader;              // offset: 0xb0 ordinal: 0x9
  struct _LIST_ENTRY DeleteOnCloseList;      // offset: 0x100 ordinal: 0xa
  struct _KTIMER DeleteOnCloseTimer;         // offset: 0x110 ordinal: 0xb
  UCHAR DeleteOnCloseTimerActive;            // offset: 0x150 ordinal: 0xc
  UCHAR SegmentDereferenceThreadExists;      // offset: 0x151 ordinal: 0xd
  VOID *SegmentDereferenceActiveControlArea; // offset: 0x158 ordinal: 0xe
  ULONGLONG UnusedSegmentPagedPool;          // offset: 0x160 ordinal: 0xf
  struct _LIST_ENTRY UnusedSegmentList;      // offset: 0x168 ordinal: 0x10
  struct _LIST_ENTRY UnusedSubsectionList;   // offset: 0x178 ordinal: 0x11
  struct _LIST_ENTRY DeleteSubsectionList;   // offset: 0x188 ordinal: 0x12
  struct _KEVENT ControlAreaDeleteEvent;     // offset: 0x198 ordinal: 0x13
  struct _SINGLE_LIST_ENTRY
      ControlAreaDeleteList; // offset: 0x1b0 ordinal: 0x14
  struct _MI_DEFERRED_PFNS_TO_FREE
      FreedSystemCacheViews[4]; // offset: 0x1b8 ordinal: 0x15
  struct _MI_DEFERRED_PFNS_TO_FREE
      FreedSystemCacheViewsReady; // offset: 0x238 ordinal: 0x16
  struct _MI_DEFERRED_PFNS_TO_FREE
      FreedSystemCachePdesReady;             // offset: 0x258 ordinal: 0x17
  struct _KEVENT CloneDereferenceEvent;      // offset: 0x278 ordinal: 0x18
  union _SLIST_HEADER CloneProtosSListHead;  // offset: 0x290 ordinal: 0x19
  struct _EX_PUSH_LOCK SystemCacheInitLock;  // offset: 0x2a0 ordinal: 0x1a
  ULONG PagefileExtensionWaiters;            // offset: 0x2a8 ordinal: 0x1b
  ULONG PagefileExtensionRequests;           // offset: 0x2ac ordinal: 0x1c
  struct _KEVENT PagefileExtensionWaitEvent; // offset: 0x2b0 ordinal: 0x1d
  struct _MI_CROSS_PARTITION_CHARGES
      SharedCharges[9];                    // offset: 0x2c8 ordinal: 0x1e
  struct _KEVENT *SharedChargesDrainEvent; // offset: 0x3e8 ordinal: 0x1f
  struct _KEVENT *ControlAreasDrainEvent;  // offset: 0x3f0 ordinal: 0x20
  struct _KEVENT *CloneHeaderDrainEvent;   // offset: 0x3f8 ordinal: 0x21
  struct _EX_RUNDOWN_REF_CACHE_AWARE
      *ProbeRundownReference; // offset: 0x400 ordinal: 0x22
} _MI_PARTITION_SEGMENTS;

// 0xb0 bytes (sizeof)
typedef struct _POP_FX_WORK_ORDER_WATCHDOG_INFO {
  struct _LIST_ENTRY Link;                       // offset: 0x0 ordinal: 0x0
  struct _KTIMER Timer;                          // offset: 0x10 ordinal: 0x1
  struct _KDPC Dpc;                              // offset: 0x50 ordinal: 0x2
  struct _POP_FX_WORK_ORDER *WorkOrder;          // offset: 0x90 ordinal: 0x3
  struct _PEP_WORK_INFORMATION *CurrentWorkInfo; // offset: 0x98 ordinal: 0x4
  ULONGLONG WatchdogStart;                       // offset: 0xa0 ordinal: 0x5
  struct _KTHREAD *WorkerThread;                 // offset: 0xa8 ordinal: 0x6
} _POP_FX_WORK_ORDER_WATCHDOG_INFO;

// 0x4218 bytes (sizeof)
typedef struct _KTIMER_TABLE {
  struct _KTIMER *TimerExpiry[64];                 // offset: 0x0 ordinal: 0x0
  struct _KTIMER_TABLE_ENTRY TimerEntries[2][256]; // offset: 0x200 ordinal: 0x1
  struct _KTIMER_TABLE_STATE TableState; // offset: 0x4200 ordinal: 0x2
} _KTIMER_TABLE;

// 0xa0 bytes (sizeof)
typedef struct _TIMEZONE_CHANGE_EVENT {
  struct _KDPC Dpc;                 // offset: 0x0 ordinal: 0x0
  struct _KTIMER Timer;             // offset: 0x40 ordinal: 0x1
  struct _WORK_QUEUE_ITEM WorkItem; // offset: 0x80 ordinal: 0x2
} _TIMEZONE_CHANGE_EVENT;

// 0x3f0 bytes (sizeof)
typedef struct _EX_TIMEZONE_STATE {
  struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION
      TimeZoneInformation;                   // offset: 0x0 ordinal: 0x0
  ULONG CurrentTimeZoneId;                   // offset: 0x1b0 ordinal: 0x1
  LONG LastTimeZoneBias;                     // offset: 0x1b4 ordinal: 0x2
  union _LARGE_INTEGER TimeZoneBias;         // offset: 0x1b8 ordinal: 0x3
  struct _TIMEZONE_CHANGE_EVENT TimeZone;    // offset: 0x1c0 ordinal: 0x4
  struct _TIMEZONE_CHANGE_EVENT Century;     // offset: 0x260 ordinal: 0x5
  struct _TIMEZONE_CHANGE_EVENT NextYear;    // offset: 0x300 ordinal: 0x6
  LONG OkToTimeZoneRefresh;                  // offset: 0x3a0 ordinal: 0x7
  union _LARGE_INTEGER NextCenturyTimeInUTC; // offset: 0x3a8 ordinal: 0x8
  struct _TIME_FIELDS
      NextCenturyTimeFieldsInLocalTime;   // offset: 0x3b0 ordinal: 0x9
  union _LARGE_INTEGER NextYearTimeInUTC; // offset: 0x3c0 ordinal: 0xa
  struct _TIME_FIELDS
      NextYearTimeFieldsInLocalTime;           // offset: 0x3c8 ordinal: 0xb
  SHORT LastDynamicTimeZoneYear;               // offset: 0x3d8 ordinal: 0xc
  union _LARGE_INTEGER NextSystemCutoverInUTC; // offset: 0x3e0 ordinal: 0xd
  ULONG RefreshFailures;                       // offset: 0x3e8 ordinal: 0xe
} _EX_TIMEZONE_STATE;

// 0x7d0 bytes (sizeof)
typedef struct _PEB {
  UCHAR InheritedAddressSpace;    // offset: 0x0 ordinal: 0x0
  UCHAR ReadImageFileExecOptions; // offset: 0x1 ordinal: 0x1
  UCHAR BeingDebugged;            // offset: 0x2 ordinal: 0x2
  union {
    UCHAR BitField;                // offset: 0x3 ordinal: 0x3
    UCHAR ImageUsesLargePages : 1; // offset: 0x3 ordinal: 0x4
  };
  UCHAR IsProtectedProcess : 1;           // offset: 0x3 ordinal: 0x5
  UCHAR IsImageDynamicallyRelocated : 1;  // offset: 0x3 ordinal: 0x6
  UCHAR SkipPatchingUser32Forwarders : 1; // offset: 0x3 ordinal: 0x7
  UCHAR IsPackagedProcess : 1;            // offset: 0x3 ordinal: 0x8
  UCHAR IsAppContainer : 1;               // offset: 0x3 ordinal: 0x9
  UCHAR IsProtectedProcessLight : 1;      // offset: 0x3 ordinal: 0xa
  UCHAR IsLongPathAwareProcess : 1;       // offset: 0x3 ordinal: 0xb
  UCHAR Padding0[4];                      // offset: 0x4 ordinal: 0xc
  VOID *Mutant;                           // offset: 0x8 ordinal: 0xd
  VOID *ImageBaseAddress;                 // offset: 0x10 ordinal: 0xe
  struct _PEB_LDR_DATA *Ldr;              // offset: 0x18 ordinal: 0xf
  struct _RTL_USER_PROCESS_PARAMETERS
      *ProcessParameters;                    // offset: 0x20 ordinal: 0x10
  VOID *SubSystemData;                       // offset: 0x28 ordinal: 0x11
  VOID *ProcessHeap;                         // offset: 0x30 ordinal: 0x12
  struct _RTL_CRITICAL_SECTION *FastPebLock; // offset: 0x38 ordinal: 0x13
  union _SLIST_HEADER *AtlThunkSListPtr;     // offset: 0x40 ordinal: 0x14
  VOID *IFEOKey;                             // offset: 0x48 ordinal: 0x15
  union {
    ULONG CrossProcessFlags; // offset: 0x50 ordinal: 0x16
    ULONG ProcessInJob : 1;  // offset: 0x50 ordinal: 0x17
  };
  ULONG ProcessInitializing : 1;        // offset: 0x50 ordinal: 0x18
  ULONG ProcessUsingVEH : 1;            // offset: 0x50 ordinal: 0x19
  ULONG ProcessUsingVCH : 1;            // offset: 0x50 ordinal: 0x1a
  ULONG ProcessUsingFTH : 1;            // offset: 0x50 ordinal: 0x1b
  ULONG ProcessPreviouslyThrottled : 1; // offset: 0x50 ordinal: 0x1c
  ULONG ProcessCurrentlyThrottled : 1;  // offset: 0x50 ordinal: 0x1d
  ULONG ProcessImagesHotPatched : 1;    // offset: 0x50 ordinal: 0x1e
  ULONG ReservedBits0 : 24;             // offset: 0x50 ordinal: 0x1f
  UCHAR Padding1[4];                    // offset: 0x54 ordinal: 0x20
  union {
    VOID *KernelCallbackTable; // offset: 0x58 ordinal: 0x21
    VOID *UserSharedInfoPtr;   // offset: 0x58 ordinal: 0x22
  };
  ULONG SystemReserved;                        // offset: 0x60 ordinal: 0x23
  ULONG AtlThunkSListPtr32;                    // offset: 0x64 ordinal: 0x24
  VOID *ApiSetMap;                             // offset: 0x68 ordinal: 0x25
  ULONG TlsExpansionCounter;                   // offset: 0x70 ordinal: 0x26
  UCHAR Padding2[4];                           // offset: 0x74 ordinal: 0x27
  struct _RTL_BITMAP *TlsBitmap;               // offset: 0x78 ordinal: 0x28
  ULONG TlsBitmapBits[2];                      // offset: 0x80 ordinal: 0x29
  VOID *ReadOnlySharedMemoryBase;              // offset: 0x88 ordinal: 0x2a
  VOID *SharedData;                            // offset: 0x90 ordinal: 0x2b
  VOID **ReadOnlyStaticServerData;             // offset: 0x98 ordinal: 0x2c
  VOID *AnsiCodePageData;                      // offset: 0xa0 ordinal: 0x2d
  VOID *OemCodePageData;                       // offset: 0xa8 ordinal: 0x2e
  VOID *UnicodeCaseTableData;                  // offset: 0xb0 ordinal: 0x2f
  ULONG NumberOfProcessors;                    // offset: 0xb8 ordinal: 0x30
  ULONG NtGlobalFlag;                          // offset: 0xbc ordinal: 0x31
  union _LARGE_INTEGER CriticalSectionTimeout; // offset: 0xc0 ordinal: 0x32
  ULONGLONG HeapSegmentReserve;                // offset: 0xc8 ordinal: 0x33
  ULONGLONG HeapSegmentCommit;                 // offset: 0xd0 ordinal: 0x34
  ULONGLONG HeapDeCommitTotalFreeThreshold;    // offset: 0xd8 ordinal: 0x35
  ULONGLONG HeapDeCommitFreeBlockThreshold;    // offset: 0xe0 ordinal: 0x36
  ULONG NumberOfHeaps;                         // offset: 0xe8 ordinal: 0x37
  ULONG MaximumNumberOfHeaps;                  // offset: 0xec ordinal: 0x38
  VOID **ProcessHeaps;                         // offset: 0xf0 ordinal: 0x39
  VOID *GdiSharedHandleTable;                  // offset: 0xf8 ordinal: 0x3a
  VOID *ProcessStarterHelper;                  // offset: 0x100 ordinal: 0x3b
  ULONG GdiDCAttributeList;                    // offset: 0x108 ordinal: 0x3c
  UCHAR Padding3[4];                           // offset: 0x10c ordinal: 0x3d
  struct _RTL_CRITICAL_SECTION *LoaderLock;    // offset: 0x110 ordinal: 0x3e
  ULONG OSMajorVersion;                        // offset: 0x118 ordinal: 0x3f
  ULONG OSMinorVersion;                        // offset: 0x11c ordinal: 0x40
  USHORT OSBuildNumber;                        // offset: 0x120 ordinal: 0x41
  USHORT OSCSDVersion;                         // offset: 0x122 ordinal: 0x42
  ULONG OSPlatformId;                          // offset: 0x124 ordinal: 0x43
  ULONG ImageSubsystem;                        // offset: 0x128 ordinal: 0x44
  ULONG ImageSubsystemMajorVersion;            // offset: 0x12c ordinal: 0x45
  ULONG ImageSubsystemMinorVersion;            // offset: 0x130 ordinal: 0x46
  UCHAR Padding4[4];                           // offset: 0x134 ordinal: 0x47
  ULONGLONG ActiveProcessAffinityMask;         // offset: 0x138 ordinal: 0x48
  ULONG GdiHandleBuffer[60];                   // offset: 0x140 ordinal: 0x49
  VOID (*PostProcessInitRoutine)();            // offset: 0x230 ordinal: 0x4a
  struct _RTL_BITMAP *TlsExpansionBitmap;      // offset: 0x238 ordinal: 0x4b
  ULONG TlsExpansionBitmapBits[32];            // offset: 0x240 ordinal: 0x4c
  ULONG SessionId;                             // offset: 0x2c0 ordinal: 0x4d
  UCHAR Padding5[4];                           // offset: 0x2c4 ordinal: 0x4e
  union _ULARGE_INTEGER AppCompatFlags;        // offset: 0x2c8 ordinal: 0x4f
  union _ULARGE_INTEGER AppCompatFlagsUser;    // offset: 0x2d0 ordinal: 0x50
  VOID *pShimData;                             // offset: 0x2d8 ordinal: 0x51
  VOID *AppCompatInfo;                         // offset: 0x2e0 ordinal: 0x52
  struct _UNICODE_STRING CSDVersion;           // offset: 0x2e8 ordinal: 0x53
  struct _ACTIVATION_CONTEXT_DATA
      *ActivationContextData; // offset: 0x2f8 ordinal: 0x54
  struct _ASSEMBLY_STORAGE_MAP
      *ProcessAssemblyStorageMap; // offset: 0x300 ordinal: 0x55
  struct _ACTIVATION_CONTEXT_DATA
      *SystemDefaultActivationContextData; // offset: 0x308 ordinal: 0x56
  struct _ASSEMBLY_STORAGE_MAP
      *SystemAssemblyStorageMap;                  // offset: 0x310 ordinal: 0x57
  ULONGLONG MinimumStackCommit;                   // offset: 0x318 ordinal: 0x58
  VOID *SparePointers[2];                         // offset: 0x320 ordinal: 0x59
  VOID *PatchLoaderData;                          // offset: 0x330 ordinal: 0x5a
  struct _CHPEV2_PROCESS_INFO *ChpeV2ProcessInfo; // offset: 0x338 ordinal: 0x5b
  ULONG AppModelFeatureState;                     // offset: 0x340 ordinal: 0x5c
  ULONG SpareUlongs[2];                           // offset: 0x344 ordinal: 0x5d
  USHORT ActiveCodePage;                          // offset: 0x34c ordinal: 0x5e
  USHORT OemCodePage;                             // offset: 0x34e ordinal: 0x5f
  USHORT UseCaseMapping;                          // offset: 0x350 ordinal: 0x60
  USHORT UnusedNlsField;                          // offset: 0x352 ordinal: 0x61
  VOID *WerRegistrationData;                      // offset: 0x358 ordinal: 0x62
  VOID *WerShipAssertPtr;                         // offset: 0x360 ordinal: 0x63
  VOID *EcCodeBitMap;                             // offset: 0x368 ordinal: 0x64
  VOID *pImageHeaderHash;                         // offset: 0x370 ordinal: 0x65
  union {
    ULONG TracingFlags;           // offset: 0x378 ordinal: 0x66
    ULONG HeapTracingEnabled : 1; // offset: 0x378 ordinal: 0x67
  };
  ULONG CritSecTracingEnabled : 1;              // offset: 0x378 ordinal: 0x68
  ULONG LibLoaderTracingEnabled : 1;            // offset: 0x378 ordinal: 0x69
  ULONG SpareTracingBits : 29;                  // offset: 0x378 ordinal: 0x6a
  UCHAR Padding6[4];                            // offset: 0x37c ordinal: 0x6b
  ULONGLONG CsrServerReadOnlySharedMemoryBase;  // offset: 0x380 ordinal: 0x6c
  ULONGLONG TppWorkerpListLock;                 // offset: 0x388 ordinal: 0x6d
  struct _LIST_ENTRY TppWorkerpList;            // offset: 0x390 ordinal: 0x6e
  VOID *WaitOnAddressHashTable[128];            // offset: 0x3a0 ordinal: 0x6f
  VOID *TelemetryCoverageHeader;                // offset: 0x7a0 ordinal: 0x70
  ULONG CloudFileFlags;                         // offset: 0x7a8 ordinal: 0x71
  ULONG CloudFileDiagFlags;                     // offset: 0x7ac ordinal: 0x72
  CHAR PlaceholderCompatibilityMode;            // offset: 0x7b0 ordinal: 0x73
  CHAR PlaceholderCompatibilityModeReserved[7]; // offset: 0x7b1 ordinal: 0x74
  struct _LEAP_SECOND_DATA *LeapSecondData;     // offset: 0x7b8 ordinal: 0x75
  union {
    ULONG LeapSecondFlags;        // offset: 0x7c0 ordinal: 0x76
    ULONG SixtySecondEnabled : 1; // offset: 0x7c0 ordinal: 0x77
  };
  ULONG Reserved : 31;                  // offset: 0x7c0 ordinal: 0x78
  ULONG NtGlobalFlag2;                  // offset: 0x7c4 ordinal: 0x79
  ULONGLONG ExtendedFeatureDisableMask; // offset: 0x7c8 ordinal: 0x7a
} _PEB;

// 0x1850 bytes (sizeof)
typedef struct _TEB {
  struct _NT_TIB NtTib;                         // offset: 0x0 ordinal: 0x0
  VOID *EnvironmentPointer;                     // offset: 0x38 ordinal: 0x1
  struct _CLIENT_ID ClientId;                   // offset: 0x40 ordinal: 0x2
  VOID *ActiveRpcHandle;                        // offset: 0x50 ordinal: 0x3
  VOID *ThreadLocalStoragePointer;              // offset: 0x58 ordinal: 0x4
  struct _PEB *ProcessEnvironmentBlock;         // offset: 0x60 ordinal: 0x5
  ULONG LastErrorValue;                         // offset: 0x68 ordinal: 0x6
  ULONG CountOfOwnedCriticalSections;           // offset: 0x6c ordinal: 0x7
  VOID *CsrClientThread;                        // offset: 0x70 ordinal: 0x8
  VOID *Win32ThreadInfo;                        // offset: 0x78 ordinal: 0x9
  ULONG User32Reserved[26];                     // offset: 0x80 ordinal: 0xa
  ULONG UserReserved[5];                        // offset: 0xe8 ordinal: 0xb
  VOID *WOW32Reserved;                          // offset: 0x100 ordinal: 0xc
  ULONG CurrentLocale;                          // offset: 0x108 ordinal: 0xd
  ULONG FpSoftwareStatusRegister;               // offset: 0x10c ordinal: 0xe
  VOID *ReservedForDebuggerInstrumentation[16]; // offset: 0x110 ordinal: 0xf
  VOID *SystemReserved1[30];                    // offset: 0x190 ordinal: 0x10
  CHAR PlaceholderCompatibilityMode;            // offset: 0x280 ordinal: 0x11
  UCHAR PlaceholderHydrationAlwaysExplicit;     // offset: 0x281 ordinal: 0x12
  CHAR PlaceholderReserved[10];                 // offset: 0x282 ordinal: 0x13
  ULONG ProxiedProcessId;                       // offset: 0x28c ordinal: 0x14
  struct _ACTIVATION_CONTEXT_STACK
      _ActivationStack;           // offset: 0x290 ordinal: 0x15
  UCHAR WorkingOnBehalfTicket[8]; // offset: 0x2b8 ordinal: 0x16
  LONG ExceptionCode;             // offset: 0x2c0 ordinal: 0x17
  UCHAR Padding0[4];              // offset: 0x2c4 ordinal: 0x18
  struct _ACTIVATION_CONTEXT_STACK
      *ActivationContextStackPointer;          // offset: 0x2c8 ordinal: 0x19
  ULONGLONG InstrumentationCallbackSp;         // offset: 0x2d0 ordinal: 0x1a
  ULONGLONG InstrumentationCallbackPreviousPc; // offset: 0x2d8 ordinal: 0x1b
  ULONGLONG InstrumentationCallbackPreviousSp; // offset: 0x2e0 ordinal: 0x1c
  ULONG TxFsContext;                           // offset: 0x2e8 ordinal: 0x1d
  UCHAR InstrumentationCallbackDisabled;       // offset: 0x2ec ordinal: 0x1e
  UCHAR UnalignedLoadStoreExceptions;          // offset: 0x2ed ordinal: 0x1f
  UCHAR Padding1[2];                           // offset: 0x2ee ordinal: 0x20
  struct _GDI_TEB_BATCH GdiTebBatch;           // offset: 0x2f0 ordinal: 0x21
  struct _CLIENT_ID RealClientId;              // offset: 0x7d8 ordinal: 0x22
  VOID *GdiCachedProcessHandle;                // offset: 0x7e8 ordinal: 0x23
  ULONG GdiClientPID;                          // offset: 0x7f0 ordinal: 0x24
  ULONG GdiClientTID;                          // offset: 0x7f4 ordinal: 0x25
  VOID *GdiThreadLocalInfo;                    // offset: 0x7f8 ordinal: 0x26
  ULONGLONG Win32ClientInfo[62];               // offset: 0x800 ordinal: 0x27
  VOID *glDispatchTable[233];                  // offset: 0x9f0 ordinal: 0x28
  ULONGLONG glReserved1[29];                   // offset: 0x1138 ordinal: 0x29
  VOID *glReserved2;                           // offset: 0x1220 ordinal: 0x2a
  VOID *glSectionInfo;                         // offset: 0x1228 ordinal: 0x2b
  VOID *glSection;                             // offset: 0x1230 ordinal: 0x2c
  VOID *glTable;                               // offset: 0x1238 ordinal: 0x2d
  VOID *glCurrentRC;                           // offset: 0x1240 ordinal: 0x2e
  VOID *glContext;                             // offset: 0x1248 ordinal: 0x2f
  ULONG LastStatusValue;                       // offset: 0x1250 ordinal: 0x30
  UCHAR Padding2[4];                           // offset: 0x1254 ordinal: 0x31
  struct _UNICODE_STRING StaticUnicodeString;  // offset: 0x1258 ordinal: 0x32
  WCHAR StaticUnicodeBuffer[261];              // offset: 0x1268 ordinal: 0x33
  UCHAR Padding3[6];                           // offset: 0x1472 ordinal: 0x34
  VOID *DeallocationStack;                     // offset: 0x1478 ordinal: 0x35
  VOID *TlsSlots[64];                          // offset: 0x1480 ordinal: 0x36
  struct _LIST_ENTRY TlsLinks;                 // offset: 0x1680 ordinal: 0x37
  VOID *Vdm;                                   // offset: 0x1690 ordinal: 0x38
  VOID *ReservedForNtRpc;                      // offset: 0x1698 ordinal: 0x39
  VOID *DbgSsReserved[2];                      // offset: 0x16a0 ordinal: 0x3a
  ULONG HardErrorMode;                         // offset: 0x16b0 ordinal: 0x3b
  UCHAR Padding4[4];                           // offset: 0x16b4 ordinal: 0x3c
  VOID *Instrumentation[11];                   // offset: 0x16b8 ordinal: 0x3d
  struct _GUID ActivityId;                     // offset: 0x1710 ordinal: 0x3e
  VOID *SubProcessTag;                         // offset: 0x1720 ordinal: 0x3f
  VOID *PerflibData;                           // offset: 0x1728 ordinal: 0x40
  VOID *EtwTraceData;                          // offset: 0x1730 ordinal: 0x41
  VOID *WinSockData;                           // offset: 0x1738 ordinal: 0x42
  ULONG GdiBatchCount;                         // offset: 0x1740 ordinal: 0x43
  union {
    struct _PROCESSOR_NUMBER
        CurrentIdealProcessor; // offset: 0x1744 ordinal: 0x44
    ULONG IdealProcessorValue; // offset: 0x1744 ordinal: 0x45
    UCHAR ReservedPad0;        // offset: 0x1744 ordinal: 0x46
  };
  UCHAR ReservedPad1;                // offset: 0x1745 ordinal: 0x47
  UCHAR ReservedPad2;                // offset: 0x1746 ordinal: 0x48
  UCHAR IdealProcessor;              // offset: 0x1747 ordinal: 0x49
  ULONG GuaranteedStackBytes;        // offset: 0x1748 ordinal: 0x4a
  UCHAR Padding5[4];                 // offset: 0x174c ordinal: 0x4b
  VOID *ReservedForPerf;             // offset: 0x1750 ordinal: 0x4c
  VOID *ReservedForOle;              // offset: 0x1758 ordinal: 0x4d
  ULONG WaitingOnLoaderLock;         // offset: 0x1760 ordinal: 0x4e
  UCHAR Padding6[4];                 // offset: 0x1764 ordinal: 0x4f
  VOID *SavedPriorityState;          // offset: 0x1768 ordinal: 0x50
  ULONGLONG ReservedForCodeCoverage; // offset: 0x1770 ordinal: 0x51
  VOID *ThreadPoolData;              // offset: 0x1778 ordinal: 0x52
  VOID **TlsExpansionSlots;          // offset: 0x1780 ordinal: 0x53
  struct _CHPEV2_CPUAREA_INFO
      *ChpeV2CpuAreaInfo;                // offset: 0x1788 ordinal: 0x54
  VOID *Unused;                          // offset: 0x1790 ordinal: 0x55
  ULONG MuiGeneration;                   // offset: 0x1798 ordinal: 0x56
  ULONG IsImpersonating;                 // offset: 0x179c ordinal: 0x57
  VOID *NlsCache;                        // offset: 0x17a0 ordinal: 0x58
  VOID *pShimData;                       // offset: 0x17a8 ordinal: 0x59
  ULONG HeapData;                        // offset: 0x17b0 ordinal: 0x5a
  UCHAR Padding7[4];                     // offset: 0x17b4 ordinal: 0x5b
  VOID *CurrentTransactionHandle;        // offset: 0x17b8 ordinal: 0x5c
  struct _TEB_ACTIVE_FRAME *ActiveFrame; // offset: 0x17c0 ordinal: 0x5d
  VOID *FlsData;                         // offset: 0x17c8 ordinal: 0x5e
  VOID *PreferredLanguages;              // offset: 0x17d0 ordinal: 0x5f
  VOID *UserPrefLanguages;               // offset: 0x17d8 ordinal: 0x60
  VOID *MergedPrefLanguages;             // offset: 0x17e0 ordinal: 0x61
  ULONG MuiImpersonation;                // offset: 0x17e8 ordinal: 0x62
  union {
    USHORT CrossTebFlags;          // offset: 0x17ec ordinal: 0x63
    USHORT SpareCrossTebBits : 16; // offset: 0x17ec ordinal: 0x64
  };
  union {
    USHORT SameTebFlags;      // offset: 0x17ee ordinal: 0x65
    USHORT SafeThunkCall : 1; // offset: 0x17ee ordinal: 0x66
  };
  USHORT InDebugPrint : 1;              // offset: 0x17ee ordinal: 0x67
  USHORT HasFiberData : 1;              // offset: 0x17ee ordinal: 0x68
  USHORT SkipThreadAttach : 1;          // offset: 0x17ee ordinal: 0x69
  USHORT WerInShipAssertCode : 1;       // offset: 0x17ee ordinal: 0x6a
  USHORT RanProcessInit : 1;            // offset: 0x17ee ordinal: 0x6b
  USHORT ClonedThread : 1;              // offset: 0x17ee ordinal: 0x6c
  USHORT SuppressDebugMsg : 1;          // offset: 0x17ee ordinal: 0x6d
  USHORT DisableUserStackWalk : 1;      // offset: 0x17ee ordinal: 0x6e
  USHORT RtlExceptionAttached : 1;      // offset: 0x17ee ordinal: 0x6f
  USHORT InitialThread : 1;             // offset: 0x17ee ordinal: 0x70
  USHORT SessionAware : 1;              // offset: 0x17ee ordinal: 0x71
  USHORT LoadOwner : 1;                 // offset: 0x17ee ordinal: 0x72
  USHORT LoaderWorker : 1;              // offset: 0x17ee ordinal: 0x73
  USHORT SkipLoaderInit : 1;            // offset: 0x17ee ordinal: 0x74
  USHORT SkipFileAPIBrokering : 1;      // offset: 0x17ee ordinal: 0x75
  VOID *TxnScopeEnterCallback;          // offset: 0x17f0 ordinal: 0x76
  VOID *TxnScopeExitCallback;           // offset: 0x17f8 ordinal: 0x77
  VOID *TxnScopeContext;                // offset: 0x1800 ordinal: 0x78
  ULONG LockCount;                      // offset: 0x1808 ordinal: 0x79
  LONG WowTebOffset;                    // offset: 0x180c ordinal: 0x7a
  VOID *ResourceRetValue;               // offset: 0x1810 ordinal: 0x7b
  VOID *ReservedForWdf;                 // offset: 0x1818 ordinal: 0x7c
  ULONGLONG ReservedForCrt;             // offset: 0x1820 ordinal: 0x7d
  struct _GUID EffectiveContainerId;    // offset: 0x1828 ordinal: 0x7e
  ULONGLONG LastSleepCounter;           // offset: 0x1838 ordinal: 0x7f
  ULONG SpinCallCount;                  // offset: 0x1840 ordinal: 0x80
  UCHAR Padding8[4];                    // offset: 0x1844 ordinal: 0x81
  ULONGLONG ExtendedFeatureDisableMask; // offset: 0x1848 ordinal: 0x82
} _TEB;

// 0xb80 bytes (sizeof)
typedef struct _EPROCESS {
  struct _KPROCESS Pcb;                  // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK ProcessLock;      // offset: 0x438 ordinal: 0x1
  VOID *UniqueProcessId;                 // offset: 0x440 ordinal: 0x2
  struct _LIST_ENTRY ActiveProcessLinks; // offset: 0x448 ordinal: 0x3
  struct _EX_RUNDOWN_REF RundownProtect; // offset: 0x458 ordinal: 0x4
  union {
    ULONG Flags2;                 // offset: 0x460 ordinal: 0x5
    ULONG JobNotReallyActive : 1; // offset: 0x460 ordinal: 0x6
  };
  ULONG AccountingFolded : 1;                // offset: 0x460 ordinal: 0x7
  ULONG NewProcessReported : 1;              // offset: 0x460 ordinal: 0x8
  ULONG ExitProcessReported : 1;             // offset: 0x460 ordinal: 0x9
  ULONG ReportCommitChanges : 1;             // offset: 0x460 ordinal: 0xa
  ULONG LastReportMemory : 1;                // offset: 0x460 ordinal: 0xb
  ULONG ForceWakeCharge : 1;                 // offset: 0x460 ordinal: 0xc
  ULONG CrossSessionCreate : 1;              // offset: 0x460 ordinal: 0xd
  ULONG NeedsHandleRundown : 1;              // offset: 0x460 ordinal: 0xe
  ULONG RefTraceEnabled : 1;                 // offset: 0x460 ordinal: 0xf
  ULONG PicoCreated : 1;                     // offset: 0x460 ordinal: 0x10
  ULONG EmptyJobEvaluated : 1;               // offset: 0x460 ordinal: 0x11
  ULONG DefaultPagePriority : 3;             // offset: 0x460 ordinal: 0x12
  ULONG PrimaryTokenFrozen : 1;              // offset: 0x460 ordinal: 0x13
  ULONG ProcessVerifierTarget : 1;           // offset: 0x460 ordinal: 0x14
  ULONG RestrictSetThreadContext : 1;        // offset: 0x460 ordinal: 0x15
  ULONG AffinityPermanent : 1;               // offset: 0x460 ordinal: 0x16
  ULONG AffinityUpdateEnable : 1;            // offset: 0x460 ordinal: 0x17
  ULONG PropagateNode : 1;                   // offset: 0x460 ordinal: 0x18
  ULONG ExplicitAffinity : 1;                // offset: 0x460 ordinal: 0x19
  ULONG ProcessExecutionState : 2;           // offset: 0x460 ordinal: 0x1a
  ULONG EnableReadVmLogging : 1;             // offset: 0x460 ordinal: 0x1b
  ULONG EnableWriteVmLogging : 1;            // offset: 0x460 ordinal: 0x1c
  ULONG FatalAccessTerminationRequested : 1; // offset: 0x460 ordinal: 0x1d
  ULONG DisableSystemAllowedCpuSet : 1;      // offset: 0x460 ordinal: 0x1e
  ULONG ProcessStateChangeRequest : 2;       // offset: 0x460 ordinal: 0x1f
  ULONG ProcessStateChangeInProgress : 1;    // offset: 0x460 ordinal: 0x20
  ULONG InPrivate : 1;                       // offset: 0x460 ordinal: 0x21
  union {
    ULONG Flags;              // offset: 0x464 ordinal: 0x22
    ULONG CreateReported : 1; // offset: 0x464 ordinal: 0x23
  };
  ULONG NoDebugInherit : 1;               // offset: 0x464 ordinal: 0x24
  ULONG ProcessExiting : 1;               // offset: 0x464 ordinal: 0x25
  ULONG ProcessDelete : 1;                // offset: 0x464 ordinal: 0x26
  ULONG ManageExecutableMemoryWrites : 1; // offset: 0x464 ordinal: 0x27
  ULONG VmDeleted : 1;                    // offset: 0x464 ordinal: 0x28
  ULONG OutswapEnabled : 1;               // offset: 0x464 ordinal: 0x29
  ULONG Outswapped : 1;                   // offset: 0x464 ordinal: 0x2a
  ULONG FailFastOnCommitFail : 1;         // offset: 0x464 ordinal: 0x2b
  ULONG Wow64VaSpace4Gb : 1;              // offset: 0x464 ordinal: 0x2c
  ULONG AddressSpaceInitialized : 2;      // offset: 0x464 ordinal: 0x2d
  ULONG SetTimerResolution : 1;           // offset: 0x464 ordinal: 0x2e
  ULONG BreakOnTermination : 1;           // offset: 0x464 ordinal: 0x2f
  ULONG DeprioritizeViews : 1;            // offset: 0x464 ordinal: 0x30
  ULONG WriteWatch : 1;                   // offset: 0x464 ordinal: 0x31
  ULONG ProcessInSession : 1;             // offset: 0x464 ordinal: 0x32
  ULONG OverrideAddressSpace : 1;         // offset: 0x464 ordinal: 0x33
  ULONG HasAddressSpace : 1;              // offset: 0x464 ordinal: 0x34
  ULONG LaunchPrefetched : 1;             // offset: 0x464 ordinal: 0x35
  ULONG Reserved : 1;                     // offset: 0x464 ordinal: 0x36
  ULONG VmTopDown : 1;                    // offset: 0x464 ordinal: 0x37
  ULONG ImageNotifyDone : 1;              // offset: 0x464 ordinal: 0x38
  ULONG PdeUpdateNeeded : 1;              // offset: 0x464 ordinal: 0x39
  ULONG VdmAllowed : 1;                   // offset: 0x464 ordinal: 0x3a
  ULONG ProcessRundown : 1;               // offset: 0x464 ordinal: 0x3b
  ULONG ProcessInserted : 1;              // offset: 0x464 ordinal: 0x3c
  ULONG DefaultIoPriority : 3;            // offset: 0x464 ordinal: 0x3d
  ULONG ProcessSelfDelete : 1;            // offset: 0x464 ordinal: 0x3e
  ULONG SetTimerResolutionLink : 1;       // offset: 0x464 ordinal: 0x3f
  union _LARGE_INTEGER CreateTime;        // offset: 0x468 ordinal: 0x40
  ULONGLONG ProcessQuotaUsage[2];         // offset: 0x470 ordinal: 0x41
  ULONGLONG ProcessQuotaPeak[2];          // offset: 0x480 ordinal: 0x42
  ULONGLONG PeakVirtualSize;              // offset: 0x490 ordinal: 0x43
  ULONGLONG VirtualSize;                  // offset: 0x498 ordinal: 0x44
  struct _LIST_ENTRY SessionProcessLinks; // offset: 0x4a0 ordinal: 0x45
  union {
    VOID *ExceptionPortData;          // offset: 0x4b0 ordinal: 0x46
    ULONGLONG ExceptionPortValue;     // offset: 0x4b0 ordinal: 0x47
    ULONGLONG ExceptionPortState : 3; // offset: 0x4b0 ordinal: 0x48
  };
  struct _EX_FAST_REF Token;                    // offset: 0x4b8 ordinal: 0x49
  ULONGLONG MmReserved;                         // offset: 0x4c0 ordinal: 0x4a
  struct _EX_PUSH_LOCK AddressCreationLock;     // offset: 0x4c8 ordinal: 0x4b
  struct _EX_PUSH_LOCK PageTableCommitmentLock; // offset: 0x4d0 ordinal: 0x4c
  struct _ETHREAD *RotateInProgress;            // offset: 0x4d8 ordinal: 0x4d
  struct _ETHREAD *ForkInProgress;              // offset: 0x4e0 ordinal: 0x4e
  struct _EJOB *CommitChargeJob;                // offset: 0x4e8 ordinal: 0x4f
  struct _RTL_AVL_TREE CloneRoot;               // offset: 0x4f0 ordinal: 0x50
  ULONGLONG NumberOfPrivatePages;               // offset: 0x4f8 ordinal: 0x51
  ULONGLONG NumberOfLockedPages;                // offset: 0x500 ordinal: 0x52
  VOID *Win32Process;                           // offset: 0x508 ordinal: 0x53
  struct _EJOB *Job;                            // offset: 0x510 ordinal: 0x54
  VOID *SectionObject;                          // offset: 0x518 ordinal: 0x55
  VOID *SectionBaseAddress;                     // offset: 0x520 ordinal: 0x56
  ULONG Cookie;                                 // offset: 0x528 ordinal: 0x57
  struct _PAGEFAULT_HISTORY *WorkingSetWatch;   // offset: 0x530 ordinal: 0x58
  VOID *Win32WindowStation;                     // offset: 0x538 ordinal: 0x59
  VOID *InheritedFromUniqueProcessId;           // offset: 0x540 ordinal: 0x5a
  ULONGLONG OwnerProcessId;                     // offset: 0x548 ordinal: 0x5b
  struct _PEB *Peb;                             // offset: 0x550 ordinal: 0x5c
  struct _MM_SESSION_SPACE *Session;            // offset: 0x558 ordinal: 0x5d
  VOID *Spare1;                                 // offset: 0x560 ordinal: 0x5e
  struct _EPROCESS_QUOTA_BLOCK *QuotaBlock;     // offset: 0x568 ordinal: 0x5f
  struct _HANDLE_TABLE *ObjectTable;            // offset: 0x570 ordinal: 0x60
  VOID *DebugPort;                              // offset: 0x578 ordinal: 0x61
  struct _EWOW64PROCESS *WoW64Process;          // offset: 0x580 ordinal: 0x62
  struct _EX_FAST_REF DeviceMap;                // offset: 0x588 ordinal: 0x63
  VOID *EtwDataSource;                          // offset: 0x590 ordinal: 0x64
  ULONGLONG PageDirectoryPte;                   // offset: 0x598 ordinal: 0x65
  struct _FILE_OBJECT *ImageFilePointer;        // offset: 0x5a0 ordinal: 0x66
  UCHAR ImageFileName[15];                      // offset: 0x5a8 ordinal: 0x67
  UCHAR PriorityClass;                          // offset: 0x5b7 ordinal: 0x68
  VOID *SecurityPort;                           // offset: 0x5b8 ordinal: 0x69
  struct _SE_AUDIT_PROCESS_CREATION_INFO
      SeAuditProcessCreationInfo;           // offset: 0x5c0 ordinal: 0x6a
  struct _LIST_ENTRY JobLinks;              // offset: 0x5c8 ordinal: 0x6b
  VOID *HighestUserAddress;                 // offset: 0x5d8 ordinal: 0x6c
  struct _LIST_ENTRY ThreadListHead;        // offset: 0x5e0 ordinal: 0x6d
  ULONG ActiveThreads;                      // offset: 0x5f0 ordinal: 0x6e
  ULONG ImagePathHash;                      // offset: 0x5f4 ordinal: 0x6f
  ULONG DefaultHardErrorProcessing;         // offset: 0x5f8 ordinal: 0x70
  LONG LastThreadExitStatus;                // offset: 0x5fc ordinal: 0x71
  struct _EX_FAST_REF PrefetchTrace;        // offset: 0x600 ordinal: 0x72
  VOID *LockedPagesList;                    // offset: 0x608 ordinal: 0x73
  union _LARGE_INTEGER ReadOperationCount;  // offset: 0x610 ordinal: 0x74
  union _LARGE_INTEGER WriteOperationCount; // offset: 0x618 ordinal: 0x75
  union _LARGE_INTEGER OtherOperationCount; // offset: 0x620 ordinal: 0x76
  union _LARGE_INTEGER ReadTransferCount;   // offset: 0x628 ordinal: 0x77
  union _LARGE_INTEGER WriteTransferCount;  // offset: 0x630 ordinal: 0x78
  union _LARGE_INTEGER OtherTransferCount;  // offset: 0x638 ordinal: 0x79
  ULONGLONG CommitChargeLimit;              // offset: 0x640 ordinal: 0x7a
  ULONGLONG CommitCharge;                   // offset: 0x648 ordinal: 0x7b
  ULONGLONG CommitChargePeak;               // offset: 0x650 ordinal: 0x7c
  struct _MMSUPPORT_FULL Vm;                // offset: 0x680 ordinal: 0x7d
  struct _LIST_ENTRY MmProcessLinks;        // offset: 0x7c0 ordinal: 0x7e
  ULONG ModifiedPageCount;                  // offset: 0x7d0 ordinal: 0x7f
  LONG ExitStatus;                          // offset: 0x7d4 ordinal: 0x80
  struct _RTL_AVL_TREE VadRoot;             // offset: 0x7d8 ordinal: 0x81
  VOID *VadHint;                            // offset: 0x7e0 ordinal: 0x82
  ULONGLONG VadCount;                       // offset: 0x7e8 ordinal: 0x83
  ULONGLONG VadPhysicalPages;               // offset: 0x7f0 ordinal: 0x84
  ULONGLONG VadPhysicalPagesLimit;          // offset: 0x7f8 ordinal: 0x85
  struct _ALPC_PROCESS_CONTEXT AlpcContext; // offset: 0x800 ordinal: 0x86
  struct _LIST_ENTRY TimerResolutionLink;   // offset: 0x820 ordinal: 0x87
  struct _PO_DIAG_STACK_RECORD
      *TimerResolutionStackRecord; // offset: 0x830 ordinal: 0x88
  ULONG RequestedTimerResolution;  // offset: 0x838 ordinal: 0x89
  ULONG SmallestTimerResolution;   // offset: 0x83c ordinal: 0x8a
  union _LARGE_INTEGER ExitTime;   // offset: 0x840 ordinal: 0x8b
  struct _INVERTED_FUNCTION_TABLE_KERNEL_MODE
      *InvertedFunctionTable;                     // offset: 0x848 ordinal: 0x8c
  struct _EX_PUSH_LOCK InvertedFunctionTableLock; // offset: 0x850 ordinal: 0x8d
  ULONG ActiveThreadsHighWatermark;               // offset: 0x858 ordinal: 0x8e
  ULONG LargePrivateVadCount;                     // offset: 0x85c ordinal: 0x8f
  struct _EX_PUSH_LOCK ThreadListLock;            // offset: 0x860 ordinal: 0x90
  VOID *WnfContext;                               // offset: 0x868 ordinal: 0x91
  struct _EJOB *ServerSilo;                       // offset: 0x870 ordinal: 0x92
  UCHAR SignatureLevel;                           // offset: 0x878 ordinal: 0x93
  UCHAR SectionSignatureLevel;                    // offset: 0x879 ordinal: 0x94
  struct _PS_PROTECTION Protection;               // offset: 0x87a ordinal: 0x95
  UCHAR HangCount : 3;                            // offset: 0x87b ordinal: 0x96
  UCHAR GhostCount : 3;                           // offset: 0x87b ordinal: 0x97
  UCHAR PrefilterException : 1;                   // offset: 0x87b ordinal: 0x98
  union {
    ULONG Flags3;      // offset: 0x87c ordinal: 0x99
    ULONG Minimal : 1; // offset: 0x87c ordinal: 0x9a
  };
  ULONG ReplacingPageRoot : 1;                 // offset: 0x87c ordinal: 0x9b
  ULONG Crashed : 1;                           // offset: 0x87c ordinal: 0x9c
  ULONG JobVadsAreTracked : 1;                 // offset: 0x87c ordinal: 0x9d
  ULONG VadTrackingDisabled : 1;               // offset: 0x87c ordinal: 0x9e
  ULONG AuxiliaryProcess : 1;                  // offset: 0x87c ordinal: 0x9f
  ULONG SubsystemProcess : 1;                  // offset: 0x87c ordinal: 0xa0
  ULONG IndirectCpuSets : 1;                   // offset: 0x87c ordinal: 0xa1
  ULONG RelinquishedCommit : 1;                // offset: 0x87c ordinal: 0xa2
  ULONG HighGraphicsPriority : 1;              // offset: 0x87c ordinal: 0xa3
  ULONG CommitFailLogged : 1;                  // offset: 0x87c ordinal: 0xa4
  ULONG ReserveFailLogged : 1;                 // offset: 0x87c ordinal: 0xa5
  ULONG SystemProcess : 1;                     // offset: 0x87c ordinal: 0xa6
  ULONG HideImageBaseAddresses : 1;            // offset: 0x87c ordinal: 0xa7
  ULONG AddressPolicyFrozen : 1;               // offset: 0x87c ordinal: 0xa8
  ULONG ProcessFirstResume : 1;                // offset: 0x87c ordinal: 0xa9
  ULONG ForegroundExternal : 1;                // offset: 0x87c ordinal: 0xaa
  ULONG ForegroundSystem : 1;                  // offset: 0x87c ordinal: 0xab
  ULONG HighMemoryPriority : 1;                // offset: 0x87c ordinal: 0xac
  ULONG EnableProcessSuspendResumeLogging : 1; // offset: 0x87c ordinal: 0xad
  ULONG EnableThreadSuspendResumeLogging : 1;  // offset: 0x87c ordinal: 0xae
  ULONG SecurityDomainChanged : 1;             // offset: 0x87c ordinal: 0xaf
  ULONG SecurityFreezeComplete : 1;            // offset: 0x87c ordinal: 0xb0
  ULONG VmProcessorHost : 1;                   // offset: 0x87c ordinal: 0xb1
  ULONG VmProcessorHostTransition : 1;         // offset: 0x87c ordinal: 0xb2
  ULONG AltSyscall : 1;                        // offset: 0x87c ordinal: 0xb3
  ULONG TimerResolutionIgnore : 1;             // offset: 0x87c ordinal: 0xb4
  ULONG DisallowUserTerminate : 1;             // offset: 0x87c ordinal: 0xb5
  ULONG EnableProcessRemoteExecProtectVmLogging : 1; // offset: 0x87c ordinal:
                                                     // 0xb6
  ULONG
  EnableProcessLocalExecProtectVmLogging : 1;  // offset: 0x87c ordinal: 0xb7
  ULONG MemoryCompressionProcess : 1;          // offset: 0x87c ordinal: 0xb8
  LONG DeviceAsid;                             // offset: 0x880 ordinal: 0xb9
  VOID *SvmData;                               // offset: 0x888 ordinal: 0xba
  struct _EX_PUSH_LOCK SvmProcessLock;         // offset: 0x890 ordinal: 0xbb
  ULONGLONG SvmLock;                           // offset: 0x898 ordinal: 0xbc
  struct _LIST_ENTRY SvmProcessDeviceListHead; // offset: 0x8a0 ordinal: 0xbd
  ULONGLONG LastFreezeInterruptTime;           // offset: 0x8b0 ordinal: 0xbe
  struct _PROCESS_DISK_COUNTERS *DiskCounters; // offset: 0x8b8 ordinal: 0xbf
  VOID *PicoContext;                           // offset: 0x8c0 ordinal: 0xc0
  VOID *EnclaveTable;                          // offset: 0x8c8 ordinal: 0xc1
  ULONGLONG EnclaveNumber;                     // offset: 0x8d0 ordinal: 0xc2
  struct _EX_PUSH_LOCK EnclaveLock;            // offset: 0x8d8 ordinal: 0xc3
  ULONG HighPriorityFaultsAllowed;             // offset: 0x8e0 ordinal: 0xc4
  struct _PO_PROCESS_ENERGY_CONTEXT
      *EnergyContext;                    // offset: 0x8e8 ordinal: 0xc5
  VOID *VmContext;                       // offset: 0x8f0 ordinal: 0xc6
  ULONGLONG SequenceNumber;              // offset: 0x8f8 ordinal: 0xc7
  ULONGLONG CreateInterruptTime;         // offset: 0x900 ordinal: 0xc8
  ULONGLONG CreateUnbiasedInterruptTime; // offset: 0x908 ordinal: 0xc9
  ULONGLONG TotalUnbiasedFrozenTime;     // offset: 0x910 ordinal: 0xca
  ULONGLONG LastAppStateUpdateTime;      // offset: 0x918 ordinal: 0xcb
  ULONGLONG LastAppStateUptime : 61;     // offset: 0x920 ordinal: 0xcc
  ULONGLONG LastAppState : 3;            // offset: 0x920 ordinal: 0xcd
  ULONGLONG SharedCommitCharge;          // offset: 0x928 ordinal: 0xce
  struct _EX_PUSH_LOCK SharedCommitLock; // offset: 0x930 ordinal: 0xcf
  struct _LIST_ENTRY SharedCommitLinks;  // offset: 0x938 ordinal: 0xd0
  ULONGLONG AllowedCpuSets;              // offset: 0x948 ordinal: 0xd1
  ULONGLONG DefaultCpuSets;              // offset: 0x950 ordinal: 0xd2
  ULONGLONG *AllowedCpuSetsIndirect;     // offset: 0x948 ordinal: 0xd3
  ULONGLONG *DefaultCpuSetsIndirect;     // offset: 0x950 ordinal: 0xd4
  VOID *DiskIoAttribution;               // offset: 0x958 ordinal: 0xd5
  VOID *DxgProcess;                      // offset: 0x960 ordinal: 0xd6
  ULONG Win32KFilterSet;                 // offset: 0x968 ordinal: 0xd7
  USHORT Machine;                        // offset: 0x96c ordinal: 0xd8
  USHORT Spare0;                         // offset: 0x96e ordinal: 0xd9
  union _PS_INTERLOCKED_TIMER_DELAY_VALUES
      ProcessTimerDelay;                   // offset: 0x970 ordinal: 0xda
  ULONG KTimerSets;                        // offset: 0x978 ordinal: 0xdb
  ULONG KTimer2Sets;                       // offset: 0x97c ordinal: 0xdc
  ULONG ThreadTimerSets;                   // offset: 0x980 ordinal: 0xdd
  ULONGLONG VirtualTimerListLock;          // offset: 0x988 ordinal: 0xde
  struct _LIST_ENTRY VirtualTimerListHead; // offset: 0x990 ordinal: 0xdf
  union {
    struct _WNF_STATE_NAME WakeChannel;           // offset: 0x9a0 ordinal: 0xe0
    struct _PS_PROCESS_WAKE_INFORMATION WakeInfo; // offset: 0x9a0 ordinal: 0xe1
  };
  union {
    ULONG MitigationFlags;                  // offset: 0x9d0 ordinal: 0xe2
    struct __anon_79 MitigationFlagsValues; // offset: 0x9d0 ordinal: 0xe3
  };
  union {
    ULONG MitigationFlags2;                  // offset: 0x9d4 ordinal: 0xe4
    struct __anon_80 MitigationFlags2Values; // offset: 0x9d4 ordinal: 0xe5
  };
  VOID *PartitionObject;          // offset: 0x9d8 ordinal: 0xe6
  ULONGLONG SecurityDomain;       // offset: 0x9e0 ordinal: 0xe7
  ULONGLONG ParentSecurityDomain; // offset: 0x9e8 ordinal: 0xe8
  VOID *CoverageSamplerContext;   // offset: 0x9f0 ordinal: 0xe9
  VOID *MmHotPatchContext;        // offset: 0x9f8 ordinal: 0xea
  struct _KE_IDEAL_PROCESSOR_ASSIGNMENT_BLOCK
      IdealProcessorAssignmentBlock; // offset: 0xa00 ordinal: 0xeb
  struct _RTL_AVL_TREE
      DynamicEHContinuationTargetsTree; // offset: 0xb18 ordinal: 0xec
  struct _EX_PUSH_LOCK
      DynamicEHContinuationTargetsLock; // offset: 0xb20 ordinal: 0xed
  struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES
      DynamicEnforcedCetCompatibleRanges; // offset: 0xb28 ordinal: 0xee
  ULONG DisabledComponentFlags;           // offset: 0xb38 ordinal: 0xef
  LONG PageCombineSequence;               // offset: 0xb3c ordinal: 0xf0
  struct _EX_PUSH_LOCK
      EnableOptionalXStateFeaturesLock;           // offset: 0xb40 ordinal: 0xf1
  ULONG *PathRedirectionHashes;                   // offset: 0xb48 ordinal: 0xf2
  struct _PS_SYSCALL_PROVIDER *SyscallProvider;   // offset: 0xb50 ordinal: 0xf3
  struct _LIST_ENTRY SyscallProviderProcessLinks; // offset: 0xb58 ordinal: 0xf4
  struct _PSP_SYSCALL_PROVIDER_DISPATCH_CONTEXT
      SyscallProviderDispatchContext; // offset: 0xb68 ordinal: 0xf5
  union {
    ULONG MitigationFlags3;                  // offset: 0xb70 ordinal: 0xf6
    struct __anon_86 MitigationFlags3Values; // offset: 0xb70 ordinal: 0xf7
  };
} _EPROCESS;

// 0x48 bytes (sizeof)
typedef struct _RH_OP_CONTEXT {
  struct _LIST_ENTRY Links;                     // offset: 0x0 ordinal: 0x0
  struct _IRP *OplockRequestIrp;                // offset: 0x10 ordinal: 0x1
  struct _FILE_OBJECT *OplockRequestFileObject; // offset: 0x18 ordinal: 0x2
  struct _EPROCESS *OplockRequestProcess;       // offset: 0x20 ordinal: 0x3
  struct _ETHREAD *OplockOwnerThread;           // offset: 0x28 ordinal: 0x4
  ULONG Flags;                                  // offset: 0x30 ordinal: 0x5
  struct _LIST_ENTRY AtomicLinks;               // offset: 0x38 ordinal: 0x6
} _RH_OP_CONTEXT;

// 0xa0 bytes (sizeof)
typedef struct _NONOPAQUE_OPLOCK {
  struct _IRP *IrpExclusiveOplock;             // offset: 0x0 ordinal: 0x0
  struct _FILE_OBJECT *FileObject;             // offset: 0x8 ordinal: 0x1
  struct _EPROCESS *ExclusiveOplockOwner;      // offset: 0x10 ordinal: 0x2
  struct _ETHREAD *ExclusiveOplockOwnerThread; // offset: 0x18 ordinal: 0x3
  UCHAR WaiterPriority;                        // offset: 0x20 ordinal: 0x4
  struct _LIST_ENTRY IrpOplocksR;              // offset: 0x28 ordinal: 0x5
  struct _LIST_ENTRY IrpOplocksRH;             // offset: 0x38 ordinal: 0x6
  struct _LIST_ENTRY RHBreakQueue;             // offset: 0x48 ordinal: 0x7
  struct _LIST_ENTRY WaitingIrps;              // offset: 0x58 ordinal: 0x8
  struct _LIST_ENTRY DelayAckFileObjectQueue;  // offset: 0x68 ordinal: 0x9
  struct _LIST_ENTRY AtomicQueue;              // offset: 0x78 ordinal: 0xa
  struct _GUID *DeleterParentKey;              // offset: 0x88 ordinal: 0xb
  ULONG OplockState;                           // offset: 0x90 ordinal: 0xc
  struct _FAST_MUTEX *FastMutex;               // offset: 0x98 ordinal: 0xd
} _NONOPAQUE_OPLOCK;

// 0x10 bytes (sizeof)
typedef struct _POOL_HEADER {
  USHORT PreviousSize : 8; // offset: 0x0 ordinal: 0x0
  USHORT PoolIndex : 8;    // offset: 0x0 ordinal: 0x1
  USHORT BlockSize : 8;    // offset: 0x2 ordinal: 0x2
  USHORT PoolType : 8;     // offset: 0x2 ordinal: 0x3
  ULONG Ulong1;            // offset: 0x0 ordinal: 0x4
  ULONG PoolTag;           // offset: 0x4 ordinal: 0x5
  union {
    struct _EPROCESS *ProcessBilled; // offset: 0x8 ordinal: 0x6
    USHORT AllocatorBackTraceIndex;  // offset: 0x8 ordinal: 0x7
  };
  USHORT PoolTagHash; // offset: 0xa ordinal: 0x8
} _POOL_HEADER;

// 0x88 bytes (sizeof)
typedef struct _MMVAD {
  struct _MMVAD_SHORT Core;         // offset: 0x0 ordinal: 0x0
  union __anon_4016 u2;             // offset: 0x40 ordinal: 0x1
  struct _SUBSECTION *Subsection;   // offset: 0x48 ordinal: 0x2
  struct _MMPTE *FirstPrototypePte; // offset: 0x50 ordinal: 0x3
  struct _MMPTE *LastContiguousPte; // offset: 0x58 ordinal: 0x4
  struct _LIST_ENTRY ViewLinks;     // offset: 0x60 ordinal: 0x5
  struct _EPROCESS *VadsProcess;    // offset: 0x70 ordinal: 0x6
  union __anon_4017 u4;             // offset: 0x78 ordinal: 0x7
  struct _FILE_OBJECT *FileObject;  // offset: 0x80 ordinal: 0x8
} _MMVAD;

// 0x20 bytes (sizeof)
typedef struct _POOL_TRACKER_BIG_PAGES {
  ULONGLONG Va;                    // offset: 0x0 ordinal: 0x0
  ULONG Key;                       // offset: 0x8 ordinal: 0x1
  ULONG Pattern : 8;               // offset: 0xc ordinal: 0x2
  ULONG PoolType : 12;             // offset: 0xc ordinal: 0x3
  ULONG SlushSize : 12;            // offset: 0xc ordinal: 0x4
  ULONGLONG NumberOfBytes;         // offset: 0x10 ordinal: 0x5
  struct _EPROCESS *ProcessBilled; // offset: 0x18 ordinal: 0x6
} _POOL_TRACKER_BIG_PAGES;

// 0x48 bytes (sizeof)
typedef struct _POP_SHUTDOWN_BUG_CHECK {
  struct _ETHREAD *InitiatingThread;   // offset: 0x0 ordinal: 0x0
  struct _EPROCESS *InitiatingProcess; // offset: 0x8 ordinal: 0x1
  VOID *ThreadId;                      // offset: 0x10 ordinal: 0x2
  VOID *ProcessId;                     // offset: 0x18 ordinal: 0x3
  ULONG Code;                          // offset: 0x20 ordinal: 0x4
  ULONGLONG Parameter1;                // offset: 0x28 ordinal: 0x5
  ULONGLONG Parameter2;                // offset: 0x30 ordinal: 0x6
  ULONGLONG Parameter3;                // offset: 0x38 ordinal: 0x7
  ULONGLONG Parameter4;                // offset: 0x40 ordinal: 0x8
} _POP_SHUTDOWN_BUG_CHECK;

// 0x1d0 bytes (sizeof)
typedef struct _POP_POWER_ACTION {
  UCHAR Updates;                                   // offset: 0x0 ordinal: 0x0
  UCHAR State;                                     // offset: 0x1 ordinal: 0x1
  UCHAR Shutdown;                                  // offset: 0x2 ordinal: 0x2
  enum POWER_ACTION Action;                        // offset: 0x4 ordinal: 0x3
  enum _SYSTEM_POWER_STATE LightestState;          // offset: 0x8 ordinal: 0x4
  ULONG Flags;                                     // offset: 0xc ordinal: 0x5
  LONG Status;                                     // offset: 0x10 ordinal: 0x6
  enum POWER_POLICY_DEVICE_TYPE DeviceType;        // offset: 0x14 ordinal: 0x7
  ULONG DeviceTypeFlags;                           // offset: 0x18 ordinal: 0x8
  UCHAR IrpMinor;                                  // offset: 0x1c ordinal: 0x9
  UCHAR Waking;                                    // offset: 0x1d ordinal: 0xa
  enum _SYSTEM_POWER_STATE SystemState;            // offset: 0x20 ordinal: 0xb
  enum _SYSTEM_POWER_STATE NextSystemState;        // offset: 0x24 ordinal: 0xc
  enum _SYSTEM_POWER_STATE EffectiveSystemState;   // offset: 0x28 ordinal: 0xd
  enum _SYSTEM_POWER_STATE CurrentSystemState;     // offset: 0x2c ordinal: 0xe
  struct _POP_SHUTDOWN_BUG_CHECK *ShutdownBugCode; // offset: 0x30 ordinal: 0xf
  struct _POP_DEVICE_SYS_STATE *DevState;          // offset: 0x38 ordinal: 0x10
  struct _POP_HIBER_CONTEXT *HiberContext;         // offset: 0x40 ordinal: 0x11
  ULONGLONG WakeTime;                              // offset: 0x48 ordinal: 0x12
  ULONGLONG SleepTime;                             // offset: 0x50 ordinal: 0x13
  ULONGLONG WakeFirstUnattendedTime;               // offset: 0x58 ordinal: 0x14
  enum SYSTEM_POWER_CONDITION WakeAlarmSignaled;   // offset: 0x60 ordinal: 0x15
  struct __anon_3948 WakeAlarm[3];                 // offset: 0x68 ordinal: 0x16
  UCHAR WakeAlarmPaused;                           // offset: 0xb0 ordinal: 0x17
  ULONGLONG WakeAlarmLastTime;                     // offset: 0xb8 ordinal: 0x18
  ULONGLONG DozeDeferralStartTime;                 // offset: 0xc0 ordinal: 0x19
  struct SYSTEM_POWER_CAPABILITIES
      FilteredCapabilities;     // offset: 0xc8 ordinal: 0x1a
  ULONGLONG WatchdogLock;       // offset: 0x118 ordinal: 0x1b
  struct _KDPC WatchdogDpc;     // offset: 0x120 ordinal: 0x1c
  struct _KTIMER WatchdogTimer; // offset: 0x160 ordinal: 0x1d
  UCHAR WatchdogInitialized;    // offset: 0x1a0 ordinal: 0x1e
  enum _POP_POWER_ACTION_WATCHDOG_STATE
      WatchdogState;                             // offset: 0x1a4 ordinal: 0x1f
  ULONGLONG WatchdogStartTime;                   // offset: 0x1a8 ordinal: 0x20
  ULONG WatchdogTimeout;                         // offset: 0x1b0 ordinal: 0x21
  struct _KTHREAD *ActionWorkerThread;           // offset: 0x1b8 ordinal: 0x22
  struct _KTHREAD *PromoteActionWorkerThread;    // offset: 0x1c0 ordinal: 0x23
  struct _KTHREAD *UnlockAfterSleepWorkerThread; // offset: 0x1c8 ordinal: 0x24
} _POP_POWER_ACTION;

// 0x100 bytes (sizeof)
typedef struct _LPCP_PORT_OBJECT {
  struct _LPCP_PORT_OBJECT *ConnectionPort;        // offset: 0x0 ordinal: 0x0
  struct _LPCP_PORT_OBJECT *ConnectedPort;         // offset: 0x8 ordinal: 0x1
  struct _LPCP_PORT_QUEUE MsgQueue;                // offset: 0x10 ordinal: 0x2
  struct _CLIENT_ID Creator;                       // offset: 0x30 ordinal: 0x3
  VOID *ClientSectionBase;                         // offset: 0x40 ordinal: 0x4
  VOID *ServerSectionBase;                         // offset: 0x48 ordinal: 0x5
  VOID *PortContext;                               // offset: 0x50 ordinal: 0x6
  struct _ETHREAD *ClientThread;                   // offset: 0x58 ordinal: 0x7
  struct _SECURITY_QUALITY_OF_SERVICE SecurityQos; // offset: 0x60 ordinal: 0x8
  struct _SECURITY_CLIENT_CONTEXT StaticSecurity;  // offset: 0x70 ordinal: 0x9
  struct _LIST_ENTRY LpcReplyChainHead;            // offset: 0xb8 ordinal: 0xa
  struct _LIST_ENTRY LpcDataInfoChainHead;         // offset: 0xc8 ordinal: 0xb
  union {
    struct _EPROCESS *ServerProcess;  // offset: 0xd8 ordinal: 0xc
    struct _EPROCESS *MappingProcess; // offset: 0xd8 ordinal: 0xd
  };
  USHORT MaxMessageLength;        // offset: 0xe0 ordinal: 0xe
  USHORT MaxConnectionInfoLength; // offset: 0xe2 ordinal: 0xf
  ULONG Flags;                    // offset: 0xe4 ordinal: 0x10
  struct _KEVENT WaitEvent;       // offset: 0xe8 ordinal: 0x11
} _LPCP_PORT_OBJECT;

// 0x20 bytes (sizeof)
typedef struct _DIAGNOSTIC_CONTEXT {
  enum _REQUESTER_TYPE CallerType;     // offset: 0x0 ordinal: 0x0
  struct _EPROCESS *Process;           // offset: 0x8 ordinal: 0x1
  ULONG ServiceTag;                    // offset: 0x10 ordinal: 0x2
  struct _DEVICE_OBJECT *DeviceObject; // offset: 0x8 ordinal: 0x3
  ULONGLONG ReasonSize;                // offset: 0x18 ordinal: 0x4
} _DIAGNOSTIC_CONTEXT;

// 0x138 bytes (sizeof)
typedef struct _ETIMER {
  struct _KTIMER KeTimer;                  // offset: 0x0 ordinal: 0x0
  ULONGLONG Lock;                          // offset: 0x40 ordinal: 0x1
  struct _KAPC TimerApc;                   // offset: 0x48 ordinal: 0x2
  struct _KDPC TimerDpc;                   // offset: 0xa0 ordinal: 0x3
  struct _LIST_ENTRY ActiveTimerListEntry; // offset: 0xe0 ordinal: 0x4
  ULONG Period;                            // offset: 0xf0 ordinal: 0x5
  union {
    CHAR TimerFlags;         // offset: 0xf4 ordinal: 0x6
    UCHAR ApcAssociated : 1; // offset: 0xf4 ordinal: 0x7
  };
  UCHAR FlushDpcs : 1;                      // offset: 0xf4 ordinal: 0x8
  UCHAR Paused : 1;                         // offset: 0xf4 ordinal: 0x9
  UCHAR Spare1 : 5;                         // offset: 0xf4 ordinal: 0xa
  UCHAR DueTimeType;                        // offset: 0xf5 ordinal: 0xb
  USHORT Spare2;                            // offset: 0xf6 ordinal: 0xc
  struct _DIAGNOSTIC_CONTEXT *WakeReason;   // offset: 0xf8 ordinal: 0xd
  struct _LIST_ENTRY WakeTimerListEntry;    // offset: 0x100 ordinal: 0xe
  VOID *VirtualizedTimerCookie;             // offset: 0x110 ordinal: 0xf
  struct _LIST_ENTRY VirtualizedTimerLinks; // offset: 0x118 ordinal: 0x10
  ULONGLONG DueTime;                        // offset: 0x128 ordinal: 0x11
  ULONG CoalescingWindow;                   // offset: 0x130 ordinal: 0x12
} _ETIMER;

// 0x70 bytes (sizeof)
typedef struct _ETW_REG_ENTRY {
  struct _LIST_ENTRY RegList;         // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY GroupRegList;    // offset: 0x10 ordinal: 0x1
  struct _ETW_GUID_ENTRY *GuidEntry;  // offset: 0x20 ordinal: 0x2
  struct _ETW_GUID_ENTRY *GroupEntry; // offset: 0x28 ordinal: 0x3
  union {
    struct _ETW_REPLY_QUEUE *ReplyQueue;   // offset: 0x30 ordinal: 0x4
    struct _ETW_QUEUE_ENTRY *ReplySlot[4]; // offset: 0x30 ordinal: 0x5
    VOID *Caller;                          // offset: 0x30 ordinal: 0x6
  };
  ULONG SessionId; // offset: 0x38 ordinal: 0x7
  union {
    struct _EPROCESS *Process; // offset: 0x50 ordinal: 0x8
    VOID *CallbackContext;     // offset: 0x50 ordinal: 0x9
  };
  VOID *Callback; // offset: 0x58 ordinal: 0xa
  USHORT Index;   // offset: 0x60 ordinal: 0xb
  union {
    USHORT Flags;                     // offset: 0x62 ordinal: 0xc
    USHORT DbgKernelRegistration : 1; // offset: 0x62 ordinal: 0xd
  };
  USHORT DbgUserRegistration : 1;         // offset: 0x62 ordinal: 0xe
  USHORT DbgReplyRegistration : 1;        // offset: 0x62 ordinal: 0xf
  USHORT DbgClassicRegistration : 1;      // offset: 0x62 ordinal: 0x10
  USHORT DbgSessionSpaceRegistration : 1; // offset: 0x62 ordinal: 0x11
  USHORT DbgModernRegistration : 1;       // offset: 0x62 ordinal: 0x12
  USHORT DbgClosed : 1;                   // offset: 0x62 ordinal: 0x13
  USHORT DbgInserted : 1;                 // offset: 0x62 ordinal: 0x14
  USHORT DbgWow64 : 1;                    // offset: 0x62 ordinal: 0x15
  USHORT DbgUseDescriptorType : 1;        // offset: 0x62 ordinal: 0x16
  USHORT DbgDropProviderTraits : 1;       // offset: 0x62 ordinal: 0x17
  UCHAR EnableMask;                       // offset: 0x64 ordinal: 0x18
  UCHAR GroupEnableMask;                  // offset: 0x65 ordinal: 0x19
  UCHAR HostEnableMask;                   // offset: 0x66 ordinal: 0x1a
  UCHAR HostGroupEnableMask;              // offset: 0x67 ordinal: 0x1b
  struct _ETW_PROVIDER_TRAITS *Traits;    // offset: 0x68 ordinal: 0x1c
} _ETW_REG_ENTRY;

// 0x38 bytes (sizeof)
typedef struct _ETW_QUEUE_ENTRY {
  struct _LIST_ENTRY ListEntry;                // offset: 0x0 ordinal: 0x0
  struct _ETWP_NOTIFICATION_HEADER *DataBlock; // offset: 0x10 ordinal: 0x1
  struct _ETW_REG_ENTRY *RegEntry;             // offset: 0x18 ordinal: 0x2
  struct _ETW_REG_ENTRY *ReplyObject;          // offset: 0x20 ordinal: 0x3
  VOID *WakeReference;                         // offset: 0x28 ordinal: 0x4
  USHORT RegIndex;                             // offset: 0x30 ordinal: 0x5
  USHORT ReplyIndex;                           // offset: 0x32 ordinal: 0x6
  ULONG Flags;                                 // offset: 0x34 ordinal: 0x7
} _ETW_QUEUE_ENTRY;

// 0x28 bytes (sizeof)
typedef struct _MI_REVERSE_VIEW_MAP {
  struct _LIST_ENTRY ViewLinks; // offset: 0x0 ordinal: 0x0
  union {
    VOID *SystemCacheVa;           // offset: 0x10 ordinal: 0x1
    VOID *SessionViewVa;           // offset: 0x10 ordinal: 0x2
    struct _EPROCESS *VadsProcess; // offset: 0x10 ordinal: 0x3
    ULONGLONG Type : 2;            // offset: 0x10 ordinal: 0x4
  };
  union {
    struct _SUBSECTION *Subsection; // offset: 0x18 ordinal: 0x5
    ULONGLONG SubsectionType : 1;   // offset: 0x18 ordinal: 0x6
  };
  union {
    struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES
        SystemCacheAttributes; // offset: 0x20 ordinal: 0x7
    ULONGLONG AllAttributes;   // offset: 0x20 ordinal: 0x8
    ULONGLONG SectionOffset;   // offset: 0x20 ordinal: 0x9
  };
} _MI_REVERSE_VIEW_MAP;

// 0x18 bytes (sizeof)
typedef struct _MI_HOT_PATCH_PROCESS_CONTEXT {
  struct _EPROCESS *Process; // offset: 0x0 ordinal: 0x0
  VOID *ProcessHandle;       // offset: 0x8 ordinal: 0x1
  ULONG TbFlushStamp;        // offset: 0x10 ordinal: 0x2
} _MI_HOT_PATCH_PROCESS_CONTEXT;

// 0x60 bytes (sizeof)
typedef struct _MI_HOT_PATCH_STATE {
  struct _RTL_AVL_TREE UserSidPatchLists;  // offset: 0x0 ordinal: 0x0
  struct _RTL_AVL_TREE GlobalHotPatchList; // offset: 0x8 ordinal: 0x1
  struct _RTL_AVL_TREE
      PreviouslyRegisteredHotPatchList;          // offset: 0x10 ordinal: 0x2
  struct _RTL_AVL_TREE SecureImageActivePatches; // offset: 0x18 ordinal: 0x3
  struct _EX_PUSH_LOCK HotPatchListLock;         // offset: 0x20 ordinal: 0x4
  struct _MI_HOT_PATCH_PROCESS_CONTEXT
      HotPatchProcessContext; // offset: 0x28 ordinal: 0x5
  struct _KLDR_DATA_TABLE_ENTRY
      *InProgressPatchTableEntry; // offset: 0x40 ordinal: 0x6
  struct _KLDR_DATA_TABLE_ENTRY
      *InProgressBaseTableEntry;         // offset: 0x48 ordinal: 0x7
  CHAR ReadyForPatchOperations;          // offset: 0x50 ordinal: 0x8
  ULONG HotPatchReserveSize;             // offset: 0x54 ordinal: 0x9
  ULONG HotPatchingEnabled : 1;          // offset: 0x58 ordinal: 0xa
  ULONG EnforcePatchSequenceNumbers : 1; // offset: 0x58 ordinal: 0xb
  ULONG HotPatchTestExecuted : 1;        // offset: 0x58 ordinal: 0xc
  ULONG Spare : 29;                      // offset: 0x58 ordinal: 0xd
} _MI_HOT_PATCH_STATE;

// 0x30 bytes (sizeof)
typedef struct _MI_SESSION_STATE {
  struct _EX_PUSH_LOCK IdLock;         // offset: 0x0 ordinal: 0x0
  struct _EPROCESS *LeaderProcess;     // offset: 0x8 ordinal: 0x1
  struct _EX_PUSH_LOCK InitializeLock; // offset: 0x10 ordinal: 0x2
  VOID *SessionBase;                   // offset: 0x18 ordinal: 0x3
  struct _RTL_AVL_TREE SessionIdNodes; // offset: 0x20 ordinal: 0x4
  VOID *ImageVaStart;                  // offset: 0x28 ordinal: 0x5
} _MI_SESSION_STATE;

// 0x90 bytes (sizeof)
typedef struct _LOCK_TRACKER {
  struct _RTL_BALANCED_NODE LockTrackerNode; // offset: 0x0 ordinal: 0x0
  struct _MDL *Mdl;                          // offset: 0x18 ordinal: 0x1
  VOID *StartVa;                             // offset: 0x20 ordinal: 0x2
  ULONGLONG Count;                           // offset: 0x28 ordinal: 0x3
  ULONG Offset;                              // offset: 0x30 ordinal: 0x4
  ULONG Length;                              // offset: 0x34 ordinal: 0x5
  ULONG Who;                                 // offset: 0x38 ordinal: 0x6
  ULONG Hash;                                // offset: 0x3c ordinal: 0x7
  ULONGLONG Page;                            // offset: 0x40 ordinal: 0x8
  VOID *StackTrace[8];                       // offset: 0x48 ordinal: 0x9
  struct _EPROCESS *Process;                 // offset: 0x88 ordinal: 0xa
} _LOCK_TRACKER;

// 0x88 bytes (sizeof)
typedef struct _WNF_PROCESS_CONTEXT {
  struct _WNF_NODE_HEADER Header;                 // offset: 0x0 ordinal: 0x0
  struct _EPROCESS *Process;                      // offset: 0x8 ordinal: 0x1
  struct _LIST_ENTRY WnfProcessesListEntry;       // offset: 0x10 ordinal: 0x2
  VOID *ImplicitScopeInstances[3];                // offset: 0x20 ordinal: 0x3
  struct _WNF_LOCK TemporaryNamesListLock;        // offset: 0x38 ordinal: 0x4
  struct _LIST_ENTRY TemporaryNamesListHead;      // offset: 0x40 ordinal: 0x5
  struct _WNF_LOCK ProcessSubscriptionListLock;   // offset: 0x50 ordinal: 0x6
  struct _LIST_ENTRY ProcessSubscriptionListHead; // offset: 0x58 ordinal: 0x7
  struct _WNF_LOCK DeliveryPendingListLock;       // offset: 0x68 ordinal: 0x8
  struct _LIST_ENTRY DeliveryPendingListHead;     // offset: 0x70 ordinal: 0x9
  struct _KEVENT *NotificationEvent;              // offset: 0x80 ordinal: 0xa
} _WNF_PROCESS_CONTEXT;

// 0xa8 bytes (sizeof)
typedef struct _WNF_NAME_INSTANCE {
  struct _WNF_NODE_HEADER Header;            // offset: 0x0 ordinal: 0x0
  struct _EX_RUNDOWN_REF RunRef;             // offset: 0x8 ordinal: 0x1
  struct _RTL_BALANCED_NODE TreeLinks;       // offset: 0x10 ordinal: 0x2
  struct _WNF_STATE_NAME_STRUCT StateName;   // offset: 0x28 ordinal: 0x3
  struct _WNF_SCOPE_INSTANCE *ScopeInstance; // offset: 0x30 ordinal: 0x4
  struct _WNF_STATE_NAME_REGISTRATION
      StateNameInfo;                 // offset: 0x38 ordinal: 0x5
  struct _WNF_LOCK StateDataLock;    // offset: 0x50 ordinal: 0x6
  struct _WNF_STATE_DATA *StateData; // offset: 0x58 ordinal: 0x7
  ULONG CurrentChangeStamp;          // offset: 0x60 ordinal: 0x8
  struct _WNF_PERMANENT_DATA_STORE
      *PermanentDataStore;                      // offset: 0x68 ordinal: 0x9
  struct _WNF_LOCK StateSubscriptionListLock;   // offset: 0x70 ordinal: 0xa
  struct _LIST_ENTRY StateSubscriptionListHead; // offset: 0x78 ordinal: 0xb
  struct _LIST_ENTRY TemporaryNameListEntry;    // offset: 0x88 ordinal: 0xc
  struct _EPROCESS *CreatorProcess;             // offset: 0x98 ordinal: 0xd
  LONG DataSubscribersCount;                    // offset: 0xa0 ordinal: 0xe
  LONG CurrentDeliveryCount;                    // offset: 0xa4 ordinal: 0xf
} _WNF_NAME_INSTANCE;

// 0x88 bytes (sizeof)
typedef struct _WNF_SUBSCRIPTION {
  struct _WNF_NODE_HEADER Header;                  // offset: 0x0 ordinal: 0x0
  struct _EX_RUNDOWN_REF RunRef;                   // offset: 0x8 ordinal: 0x1
  ULONGLONG SubscriptionId;                        // offset: 0x10 ordinal: 0x2
  struct _LIST_ENTRY ProcessSubscriptionListEntry; // offset: 0x18 ordinal: 0x3
  struct _EPROCESS *Process;                       // offset: 0x28 ordinal: 0x4
  struct _WNF_NAME_INSTANCE *NameInstance;         // offset: 0x30 ordinal: 0x5
  struct _WNF_STATE_NAME_STRUCT StateName;         // offset: 0x38 ordinal: 0x6
  struct _LIST_ENTRY StateSubscriptionListEntry;   // offset: 0x40 ordinal: 0x7
  ULONGLONG CallbackRoutine;                       // offset: 0x50 ordinal: 0x8
  VOID *CallbackContext;                           // offset: 0x58 ordinal: 0x9
  ULONG CurrentChangeStamp;                        // offset: 0x60 ordinal: 0xa
  ULONG SubscribedEventSet;                        // offset: 0x64 ordinal: 0xb
  struct _LIST_ENTRY PendingSubscriptionListEntry; // offset: 0x68 ordinal: 0xc
  enum _WNF_SUBSCRIPTION_STATE SubscriptionState;  // offset: 0x78 ordinal: 0xd
  ULONG SignaledEventSet;                          // offset: 0x7c ordinal: 0xe
  ULONG InDeliveryEventSet;                        // offset: 0x80 ordinal: 0xf
} _WNF_SUBSCRIPTION;

// 0x10 bytes (sizeof)
typedef struct _OBJECT_HANDLE_COUNT_ENTRY {
  struct _EPROCESS *Process; // offset: 0x0 ordinal: 0x0
  ULONG HandleCount : 24;    // offset: 0x8 ordinal: 0x1
  ULONG LockCount : 8;       // offset: 0x8 ordinal: 0x2
} _OBJECT_HANDLE_COUNT_ENTRY;

// 0x18 bytes (sizeof)
typedef struct _OBJECT_HANDLE_COUNT_DATABASE {
  ULONG CountEntries; // offset: 0x0 ordinal: 0x0
  struct _OBJECT_HANDLE_COUNT_ENTRY
      HandleCountEntries[1]; // offset: 0x8 ordinal: 0x1
} _OBJECT_HANDLE_COUNT_DATABASE;

// 0x10 bytes (sizeof)
typedef struct _OBJECT_HEADER_HANDLE_INFO {
  union {
    struct _OBJECT_HANDLE_COUNT_DATABASE
        *HandleCountDataBase;                      // offset: 0x0 ordinal: 0x0
    struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // offset: 0x0 ordinal: 0x1
  };
} _OBJECT_HEADER_HANDLE_INFO;

// 0x10 bytes (sizeof)
typedef struct _OBJECT_HEADER_PROCESS_INFO {
  struct _EPROCESS *ExclusiveProcess; // offset: 0x0 ordinal: 0x0
  ULONGLONG Reserved;                 // offset: 0x8 ordinal: 0x1
} _OBJECT_HEADER_PROCESS_INFO;

typedef UCHAR (*__anon_2931)(struct _EPROCESS *, VOID *, VOID *, CHAR);

typedef VOID (*__anon_2926)(struct _EPROCESS *, VOID *, ULONGLONG, ULONGLONG);

typedef LONG (*__anon_2925)(enum _OB_OPEN_REASON, CHAR, struct _EPROCESS *,
                            VOID *, ULONG *, ULONG);

// 0x78 bytes (sizeof)
typedef struct _OBJECT_TYPE_INITIALIZER {
  USHORT Length; // offset: 0x0 ordinal: 0x0
  union {
    USHORT ObjectTypeFlags;    // offset: 0x2 ordinal: 0x1
    UCHAR CaseInsensitive : 1; // offset: 0x2 ordinal: 0x2
  };
  UCHAR UnnamedObjectsOnly : 1;           // offset: 0x2 ordinal: 0x3
  UCHAR UseDefaultObject : 1;             // offset: 0x2 ordinal: 0x4
  UCHAR SecurityRequired : 1;             // offset: 0x2 ordinal: 0x5
  UCHAR MaintainHandleCount : 1;          // offset: 0x2 ordinal: 0x6
  UCHAR MaintainTypeList : 1;             // offset: 0x2 ordinal: 0x7
  UCHAR SupportsObjectCallbacks : 1;      // offset: 0x2 ordinal: 0x8
  UCHAR CacheAligned : 1;                 // offset: 0x2 ordinal: 0x9
  UCHAR UseExtendedParameters : 1;        // offset: 0x3 ordinal: 0xa
  UCHAR Reserved : 7;                     // offset: 0x3 ordinal: 0xb
  ULONG ObjectTypeCode;                   // offset: 0x4 ordinal: 0xc
  ULONG InvalidAttributes;                // offset: 0x8 ordinal: 0xd
  struct _GENERIC_MAPPING GenericMapping; // offset: 0xc ordinal: 0xe
  ULONG ValidAccessMask;                  // offset: 0x1c ordinal: 0xf
  ULONG RetainAccess;                     // offset: 0x20 ordinal: 0x10
  enum _POOL_TYPE PoolType;               // offset: 0x24 ordinal: 0x11
  ULONG DefaultPagedPoolCharge;           // offset: 0x28 ordinal: 0x12
  ULONG DefaultNonPagedPoolCharge;        // offset: 0x2c ordinal: 0x13
  VOID(*DumpProcedure)
  (VOID *, struct _OBJECT_DUMP_CONTROL *); // offset: 0x30 ordinal: 0x14
  LONG(*OpenProcedure)
  (enum _OB_OPEN_REASON, CHAR, struct _EPROCESS *, VOID *, ULONG *,
   ULONG); // offset: 0x38 ordinal: 0x15
  VOID(*CloseProcedure)
  (struct _EPROCESS *, VOID *, ULONGLONG,
   ULONGLONG);                     // offset: 0x40 ordinal: 0x16
  VOID (*DeleteProcedure)(VOID *); // offset: 0x48 ordinal: 0x17
  union {
    LONG(*ParseProcedure)
    (VOID *, VOID *, struct _ACCESS_STATE *, CHAR, ULONG,
     struct _UNICODE_STRING *, struct _UNICODE_STRING *, VOID *,
     struct _SECURITY_QUALITY_OF_SERVICE *,
     VOID **); // offset: 0x50 ordinal: 0x18
    LONG(*ParseProcedureEx)
    (VOID *, VOID *, struct _ACCESS_STATE *, CHAR, ULONG,
     struct _UNICODE_STRING *, struct _UNICODE_STRING *, VOID *,
     struct _SECURITY_QUALITY_OF_SERVICE *,
     struct _OB_EXTENDED_PARSE_PARAMETERS *,
     VOID **); // offset: 0x50 ordinal: 0x19
  };
  LONG(*SecurityProcedure)
  (VOID *, enum _SECURITY_OPERATION_CODE, ULONG *, VOID *, ULONG *, VOID **,
   enum _POOL_TYPE, struct _GENERIC_MAPPING *,
   CHAR); // offset: 0x58 ordinal: 0x1a
  LONG(*QueryNameProcedure)
  (VOID *, UCHAR, struct _OBJECT_NAME_INFORMATION *, ULONG, ULONG *,
   CHAR); // offset: 0x60 ordinal: 0x1b
  UCHAR(*OkayToCloseProcedure)
  (struct _EPROCESS *, VOID *, VOID *, CHAR); // offset: 0x68 ordinal: 0x1c
  ULONG WaitObjectFlagMask;                   // offset: 0x70 ordinal: 0x1d
  USHORT WaitObjectFlagOffset;                // offset: 0x74 ordinal: 0x1e
  USHORT WaitObjectPointerOffset;             // offset: 0x76 ordinal: 0x1f
} _OBJECT_TYPE_INITIALIZER;

// 0xd8 bytes (sizeof)
typedef struct _OBJECT_TYPE {
  struct _LIST_ENTRY TypeList;              // offset: 0x0 ordinal: 0x0
  struct _UNICODE_STRING Name;              // offset: 0x10 ordinal: 0x1
  VOID *DefaultObject;                      // offset: 0x20 ordinal: 0x2
  UCHAR Index;                              // offset: 0x28 ordinal: 0x3
  ULONG TotalNumberOfObjects;               // offset: 0x2c ordinal: 0x4
  ULONG TotalNumberOfHandles;               // offset: 0x30 ordinal: 0x5
  ULONG HighWaterNumberOfObjects;           // offset: 0x34 ordinal: 0x6
  ULONG HighWaterNumberOfHandles;           // offset: 0x38 ordinal: 0x7
  struct _OBJECT_TYPE_INITIALIZER TypeInfo; // offset: 0x40 ordinal: 0x8
  struct _EX_PUSH_LOCK TypeLock;            // offset: 0xb8 ordinal: 0x9
  ULONG Key;                                // offset: 0xc0 ordinal: 0xa
  struct _LIST_ENTRY CallbackList;          // offset: 0xc8 ordinal: 0xb
} _OBJECT_TYPE;

// 0x28 bytes (sizeof)
typedef struct _OB_DUPLICATE_OBJECT_STATE {
  struct _EPROCESS *SourceProcess;            // offset: 0x0 ordinal: 0x0
  VOID *SourceHandle;                         // offset: 0x8 ordinal: 0x1
  VOID *Object;                               // offset: 0x10 ordinal: 0x2
  ULONG TargetAccess;                         // offset: 0x18 ordinal: 0x3
  struct _HANDLE_TABLE_ENTRY_INFO ObjectInfo; // offset: 0x1c ordinal: 0x4
  ULONG HandleAttributes;                     // offset: 0x24 ordinal: 0x5
} _OB_DUPLICATE_OBJECT_STATE;

// 0x30 bytes (sizeof)
typedef struct _KALPC_HANDLE_DATA {
  ULONG ObjectType; // offset: 0x0 ordinal: 0x0
  ULONG Count;      // offset: 0x4 ordinal: 0x1
  struct _OB_DUPLICATE_OBJECT_STATE
      DuplicateContext; // offset: 0x8 ordinal: 0x2
} _KALPC_HANDLE_DATA;

// 0x70 bytes (sizeof)
typedef struct _KALPC_SECURITY_DATA {
  struct _ALPC_HANDLE_TABLE *HandleTable;          // offset: 0x0 ordinal: 0x0
  VOID *ContextHandle;                             // offset: 0x8 ordinal: 0x1
  struct _EPROCESS *OwningProcess;                 // offset: 0x10 ordinal: 0x2
  struct _ALPC_PORT *OwnerPort;                    // offset: 0x18 ordinal: 0x3
  struct _SECURITY_CLIENT_CONTEXT DynamicSecurity; // offset: 0x20 ordinal: 0x4
  union __anon_2902 u1;                            // offset: 0x68 ordinal: 0x5
} _KALPC_SECURITY_DATA;

// 0x48 bytes (sizeof)
typedef struct _KALPC_MESSAGE_ATTRIBUTES {
  VOID *ClientContext;                       // offset: 0x0 ordinal: 0x0
  VOID *ServerContext;                       // offset: 0x8 ordinal: 0x1
  VOID *PortContext;                         // offset: 0x10 ordinal: 0x2
  VOID *CancelPortContext;                   // offset: 0x18 ordinal: 0x3
  struct _KALPC_SECURITY_DATA *SecurityData; // offset: 0x20 ordinal: 0x4
  struct _KALPC_VIEW *View;                  // offset: 0x28 ordinal: 0x5
  struct _KALPC_HANDLE_DATA *HandleData;     // offset: 0x30 ordinal: 0x6
  union _KALPC_DIRECT_EVENT DirectEvent;     // offset: 0x38 ordinal: 0x7
  struct _KALPC_WORK_ON_BEHALF_DATA
      WorkOnBehalfData; // offset: 0x40 ordinal: 0x8
} _KALPC_MESSAGE_ATTRIBUTES;

// 0x118 bytes (sizeof)
typedef struct _KALPC_MESSAGE {
  struct _LIST_ENTRY Entry;       // offset: 0x0 ordinal: 0x0
  struct _ALPC_PORT *PortQueue;   // offset: 0x10 ordinal: 0x1
  struct _ALPC_PORT *OwnerPort;   // offset: 0x18 ordinal: 0x2
  struct _ETHREAD *WaitingThread; // offset: 0x20 ordinal: 0x3
  union __anon_2884 u1;           // offset: 0x28 ordinal: 0x4
  LONG SequenceNo;                // offset: 0x2c ordinal: 0x5
  union {
    struct _EPROCESS *QuotaProcess; // offset: 0x30 ordinal: 0x6
    VOID *QuotaBlock;               // offset: 0x30 ordinal: 0x7
  };
  struct _ALPC_PORT *CancelSequencePort; // offset: 0x38 ordinal: 0x8
  struct _ALPC_PORT *CancelQueuePort;    // offset: 0x40 ordinal: 0x9
  LONG CancelSequenceNo;                 // offset: 0x48 ordinal: 0xa
  struct _LIST_ENTRY CancelListEntry;    // offset: 0x50 ordinal: 0xb
  struct _KALPC_RESERVE *Reserve;        // offset: 0x60 ordinal: 0xc
  struct _KALPC_MESSAGE_ATTRIBUTES
      MessageAttributes; // offset: 0x68 ordinal: 0xd
  VOID *DataUserVa;      // offset: 0xb0 ordinal: 0xe
  struct _ALPC_COMMUNICATION_INFO
      *CommunicationInfo;            // offset: 0xb8 ordinal: 0xf
  struct _ALPC_PORT *ConnectionPort; // offset: 0xc0 ordinal: 0x10
  struct _ETHREAD *ServerThread;     // offset: 0xc8 ordinal: 0x11
  VOID *WakeReference;               // offset: 0xd0 ordinal: 0x12
  VOID *WakeReference2;              // offset: 0xd8 ordinal: 0x13
  VOID *ExtensionBuffer;             // offset: 0xe0 ordinal: 0x14
  ULONGLONG ExtensionBufferSize;     // offset: 0xe8 ordinal: 0x15
  struct _PORT_MESSAGE PortMessage;  // offset: 0xf0 ordinal: 0x16
} _KALPC_MESSAGE;

// 0x40 bytes (sizeof)
typedef struct _ALPC_DISPATCH_CONTEXT {
  struct _ALPC_PORT *PortObject;  // offset: 0x0 ordinal: 0x0
  struct _KALPC_MESSAGE *Message; // offset: 0x8 ordinal: 0x1
  struct _ALPC_COMMUNICATION_INFO
      *CommunicationInfo;                // offset: 0x10 ordinal: 0x2
  struct _ETHREAD *TargetThread;         // offset: 0x18 ordinal: 0x3
  struct _ALPC_PORT *TargetPort;         // offset: 0x20 ordinal: 0x4
  union _KALPC_DIRECT_EVENT DirectEvent; // offset: 0x28 ordinal: 0x5
  ULONG Flags;                           // offset: 0x30 ordinal: 0x6
  USHORT TotalLength;                    // offset: 0x34 ordinal: 0x7
  USHORT Type;                           // offset: 0x36 ordinal: 0x8
  USHORT DataInfoOffset;                 // offset: 0x38 ordinal: 0x9
  UCHAR SignalCompletion;                // offset: 0x3a ordinal: 0xa
  UCHAR PostedToCompletionList;          // offset: 0x3b ordinal: 0xb
} _ALPC_DISPATCH_CONTEXT;

// 0x30 bytes (sizeof)
typedef struct _KALPC_RESERVE {
  struct _ALPC_PORT *OwnerPort;           // offset: 0x0 ordinal: 0x0
  struct _ALPC_HANDLE_TABLE *HandleTable; // offset: 0x8 ordinal: 0x1
  VOID *Handle;                           // offset: 0x10 ordinal: 0x2
  struct _KALPC_MESSAGE *Message;         // offset: 0x18 ordinal: 0x3
  ULONGLONG Size;                         // offset: 0x20 ordinal: 0x4
  LONG Active;                            // offset: 0x28 ordinal: 0x5
} _KALPC_RESERVE;

// 0x50 bytes (sizeof)
typedef struct _ALPC_COMMUNICATION_INFO {
  struct _ALPC_PORT *ConnectionPort;          // offset: 0x0 ordinal: 0x0
  struct _ALPC_PORT *ServerCommunicationPort; // offset: 0x8 ordinal: 0x1
  struct _ALPC_PORT *ClientCommunicationPort; // offset: 0x10 ordinal: 0x2
  struct _LIST_ENTRY CommunicationList;       // offset: 0x18 ordinal: 0x3
  struct _ALPC_HANDLE_TABLE HandleTable;      // offset: 0x28 ordinal: 0x4
  struct _KALPC_MESSAGE *CloseMessage;        // offset: 0x48 ordinal: 0x5
} _ALPC_COMMUNICATION_INFO;

// 0xa0 bytes (sizeof)
typedef struct _ALPC_COMPLETION_LIST {
  struct _LIST_ENTRY Entry;                    // offset: 0x0 ordinal: 0x0
  struct _EPROCESS *OwnerProcess;              // offset: 0x10 ordinal: 0x1
  struct _EX_PUSH_LOCK CompletionListLock;     // offset: 0x18 ordinal: 0x2
  struct _MDL *Mdl;                            // offset: 0x20 ordinal: 0x3
  VOID *UserVa;                                // offset: 0x28 ordinal: 0x4
  VOID *UserLimit;                             // offset: 0x30 ordinal: 0x5
  VOID *DataUserVa;                            // offset: 0x38 ordinal: 0x6
  VOID *SystemVa;                              // offset: 0x40 ordinal: 0x7
  ULONGLONG TotalSize;                         // offset: 0x48 ordinal: 0x8
  struct _ALPC_COMPLETION_LIST_HEADER *Header; // offset: 0x50 ordinal: 0x9
  VOID *List;                                  // offset: 0x58 ordinal: 0xa
  ULONGLONG ListSize;                          // offset: 0x60 ordinal: 0xb
  VOID *Bitmap;                                // offset: 0x68 ordinal: 0xc
  ULONGLONG BitmapSize;                        // offset: 0x70 ordinal: 0xd
  VOID *Data;                                  // offset: 0x78 ordinal: 0xe
  ULONGLONG DataSize;                          // offset: 0x80 ordinal: 0xf
  ULONG BitmapLimit;                           // offset: 0x88 ordinal: 0x10
  ULONG BitmapNextHint;                        // offset: 0x8c ordinal: 0x11
  ULONG ConcurrencyCount;                      // offset: 0x90 ordinal: 0x12
  ULONG AttributeFlags;                        // offset: 0x94 ordinal: 0x13
  ULONG AttributeSize;                         // offset: 0x98 ordinal: 0x14
} _ALPC_COMPLETION_LIST;

// 0x1d8 bytes (sizeof)
typedef struct _ALPC_PORT {
  struct _LIST_ENTRY PortListEntry; // offset: 0x0 ordinal: 0x0
  struct _ALPC_COMMUNICATION_INFO
      *CommunicationInfo;         // offset: 0x10 ordinal: 0x1
  struct _EPROCESS *OwnerProcess; // offset: 0x18 ordinal: 0x2
  struct _KQUEUE *CompletionPort; // offset: 0x20 ordinal: 0x3
  VOID *CompletionKey;            // offset: 0x28 ordinal: 0x4
  struct _ALPC_COMPLETION_PACKET_LOOKASIDE
      *CompletionPacketLookaside;                 // offset: 0x30 ordinal: 0x5
  VOID *PortContext;                              // offset: 0x38 ordinal: 0x6
  struct _SECURITY_CLIENT_CONTEXT StaticSecurity; // offset: 0x40 ordinal: 0x7
  struct _EX_PUSH_LOCK IncomingQueueLock;         // offset: 0x88 ordinal: 0x8
  struct _LIST_ENTRY MainQueue;                   // offset: 0x90 ordinal: 0x9
  struct _LIST_ENTRY LargeMessageQueue;           // offset: 0xa0 ordinal: 0xa
  struct _EX_PUSH_LOCK PendingQueueLock;          // offset: 0xb0 ordinal: 0xb
  struct _LIST_ENTRY PendingQueue;                // offset: 0xb8 ordinal: 0xc
  struct _EX_PUSH_LOCK DirectQueueLock;           // offset: 0xc8 ordinal: 0xd
  struct _LIST_ENTRY DirectQueue;                 // offset: 0xd0 ordinal: 0xe
  struct _EX_PUSH_LOCK WaitQueueLock;             // offset: 0xe0 ordinal: 0xf
  struct _LIST_ENTRY WaitQueue;                   // offset: 0xe8 ordinal: 0x10
  union {
    struct _KSEMAPHORE *Semaphore; // offset: 0xf8 ordinal: 0x11
    struct _KEVENT *DummyEvent;    // offset: 0xf8 ordinal: 0x12
  };
  struct _ALPC_PORT_ATTRIBUTES PortAttributes;  // offset: 0x100 ordinal: 0x13
  struct _EX_PUSH_LOCK ResourceListLock;        // offset: 0x148 ordinal: 0x14
  struct _LIST_ENTRY ResourceListHead;          // offset: 0x150 ordinal: 0x15
  struct _EX_PUSH_LOCK PortObjectLock;          // offset: 0x160 ordinal: 0x16
  struct _ALPC_COMPLETION_LIST *CompletionList; // offset: 0x168 ordinal: 0x17
  struct _CALLBACK_OBJECT *CallbackObject;      // offset: 0x170 ordinal: 0x18
  VOID *CallbackContext;                        // offset: 0x178 ordinal: 0x19
  struct _LIST_ENTRY CanceledQueue;             // offset: 0x180 ordinal: 0x1a
  LONG SequenceNo;                              // offset: 0x190 ordinal: 0x1b
  LONG ReferenceNo;                             // offset: 0x194 ordinal: 0x1c
  struct _PALPC_PORT_REFERENCE_WAIT_BLOCK
      *ReferenceNoWait;                  // offset: 0x198 ordinal: 0x1d
  union __anon_2873 u1;                  // offset: 0x1a0 ordinal: 0x1e
  struct _ALPC_PORT *TargetQueuePort;    // offset: 0x1a8 ordinal: 0x1f
  struct _ALPC_PORT *TargetSequencePort; // offset: 0x1b0 ordinal: 0x20
  struct _KALPC_MESSAGE *CachedMessage;  // offset: 0x1b8 ordinal: 0x21
  ULONG MainQueueLength;                 // offset: 0x1c0 ordinal: 0x22
  ULONG LargeMessageQueueLength;         // offset: 0x1c4 ordinal: 0x23
  ULONG PendingQueueLength;              // offset: 0x1c8 ordinal: 0x24
  ULONG DirectQueueLength;               // offset: 0x1cc ordinal: 0x25
  ULONG CanceledQueueLength;             // offset: 0x1d0 ordinal: 0x26
  ULONG WaitQueueLength;                 // offset: 0x1d4 ordinal: 0x27
} _ALPC_PORT;

// 0x48 bytes (sizeof)
typedef struct _KALPC_SECTION {
  VOID *SectionObject;                    // offset: 0x0 ordinal: 0x0
  ULONGLONG Size;                         // offset: 0x8 ordinal: 0x1
  struct _ALPC_HANDLE_TABLE *HandleTable; // offset: 0x10 ordinal: 0x2
  VOID *SectionHandle;                    // offset: 0x18 ordinal: 0x3
  struct _EPROCESS *OwnerProcess;         // offset: 0x20 ordinal: 0x4
  struct _ALPC_PORT *OwnerPort;           // offset: 0x28 ordinal: 0x5
  union __anon_2859 u1;                   // offset: 0x30 ordinal: 0x6
  ULONG NumberOfRegions;                  // offset: 0x34 ordinal: 0x7
  struct _LIST_ENTRY RegionListHead;      // offset: 0x38 ordinal: 0x8
} _KALPC_SECTION;

// 0x58 bytes (sizeof)
typedef struct _KALPC_REGION {
  struct _LIST_ENTRY RegionListEntry; // offset: 0x0 ordinal: 0x0
  struct _KALPC_SECTION *Section;     // offset: 0x10 ordinal: 0x1
  ULONGLONG Offset;                   // offset: 0x18 ordinal: 0x2
  ULONGLONG Size;                     // offset: 0x20 ordinal: 0x3
  ULONGLONG ViewSize;                 // offset: 0x28 ordinal: 0x4
  union __anon_2911 u1;               // offset: 0x30 ordinal: 0x5
  ULONG NumberOfViews;                // offset: 0x34 ordinal: 0x6
  struct _LIST_ENTRY ViewListHead;    // offset: 0x38 ordinal: 0x7
  struct _KALPC_VIEW *ReadOnlyView;   // offset: 0x48 ordinal: 0x8
  struct _KALPC_VIEW *ReadWriteView;  // offset: 0x50 ordinal: 0x9
} _KALPC_REGION;

// 0x60 bytes (sizeof)
typedef struct _KALPC_VIEW {
  struct _LIST_ENTRY ViewListEntry;        // offset: 0x0 ordinal: 0x0
  struct _KALPC_REGION *Region;            // offset: 0x10 ordinal: 0x1
  struct _ALPC_PORT *OwnerPort;            // offset: 0x18 ordinal: 0x2
  struct _EPROCESS *OwnerProcess;          // offset: 0x20 ordinal: 0x3
  VOID *Address;                           // offset: 0x28 ordinal: 0x4
  ULONGLONG Size;                          // offset: 0x30 ordinal: 0x5
  VOID *SecureViewHandle;                  // offset: 0x38 ordinal: 0x6
  VOID *WriteAccessHandle;                 // offset: 0x40 ordinal: 0x7
  union __anon_2904 u1;                    // offset: 0x48 ordinal: 0x8
  ULONG NumberOfOwnerMessages;             // offset: 0x4c ordinal: 0x9
  struct _LIST_ENTRY ProcessViewListEntry; // offset: 0x50 ordinal: 0xa
} _KALPC_VIEW;

// 0x70 bytes (sizeof)
typedef struct __anon_2717 {
  struct _SHARED_CACHE_MAP *SharedCacheMap;       // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER FileOffset;                // offset: 0x8 ordinal: 0x1
  struct _FILE_OBJECT *FileObject;                // offset: 0x10 ordinal: 0x2
  ULONG Length;                                   // offset: 0x18 ordinal: 0x3
  struct _SINGLE_LIST_ENTRY *PrefetchList;        // offset: 0x20 ordinal: 0x4
  ULONG PrefetchPagePriority;                     // offset: 0x28 ordinal: 0x5
  struct _MDL *Mdl;                               // offset: 0x30 ordinal: 0x6
  struct _IO_STATUS_BLOCK *IoStatusBlock;         // offset: 0x38 ordinal: 0x7
  struct _CC_ASYNC_READ_CONTEXT *CallbackContext; // offset: 0x40 ordinal: 0x8
  struct _EPROCESS *OriginatingProcess;           // offset: 0x48 ordinal: 0x9
  struct _ETHREAD *IoIssuerThread;                // offset: 0x50 ordinal: 0xa
  VOID *DiskIoAttribution;                        // offset: 0x58 ordinal: 0xb
  CHAR RequestorMode;                             // offset: 0x60 ordinal: 0xc
  ULONG NestingLevel;                             // offset: 0x64 ordinal: 0xd
  union _LARGE_INTEGER StartTime;                 // offset: 0x68 ordinal: 0xe
} __anon_2717;

// 0x70 bytes (sizeof)
typedef union __anon_2729 {
  struct __anon_2712 Read;             // offset: 0x0 ordinal: 0x0
  struct __anon_2713 Write;            // offset: 0x0 ordinal: 0x1
  struct __anon_2714 Event;            // offset: 0x0 ordinal: 0x2
  struct __anon_2715 Notification;     // offset: 0x0 ordinal: 0x3
  struct __anon_2716 LowPriWrite;      // offset: 0x0 ordinal: 0x4
  struct __anon_2717 AsyncRead;        // offset: 0x0 ordinal: 0x5
  struct __anon_2720 AsyncWriteBehind; // offset: 0x0 ordinal: 0x6
} __anon_2729;

// 0xa0 bytes (sizeof)
typedef struct _WORK_QUEUE_ENTRY {
  struct _LIST_ENTRY WorkQueueLinks; // offset: 0x0 ordinal: 0x0
  union __anon_2729 Parameters;      // offset: 0x10 ordinal: 0x1
  enum _WORKER_FUNCTION Function;    // offset: 0x80 ordinal: 0x2
  struct _CC_PARTITION *Partition;   // offset: 0x88 ordinal: 0x3
  struct _PRIVATE_VOLUME_CACHEMAP
      *PrivateVolumeCacheMap;     // offset: 0x90 ordinal: 0x4
  struct _CC_NUMA_NODE *NumaNode; // offset: 0x98 ordinal: 0x5
} _WORK_QUEUE_ENTRY;

// 0x108 bytes (sizeof)
typedef struct _CC_FLUSH_PACKET {
  struct _CC_PARTITION *Partition; // offset: 0x0 ordinal: 0x0
  struct _PRIVATE_VOLUME_CACHEMAP
      *PrivateVolumeCacheMap;               // offset: 0x8 ordinal: 0x1
  struct _SHARED_CACHE_MAP *SharedCacheMap; // offset: 0x10 ordinal: 0x2
  struct _SECTION_OBJECT_POINTERS
      *SectionObjectPointer;                  // offset: 0x18 ordinal: 0x3
  union _LARGE_INTEGER TargetOffset;          // offset: 0x20 ordinal: 0x4
  union _LARGE_INTEGER NextFileOffset;        // offset: 0x28 ordinal: 0x5
  ULONG NextLength;                           // offset: 0x30 ordinal: 0x6
  ULONG BytesWritten;                         // offset: 0x34 ordinal: 0x7
  ULONG MmFlushFlags;                         // offset: 0x38 ordinal: 0x8
  ULONG HotSpot;                              // offset: 0x3c ordinal: 0x9
  ULONG VerifyRequired;                       // offset: 0x40 ordinal: 0xa
  struct _KEVENT *FlushEvent;                 // offset: 0x48 ordinal: 0xb
  union _LARGE_INTEGER FlushLargestLsn;       // offset: 0x50 ordinal: 0xc
  union _LARGE_INTEGER *LargestLsn;           // offset: 0x58 ordinal: 0xd
  union _LARGE_INTEGER *CallersFileOffset;    // offset: 0x60 ordinal: 0xe
  ULONG CallersLength;                        // offset: 0x68 ordinal: 0xf
  UCHAR MarkWritethrough;                     // offset: 0x6c ordinal: 0x10
  struct _IO_STATUS_BLOCK *CallersIoStatus;   // offset: 0x70 ordinal: 0x11
  struct _BCB *FirstBcb;                      // offset: 0x78 ordinal: 0x12
  LONG FirstFailureStatus;                    // offset: 0x80 ordinal: 0x13
  UCHAR IsLazyWriter;                         // offset: 0x84 ordinal: 0x14
  UCHAR FastLazyWrite;                        // offset: 0x85 ordinal: 0x15
  UCHAR ForceFullFlush;                       // offset: 0x86 ordinal: 0x16
  UCHAR PerformedFlushForMemMapped;           // offset: 0x87 ordinal: 0x17
  UCHAR TeardownFlagBeforeFlush;              // offset: 0x88 ordinal: 0x18
  UCHAR ShouldRetryTeardown;                  // offset: 0x89 ordinal: 0x19
  UCHAR FlushForImageSection;                 // offset: 0x8a ordinal: 0x1a
  UCHAR ForceSynchronousLazyWrite;            // offset: 0x8b ordinal: 0x1b
  ULONG AcquireForLazyWriteOutFlags;          // offset: 0x8c ordinal: 0x1c
  union _LARGE_INTEGER StartTick;             // offset: 0x90 ordinal: 0x1d
  union _LARGE_INTEGER EndTick;               // offset: 0x98 ordinal: 0x1e
  struct _FSRTL_COMMON_FCB_HEADER *FsContext; // offset: 0xa0 ordinal: 0x1f
  struct _WORK_QUEUE_ENTRY *WorkEntry;        // offset: 0xa8 ordinal: 0x20
  struct _LIST_ENTRY *DeferredWritesList;     // offset: 0xb0 ordinal: 0x21
  UCHAR *CoalescingState;                     // offset: 0xb8 ordinal: 0x22
  UCHAR DoSinglePassFlush;                    // offset: 0xc0 ordinal: 0x23
  UCHAR RecordedSinglePassStartOffset;        // offset: 0xc1 ordinal: 0x24
  union _LARGE_INTEGER SinglePassStartOffset; // offset: 0xc8 ordinal: 0x25
  ULONGLONG DirtyPagesAtStart;                // offset: 0xd0 ordinal: 0x26
  ULONGLONG TotalBytesWritten;                // offset: 0xd8 ordinal: 0x27
  union _LARGE_INTEGER LwFlushStart;          // offset: 0xe0 ordinal: 0x28
  union _LARGE_INTEGER LwFlushEnd;            // offset: 0xe8 ordinal: 0x29
  ULONG TotalPagesFlushed;                    // offset: 0xf0 ordinal: 0x2a
  ULONG PagesToWrite;                         // offset: 0xf4 ordinal: 0x2b
  ULONG RequeueToHeadCount;                   // offset: 0xf8 ordinal: 0x2c
  struct _WORK_QUEUE_ENTRY *WorkQueueEntry;   // offset: 0x100 ordinal: 0x2d
} _CC_FLUSH_PACKET;

// 0x28 bytes (sizeof)
typedef struct _KRESOURCEMANAGER_COMPLETION_BINDING {
  struct _LIST_ENTRY NotificationListHead; // offset: 0x0 ordinal: 0x0
  VOID *Port;                              // offset: 0x10 ordinal: 0x1
  ULONGLONG Key;                           // offset: 0x18 ordinal: 0x2
  struct _EPROCESS *BindingProcess;        // offset: 0x20 ordinal: 0x3
} _KRESOURCEMANAGER_COMPLETION_BINDING;

// 0x250 bytes (sizeof)
typedef struct _KRESOURCEMANAGER {
  struct _KEVENT NotificationAvailable;           // offset: 0x0 ordinal: 0x0
  ULONG cookie;                                   // offset: 0x18 ordinal: 0x1
  enum _KRESOURCEMANAGER_STATE State;             // offset: 0x1c ordinal: 0x2
  ULONG Flags;                                    // offset: 0x20 ordinal: 0x3
  struct _KMUTANT Mutex;                          // offset: 0x28 ordinal: 0x4
  struct _KTMOBJECT_NAMESPACE_LINK NamespaceLink; // offset: 0x60 ordinal: 0x5
  struct _GUID RmId;                              // offset: 0x88 ordinal: 0x6
  struct _KQUEUE NotificationQueue;               // offset: 0x98 ordinal: 0x7
  struct _KMUTANT NotificationMutex;              // offset: 0xd8 ordinal: 0x8
  struct _LIST_ENTRY EnlistmentHead;              // offset: 0x110 ordinal: 0x9
  ULONG EnlistmentCount;                          // offset: 0x120 ordinal: 0xa
  LONG(*NotificationRoutine)
  (struct _KENLISTMENT *, VOID *, VOID *, ULONG, union _LARGE_INTEGER *, ULONG,
   VOID *);                                  // offset: 0x128 ordinal: 0xb
  VOID *Key;                                 // offset: 0x130 ordinal: 0xc
  struct _LIST_ENTRY ProtocolListHead;       // offset: 0x138 ordinal: 0xd
  struct _LIST_ENTRY PendingPropReqListHead; // offset: 0x148 ordinal: 0xe
  struct _LIST_ENTRY CRMListEntry;           // offset: 0x158 ordinal: 0xf
  struct _KTM *Tm;                           // offset: 0x168 ordinal: 0x10
  struct _UNICODE_STRING Description;        // offset: 0x170 ordinal: 0x11
  struct _KTMOBJECT_NAMESPACE Enlistments;   // offset: 0x180 ordinal: 0x12
  struct _KRESOURCEMANAGER_COMPLETION_BINDING
      CompletionBinding; // offset: 0x228 ordinal: 0x13
} _KRESOURCEMANAGER;

// 0x3c0 bytes (sizeof)
typedef struct _KTM {
  ULONG cookie;                                   // offset: 0x0 ordinal: 0x0
  struct _KMUTANT Mutex;                          // offset: 0x8 ordinal: 0x1
  enum KTM_STATE State;                           // offset: 0x40 ordinal: 0x2
  struct _KTMOBJECT_NAMESPACE_LINK NamespaceLink; // offset: 0x48 ordinal: 0x3
  struct _GUID TmIdentity;                        // offset: 0x70 ordinal: 0x4
  ULONG Flags;                                    // offset: 0x80 ordinal: 0x5
  ULONG VolatileFlags;                            // offset: 0x84 ordinal: 0x6
  struct _UNICODE_STRING LogFileName;             // offset: 0x88 ordinal: 0x7
  struct _FILE_OBJECT *LogFileObject;             // offset: 0x98 ordinal: 0x8
  VOID *MarshallingContext;                       // offset: 0xa0 ordinal: 0x9
  VOID *LogManagementContext;                     // offset: 0xa8 ordinal: 0xa
  struct _KTMOBJECT_NAMESPACE Transactions;       // offset: 0xb0 ordinal: 0xb
  struct _KTMOBJECT_NAMESPACE ResourceManagers;   // offset: 0x158 ordinal: 0xc
  struct _KMUTANT LsnOrderedMutex;                // offset: 0x200 ordinal: 0xd
  struct _LIST_ENTRY LsnOrderedList;              // offset: 0x238 ordinal: 0xe
  union _LARGE_INTEGER CommitVirtualClock;        // offset: 0x248 ordinal: 0xf
  struct _FAST_MUTEX CommitVirtualClockMutex;     // offset: 0x250 ordinal: 0x10
  union _CLS_LSN BaseLsn;                         // offset: 0x288 ordinal: 0x11
  union _CLS_LSN CurrentReadLsn;                  // offset: 0x290 ordinal: 0x12
  union _CLS_LSN LastRecoveredLsn;                // offset: 0x298 ordinal: 0x13
  VOID *TmRmHandle;                               // offset: 0x2a0 ordinal: 0x14
  struct _KRESOURCEMANAGER *TmRm;                 // offset: 0x2a8 ordinal: 0x15
  struct _KEVENT LogFullNotifyEvent;              // offset: 0x2b0 ordinal: 0x16
  struct _WORK_QUEUE_ITEM CheckpointWorkItem;     // offset: 0x2c8 ordinal: 0x17
  union _CLS_LSN CheckpointTargetLsn;             // offset: 0x2e8 ordinal: 0x18
  struct _WORK_QUEUE_ITEM
      LogFullCompletedWorkItem;            // offset: 0x2f0 ordinal: 0x19
  struct _ERESOURCE LogWriteResource;      // offset: 0x310 ordinal: 0x1a
  ULONG LogFlags;                          // offset: 0x378 ordinal: 0x1b
  LONG LogFullStatus;                      // offset: 0x37c ordinal: 0x1c
  LONG RecoveryStatus;                     // offset: 0x380 ordinal: 0x1d
  union _CLS_LSN LastCheckBaseLsn;         // offset: 0x388 ordinal: 0x1e
  struct _LIST_ENTRY RestartOrderedList;   // offset: 0x390 ordinal: 0x1f
  struct _WORK_QUEUE_ITEM OfflineWorkItem; // offset: 0x3a0 ordinal: 0x20
} _KTM;

// 0x1e0 bytes (sizeof)
typedef struct _KENLISTMENT {
  ULONG cookie;                                   // offset: 0x0 ordinal: 0x0
  struct _KTMOBJECT_NAMESPACE_LINK NamespaceLink; // offset: 0x8 ordinal: 0x1
  struct _GUID EnlistmentId;                      // offset: 0x30 ordinal: 0x2
  struct _KMUTANT Mutex;                          // offset: 0x40 ordinal: 0x3
  struct _LIST_ENTRY NextSameTx;                  // offset: 0x78 ordinal: 0x4
  struct _LIST_ENTRY NextSameRm;                  // offset: 0x88 ordinal: 0x5
  struct _KRESOURCEMANAGER *ResourceManager;      // offset: 0x98 ordinal: 0x6
  struct _KTRANSACTION *Transaction;              // offset: 0xa0 ordinal: 0x7
  enum _KENLISTMENT_STATE State;                  // offset: 0xa8 ordinal: 0x8
  ULONG Flags;                                    // offset: 0xac ordinal: 0x9
  ULONG NotificationMask;                         // offset: 0xb0 ordinal: 0xa
  VOID *Key;                                      // offset: 0xb8 ordinal: 0xb
  ULONG KeyRefCount;                              // offset: 0xc0 ordinal: 0xc
  VOID *RecoveryInformation;                      // offset: 0xc8 ordinal: 0xd
  ULONG RecoveryInformationLength;                // offset: 0xd0 ordinal: 0xe
  VOID *DynamicNameInformation;                   // offset: 0xd8 ordinal: 0xf
  ULONG DynamicNameInformationLength;             // offset: 0xe0 ordinal: 0x10
  struct _KTMNOTIFICATION_PACKET
      *FinalNotification;                  // offset: 0xe8 ordinal: 0x11
  struct _KENLISTMENT *SupSubEnlistment;   // offset: 0xf0 ordinal: 0x12
  VOID *SupSubEnlHandle;                   // offset: 0xf8 ordinal: 0x13
  VOID *SubordinateTxHandle;               // offset: 0x100 ordinal: 0x14
  struct _GUID CrmEnlistmentEnId;          // offset: 0x108 ordinal: 0x15
  struct _GUID CrmEnlistmentTmId;          // offset: 0x118 ordinal: 0x16
  struct _GUID CrmEnlistmentRmId;          // offset: 0x128 ordinal: 0x17
  ULONG NextHistory;                       // offset: 0x138 ordinal: 0x18
  struct _KENLISTMENT_HISTORY History[20]; // offset: 0x13c ordinal: 0x19
} _KENLISTMENT;

// 0xb0 bytes (sizeof)
typedef struct _MI_PARTITION_STORES {
  union __anon_2159 WriteAllStoreSwapPages;      // offset: 0x0 ordinal: 0x0
  ULONG VirtualPageFileNumber;                   // offset: 0x4 ordinal: 0x1
  ULONG Registered;                              // offset: 0x8 ordinal: 0x2
  ULONG ReadClusterSizeMax;                      // offset: 0xc ordinal: 0x3
  ULONG EvictFlushRequestCount;                  // offset: 0x10 ordinal: 0x4
  ULONG ModifiedWriteDisableCount;               // offset: 0x14 ordinal: 0x5
  ULONG WriteIssueFailures;                      // offset: 0x18 ordinal: 0x6
  ULONG WritesOutstanding;                       // offset: 0x1c ordinal: 0x7
  struct _KEVENT *RundownWrites;                 // offset: 0x20 ordinal: 0x8
  LONG EvictFlushLock;                           // offset: 0x28 ordinal: 0x9
  struct _ETHREAD *EvictionThread;               // offset: 0x30 ordinal: 0xa
  struct _KEVENT EvictEvent;                     // offset: 0x38 ordinal: 0xb
  struct _KEVENT EvictThreadExitEvent;           // offset: 0x50 ordinal: 0xc
  union _SLIST_HEADER WriteSupportSListHead;     // offset: 0x70 ordinal: 0xd
  struct _KEVENT EvictFlushCompleteEvent;        // offset: 0x80 ordinal: 0xe
  struct _RTL_BITMAP *ModifiedWriteFailedBitmap; // offset: 0x98 ordinal: 0xf
  struct _EPROCESS *StoreProcess;                // offset: 0xa0 ordinal: 0x10
  LONG MemoryConditionsLock;                     // offset: 0xa8 ordinal: 0x11
  ULONG DeleteStoredPages;                       // offset: 0xac ordinal: 0x12
} _MI_PARTITION_STORES;

// 0x48 bytes (sizeof)
typedef struct _MM_PAGE_ACCESS_INFO_HEADER {
  struct _SINGLE_LIST_ENTRY Link; // offset: 0x0 ordinal: 0x0
  enum _MM_PAGE_ACCESS_TYPE Type; // offset: 0x8 ordinal: 0x1
  union {
    ULONG EmptySequenceNumber; // offset: 0xc ordinal: 0x2
    ULONG CurrentFileIndex;    // offset: 0xc ordinal: 0x3
  };
  ULONGLONG CreateTime; // offset: 0x10 ordinal: 0x4
  union {
    ULONGLONG EmptyTime;                    // offset: 0x18 ordinal: 0x5
    struct _MM_PAGE_ACCESS_INFO *TempEntry; // offset: 0x18 ordinal: 0x6
  };
  struct _MM_PAGE_ACCESS_INFO *PageEntry; // offset: 0x20 ordinal: 0x7
  ULONGLONG *FileEntry;                   // offset: 0x28 ordinal: 0x8
  ULONGLONG *FirstFileEntry;              // offset: 0x30 ordinal: 0x9
  struct _EPROCESS *Process;              // offset: 0x38 ordinal: 0xa
  ULONG SessionId;                        // offset: 0x40 ordinal: 0xb
  ULONGLONG *PageFrameEntry;              // offset: 0x20 ordinal: 0xc
  ULONGLONG *LastPageFrameEntry;          // offset: 0x28 ordinal: 0xd
} _MM_PAGE_ACCESS_INFO_HEADER;

// 0x1a0 bytes (sizeof)
typedef struct _MI_STANDBY_STATE {
  ULONGLONG FirstDecayPage;              // offset: 0x0 ordinal: 0x0
  union _SLIST_HEADER PfnDecayFreeSList; // offset: 0x10 ordinal: 0x1
  LONG DecayPfnLock;                     // offset: 0x20 ordinal: 0x2
  struct _RTL_BITMAP DecayPfnsToBeFreed; // offset: 0x28 ordinal: 0x3
  ULONG DecayPfnsToBeFreedBuffer[64];    // offset: 0x38 ordinal: 0x4
  struct _MM_PAGE_ACCESS_INFO_HEADER
      *PfnRepurposeLog;                  // offset: 0x138 ordinal: 0x5
  struct _KDPC AllocatePfnRepurposeDpc;  // offset: 0x140 ordinal: 0x6
  union _SLIST_HEADER PageHeatListSlist; // offset: 0x180 ordinal: 0x7
  LONG PageHeatListDisableAllocation;    // offset: 0x190 ordinal: 0x8
} _MI_STANDBY_STATE;

// 0x80 bytes (sizeof)
typedef struct _MI_ACCESS_LOG_STATE {
  struct _MM_PAGE_ACCESS_INFO_HEADER *CcAccessLog; // offset: 0x0 ordinal: 0x0
  struct _WORK_QUEUE_ITEM DisableAccessLogging;    // offset: 0x8 ordinal: 0x1
  ULONG Enabled;                                   // offset: 0x28 ordinal: 0x2
  ULONG MinLoggingPriority;                        // offset: 0x2c ordinal: 0x3
  ULONGLONG AccessLoggingLock;                     // offset: 0x40 ordinal: 0x4
} _MI_ACCESS_LOG_STATE;

// 0x88 bytes (sizeof)
typedef struct _EPARTITION {
  VOID *MmPartition;                        // offset: 0x0 ordinal: 0x0
  VOID *CcPartition;                        // offset: 0x8 ordinal: 0x1
  VOID *ExPartition;                        // offset: 0x10 ordinal: 0x2
  VOID *SmPartition;                        // offset: 0x18 ordinal: 0x3
  LONGLONG HardReferenceCount;              // offset: 0x20 ordinal: 0x4
  LONGLONG OpenHandleCount;                 // offset: 0x28 ordinal: 0x5
  struct _LIST_ENTRY ActivePartitionLinks;  // offset: 0x30 ordinal: 0x6
  struct _EPARTITION *ParentPartition;      // offset: 0x40 ordinal: 0x7
  struct _WORK_QUEUE_ITEM TeardownWorkItem; // offset: 0x48 ordinal: 0x8
  struct _EX_PUSH_LOCK TeardownLock;        // offset: 0x68 ordinal: 0x9
  struct _EPROCESS *SystemProcess;          // offset: 0x70 ordinal: 0xa
  VOID *SystemProcessHandle;                // offset: 0x78 ordinal: 0xb
  union {
    ULONG PartitionFlags;    // offset: 0x80 ordinal: 0xc
    ULONG PairedWithJob : 1; // offset: 0x80 ordinal: 0xd
  };
} _EPARTITION;

// 0xa0 bytes (sizeof)
typedef struct _ETW_REALTIME_CONSUMER {
  struct _LIST_ENTRY Links;                      // offset: 0x0 ordinal: 0x0
  VOID *ProcessHandle;                           // offset: 0x10 ordinal: 0x1
  struct _EPROCESS *ProcessObject;               // offset: 0x18 ordinal: 0x2
  VOID *NextNotDelivered;                        // offset: 0x20 ordinal: 0x3
  VOID *RealtimeConnectContext;                  // offset: 0x28 ordinal: 0x4
  struct _KEVENT *DisconnectEvent;               // offset: 0x30 ordinal: 0x5
  struct _KEVENT *DataAvailableEvent;            // offset: 0x38 ordinal: 0x6
  ULONG *UserBufferCount;                        // offset: 0x40 ordinal: 0x7
  struct _SINGLE_LIST_ENTRY *UserBufferListHead; // offset: 0x48 ordinal: 0x8
  ULONG BuffersLost;                             // offset: 0x50 ordinal: 0x9
  ULONG EmptyBuffersCount;                       // offset: 0x54 ordinal: 0xa
  USHORT LoggerId;                               // offset: 0x58 ordinal: 0xb
  union {
    UCHAR Flags;                 // offset: 0x5a ordinal: 0xc
    UCHAR ShutDownRequested : 1; // offset: 0x5a ordinal: 0xd
  };
  UCHAR NewBuffersLost : 1;                     // offset: 0x5a ordinal: 0xe
  UCHAR Disconnected : 1;                       // offset: 0x5a ordinal: 0xf
  UCHAR Notified : 1;                           // offset: 0x5a ordinal: 0x10
  UCHAR Wow : 1;                                // offset: 0x5a ordinal: 0x11
  struct _RTL_BITMAP ReservedBufferSpaceBitMap; // offset: 0x60 ordinal: 0x12
  UCHAR *ReservedBufferSpace;                   // offset: 0x70 ordinal: 0x13
  ULONG ReservedBufferSpaceSize;                // offset: 0x78 ordinal: 0x14
  ULONG UserPagesAllocated;                     // offset: 0x7c ordinal: 0x15
  ULONG UserPagesReused;                        // offset: 0x80 ordinal: 0x16
  ULONG *EventsLostCount;                       // offset: 0x88 ordinal: 0x17
  ULONG *BuffersLostCount;                      // offset: 0x90 ordinal: 0x18
  struct _ETW_SILODRIVERSTATE *SiloState;       // offset: 0x98 ordinal: 0x19
} _ETW_REALTIME_CONSUMER;

// 0x540 bytes (sizeof)
typedef struct _WMI_LOGGER_CONTEXT {
  ULONG LoggerId;                         // offset: 0x0 ordinal: 0x0
  ULONG BufferSize;                       // offset: 0x4 ordinal: 0x1
  ULONG MaximumEventSize;                 // offset: 0x8 ordinal: 0x2
  ULONG LoggerMode;                       // offset: 0xc ordinal: 0x3
  LONG AcceptNewEvents;                   // offset: 0x10 ordinal: 0x4
  ULONGLONG GetCpuClock;                  // offset: 0x18 ordinal: 0x5
  struct _ETHREAD *LoggerThread;          // offset: 0x20 ordinal: 0x6
  LONG LoggerStatus;                      // offset: 0x28 ordinal: 0x7
  ULONG FailureReason;                    // offset: 0x2c ordinal: 0x8
  struct _ETW_BUFFER_QUEUE BufferQueue;   // offset: 0x30 ordinal: 0x9
  struct _ETW_BUFFER_QUEUE OverflowQueue; // offset: 0x40 ordinal: 0xa
  struct _LIST_ENTRY GlobalList;          // offset: 0x50 ordinal: 0xb
  struct _LIST_ENTRY DebugIdTrackingList; // offset: 0x60 ordinal: 0xc
  struct _ETW_DECODE_CONTROL_ENTRY
      *DecodeControlList;   // offset: 0x70 ordinal: 0xd
  ULONG DecodeControlCount; // offset: 0x78 ordinal: 0xe
  union {
    struct _WMI_BUFFER_HEADER *BatchedBufferList; // offset: 0x80 ordinal: 0xf
    struct _EX_FAST_REF CurrentBuffer;            // offset: 0x80 ordinal: 0x10
  };
  struct _UNICODE_STRING LoggerName;     // offset: 0x88 ordinal: 0x11
  struct _UNICODE_STRING LogFileName;    // offset: 0x98 ordinal: 0x12
  struct _UNICODE_STRING LogFilePattern; // offset: 0xa8 ordinal: 0x13
  struct _UNICODE_STRING NewLogFileName; // offset: 0xb8 ordinal: 0x14
  ULONG ClockType;                       // offset: 0xc8 ordinal: 0x15
  ULONG LastFlushedBuffer;               // offset: 0xcc ordinal: 0x16
  ULONG FlushTimer;                      // offset: 0xd0 ordinal: 0x17
  ULONG FlushThreshold;                  // offset: 0xd4 ordinal: 0x18
  union _LARGE_INTEGER ByteOffset;       // offset: 0xd8 ordinal: 0x19
  ULONG MinimumBuffers;                  // offset: 0xe0 ordinal: 0x1a
  LONG BuffersAvailable;                 // offset: 0xe4 ordinal: 0x1b
  LONG NumberOfBuffers;                  // offset: 0xe8 ordinal: 0x1c
  ULONG MaximumBuffers;                  // offset: 0xec ordinal: 0x1d
  ULONG EventsLost;                      // offset: 0xf0 ordinal: 0x1e
  LONG PeakBuffersCount;                 // offset: 0xf4 ordinal: 0x1f
  ULONG BuffersWritten;                  // offset: 0xf8 ordinal: 0x20
  ULONG LogBuffersLost;                  // offset: 0xfc ordinal: 0x21
  ULONG RealTimeBuffersDelivered;        // offset: 0x100 ordinal: 0x22
  ULONG RealTimeBuffersLost;             // offset: 0x104 ordinal: 0x23
  LONG *SequencePtr;                     // offset: 0x108 ordinal: 0x24
  ULONG LocalSequence;                   // offset: 0x110 ordinal: 0x25
  struct _GUID InstanceGuid;             // offset: 0x114 ordinal: 0x26
  ULONG MaximumFileSize;                 // offset: 0x124 ordinal: 0x27
  LONG FileCounter;                      // offset: 0x128 ordinal: 0x28
  enum _POOL_TYPE PoolType;              // offset: 0x12c ordinal: 0x29
  struct _ETW_REF_CLOCK ReferenceTime;   // offset: 0x130 ordinal: 0x2a
  LONG CollectionOn;                     // offset: 0x140 ordinal: 0x2b
  ULONG ProviderInfoSize;                // offset: 0x144 ordinal: 0x2c
  struct _LIST_ENTRY Consumers;          // offset: 0x148 ordinal: 0x2d
  ULONG NumConsumers;                    // offset: 0x158 ordinal: 0x2e
  struct _ETW_REALTIME_CONSUMER
      *TransitionConsumer;                     // offset: 0x160 ordinal: 0x2f
  VOID *RealtimeLogfileHandle;                 // offset: 0x168 ordinal: 0x30
  struct _UNICODE_STRING RealtimeLogfileName;  // offset: 0x170 ordinal: 0x31
  union _LARGE_INTEGER RealtimeWriteOffset;    // offset: 0x180 ordinal: 0x32
  union _LARGE_INTEGER RealtimeReadOffset;     // offset: 0x188 ordinal: 0x33
  union _LARGE_INTEGER RealtimeLogfileSize;    // offset: 0x190 ordinal: 0x34
  ULONGLONG RealtimeLogfileUsage;              // offset: 0x198 ordinal: 0x35
  ULONGLONG RealtimeMaximumFileSize;           // offset: 0x1a0 ordinal: 0x36
  ULONG RealtimeBuffersSaved;                  // offset: 0x1a8 ordinal: 0x37
  struct _ETW_REF_CLOCK RealtimeReferenceTime; // offset: 0x1b0 ordinal: 0x38
  enum _ETW_RT_EVENT_LOSS NewRTEventsLost;     // offset: 0x1c0 ordinal: 0x39
  struct _KEVENT LoggerEvent;                  // offset: 0x1c8 ordinal: 0x3a
  struct _KEVENT FlushEvent;                   // offset: 0x1e0 ordinal: 0x3b
  struct _KTIMER FlushTimeOutTimer;            // offset: 0x1f8 ordinal: 0x3c
  struct _KDPC LoggerDpc;                      // offset: 0x238 ordinal: 0x3d
  struct _KMUTANT LoggerMutex;                 // offset: 0x278 ordinal: 0x3e
  struct _EX_PUSH_LOCK LoggerLock;             // offset: 0x2b0 ordinal: 0x3f
  union {
    ULONGLONG BufferListSpinLock;            // offset: 0x2b8 ordinal: 0x40
    struct _EX_PUSH_LOCK BufferListPushLock; // offset: 0x2b8 ordinal: 0x41
  };
  struct _SECURITY_CLIENT_CONTEXT
      ClientSecurityContext; // offset: 0x2c0 ordinal: 0x42
  struct _TOKEN_ACCESS_INFORMATION
      *TokenAccessInformation;            // offset: 0x308 ordinal: 0x43
  struct _EX_FAST_REF SecurityDescriptor; // offset: 0x310 ordinal: 0x44
  union _LARGE_INTEGER StartTime;         // offset: 0x318 ordinal: 0x45
  VOID *LogFileHandle;                    // offset: 0x320 ordinal: 0x46
  LONGLONG BufferSequenceNumber;          // offset: 0x328 ordinal: 0x47
  union {
    ULONG Flags;          // offset: 0x330 ordinal: 0x48
    ULONG Persistent : 1; // offset: 0x330 ordinal: 0x49
  };
  ULONG AutoLogger : 1;                  // offset: 0x330 ordinal: 0x4a
  ULONG FsReady : 1;                     // offset: 0x330 ordinal: 0x4b
  ULONG RealTime : 1;                    // offset: 0x330 ordinal: 0x4c
  ULONG Wow : 1;                         // offset: 0x330 ordinal: 0x4d
  ULONG KernelTrace : 1;                 // offset: 0x330 ordinal: 0x4e
  ULONG NoMoreEnable : 1;                // offset: 0x330 ordinal: 0x4f
  ULONG StackTracing : 1;                // offset: 0x330 ordinal: 0x50
  ULONG ErrorLogged : 1;                 // offset: 0x330 ordinal: 0x51
  ULONG RealtimeLoggerContextFreed : 1;  // offset: 0x330 ordinal: 0x52
  ULONG PebsTracing : 1;                 // offset: 0x330 ordinal: 0x53
  ULONG PmcCounters : 1;                 // offset: 0x330 ordinal: 0x54
  ULONG PageAlignBuffers : 1;            // offset: 0x330 ordinal: 0x55
  ULONG StackLookasideListAllocated : 1; // offset: 0x330 ordinal: 0x56
  ULONG SecurityTrace : 1;               // offset: 0x330 ordinal: 0x57
  ULONG LastBranchTracing : 1;           // offset: 0x330 ordinal: 0x58
  ULONG SystemLoggerIndex : 8;           // offset: 0x330 ordinal: 0x59
  ULONG StackCaching : 1;                // offset: 0x330 ordinal: 0x5a
  ULONG ProviderTracking : 1;            // offset: 0x330 ordinal: 0x5b
  ULONG ProcessorTrace : 1;              // offset: 0x330 ordinal: 0x5c
  ULONG QpcDeltaTracking : 1;            // offset: 0x330 ordinal: 0x5d
  ULONG MarkerBufferSaved : 1;           // offset: 0x330 ordinal: 0x5e
  ULONG LargeMdlPages : 1;               // offset: 0x330 ordinal: 0x5f
  ULONG ExcludeKernelStack : 1;          // offset: 0x330 ordinal: 0x60
  ULONG BootLogger : 1;                  // offset: 0x330 ordinal: 0x61
  union {
    ULONG Flags2;                  // offset: 0x334 ordinal: 0x62
    ULONG UnifiedStackCaching : 1; // offset: 0x334 ordinal: 0x63
  };
  union {
    ULONG RequestFlag;           // offset: 0x338 ordinal: 0x64
    ULONG DbgRequestNewFile : 1; // offset: 0x338 ordinal: 0x65
  };
  ULONG DbgRequestUpdateFile : 1;                // offset: 0x338 ordinal: 0x66
  ULONG DbgRequestFlush : 1;                     // offset: 0x338 ordinal: 0x67
  ULONG DbgRequestDisableRealtime : 1;           // offset: 0x338 ordinal: 0x68
  ULONG DbgRequestDisconnectConsumer : 1;        // offset: 0x338 ordinal: 0x69
  ULONG DbgRequestConnectConsumer : 1;           // offset: 0x338 ordinal: 0x6a
  ULONG DbgRequestNotifyConsumer : 1;            // offset: 0x338 ordinal: 0x6b
  ULONG DbgRequestUpdateHeader : 1;              // offset: 0x338 ordinal: 0x6c
  ULONG DbgRequestDeferredFlush : 1;             // offset: 0x338 ordinal: 0x6d
  ULONG DbgRequestDeferredFlushTimer : 1;        // offset: 0x338 ordinal: 0x6e
  ULONG DbgRequestFlushTimer : 1;                // offset: 0x338 ordinal: 0x6f
  ULONG DbgRequestUpdateDebugger : 1;            // offset: 0x338 ordinal: 0x70
  ULONG DbgSpareRequestFlags : 20;               // offset: 0x338 ordinal: 0x71
  struct _ETW_STACK_TRACE_BLOCK StackTraceBlock; // offset: 0x340 ordinal: 0x72
  struct _RTL_BITMAP HookIdMap;                  // offset: 0x3e0 ordinal: 0x73
  struct _ETW_STACK_CACHE *StackCache;           // offset: 0x3f0 ordinal: 0x74
  struct _ETW_PMC_SUPPORT *PmcData;              // offset: 0x3f8 ordinal: 0x75
  struct _ETW_LBR_SUPPORT *LbrData;              // offset: 0x400 ordinal: 0x76
  struct _ETW_IPT_SUPPORT *IptData;              // offset: 0x408 ordinal: 0x77
  struct _LIST_ENTRY BinaryTrackingList;         // offset: 0x410 ordinal: 0x78
  struct _WMI_BUFFER_HEADER **ScratchArray;      // offset: 0x420 ordinal: 0x79
  struct _DISALLOWED_GUIDS DisallowedGuids;      // offset: 0x428 ordinal: 0x7a
  struct PERIODIC_CAPTURE_STATE_CONTEXT
      *PeriodicCaptureStateContext; // offset: 0x438 ordinal: 0x7b
  struct _ETW_SOFT_RESTART_CONTEXT
      *SoftRestartContext;                      // offset: 0x440 ordinal: 0x7c
  struct _ETW_SILODRIVERSTATE *SiloState;       // offset: 0x448 ordinal: 0x7d
  struct _WORK_QUEUE_ITEM CompressionWorkItem;  // offset: 0x450 ordinal: 0x7e
  LONG CompressionWorkItemState;                // offset: 0x470 ordinal: 0x7f
  struct _EX_PUSH_LOCK CompressionLock;         // offset: 0x478 ordinal: 0x80
  struct _WMI_BUFFER_HEADER *CompressionTarget; // offset: 0x480 ordinal: 0x81
  VOID *CompressionWorkspace;                   // offset: 0x488 ordinal: 0x82
  LONG CompressionOn;                           // offset: 0x490 ordinal: 0x83
  ULONG CompressionRatioGuess;                  // offset: 0x494 ordinal: 0x84
  ULONG PartialBufferCompressionLevel;          // offset: 0x498 ordinal: 0x85
  enum ETW_COMPRESSION_RESUMPTION_MODE
      CompressionResumptionMode;               // offset: 0x49c ordinal: 0x86
  struct _SINGLE_LIST_ENTRY PlaceholderList;   // offset: 0x4a0 ordinal: 0x87
  struct _KDPC CompressionDpc;                 // offset: 0x4a8 ordinal: 0x88
  union _LARGE_INTEGER LastBufferSwitchTime;   // offset: 0x4e8 ordinal: 0x89
  union _LARGE_INTEGER BufferWriteDuration;    // offset: 0x4f0 ordinal: 0x8a
  union _LARGE_INTEGER BufferCompressDuration; // offset: 0x4f8 ordinal: 0x8b
  LONGLONG ReferenceQpcDelta;                  // offset: 0x500 ordinal: 0x8c
  struct _ETW_EVENT_CALLBACK_CONTEXT
      *CallbackContext;                           // offset: 0x508 ordinal: 0x8d
  union _LARGE_INTEGER *LastDroppedTime;          // offset: 0x510 ordinal: 0x8e
  union _LARGE_INTEGER *FlushingLastDroppedTime;  // offset: 0x518 ordinal: 0x8f
  LONGLONG FlushingSequenceNumber;                // offset: 0x520 ordinal: 0x90
  struct _ETW_PARTITION_CONTEXT PartitionContext; // offset: 0x528 ordinal: 0x91
  struct _MDL *BufferMdl;                         // offset: 0x530 ordinal: 0x92
} _WMI_LOGGER_CONTEXT;

typedef UCHAR (*__anon_778)(struct _FILE_OBJECT *, struct _EPROCESS *,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_777)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                            union _LARGE_INTEGER *, struct _EPROCESS *, ULONG,
                            struct _IO_STATUS_BLOCK *, struct _DEVICE_OBJECT *);

typedef UCHAR (*__anon_776)(struct _FILE_OBJECT *, union _LARGE_INTEGER *,
                            union _LARGE_INTEGER *, struct _EPROCESS *, ULONG,
                            UCHAR, UCHAR, struct _IO_STATUS_BLOCK *,
                            struct _DEVICE_OBJECT *);

// 0x150 bytes (sizeof)
typedef struct _DRIVER_OBJECT {
  SHORT Type;                                // offset: 0x0 ordinal: 0x0
  SHORT Size;                                // offset: 0x2 ordinal: 0x1
  struct _DEVICE_OBJECT *DeviceObject;       // offset: 0x8 ordinal: 0x2
  ULONG Flags;                               // offset: 0x10 ordinal: 0x3
  VOID *DriverStart;                         // offset: 0x18 ordinal: 0x4
  ULONG DriverSize;                          // offset: 0x20 ordinal: 0x5
  VOID *DriverSection;                       // offset: 0x28 ordinal: 0x6
  struct _DRIVER_EXTENSION *DriverExtension; // offset: 0x30 ordinal: 0x7
  struct _UNICODE_STRING DriverName;         // offset: 0x38 ordinal: 0x8
  struct _UNICODE_STRING *HardwareDatabase;  // offset: 0x48 ordinal: 0x9
  struct _FAST_IO_DISPATCH *FastIoDispatch;  // offset: 0x50 ordinal: 0xa
  LONG(*DriverInit)
  (struct _DRIVER_OBJECT *,
   struct _UNICODE_STRING *); // offset: 0x58 ordinal: 0xb
  VOID(*DriverStartIo)
  (struct _DEVICE_OBJECT *, struct _IRP *);      // offset: 0x60 ordinal: 0xc
  VOID (*DriverUnload)(struct _DRIVER_OBJECT *); // offset: 0x68 ordinal: 0xd
  LONG(*MajorFunction[28])
  (struct _DEVICE_OBJECT *, struct _IRP *); // offset: 0x70 ordinal: 0xe
} _DRIVER_OBJECT;

// 0x40 bytes (sizeof)
typedef struct _VF_TARGET_DRIVER {
  struct _VF_AVL_TREE_NODE_EX TreeNode; // offset: 0x0 ordinal: 0x0
  union __anon_3892 u1;                 // offset: 0x18 ordinal: 0x1
  struct _DRIVER_OBJECT *DriverObject;  // offset: 0x30 ordinal: 0x2
  struct _VF_TARGET_VERIFIED_DRIVER_DATA
      *VerifiedData; // offset: 0x38 ordinal: 0x3
} _VF_TARGET_DRIVER;

typedef LONG (*__anon_3418)(struct _BUS_HANDLER *, struct _BUS_HANDLER *,
                            struct _UNICODE_STRING *, struct _UNICODE_STRING *,
                            struct _DRIVER_OBJECT *, struct _DEVICE_OBJECT *,
                            ULONG, struct _CM_RESOURCE_LIST **);

// 0xb0 bytes (sizeof)
typedef struct _BUS_HANDLER {
  ULONG Version;                          // offset: 0x0 ordinal: 0x0
  enum _INTERFACE_TYPE InterfaceType;     // offset: 0x4 ordinal: 0x1
  enum _BUS_DATA_TYPE ConfigurationType;  // offset: 0x8 ordinal: 0x2
  ULONG BusNumber;                        // offset: 0xc ordinal: 0x3
  struct _DEVICE_OBJECT *DeviceObject;    // offset: 0x10 ordinal: 0x4
  struct _BUS_HANDLER *ParentHandler;     // offset: 0x18 ordinal: 0x5
  VOID *BusData;                          // offset: 0x20 ordinal: 0x6
  ULONG DeviceControlExtensionSize;       // offset: 0x28 ordinal: 0x7
  struct _SUPPORTED_RANGES *BusAddresses; // offset: 0x30 ordinal: 0x8
  ULONG Reserved[4];                      // offset: 0x38 ordinal: 0x9
  ULONG(*GetBusData)
  (struct _BUS_HANDLER *, struct _BUS_HANDLER *, ULONG, VOID *, ULONG,
   ULONG); // offset: 0x48 ordinal: 0xa
  ULONG(*SetBusData)
  (struct _BUS_HANDLER *, struct _BUS_HANDLER *, ULONG, VOID *, ULONG,
   ULONG); // offset: 0x50 ordinal: 0xb
  LONG(*AdjustResourceList)
  (struct _BUS_HANDLER *, struct _BUS_HANDLER *,
   struct _IO_RESOURCE_REQUIREMENTS_LIST **); // offset: 0x58 ordinal: 0xc
  LONG(*AssignSlotResources)
  (struct _BUS_HANDLER *, struct _BUS_HANDLER *, struct _UNICODE_STRING *,
   struct _UNICODE_STRING *, struct _DRIVER_OBJECT *, struct _DEVICE_OBJECT *,
   ULONG, struct _CM_RESOURCE_LIST **); // offset: 0x60 ordinal: 0xd
  UCHAR(*TranslateBusAddress)
  (struct _BUS_HANDLER *, struct _BUS_HANDLER *, union _LARGE_INTEGER, ULONG *,
   union _LARGE_INTEGER *); // offset: 0x68 ordinal: 0xe
  VOID *Spare1;             // offset: 0x70 ordinal: 0xf
  VOID *Spare2;             // offset: 0x78 ordinal: 0x10
  VOID *Spare3;             // offset: 0x80 ordinal: 0x11
  VOID *Spare4;             // offset: 0x88 ordinal: 0x12
  VOID *Spare5;             // offset: 0x90 ordinal: 0x13
  VOID *Spare6;             // offset: 0x98 ordinal: 0x14
  VOID *Spare7;             // offset: 0xa0 ordinal: 0x15
  VOID *Spare8;             // offset: 0xa8 ordinal: 0x16
} _BUS_HANDLER;

typedef LONG (*__anon_3236)(struct _UNICODE_STRING *, struct _UNICODE_STRING *,
                            struct _DRIVER_OBJECT *, struct _DEVICE_OBJECT *,
                            enum _INTERFACE_TYPE, ULONG, ULONG,
                            struct _CM_RESOURCE_LIST **);

// 0x4f0 bytes (sizeof)
typedef struct HAL_PRIVATE_DISPATCH {
  ULONG Version; // offset: 0x0 ordinal: 0x0
  struct _BUS_HANDLER *(*HalHandlerForBus)(enum _INTERFACE_TYPE,
                                           ULONG); // offset: 0x8 ordinal: 0x1
  struct _BUS_HANDLER *(*HalHandlerForConfigSpace)(
      enum _BUS_DATA_TYPE, ULONG);      // offset: 0x10 ordinal: 0x2
  VOID (*HalLocateHiberRanges)(VOID *); // offset: 0x18 ordinal: 0x3
  LONG(*HalRegisterBusHandler)
  (enum _INTERFACE_TYPE, enum _BUS_DATA_TYPE, ULONG, enum _INTERFACE_TYPE,
   ULONG, ULONG, LONG (*)(struct _BUS_HANDLER *),
   struct _BUS_HANDLER **);                      // offset: 0x20 ordinal: 0x4
  VOID (*HalSetWakeEnable)(UCHAR);               // offset: 0x28 ordinal: 0x5
  LONG (*HalSetWakeAlarm)(ULONGLONG, ULONGLONG); // offset: 0x30 ordinal: 0x6
  UCHAR(*HalPciTranslateBusAddress)
  (enum _INTERFACE_TYPE, ULONG, union _LARGE_INTEGER, ULONG *,
   union _LARGE_INTEGER *); // offset: 0x38 ordinal: 0x7
  LONG(*HalPciAssignSlotResources)
  (struct _UNICODE_STRING *, struct _UNICODE_STRING *, struct _DRIVER_OBJECT *,
   struct _DEVICE_OBJECT *, enum _INTERFACE_TYPE, ULONG, ULONG,
   struct _CM_RESOURCE_LIST **); // offset: 0x40 ordinal: 0x8
  VOID (*HalHaltSystem)();       // offset: 0x48 ordinal: 0x9
  UCHAR(*HalFindBusAddressTranslation)
  (union _LARGE_INTEGER, ULONG *, union _LARGE_INTEGER *, ULONGLONG *,
   UCHAR);                    // offset: 0x50 ordinal: 0xa
  UCHAR (*HalResetDisplay)(); // offset: 0x58 ordinal: 0xb
  LONG(*HalAllocateMapRegisters)
  (struct _ADAPTER_OBJECT *, ULONG, ULONG,
   struct _MAP_REGISTER_ENTRY *); // offset: 0x60 ordinal: 0xc
  LONG(*KdSetupPciDeviceForDebugging)
  (VOID *, struct _DEBUG_DEVICE_DESCRIPTOR *); // offset: 0x68 ordinal: 0xd
  LONG(*KdReleasePciDeviceForDebugging)
  (struct _DEBUG_DEVICE_DESCRIPTOR *); // offset: 0x70 ordinal: 0xe
  VOID *(*KdGetAcpiTablePhase0)(struct _LOADER_PARAMETER_BLOCK *,
                                ULONG); // offset: 0x78 ordinal: 0xf
  VOID (*KdCheckPowerButton)();         // offset: 0x80 ordinal: 0x10
  UCHAR (*HalVectorToIDTEntry)(ULONG);  // offset: 0x88 ordinal: 0x11
  VOID *(*KdMapPhysicalMemory64)(union _LARGE_INTEGER, ULONG,
                                 UCHAR); // offset: 0x90 ordinal: 0x12
  VOID(*KdUnmapVirtualAddress)
  (VOID *, ULONG, UCHAR); // offset: 0x98 ordinal: 0x13
  ULONG(*KdGetPciDataByOffset)
  (ULONG, ULONG, VOID *, ULONG, ULONG); // offset: 0xa0 ordinal: 0x14
  ULONG(*KdSetPciDataByOffset)
  (ULONG, ULONG, VOID *, ULONG, ULONG); // offset: 0xa8 ordinal: 0x15
  ULONG(*HalGetInterruptVectorOverride)
  (enum _INTERFACE_TYPE, ULONG, ULONG, ULONG, UCHAR *,
   ULONGLONG *); // offset: 0xb0 ordinal: 0x16
  LONG(*HalGetVectorInputOverride)
  (ULONG, struct _GROUP_AFFINITY *, ULONG *, enum _KINTERRUPT_POLARITY *,
   struct _INTERRUPT_REMAPPING_INFO *); // offset: 0xb8 ordinal: 0x17
  LONG (*HalLoadMicrocode)(VOID *);     // offset: 0xc0 ordinal: 0x18
  LONG (*HalUnloadMicrocode)();         // offset: 0xc8 ordinal: 0x19
  LONG (*HalPostMicrocodeUpdate)();     // offset: 0xd0 ordinal: 0x1a
  LONG(*HalAllocateMessageTargetOverride)
  (struct _DEVICE_OBJECT *, struct _GROUP_AFFINITY *, ULONG,
   enum _KINTERRUPT_MODE, UCHAR, ULONG *, UCHAR *,
   ULONG *); // offset: 0xd8 ordinal: 0x1b
  VOID(*HalFreeMessageTargetOverride)
  (struct _DEVICE_OBJECT *, ULONG,
   struct _GROUP_AFFINITY *); // offset: 0xe0 ordinal: 0x1c
  LONG(*HalDpReplaceBegin)
  (struct _HAL_DP_REPLACE_PARAMETERS *, VOID **); // offset: 0xe8 ordinal: 0x1d
  VOID (*HalDpReplaceTarget)(VOID *);             // offset: 0xf0 ordinal: 0x1e
  LONG (*HalDpReplaceControl)(ULONG, VOID *);     // offset: 0xf8 ordinal: 0x1f
  VOID (*HalDpReplaceEnd)(VOID *);                // offset: 0x100 ordinal: 0x20
  VOID (*HalPrepareForBugcheck)(ULONG);           // offset: 0x108 ordinal: 0x21
  UCHAR(*HalQueryWakeTime)
  (ULONGLONG *, ULONGLONG *); // offset: 0x110 ordinal: 0x22
  VOID(*HalReportIdleStateUsage)
  (UCHAR, struct _KAFFINITY_EX *);               // offset: 0x118 ordinal: 0x23
  VOID (*HalTscSynchronization)(UCHAR, ULONG *); // offset: 0x120 ordinal: 0x24
  LONG(*HalWheaInitProcessorGenericSection)
  (struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR *,
   struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION
       *); // offset: 0x128 ordinal: 0x25
  VOID(*HalStopLegacyUsbInterrupts)
  (enum _SYSTEM_POWER_STATE); // offset: 0x130 ordinal: 0x26
  LONG(*HalReadWheaPhysicalMemory)
  (union _LARGE_INTEGER, ULONG, VOID *); // offset: 0x138 ordinal: 0x27
  LONG(*HalWriteWheaPhysicalMemory)
  (union _LARGE_INTEGER, ULONG, VOID *);         // offset: 0x140 ordinal: 0x28
  LONG (*HalDpMaskLevelTriggeredInterrupts)();   // offset: 0x148 ordinal: 0x29
  LONG (*HalDpUnmaskLevelTriggeredInterrupts)(); // offset: 0x150 ordinal: 0x2a
  LONG(*HalDpGetInterruptReplayState)
  (VOID *, VOID **);                        // offset: 0x158 ordinal: 0x2b
  LONG (*HalDpReplayInterrupts)(VOID *);    // offset: 0x160 ordinal: 0x2c
  UCHAR (*HalQueryIoPortAccessSupported)(); // offset: 0x168 ordinal: 0x2d
  LONG(*KdSetupIntegratedDeviceForDebugging)
  (VOID *, struct _DEBUG_DEVICE_DESCRIPTOR *); // offset: 0x170 ordinal: 0x2e
  LONG(*KdReleaseIntegratedDeviceForDebugging)
  (struct _DEBUG_DEVICE_DESCRIPTOR *); // offset: 0x178 ordinal: 0x2f
  VOID(*HalGetEnlightenmentInformation)
  (struct _HAL_INTEL_ENLIGHTENMENT_INFORMATION
       *); // offset: 0x180 ordinal: 0x30
  VOID *(*HalAllocateEarlyPages)(struct _LOADER_PARAMETER_BLOCK *, ULONG,
                                 ULONGLONG *,
                                 ULONG); // offset: 0x188 ordinal: 0x31
  VOID *(*HalMapEarlyPages)(ULONGLONG, ULONG,
                            ULONG);               // offset: 0x190 ordinal: 0x32
  VOID *Dummy1;                                   // offset: 0x198 ordinal: 0x33
  VOID *Dummy2;                                   // offset: 0x1a0 ordinal: 0x34
  VOID (*HalNotifyProcessorFreeze)(UCHAR, UCHAR); // offset: 0x1a8 ordinal: 0x35
  LONG (*HalPrepareProcessorForIdle)(ULONG);      // offset: 0x1b0 ordinal: 0x36
  VOID(*HalRegisterLogRoutine)
  (struct _HAL_LOG_REGISTER_CONTEXT *);  // offset: 0x1b8 ordinal: 0x37
  VOID (*HalResumeProcessorFromIdle)();  // offset: 0x1c0 ordinal: 0x38
  VOID *Dummy;                           // offset: 0x1c8 ordinal: 0x39
  ULONG (*HalVectorToIDTEntryEx)(ULONG); // offset: 0x1d0 ordinal: 0x3a
  LONG(*HalSecondaryInterruptQueryPrimaryInformation)
  (struct _INTERRUPT_VECTOR_DATA *, ULONG *); // offset: 0x1d8 ordinal: 0x3b
  LONG (*HalMaskInterrupt)(ULONG, ULONG);     // offset: 0x1e0 ordinal: 0x3c
  LONG (*HalUnmaskInterrupt)(ULONG, ULONG);   // offset: 0x1e8 ordinal: 0x3d
  UCHAR(*HalIsInterruptTypeSecondary)
  (ULONG, ULONG); // offset: 0x1f0 ordinal: 0x3e
  LONG(*HalAllocateGsivForSecondaryInterrupt)
  (CHAR *, USHORT, ULONG *); // offset: 0x1f8 ordinal: 0x3f
  LONG(*HalAddInterruptRemapping)
  (ULONG, ULONG, struct _PCI_BUSMASTER_DESCRIPTOR *, UCHAR,
   struct _INTERRUPT_VECTOR_DATA *, ULONG); // offset: 0x200 ordinal: 0x40
  VOID(*HalRemoveInterruptRemapping)
  (ULONG, ULONG, struct _PCI_BUSMASTER_DESCRIPTOR *, UCHAR,
   struct _INTERRUPT_VECTOR_DATA *, ULONG); // offset: 0x208 ordinal: 0x41
  VOID(*HalSaveAndDisableHvEnlightenment)
  (UCHAR);                             // offset: 0x210 ordinal: 0x42
  VOID (*HalRestoreHvEnlightenment)(); // offset: 0x218 ordinal: 0x43
  VOID(*HalFlushIoBuffersExternalCache)
  (struct _MDL *, UCHAR);               // offset: 0x220 ordinal: 0x44
  VOID (*HalFlushExternalCache)(UCHAR); // offset: 0x228 ordinal: 0x45
  LONG(*HalPciEarlyRestore)
  (enum _SYSTEM_POWER_STATE); // offset: 0x230 ordinal: 0x46
  LONG(*HalGetProcessorId)
  (ULONG, ULONG *, ULONG *); // offset: 0x238 ordinal: 0x47
  LONG(*HalAllocatePmcCounterSet)
  (ULONG, enum _KPROFILE_SOURCE *, ULONG,
   struct _HAL_PMC_COUNTERS **); // offset: 0x240 ordinal: 0x48
  VOID(*HalCollectPmcCounters)
  (struct _HAL_PMC_COUNTERS *, ULONGLONG *); // offset: 0x248 ordinal: 0x49
  VOID(*HalFreePmcCounterSet)
  (struct _HAL_PMC_COUNTERS *); // offset: 0x250 ordinal: 0x4a
  LONG(*HalProcessorHalt)
  (ULONG, VOID *, LONG (*)(VOID *)); // offset: 0x258 ordinal: 0x4b
  ULONGLONG(*HalTimerQueryCycleCounter)
  (ULONGLONG *);                  // offset: 0x260 ordinal: 0x4c
  VOID *Dummy3;                   // offset: 0x268 ordinal: 0x4d
  VOID (*HalPciMarkHiberPhase)(); // offset: 0x270 ordinal: 0x4e
  LONG(*HalQueryProcessorRestartEntryPoint)
  (union _LARGE_INTEGER *);           // offset: 0x278 ordinal: 0x4f
  LONG (*HalRequestInterrupt)(ULONG); // offset: 0x280 ordinal: 0x50
  LONG(*HalEnumerateUnmaskedInterrupts)
  (UCHAR (*)(VOID *, struct _HAL_UNMASKED_INTERRUPT_INFORMATION *), VOID *,
   struct _HAL_UNMASKED_INTERRUPT_INFORMATION *); // offset: 0x288 ordinal: 0x51
  VOID(*HalFlushAndInvalidatePageExternalCache)
  (union _LARGE_INTEGER); // offset: 0x290 ordinal: 0x52
  LONG(*KdEnumerateDebuggingDevices)
  (VOID *, struct _DEBUG_DEVICE_DESCRIPTOR *,
   enum KD_CALLBACK_ACTION (*)(
       struct _DEBUG_DEVICE_DESCRIPTOR *)); // offset: 0x298 ordinal: 0x53
  VOID(*HalFlushIoRectangleExternalCache)
  (struct _MDL *, ULONG, ULONG, ULONG, ULONG,
   UCHAR);                             // offset: 0x2a0 ordinal: 0x54
  VOID (*HalPowerEarlyRestore)(ULONG); // offset: 0x2a8 ordinal: 0x55
  LONG(*HalQueryCapsuleCapabilities)
  (VOID *, ULONG, ULONGLONG *, ULONG *); // offset: 0x2b0 ordinal: 0x56
  LONG(*HalUpdateCapsule)
  (VOID *, ULONG, union _LARGE_INTEGER);       // offset: 0x2b8 ordinal: 0x57
  UCHAR (*HalPciMultiStageResumeCapable)();    // offset: 0x2c0 ordinal: 0x58
  VOID (*HalDmaFreeCrashDumpRegisters)(ULONG); // offset: 0x2c8 ordinal: 0x59
  UCHAR (*HalAcpiAoacCapable)();               // offset: 0x2d0 ordinal: 0x5a
  LONG(*HalInterruptSetDestination)
  (struct _INTERRUPT_VECTOR_DATA *, struct _GROUP_AFFINITY *,
   ULONG *); // offset: 0x2d8 ordinal: 0x5b
  VOID(*HalGetClockConfiguration)
  (struct _HAL_CLOCK_TIMER_CONFIGURATION *); // offset: 0x2e0 ordinal: 0x5c
  VOID (*HalClockTimerActivate)(UCHAR);      // offset: 0x2e8 ordinal: 0x5d
  VOID (*HalClockTimerInitialize)();         // offset: 0x2f0 ordinal: 0x5e
  VOID (*HalClockTimerStop)();               // offset: 0x2f8 ordinal: 0x5f
  LONG(*HalClockTimerArm)
  (enum _HAL_CLOCK_TIMER_MODE, ULONGLONG,
   ULONGLONG *);                                // offset: 0x300 ordinal: 0x60
  UCHAR (*HalTimerOnlyClockInterruptPending)(); // offset: 0x308 ordinal: 0x61
  VOID *(*HalAcpiGetMultiNode)();               // offset: 0x310 ordinal: 0x62
  VOID *HalPowerSetRebootHandler;               // offset: 0x318 ordinal: 0x63
  VOID(*HalIommuRegisterDispatchTable)
  (struct _HAL_IOMMU_DISPATCH *);                // offset: 0x320 ordinal: 0x64
  VOID (*HalTimerWatchdogStart)();               // offset: 0x328 ordinal: 0x65
  VOID (*HalTimerWatchdogResetCountdown)();      // offset: 0x330 ordinal: 0x66
  VOID (*HalTimerWatchdogStop)();                // offset: 0x338 ordinal: 0x67
  UCHAR (*HalTimerWatchdogGeneratedLastReset)(); // offset: 0x340 ordinal: 0x68
  LONG(*HalTimerWatchdogTriggerSystemReset)
  (UCHAR); // offset: 0x348 ordinal: 0x69
  LONG(*HalInterruptVectorDataToGsiv)
  (struct _INTERRUPT_VECTOR_DATA *, ULONG *); // offset: 0x350 ordinal: 0x6a
  LONG(*HalInterruptGetHighestPriorityInterrupt)
  (ULONG *, UCHAR *);            // offset: 0x358 ordinal: 0x6b
  LONG (*HalProcessorOn)(ULONG); // offset: 0x360 ordinal: 0x6c
  LONG (*HalProcessorOff)();     // offset: 0x368 ordinal: 0x6d
  LONG (*HalProcessorFreeze)();  // offset: 0x370 ordinal: 0x6e
  LONG(*HalDmaLinkDeviceObjectByToken)
  (ULONGLONG, struct _DEVICE_OBJECT *);       // offset: 0x378 ordinal: 0x6f
  LONG (*HalDmaCheckAdapterToken)(ULONGLONG); // offset: 0x380 ordinal: 0x70
  VOID *Dummy4;                               // offset: 0x388 ordinal: 0x71
  LONG(*HalTimerConvertPerformanceCounterToAuxiliaryCounter)
  (ULONGLONG, ULONGLONG *, ULONGLONG *); // offset: 0x390 ordinal: 0x72
  LONG(*HalTimerConvertAuxiliaryCounterToPerformanceCounter)
  (ULONGLONG, ULONGLONG *, ULONGLONG *); // offset: 0x398 ordinal: 0x73
  LONG(*HalTimerQueryAuxiliaryCounterFrequency)
  (ULONGLONG *); // offset: 0x3a0 ordinal: 0x74
  LONG(*HalConnectThermalInterrupt)
  (UCHAR (*)(struct _KINTERRUPT *, VOID *));      // offset: 0x3a8 ordinal: 0x75
  UCHAR (*HalIsEFIRuntimeActive)();               // offset: 0x3b0 ordinal: 0x76
  UCHAR (*HalTimerQueryAndResetRtcErrors)(UCHAR); // offset: 0x3b8 ordinal: 0x77
  VOID (*HalAcpiLateRestore)();                   // offset: 0x3c0 ordinal: 0x78
  LONG (*KdWatchdogDelayExpiration)(ULONGLONG *); // offset: 0x3c8 ordinal: 0x79
  LONG(*HalGetProcessorStats)
  (enum _HAL_PROCESSOR_STAT_TYPE, ULONG, ULONG,
   ULONGLONG *); // offset: 0x3d0 ordinal: 0x7a
  ULONGLONG(*HalTimerWatchdogQueryDueTime)
  (UCHAR); // offset: 0x3d8 ordinal: 0x7b
  LONG(*HalConnectSyntheticInterrupt)
  (UCHAR (*)(struct _KINTERRUPT *, VOID *)); // offset: 0x3e0 ordinal: 0x7c
  VOID (*HalPreprocessNmi)(ULONG);           // offset: 0x3e8 ordinal: 0x7d
  LONG(*HalEnumerateEnvironmentVariablesWithFilter)
  (ULONG, UCHAR (*)(struct _GUID *, WCHAR *), VOID *,
   ULONG *); // offset: 0x3f0 ordinal: 0x7e
  LONG(*HalCaptureLastBranchRecordStack)
  (ULONG, struct _HAL_LBR_ENTRY *, ULONG *); // offset: 0x3f8 ordinal: 0x7f
  UCHAR (*HalClearLastBranchRecordStack)();  // offset: 0x400 ordinal: 0x80
  LONG(*HalConfigureLastBranchRecord)
  (ULONG, ULONG); // offset: 0x408 ordinal: 0x81
  UCHAR(*HalGetLastBranchInformation)
  (ULONG *, ULONG *);                       // offset: 0x410 ordinal: 0x82
  VOID (*HalResumeLastBranchRecord)(UCHAR); // offset: 0x418 ordinal: 0x83
  LONG(*HalStartLastBranchRecord)
  (ULONG, ULONG *);                       // offset: 0x420 ordinal: 0x84
  LONG (*HalStopLastBranchRecord)(ULONG); // offset: 0x428 ordinal: 0x85
  LONG(*HalIommuBlockDevice)
  (struct _IOMMU_DMA_DEVICE *); // offset: 0x430 ordinal: 0x86
  LONG(*HalIommuUnblockDevice)
  (struct _EXT_IOMMU_DEVICE_ID *, struct _DEVICE_OBJECT *,
   struct _IOMMU_DMA_DEVICE **); // offset: 0x438 ordinal: 0x87
  LONG(*HalGetIommuInterface)
  (ULONG, struct _DMA_IOMMU_INTERFACE *); // offset: 0x440 ordinal: 0x88
  LONG(*HalRequestGenericErrorRecovery)
  (VOID *, ULONG *); // offset: 0x448 ordinal: 0x89
  LONG(*HalTimerQueryHostPerformanceCounter)
  (ULONGLONG *); // offset: 0x450 ordinal: 0x8a
  LONG(*HalTopologyQueryProcessorRelationships)
  (ULONG, ULONG, UCHAR *, UCHAR *, UCHAR *, ULONG *,
   ULONG *);                                  // offset: 0x458 ordinal: 0x8b
  VOID (*HalInitPlatformDebugTriggers)();     // offset: 0x460 ordinal: 0x8c
  VOID (*HalRunPlatformDebugTriggers)(UCHAR); // offset: 0x468 ordinal: 0x8d
  VOID *(*HalTimerGetReferencePage)();        // offset: 0x470 ordinal: 0x8e
  LONG(*HalGetHiddenProcessorPowerInterface)
  (struct _HIDDEN_PROCESSOR_POWER_INTERFACE *);   // offset: 0x478 ordinal: 0x8f
  ULONG (*HalGetHiddenProcessorPackageId)(ULONG); // offset: 0x480 ordinal: 0x90
  ULONG(*HalGetHiddenPackageProcessorCount)
  (ULONG); // offset: 0x488 ordinal: 0x91
  LONG(*HalGetHiddenProcessorApicIdByIndex)
  (ULONG, ULONG *); // offset: 0x490 ordinal: 0x92
  LONG(*HalRegisterHiddenProcessorIdleState)
  (ULONG, ULONGLONG); // offset: 0x498 ordinal: 0x93
  VOID(*HalIommuReportIommuFault)
  (ULONGLONG, struct _FAULT_INFORMATION *); // offset: 0x4a0 ordinal: 0x94
  UCHAR(*HalIommuDmaRemappingCapable)
  (struct _EXT_IOMMU_DEVICE_ID *, ULONG *); // offset: 0x4a8 ordinal: 0x95
  LONG(*HalAllocatePmcCounterSetEx)
  (ULONG, enum _KPROFILE_SOURCE *, ULONG, ULONG *, struct _HAL_PMC_COUNTERS **,
   ULONG *); // offset: 0x4b0 ordinal: 0x96
  LONG(*HalStartProfileInterruptEx)
  (enum _KPROFILE_SOURCE, ULONG *, ULONG *,
   struct _HAL_PMC_COUNTERS **); // offset: 0x4b8 ordinal: 0x97
  LONG(*HalGetIommuInterfaceEx)
  (ULONG, ULONGLONG,
   struct _DMA_IOMMU_INTERFACE_EX *); // offset: 0x4c0 ordinal: 0x98
  VOID(*HalNotifyIommuDomainPolicyChange)
  (struct _DEVICE_OBJECT *); // offset: 0x4c8 ordinal: 0x99
  UCHAR(*HalPciGetDeviceLocationFromPhysicalAddress)
  (ULONGLONG, USHORT *, UCHAR *, UCHAR *,
   UCHAR *); // offset: 0x4d0 ordinal: 0x9a
  VOID(*HalInvokeSmc)
  (ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG,
   ULONGLONG *, ULONGLONG *, ULONGLONG *,
   ULONGLONG *); // offset: 0x4d8 ordinal: 0x9b
  VOID(*HalInvokeHvc)
  (ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG,
   ULONGLONG *, ULONGLONG *, ULONGLONG *,
   ULONGLONG *); // offset: 0x4e0 ordinal: 0x9c
  union _LARGE_INTEGER (
      *HalGetSoftRebootDatabase)(); // offset: 0x4e8 ordinal: 0x9d
} HAL_PRIVATE_DISPATCH;

// 0x58 bytes (sizeof)
typedef struct _SECONDARY_INTERRUPT_PROVIDER_INTERFACE {
  USHORT Size;                         // offset: 0x0 ordinal: 0x0
  USHORT Version;                      // offset: 0x2 ordinal: 0x1
  VOID *Context;                       // offset: 0x8 ordinal: 0x2
  ULONG GsivBase;                      // offset: 0x10 ordinal: 0x3
  USHORT GsivSize;                     // offset: 0x14 ordinal: 0x4
  struct _DRIVER_OBJECT *DriverObject; // offset: 0x18 ordinal: 0x5
  VOID *Reserved1;                     // offset: 0x20 ordinal: 0x6
  VOID *Reserved2;                     // offset: 0x28 ordinal: 0x7
  VOID *Reserved3;                     // offset: 0x30 ordinal: 0x8
  VOID *Reserved4;                     // offset: 0x38 ordinal: 0x9
  VOID *Reserved5;                     // offset: 0x40 ordinal: 0xa
  VOID *Reserved6;                     // offset: 0x48 ordinal: 0xb
  VOID *Reserved7;                     // offset: 0x50 ordinal: 0xc
} _SECONDARY_INTERRUPT_PROVIDER_INTERFACE;

// 0xb0 bytes (sizeof)
typedef struct _SECONDARY_IC_LIST_ENTRY {
  struct _LIST_ENTRY ListEntry; // offset: 0x0 ordinal: 0x0
  ULONG GsivBase;               // offset: 0x10 ordinal: 0x1
  ULONG GsivSize;               // offset: 0x14 ordinal: 0x2
  struct _SECONDARY_INTERRUPT_PROVIDER_INTERFACE
      Interface;                                   // offset: 0x18 ordinal: 0x3
  LONG BusyCount;                                  // offset: 0x70 ordinal: 0x4
  LONG ExclusiveWaiterCount;                       // offset: 0x74 ordinal: 0x5
  struct _KEVENT NotificationEvent;                // offset: 0x78 ordinal: 0x6
  struct _LIST_ENTRY SignalListEntry;              // offset: 0x90 ordinal: 0x7
  struct _SECONDARY_INTERRUPT_LINE_STATE State[1]; // offset: 0xa0 ordinal: 0x8
} _SECONDARY_IC_LIST_ENTRY;

typedef LONG (*__anon_769)(struct _DRIVER_OBJECT *, struct _DEVICE_OBJECT *);

// 0x100 bytes (sizeof)
typedef struct _VF_DRIVER_IO_CALLBACKS {
  LONG(*DriverInit)
  (struct _DRIVER_OBJECT *,
   struct _UNICODE_STRING *); // offset: 0x0 ordinal: 0x0
  VOID(*DriverStartIo)
  (struct _DEVICE_OBJECT *, struct _IRP *);      // offset: 0x8 ordinal: 0x1
  VOID (*DriverUnload)(struct _DRIVER_OBJECT *); // offset: 0x10 ordinal: 0x2
  LONG(*AddDevice)
  (struct _DRIVER_OBJECT *,
   struct _DEVICE_OBJECT *); // offset: 0x18 ordinal: 0x3
  LONG(*MajorFunction[28])
  (struct _DEVICE_OBJECT *, struct _IRP *); // offset: 0x20 ordinal: 0x4
} _VF_DRIVER_IO_CALLBACKS;

// 0x28 bytes (sizeof)
typedef struct _DRIVER_EXTENSION {
  struct _DRIVER_OBJECT *DriverObject; // offset: 0x0 ordinal: 0x0
  LONG(*AddDevice)
  (struct _DRIVER_OBJECT *,
   struct _DEVICE_OBJECT *);             // offset: 0x8 ordinal: 0x1
  ULONG Count;                           // offset: 0x10 ordinal: 0x2
  struct _UNICODE_STRING ServiceKeyName; // offset: 0x18 ordinal: 0x3
} _DRIVER_EXTENSION;

typedef LONG (*__anon_573)(struct _DRIVER_OBJECT *, struct _UNICODE_STRING *);

// 0x500 bytes (sizeof)
typedef struct _POP_FX_DEVICE {
  struct _LIST_ENTRY Link;                       // offset: 0x0 ordinal: 0x0
  struct _IRP *Irp;                              // offset: 0x10 ordinal: 0x1
  struct _POP_IRP_DATA *IrpData;                 // offset: 0x18 ordinal: 0x2
  union _POP_FX_DEVICE_STATUS Status;            // offset: 0x20 ordinal: 0x3
  LONG PowerReqCall;                             // offset: 0x24 ordinal: 0x4
  LONG PowerNotReqCall;                          // offset: 0x28 ordinal: 0x5
  struct _DEVICE_NODE *DevNode;                  // offset: 0x30 ordinal: 0x6
  struct PEPHANDLE__ *DpmContext;                // offset: 0x38 ordinal: 0x7
  struct _POP_FX_PLUGIN *Plugin;                 // offset: 0x40 ordinal: 0x8
  struct PEPHANDLE__ *PluginHandle;              // offset: 0x48 ordinal: 0x9
  struct _POP_FX_PLUGIN *AcpiPlugin;             // offset: 0x50 ordinal: 0xa
  struct PEPHANDLE__ *AcpiPluginHandle;          // offset: 0x58 ordinal: 0xb
  struct _DEVICE_OBJECT *DeviceObject;           // offset: 0x60 ordinal: 0xc
  struct _DEVICE_OBJECT *TargetDevice;           // offset: 0x68 ordinal: 0xd
  struct _POP_FX_DRIVER_CALLBACKS Callbacks;     // offset: 0x70 ordinal: 0xe
  VOID *DriverContext;                           // offset: 0xc0 ordinal: 0xf
  struct _LIST_ENTRY AcpiLink;                   // offset: 0xc8 ordinal: 0x10
  struct _UNICODE_STRING DeviceId;               // offset: 0xd8 ordinal: 0x11
  LONG CommonReferenceFlags;                     // offset: 0xe8 ordinal: 0x12
  struct _IO_REMOVE_LOCK RemoveLock;             // offset: 0xf0 ordinal: 0x13
  struct _IO_REMOVE_LOCK AcpiRemoveLock;         // offset: 0x110 ordinal: 0x14
  struct _POP_FX_WORK_ORDER WorkOrder;           // offset: 0x130 ordinal: 0x15
  ULONGLONG IdleLock;                            // offset: 0x168 ordinal: 0x16
  struct _KTIMER IdleTimer;                      // offset: 0x170 ordinal: 0x17
  struct _KDPC IdleDpc;                          // offset: 0x1b0 ordinal: 0x18
  ULONGLONG IdleTimeout;                         // offset: 0x1f0 ordinal: 0x19
  ULONGLONG IdleStamp;                           // offset: 0x1f8 ordinal: 0x1a
  struct _DEVICE_OBJECT *NextIrpDeviceObject[2]; // offset: 0x200 ordinal: 0x1b
  union _POWER_STATE NextIrpPowerState[2];       // offset: 0x210 ordinal: 0x1c
  VOID(*NextIrpCallerCompletion[2])
  (struct _DEVICE_OBJECT *, UCHAR, union _POWER_STATE, VOID *,
   struct _IO_STATUS_BLOCK *);     // offset: 0x218 ordinal: 0x1d
  VOID *NextIrpCallerContext[2];   // offset: 0x228 ordinal: 0x1e
  struct _KEVENT IrpCompleteEvent; // offset: 0x238 ordinal: 0x1f
  UCHAR(*PowerOnDumpDeviceCallback)
  (struct _PEP_CRASHDUMP_INFORMATION *); // offset: 0x250 ordinal: 0x20
  struct _POP_FX_ACCOUNTING Accounting;  // offset: 0x258 ordinal: 0x21
  ULONG Flags;                           // offset: 0x338 ordinal: 0x22
  ULONG ComponentCount;                  // offset: 0x33c ordinal: 0x23
  struct _POP_FX_COMPONENT **Components; // offset: 0x340 ordinal: 0x24
  ULONG LogEntries;                      // offset: 0x348 ordinal: 0x25
  struct _POP_FX_LOG_ENTRY *Log;         // offset: 0x350 ordinal: 0x26
  LONG LogIndex;                         // offset: 0x358 ordinal: 0x27
  struct _DRIVER_OBJECT
      *DripsWatchdogDriverObject; // offset: 0x360 ordinal: 0x28
  struct _POP_FX_DRIPS_WATCHDOG_CONTEXT
      DripsWatchdogContext;                    // offset: 0x368 ordinal: 0x29
  ULONG DirectedTimeout;                       // offset: 0x390 ordinal: 0x2a
  struct _POP_FX_WORK_ORDER DirectedWorkOrder; // offset: 0x398 ordinal: 0x2b
  struct _POP_FX_WORK_ORDER_WATCHDOG_INFO
      DirectedWorkWatchdogInfo;     // offset: 0x3d0 ordinal: 0x2c
  ULONGLONG DirectedLock;           // offset: 0x480 ordinal: 0x2d
  LONG DirectedTransitionCallCount; // offset: 0x488 ordinal: 0x2e
  struct _POP_FX_DEVICE_DIRECTED_TRANSITION_STATE
      DirectedTransitionState;                    // offset: 0x490 ordinal: 0x2f
  struct _POP_DEVICE_POWER_PROFILE *PowerProfile; // offset: 0x4a0 ordinal: 0x30
  struct _UNICODE_STRING FriendlyName;            // offset: 0x4a8 ordinal: 0x31
  struct _WORK_QUEUE_ITEM
      ReportDevicePoweredOnPassiveWorkItem; // offset: 0x4b8 ordinal: 0x32
  ULONGLONG RelationsLock;                  // offset: 0x4d8 ordinal: 0x33
  ULONG IdleProviderCount;                  // offset: 0x4e0 ordinal: 0x34
  struct _IRP *PendingDevicePowerIrp;       // offset: 0x4e8 ordinal: 0x35
  struct _LIST_ENTRY ExternalDependencies;  // offset: 0x4f0 ordinal: 0x36
} _POP_FX_DEVICE;

// 0x1d8 bytes (sizeof)
typedef struct _POP_FX_COMPONENT {
  struct _GUID Id;                       // offset: 0x0 ordinal: 0x0
  ULONG Index;                           // offset: 0x10 ordinal: 0x1
  struct _POP_FX_WORK_ORDER WorkOrder;   // offset: 0x18 ordinal: 0x2
  struct _POP_FX_DEVICE *Device;         // offset: 0x50 ordinal: 0x3
  union _POP_FX_COMPONENT_FLAGS Flags;   // offset: 0x58 ordinal: 0x4
  LONG Resident;                         // offset: 0x60 ordinal: 0x5
  struct _KEVENT ActiveEvent;            // offset: 0x68 ordinal: 0x6
  ULONGLONG IdleLock;                    // offset: 0x80 ordinal: 0x7
  LONG IdleConditionComplete;            // offset: 0x88 ordinal: 0x8
  LONG IdleStateComplete;                // offset: 0x8c ordinal: 0x9
  ULONGLONG IdleStamp;                   // offset: 0x90 ordinal: 0xa
  ULONG CurrentIdleState;                // offset: 0x98 ordinal: 0xb
  ULONG IdleStateCount;                  // offset: 0x9c ordinal: 0xc
  struct _POP_FX_IDLE_STATE *IdleStates; // offset: 0xa0 ordinal: 0xd
  ULONG DeepestWakeableIdleState;        // offset: 0xa8 ordinal: 0xe
  ULONG ProviderCount;                   // offset: 0xac ordinal: 0xf
  struct _POP_FX_PROVIDER *Providers;    // offset: 0xb0 ordinal: 0x10
  ULONG IdleProviderCount;               // offset: 0xb8 ordinal: 0x11
  ULONG DependentCount;                  // offset: 0xbc ordinal: 0x12
  struct _POP_FX_DEPENDENT *Dependents;  // offset: 0xc0 ordinal: 0x13
  struct _POP_FX_ACCOUNTING Accounting;  // offset: 0xc8 ordinal: 0x14
  struct _POP_FX_PERF_INFO *Performance; // offset: 0x1a8 ordinal: 0x15
  struct _POP_COMPONENT_POWER_PROFILE
      *PowerProfile;                       // offset: 0x1b0 ordinal: 0x16
  struct _LIST_ENTRY ExternalDependents;   // offset: 0x1b8 ordinal: 0x17
  struct _LIST_ENTRY ExternalDependencies; // offset: 0x1c8 ordinal: 0x18
} _POP_FX_COMPONENT;

// 0xa0 bytes (sizeof)
typedef struct _POP_FX_PERF_INFO {
  struct _POP_FX_COMPONENT *Component; // offset: 0x0 ordinal: 0x0
  struct _KEVENT CompletedEvent;       // offset: 0x8 ordinal: 0x1
  VOID(*ComponentPerfState)
  (VOID *, ULONG, UCHAR, VOID *);              // offset: 0x20 ordinal: 0x2
  union _POP_FX_PERF_FLAGS Flags;              // offset: 0x28 ordinal: 0x3
  struct _PO_FX_PERF_STATE_CHANGE *LastChange; // offset: 0x30 ordinal: 0x4
  ULONG LastChangeCount;                       // offset: 0x38 ordinal: 0x5
  ULONGLONG LastChangeStamp;                   // offset: 0x40 ordinal: 0x6
  UCHAR LastChangeNominal;                     // offset: 0x48 ordinal: 0x7
  UCHAR PepRegistered;                         // offset: 0x49 ordinal: 0x8
  UCHAR QueryOnIdleStates;                     // offset: 0x4a ordinal: 0x9
  VOID *RequestDriverContext;                  // offset: 0x50 ordinal: 0xa
  struct _POP_FX_WORK_ORDER WorkOrder;         // offset: 0x58 ordinal: 0xb
  ULONG SetsCount;                             // offset: 0x90 ordinal: 0xc
  struct _POP_FX_PERF_SET *Sets;               // offset: 0x98 ordinal: 0xd
} _POP_FX_PERF_INFO;

// 0x58 bytes (sizeof)
typedef struct _POP_DEVICE_POWER_PROFILE {
  struct _UNICODE_STRING DeviceId;                  // offset: 0x0 ordinal: 0x0
  struct _POP_POWER_PLANE *PowerPlane;              // offset: 0x10 ordinal: 0x1
  struct _POP_FX_DEVICE *FxDevice;                  // offset: 0x18 ordinal: 0x2
  LONG PowerDrawMw;                                 // offset: 0x20 ordinal: 0x3
  struct _PO_POWER_PLANE_PROFILE DxPower[4];        // offset: 0x24 ordinal: 0x4
  ULONGLONG ComponentCount;                         // offset: 0x48 ordinal: 0x5
  struct _POP_COMPONENT_POWER_PROFILE **Components; // offset: 0x50 ordinal: 0x6
} _POP_DEVICE_POWER_PROFILE;

// 0x388 bytes (sizeof)
typedef struct _DEVICE_NODE {
  struct _DEVICE_NODE *Sibling;                // offset: 0x0 ordinal: 0x0
  struct _DEVICE_NODE *Child;                  // offset: 0x8 ordinal: 0x1
  struct _DEVICE_NODE *Parent;                 // offset: 0x10 ordinal: 0x2
  struct _DEVICE_NODE *LastChild;              // offset: 0x18 ordinal: 0x3
  struct _DEVICE_OBJECT *PhysicalDeviceObject; // offset: 0x20 ordinal: 0x4
  struct _UNICODE_STRING InstancePath;         // offset: 0x28 ordinal: 0x5
  struct _UNICODE_STRING ServiceName;          // offset: 0x38 ordinal: 0x6
  struct _IRP *PendingIrp;                     // offset: 0x48 ordinal: 0x7
  struct _POP_FX_DEVICE *FxDevice;             // offset: 0x50 ordinal: 0x8
  LONG FxDeviceLock;                           // offset: 0x58 ordinal: 0x9
  struct _KEVENT FxRemoveEvent;                // offset: 0x60 ordinal: 0xa
  LONG FxActivationCount;                      // offset: 0x78 ordinal: 0xb
  LONG FxSleepCount;                           // offset: 0x7c ordinal: 0xc
  struct _UNICODE_STRING UniqueId;             // offset: 0x80 ordinal: 0xd
  struct _POP_FX_PLUGIN *Plugin;               // offset: 0x90 ordinal: 0xe
  ULONG Level;                                 // offset: 0x98 ordinal: 0xf
  union _POWER_STATE CurrentPowerState;        // offset: 0x9c ordinal: 0x10
  struct _PO_DEVICE_NOTIFY Notify;             // offset: 0xa0 ordinal: 0x11
  struct _PO_IRP_MANAGER PoIrpManager;         // offset: 0x108 ordinal: 0x12
  LONG PowerFlags;                             // offset: 0x128 ordinal: 0x13
  enum _PNP_DEVNODE_STATE State;               // offset: 0x12c ordinal: 0x14
  enum _PNP_DEVNODE_STATE PreviousState;       // offset: 0x130 ordinal: 0x15
  enum _PNP_DEVNODE_STATE StateHistory[20];    // offset: 0x134 ordinal: 0x16
  ULONG StateHistoryEntry;                     // offset: 0x184 ordinal: 0x17
  LONG CompletionStatus;                       // offset: 0x188 ordinal: 0x18
  ULONG Flags;                                 // offset: 0x18c ordinal: 0x19
  ULONG UserFlags;                             // offset: 0x190 ordinal: 0x1a
  ULONG Problem;                               // offset: 0x194 ordinal: 0x1b
  LONG ProblemStatus;                          // offset: 0x198 ordinal: 0x1c
  struct _CM_RESOURCE_LIST *ResourceList;      // offset: 0x1a0 ordinal: 0x1d
  struct _CM_RESOURCE_LIST
      *ResourceListTranslated;         // offset: 0x1a8 ordinal: 0x1e
  struct _DEVICE_OBJECT *DuplicatePDO; // offset: 0x1b0 ordinal: 0x1f
  struct _IO_RESOURCE_REQUIREMENTS_LIST
      *ResourceRequirements;               // offset: 0x1b8 ordinal: 0x20
  enum _INTERFACE_TYPE InterfaceType;      // offset: 0x1c0 ordinal: 0x21
  ULONG BusNumber;                         // offset: 0x1c4 ordinal: 0x22
  enum _INTERFACE_TYPE ChildInterfaceType; // offset: 0x1c8 ordinal: 0x23
  ULONG ChildBusNumber;                    // offset: 0x1cc ordinal: 0x24
  USHORT ChildBusTypeIndex;                // offset: 0x1d0 ordinal: 0x25
  UCHAR RemovalPolicy;                     // offset: 0x1d2 ordinal: 0x26
  UCHAR HardwareRemovalPolicy;             // offset: 0x1d3 ordinal: 0x27
  struct _LIST_ENTRY TargetDeviceNotify;   // offset: 0x1d8 ordinal: 0x28
  struct _LIST_ENTRY DeviceArbiterList;    // offset: 0x1e8 ordinal: 0x29
  struct _LIST_ENTRY DeviceTranslatorList; // offset: 0x1f8 ordinal: 0x2a
  USHORT NoTranslatorMask;                 // offset: 0x208 ordinal: 0x2b
  USHORT QueryTranslatorMask;              // offset: 0x20a ordinal: 0x2c
  USHORT NoArbiterMask;                    // offset: 0x20c ordinal: 0x2d
  USHORT QueryArbiterMask;                 // offset: 0x20e ordinal: 0x2e
  union __anon_870 OverUsed1;              // offset: 0x210 ordinal: 0x2f
  union __anon_871 OverUsed2;              // offset: 0x218 ordinal: 0x30
  struct _CM_RESOURCE_LIST *BootResources; // offset: 0x220 ordinal: 0x31
  struct _CM_RESOURCE_LIST
      *BootResourcesTranslated;               // offset: 0x228 ordinal: 0x32
  ULONG CapabilityFlags;                      // offset: 0x230 ordinal: 0x33
  struct __anon_872 DockInfo;                 // offset: 0x238 ordinal: 0x34
  ULONG DisableableDepends;                   // offset: 0x258 ordinal: 0x35
  struct _LIST_ENTRY PendedSetInterfaceState; // offset: 0x260 ordinal: 0x36
  struct _LIST_ENTRY LegacyBusListEntry;      // offset: 0x270 ordinal: 0x37
  ULONG DriverUnloadRetryCount;               // offset: 0x280 ordinal: 0x38
  struct _DEVICE_NODE *PreviousParent;        // offset: 0x288 ordinal: 0x39
  LONG DeletedChildren;                       // offset: 0x290 ordinal: 0x3a
  ULONG NumaNodeIndex;                        // offset: 0x294 ordinal: 0x3b
  struct _GUID ContainerID;                   // offset: 0x298 ordinal: 0x3c
  UCHAR OverrideFlags;                        // offset: 0x2a8 ordinal: 0x3d
  ULONG DeviceIdsHash;                        // offset: 0x2ac ordinal: 0x3e
  UCHAR RequiresUnloadedDriver;               // offset: 0x2b0 ordinal: 0x3f
  struct _PENDING_RELATIONS_LIST_ENTRY
      *PendingEjectRelations; // offset: 0x2b8 ordinal: 0x40
  ULONG StateFlags;           // offset: 0x2c0 ordinal: 0x41
  struct _PNP_REBALANCE_TRACE_CONTEXT
      *RebalanceContext; // offset: 0x2c8 ordinal: 0x42
  struct _DEVICE_NODE_IOMMU_EXTENSION
      *IommuExtension; // offset: 0x2d0 ordinal: 0x43
  struct _PO_DIRECTED_DRIPS_STATE
      DirectedDripsState; // offset: 0x2d8 ordinal: 0x44
  struct _PNP_PROBLEM_CODE_LOG_ENTRY
      ProblemCodeLog[4];                       // offset: 0x310 ordinal: 0x45
  ULONG ProblemCodeLogNextIndex;               // offset: 0x370 ordinal: 0x46
  union _LARGE_INTEGER StateTimestamp;         // offset: 0x378 ordinal: 0x47
  union _LARGE_INTEGER PreviousStateTimestamp; // offset: 0x380 ordinal: 0x48
} _DEVICE_NODE;

// 0x138 bytes (sizeof)
typedef struct _POP_IRP_DATA {
  struct _LIST_ENTRY Link;               // offset: 0x0 ordinal: 0x0
  struct _IRP *Irp;                      // offset: 0x10 ordinal: 0x1
  struct _DEVICE_OBJECT *Pdo;            // offset: 0x18 ordinal: 0x2
  struct _DEVICE_OBJECT *TargetDevice;   // offset: 0x20 ordinal: 0x3
  struct _DEVICE_OBJECT *CurrentDevice;  // offset: 0x28 ordinal: 0x4
  ULONGLONG WatchdogStart;               // offset: 0x30 ordinal: 0x5
  struct _KTIMER WatchdogTimer;          // offset: 0x38 ordinal: 0x6
  struct _KDPC WatchdogDpc;              // offset: 0x78 ordinal: 0x7
  UCHAR MinorFunction;                   // offset: 0xb8 ordinal: 0x8
  enum _POWER_STATE_TYPE PowerStateType; // offset: 0xbc ordinal: 0x9
  union _POWER_STATE PowerState;         // offset: 0xc0 ordinal: 0xa
  struct _POP_FX_DEVICE *FxDevice;       // offset: 0xc8 ordinal: 0xb
  UCHAR SystemTransition;                // offset: 0xd0 ordinal: 0xc
  UCHAR NotifyPEP;                       // offset: 0xd1 ordinal: 0xd
  LONG IrpSequenceID;                    // offset: 0xd4 ordinal: 0xe
  union {
    struct __anon_859 Device; // offset: 0xd8 ordinal: 0xf
    struct __anon_860 System; // offset: 0xd8 ordinal: 0x10
  };
  enum _POP_PEP_NOTIFY_DEVICE_DSTATE_REASON
      DStateReason;                           // offset: 0x118 ordinal: 0x11
  ULONGLONG WatchdogLock;                     // offset: 0x120 ordinal: 0x12
  enum _POP_IRP_WATCHDOG_STATE WatchdogState; // offset: 0x128 ordinal: 0x13
  ULONGLONG BlackboxWatchdogStartTime;        // offset: 0x130 ordinal: 0x14
} _POP_IRP_DATA;

// 0x230 bytes (sizeof)
typedef struct _PROCESSOR_POWER_STATE {
  struct _PPM_IDLE_STATES *IdleStates;          // offset: 0x0 ordinal: 0x0
  struct _PROC_IDLE_ACCOUNTING *IdleAccounting; // offset: 0x8 ordinal: 0x1
  ULONGLONG IdleTimeLast;                       // offset: 0x10 ordinal: 0x2
  ULONGLONG IdleTimeTotal;                      // offset: 0x18 ordinal: 0x3
  ULONGLONG IdleSequenceNumber;                 // offset: 0x20 ordinal: 0x4
  ULONGLONG IdleTimeEntry;                      // offset: 0x28 ordinal: 0x5
  union {
    ULONGLONG IdleTimeExpiration; // offset: 0x30 ordinal: 0x6
    LONGLONG IdleWakeTime;        // offset: 0x30 ordinal: 0x7
  };
  UCHAR NonInterruptibleTransition;    // offset: 0x38 ordinal: 0x8
  UCHAR PepWokenTransition;            // offset: 0x39 ordinal: 0x9
  UCHAR HvTargetState;                 // offset: 0x3a ordinal: 0xa
  UCHAR SoftParked;                    // offset: 0x3b ordinal: 0xb
  ULONG TargetIdleState;               // offset: 0x3c ordinal: 0xc
  struct _PROC_IDLE_POLICY IdlePolicy; // offset: 0x40 ordinal: 0xd
  union _PPM_IDLE_SYNCHRONIZATION_STATE
      Synchronization;                    // offset: 0x48 ordinal: 0xe
  struct _PROC_FEEDBACK PerfFeedback;     // offset: 0x50 ordinal: 0xf
  enum _PROC_HYPERVISOR_STATE Hypervisor; // offset: 0xe0 ordinal: 0x10
  ULONG LastSysTime;                      // offset: 0xe4 ordinal: 0x11
  ULONGLONG WmiDispatchPtr;               // offset: 0xe8 ordinal: 0x12
  LONG WmiInterfaceEnabled;               // offset: 0xf0 ordinal: 0x13
  struct _PPM_FFH_THROTTLE_STATE_INFO
      FFHThrottleStateInfo;                     // offset: 0xf8 ordinal: 0x14
  struct _KDPC PerfActionDpc;                   // offset: 0x118 ordinal: 0x15
  LONG PerfActionMask;                          // offset: 0x158 ordinal: 0x16
  struct _PROC_IDLE_SNAP HvIdleCheck;           // offset: 0x160 ordinal: 0x17
  struct _PROC_PERF_CHECK_CONTEXT CheckContext; // offset: 0x170 ordinal: 0x18
  struct _PPM_CONCURRENCY_ACCOUNTING
      *Concurrency; // offset: 0x1b8 ordinal: 0x19
  struct _PPM_CONCURRENCY_ACCOUNTING
      *ClassConcurrency;                       // offset: 0x1c0 ordinal: 0x1a
  UCHAR ArchitecturalEfficiencyClass;          // offset: 0x1c8 ordinal: 0x1b
  UCHAR PerformanceSchedulingClass;            // offset: 0x1c9 ordinal: 0x1c
  UCHAR EfficiencySchedulingClass;             // offset: 0x1ca ordinal: 0x1d
  UCHAR EarlyBootArchitecturalEfficiencyClass; // offset: 0x1cb ordinal: 0x1e
  UCHAR Parked;                                // offset: 0x1cc ordinal: 0x1f
  UCHAR LongPriorQosPeriod;                    // offset: 0x1cd ordinal: 0x20
  union {
    ULONGLONG SnapTimeLast;   // offset: 0x1d0 ordinal: 0x21
    ULONGLONG EnergyConsumed; // offset: 0x1d0 ordinal: 0x22
  };
  ULONGLONG ActiveTime;                    // offset: 0x1d8 ordinal: 0x23
  ULONGLONG TotalTime;                     // offset: 0x1e0 ordinal: 0x24
  struct _POP_FX_DEVICE *FxDevice;         // offset: 0x1e8 ordinal: 0x25
  ULONGLONG LastQosTranstionTsc;           // offset: 0x1f0 ordinal: 0x26
  ULONGLONG QosTransitionHysteresis;       // offset: 0x1f8 ordinal: 0x27
  enum _KHETERO_CPU_QOS RequestedQosClass; // offset: 0x200 ordinal: 0x28
  enum _KHETERO_CPU_QOS ResolvedQosClass;  // offset: 0x204 ordinal: 0x29
  USHORT QosEquivalencyMask;               // offset: 0x208 ordinal: 0x2a
  USHORT HwFeedbackTableOffset;            // offset: 0x20a ordinal: 0x2b
  UCHAR HwFeedbackParkHint;                // offset: 0x20c ordinal: 0x2c
  UCHAR HeteroCoreType;                    // offset: 0x20d ordinal: 0x2d
  USHORT HwFeedbackTableIndex;             // offset: 0x20e ordinal: 0x2e
  struct _KHETRO_HWFEEDBACK_TYPE
      *HwFeedbackClassList; // offset: 0x210 ordinal: 0x2f
  struct _PROCESSOR_CYCLES_WORKLOAD_CLASS
      *EeCyclesWorkloadClassList; // offset: 0x218 ordinal: 0x30
  struct _PROCESSOR_CYCLES_WORKLOAD_CLASS
      *PerfCyclesWorkloadClassList; // offset: 0x220 ordinal: 0x31
  UCHAR NotUsed;                    // offset: 0x228 ordinal: 0x32
} _PROCESSOR_POWER_STATE;

// 0x480 bytes (sizeof)
typedef struct _KTHREAD {
  struct _DISPATCHER_HEADER Header;           // offset: 0x0 ordinal: 0x0
  VOID *SListFaultAddress;                    // offset: 0x18 ordinal: 0x1
  ULONGLONG QuantumTarget;                    // offset: 0x20 ordinal: 0x2
  VOID *InitialStack;                         // offset: 0x28 ordinal: 0x3
  VOID *StackLimit;                           // offset: 0x30 ordinal: 0x4
  VOID *StackBase;                            // offset: 0x38 ordinal: 0x5
  ULONGLONG ThreadLock;                       // offset: 0x40 ordinal: 0x6
  ULONGLONG CycleTime;                        // offset: 0x48 ordinal: 0x7
  ULONG CurrentRunTime;                       // offset: 0x50 ordinal: 0x8
  ULONG ExpectedRunTime;                      // offset: 0x54 ordinal: 0x9
  VOID *KernelStack;                          // offset: 0x58 ordinal: 0xa
  struct _XSAVE_FORMAT *StateSaveArea;        // offset: 0x60 ordinal: 0xb
  struct _KSCHEDULING_GROUP *SchedulingGroup; // offset: 0x68 ordinal: 0xc
  union _KWAIT_STATUS_REGISTER WaitRegister;  // offset: 0x70 ordinal: 0xd
  UCHAR Running;                              // offset: 0x71 ordinal: 0xe
  UCHAR Alerted[2];                           // offset: 0x72 ordinal: 0xf
  ULONG AutoBoostActive : 1;                  // offset: 0x74 ordinal: 0x10
  ULONG ReadyTransition : 1;                  // offset: 0x74 ordinal: 0x11
  ULONG WaitNext : 1;                         // offset: 0x74 ordinal: 0x12
  ULONG SystemAffinityActive : 1;             // offset: 0x74 ordinal: 0x13
  ULONG Alertable : 1;                        // offset: 0x74 ordinal: 0x14
  ULONG UserStackWalkActive : 1;              // offset: 0x74 ordinal: 0x15
  ULONG ApcInterruptRequest : 1;              // offset: 0x74 ordinal: 0x16
  ULONG QuantumEndMigrate : 1;                // offset: 0x74 ordinal: 0x17
  ULONG SecureThread : 1;                     // offset: 0x74 ordinal: 0x18
  ULONG TimerActive : 1;                      // offset: 0x74 ordinal: 0x19
  ULONG SystemThread : 1;                     // offset: 0x74 ordinal: 0x1a
  ULONG ProcessDetachActive : 1;              // offset: 0x74 ordinal: 0x1b
  ULONG CalloutActive : 1;                    // offset: 0x74 ordinal: 0x1c
  ULONG ScbReadyQueue : 1;                    // offset: 0x74 ordinal: 0x1d
  ULONG ApcQueueable : 1;                     // offset: 0x74 ordinal: 0x1e
  ULONG ReservedStackInUse : 1;               // offset: 0x74 ordinal: 0x1f
  ULONG Spare : 1;                            // offset: 0x74 ordinal: 0x20
  ULONG TimerSuspended : 1;                   // offset: 0x74 ordinal: 0x21
  ULONG SuspendedWaitMode : 1;                // offset: 0x74 ordinal: 0x22
  ULONG SuspendSchedulerApcWait : 1;          // offset: 0x74 ordinal: 0x23
  ULONG CetUserShadowStack : 1;               // offset: 0x74 ordinal: 0x24
  ULONG BypassProcessFreeze : 1;              // offset: 0x74 ordinal: 0x25
  ULONG CetKernelShadowStack : 1;             // offset: 0x74 ordinal: 0x26
  ULONG StateSaveAreaDecoupled : 1;           // offset: 0x74 ordinal: 0x27
  ULONG Reserved : 8;                         // offset: 0x74 ordinal: 0x28
  LONG MiscFlags;                             // offset: 0x74 ordinal: 0x29
  ULONG UserIdealProcessorFixed : 1;          // offset: 0x78 ordinal: 0x2a
  ULONG IsolationWidth : 1;                   // offset: 0x78 ordinal: 0x2b
  ULONG AutoAlignment : 1;                    // offset: 0x78 ordinal: 0x2c
  ULONG DisableBoost : 1;                     // offset: 0x78 ordinal: 0x2d
  ULONG AlertedByThreadId : 1;                // offset: 0x78 ordinal: 0x2e
  ULONG QuantumDonation : 1;                  // offset: 0x78 ordinal: 0x2f
  ULONG EnableStackSwap : 1;                  // offset: 0x78 ordinal: 0x30
  ULONG GuiThread : 1;                        // offset: 0x78 ordinal: 0x31
  ULONG DisableQuantum : 1;                   // offset: 0x78 ordinal: 0x32
  ULONG ChargeOnlySchedulingGroup : 1;        // offset: 0x78 ordinal: 0x33
  ULONG DeferPreemption : 1;                  // offset: 0x78 ordinal: 0x34
  ULONG QueueDeferPreemption : 1;             // offset: 0x78 ordinal: 0x35
  ULONG ForceDeferSchedule : 1;               // offset: 0x78 ordinal: 0x36
  ULONG SharedReadyQueueAffinity : 1;         // offset: 0x78 ordinal: 0x37
  ULONG FreezeCount : 1;                      // offset: 0x78 ordinal: 0x38
  ULONG TerminationApcRequest : 1;            // offset: 0x78 ordinal: 0x39
  ULONG AutoBoostEntriesExhausted : 1;        // offset: 0x78 ordinal: 0x3a
  ULONG KernelStackResident : 1;              // offset: 0x78 ordinal: 0x3b
  ULONG TerminateRequestReason : 2;           // offset: 0x78 ordinal: 0x3c
  ULONG ProcessStackCountDecremented : 1;     // offset: 0x78 ordinal: 0x3d
  ULONG RestrictedGuiThread : 1;              // offset: 0x78 ordinal: 0x3e
  ULONG VpBackingThread : 1;                  // offset: 0x78 ordinal: 0x3f
  ULONG EtwStackTraceCrimsonApcDisabled : 1;  // offset: 0x78 ordinal: 0x40
  ULONG EtwStackTraceApcInserted : 8;         // offset: 0x78 ordinal: 0x41
  LONG ThreadFlags;                           // offset: 0x78 ordinal: 0x42
  UCHAR Tag;                                  // offset: 0x7c ordinal: 0x43
  UCHAR SystemHeteroCpuPolicy;                // offset: 0x7d ordinal: 0x44
  UCHAR UserHeteroCpuPolicy : 7;              // offset: 0x7e ordinal: 0x45
  UCHAR ExplicitSystemHeteroCpuPolicy : 1;    // offset: 0x7e ordinal: 0x46
  UCHAR RunningNonRetpolineCode : 1;          // offset: 0x7f ordinal: 0x47
  UCHAR SpecCtrlSpare : 7;                    // offset: 0x7f ordinal: 0x48
  UCHAR SpecCtrl;                             // offset: 0x7f ordinal: 0x49
  ULONG SystemCallNumber;                     // offset: 0x80 ordinal: 0x4a
  ULONG ReadyTime;                            // offset: 0x84 ordinal: 0x4b
  VOID *FirstArgument;                        // offset: 0x88 ordinal: 0x4c
  struct _KTRAP_FRAME *TrapFrame;             // offset: 0x90 ordinal: 0x4d
  union {
    struct _KAPC_STATE ApcState; // offset: 0x98 ordinal: 0x4e
    UCHAR ApcStateFill[43];      // offset: 0x98 ordinal: 0x4f
  };
  CHAR Priority;                      // offset: 0xc3 ordinal: 0x50
  ULONG UserIdealProcessor;           // offset: 0xc4 ordinal: 0x51
  LONGLONG WaitStatus;                // offset: 0xc8 ordinal: 0x52
  struct _KWAIT_BLOCK *WaitBlockList; // offset: 0xd0 ordinal: 0x53
  union {
    struct _LIST_ENTRY WaitListEntry;        // offset: 0xd8 ordinal: 0x54
    struct _SINGLE_LIST_ENTRY SwapListEntry; // offset: 0xd8 ordinal: 0x55
  };
  struct _DISPATCHER_HEADER *Queue; // offset: 0xe8 ordinal: 0x56
  VOID *Teb;                        // offset: 0xf0 ordinal: 0x57
  ULONGLONG RelativeTimerBias;      // offset: 0xf8 ordinal: 0x58
  struct _KTIMER Timer;             // offset: 0x100 ordinal: 0x59
  union {
    struct _KWAIT_BLOCK WaitBlock[4]; // offset: 0x140 ordinal: 0x5a
    UCHAR WaitBlockFill4[20];         // offset: 0x140 ordinal: 0x5b
  };
  ULONG ContextSwitches;                    // offset: 0x154 ordinal: 0x5c
  UCHAR WaitBlockFill5[68];                 // offset: 0x140 ordinal: 0x5d
  UCHAR State;                              // offset: 0x184 ordinal: 0x5e
  CHAR Spare13;                             // offset: 0x185 ordinal: 0x5f
  UCHAR WaitIrql;                           // offset: 0x186 ordinal: 0x60
  CHAR WaitMode;                            // offset: 0x187 ordinal: 0x61
  UCHAR WaitBlockFill6[116];                // offset: 0x140 ordinal: 0x62
  ULONG WaitTime;                           // offset: 0x1b4 ordinal: 0x63
  UCHAR WaitBlockFill7[164];                // offset: 0x140 ordinal: 0x64
  SHORT KernelApcDisable;                   // offset: 0x1e4 ordinal: 0x65
  SHORT SpecialApcDisable;                  // offset: 0x1e6 ordinal: 0x66
  ULONG CombinedApcDisable;                 // offset: 0x1e4 ordinal: 0x67
  UCHAR WaitBlockFill8[40];                 // offset: 0x140 ordinal: 0x68
  struct _KTHREAD_COUNTERS *ThreadCounters; // offset: 0x168 ordinal: 0x69
  UCHAR WaitBlockFill9[88];                 // offset: 0x140 ordinal: 0x6a
  struct _XSTATE_SAVE *XStateSave;          // offset: 0x198 ordinal: 0x6b
  UCHAR WaitBlockFill10[136];               // offset: 0x140 ordinal: 0x6c
  VOID *Win32Thread;                        // offset: 0x1c8 ordinal: 0x6d
  UCHAR WaitBlockFill11[176];               // offset: 0x140 ordinal: 0x6e
  ULONGLONG Spare18;                        // offset: 0x1f0 ordinal: 0x6f
  ULONGLONG Spare19;                        // offset: 0x1f8 ordinal: 0x70
  union {
    LONG ThreadFlags2;     // offset: 0x200 ordinal: 0x71
    ULONG BamQosLevel : 8; // offset: 0x200 ordinal: 0x72
  };
  ULONG ThreadFlags2Reserved : 24;   // offset: 0x200 ordinal: 0x73
  UCHAR HgsFeedbackClass;            // offset: 0x204 ordinal: 0x74
  UCHAR Spare23[3];                  // offset: 0x205 ordinal: 0x75
  struct _LIST_ENTRY QueueListEntry; // offset: 0x208 ordinal: 0x76
  union {
    ULONG NextProcessor;            // offset: 0x218 ordinal: 0x77
    ULONG NextProcessorNumber : 31; // offset: 0x218 ordinal: 0x78
  };
  ULONG SharedReadyQueue : 1;         // offset: 0x218 ordinal: 0x79
  LONG QueuePriority;                 // offset: 0x21c ordinal: 0x7a
  struct _KPROCESS *Process;          // offset: 0x220 ordinal: 0x7b
  struct _KAFFINITY_EX *UserAffinity; // offset: 0x228 ordinal: 0x7c
  USHORT UserAffinityPrimaryGroup;    // offset: 0x230 ordinal: 0x7d
  CHAR PreviousMode;                  // offset: 0x232 ordinal: 0x7e
  CHAR BasePriority;                  // offset: 0x233 ordinal: 0x7f
  union {
    CHAR PriorityDecrement;    // offset: 0x234 ordinal: 0x80
    UCHAR ForegroundBoost : 4; // offset: 0x234 ordinal: 0x81
  };
  UCHAR UnusualBoost : 4;         // offset: 0x234 ordinal: 0x82
  UCHAR Preempted;                // offset: 0x235 ordinal: 0x83
  UCHAR AdjustReason;             // offset: 0x236 ordinal: 0x84
  CHAR AdjustIncrement;           // offset: 0x237 ordinal: 0x85
  ULONGLONG AffinityVersion;      // offset: 0x238 ordinal: 0x86
  struct _KAFFINITY_EX *Affinity; // offset: 0x240 ordinal: 0x87
  USHORT AffinityPrimaryGroup;    // offset: 0x248 ordinal: 0x88
  UCHAR ApcStateIndex;            // offset: 0x24a ordinal: 0x89
  UCHAR WaitBlockCount;           // offset: 0x24b ordinal: 0x8a
  ULONG IdealProcessor;           // offset: 0x24c ordinal: 0x8b
  ULONGLONG NpxState;             // offset: 0x250 ordinal: 0x8c
  union {
    struct _KAPC_STATE SavedApcState; // offset: 0x258 ordinal: 0x8d
    UCHAR SavedApcStateFill[43];      // offset: 0x258 ordinal: 0x8e
  };
  UCHAR WaitReason;       // offset: 0x283 ordinal: 0x8f
  CHAR SuspendCount;      // offset: 0x284 ordinal: 0x90
  CHAR Saturation;        // offset: 0x285 ordinal: 0x91
  USHORT SListFaultCount; // offset: 0x286 ordinal: 0x92
  union {
    struct _KAPC SchedulerApc;  // offset: 0x288 ordinal: 0x93
    UCHAR SchedulerApcFill1[3]; // offset: 0x288 ordinal: 0x94
  };
  UCHAR QuantumReset;                 // offset: 0x28b ordinal: 0x95
  UCHAR SchedulerApcFill2[4];         // offset: 0x288 ordinal: 0x96
  ULONG KernelTime;                   // offset: 0x28c ordinal: 0x97
  UCHAR SchedulerApcFill3[64];        // offset: 0x288 ordinal: 0x98
  struct _KPRCB *WaitPrcb;            // offset: 0x2c8 ordinal: 0x99
  UCHAR SchedulerApcFill4[72];        // offset: 0x288 ordinal: 0x9a
  VOID *LegoData;                     // offset: 0x2d0 ordinal: 0x9b
  UCHAR SchedulerApcFill5[83];        // offset: 0x288 ordinal: 0x9c
  UCHAR CallbackNestingLevel;         // offset: 0x2db ordinal: 0x9d
  ULONG UserTime;                     // offset: 0x2dc ordinal: 0x9e
  struct _KEVENT SuspendEvent;        // offset: 0x2e0 ordinal: 0x9f
  struct _LIST_ENTRY ThreadListEntry; // offset: 0x2f8 ordinal: 0xa0
  struct _LIST_ENTRY MutantListHead;  // offset: 0x308 ordinal: 0xa1
  UCHAR AbEntrySummary;               // offset: 0x318 ordinal: 0xa2
  UCHAR AbWaitEntryCount;             // offset: 0x319 ordinal: 0xa3
  union {
    UCHAR FreezeFlags;      // offset: 0x31a ordinal: 0xa4
    UCHAR FreezeCount2 : 1; // offset: 0x31a ordinal: 0xa5
  };
  UCHAR FreezeNormal : 1;                         // offset: 0x31a ordinal: 0xa6
  UCHAR FreezeDeep : 1;                           // offset: 0x31a ordinal: 0xa7
  CHAR SystemPriority;                            // offset: 0x31b ordinal: 0xa8
  ULONG SecureThreadCookie;                       // offset: 0x31c ordinal: 0xa9
  VOID *Spare22;                                  // offset: 0x320 ordinal: 0xaa
  struct _SINGLE_LIST_ENTRY PropagateBoostsEntry; // offset: 0x328 ordinal: 0xab
  struct _SINGLE_LIST_ENTRY IoSelfBoostsEntry;    // offset: 0x330 ordinal: 0xac
  UCHAR PriorityFloorCounts[32];                  // offset: 0x338 ordinal: 0xad
  ULONG PriorityFloorSummary;                     // offset: 0x358 ordinal: 0xae
  LONG AbCompletedIoBoostCount;                   // offset: 0x35c ordinal: 0xaf
  LONG AbCompletedIoQoSBoostCount;                // offset: 0x360 ordinal: 0xb0
  SHORT KeReferenceCount;                         // offset: 0x364 ordinal: 0xb1
  UCHAR AbOrphanedEntrySummary;                   // offset: 0x366 ordinal: 0xb2
  UCHAR AbOwnedEntryCount;                        // offset: 0x367 ordinal: 0xb3
  ULONG ForegroundLossTime;                       // offset: 0x368 ordinal: 0xb4
  union {
    struct _LIST_ENTRY GlobalForegroundListEntry; // offset: 0x370 ordinal: 0xb5
    struct _SINGLE_LIST_ENTRY
        ForegroundDpcStackListEntry; // offset: 0x370 ordinal: 0xb6
  };
  ULONGLONG InGlobalForegroundList; // offset: 0x378 ordinal: 0xb7
  LONGLONG ReadOperationCount;      // offset: 0x380 ordinal: 0xb8
  LONGLONG WriteOperationCount;     // offset: 0x388 ordinal: 0xb9
  LONGLONG OtherOperationCount;     // offset: 0x390 ordinal: 0xba
  LONGLONG ReadTransferCount;       // offset: 0x398 ordinal: 0xbb
  LONGLONG WriteTransferCount;      // offset: 0x3a0 ordinal: 0xbc
  LONGLONG OtherTransferCount;      // offset: 0x3a8 ordinal: 0xbd
  struct _KSCB *QueuedScb;          // offset: 0x3b0 ordinal: 0xbe
  ULONG ThreadTimerDelay;           // offset: 0x3b8 ordinal: 0xbf
  union {
    LONG ThreadFlags3;              // offset: 0x3bc ordinal: 0xc0
    ULONG ThreadFlags3Reserved : 8; // offset: 0x3bc ordinal: 0xc1
  };
  ULONG PpmPolicy : 3;                  // offset: 0x3bc ordinal: 0xc2
  ULONG ThreadFlags3Reserved2 : 21;     // offset: 0x3bc ordinal: 0xc3
  ULONGLONG TracingPrivate[1];          // offset: 0x3c0 ordinal: 0xc4
  VOID *SchedulerAssist;                // offset: 0x3c8 ordinal: 0xc5
  VOID *AbWaitObject;                   // offset: 0x3d0 ordinal: 0xc6
  ULONG ReservedPreviousReadyTimeValue; // offset: 0x3d8 ordinal: 0xc7
  ULONGLONG KernelWaitTime;             // offset: 0x3e0 ordinal: 0xc8
  ULONGLONG UserWaitTime;               // offset: 0x3e8 ordinal: 0xc9
  union {
    struct _LIST_ENTRY
        GlobalUpdateVpThreadPriorityListEntry; // offset: 0x3f0 ordinal: 0xca
    struct _SINGLE_LIST_ENTRY
        UpdateVpThreadPriorityDpcStackListEntry; // offset: 0x3f0 ordinal: 0xcb
  };
  ULONGLONG InGlobalUpdateVpThreadPriorityList; // offset: 0x3f8 ordinal: 0xcc
  LONG SchedulerAssistPriorityFloor;            // offset: 0x400 ordinal: 0xcd
  LONG RealtimePriorityFloor;                   // offset: 0x404 ordinal: 0xce
  VOID *KernelShadowStack;                      // offset: 0x408 ordinal: 0xcf
  VOID *KernelShadowStackInitial;               // offset: 0x410 ordinal: 0xd0
  VOID *KernelShadowStackBase;                  // offset: 0x418 ordinal: 0xd1
  union _KERNEL_SHADOW_STACK_LIMIT
      KernelShadowStackLimit;            // offset: 0x420 ordinal: 0xd2
  ULONGLONG ExtendedFeatureDisableMask;  // offset: 0x428 ordinal: 0xd3
  ULONGLONG HgsFeedbackStartTime;        // offset: 0x430 ordinal: 0xd4
  ULONGLONG HgsFeedbackCycles;           // offset: 0x438 ordinal: 0xd5
  ULONG HgsInvalidFeedbackCount;         // offset: 0x440 ordinal: 0xd6
  ULONG HgsLowerPerfClassFeedbackCount;  // offset: 0x444 ordinal: 0xd7
  ULONG HgsHigherPerfClassFeedbackCount; // offset: 0x448 ordinal: 0xd8
  ULONG Spare27;                         // offset: 0x44c ordinal: 0xd9
  struct _SINGLE_LIST_ENTRY
      SystemAffinityTokenListHead; // offset: 0x450 ordinal: 0xda
  VOID *IptSaveArea;               // offset: 0x458 ordinal: 0xdb
  UCHAR ResourceIndex;             // offset: 0x460 ordinal: 0xdc
  UCHAR CoreIsolationReasons;      // offset: 0x461 ordinal: 0xdd
  UCHAR BamQosLevelFromAssistPage; // offset: 0x462 ordinal: 0xde
  UCHAR Spare31[1];                // offset: 0x463 ordinal: 0xdf
  ULONG Spare32;                   // offset: 0x464 ordinal: 0xe0
  ULONGLONG EndPadding[3];         // offset: 0x468 ordinal: 0xe1
} _KTHREAD;

// 0x120 bytes (sizeof)
typedef struct _KINTERRUPT {
  SHORT Type;                            // offset: 0x0 ordinal: 0x0
  SHORT Size;                            // offset: 0x2 ordinal: 0x1
  struct _LIST_ENTRY InterruptListEntry; // offset: 0x8 ordinal: 0x2
  UCHAR(*ServiceRoutine)
  (struct _KINTERRUPT *, VOID *); // offset: 0x18 ordinal: 0x3
  UCHAR(*MessageServiceRoutine)
  (struct _KINTERRUPT *, VOID *, ULONG); // offset: 0x20 ordinal: 0x4
  ULONG MessageIndex;                    // offset: 0x28 ordinal: 0x5
  VOID *ServiceContext;                  // offset: 0x30 ordinal: 0x6
  ULONGLONG SpinLock;                    // offset: 0x38 ordinal: 0x7
  ULONG TickCount;                       // offset: 0x40 ordinal: 0x8
  ULONGLONG *ActualLock;                 // offset: 0x48 ordinal: 0x9
  VOID (*DispatchAddress)();             // offset: 0x50 ordinal: 0xa
  ULONG Vector;                          // offset: 0x58 ordinal: 0xb
  UCHAR Irql;                            // offset: 0x5c ordinal: 0xc
  UCHAR SynchronizeIrql;                 // offset: 0x5d ordinal: 0xd
  UCHAR FloatingSave;                    // offset: 0x5e ordinal: 0xe
  UCHAR Connected;                       // offset: 0x5f ordinal: 0xf
  ULONG Number;                          // offset: 0x60 ordinal: 0x10
  UCHAR ShareVector;                     // offset: 0x64 ordinal: 0x11
  UCHAR EmulateActiveBoth;               // offset: 0x65 ordinal: 0x12
  USHORT ActiveCount;                    // offset: 0x66 ordinal: 0x13
  LONG InternalState;                    // offset: 0x68 ordinal: 0x14
  enum _KINTERRUPT_MODE Mode;            // offset: 0x6c ordinal: 0x15
  enum _KINTERRUPT_POLARITY Polarity;    // offset: 0x70 ordinal: 0x16
  ULONG ServiceCount;                    // offset: 0x74 ordinal: 0x17
  ULONG DispatchCount;                   // offset: 0x78 ordinal: 0x18
  struct _KEVENT *PassiveEvent;          // offset: 0x80 ordinal: 0x19
  struct _KTRAP_FRAME *TrapFrame;        // offset: 0x88 ordinal: 0x1a
  VOID *DisconnectData;                  // offset: 0x90 ordinal: 0x1b
  struct _KTHREAD *ServiceThread;        // offset: 0x98 ordinal: 0x1c
  struct _INTERRUPT_CONNECTION_DATA
      *ConnectionData;             // offset: 0xa0 ordinal: 0x1d
  VOID *IntTrackEntry;             // offset: 0xa8 ordinal: 0x1e
  struct _ISRDPCSTATS IsrDpcStats; // offset: 0xb0 ordinal: 0x1f
  VOID *RedirectObject;            // offset: 0x110 ordinal: 0x20
  UCHAR Padding[8];                // offset: 0x118 ordinal: 0x21
} _KINTERRUPT;

// 0x30 bytes (sizeof)
typedef struct _KSECONDARY_IDT_ENTRY {
  ULONGLONG SpinLock;                // offset: 0x0 ordinal: 0x0
  struct _KEVENT ConnectLock;        // offset: 0x8 ordinal: 0x1
  UCHAR LineMasked;                  // offset: 0x20 ordinal: 0x2
  struct _KINTERRUPT *InterruptList; // offset: 0x28 ordinal: 0x3
} _KSECONDARY_IDT_ENTRY;

typedef UCHAR (*__anon_3093)(struct _KINTERRUPT *, VOID *, ULONG);

typedef UCHAR (*__anon_3092)(struct _KINTERRUPT *, VOID *);

// 0x98 bytes (sizeof)
typedef struct _INTERRUPT_TRACKING_ENTRY {
  struct _LIST_ENTRY ListEntry;                  // offset: 0x0 ordinal: 0x0
  struct _INTERRUPT_TRACKING_ROOT *IntTrackRoot; // offset: 0x10 ordinal: 0x1
  ULONG InterruptObjectCount;                    // offset: 0x18 ordinal: 0x2
  struct _KINTERRUPT **InterruptObjectArray;     // offset: 0x20 ordinal: 0x3
  ULONGLONG IsrTime;                             // offset: 0x28 ordinal: 0x4
  ULONGLONG DpcTime;                             // offset: 0x30 ordinal: 0x5
  UCHAR IsPrimaryInterrupt;                      // offset: 0x38 ordinal: 0x6
  struct _INTERRUPT_VECTOR_DATA VectorData;      // offset: 0x40 ordinal: 0x7
} _INTERRUPT_TRACKING_ENTRY;

// 0x900 bytes (sizeof)
typedef struct _ETHREAD {
  struct _KTHREAD Tcb;             // offset: 0x0 ordinal: 0x0
  union _LARGE_INTEGER CreateTime; // offset: 0x480 ordinal: 0x1
  union {
    union _LARGE_INTEGER ExitTime;     // offset: 0x488 ordinal: 0x2
    struct _LIST_ENTRY KeyedWaitChain; // offset: 0x488 ordinal: 0x3
  };
  union {
    struct _LIST_ENTRY PostBlockList; // offset: 0x498 ordinal: 0x4
    VOID *ForwardLinkShadow;          // offset: 0x498 ordinal: 0x5
  };
  VOID *StartAddress; // offset: 0x4a0 ordinal: 0x6
  union {
    struct _TERMINATION_PORT *TerminationPort; // offset: 0x4a8 ordinal: 0x7
    struct _ETHREAD *ReaperLink;               // offset: 0x4a8 ordinal: 0x8
    VOID *KeyedWaitValue;                      // offset: 0x4a8 ordinal: 0x9
  };
  ULONGLONG ActiveTimerListLock;          // offset: 0x4b0 ordinal: 0xa
  struct _LIST_ENTRY ActiveTimerListHead; // offset: 0x4b8 ordinal: 0xb
  struct _CLIENT_ID Cid;                  // offset: 0x4c8 ordinal: 0xc
  union {
    struct _KSEMAPHORE KeyedWaitSemaphore; // offset: 0x4d8 ordinal: 0xd
    struct _KSEMAPHORE AlpcWaitSemaphore;  // offset: 0x4d8 ordinal: 0xe
  };
  union _PS_CLIENT_SECURITY_CONTEXT
      ClientSecurity;                    // offset: 0x4f8 ordinal: 0xf
  struct _LIST_ENTRY IrpList;            // offset: 0x500 ordinal: 0x10
  ULONGLONG TopLevelIrp;                 // offset: 0x510 ordinal: 0x11
  struct _DEVICE_OBJECT *DeviceToVerify; // offset: 0x518 ordinal: 0x12
  VOID *Win32StartAddress;               // offset: 0x520 ordinal: 0x13
  VOID *ChargeOnlySession;               // offset: 0x528 ordinal: 0x14
  VOID *LegacyPowerObject;               // offset: 0x530 ordinal: 0x15
  struct _LIST_ENTRY ThreadListEntry;    // offset: 0x538 ordinal: 0x16
  struct _EX_RUNDOWN_REF RundownProtect; // offset: 0x548 ordinal: 0x17
  struct _EX_PUSH_LOCK ThreadLock;       // offset: 0x550 ordinal: 0x18
  ULONG ReadClusterSize;                 // offset: 0x558 ordinal: 0x19
  LONG MmLockOrdering;                   // offset: 0x55c ordinal: 0x1a
  union {
    ULONG CrossThreadFlags; // offset: 0x560 ordinal: 0x1b
    ULONG Terminated : 1;   // offset: 0x560 ordinal: 0x1c
  };
  ULONG ThreadInserted : 1;           // offset: 0x560 ordinal: 0x1d
  ULONG HideFromDebugger : 1;         // offset: 0x560 ordinal: 0x1e
  ULONG ActiveImpersonationInfo : 1;  // offset: 0x560 ordinal: 0x1f
  ULONG HardErrorsAreDisabled : 1;    // offset: 0x560 ordinal: 0x20
  ULONG BreakOnTermination : 1;       // offset: 0x560 ordinal: 0x21
  ULONG SkipCreationMsg : 1;          // offset: 0x560 ordinal: 0x22
  ULONG SkipTerminationMsg : 1;       // offset: 0x560 ordinal: 0x23
  ULONG CopyTokenOnOpen : 1;          // offset: 0x560 ordinal: 0x24
  ULONG ThreadIoPriority : 3;         // offset: 0x560 ordinal: 0x25
  ULONG ThreadPagePriority : 3;       // offset: 0x560 ordinal: 0x26
  ULONG RundownFail : 1;              // offset: 0x560 ordinal: 0x27
  ULONG UmsForceQueueTermination : 1; // offset: 0x560 ordinal: 0x28
  ULONG IndirectCpuSets : 1;          // offset: 0x560 ordinal: 0x29
  ULONG DisableDynamicCodeOptOut : 1; // offset: 0x560 ordinal: 0x2a
  ULONG ExplicitCaseSensitivity : 1;  // offset: 0x560 ordinal: 0x2b
  ULONG PicoNotifyExit : 1;           // offset: 0x560 ordinal: 0x2c
  ULONG DbgWerUserReportActive : 1;   // offset: 0x560 ordinal: 0x2d
  ULONG ForcedSelfTrimActive : 1;     // offset: 0x560 ordinal: 0x2e
  ULONG SamplingCoverage : 1;         // offset: 0x560 ordinal: 0x2f
  ULONG ReservedCrossThreadFlags : 8; // offset: 0x560 ordinal: 0x30
  union {
    ULONG SameThreadPassiveFlags; // offset: 0x564 ordinal: 0x31
    ULONG ActiveExWorker : 1;     // offset: 0x564 ordinal: 0x32
  };
  ULONG MemoryMaker : 1;                     // offset: 0x564 ordinal: 0x33
  ULONG StoreLockThread : 2;                 // offset: 0x564 ordinal: 0x34
  ULONG ClonedThread : 1;                    // offset: 0x564 ordinal: 0x35
  ULONG KeyedEventInUse : 1;                 // offset: 0x564 ordinal: 0x36
  ULONG SelfTerminate : 1;                   // offset: 0x564 ordinal: 0x37
  ULONG RespectIoPriority : 1;               // offset: 0x564 ordinal: 0x38
  ULONG ActivePageLists : 1;                 // offset: 0x564 ordinal: 0x39
  ULONG SecureContext : 1;                   // offset: 0x564 ordinal: 0x3a
  ULONG ZeroPageThread : 1;                  // offset: 0x564 ordinal: 0x3b
  ULONG WorkloadClass : 1;                   // offset: 0x564 ordinal: 0x3c
  ULONG GenerateDumpOnBadHandleAccess : 1;   // offset: 0x564 ordinal: 0x3d
  ULONG ReservedSameThreadPassiveFlags : 19; // offset: 0x564 ordinal: 0x3e
  union {
    ULONG SameThreadApcFlags;                   // offset: 0x568 ordinal: 0x3f
    UCHAR OwnsProcessAddressSpaceExclusive : 1; // offset: 0x568 ordinal: 0x40
  };
  UCHAR OwnsProcessAddressSpaceShared : 1;       // offset: 0x568 ordinal: 0x41
  UCHAR HardFaultBehavior : 1;                   // offset: 0x568 ordinal: 0x42
  UCHAR StartAddressInvalid : 1;                 // offset: 0x568 ordinal: 0x43
  UCHAR EtwCalloutActive : 1;                    // offset: 0x568 ordinal: 0x44
  UCHAR SuppressSymbolLoad : 1;                  // offset: 0x568 ordinal: 0x45
  UCHAR Prefetching : 1;                         // offset: 0x568 ordinal: 0x46
  UCHAR OwnsVadExclusive : 1;                    // offset: 0x568 ordinal: 0x47
  UCHAR SystemPagePriorityActive : 1;            // offset: 0x569 ordinal: 0x48
  UCHAR SystemPagePriority : 3;                  // offset: 0x569 ordinal: 0x49
  UCHAR AllowUserWritesToExecutableMemory : 1;   // offset: 0x569 ordinal: 0x4a
  UCHAR AllowKernelWritesToExecutableMemory : 1; // offset: 0x569 ordinal: 0x4b
  UCHAR OwnsVadShared : 1;                       // offset: 0x569 ordinal: 0x4c
  UCHAR SessionAttachActive : 1;                 // offset: 0x569 ordinal: 0x4d
  UCHAR PasidMsrValid : 1;                       // offset: 0x56a ordinal: 0x4e
  UCHAR CacheManagerActive;                      // offset: 0x56c ordinal: 0x4f
  UCHAR DisablePageFaultClustering;              // offset: 0x56d ordinal: 0x50
  UCHAR ActiveFaultCount;                        // offset: 0x56e ordinal: 0x51
  UCHAR LockOrderState;                          // offset: 0x56f ordinal: 0x52
  ULONG PerformanceCountLowReserved;             // offset: 0x570 ordinal: 0x53
  LONG PerformanceCountHighReserved;             // offset: 0x574 ordinal: 0x54
  ULONGLONG AlpcMessageId;                       // offset: 0x578 ordinal: 0x55
  union {
    VOID *AlpcMessage;             // offset: 0x580 ordinal: 0x56
    ULONG AlpcReceiveAttributeSet; // offset: 0x580 ordinal: 0x57
  };
  struct _LIST_ENTRY AlpcWaitListEntry;         // offset: 0x588 ordinal: 0x58
  LONG ExitStatus;                              // offset: 0x598 ordinal: 0x59
  ULONG CacheManagerCount;                      // offset: 0x59c ordinal: 0x5a
  ULONG IoBoostCount;                           // offset: 0x5a0 ordinal: 0x5b
  ULONG IoQoSBoostCount;                        // offset: 0x5a4 ordinal: 0x5c
  ULONG IoQoSThrottleCount;                     // offset: 0x5a8 ordinal: 0x5d
  ULONG KernelStackReference;                   // offset: 0x5ac ordinal: 0x5e
  struct _LIST_ENTRY BoostList;                 // offset: 0x5b0 ordinal: 0x5f
  struct _LIST_ENTRY DeboostList;               // offset: 0x5c0 ordinal: 0x60
  ULONGLONG BoostListLock;                      // offset: 0x5d0 ordinal: 0x61
  ULONGLONG IrpListLock;                        // offset: 0x5d8 ordinal: 0x62
  VOID *ReservedForSynchTracking;               // offset: 0x5e0 ordinal: 0x63
  struct _SINGLE_LIST_ENTRY CmCallbackListHead; // offset: 0x5e8 ordinal: 0x64
  struct _GUID *ActivityId;                     // offset: 0x5f0 ordinal: 0x65
  struct _SINGLE_LIST_ENTRY
      SeLearningModeListHead;                 // offset: 0x5f8 ordinal: 0x66
  VOID *VerifierContext;                      // offset: 0x600 ordinal: 0x67
  VOID *AdjustedClientToken;                  // offset: 0x608 ordinal: 0x68
  VOID *WorkOnBehalfThread;                   // offset: 0x610 ordinal: 0x69
  struct _PS_PROPERTY_SET PropertySet;        // offset: 0x618 ordinal: 0x6a
  VOID *PicoContext;                          // offset: 0x630 ordinal: 0x6b
  ULONGLONG UserFsBase;                       // offset: 0x638 ordinal: 0x6c
  ULONGLONG UserGsBase;                       // offset: 0x640 ordinal: 0x6d
  struct _THREAD_ENERGY_VALUES *EnergyValues; // offset: 0x648 ordinal: 0x6e
  union {
    ULONGLONG SelectedCpuSets;          // offset: 0x650 ordinal: 0x6f
    ULONGLONG *SelectedCpuSetsIndirect; // offset: 0x650 ordinal: 0x70
  };
  struct _EJOB *Silo;                            // offset: 0x658 ordinal: 0x71
  struct _UNICODE_STRING *ThreadName;            // offset: 0x660 ordinal: 0x72
  struct _CONTEXT *SetContextState;              // offset: 0x668 ordinal: 0x73
  UCHAR LastSoftParkElectionQos;                 // offset: 0x670 ordinal: 0x74
  UCHAR LastSoftParkElectionWorkloadType;        // offset: 0x671 ordinal: 0x75
  UCHAR LastSoftParkElectionRunningType;         // offset: 0x672 ordinal: 0x76
  UCHAR Spare1;                                  // offset: 0x673 ordinal: 0x77
  ULONG HeapData;                                // offset: 0x674 ordinal: 0x78
  struct _LIST_ENTRY OwnerEntryListHead;         // offset: 0x678 ordinal: 0x79
  ULONGLONG DisownedOwnerEntryListLock;          // offset: 0x688 ordinal: 0x7a
  struct _LIST_ENTRY DisownedOwnerEntryListHead; // offset: 0x690 ordinal: 0x7b
  struct _KLOCK_ENTRY LockEntries[6];            // offset: 0x6a0 ordinal: 0x7c
  VOID *CmThreadInfo;                            // offset: 0x8e0 ordinal: 0x7d
  VOID *FlsData;                                 // offset: 0x8e8 ordinal: 0x7e
  ULONG LastExpectedRunTime;                     // offset: 0x8f0 ordinal: 0x7f
  ULONG LastSoftParkElectionRunTime;             // offset: 0x8f4 ordinal: 0x80
  ULONGLONG LastSoftParkElectionGeneration;      // offset: 0x8f8 ordinal: 0x81
} _ETHREAD;

typedef VOID (*__anon_322)(struct _DRIVER_OBJECT *);

// 0x150 bytes (sizeof)
typedef struct _DEVICE_OBJECT {
  SHORT Type;                            // offset: 0x0 ordinal: 0x0
  USHORT Size;                           // offset: 0x2 ordinal: 0x1
  LONG ReferenceCount;                   // offset: 0x4 ordinal: 0x2
  struct _DRIVER_OBJECT *DriverObject;   // offset: 0x8 ordinal: 0x3
  struct _DEVICE_OBJECT *NextDevice;     // offset: 0x10 ordinal: 0x4
  struct _DEVICE_OBJECT *AttachedDevice; // offset: 0x18 ordinal: 0x5
  struct _IRP *CurrentIrp;               // offset: 0x20 ordinal: 0x6
  struct _IO_TIMER *Timer;               // offset: 0x28 ordinal: 0x7
  ULONG Flags;                           // offset: 0x30 ordinal: 0x8
  ULONG Characteristics;                 // offset: 0x34 ordinal: 0x9
  struct _VPB *Vpb;                      // offset: 0x38 ordinal: 0xa
  VOID *DeviceExtension;                 // offset: 0x40 ordinal: 0xb
  ULONG DeviceType;                      // offset: 0x48 ordinal: 0xc
  CHAR StackSize;                        // offset: 0x4c ordinal: 0xd
  union __anon_289 Queue;                // offset: 0x50 ordinal: 0xe
  ULONG AlignmentRequirement;            // offset: 0x98 ordinal: 0xf
  struct _KDEVICE_QUEUE DeviceQueue;     // offset: 0xa0 ordinal: 0x10
  struct _KDPC Dpc;                      // offset: 0xc8 ordinal: 0x11
  ULONG ActiveThreadCount;               // offset: 0x108 ordinal: 0x12
  VOID *SecurityDescriptor;              // offset: 0x110 ordinal: 0x13
  struct _KEVENT DeviceLock;             // offset: 0x118 ordinal: 0x14
  USHORT SectorSize;                     // offset: 0x130 ordinal: 0x15
  USHORT Spare1;                         // offset: 0x132 ordinal: 0x16
  struct _DEVOBJ_EXTENSION
      *DeviceObjectExtension; // offset: 0x138 ordinal: 0x17
  VOID *Reserved;             // offset: 0x140 ordinal: 0x18
} _DEVICE_OBJECT;

// 0x20 bytes (sizeof)
typedef struct _DBGK_SILOSTATE {
  struct _EX_PUSH_LOCK ErrorPortLock;       // offset: 0x0 ordinal: 0x0
  struct _DBGKP_ERROR_PORT *ErrorPort;      // offset: 0x8 ordinal: 0x1
  struct _EPROCESS *ErrorProcess;           // offset: 0x10 ordinal: 0x2
  struct _KEVENT *ErrorPortRegisteredEvent; // offset: 0x18 ordinal: 0x3
} _DBGK_SILOSTATE;

// 0x560 bytes (sizeof)
typedef struct _ESERVERSILO_GLOBALS {
  struct _OBP_SILODRIVERSTATE ObSiloState; // offset: 0x0 ordinal: 0x0
  struct _SEP_SILOSTATE SeSiloState;       // offset: 0x2e0 ordinal: 0x1
  struct _SEP_RM_LSA_CONNECTION_STATE
      SeRmSiloState;                            // offset: 0x310 ordinal: 0x2
  struct _ETW_SILODRIVERSTATE *EtwSiloState;    // offset: 0x360 ordinal: 0x3
  struct _EPROCESS *MiSessionLeaderProcess;     // offset: 0x368 ordinal: 0x4
  struct _EPROCESS *ExpDefaultErrorPortProcess; // offset: 0x370 ordinal: 0x5
  VOID *ExpDefaultErrorPort;                    // offset: 0x378 ordinal: 0x6
  ULONG HardErrorState;                         // offset: 0x380 ordinal: 0x7
  struct _EXP_LICENSE_STATE *ExpLicenseState;   // offset: 0x388 ordinal: 0x8
  struct _WNF_SILODRIVERSTATE WnfSiloState;     // offset: 0x390 ordinal: 0x9
  struct _DBGK_SILOSTATE DbgkSiloState;         // offset: 0x3c8 ordinal: 0xa
  struct _UNICODE_STRING
      PsProtectedCurrentDirectory;               // offset: 0x3e8 ordinal: 0xb
  struct _UNICODE_STRING PsProtectedEnvironment; // offset: 0x3f8 ordinal: 0xc
  VOID *ApiSetSection;                           // offset: 0x408 ordinal: 0xd
  VOID *ApiSetSchema;                            // offset: 0x410 ordinal: 0xe
  UCHAR OneCoreForwardersEnabled;                // offset: 0x418 ordinal: 0xf
  struct _NLS_STATE *NlsState;                   // offset: 0x420 ordinal: 0x10
  struct _RTL_NLS_STATE RtlNlsState;             // offset: 0x428 ordinal: 0x11
  VOID *ImgFileExecOptions;                      // offset: 0x4e0 ordinal: 0x12
  struct _EX_TIMEZONE_STATE *ExTimeZoneState;    // offset: 0x4e8 ordinal: 0x13
  struct _UNICODE_STRING NtSystemRoot;           // offset: 0x4f0 ordinal: 0x14
  struct _UNICODE_STRING SiloRootDirectoryName;  // offset: 0x500 ordinal: 0x15
  struct _PSP_STORAGE *Storage;                  // offset: 0x510 ordinal: 0x16
  enum _SERVERSILO_STATE State;                  // offset: 0x518 ordinal: 0x17
  LONG ExitStatus;                               // offset: 0x51c ordinal: 0x18
  struct _KEVENT *DeleteEvent;                   // offset: 0x520 ordinal: 0x19
  struct _SILO_USER_SHARED_DATA *UserSharedData; // offset: 0x528 ordinal: 0x1a
  VOID *UserSharedSection;                       // offset: 0x530 ordinal: 0x1b
  struct _WORK_QUEUE_ITEM TerminateWorkItem;     // offset: 0x538 ordinal: 0x1c
  UCHAR IsDownlevelContainer;                    // offset: 0x558 ordinal: 0x1d
} _ESERVERSILO_GLOBALS;

// 0x1238 bytes (sizeof)
typedef struct _ETW_SILODRIVERSTATE {
  struct _EJOB *Silo;                       // offset: 0x0 ordinal: 0x0
  struct _ESERVERSILO_GLOBALS *SiloGlobals; // offset: 0x8 ordinal: 0x1
  ULONG MaxLoggers;                         // offset: 0x10 ordinal: 0x2
  struct _ETW_GUID_ENTRY
      EtwpSecurityProviderGuidEntry; // offset: 0x18 ordinal: 0x3
  struct _EX_RUNDOWN_REF_CACHE_AWARE *
      *EtwpLoggerRundown;                         // offset: 0x1c0 ordinal: 0x4
  struct _WMI_LOGGER_CONTEXT **EtwpLoggerContext; // offset: 0x1c8 ordinal: 0x5
  struct _ETW_HASH_BUCKET EtwpGuidHashTable[64];  // offset: 0x1d0 ordinal: 0x6
  USHORT EtwpSecurityLoggers[8];                  // offset: 0xfd0 ordinal: 0x7
  UCHAR EtwpSecurityProviderEnableMask;           // offset: 0xfe0 ordinal: 0x8
  LONG EtwpShutdownInProgress;                    // offset: 0xfe4 ordinal: 0x9
  ULONG EtwpSecurityProviderPID;                  // offset: 0xfe8 ordinal: 0xa
  struct _ETW_PRIV_HANDLE_DEMUX_TABLE
      PrivHandleDemuxTable;                 // offset: 0xff0 ordinal: 0xb
  WCHAR *RTBacklogFileRoot;                 // offset: 0x1010 ordinal: 0xc
  struct _ETW_COUNTERS EtwpCounters;        // offset: 0x1018 ordinal: 0xd
  union _LARGE_INTEGER LogfileBytesWritten; // offset: 0x1028 ordinal: 0xe
  struct _ETW_SILO_TRACING_BLOCK
      *ProcessorBlocks; // offset: 0x1030 ordinal: 0xf
  struct _EX_WNF_SUBSCRIPTION
      *ContainerStateWnfSubscription;           // offset: 0x1038 ordinal: 0x10
  ULONG ContainerStateWnfCallbackCalled;        // offset: 0x1040 ordinal: 0x11
  struct _WORK_QUEUE_ITEM *UnsubscribeWorkItem; // offset: 0x1048 ordinal: 0x12
  struct _GUID PartitionId;                     // offset: 0x1050 ordinal: 0x13
  struct _GUID ParentId;                        // offset: 0x1060 ordinal: 0x14
  union _LARGE_INTEGER QpcOffsetFromRoot;       // offset: 0x1070 ordinal: 0x15
  CHAR *PartitionName;                          // offset: 0x1078 ordinal: 0x16
  USHORT PartitionNameSize;                     // offset: 0x1080 ordinal: 0x17
  USHORT UnusedPadding;                         // offset: 0x1082 ordinal: 0x18
  ULONG PartitionType;                          // offset: 0x1084 ordinal: 0x19
  struct _ETW_SYSTEM_LOGGER_SETTINGS
      SystemLoggerSettings;            // offset: 0x1088 ordinal: 0x1a
  struct _KMUTANT EtwpStartTraceMutex; // offset: 0x1200 ordinal: 0x1b
} _ETW_SILODRIVERSTATE;

// 0x710 bytes (sizeof)
typedef struct _EJOB {
  struct _KEVENT Event;                           // offset: 0x0 ordinal: 0x0
  struct _LIST_ENTRY JobLinks;                    // offset: 0x18 ordinal: 0x1
  struct _LIST_ENTRY ProcessListHead;             // offset: 0x28 ordinal: 0x2
  struct _ERESOURCE JobLock;                      // offset: 0x38 ordinal: 0x3
  union _LARGE_INTEGER TotalUserTime;             // offset: 0xa0 ordinal: 0x4
  union _LARGE_INTEGER TotalKernelTime;           // offset: 0xa8 ordinal: 0x5
  union _LARGE_INTEGER TotalCycleTime;            // offset: 0xb0 ordinal: 0x6
  union _LARGE_INTEGER ThisPeriodTotalUserTime;   // offset: 0xb8 ordinal: 0x7
  union _LARGE_INTEGER ThisPeriodTotalKernelTime; // offset: 0xc0 ordinal: 0x8
  ULONGLONG TotalContextSwitches;                 // offset: 0xc8 ordinal: 0x9
  ULONG TotalPageFaultCount;                      // offset: 0xd0 ordinal: 0xa
  ULONG TotalProcesses;                           // offset: 0xd4 ordinal: 0xb
  ULONG ActiveProcesses;                          // offset: 0xd8 ordinal: 0xc
  ULONG TotalTerminatedProcesses;                 // offset: 0xdc ordinal: 0xd
  union _LARGE_INTEGER PerProcessUserTimeLimit;   // offset: 0xe0 ordinal: 0xe
  union _LARGE_INTEGER PerJobUserTimeLimit;       // offset: 0xe8 ordinal: 0xf
  ULONGLONG MinimumWorkingSetSize;                // offset: 0xf0 ordinal: 0x10
  ULONGLONG MaximumWorkingSetSize;                // offset: 0xf8 ordinal: 0x11
  ULONG LimitFlags;                               // offset: 0x100 ordinal: 0x12
  ULONG ActiveProcessLimit;                       // offset: 0x104 ordinal: 0x13
  struct _KAFFINITY_EX Affinity;                  // offset: 0x108 ordinal: 0x14
  struct _JOB_ACCESS_STATE *AccessState;          // offset: 0x210 ordinal: 0x15
  VOID *AccessStateQuotaReference;                // offset: 0x218 ordinal: 0x16
  ULONG UIRestrictionsClass;                      // offset: 0x220 ordinal: 0x17
  ULONG EndOfJobTimeAction;                       // offset: 0x224 ordinal: 0x18
  VOID *CompletionPort;                           // offset: 0x228 ordinal: 0x19
  VOID *CompletionKey;                            // offset: 0x230 ordinal: 0x1a
  ULONGLONG CompletionCount;                      // offset: 0x238 ordinal: 0x1b
  ULONG SessionId;                                // offset: 0x240 ordinal: 0x1c
  ULONG SchedulingClass;                          // offset: 0x244 ordinal: 0x1d
  ULONGLONG ReadOperationCount;                   // offset: 0x248 ordinal: 0x1e
  ULONGLONG WriteOperationCount;                  // offset: 0x250 ordinal: 0x1f
  ULONGLONG OtherOperationCount;                  // offset: 0x258 ordinal: 0x20
  ULONGLONG ReadTransferCount;                    // offset: 0x260 ordinal: 0x21
  ULONGLONG WriteTransferCount;                   // offset: 0x268 ordinal: 0x22
  ULONGLONG OtherTransferCount;                   // offset: 0x270 ordinal: 0x23
  struct _PROCESS_DISK_COUNTERS DiskIoInfo;       // offset: 0x278 ordinal: 0x24
  ULONGLONG ProcessMemoryLimit;                   // offset: 0x2a0 ordinal: 0x25
  ULONGLONG JobMemoryLimit;                       // offset: 0x2a8 ordinal: 0x26
  ULONGLONG JobTotalMemoryLimit;                  // offset: 0x2b0 ordinal: 0x27
  ULONGLONG PeakProcessMemoryUsed;                // offset: 0x2b8 ordinal: 0x28
  ULONGLONG PeakJobMemoryUsed;                    // offset: 0x2c0 ordinal: 0x29
  struct _KAFFINITY_EX EffectiveAffinity;         // offset: 0x2c8 ordinal: 0x2a
  union _LARGE_INTEGER
      EffectivePerProcessUserTimeLimit;         // offset: 0x3d0 ordinal: 0x2b
  ULONGLONG EffectiveMinimumWorkingSetSize;     // offset: 0x3d8 ordinal: 0x2c
  ULONGLONG EffectiveMaximumWorkingSetSize;     // offset: 0x3e0 ordinal: 0x2d
  ULONGLONG EffectiveProcessMemoryLimit;        // offset: 0x3e8 ordinal: 0x2e
  struct _EJOB *EffectiveProcessMemoryLimitJob; // offset: 0x3f0 ordinal: 0x2f
  struct _EJOB
      *EffectivePerProcessUserTimeLimitJob;  // offset: 0x3f8 ordinal: 0x30
  struct _EJOB *EffectiveNetIoRateLimitJob;  // offset: 0x400 ordinal: 0x31
  struct _EJOB *EffectiveHeapAttributionJob; // offset: 0x408 ordinal: 0x32
  ULONG EffectiveLimitFlags;                 // offset: 0x410 ordinal: 0x33
  ULONG EffectiveSchedulingClass;            // offset: 0x414 ordinal: 0x34
  ULONG EffectiveFreezeCount;                // offset: 0x418 ordinal: 0x35
  ULONG EffectiveBackgroundCount;            // offset: 0x41c ordinal: 0x36
  ULONG EffectiveSwapCount;                  // offset: 0x420 ordinal: 0x37
  ULONG EffectiveNotificationLimitCount;     // offset: 0x424 ordinal: 0x38
  ULONG EffectiveIoPriorityLimit;            // offset: 0x428 ordinal: 0x39
  ULONG IoPriorityLimit;                     // offset: 0x42c ordinal: 0x3a
  ULONG EffectivePagePriorityLimit;          // offset: 0x430 ordinal: 0x3b
  ULONG PagePriorityLimit;                   // offset: 0x434 ordinal: 0x3c
  UCHAR EffectivePriorityClass;              // offset: 0x438 ordinal: 0x3d
  UCHAR PriorityClass;                       // offset: 0x439 ordinal: 0x3e
  UCHAR NestingDepth;                        // offset: 0x43a ordinal: 0x3f
  UCHAR Reserved1[1];                        // offset: 0x43b ordinal: 0x40
  ULONG CompletionFilter;                    // offset: 0x43c ordinal: 0x41
  union {
    struct _WNF_STATE_NAME WakeChannel;       // offset: 0x440 ordinal: 0x42
    struct _PS_JOB_WAKE_INFORMATION WakeInfo; // offset: 0x440 ordinal: 0x43
  };
  struct _JOBOBJECT_WAKE_FILTER WakeFilter; // offset: 0x488 ordinal: 0x44
  ULONG LowEdgeLatchFilter;                 // offset: 0x490 ordinal: 0x45
  struct _EJOB *NotificationLink;           // offset: 0x498 ordinal: 0x46
  ULONGLONG CurrentJobMemoryUsed;           // offset: 0x4a0 ordinal: 0x47
  struct _JOB_NOTIFICATION_INFORMATION
      *NotificationInfo;                // offset: 0x4a8 ordinal: 0x48
  VOID *NotificationInfoQuotaReference; // offset: 0x4b0 ordinal: 0x49
  struct _IO_MINI_COMPLETION_PACKET_USER
      *NotificationPacket;                      // offset: 0x4b8 ordinal: 0x4a
  struct _JOB_CPU_RATE_CONTROL *CpuRateControl; // offset: 0x4c0 ordinal: 0x4b
  VOID *EffectiveSchedulingGroup;               // offset: 0x4c8 ordinal: 0x4c
  ULONGLONG ReadyTime;                          // offset: 0x4d0 ordinal: 0x4d
  struct _EX_PUSH_LOCK MemoryLimitsLock;        // offset: 0x4d8 ordinal: 0x4e
  struct _LIST_ENTRY SiblingJobLinks;           // offset: 0x4e0 ordinal: 0x4f
  struct _LIST_ENTRY ChildJobListHead;          // offset: 0x4f0 ordinal: 0x50
  struct _EJOB *ParentJob;                      // offset: 0x500 ordinal: 0x51
  struct _EJOB *RootJob;                        // offset: 0x508 ordinal: 0x52
  struct _LIST_ENTRY IteratorListHead;          // offset: 0x510 ordinal: 0x53
  ULONGLONG AncestorCount;                      // offset: 0x520 ordinal: 0x54
  union {
    struct _EJOB **Ancestors; // offset: 0x528 ordinal: 0x55
    VOID *SessionObject;      // offset: 0x528 ordinal: 0x56
  };
  struct _EPROCESS_VALUES Accounting;             // offset: 0x530 ordinal: 0x57
  ULONG ShadowActiveProcessCount;                 // offset: 0x598 ordinal: 0x58
  ULONG ActiveAuxiliaryProcessCount;              // offset: 0x59c ordinal: 0x59
  ULONG SequenceNumber;                           // offset: 0x5a0 ordinal: 0x5a
  ULONG JobId;                                    // offset: 0x5a4 ordinal: 0x5b
  struct _GUID ContainerId;                       // offset: 0x5a8 ordinal: 0x5c
  struct _GUID ContainerTelemetryId;              // offset: 0x5b8 ordinal: 0x5d
  struct _ESERVERSILO_GLOBALS *ServerSiloGlobals; // offset: 0x5c8 ordinal: 0x5e
  struct _PS_PROPERTY_SET PropertySet;            // offset: 0x5d0 ordinal: 0x5f
  struct _PSP_STORAGE *Storage;                   // offset: 0x5e8 ordinal: 0x60
  struct _JOB_NET_RATE_CONTROL *NetRateControl;   // offset: 0x5f0 ordinal: 0x61
  union {
    ULONG JobFlags;      // offset: 0x5f8 ordinal: 0x62
    ULONG CloseDone : 1; // offset: 0x5f8 ordinal: 0x63
  };
  ULONG MultiGroup : 1;                    // offset: 0x5f8 ordinal: 0x64
  ULONG OutstandingNotification : 1;       // offset: 0x5f8 ordinal: 0x65
  ULONG NotificationInProgress : 1;        // offset: 0x5f8 ordinal: 0x66
  ULONG UILimits : 1;                      // offset: 0x5f8 ordinal: 0x67
  ULONG CpuRateControlActive : 1;          // offset: 0x5f8 ordinal: 0x68
  ULONG OwnCpuRateControl : 1;             // offset: 0x5f8 ordinal: 0x69
  ULONG Terminating : 1;                   // offset: 0x5f8 ordinal: 0x6a
  ULONG WorkingSetLock : 1;                // offset: 0x5f8 ordinal: 0x6b
  ULONG JobFrozen : 1;                     // offset: 0x5f8 ordinal: 0x6c
  ULONG Background : 1;                    // offset: 0x5f8 ordinal: 0x6d
  ULONG WakeNotificationAllocated : 1;     // offset: 0x5f8 ordinal: 0x6e
  ULONG WakeNotificationEnabled : 1;       // offset: 0x5f8 ordinal: 0x6f
  ULONG WakeNotificationPending : 1;       // offset: 0x5f8 ordinal: 0x70
  ULONG LimitNotificationRequired : 1;     // offset: 0x5f8 ordinal: 0x71
  ULONG ZeroCountNotificationRequired : 1; // offset: 0x5f8 ordinal: 0x72
  ULONG CycleTimeNotificationRequired : 1; // offset: 0x5f8 ordinal: 0x73
  ULONG CycleTimeNotificationPending : 1;  // offset: 0x5f8 ordinal: 0x74
  ULONG TimersVirtualized : 1;             // offset: 0x5f8 ordinal: 0x75
  ULONG JobSwapped : 1;                    // offset: 0x5f8 ordinal: 0x76
  ULONG ViolationDetected : 1;             // offset: 0x5f8 ordinal: 0x77
  ULONG EmptyJobNotified : 1;              // offset: 0x5f8 ordinal: 0x78
  ULONG NoSystemCharge : 1;                // offset: 0x5f8 ordinal: 0x79
  ULONG DropNoWakeCharges : 1;             // offset: 0x5f8 ordinal: 0x7a
  ULONG NoWakeChargePolicyDecided : 1;     // offset: 0x5f8 ordinal: 0x7b
  ULONG NetRateControlActive : 1;          // offset: 0x5f8 ordinal: 0x7c
  ULONG OwnNetRateControl : 1;             // offset: 0x5f8 ordinal: 0x7d
  ULONG IoRateControlActive : 1;           // offset: 0x5f8 ordinal: 0x7e
  ULONG OwnIoRateControl : 1;              // offset: 0x5f8 ordinal: 0x7f
  ULONG DisallowNewProcesses : 1;          // offset: 0x5f8 ordinal: 0x80
  ULONG Silo : 1;                          // offset: 0x5f8 ordinal: 0x81
  ULONG ContainerTelemetryIdSet : 1;       // offset: 0x5f8 ordinal: 0x82
  union {
    ULONG JobFlags2;        // offset: 0x5fc ordinal: 0x83
    ULONG ParentLocked : 1; // offset: 0x5fc ordinal: 0x84
  };
  ULONG
  EnableUsermodeSiloThreadImpersonation : 1; // offset: 0x5fc ordinal: 0x85
  ULONG DisallowUsermodeSiloThreadImpersonation : 1; // offset: 0x5fc ordinal:
                                                     // 0x86
  struct _PROCESS_EXTENDED_ENERGY_VALUES
      *EnergyValues;                   // offset: 0x600 ordinal: 0x87
  ULONGLONG SharedCommitCharge;        // offset: 0x608 ordinal: 0x88
  ULONG DiskIoAttributionUserRefCount; // offset: 0x610 ordinal: 0x89
  ULONG DiskIoAttributionRefCount;     // offset: 0x614 ordinal: 0x8a
  union {
    VOID *DiskIoAttributionContext;          // offset: 0x618 ordinal: 0x8b
    struct _EJOB *DiskIoAttributionOwnerJob; // offset: 0x618 ordinal: 0x8c
  };
  struct _JOB_RATE_CONTROL_HEADER
      IoRateControlHeader;                     // offset: 0x620 ordinal: 0x8d
  struct _PS_IO_CONTROL_ENTRY GlobalIoControl; // offset: 0x648 ordinal: 0x8e
  LONG IoControlStateLock;                     // offset: 0x680 ordinal: 0x8f
  struct _RTL_RB_TREE VolumeIoControlTree;     // offset: 0x688 ordinal: 0x90
  ULONGLONG IoRateOverQuotaHistory;            // offset: 0x698 ordinal: 0x91
  ULONG IoRateCurrentGeneration;               // offset: 0x6a0 ordinal: 0x92
  ULONG IoRateLastQueryGeneration;             // offset: 0x6a4 ordinal: 0x93
  ULONG IoRateGenerationLength;                // offset: 0x6a8 ordinal: 0x94
  ULONG IoRateOverQuotaNotifySequenceId;       // offset: 0x6ac ordinal: 0x95
  ULONGLONG LastThrottledIoTime;               // offset: 0x6b0 ordinal: 0x96
  struct _EX_PUSH_LOCK IoControlLock;          // offset: 0x6b8 ordinal: 0x97
  LONGLONG SiloHardReferenceCount;             // offset: 0x6c0 ordinal: 0x98
  struct _WORK_QUEUE_ITEM RundownWorkItem;     // offset: 0x6c8 ordinal: 0x99
  VOID *PartitionObject;                       // offset: 0x6e8 ordinal: 0x9a
  struct _EJOB *PartitionOwnerJob;             // offset: 0x6f0 ordinal: 0x9b
  union _JOBOBJECT_ENERGY_TRACKING_STATE
      EnergyTrackingState;  // offset: 0x6f8 ordinal: 0x9c
  ULONGLONG KernelWaitTime; // offset: 0x700 ordinal: 0x9d
  ULONGLONG UserWaitTime;   // offset: 0x708 ordinal: 0x9e
} _EJOB;

// 0x340 bytes (sizeof)
typedef struct _MM_SESSION_SPACE {
  LONG ReferenceCount;                          // offset: 0x0 ordinal: 0x0
  union __anon_172 u;                           // offset: 0x4 ordinal: 0x1
  ULONG SessionId;                              // offset: 0x8 ordinal: 0x2
  LONG ProcessReferenceToSession;               // offset: 0xc ordinal: 0x3
  struct _LIST_ENTRY ProcessList;               // offset: 0x10 ordinal: 0x4
  ULONGLONG NonPagablePages;                    // offset: 0x20 ordinal: 0x5
  ULONGLONG CommittedPages;                     // offset: 0x28 ordinal: 0x6
  VOID *SessionObject;                          // offset: 0x30 ordinal: 0x7
  VOID *SessionObjectHandle;                    // offset: 0x38 ordinal: 0x8
  struct _RTL_AVL_TREE ImageTree;               // offset: 0x40 ordinal: 0x9
  ULONG LocaleId;                               // offset: 0x48 ordinal: 0xa
  ULONG AttachCount;                            // offset: 0x4c ordinal: 0xb
  struct _KGATE AttachGate;                     // offset: 0x50 ordinal: 0xc
  struct _EPROCESS *AttachersUsingPxeCopies[2]; // offset: 0x68 ordinal: 0xd
  struct _LIST_ENTRY WsListEntry;               // offset: 0x78 ordinal: 0xe
  struct _RTL_BALANCED_NODE WsTreeEntry;        // offset: 0x88 ordinal: 0xf
  ULONGLONG CombineDomain;                      // offset: 0xa0 ordinal: 0x10
  struct _MMSUPPORT_FULL Vm;                    // offset: 0xc0 ordinal: 0x11
  struct _MMWSL_INSTANCE WorkingSetList;        // offset: 0x200 ordinal: 0x12
  struct _MMSUPPORT_AGGREGATION
      AggregateSessionWs;                        // offset: 0x240 ordinal: 0x13
  struct _MI_SESSION_DRIVER_UNLOAD DriverUnload; // offset: 0x260 ordinal: 0x14
  ULONG TopLevelPteLockBits[32];                 // offset: 0x268 ordinal: 0x15
  struct _MMPTE PageTables[1];                   // offset: 0x2e8 ordinal: 0x16
  enum _IO_SESSION_STATE IoState;                // offset: 0x2f0 ordinal: 0x17
  ULONG IoStateSequence;                         // offset: 0x2f4 ordinal: 0x18
  struct _KEVENT IoNotificationEvent;            // offset: 0x2f8 ordinal: 0x19
  struct _EJOB *ServerSilo;                      // offset: 0x310 ordinal: 0x1a
  ULONGLONG CreateTime;                          // offset: 0x318 ordinal: 0x1b
} _MM_SESSION_SPACE;

// 0x80 bytes (sizeof)
typedef struct _HANDLE_TABLE {
  ULONG NextHandleNeedingPool;        // offset: 0x0 ordinal: 0x0
  LONG ExtraInfoPages;                // offset: 0x4 ordinal: 0x1
  ULONGLONG TableCode;                // offset: 0x8 ordinal: 0x2
  struct _EPROCESS *QuotaProcess;     // offset: 0x10 ordinal: 0x3
  struct _LIST_ENTRY HandleTableList; // offset: 0x18 ordinal: 0x4
  ULONG UniqueProcessId;              // offset: 0x28 ordinal: 0x5
  union {
    ULONG Flags;          // offset: 0x2c ordinal: 0x6
    UCHAR StrictFIFO : 1; // offset: 0x2c ordinal: 0x7
  };
  UCHAR EnableHandleExceptions : 1;               // offset: 0x2c ordinal: 0x8
  UCHAR Rundown : 1;                              // offset: 0x2c ordinal: 0x9
  UCHAR Duplicated : 1;                           // offset: 0x2c ordinal: 0xa
  UCHAR RaiseUMExceptionOnInvalidHandleClose : 1; // offset: 0x2c ordinal: 0xb
  struct _EX_PUSH_LOCK HandleContentionEvent;     // offset: 0x30 ordinal: 0xc
  struct _EX_PUSH_LOCK HandleTableLock;           // offset: 0x38 ordinal: 0xd
  union {
    struct _HANDLE_TABLE_FREE_LIST FreeLists[1]; // offset: 0x40 ordinal: 0xe
    UCHAR ActualEntry[32];                       // offset: 0x40 ordinal: 0xf
  };
  struct _HANDLE_TRACE_DEBUG_INFO *DebugInfo; // offset: 0x60 ordinal: 0x10
} _HANDLE_TABLE;

// 0x30 bytes (sizeof)
typedef struct _MDL {
  struct _MDL *Next;                // offset: 0x0 ordinal: 0x0
  SHORT Size;                       // offset: 0x8 ordinal: 0x1
  SHORT MdlFlags;                   // offset: 0xa ordinal: 0x2
  USHORT AllocationProcessorNumber; // offset: 0xc ordinal: 0x3
  USHORT Reserved;                  // offset: 0xe ordinal: 0x4
  struct _EPROCESS *Process;        // offset: 0x10 ordinal: 0x5
  VOID *MappedSystemVa;             // offset: 0x18 ordinal: 0x6
  VOID *StartVa;                    // offset: 0x20 ordinal: 0x7
  ULONG ByteCount;                  // offset: 0x28 ordinal: 0x8
  ULONG ByteOffset;                 // offset: 0x2c ordinal: 0x9
} _MDL;

// 0x38 bytes (sizeof)
typedef struct __anon_2229 {
  struct _MDL Mdl;   // offset: 0x0 ordinal: 0x0
  ULONGLONG Page[1]; // offset: 0x30 ordinal: 0x1
} __anon_2229;

// 0x80 bytes (sizeof)
typedef struct _MI_PAGEFILE_TRACES {
  LONG Status;                                  // offset: 0x0 ordinal: 0x0
  UCHAR PagefileNumber;                         // offset: 0x4 ordinal: 0x1
  UCHAR Priority;                               // offset: 0x5 ordinal: 0x2
  UCHAR IrpPriority;                            // offset: 0x6 ordinal: 0x3
  UCHAR ReservationWrite;                       // offset: 0x7 ordinal: 0x4
  union _LARGE_INTEGER CurrentTime;             // offset: 0x8 ordinal: 0x5
  ULONGLONG AvailablePages;                     // offset: 0x10 ordinal: 0x6
  ULONGLONG ModifiedPagesTotal;                 // offset: 0x18 ordinal: 0x7
  ULONGLONG ModifiedPagefilePages;              // offset: 0x20 ordinal: 0x8
  ULONGLONG ModifiedNoWritePages;               // offset: 0x28 ordinal: 0x9
  ULONGLONG ModifiedPagefileNoReservationPages; // offset: 0x30 ordinal: 0xa
  ULONGLONG
  ModifiedPageFileNoReservationCompressPages; // offset: 0x38 ordinal: 0xb
  ULONGLONG ModifiedPagefileReservationPages; // offset: 0x40 ordinal: 0xc
  struct __anon_2229 MdlHack;                 // offset: 0x48 ordinal: 0xd
} _MI_PAGEFILE_TRACES;

// 0x1380 bytes (sizeof)
typedef struct _MI_VISIBLE_PARTITION {
  ULONGLONG LowestPhysicalPage;              // offset: 0x0 ordinal: 0x0
  ULONGLONG HighestPhysicalPage;             // offset: 0x8 ordinal: 0x1
  ULONGLONG NumberOfPhysicalPages;           // offset: 0x10 ordinal: 0x2
  ULONG NumberOfPagingFiles;                 // offset: 0x18 ordinal: 0x3
  UCHAR SystemCacheInitialized;              // offset: 0x1c ordinal: 0x4
  struct _MMPAGING_FILE *PagingFile[16];     // offset: 0x20 ordinal: 0x5
  ULONGLONG AvailablePages;                  // offset: 0xc0 ordinal: 0x6
  ULONGLONG ResidentAvailablePages;          // offset: 0x100 ordinal: 0x7
  struct _MMSUPPORT_INSTANCE PartitionWs[1]; // offset: 0x140 ordinal: 0x8
  struct _MMWSL_INSTANCE
      PartitionWorkingSetLists[1];                // offset: 0x200 ordinal: 0x9
  ULONGLONG TotalCommittedPages;                  // offset: 0x228 ordinal: 0xa
  struct _MMPFNLIST ModifiedPageListHead;         // offset: 0x240 ordinal: 0xb
  struct _MMPFNLIST ModifiedNoWritePageListHead;  // offset: 0x2c0 ordinal: 0xc
  ULONGLONG TotalCommitLimit;                     // offset: 0x318 ordinal: 0xd
  ULONGLONG TotalPagesForPagingFile;              // offset: 0x320 ordinal: 0xe
  ULONGLONG VadPhysicalPages;                     // offset: 0x328 ordinal: 0xf
  ULONGLONG ProcessLockedFilePages;               // offset: 0x330 ordinal: 0x10
  ULONGLONG SharedCommit;                         // offset: 0x338 ordinal: 0x11
  ULONGLONG SlabAllocatorPages;                   // offset: 0x340 ordinal: 0x12
  ULONGLONG SlabAllocatorPagesUncharged;          // offset: 0x348 ordinal: 0x13
  ULONGLONG BootSlabPages;                        // offset: 0x350 ordinal: 0x14
  ULONGLONG SecureKernelPagesFromNonChargedSlabs; // offset: 0x358 ordinal: 0x15
  ULONGLONG KernelShadowStackPages;               // offset: 0x360 ordinal: 0x16
  ULONG ChargeCommitmentFailures[4];              // offset: 0x368 ordinal: 0x17
  LONG PageFileTraceIndex;                        // offset: 0x378 ordinal: 0x18
  struct _MI_PAGEFILE_TRACES PageFileTraces[32];  // offset: 0x380 ordinal: 0x19
} _MI_VISIBLE_PARTITION;

// 0x5600 bytes (sizeof)
typedef struct _MI_PARTITION {
  struct _MI_PARTITION_CORE Core;                // offset: 0x0 ordinal: 0x0
  struct _MI_PARTITION_MODWRITES Modwriter;      // offset: 0x1e0 ordinal: 0x1
  struct _MI_PARTITION_STORES Store;             // offset: 0x4a0 ordinal: 0x2
  struct _MI_PARTITION_SEGMENTS Segments;        // offset: 0x580 ordinal: 0x3
  struct _MI_PARTITION_PAGE_LISTS PageLists;     // offset: 0x9c0 ordinal: 0x4
  struct _MI_PARTITION_COMMIT Commit;            // offset: 0x4000 ordinal: 0x5
  struct _MI_PARTITION_ZEROING Zeroing;          // offset: 0x4040 ordinal: 0x6
  struct _MI_PAGE_COMBINING_SUPPORT PageCombine; // offset: 0x4088 ordinal: 0x7
  VOID *WorkingSetControl;                       // offset: 0x4218 ordinal: 0x8
  struct _MMWORKING_SET_EXPANSION_HEAD
      WorkingSetExpansionHead; // offset: 0x4220 ordinal: 0x9
  struct _MI_SPECIAL_PURPOSE_MEMORY_STATE
      SpecialPurposeMemory;               // offset: 0x4230 ordinal: 0xa
  ULONG SessionDetachTimeStamp;           // offset: 0x4268 ordinal: 0xb
  ULONGLONG LastPeriodicTelemetryLogTime; // offset: 0x4270 ordinal: 0xc
  struct _MI_VISIBLE_PARTITION Vp;        // offset: 0x4280 ordinal: 0xd
} _MI_PARTITION;

// 0xac0 bytes (sizeof)
typedef struct _MI_PARTITION_STATE {
  ULONGLONG PartitionLock;                        // offset: 0x0 ordinal: 0x0
  struct _EX_PUSH_LOCK PartitionIdLock;           // offset: 0x8 ordinal: 0x1
  ULONGLONG InitialPartitionIdBits;               // offset: 0x10 ordinal: 0x2
  struct _LIST_ENTRY PartitionList;               // offset: 0x18 ordinal: 0x3
  struct _RTL_BITMAP *PartitionIdBitmap;          // offset: 0x28 ordinal: 0x4
  struct _RTL_BITMAP InitialPartitionIdBitmap;    // offset: 0x30 ordinal: 0x5
  struct _MI_PARTITION *TempPartitionPointers[1]; // offset: 0x40 ordinal: 0x6
  struct _MI_PARTITION **Partition;               // offset: 0x48 ordinal: 0x7
  ULONGLONG TotalNodePagesInChildPartitions[64];  // offset: 0x50 ordinal: 0x8
  ULONGLONG TotalSpecialPurposeMemoryInChildPartitions[64][4]; // offset: 0x250
                                                               // ordinal: 0x9
  ULONG CrossPartitionDenials;           // offset: 0xa50 ordinal: 0xa
  UCHAR MultiplePartitionsExist;         // offset: 0xa54 ordinal: 0xb
  ULONGLONG ChildPartitionBytes;         // offset: 0xa58 ordinal: 0xc
  struct _RTL_BITMAP_EX HugeIoPfnBitMap; // offset: 0xa60 ordinal: 0xd
  struct _MI_HUGE_PFN *HugePfnDatabase;  // offset: 0xa70 ordinal: 0xe
  ULONG *HugePfnLockArray;               // offset: 0xa78 ordinal: 0xf
  ULONGLONG HugeRangesLock;              // offset: 0xa80 ordinal: 0x10
} _MI_PARTITION_STATE;

// 0x108 bytes (sizeof)
typedef struct _MI_SLAB_ALLOCATOR_CONTEXT {
  struct _RTL_RB_TREE AllocationsTree; // offset: 0x0 ordinal: 0x0
  LONG Lock;                           // offset: 0x10 ordinal: 0x1
  struct _MI_PARTITION *Partition;     // offset: 0x18 ordinal: 0x2
  struct _MI_SLAB_ALLOCATOR_ENTRY
      *SlabEntryAllocationHint; // offset: 0x20 ordinal: 0x3
  struct _MI_SLAB_ALLOCATOR_ENTRY
      *SlabEntryFreeHint;                          // offset: 0x28 ordinal: 0x4
  ULONGLONG FreePageCount;                         // offset: 0x30 ordinal: 0x5
  ULONGLONG AvailablePagesGoal;                    // offset: 0x38 ordinal: 0x6
  ULONGLONG ChargedPageCount;                      // offset: 0x40 ordinal: 0x7
  ULONGLONG SlabEntryCount;                        // offset: 0x48 ordinal: 0x8
  enum _MI_SLAB_ALLOCATOR_TYPE Type;               // offset: 0x50 ordinal: 0x9
  struct _MI_NODE_NUMBER_ZERO_BASED NumaNodeIndex; // offset: 0x54 ordinal: 0xa
  union __anon_2251 Flags;                         // offset: 0x58 ordinal: 0xb
  ULONG SlabEntriesAllocated;                      // offset: 0x5c ordinal: 0xc
  ULONG SlabEntriesDemoted;                        // offset: 0x60 ordinal: 0xd
  ULONG SlabEntriesFailedFast;                     // offset: 0x64 ordinal: 0xe
  ULONG SlabEntriesFailedSlow;                     // offset: 0x68 ordinal: 0xf
  ULONG SlabPagesFreedNonZeroed;                   // offset: 0x6c ordinal: 0x10
  struct _MMPFNLIST StandbyList;                   // offset: 0x70 ordinal: 0x11
  ULONGLONG LastReplenishTime;                     // offset: 0xc8 ordinal: 0x12
  ULONGLONG LastFailureTime;                       // offset: 0xd0 ordinal: 0x13
  struct _WORK_QUEUE_ITEM ReplenishWorkItem;       // offset: 0xd8 ordinal: 0x14
  struct _LIST_ENTRY ReplenishWaitList;            // offset: 0xf8 ordinal: 0x15
} _MI_SLAB_ALLOCATOR_CONTEXT;

// 0x120 bytes (sizeof)
typedef struct _MMPAGING_FILE {
  ULONGLONG Size;                                // offset: 0x0 ordinal: 0x0
  ULONGLONG MaximumSize;                         // offset: 0x8 ordinal: 0x1
  ULONGLONG MinimumSize;                         // offset: 0x10 ordinal: 0x2
  ULONGLONG FreeSpace;                           // offset: 0x18 ordinal: 0x3
  ULONGLONG PeakUsage;                           // offset: 0x20 ordinal: 0x4
  ULONGLONG HighestPage;                         // offset: 0x28 ordinal: 0x5
  ULONGLONG FreeReservationSpace;                // offset: 0x30 ordinal: 0x6
  struct _FILE_OBJECT *File;                     // offset: 0x38 ordinal: 0x7
  struct _MMMOD_WRITER_MDL_ENTRY **Entry;        // offset: 0x40 ordinal: 0x8
  ULONG NumberOfModWriterEntries;                // offset: 0x48 ordinal: 0x9
  union _SLIST_HEADER PfnsToFree;                // offset: 0x50 ordinal: 0xa
  struct _UNICODE_STRING PageFileName;           // offset: 0x60 ordinal: 0xb
  struct _MI_PAGING_FILE_SPACE_BITMAPS *Bitmaps; // offset: 0x70 ordinal: 0xc
  ULONG AllocationBitmapHint;                    // offset: 0x78 ordinal: 0xd
  ULONG LargestAllocationCluster;                // offset: 0x7c ordinal: 0xe
  ULONG RefreshAllocationCluster;                // offset: 0x80 ordinal: 0xf
  ULONG LastRefreshAllocationCluster;            // offset: 0x84 ordinal: 0x10
  ULONG ReservedClusterSizeAggregate;            // offset: 0x88 ordinal: 0x11
  ULONG MaximumRunLengthInBitmaps;               // offset: 0x8c ordinal: 0x12
  struct _RTL_RB_TREE BitmapsCacheLengthTree;    // offset: 0x90 ordinal: 0x13
  struct _RTL_RB_TREE BitmapsCacheLocationTree;  // offset: 0xa0 ordinal: 0x14
  struct _LIST_ENTRY BitmapsCacheFreeList;       // offset: 0xb0 ordinal: 0x15
  struct _MI_PAGEFILE_BITMAPS_CACHE_ENTRY
      *BitmapsCacheEntries; // offset: 0xc0 ordinal: 0x16
  union {
    ULONG ToBeEvictedCount; // offset: 0xc8 ordinal: 0x17
    ULONG HybridPriority;   // offset: 0xc8 ordinal: 0x18
  };
  USHORT PageFileNumber : 4;                // offset: 0xcc ordinal: 0x19
  USHORT WsSwapPagefile : 1;                // offset: 0xcc ordinal: 0x1a
  USHORT NoReservations : 1;                // offset: 0xcc ordinal: 0x1b
  USHORT VirtualStorePagefile : 1;          // offset: 0xcc ordinal: 0x1c
  USHORT SwapSupported : 1;                 // offset: 0xcc ordinal: 0x1d
  USHORT NodeInserted : 1;                  // offset: 0xcc ordinal: 0x1e
  USHORT StackNotified : 1;                 // offset: 0xcc ordinal: 0x1f
  USHORT BackedBySCM : 1;                   // offset: 0xcc ordinal: 0x20
  USHORT SpecialPurposeMemory : 1;          // offset: 0xcc ordinal: 0x21
  USHORT Spare0 : 3;                        // offset: 0xcc ordinal: 0x22
  UCHAR AdriftMdls : 1;                     // offset: 0xce ordinal: 0x23
  UCHAR Spare1 : 7;                         // offset: 0xce ordinal: 0x24
  UCHAR IgnoreReservations : 1;             // offset: 0xcf ordinal: 0x25
  UCHAR Spare2 : 7;                         // offset: 0xcf ordinal: 0x26
  ULONG PageHashPages;                      // offset: 0xd0 ordinal: 0x27
  ULONG PageHashPagesPeak;                  // offset: 0xd4 ordinal: 0x28
  struct _MI_PAGE_HASH *PageHash;           // offset: 0xd8 ordinal: 0x29
  VOID *FileHandle;                         // offset: 0xe0 ordinal: 0x2a
  LONG SpinLock;                            // offset: 0xe8 ordinal: 0x2b
  struct _RTL_AVL_TREE FlowThroughReadRoot; // offset: 0xf0 ordinal: 0x2c
  struct _MI_PARTITION *Partition;          // offset: 0xf8 ordinal: 0x2d
  union {
    struct _RTL_BALANCED_NODE FileObjectNode; // offset: 0x100 ordinal: 0x2e
    struct _RTL_RB_TREE ExtentsTree;          // offset: 0x100 ordinal: 0x2f
  };
} _MMPAGING_FILE;

// 0x38 bytes (sizeof)
typedef struct _MMINPAGE_SUPPORT_FLOW_THROUGH {
  ULONGLONG Page[1];                              // offset: 0x0 ordinal: 0x0
  struct _MMINPAGE_SUPPORT *InitialInPageSupport; // offset: 0x8 ordinal: 0x1
  struct _MMPAGING_FILE *PagingFile;              // offset: 0x10 ordinal: 0x2
  ULONGLONG PageFileOffset;                       // offset: 0x18 ordinal: 0x3
  struct _RTL_BALANCED_NODE Node;                 // offset: 0x20 ordinal: 0x4
} _MMINPAGE_SUPPORT_FLOW_THROUGH;

// 0x1c0 bytes (sizeof)
typedef struct _MMINPAGE_SUPPORT {
  union {
    struct _LIST_ENTRY ListEntry;   // offset: 0x0 ordinal: 0x0
    struct _SLIST_ENTRY SListEntry; // offset: 0x0 ordinal: 0x1
  };
  struct _LIST_ENTRY ListHead;      // offset: 0x10 ordinal: 0x2
  struct _KEVENT Event;             // offset: 0x20 ordinal: 0x3
  struct _KEVENT CollidedEvent;     // offset: 0x38 ordinal: 0x4
  struct _IO_STATUS_BLOCK IoStatus; // offset: 0x50 ordinal: 0x5
  union _LARGE_INTEGER ReadOffset;  // offset: 0x60 ordinal: 0x6
  union __anon_3688 u2;             // offset: 0x68 ordinal: 0x7
  struct _ETHREAD *Thread;          // offset: 0x98 ordinal: 0x8
  struct _MMPFN *LockedProtoPfn;    // offset: 0xa0 ordinal: 0x9
  struct _MMPTE PteContents;        // offset: 0xa8 ordinal: 0xa
  LONG WaitCount;                   // offset: 0xb0 ordinal: 0xb
  LONG InjectRetry;                 // offset: 0xb4 ordinal: 0xc
  ULONG ByteCount;                  // offset: 0xb8 ordinal: 0xd
  union __anon_3689 u3;             // offset: 0xbc ordinal: 0xe
  union __anon_3690 u1;             // offset: 0xc0 ordinal: 0xf
  union {
    struct _FILE_OBJECT *FilePointer;  // offset: 0xc8 ordinal: 0x10
    struct _MMPAGING_FILE *PagingFile; // offset: 0xc8 ordinal: 0x11
  };
  struct _SUBSECTION *Subsection; // offset: 0xd0 ordinal: 0x12
  VOID *AutoBoostLock;            // offset: 0xd8 ordinal: 0x13
  VOID *FaultingAddress;          // offset: 0xe0 ordinal: 0x14
  struct _MMPTE *PointerPte;      // offset: 0xe8 ordinal: 0x15
  struct _MMPTE *BasePte;         // offset: 0xf0 ordinal: 0x16
  struct _MMPFN *Pfn;             // offset: 0xf8 ordinal: 0x17
  struct _MDL *PrefetchMdl;       // offset: 0x100 ordinal: 0x18
  LONGLONG ProbeCount;            // offset: 0x108 ordinal: 0x19
  struct _MDL Mdl;                // offset: 0x110 ordinal: 0x1a
  union {
    ULONGLONG Page[16]; // offset: 0x140 ordinal: 0x1b
    struct _MMINPAGE_SUPPORT_FLOW_THROUGH
        FlowThrough; // offset: 0x140 ordinal: 0x1c
  };
} _MMINPAGE_SUPPORT;

// 0xb0 bytes (sizeof)
typedef struct _MI_PAGING_IO_STATE {
  struct _RTL_AVL_TREE PageFileHead; // offset: 0x0 ordinal: 0x0
  LONG PageFileHeadSpinLock;         // offset: 0x8 ordinal: 0x1
  struct _MI_PAGEFILE_METADATA_LAYOUT
      PageFileMetadata;                          // offset: 0xc ordinal: 0x2
  LONG PrefetchSeekThreshold;                    // offset: 0x14 ordinal: 0x3
  ULONG InPageSinglePages;                       // offset: 0x18 ordinal: 0x4
  union _SLIST_HEADER InPageSupportSListHead[2]; // offset: 0x20 ordinal: 0x5
  union _SLIST_HEADER
      ReservedInPageSupportSListHead[2]; // offset: 0x40 ordinal: 0x6
  UCHAR InPageSupportSListMinimum[2];    // offset: 0x60 ordinal: 0x7
  struct _MMINPAGE_SUPPORT
      *FirstReservedInPageBlock[2]; // offset: 0x68 ordinal: 0x8
  struct _MMINPAGE_SUPPORT
      *LastReservedInPageBlock[2];    // offset: 0x78 ordinal: 0x9
  struct _MMPTE *ReservedPtes;        // offset: 0x88 ordinal: 0xa
  ULONGLONG ReservedPtesLock;         // offset: 0x90 ordinal: 0xb
  ULONG ReservedPtesBitBuffer;        // offset: 0x98 ordinal: 0xc
  LONG DelayPageFaults;               // offset: 0x9c ordinal: 0xd
  ULONG FileCompressionBoundary;      // offset: 0xa0 ordinal: 0xe
  UCHAR MdlsAdjusted;                 // offset: 0xa4 ordinal: 0xf
  struct _MMPTE *FileOnlyReservePtes; // offset: 0xa8 ordinal: 0x10
} _MI_PAGING_IO_STATE;

// 0x5040 bytes (sizeof)
typedef struct _MI_SYSTEM_INFORMATION {
  struct _MI_POOL_STATE Pools;                 // offset: 0x0 ordinal: 0x0
  struct _MI_SECTION_STATE Sections;           // offset: 0xc0 ordinal: 0x1
  struct _MI_SYSTEM_IMAGE_STATE SystemImages;  // offset: 0x440 ordinal: 0x2
  struct _MI_SESSION_STATE Sessions;           // offset: 0x550 ordinal: 0x3
  struct _MI_PROCESS_STATE Processes;          // offset: 0x580 ordinal: 0x4
  struct _MI_HARDWARE_STATE Hardware;          // offset: 0x600 ordinal: 0x5
  struct _MI_SYSTEM_VA_STATE SystemVa;         // offset: 0x1780 ordinal: 0x6
  struct _MI_COMBINE_STATE PageCombines;       // offset: 0x1c80 ordinal: 0x7
  struct _MI_PAGELIST_STATE PageLists;         // offset: 0x1ca0 ordinal: 0x8
  struct _MI_PARTITION_STATE Partitions;       // offset: 0x1dc0 ordinal: 0x9
  struct _MI_SHUTDOWN_STATE Shutdowns;         // offset: 0x2880 ordinal: 0xa
  struct _MI_ERROR_STATE Errors;               // offset: 0x28f8 ordinal: 0xb
  struct _MI_ACCESS_LOG_STATE AccessLog;       // offset: 0x2a00 ordinal: 0xc
  struct _MI_DEBUGGER_STATE Debugger;          // offset: 0x2a80 ordinal: 0xd
  struct _MI_STANDBY_STATE Standby;            // offset: 0x2ba0 ordinal: 0xe
  struct _MI_SYSTEM_PTE_STATE SystemPtes;      // offset: 0x2d40 ordinal: 0xf
  struct _MI_IO_PAGE_STATE IoPages;            // offset: 0x3fc0 ordinal: 0x10
  struct _MI_PAGING_IO_STATE PagingIo;         // offset: 0x4080 ordinal: 0x11
  struct _MI_COMMON_PAGE_STATE CommonPages;    // offset: 0x4130 ordinal: 0x12
  struct _MI_SYSTEM_TRIM_STATE Trims;          // offset: 0x4200 ordinal: 0x13
  struct _MI_SYSTEM_ACCELERATORS Accelerators; // offset: 0x4240 ordinal: 0x14
  struct _MI_HOT_PATCH_STATE HotPatch;         // offset: 0x4268 ordinal: 0x15
  struct _MI_ENCLAVE_STATE Enclaves;           // offset: 0x42c8 ordinal: 0x16
  ULONGLONG Cookie;                            // offset: 0x4310 ordinal: 0x17
  VOID **BootRegistryRuns;                     // offset: 0x4318 ordinal: 0x18
  LONG ZeroingDisabled;                        // offset: 0x4320 ordinal: 0x19
  UCHAR FullyInitialized;                      // offset: 0x4324 ordinal: 0x1a
  UCHAR SafeBooted;                            // offset: 0x4325 ordinal: 0x1b
  struct _tlgProvider_t *TraceLogging;         // offset: 0x4328 ordinal: 0x1c
  struct _MI_VISIBLE_STATE Vs;                 // offset: 0x4340 ordinal: 0x1d
} _MI_SYSTEM_INFORMATION;

// 0x108 bytes (sizeof)
typedef struct _MMMOD_WRITER_MDL_ENTRY {
  struct _LIST_ENTRY Links;             // offset: 0x0 ordinal: 0x0
  union __anon_2277 u;                  // offset: 0x10 ordinal: 0x1
  struct _IRP *Irp;                     // offset: 0x20 ordinal: 0x2
  struct _MODWRITER_FLAGS u1;           // offset: 0x28 ordinal: 0x3
  ULONG StoreWriteRefCount;             // offset: 0x2c ordinal: 0x4
  struct _KAPC StoreWriteCompletionApc; // offset: 0x30 ordinal: 0x5
  ULONG ByteCount;                      // offset: 0x88 ordinal: 0x6
  ULONG ChargedPages;                   // offset: 0x8c ordinal: 0x7
  struct _MMPAGING_FILE *PagingFile;    // offset: 0x90 ordinal: 0x8
  struct _FILE_OBJECT *File;            // offset: 0x98 ordinal: 0x9
  struct _CONTROL_AREA *ControlArea;    // offset: 0xa0 ordinal: 0xa
  struct _ERESOURCE *FileResource;      // offset: 0xa8 ordinal: 0xb
  union _LARGE_INTEGER WriteOffset;     // offset: 0xb0 ordinal: 0xc
  union _LARGE_INTEGER IssueTime;       // offset: 0xb8 ordinal: 0xd
  struct _MI_PARTITION *Partition;      // offset: 0xc0 ordinal: 0xe
  struct _MDL *PointerMdl;              // offset: 0xc8 ordinal: 0xf
  struct _MDL Mdl;                      // offset: 0xd0 ordinal: 0x10
  ULONGLONG Page[1];                    // offset: 0x100 ordinal: 0x11
} _MMMOD_WRITER_MDL_ENTRY;

// 0x6340 bytes (sizeof)
typedef struct _MI_NODE_INFORMATION {
  struct _MI_FREE_LARGE_PAGES FreeLargePages[3]; // offset: 0x0 ordinal: 0x0
  struct _MI_REBUILD_LARGE_PAGE_TIMER
      LargePageRebuildTimer;               // offset: 0xc90 ordinal: 0x1
  struct _MMPFNLIST StandbyPageList[4][8]; // offset: 0xcb8 ordinal: 0x2
  struct _MI_STANDBY_LOOKASIDE
      StandbyPageCachePerChannel[4][8]; // offset: 0x17c0 ordinal: 0x3
  struct _RTL_BITMAP_EX
      FreePageListHeadsBitmap[3][2];           // offset: 0x57c0 ordinal: 0x4
  ULONGLONG FreePageListHeadsBitmapBuffer[24]; // offset: 0x5820 ordinal: 0x5
  ULONGLONG FreeCount[2];                      // offset: 0x58e0 ordinal: 0x6
  ULONGLONG FreeZeroCountByAttribute[4];       // offset: 0x58f0 ordinal: 0x7
  ULONGLONG TotalPages[4];                     // offset: 0x5910 ordinal: 0x8
  ULONGLONG TotalPagesEntireNode;              // offset: 0x5930 ordinal: 0x9
  struct _MI_PARTITION *Partition;             // offset: 0x5938 ordinal: 0xa
  ULONG CurrentHugeRangeColor;                 // offset: 0x5940 ordinal: 0xb
  ULONGLONG TotalHugeIoPages;                  // offset: 0x5948 ordinal: 0xc
  ULONGLONG HugeIoRangeFreeCount[2][4];        // offset: 0x5950 ordinal: 0xd
  ULONG MmShiftedColor;                        // offset: 0x5990 ordinal: 0xe
  ULONG Color;                                 // offset: 0x5994 ordinal: 0xf
  ULONGLONG ChannelFreeCount[4][2];            // offset: 0x5998 ordinal: 0x10
  struct __anon_2217 Flags;                    // offset: 0x59d8 ordinal: 0x11
  ULONG LargeListMoveInProgress;               // offset: 0x59dc ordinal: 0x12
  struct _MI_LARGE_PAGE_LISTS_CHANGING
      *LargeListWaiters;                 // offset: 0x59e0 ordinal: 0x13
  LONG NodeLock;                         // offset: 0x59e8 ordinal: 0x14
  ULONGLONG ZeroThreadHugeMapLock;       // offset: 0x59f0 ordinal: 0x15
  UCHAR ChannelStatus;                   // offset: 0x59f8 ordinal: 0x16
  UCHAR ChannelOrdering[4];              // offset: 0x59f9 ordinal: 0x17
  UCHAR LockedChannelOrdering[4];        // offset: 0x59fd ordinal: 0x18
  UCHAR PowerAttribute[4];               // offset: 0x5a01 ordinal: 0x19
  LONG LargePageLock;                    // offset: 0x5a40 ordinal: 0x1a
  ULONGLONG ScrubResumePage;             // offset: 0x5a48 ordinal: 0x1b
  struct _MI_PAGE_COLORS PageColorTable; // offset: 0x5a50 ordinal: 0x1c
  ULONGLONG NumberOfPagesGoingBad;       // offset: 0x5a60 ordinal: 0x1d
  VOID *BootZeroContext;                 // offset: 0x5a68 ordinal: 0x1e
  VOID *ZeroingContext;                  // offset: 0x5a70 ordinal: 0x1f
  LONG ZeroContextLock;                  // offset: 0x5a78 ordinal: 0x20
  VOID *ZeroThreadConductor;             // offset: 0x5a80 ordinal: 0x21
  UCHAR BackgroundZeroingActive;         // offset: 0x5a88 ordinal: 0x22
  struct _PHYSICAL_MEMORY_DESCRIPTOR
      *ZeroingPhysicalMemoryBlock; // offset: 0x5a90 ordinal: 0x23
  struct _CACHED_KSTACK_LIST
      CachedKernelStacks[3]; // offset: 0x5aa0 ordinal: 0x24
  struct _CACHED_KSTACK_LIST
      CachedKernelShadowStackLists[3]; // offset: 0x5b00 ordinal: 0x25
  struct _MI_SLAB_ALLOCATOR_CONTEXT
      SlabContexts[7]; // offset: 0x5b60 ordinal: 0x26
  struct _MI_SLAB_ALLOCATOR_CONTEXT
      *FreePageSlabContextHint;               // offset: 0x6298 ordinal: 0x27
  ULONGLONG MdlSlabFragmentionLastDemoteTime; // offset: 0x62a0 ordinal: 0x28
  struct _MMPFNLIST EnclavePageListHead;      // offset: 0x62c0 ordinal: 0x29
} _MI_NODE_INFORMATION;

// 0x20 bytes (sizeof)
typedef struct _MMCLONE_HEADER {
  ULONGLONG NumberOfPtes;              // offset: 0x0 ordinal: 0x0
  ULONGLONG NumberOfProcessReferences; // offset: 0x8 ordinal: 0x1
  struct _MMCLONE_BLOCK *ClonePtes;    // offset: 0x10 ordinal: 0x2
  struct _MI_PARTITION *Partition;     // offset: 0x18 ordinal: 0x3
} _MMCLONE_HEADER;

// 0x70 bytes (sizeof)
typedef struct _MMCLONE_DESCRIPTOR {
  union {
    struct _RTL_BALANCED_NODE CloneNode; // offset: 0x0 ordinal: 0x0
    struct _MMCLONE_DESCRIPTOR *Next;    // offset: 0x0 ordinal: 0x1
  };
  struct _MMCLONE_BLOCK *StartingCloneBlock; // offset: 0x18 ordinal: 0x2
  struct _MMCLONE_BLOCK *EndingCloneBlock;   // offset: 0x20 ordinal: 0x3
  ULONGLONG NumberOfPtes;                    // offset: 0x28 ordinal: 0x4
  ULONGLONG NumberOfReferences;              // offset: 0x30 ordinal: 0x5
  struct _MMCLONE_HEADER *CloneHeader;       // offset: 0x38 ordinal: 0x6
  ULONGLONG NonPagedPoolQuotaCharge;         // offset: 0x40 ordinal: 0x7
  struct _SLIST_ENTRY DeleteList;            // offset: 0x50 ordinal: 0x8
  ULONGLONG NestingLevel;                    // offset: 0x60 ordinal: 0x9
} _MMCLONE_DESCRIPTOR;

// 0x10 bytes (sizeof)
typedef struct LIST_ENTRY64 {
  ULONGLONG Flink; // offset: 0x0 ordinal: 0x0
  ULONGLONG Blink; // offset: 0x8 ordinal: 0x1
} LIST_ENTRY64;

// 0x7d0 bytes (sizeof)
typedef struct _PEB64 {
  UCHAR InheritedAddressSpace;    // offset: 0x0 ordinal: 0x0
  UCHAR ReadImageFileExecOptions; // offset: 0x1 ordinal: 0x1
  UCHAR BeingDebugged;            // offset: 0x2 ordinal: 0x2
  union {
    UCHAR BitField;                // offset: 0x3 ordinal: 0x3
    UCHAR ImageUsesLargePages : 1; // offset: 0x3 ordinal: 0x4
  };
  UCHAR IsProtectedProcess : 1;           // offset: 0x3 ordinal: 0x5
  UCHAR IsImageDynamicallyRelocated : 1;  // offset: 0x3 ordinal: 0x6
  UCHAR SkipPatchingUser32Forwarders : 1; // offset: 0x3 ordinal: 0x7
  UCHAR IsPackagedProcess : 1;            // offset: 0x3 ordinal: 0x8
  UCHAR IsAppContainer : 1;               // offset: 0x3 ordinal: 0x9
  UCHAR IsProtectedProcessLight : 1;      // offset: 0x3 ordinal: 0xa
  UCHAR IsLongPathAwareProcess : 1;       // offset: 0x3 ordinal: 0xb
  UCHAR Padding0[4];                      // offset: 0x4 ordinal: 0xc
  ULONGLONG Mutant;                       // offset: 0x8 ordinal: 0xd
  ULONGLONG ImageBaseAddress;             // offset: 0x10 ordinal: 0xe
  ULONGLONG Ldr;                          // offset: 0x18 ordinal: 0xf
  ULONGLONG ProcessParameters;            // offset: 0x20 ordinal: 0x10
  ULONGLONG SubSystemData;                // offset: 0x28 ordinal: 0x11
  ULONGLONG ProcessHeap;                  // offset: 0x30 ordinal: 0x12
  ULONGLONG FastPebLock;                  // offset: 0x38 ordinal: 0x13
  ULONGLONG AtlThunkSListPtr;             // offset: 0x40 ordinal: 0x14
  ULONGLONG IFEOKey;                      // offset: 0x48 ordinal: 0x15
  union {
    ULONG CrossProcessFlags; // offset: 0x50 ordinal: 0x16
    ULONG ProcessInJob : 1;  // offset: 0x50 ordinal: 0x17
  };
  ULONG ProcessInitializing : 1;        // offset: 0x50 ordinal: 0x18
  ULONG ProcessUsingVEH : 1;            // offset: 0x50 ordinal: 0x19
  ULONG ProcessUsingVCH : 1;            // offset: 0x50 ordinal: 0x1a
  ULONG ProcessUsingFTH : 1;            // offset: 0x50 ordinal: 0x1b
  ULONG ProcessPreviouslyThrottled : 1; // offset: 0x50 ordinal: 0x1c
  ULONG ProcessCurrentlyThrottled : 1;  // offset: 0x50 ordinal: 0x1d
  ULONG ProcessImagesHotPatched : 1;    // offset: 0x50 ordinal: 0x1e
  ULONG ReservedBits0 : 24;             // offset: 0x50 ordinal: 0x1f
  UCHAR Padding1[4];                    // offset: 0x54 ordinal: 0x20
  union {
    ULONGLONG KernelCallbackTable; // offset: 0x58 ordinal: 0x21
    ULONGLONG UserSharedInfoPtr;   // offset: 0x58 ordinal: 0x22
  };
  ULONG SystemReserved;                         // offset: 0x60 ordinal: 0x23
  ULONG AtlThunkSListPtr32;                     // offset: 0x64 ordinal: 0x24
  ULONGLONG ApiSetMap;                          // offset: 0x68 ordinal: 0x25
  ULONG TlsExpansionCounter;                    // offset: 0x70 ordinal: 0x26
  UCHAR Padding2[4];                            // offset: 0x74 ordinal: 0x27
  ULONGLONG TlsBitmap;                          // offset: 0x78 ordinal: 0x28
  ULONG TlsBitmapBits[2];                       // offset: 0x80 ordinal: 0x29
  ULONGLONG ReadOnlySharedMemoryBase;           // offset: 0x88 ordinal: 0x2a
  ULONGLONG SharedData;                         // offset: 0x90 ordinal: 0x2b
  ULONGLONG ReadOnlyStaticServerData;           // offset: 0x98 ordinal: 0x2c
  ULONGLONG AnsiCodePageData;                   // offset: 0xa0 ordinal: 0x2d
  ULONGLONG OemCodePageData;                    // offset: 0xa8 ordinal: 0x2e
  ULONGLONG UnicodeCaseTableData;               // offset: 0xb0 ordinal: 0x2f
  ULONG NumberOfProcessors;                     // offset: 0xb8 ordinal: 0x30
  ULONG NtGlobalFlag;                           // offset: 0xbc ordinal: 0x31
  union _LARGE_INTEGER CriticalSectionTimeout;  // offset: 0xc0 ordinal: 0x32
  ULONGLONG HeapSegmentReserve;                 // offset: 0xc8 ordinal: 0x33
  ULONGLONG HeapSegmentCommit;                  // offset: 0xd0 ordinal: 0x34
  ULONGLONG HeapDeCommitTotalFreeThreshold;     // offset: 0xd8 ordinal: 0x35
  ULONGLONG HeapDeCommitFreeBlockThreshold;     // offset: 0xe0 ordinal: 0x36
  ULONG NumberOfHeaps;                          // offset: 0xe8 ordinal: 0x37
  ULONG MaximumNumberOfHeaps;                   // offset: 0xec ordinal: 0x38
  ULONGLONG ProcessHeaps;                       // offset: 0xf0 ordinal: 0x39
  ULONGLONG GdiSharedHandleTable;               // offset: 0xf8 ordinal: 0x3a
  ULONGLONG ProcessStarterHelper;               // offset: 0x100 ordinal: 0x3b
  ULONG GdiDCAttributeList;                     // offset: 0x108 ordinal: 0x3c
  UCHAR Padding3[4];                            // offset: 0x10c ordinal: 0x3d
  ULONGLONG LoaderLock;                         // offset: 0x110 ordinal: 0x3e
  ULONG OSMajorVersion;                         // offset: 0x118 ordinal: 0x3f
  ULONG OSMinorVersion;                         // offset: 0x11c ordinal: 0x40
  USHORT OSBuildNumber;                         // offset: 0x120 ordinal: 0x41
  USHORT OSCSDVersion;                          // offset: 0x122 ordinal: 0x42
  ULONG OSPlatformId;                           // offset: 0x124 ordinal: 0x43
  ULONG ImageSubsystem;                         // offset: 0x128 ordinal: 0x44
  ULONG ImageSubsystemMajorVersion;             // offset: 0x12c ordinal: 0x45
  ULONG ImageSubsystemMinorVersion;             // offset: 0x130 ordinal: 0x46
  UCHAR Padding4[4];                            // offset: 0x134 ordinal: 0x47
  ULONGLONG ActiveProcessAffinityMask;          // offset: 0x138 ordinal: 0x48
  ULONG GdiHandleBuffer[60];                    // offset: 0x140 ordinal: 0x49
  ULONGLONG PostProcessInitRoutine;             // offset: 0x230 ordinal: 0x4a
  ULONGLONG TlsExpansionBitmap;                 // offset: 0x238 ordinal: 0x4b
  ULONG TlsExpansionBitmapBits[32];             // offset: 0x240 ordinal: 0x4c
  ULONG SessionId;                              // offset: 0x2c0 ordinal: 0x4d
  UCHAR Padding5[4];                            // offset: 0x2c4 ordinal: 0x4e
  union _ULARGE_INTEGER AppCompatFlags;         // offset: 0x2c8 ordinal: 0x4f
  union _ULARGE_INTEGER AppCompatFlagsUser;     // offset: 0x2d0 ordinal: 0x50
  ULONGLONG pShimData;                          // offset: 0x2d8 ordinal: 0x51
  ULONGLONG AppCompatInfo;                      // offset: 0x2e0 ordinal: 0x52
  struct _STRING64 CSDVersion;                  // offset: 0x2e8 ordinal: 0x53
  ULONGLONG ActivationContextData;              // offset: 0x2f8 ordinal: 0x54
  ULONGLONG ProcessAssemblyStorageMap;          // offset: 0x300 ordinal: 0x55
  ULONGLONG SystemDefaultActivationContextData; // offset: 0x308 ordinal: 0x56
  ULONGLONG SystemAssemblyStorageMap;           // offset: 0x310 ordinal: 0x57
  ULONGLONG MinimumStackCommit;                 // offset: 0x318 ordinal: 0x58
  ULONGLONG SparePointers[2];                   // offset: 0x320 ordinal: 0x59
  ULONGLONG PatchLoaderData;                    // offset: 0x330 ordinal: 0x5a
  ULONGLONG ChpeV2ProcessInfo;                  // offset: 0x338 ordinal: 0x5b
  ULONG AppModelFeatureState;                   // offset: 0x340 ordinal: 0x5c
  ULONG SpareUlongs[2];                         // offset: 0x344 ordinal: 0x5d
  USHORT ActiveCodePage;                        // offset: 0x34c ordinal: 0x5e
  USHORT OemCodePage;                           // offset: 0x34e ordinal: 0x5f
  USHORT UseCaseMapping;                        // offset: 0x350 ordinal: 0x60
  USHORT UnusedNlsField;                        // offset: 0x352 ordinal: 0x61
  ULONGLONG WerRegistrationData;                // offset: 0x358 ordinal: 0x62
  ULONGLONG WerShipAssertPtr;                   // offset: 0x360 ordinal: 0x63
  ULONGLONG EcCodeBitMap;                       // offset: 0x368 ordinal: 0x64
  ULONGLONG pImageHeaderHash;                   // offset: 0x370 ordinal: 0x65
  union {
    ULONG TracingFlags;           // offset: 0x378 ordinal: 0x66
    ULONG HeapTracingEnabled : 1; // offset: 0x378 ordinal: 0x67
  };
  ULONG CritSecTracingEnabled : 1;              // offset: 0x378 ordinal: 0x68
  ULONG LibLoaderTracingEnabled : 1;            // offset: 0x378 ordinal: 0x69
  ULONG SpareTracingBits : 29;                  // offset: 0x378 ordinal: 0x6a
  UCHAR Padding6[4];                            // offset: 0x37c ordinal: 0x6b
  ULONGLONG CsrServerReadOnlySharedMemoryBase;  // offset: 0x380 ordinal: 0x6c
  ULONGLONG TppWorkerpListLock;                 // offset: 0x388 ordinal: 0x6d
  struct LIST_ENTRY64 TppWorkerpList;           // offset: 0x390 ordinal: 0x6e
  ULONGLONG WaitOnAddressHashTable[128];        // offset: 0x3a0 ordinal: 0x6f
  ULONGLONG TelemetryCoverageHeader;            // offset: 0x7a0 ordinal: 0x70
  ULONG CloudFileFlags;                         // offset: 0x7a8 ordinal: 0x71
  ULONG CloudFileDiagFlags;                     // offset: 0x7ac ordinal: 0x72
  CHAR PlaceholderCompatibilityMode;            // offset: 0x7b0 ordinal: 0x73
  CHAR PlaceholderCompatibilityModeReserved[7]; // offset: 0x7b1 ordinal: 0x74
  ULONGLONG LeapSecondData;                     // offset: 0x7b8 ordinal: 0x75
  union {
    ULONG LeapSecondFlags;        // offset: 0x7c0 ordinal: 0x76
    ULONG SixtySecondEnabled : 1; // offset: 0x7c0 ordinal: 0x77
  };
  ULONG Reserved : 31;                  // offset: 0x7c0 ordinal: 0x78
  ULONG NtGlobalFlag2;                  // offset: 0x7c4 ordinal: 0x79
  ULONGLONG ExtendedFeatureDisableMask; // offset: 0x7c8 ordinal: 0x7a
} _PEB64;

// 0x28 bytes (sizeof)
typedef struct _ACTIVATION_CONTEXT_STACK64 {
  ULONGLONG ActiveFrame;              // offset: 0x0 ordinal: 0x0
  struct LIST_ENTRY64 FrameListCache; // offset: 0x8 ordinal: 0x1
  ULONG Flags;                        // offset: 0x18 ordinal: 0x2
  ULONG NextCookieSequenceNumber;     // offset: 0x1c ordinal: 0x3
  ULONG StackId;                      // offset: 0x20 ordinal: 0x4
} _ACTIVATION_CONTEXT_STACK64;

// 0x1850 bytes (sizeof)
typedef struct _TEB64 {
  struct _NT_TIB64 NtTib;              // offset: 0x0 ordinal: 0x0
  ULONGLONG EnvironmentPointer;        // offset: 0x38 ordinal: 0x1
  struct _CLIENT_ID64 ClientId;        // offset: 0x40 ordinal: 0x2
  ULONGLONG ActiveRpcHandle;           // offset: 0x50 ordinal: 0x3
  ULONGLONG ThreadLocalStoragePointer; // offset: 0x58 ordinal: 0x4
  ULONGLONG ProcessEnvironmentBlock;   // offset: 0x60 ordinal: 0x5
  ULONG LastErrorValue;                // offset: 0x68 ordinal: 0x6
  ULONG CountOfOwnedCriticalSections;  // offset: 0x6c ordinal: 0x7
  ULONGLONG CsrClientThread;           // offset: 0x70 ordinal: 0x8
  ULONGLONG Win32ThreadInfo;           // offset: 0x78 ordinal: 0x9
  ULONG User32Reserved[26];            // offset: 0x80 ordinal: 0xa
  ULONG UserReserved[5];               // offset: 0xe8 ordinal: 0xb
  ULONGLONG WOW32Reserved;             // offset: 0x100 ordinal: 0xc
  ULONG CurrentLocale;                 // offset: 0x108 ordinal: 0xd
  ULONG FpSoftwareStatusRegister;      // offset: 0x10c ordinal: 0xe
  ULONGLONG
  ReservedForDebuggerInstrumentation[16];   // offset: 0x110 ordinal: 0xf
  ULONGLONG SystemReserved1[30];            // offset: 0x190 ordinal: 0x10
  CHAR PlaceholderCompatibilityMode;        // offset: 0x280 ordinal: 0x11
  UCHAR PlaceholderHydrationAlwaysExplicit; // offset: 0x281 ordinal: 0x12
  CHAR PlaceholderReserved[10];             // offset: 0x282 ordinal: 0x13
  ULONG ProxiedProcessId;                   // offset: 0x28c ordinal: 0x14
  struct _ACTIVATION_CONTEXT_STACK64
      _ActivationStack;                        // offset: 0x290 ordinal: 0x15
  UCHAR WorkingOnBehalfTicket[8];              // offset: 0x2b8 ordinal: 0x16
  LONG ExceptionCode;                          // offset: 0x2c0 ordinal: 0x17
  UCHAR Padding0[4];                           // offset: 0x2c4 ordinal: 0x18
  ULONGLONG ActivationContextStackPointer;     // offset: 0x2c8 ordinal: 0x19
  ULONGLONG InstrumentationCallbackSp;         // offset: 0x2d0 ordinal: 0x1a
  ULONGLONG InstrumentationCallbackPreviousPc; // offset: 0x2d8 ordinal: 0x1b
  ULONGLONG InstrumentationCallbackPreviousSp; // offset: 0x2e0 ordinal: 0x1c
  ULONG TxFsContext;                           // offset: 0x2e8 ordinal: 0x1d
  UCHAR InstrumentationCallbackDisabled;       // offset: 0x2ec ordinal: 0x1e
  UCHAR UnalignedLoadStoreExceptions;          // offset: 0x2ed ordinal: 0x1f
  UCHAR Padding1[2];                           // offset: 0x2ee ordinal: 0x20
  struct _GDI_TEB_BATCH64 GdiTebBatch;         // offset: 0x2f0 ordinal: 0x21
  struct _CLIENT_ID64 RealClientId;            // offset: 0x7d8 ordinal: 0x22
  ULONGLONG GdiCachedProcessHandle;            // offset: 0x7e8 ordinal: 0x23
  ULONG GdiClientPID;                          // offset: 0x7f0 ordinal: 0x24
  ULONG GdiClientTID;                          // offset: 0x7f4 ordinal: 0x25
  ULONGLONG GdiThreadLocalInfo;                // offset: 0x7f8 ordinal: 0x26
  ULONGLONG Win32ClientInfo[62];               // offset: 0x800 ordinal: 0x27
  ULONGLONG glDispatchTable[233];              // offset: 0x9f0 ordinal: 0x28
  ULONGLONG glReserved1[29];                   // offset: 0x1138 ordinal: 0x29
  ULONGLONG glReserved2;                       // offset: 0x1220 ordinal: 0x2a
  ULONGLONG glSectionInfo;                     // offset: 0x1228 ordinal: 0x2b
  ULONGLONG glSection;                         // offset: 0x1230 ordinal: 0x2c
  ULONGLONG glTable;                           // offset: 0x1238 ordinal: 0x2d
  ULONGLONG glCurrentRC;                       // offset: 0x1240 ordinal: 0x2e
  ULONGLONG glContext;                         // offset: 0x1248 ordinal: 0x2f
  ULONG LastStatusValue;                       // offset: 0x1250 ordinal: 0x30
  UCHAR Padding2[4];                           // offset: 0x1254 ordinal: 0x31
  struct _STRING64 StaticUnicodeString;        // offset: 0x1258 ordinal: 0x32
  WCHAR StaticUnicodeBuffer[261];              // offset: 0x1268 ordinal: 0x33
  UCHAR Padding3[6];                           // offset: 0x1472 ordinal: 0x34
  ULONGLONG DeallocationStack;                 // offset: 0x1478 ordinal: 0x35
  ULONGLONG TlsSlots[64];                      // offset: 0x1480 ordinal: 0x36
  struct LIST_ENTRY64 TlsLinks;                // offset: 0x1680 ordinal: 0x37
  ULONGLONG Vdm;                               // offset: 0x1690 ordinal: 0x38
  ULONGLONG ReservedForNtRpc;                  // offset: 0x1698 ordinal: 0x39
  ULONGLONG DbgSsReserved[2];                  // offset: 0x16a0 ordinal: 0x3a
  ULONG HardErrorMode;                         // offset: 0x16b0 ordinal: 0x3b
  UCHAR Padding4[4];                           // offset: 0x16b4 ordinal: 0x3c
  ULONGLONG Instrumentation[11];               // offset: 0x16b8 ordinal: 0x3d
  struct _GUID ActivityId;                     // offset: 0x1710 ordinal: 0x3e
  ULONGLONG SubProcessTag;                     // offset: 0x1720 ordinal: 0x3f
  ULONGLONG PerflibData;                       // offset: 0x1728 ordinal: 0x40
  ULONGLONG EtwTraceData;                      // offset: 0x1730 ordinal: 0x41
  ULONGLONG WinSockData;                       // offset: 0x1738 ordinal: 0x42
  ULONG GdiBatchCount;                         // offset: 0x1740 ordinal: 0x43
  union {
    struct _PROCESSOR_NUMBER
        CurrentIdealProcessor; // offset: 0x1744 ordinal: 0x44
    ULONG IdealProcessorValue; // offset: 0x1744 ordinal: 0x45
    UCHAR ReservedPad0;        // offset: 0x1744 ordinal: 0x46
  };
  UCHAR ReservedPad1;                 // offset: 0x1745 ordinal: 0x47
  UCHAR ReservedPad2;                 // offset: 0x1746 ordinal: 0x48
  UCHAR IdealProcessor;               // offset: 0x1747 ordinal: 0x49
  ULONG GuaranteedStackBytes;         // offset: 0x1748 ordinal: 0x4a
  UCHAR Padding5[4];                  // offset: 0x174c ordinal: 0x4b
  ULONGLONG ReservedForPerf;          // offset: 0x1750 ordinal: 0x4c
  ULONGLONG ReservedForOle;           // offset: 0x1758 ordinal: 0x4d
  ULONG WaitingOnLoaderLock;          // offset: 0x1760 ordinal: 0x4e
  UCHAR Padding6[4];                  // offset: 0x1764 ordinal: 0x4f
  ULONGLONG SavedPriorityState;       // offset: 0x1768 ordinal: 0x50
  ULONGLONG ReservedForCodeCoverage;  // offset: 0x1770 ordinal: 0x51
  ULONGLONG ThreadPoolData;           // offset: 0x1778 ordinal: 0x52
  ULONGLONG TlsExpansionSlots;        // offset: 0x1780 ordinal: 0x53
  ULONGLONG ChpeV2CpuAreaInfo;        // offset: 0x1788 ordinal: 0x54
  ULONGLONG Unused;                   // offset: 0x1790 ordinal: 0x55
  ULONG MuiGeneration;                // offset: 0x1798 ordinal: 0x56
  ULONG IsImpersonating;              // offset: 0x179c ordinal: 0x57
  ULONGLONG NlsCache;                 // offset: 0x17a0 ordinal: 0x58
  ULONGLONG pShimData;                // offset: 0x17a8 ordinal: 0x59
  ULONG HeapData;                     // offset: 0x17b0 ordinal: 0x5a
  UCHAR Padding7[4];                  // offset: 0x17b4 ordinal: 0x5b
  ULONGLONG CurrentTransactionHandle; // offset: 0x17b8 ordinal: 0x5c
  ULONGLONG ActiveFrame;              // offset: 0x17c0 ordinal: 0x5d
  ULONGLONG FlsData;                  // offset: 0x17c8 ordinal: 0x5e
  ULONGLONG PreferredLanguages;       // offset: 0x17d0 ordinal: 0x5f
  ULONGLONG UserPrefLanguages;        // offset: 0x17d8 ordinal: 0x60
  ULONGLONG MergedPrefLanguages;      // offset: 0x17e0 ordinal: 0x61
  ULONG MuiImpersonation;             // offset: 0x17e8 ordinal: 0x62
  union {
    USHORT CrossTebFlags;          // offset: 0x17ec ordinal: 0x63
    USHORT SpareCrossTebBits : 16; // offset: 0x17ec ordinal: 0x64
  };
  union {
    USHORT SameTebFlags;      // offset: 0x17ee ordinal: 0x65
    USHORT SafeThunkCall : 1; // offset: 0x17ee ordinal: 0x66
  };
  USHORT InDebugPrint : 1;              // offset: 0x17ee ordinal: 0x67
  USHORT HasFiberData : 1;              // offset: 0x17ee ordinal: 0x68
  USHORT SkipThreadAttach : 1;          // offset: 0x17ee ordinal: 0x69
  USHORT WerInShipAssertCode : 1;       // offset: 0x17ee ordinal: 0x6a
  USHORT RanProcessInit : 1;            // offset: 0x17ee ordinal: 0x6b
  USHORT ClonedThread : 1;              // offset: 0x17ee ordinal: 0x6c
  USHORT SuppressDebugMsg : 1;          // offset: 0x17ee ordinal: 0x6d
  USHORT DisableUserStackWalk : 1;      // offset: 0x17ee ordinal: 0x6e
  USHORT RtlExceptionAttached : 1;      // offset: 0x17ee ordinal: 0x6f
  USHORT InitialThread : 1;             // offset: 0x17ee ordinal: 0x70
  USHORT SessionAware : 1;              // offset: 0x17ee ordinal: 0x71
  USHORT LoadOwner : 1;                 // offset: 0x17ee ordinal: 0x72
  USHORT LoaderWorker : 1;              // offset: 0x17ee ordinal: 0x73
  USHORT SkipLoaderInit : 1;            // offset: 0x17ee ordinal: 0x74
  USHORT SkipFileAPIBrokering : 1;      // offset: 0x17ee ordinal: 0x75
  ULONGLONG TxnScopeEnterCallback;      // offset: 0x17f0 ordinal: 0x76
  ULONGLONG TxnScopeExitCallback;       // offset: 0x17f8 ordinal: 0x77
  ULONGLONG TxnScopeContext;            // offset: 0x1800 ordinal: 0x78
  ULONG LockCount;                      // offset: 0x1808 ordinal: 0x79
  LONG WowTebOffset;                    // offset: 0x180c ordinal: 0x7a
  ULONGLONG ResourceRetValue;           // offset: 0x1810 ordinal: 0x7b
  ULONGLONG ReservedForWdf;             // offset: 0x1818 ordinal: 0x7c
  ULONGLONG ReservedForCrt;             // offset: 0x1820 ordinal: 0x7d
  struct _GUID EffectiveContainerId;    // offset: 0x1828 ordinal: 0x7e
  ULONGLONG LastSleepCounter;           // offset: 0x1838 ordinal: 0x7f
  ULONG SpinCallCount;                  // offset: 0x1840 ordinal: 0x80
  UCHAR Padding8[4];                    // offset: 0x1844 ordinal: 0x81
  ULONGLONG ExtendedFeatureDisableMask; // offset: 0x1848 ordinal: 0x82
} _TEB64;
