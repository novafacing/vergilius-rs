/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDRP_LOAD_CONTEXT {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ADAPTER_OBJECT {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VERIFIER_SHARED_EXPORT_THUNK {}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_TARGET_ALL_SHARED_EXPORT_THUNKS {
    #[doc = "offset: 0x0 (0)"]
    pub SharedExportThunks: *mut _VERIFIER_SHARED_EXPORT_THUNK,
    #[doc = "offset: 0x4 (4)"]
    pub PoolSharedExportThunks: *mut _VERIFIER_SHARED_EXPORT_THUNK,
    #[doc = "offset: 0x8 (8)"]
    pub OrderDependentSharedExportThunks: *mut _VERIFIER_SHARED_EXPORT_THUNK,
    #[doc = "offset: 0xc (12)"]
    pub XdvSharedExportThunks: *mut _VERIFIER_SHARED_EXPORT_THUNK,
}
impl Default for _VF_TARGET_ALL_SHARED_EXPORT_THUNKS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CALLBACK_OBJECT {}
pub type UCHAR = u8;
pub type ULONGLONG = u64;
pub type VOID = ::std::os::raw::c_void;
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PCW_INSTANCE {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PCW_BUFFER {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PCW_REGISTRATION {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTMNOTIFICATION_PACKET {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_ZERO_THREAD_CONTEXT {}
pub type USHORT = u16;
pub type ULONG = u32;
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMSECTION_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMSECTION_FLAGS {
    #[inline]
    pub fn BeingDeleted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BeingDeleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BeingCreated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BeingCreated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BeingPurged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BeingPurged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoModifiedWriting(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoModifiedWriting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FailAllIo(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FailAllIo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Image(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Image(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Based(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Based(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn File(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_File(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AttemptingDelete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AttemptingDelete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PrefetchCreated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrefetchCreated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalMemory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PhysicalMemory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageControlAreaOnRemovableMedia(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImageControlAreaOnRemovableMedia(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserve(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserve(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Commit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Commit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoChange(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoChange(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WasPurged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WasPurged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalMemory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GlobalMemory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeleteOnClose(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeleteOnClose(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FilePointerNull(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FilePointerNull(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferredNode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_PreferredNode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalOnlyPerSession(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GlobalOnlyPerSession(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserWritable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserWritable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemVaAllocated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemVaAllocated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferredFsCompressionBoundary(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreferredFsCompressionBoundary(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UsingFileExtents(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UsingFileExtents(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageSize64K(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageSize64K(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BeingDeleted: ULONG,
        BeingCreated: ULONG,
        BeingPurged: ULONG,
        NoModifiedWriting: ULONG,
        FailAllIo: ULONG,
        Image: ULONG,
        Based: ULONG,
        File: ULONG,
        AttemptingDelete: ULONG,
        PrefetchCreated: ULONG,
        PhysicalMemory: ULONG,
        ImageControlAreaOnRemovableMedia: ULONG,
        Reserve: ULONG,
        Commit: ULONG,
        NoChange: ULONG,
        WasPurged: ULONG,
        UserReference: ULONG,
        GlobalMemory: ULONG,
        DeleteOnClose: ULONG,
        FilePointerNull: ULONG,
        PreferredNode: ULONG,
        GlobalOnlyPerSession: ULONG,
        UserWritable: ULONG,
        SystemVaAllocated: ULONG,
        PreferredFsCompressionBoundary: ULONG,
        UsingFileExtents: ULONG,
        PageSize64K: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BeingDeleted: u32 = unsafe { ::std::mem::transmute(BeingDeleted) };
            BeingDeleted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BeingCreated: u32 = unsafe { ::std::mem::transmute(BeingCreated) };
            BeingCreated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BeingPurged: u32 = unsafe { ::std::mem::transmute(BeingPurged) };
            BeingPurged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoModifiedWriting: u32 = unsafe { ::std::mem::transmute(NoModifiedWriting) };
            NoModifiedWriting as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FailAllIo: u32 = unsafe { ::std::mem::transmute(FailAllIo) };
            FailAllIo as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Image: u32 = unsafe { ::std::mem::transmute(Image) };
            Image as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Based: u32 = unsafe { ::std::mem::transmute(Based) };
            Based as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let File: u32 = unsafe { ::std::mem::transmute(File) };
            File as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let AttemptingDelete: u32 = unsafe { ::std::mem::transmute(AttemptingDelete) };
            AttemptingDelete as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PrefetchCreated: u32 = unsafe { ::std::mem::transmute(PrefetchCreated) };
            PrefetchCreated as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PhysicalMemory: u32 = unsafe { ::std::mem::transmute(PhysicalMemory) };
            PhysicalMemory as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ImageControlAreaOnRemovableMedia: u32 =
                unsafe { ::std::mem::transmute(ImageControlAreaOnRemovableMedia) };
            ImageControlAreaOnRemovableMedia as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Reserve: u32 = unsafe { ::std::mem::transmute(Reserve) };
            Reserve as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Commit: u32 = unsafe { ::std::mem::transmute(Commit) };
            Commit as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let NoChange: u32 = unsafe { ::std::mem::transmute(NoChange) };
            NoChange as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WasPurged: u32 = unsafe { ::std::mem::transmute(WasPurged) };
            WasPurged as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UserReference: u32 = unsafe { ::std::mem::transmute(UserReference) };
            UserReference as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let GlobalMemory: u32 = unsafe { ::std::mem::transmute(GlobalMemory) };
            GlobalMemory as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DeleteOnClose: u32 = unsafe { ::std::mem::transmute(DeleteOnClose) };
            DeleteOnClose as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let FilePointerNull: u32 = unsafe { ::std::mem::transmute(FilePointerNull) };
            FilePointerNull as u64
        });
        __bindgen_bitfield_unit.set(20usize, 6u8, {
            let PreferredNode: u32 = unsafe { ::std::mem::transmute(PreferredNode) };
            PreferredNode as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let GlobalOnlyPerSession: u32 = unsafe { ::std::mem::transmute(GlobalOnlyPerSession) };
            GlobalOnlyPerSession as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let UserWritable: u32 = unsafe { ::std::mem::transmute(UserWritable) };
            UserWritable as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let SystemVaAllocated: u32 = unsafe { ::std::mem::transmute(SystemVaAllocated) };
            SystemVaAllocated as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let PreferredFsCompressionBoundary: u32 =
                unsafe { ::std::mem::transmute(PreferredFsCompressionBoundary) };
            PreferredFsCompressionBoundary as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let UsingFileExtents: u32 = unsafe { ::std::mem::transmute(UsingFileExtents) };
            UsingFileExtents as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let PageSize64K: u32 = unsafe { ::std::mem::transmute(PageSize64K) };
            PageSize64K as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HAL_PMC_COUNTERS {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SOFT_RESTART_CONTEXT {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EX_TIMER {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_STACK_CACHE {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_PERFECT_HASH_FUNCTION {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKP_ERROR_PORT {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_SCOPE_MAP {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CI_NGEN_PATHS {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SCSI_REQUEST_BLOCK {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOB_NET_RATE_CONTROL {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PSP_STORAGE {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOB_CPU_RATE_CONTROL {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOB_NOTIFICATION_INFORMATION {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOB_ACCESS_STATE {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PO_PROCESS_ENERGY_CONTEXT {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS_QUOTA_BLOCK {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PAGEFAULT_HISTORY {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DEVICE_NODE_IOMMU_EXTENSION {}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_ADD_RESERVED_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub ReserveDevice: *mut _DEVICE_OBJECT,
}
impl Default for _ARBITER_ADD_RESERVED_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LONGLONG = i64;
pub type SHORT = i16;
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TIME_FIELDS {
    #[doc = "offset: 0x0 (0)"]
    pub Year: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Month: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Day: SHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Hour: SHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Minute: SHORT,
    #[doc = "offset: 0xa (10)"]
    pub Second: SHORT,
    #[doc = "offset: 0xc (12)"]
    pub Milliseconds: SHORT,
    #[doc = "offset: 0xe (14)"]
    pub Weekday: SHORT,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_AVL_TREE {
    #[doc = "offset: 0x0 (0)"]
    pub Root: *mut _RTL_BALANCED_NODE,
}
impl Default for _RTL_AVL_TREE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SPLAY_LINKS {
    #[doc = "offset: 0x0 (0)"]
    pub Parent: *mut _RTL_SPLAY_LINKS,
    #[doc = "offset: 0x4 (4)"]
    pub LeftChild: *mut _RTL_SPLAY_LINKS,
    #[doc = "offset: 0x8 (8)"]
    pub RightChild: *mut _RTL_SPLAY_LINKS,
}
impl Default for _RTL_SPLAY_LINKS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CHAR = i8;
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDRP_CSLIST {
    #[doc = "offset: 0x0 (0)"]
    pub Tail: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _LDRP_CSLIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _SINGLE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_BUFFER_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub QueueTail: *mut _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub QueueEntry: _SINGLE_LIST_ENTRY,
}
impl Default for _ETW_BUFFER_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub LastEntry: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _KDPC_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLS_CALLBACK_INFO {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ASSEMBLY_STORAGE_MAP {}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
}
impl Default for _ARBITER_QUERY_ARBITRATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
}
impl Default for _ARBITER_BOOT_ALLOCATION_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Flink: *mut _LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Blink: *mut _LIST_ENTRY,
}
impl Default for _LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIAGE_PNP_DEVICE_COMPLETION_REQUEST {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceNode: *mut _TRIAGE_DEVICE_NODE,
}
impl Default for _TRIAGE_PNP_DEVICE_COMPLETION_REQUEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DELAY_ACK_FO {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub OriginalFileObject: *mut _FILE_OBJECT,
}
impl Default for _DELAY_ACK_FO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub DispatchedList: _LIST_ENTRY,
}
impl Default for _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KCB_LAYER_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub LayerListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Kcb: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0xc (12)"]
    pub LowerLayer: *mut _CM_KCB_LAYER_INFO,
    #[doc = "offset: 0x10 (16)"]
    pub UpperLayerListHead: _LIST_ENTRY,
}
impl Default for _CM_KCB_LAYER_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMWORKING_SET_EXPANSION_HEAD {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
}
impl Default for _MMWORKING_SET_EXPANSION_HEAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KWAIT_CHAIN {
    #[doc = "offset: 0x0 (0)"]
    pub Head: *mut VOID,
}
impl Default for _KWAIT_CHAIN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VI_FAULT_TRACE {
    #[doc = "offset: 0x0 (0)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0x4 (4)"]
    pub StackTrace: [*mut VOID; 8usize],
}
impl Default for _VI_FAULT_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_KE_CRITICAL_REGION_TRACE {
    #[doc = "offset: 0x0 (0)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0x4 (4)"]
    pub StackTrace: [*mut VOID; 7usize],
}
impl Default for _VF_KE_CRITICAL_REGION_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_EXTENDED_USER_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Context1: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Context2: *mut VOID,
}
impl Default for _OB_EXTENDED_USER_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_HANDLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Object: *mut VOID,
}
impl Default for _ALPC_HANDLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_RFG_PROTECTED_STACK {
    #[doc = "offset: 0x0 (0)"]
    pub ControlStackBase: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub ControlStackVad: *mut _MMVAD_SHORT,
    #[doc = "offset: 0x8 (8)"]
    pub OwnerThread: *mut VOID,
}
impl Default for _MI_RFG_PROTECTED_STACK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Port: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Key: *mut VOID,
}
impl Default for _IO_COMPLETION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECTION_OBJECT_POINTERS {
    #[doc = "offset: 0x0 (0)"]
    pub DataSectionObject: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub SharedCacheMap: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub ImageSectionObject: *mut VOID,
}
impl Default for _SECTION_OBJECT_POINTERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TERMINATION_PORT {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _TERMINATION_PORT,
    #[doc = "offset: 0x4 (4)"]
    pub Port: *mut VOID,
}
impl Default for _TERMINATION_PORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CLIENT_EXTENSION {
    #[doc = "offset: 0x0 (0)"]
    pub NextExtension: *mut _IO_CLIENT_EXTENSION,
    #[doc = "offset: 0x4 (4)"]
    pub ClientIdentificationAddress: *mut VOID,
}
impl Default for _IO_CLIENT_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_TIMER {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub TimerFlag: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub TimerList: _LIST_ENTRY,
    pub TimerRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut VOID)>,
    #[doc = "offset: 0x10 (16)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
}
impl Default for _IO_TIMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORK_QUEUE_ITEM {
    #[doc = "offset: 0x0 (0)"]
    pub List: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub WorkerRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0xc (12)"]
    pub Parameter: *mut VOID,
}
impl Default for _WORK_QUEUE_ITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_COMBINE_WORKITEM {
    #[doc = "offset: 0x0 (0)"]
    pub NextEntry: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
}
impl Default for _MI_COMBINE_WORKITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KREQUEST_PACKET {
    #[doc = "offset: 0x0 (0)"]
    pub CurrentPacket: [*mut VOID; 3usize],
    pub WorkerRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut VOID, arg4: *mut VOID),
    >,
}
impl Default for _KREQUEST_PACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAST_OWNER_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Reserved: [*mut VOID; 9usize],
}
impl Default for _FAST_OWNER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x34 (52) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_BTS_DATA_MANAGEMENT_AREA {
    #[doc = "offset: 0x0 (0)"]
    pub BTSBufferBase: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub BTSIndex: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub BTSMax: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub BTSInterruptThreshold: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub PEBSBufferBase: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub PEBSIndex: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub PEBSMax: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub PEBSInterruptThreshold: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub PEBSCounterReset: [*mut VOID; 2usize],
    #[doc = "offset: 0x28 (40)"]
    pub Reserved: [CHAR; 12usize],
}
impl Default for _VF_BTS_DATA_MANAGEMENT_AREA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_REF_TRACE {
    #[doc = "offset: 0x0 (0)"]
    pub StackTrace: [*mut VOID; 16usize],
}
impl Default for _OBJECT_REF_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLIENT_ID {
    #[doc = "offset: 0x0 (0)"]
    pub UniqueProcess: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub UniqueThread: *mut VOID,
}
impl Default for _CLIENT_ID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_CALLBACK_INSTANCE {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_CLEANUP_GROUP {}
#[doc = "0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_POOL {}
pub type LONG = i32;
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,
    CmResourceShareDeviceExclusive = 1,
    CmResourceShareDriverExclusive = 2,
    CmResourceShareShared = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_HEADER_TYPE {
    EtwHeaderTypeNative = 0,
    EtwHeaderTypeMax = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_AVAILABLE_PAGE_WAIT_TYPES {
    AvailablePagesWaitLow = 0,
    AvailablePagesWaitHigh = 1,
    AvailablePagesWaitVeryHigh = 2,
    AvailablePagesWaitMaximum = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_MODERN_SLEEP_ACTION {
    PoModernSleepActionGlobalActivatorsVeto = 0,
    PoModernSleepActionNonBlockingPhases = 1,
    PoModernSleepActionForceIdle = 2,
    PoModernSleepActionMinimalBlockingNotificationClients = 3,
    PoModernSleepActionMax = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_MIRROR_BITMAP_TYPES {
    MirrorBitmapTypeNormal = 0,
    MirrorBitmapTypeInterlocked = 1,
    MirrorBitmapTypeMaximum = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 7,
}
impl PDC_ACTIVITY_TYPE {
    pub const PdcMaxActivity: PDC_ACTIVITY_TYPE = PDC_ACTIVITY_TYPE::PdcInvalidActivity;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDC_ACTIVITY_TYPE {
    PdcNetwork = 0,
    PdcSystem = 1,
    PdcTimer = 2,
    PdcAllNetworks = 3,
    PdcInvalidActivity = 4,
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VERSION_MAJOR_V2: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VERSION_MAJOR: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_DELETED_NAME_LENGTH: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLEGAP_NAME_LENGTH: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const NATIVE_TYPE_MAX_CB: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_METHODRVA: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_EHRVA: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_BASICBLOCK: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_32BIT: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_64BIT: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_FROM_UNMANAGED: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_IL_LIBRARY;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_CALL_MOST_DERIVED: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_NATIVE_ENTRYPOINT;
}
impl ReplacesCorHdrNumericDefines {
    pub const MAX_PACKAGE_NAME: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::MAX_CLASS_NAME;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ReplacesCorHdrNumericDefines {
    COMIMAGE_FLAGS_ILONLY = 1,
    COMIMAGE_FLAGS_32BITREQUIRED = 2,
    COMIMAGE_FLAGS_IL_LIBRARY = 4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
    COMIMAGE_FLAGS_32BITPREFERRED = 131072,
    COR_VERSION_MINOR = 5,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
}
impl LSA_FOREST_TRUST_RECORD_TYPE {
    pub const ForestTrustRecordTypeLast: LSA_FOREST_TRUST_RECORD_TYPE =
        LSA_FOREST_TRUST_RECORD_TYPE::ForestTrustDomainInfo;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LSA_FOREST_TRUST_RECORD_TYPE {
    ForestTrustTopLevelName = 0,
    ForestTrustTopLevelNameEx = 1,
    ForestTrustDomainInfo = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SLEEPSTUDY_SPM_SCENARIO_CS_EXIT {
    SpmScenarioStopReasonUnspecified = 16,
    SpmScenarioStopReasonCsExit = 17,
    SpmScenarioStopReasonMax = 18,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDCCLIENTID {
    PDC_INVALID_CLIENT = 0,
    PDC_PLM_CLIENT = 1,
    PDC_NQM_CLIENT = 2,
    PDC_WNS_CLIENT = 3,
    PDC_DAM_CLIENT = 4,
    PDC_WCM_CLIENT = 5,
    PDC_NCSI_CLIENT = 7,
    PDC_DHCP_CLIENT = 8,
    PDC_TCPIP_CLIENT = 9,
    PDC_WU_CLIENT = 11,
    PDC_GP_CLIENT = 12,
    PDC_NCA_CLIENT = 14,
    PDC_BI_CLIENT = 15,
    PDC_MSCHED_CLIENT = 16,
    PDC_SUSPENDRESUME_CLIENT = 17,
    PDC_ACTIVATION_CLIENT = 18,
    PDC_ACTIVATION_TEST_CLIENT = 19,
    PDC_PLM_PHASE_TEST_CLIENT = 20,
    PDC_DAM_PHASE_TEST_CLIENT = 21,
    PDC_LOW_POWER_PHASE_TEST_CLIENT = 22,
    PDC_RESILIENCY_NOTIFICATION_PHASE_TEST_CLIENT = 23,
    PDC_NQM_RESILIENCY_TEST_CLIENT = 24,
    PDC_DAM_RESILIENCY_TEST_CLIENT = 25,
    PDC_DAM_KM_TEST_CLIENT = 26,
    PDC_DAM_UM_TEST_CLIENT = 27,
    PDC_SINGLETON_TEST_CLIENT = 28,
    PDC_NETWORK_SERVICE_TEST_CLIENT = 29,
    PDC_NETWORK_SERVICE2_TEST_CLIENT = 30,
    PDC_SYSTEM_SERVICE_TEST_CLIENT = 31,
    PDC_ACTIV_NOTIF_DAM_RESIL_TEST_CLIENT = 32,
    PDC_ACTIV_NOTIF_NET_RESIL_TEST_CLIENT = 33,
    PDC_SHELL_CLIENT = 34,
    PDC_MAINTENANCE_CLIENT = 35,
    PDC_SYNC_CLIENT = 36,
    PDC_IDM_CLIENT = 37,
    PDC_CORTANA_VOICE_ACTIVATION_CLIENT = 38,
    PDC_TETHERING_CLIENT = 39,
    PDC_AUDIO_CLIENT = 40,
    PDC_LOCK_SCREEN = 41,
    PDC_LREC_CLIENT = 42,
    PDC_WP_BW_CLIENT = 43,
    PDC_WP_MEDIA_STREAMING_CLIENT = 44,
    PDC_WP_MAPS_CLIENT = 46,
    PDC_WP_SYNC_CLIENT = 47,
    PDC_SETTING_SYNC_CLIENT = 48,
    PDC_WP_EDM_CLIENT = 49,
    PDC_WP_WALLET_CLIENT = 50,
    PDC_WP_LOCATION_CLIENT = 51,
    PDC_WP_CM_CLIENT = 53,
    PDC_WP_DCP_CLIENT = 54,
    PDC_WP_WIFIAUTO_CLIENT = 55,
    PDC_BITLOCKER_CLIENT = 56,
    PDC_MDM_CERTINSTALLER_CLIENT = 57,
    PDC_WP_IM_CLIENT = 58,
    PDC_WP_MMS_CLIENT = 59,
    PDC_DEVICEENROLLER_CLIENT = 60,
    PDC_WP_WIFI_SCANNING_CLIENT = 61,
    PDC_WP_OMADM_CLIENT = 62,
    PDC_WP_TELEMETRY_CHECK_CLIENT = 63,
    PDC_WP_DIS_CLIENT = 64,
    PDC_BITS_CLIENT = 65,
    PDC_WP_VOIP_EXECUTION_CLIENT = 66,
    PDC_WP_RESERVED_CLIENT3 = 67,
    PDC_SLEEP_STUDY_CLIENT = 68,
    PDC_WP_AUTOTIMEUPDATE_CLIENT = 69,
    PDC_HYPERV_CLIENT = 70,
    PDC_KM_SIGNAL_CLIENT = 71,
    PDC_UM_SIGNAL_CLIENT = 72,
    PDC_DEVICE_HEALTH_ATTESTATION_CLIENT = 73,
    PDC_XB_SYSTEM_CLIENT = 74,
    PDC_XB_HOST_CLIENT = 75,
    PDC_PRINT_JOB_MANAGER_CLIENT = 76,
    PDC_TELEMETRY_CLIENT = 77,
    PDC_ERROR_REPORTING_CLIENT = 78,
    PDC_XBOX_NTM = 79,
    PDC_CBE_CLIENT = 80,
    PDC_FIND_MY_PHONE_CLIENT = 81,
    PDC_COMMAND_CHANNEL_CLIENT = 82,
    PDC_PPM_PROFILES_CLIENT = 83,
    PDC_WIFI_CALLING_CLIENT = 84,
    PDC_WU_REBOOT_CLIENT = 85,
    PDC_SYSMAIN_CLIENT = 86,
    PDC_XBOX_UPDATE_CLIENT = 87,
    PDC_CHAT_SERVICE_CLIENT = 88,
    PDC_FIND_MY_DEVICE_CLIENT = 89,
    PDC_NOTIFICATION_FORWARDING_AND_ACTION_CLIENT = 90,
    PDC_INSTALL_AGENT_CLIENT = 91,
    PDC_XBOX_WAKE_ON_VOICE = 92,
    PDC_PLM_AUDIO_CLIENT = 93,
    PDC_WP_BCKAUDIO_CLIENT = 94,
    PDC_WAKE_ON_LAN_CLIENT = 95,
    PDC_WP_CLOUD_MESSAGING_CLIENT = 96,
    PDC_DATA_MIGRATION_MANAGER = 97,
    PDC_EVENT_SOUND_MANAGER_CLIENT = 98,
    PDC_WWAN_DORMANCY_HINT_CLIENT = 99,
    PDC_HAM_CLIENT = 100,
    PDC_NUMBER_OF_CLIENTS = 101,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_TERMINATE_REQUEST_REASON {
    ProcessTerminateRequestReasonNone = 0,
    ProcessTerminateCommitFail = 1,
    ProcessTerminateWriteToExecuteMemory = 2,
    ProcessTerminateAttachedWriteToExecuteMemory = 3,
    ProcessTerminateRequestReasonMax = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ConnectionResourceConsumerDesc {
    ConnectionResourceConsumerDescIsUndefined = 0,
    ConnectionResourceConsumerDescIsDevice = 1,
    ConnectionResourceConsumerDescIsOpregion = 2,
    ConnectionResourceConsumerDescMax = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_VAD_ALLOCATION_CELL_TYPE {
    MiVadBottomUp = 0,
    MiVadStackPebTeb = 1,
    MiVadAllocationCellMaximum = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PPM_PERF_QOS_DISABLE_REASON {
    PpmPerfQosDisableInternal = 0,
    PpmPerfQosDisableNoProfile = 1,
    PpmPerfQosDisableNoPolicy = 2,
    PpmPerfQosDisableInsufficientPolicy = 3,
    PpmPerfQosDisableMaxOverride = 4,
    PpmPerfQosDisableLowLatency = 5,
    PpmPerfQosDisableSmtScheduler = 6,
    PpmPerfQosDisableNoHardwareSupport = 7,
    PpmPerfQosDisableGroupPolicy = 8,
    PpmPerfQosDisableMax = 9,
}
impl _HV_EXT_EPF_MODE {
    pub const HvExtEpfModeNt: _HV_EXT_EPF_MODE = _HV_EXT_EPF_MODE::HvExtEpfModeMin;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HV_EXT_EPF_MODE {
    HvExtEpfModeMin = 0,
    HvExtEpfModeMax = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_MM_STAT {
    PerfInfoMMStatNotUsed = 0,
    PerfInfoMMStatAggregatePageCombine = 1,
    PerfInfoMMStatIterationPageCombine = 2,
    PerfInfoMMStatMax = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_PARTITION_THREAD {
    MiZeroPageThreadSlot = 0,
    MiPartitionWorkingSetManagerSlot = 1,
    MiDereferenceSegmentThreadSlot = 2,
    MiModifiedPageWriterSlot = 3,
    MiMappedPageWriterSlot = 4,
    MiNumberOfPartitionThreads = 5,
}
impl _TRACE_INFORMATION_CLASS {
    pub const AllPossibleNotifyRoutinesClass: _TRACE_INFORMATION_CLASS =
        _TRACE_INFORMATION_CLASS::TraceInformationClassReserved1;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRACE_INFORMATION_CLASS {
    TraceIdClass = 0,
    TraceHandleClass = 1,
    TraceEnableFlagsClass = 2,
    TraceEnableLevelClass = 3,
    GlobalLoggerHandleClass = 4,
    EventLoggerHandleClass = 5,
    AllLoggerHandlesClass = 6,
    TraceHandleByNameClass = 7,
    LoggerEventsLostClass = 8,
    TraceSessionSettingsClass = 9,
    LoggerEventsLoggedClass = 10,
    DiskIoNotifyRoutinesClass = 11,
    TraceInformationClassReserved1 = 12,
    FltIoNotifyRoutinesClass = 13,
    TraceInformationClassReserved2 = 14,
    WdfNotifyRoutinesClass = 15,
    MaxTraceInformationClass = 16,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_IO_PFN_TYPE {
    MiIoPfnProbes = 0,
    MiIoPfnMaps = 1,
    MiIoPfnUnmapped = 2,
    MiMaximumIoPfnType = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TlgOut_t {
    TlgOutNULL = 0,
    TlgOutNOPRINT = 1,
    TlgOutSTRING = 2,
    TlgOutBOOLEAN = 3,
    TlgOutHEX = 4,
    TlgOutPID = 5,
    TlgOutTID = 6,
    TlgOutPORT = 7,
    TlgOutIPV4 = 8,
    TlgOutIPV6 = 9,
    TlgOutSOCKETADDRESS = 10,
    TlgOutXML = 11,
    TlgOutJSON = 12,
    TlgOutWIN32ERROR = 13,
    TlgOutNTSTATUS = 14,
    TlgOutHRESULT = 15,
    TlgOutFILETIME = 16,
    TlgOutSIGNED = 17,
    TlgOutUNSIGNED = 18,
    TlgOutUTF8 = 35,
    TlgOutPKCS7_WITH_TYPE_INFO = 36,
    TlgOutCODE_POINTER = 37,
    _TlgOutMax = 38,
    _TlgOutChain = 128,
    _TlgOutTypeMask = 127,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ADD_DRIVER_STAGE {
    ClassConfigFilters = 0,
    LowerDeviceFilters = 1,
    LowerClassFilters = 2,
    DeviceService = 3,
    UpperDeviceFilters = 4,
    UpperClassFilters = 5,
    MaximumAddStage = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KPROCESS_STATE {
    ProcessInMemory = 0,
    ProcessOutOfMemory = 1,
    ProcessInTransition = 2,
    ProcessOutTransition = 3,
    ProcessInSwap = 4,
    ProcessOutSwap = 5,
    ProcessRetryOutSwap = 6,
    ProcessAllSwapStates = 7,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_VAD_64K_TYPES {
    MiVad64KPrivate = 0,
    MiVad64KShared = 1,
    MiVad64KTypes = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_CS_DEVICE_NOTIFICATION_TYPE {
    PoCsDeviceNotificationStorage = 0,
    PoCsDeviceNotificationWiFi = 1,
    PoCsDeviceNotificationMbn = 2,
    PoCsDeviceNotificationAudio = 3,
    PoCsDeviceNotificationEthernet = 4,
    PoCsDeviceNotificationMaximum = 5,
}
impl _USER_ACTIVITY_PRESENCE {
    pub const PowerUserInvalid: _USER_ACTIVITY_PRESENCE = _USER_ACTIVITY_PRESENCE::PowerUserMaximum;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent = 1,
    PowerUserInactive = 2,
    PowerUserMaximum = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POLICY_AUDIT_EVENT_TYPE {
    AuditCategorySystem = 0,
    AuditCategoryLogon = 1,
    AuditCategoryObjectAccess = 2,
    AuditCategoryPrivilegeUse = 3,
    AuditCategoryDetailedTracking = 4,
    AuditCategoryPolicyChange = 5,
    AuditCategoryAccountManagement = 6,
    AuditCategoryDirectoryServiceAccess = 7,
    AuditCategoryAccountLogon = 8,
}
impl _MI_WORKING_SET_TYPE {
    pub const MiWorkingSetTypePartitionMaximum: _MI_WORKING_SET_TYPE =
        _MI_WORKING_SET_TYPE::MiWorkingSetTypeSystemPtes;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_WORKING_SET_TYPE {
    MiWorkingSetTypeSystemCache = 0,
    MiWorkingSetTypeSystemPtes = 1,
    MiWorkingSetTypePagedPool = 2,
    MiWorkingSetTypeMaximum = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_SUBVAD_LISTS {
    MiSubVadPebTebAny = 0,
    MiSubVadRfg = 1,
    MiSubVadMaximum = 2,
}
impl _KWAIT_STATE {
    pub const WaitFirstSuspendState: _KWAIT_STATE = _KWAIT_STATE::WaitSuspendInProgress;
}
impl _KWAIT_STATE {
    pub const WaitLastSuspendState: _KWAIT_STATE = _KWAIT_STATE::WaitResumeAborted;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KWAIT_STATE {
    WaitInProgress = 0,
    WaitCommitted = 1,
    WaitAborted = 2,
    WaitSuspendInProgress = 3,
    WaitSuspended = 4,
    WaitResumeInProgress = 5,
    WaitResumeAborted = 6,
    MaximumWaitState = 7,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_GUID_TYPE {
    EtwTraceGuidType = 0,
    EtwNotificationGuidType = 1,
    EtwGroupGuidType = 2,
    EtwGuidTypeMax = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_KSTACK_TYPE {
    MiRegularKstack = 0,
    MiShortLivedKstack = 1,
    MiMaximumKstack = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WOW64_SHARED_INFORMATION {
    SharedNtdll32LdrInitializeThunk = 0,
    SharedNtdll32KiUserExceptionDispatcher = 1,
    SharedNtdll32KiUserApcDispatcher = 2,
    SharedNtdll32KiUserCallbackDispatcher = 3,
    SharedNtdll32RtlUserThreadStart = 4,
    SharedNtdll32pQueryProcessDebugInformationRemote = 5,
    SharedNtdll32BaseAddress = 6,
    SharedNtdll32LdrSystemDllInitBlock = 7,
    SharedNtdll32RtlpFreezeTimeBias = 8,
    Wow64SharedPageEntriesCount = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_HIBER_FORCE_DISABLE_REASON {
    PoHiberForceDisableReasonPolicy = 0,
    PoHiberForceDisableReasonGuardedHost = 1,
    PoHiberForceDisableReasonMax = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_NODE_NONPAGED_POOL_BITMAP {
    NonPagedPoolLargePdeNx = 0,
    NonPagedPoolSmallPde = 1,
    NonPagedPoolPerPage = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_DYNAMICBASE_BITMAP {
    DynamicBaseBitMap32 = 0,
    LastDynamicBaseBitMap = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTHREAD_STATE {
    Initialized = 0,
    Ready = 1,
    Running = 2,
    Standby = 3,
    Terminated = 4,
    Waiting = 5,
    Transition = 6,
    DeferredReady = 7,
    GateWaitObsolete = 8,
    WaitingForProcessInSwap = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TlgBlob_t {
    _TlgBlobNone = 0,
    _TlgBlobEnd = 1,
    _TlgBlobProvider = 2,
    _TlgBlobEvent3 = 3,
    _TlgBlobProvider3 = 4,
    _TlgBlobEvent2 = 5,
    _TlgBlobMax = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KPROCESS_PPM_POLICY {
    ProcessPpmDefault = 0,
    ProcessPpmThrottle = 1,
    ProcessPpmSemiThrottle = 2,
    ProcessPpmNoThrottle = 3,
    ProcessPpmWindowMinimized = 4,
    ProcessPpmWindowOccluded = 5,
    ProcessPpmWindowVisible = 6,
    ProcessPpmWindowInFocus = 7,
    MaxProcessPpmPolicy = 8,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTHREAD_PPM_POLICY {
    ThreadPpmDefault = 0,
    ThreadPpmThrottle = 1,
    ThreadPpmSemiThrottle = 2,
    ThreadPpmNoThrottle = 3,
    MaxThreadPpmPolicy = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MODE {
    KernelMode = 0,
    UserMode = 1,
    MaximumMode = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_STRING_TOKEN_TYPE {
    ETW_STRING_TOKEN_EXE = 0,
    ETW_STRING_TOKEN_PACKAGE_ID = 1,
    ETW_STRING_TOKEN_PKG_APP_ID = 2,
    ETW_STRING_TOKEN_MAX_COUNT = 3,
}
impl _WORKING_SET_TYPE {
    pub const WorkingSetTypeSystemCache: _WORKING_SET_TYPE =
        _WORKING_SET_TYPE::WorkingSetTypeSystemTypes;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WORKING_SET_TYPE {
    WorkingSetTypeUser = 0,
    WorkingSetTypeSession = 1,
    WorkingSetTypeSystemTypes = 2,
    WorkingSetTypePagedPool = 3,
    WorkingSetTypeSystemPtes = 4,
    WorkingSetTypeMaximum = 5,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_PROTECTED_SIGNER {
    PsProtectedSignerNone = 0,
    PsProtectedSignerAuthenticode = 1,
    PsProtectedSignerCodeGen = 2,
    PsProtectedSignerAntimalware = 3,
    PsProtectedSignerLsa = 4,
    PsProtectedSignerWindows = 5,
    PsProtectedSignerWinTcb = 6,
    PsProtectedSignerWinSystem = 7,
    PsProtectedSignerApp = 8,
    PsProtectedSignerMax = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_MEMORY_HIGHLOW {
    MiMemoryHigh = 0,
    MiMemoryLow = 1,
    MiMemoryHighLow = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_KERNELMEMORY_USAGE_TYPE {
    PerfInfoMemUsagePfnMetadata = 0,
    PerfInfoMemUsageMax = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_RESOURCE_TYPE {
    PsResourceNonPagedPool = 0,
    PsResourcePagedPool = 1,
    PsResourcePageFile = 2,
    PsResourceWorkingSet = 3,
    PsResourceMax = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_VA_TYPE {
    ProcessVAImage = 0,
    ProcessVASection = 1,
    ProcessVAPrivate = 2,
    ProcessVAMax = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_CFG_BITMAP_TYPE {
    CfgBitMapNative = 0,
    CfgBitMapMax = 1,
}
impl CPU_VENDORS {
    pub const CPU_CENTAUR: CPU_VENDORS = CPU_VENDORS::CPU_VIA;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CPU_VENDORS {
    CPU_NONE = 0,
    CPU_INTEL = 1,
    CPU_AMD = 2,
    CPU_CYRIX = 3,
    CPU_TRANSMETA = 4,
    CPU_VIA = 5,
    CPU_RISE = 6,
    CPU_UNKNOWN = 7,
}
impl _KTIMER2_COLLECTION_INDEX {
    pub const KTimer2CollectionMin: _KTIMER2_COLLECTION_INDEX =
        _KTIMER2_COLLECTION_INDEX::KTimer2CollectionNoWake;
}
impl _KTIMER2_COLLECTION_INDEX {
    pub const KTimer2CollectionNode1: _KTIMER2_COLLECTION_INDEX =
        _KTIMER2_COLLECTION_INDEX::KTimer2CollectionFinite;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTIMER2_COLLECTION_INDEX {
    KTimer2CollectionNoWake = 0,
    KTimer2CollectionHr = 1,
    KTimer2CollectionFinite = 2,
    KTimer2CollectionIr = 3,
    KTimer2CollectionNotInserted = 16,
    KTimer2CollectionInvalid = 20,
    KTimer2CollectionOptional = 32,
    KTimer2CollectionMax = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_PREEMPTIVE_TRIMS {
    MmPreemptForNonPaged = 0,
    MmPreemptForPaged = 1,
    MmPreemptForNonPagedPriority = 2,
    MmPreemptForPagedPriority = 3,
    MmMaximumPreempt = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_ENCLAVE_TYPE {
    MiEnclaveNone = 0,
    MiEnclaveHardware = 1,
    MiEnclaveVsm = 2,
    MiEnclaveMax = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_PERFECT_HASH_FUNCTION_TYPE {
    ETW_PHF_EVENT_ID = 0,
    ETW_PHF_STACK_WALK = 1,
    ETW_PHF_MAX_COUNT = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTHREAD_TAG {
    KThreadTagNone = 0,
    KThreadTagMediaBuffering = 1,
    KThreadTagMax = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_POOL_PRIORITIES {
    MmHighPriority = 0,
    MmNormalPriority = 1,
    MmLowPriority = 2,
    MmMaximumPoolPriority = 3,
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreDeleteKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtDeleteKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreSetValueKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtSetValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreDeleteValueKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtDeleteValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreSetInformationKey: _REG_NOTIFY_CLASS =
        _REG_NOTIFY_CLASS::RegNtSetInformationKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreRenameKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtRenameKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreEnumerateKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtEnumerateKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreEnumerateValueKey: _REG_NOTIFY_CLASS =
        _REG_NOTIFY_CLASS::RegNtEnumerateValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreQueryKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtQueryKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreQueryValueKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtQueryValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreQueryMultipleValueKey: _REG_NOTIFY_CLASS =
        _REG_NOTIFY_CLASS::RegNtQueryMultipleValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreKeyHandleClose: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtKeyHandleClose;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REG_NOTIFY_CLASS {
    RegNtDeleteKey = 0,
    RegNtSetValueKey = 1,
    RegNtDeleteValueKey = 2,
    RegNtSetInformationKey = 3,
    RegNtRenameKey = 4,
    RegNtEnumerateKey = 5,
    RegNtEnumerateValueKey = 6,
    RegNtQueryKey = 7,
    RegNtQueryValueKey = 8,
    RegNtQueryMultipleValueKey = 9,
    RegNtPreCreateKey = 10,
    RegNtPostCreateKey = 11,
    RegNtPreOpenKey = 12,
    RegNtPostOpenKey = 13,
    RegNtKeyHandleClose = 14,
    RegNtPostDeleteKey = 15,
    RegNtPostSetValueKey = 16,
    RegNtPostDeleteValueKey = 17,
    RegNtPostSetInformationKey = 18,
    RegNtPostRenameKey = 19,
    RegNtPostEnumerateKey = 20,
    RegNtPostEnumerateValueKey = 21,
    RegNtPostQueryKey = 22,
    RegNtPostQueryValueKey = 23,
    RegNtPostQueryMultipleValueKey = 24,
    RegNtPostKeyHandleClose = 25,
    RegNtPreCreateKeyEx = 26,
    RegNtPostCreateKeyEx = 27,
    RegNtPreOpenKeyEx = 28,
    RegNtPostOpenKeyEx = 29,
    RegNtPreFlushKey = 30,
    RegNtPostFlushKey = 31,
    RegNtPreLoadKey = 32,
    RegNtPostLoadKey = 33,
    RegNtPreUnLoadKey = 34,
    RegNtPostUnLoadKey = 35,
    RegNtPreQueryKeySecurity = 36,
    RegNtPostQueryKeySecurity = 37,
    RegNtPreSetKeySecurity = 38,
    RegNtPostSetKeySecurity = 39,
    RegNtCallbackObjectContextCleanup = 40,
    RegNtPreRestoreKey = 41,
    RegNtPostRestoreKey = 42,
    RegNtPreSaveKey = 43,
    RegNtPostSaveKey = 44,
    RegNtPreReplaceKey = 45,
    RegNtPostReplaceKey = 46,
    RegNtPreQueryKeyName = 47,
    RegNtPostQueryKeyName = 48,
    MaxRegNtNotifyClass = 49,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KHETERO_RUNNING_TYPE {
    KHeteroShortRunning = 0,
    KHeteroLongRunning = 1,
    KHeteroRunningTypeMax = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_WAKE_REASON {
    PsWakeReasonUser = 0,
    PsWakeReasonExecutionRequired = 1,
    PsWakeReasonKernel = 2,
    PsWakeReasonInstrumentation = 3,
    PsWakeReasonPreserveProcess = 4,
    PsWakeReasonActivityReference = 5,
    PsWakeReasonWorkOnBehalf = 6,
    PsMaxWakeReasons = 7,
}
impl TlgIn_t {
    pub const TlgInINTPTR: TlgIn_t = TlgIn_t::TlgInINT32;
}
impl TlgIn_t {
    pub const TlgInUINTPTR: TlgIn_t = TlgIn_t::TlgInUINT32;
}
impl TlgIn_t {
    pub const TlgInPOINTER: TlgIn_t = TlgIn_t::TlgInHEXINT32;
}
impl TlgIn_t {
    pub const _TlgInCountMask: TlgIn_t = TlgIn_t::_TlgInCustom;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TlgIn_t {
    TlgInNULL = 0,
    TlgInUNICODESTRING = 1,
    TlgInANSISTRING = 2,
    TlgInINT8 = 3,
    TlgInUINT8 = 4,
    TlgInINT16 = 5,
    TlgInUINT16 = 6,
    TlgInINT32 = 7,
    TlgInUINT32 = 8,
    TlgInINT64 = 9,
    TlgInUINT64 = 10,
    TlgInFLOAT = 11,
    TlgInDOUBLE = 12,
    TlgInBOOL32 = 13,
    TlgInBINARY = 14,
    TlgInGUID = 15,
    _TlgInPOINTER_unsupported = 16,
    TlgInFILETIME = 17,
    TlgInSYSTEMTIME = 18,
    TlgInSID = 19,
    TlgInHEXINT32 = 20,
    TlgInHEXINT64 = 21,
    TlgInCOUNTEDSTRING = 22,
    TlgInCOUNTEDANSISTRING = 23,
    _TlgInSTRUCT = 24,
    _TlgInMax = 25,
    _TlgInCcount = 32,
    TlgInVcount = 64,
    _TlgInChain = 128,
    _TlgInCustom = 96,
    _TlgInTypeMask = 31,
    _TlgInFlagMask = 224,
}
impl _POP_SLEEP_CHECKPOINT_STATUS {
    pub const PopSleepCheckpointStatusMax: _POP_SLEEP_CHECKPOINT_STATUS =
        _POP_SLEEP_CHECKPOINT_STATUS::PopSleepCheckpointStatusFailedOtherError;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POP_SLEEP_CHECKPOINT_STATUS {
    PopSleepCheckpointStatusDisabled = 0,
    PopSleepCheckpointStatusEnabledDueToDirtyShutdown = 1,
    PopSleepCheckpointStatusEnabledManually = 4,
    PopSleepCheckpointStatusEnabledMax = 7,
    PopSleepCheckpointStatusFailedNotEfiSystem = 8,
    PopSleepCheckpointStatusFailedInsufficientSpace = 9,
    PopSleepCheckpointStatusFailedOtherError = 15,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    GateObject = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    ProfileCallbackObject = 17,
    ApcObject = 18,
    DpcObject = 19,
    DeviceQueueObject = 20,
    PriQueueObject = 21,
    InterruptObject = 22,
    ProfileObject = 23,
    Timer2NotificationObject = 24,
    Timer2SynchronizationObject = 25,
    ThreadedDpcObject = 26,
    MaximumKernelObject = 27,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 2,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_MEMORY_EVENT_TYPES {
    LowPagedPoolEvent = 0,
    HighPagedPoolEvent = 1,
    LowNonPagedPoolEvent = 2,
    HighNonPagedPoolEvent = 3,
    LowAvailablePagesEvent = 4,
    HighAvailablePagesEvent = 5,
    LowCommitEvent = 6,
    HighCommitEvent = 7,
    MaximumCommitEvent = 8,
    BadMemoryDetectedEvent = 9,
    PhysicalMemoryChangeEvent = 10,
    TotalNumberOfMemoryEvents = 11,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POP_SLEEP_CHECKPOINT {
    PopSleepCheckpointInvalid = 0,
    PopSleepCheckpointPowerTransitionStart = 1,
    PopSleepCheckpointSuspendAppsBefore = 2,
    PopSleepCheckpointSuspendAppsAfter = 3,
    PopSleepCheckpointSuspendServicesBefore = 4,
    PopSleepCheckpointSuspendServicesAfter = 5,
    PopSleepCheckpointNotifySuperfetchBefore = 6,
    PopSleepCheckpointNotifySuperfetchAfter = 7,
    PopSleepCheckpointNotifyCallbacksBefore = 8,
    PopSleepCheckpointNotifyCallbacksAfter = 9,
    PopSleepCheckpointSleepTransactionCommitted = 10,
    PopSleepCheckpointQueryDriversBefore = 11,
    PopSleepCheckpointQueryDriversAfter = 12,
    PopSleepCheckpointAllocatingHiberContext = 13,
    PopSleepCheckpointSuspendDriversBefore = 14,
    PopSleepCheckpointPreSleepNotification = 16,
    PopSleepCheckpointInterruptsDisabledBegin = 17,
    PopSleepCheckpointInvokeHandlerBefore = 18,
    PopSleepCheckpointSaveHiberContextBegin = 19,
    PopSleepCheckpointInitializeDumpStackFailed = 20,
    PopSleepCheckpointHiberWriteFailed = 21,
    PopSleepCheckpointHiberFileTooSmall = 22,
    PopSleepCheckpointSaveHiberContextFailed = 23,
    PopSleepCheckpointSaveHiberContextEnd = 24,
    PopSleepCheckpointHiberKernelHandoff = 25,
    PopSleepCheckpointInvokeHandlerAfter = 26,
    PopSleepCheckpointReadHiberfileBefore = 27,
    PopSleepCheckpointInitializeDumpStackForReadFailed = 28,
    PopSleepCheckpointHiberReadFailed = 29,
    PopSleepCheckpointChecksumFailure = 30,
    PopSleepCheckpointDecompressionFailed = 31,
    PopSleepCheckpointReadHiberfileAfter = 32,
    PopSleepCheckpointInterruptsDisabledEnd = 33,
    PopSleepCheckpointWakeDriversAfter = 36,
    PopSleepCheckpointResumeAppsBefore = 37,
    PopSleepCheckpointResumeAppsAfter = 38,
    PopSleepCheckpointResumeServicesBefore = 39,
    PopSleepCheckpointResumeServicesAfter = 40,
    PopSleepCheckpointPowerTransitionEnd = 41,
    PopSleepCheckpointMax = 42,
}
impl _POWER_INFORMATION_LEVEL_INTERNAL {
    pub const PowerInformationInternalTtmFirst: _POWER_INFORMATION_LEVEL_INTERNAL =
        _POWER_INFORMATION_LEVEL_INTERNAL::PowerInternalTtmOpenTerminal;
}
impl _POWER_INFORMATION_LEVEL_INTERNAL {
    pub const PowerInformationInternalTtmLast: _POWER_INFORMATION_LEVEL_INTERNAL =
        _POWER_INFORMATION_LEVEL_INTERNAL::PowerInternalTtmSetDisplayTimeouts;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_INFORMATION_LEVEL_INTERNAL {
    PowerInternalAcpiInterfaceRegister = 0,
    PowerInternalS0LowPowerIdleInfo = 1,
    PowerInternalReapplyBrightnessSettings = 2,
    PowerInternalUserAbsencePrediction = 3,
    PowerInternalUserAbsencePredictionCapability = 4,
    PowerInternalPoProcessorLatencyHint = 5,
    PowerInternalStandbyNetworkRequest = 6,
    PowerInternalDirtyTransitionInformation = 7,
    PowerInternalSetBackgroundTaskState = 8,
    PowerInternalTtmOpenTerminal = 9,
    PowerInternalTtmCreateTerminal = 10,
    PowerInternalTtmEvacuateDevices = 11,
    PowerInternalTtmCreateTerminalEventQueue = 12,
    PowerInternalTtmGetTerminalEvent = 13,
    PowerInternalTtmSetDefaultDeviceAssignment = 14,
    PowerInternalTtmAssignDevice = 15,
    PowerInternalTtmSetDisplayState = 16,
    PowerInternalTtmSetDisplayTimeouts = 17,
    PowerInternalBootSessionStandbyActivationInformation = 18,
    PowerInternalSessionPowerState = 19,
    PowerInternalSessionTerminalInput = 20,
    PowerInternalSetWatchdog = 21,
    PowerInternalPhysicalPowerButtonPressInfoAtBoot = 22,
    PowerInternalExternalMonitorConnected = 23,
    PowerInternalHighPrecisionBrightnessSettings = 24,
    PowerInternalWinrtScreenToggle = 25,
    PowerInternalPpmQosDisable = 26,
    PowerInternalTransitionCheckpoint = 27,
    PowerInternalInputControllerState = 28,
    PowerInternalFirmwareResetReason = 29,
    PowerInternalPpmSchedulerQosSupport = 30,
    PowerInternalBootStatGet = 31,
    PowerInternalBootStatSet = 32,
    PowerInternalCallHasNotReturnedWatchdog = 33,
    PowerInternalBootStatCheckIntegrity = 34,
    PowerInternalBootStatRestoreDefaults = 35,
    PowerInternalHostEsStateUpdate = 36,
    PowerInternalGetPowerActionState = 37,
    PowerInternalBootStatUnlock = 38,
    PowerInternalWakeOnVoiceState = 39,
    PowerInternalDeepSleepBlock = 40,
    PowerInformationInternalMaximum = 41,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KWAIT_BLOCK_STATE {
    WaitBlockBypassStart = 0,
    WaitBlockBypassComplete = 1,
    WaitBlockSuspendBypassStart = 2,
    WaitBlockSuspendBypassComplete = 3,
    WaitBlockActive = 4,
    WaitBlockInactive = 5,
    WaitBlockSuspended = 6,
    WaitBlockAllStates = 7,
}
#[repr(i32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVPROP_OPERATOR {
    DEVPROP_OPERATOR_MODIFIER_NOT = 65536,
    DEVPROP_OPERATOR_MODIFIER_IGNORE_CASE = 131072,
    DEVPROP_OPERATOR_NONE = 0,
    DEVPROP_OPERATOR_EXISTS = 1,
    DEVPROP_OPERATOR_NOT_EXISTS = 65537,
    DEVPROP_OPERATOR_EQUALS = 2,
    DEVPROP_OPERATOR_NOT_EQUALS = 65538,
    DEVPROP_OPERATOR_GREATER_THAN = 3,
    DEVPROP_OPERATOR_LESS_THAN = 4,
    DEVPROP_OPERATOR_GREATER_THAN_EQUALS = 5,
    DEVPROP_OPERATOR_LESS_THAN_EQUALS = 6,
    DEVPROP_OPERATOR_EQUALS_IGNORE_CASE = 131074,
    DEVPROP_OPERATOR_NOT_EQUALS_IGNORE_CASE = 196610,
    DEVPROP_OPERATOR_BITWISE_AND = 7,
    DEVPROP_OPERATOR_BITWISE_OR = 8,
    DEVPROP_OPERATOR_BEGINS_WITH = 9,
    DEVPROP_OPERATOR_ENDS_WITH = 10,
    DEVPROP_OPERATOR_CONTAINS = 11,
    DEVPROP_OPERATOR_BEGINS_WITH_IGNORE_CASE = 131081,
    DEVPROP_OPERATOR_ENDS_WITH_IGNORE_CASE = 131082,
    DEVPROP_OPERATOR_CONTAINS_IGNORE_CASE = 131083,
    DEVPROP_OPERATOR_LIST_CONTAINS = 4096,
    DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH = 8192,
    DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH = 12288,
    DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS = 16384,
    DEVPROP_OPERATOR_LIST_CONTAINS_IGNORE_CASE = 135168,
    DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE = 139264,
    DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH_IGNORE_CASE = 143360,
    DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS_IGNORE_CASE = 147456,
    DEVPROP_OPERATOR_AND_OPEN = 1048576,
    DEVPROP_OPERATOR_AND_CLOSE = 2097152,
    DEVPROP_OPERATOR_OR_OPEN = 3145728,
    DEVPROP_OPERATOR_OR_CLOSE = 4194304,
    DEVPROP_OPERATOR_NOT_OPEN = 5242880,
    DEVPROP_OPERATOR_NOT_CLOSE = 6291456,
    DEVPROP_OPERATOR_ARRAY_CONTAINS = 268435456,
    DEVPROP_OPERATOR_MASK_EVAL = 4095,
    DEVPROP_OPERATOR_MASK_LIST = 61440,
    DEVPROP_OPERATOR_MASK_MODIFIER = 983040,
    DEVPROP_OPERATOR_MASK_NOT_LOGICAL = -267386881,
    DEVPROP_OPERATOR_MASK_LOGICAL = 267386880,
    DEVPROP_OPERATOR_MASK_ARRAY = -268435456,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_POOL_TYPES {
    MmNonPagedPool = 0,
    MmPagedPool = 1,
    MmSessionPagedPool = 2,
    MmMaximumPoolType = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_SECTION_TYPE {
    ProcessSectionData = 0,
    ProcessSectionImage = 1,
    ProcessSectionImageNx = 2,
    ProcessSectionPagefileBacked = 3,
    ProcessSectionMax = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_OBJECT_EXTENSION_TYPE {
    FoExtTypeTransactionParams = 0,
    FoExtTypeInternal = 1,
    FoExtTypeIosbRange = 2,
    FoExtTypeGeneric = 3,
    FoExtTypeSfio = 4,
    FoExtTypeSymlink = 5,
    FoExtTypeOplockKey = 6,
    FoExtTypeSilo = 7,
    FoExtTypeMemoryPartitionInfo = 8,
    MaxFoExtTypes = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation = 0,
    ObjectNameInformation = 1,
    ObjectTypeInformation = 2,
    ObjectTypesInformation = 3,
    ObjectHandleFlagInformation = 4,
    ObjectSessionInformation = 5,
    ObjectSessionObjectInformation = 6,
    MaxObjectInfoClass = 7,
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved1Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectFreezeInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved2Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectExtendedAccountingInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved3Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectWakeInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved4Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectBackgroundInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved5Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectSchedulingRankBiasInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved6Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectTimerVirtualizationInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved7Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectCycleTimeNotification;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved8Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectClearEvent;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved9Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectInterferenceInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved10Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectClearPeakJobMemoryUsed;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved11Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectMemoryUsageInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved12Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectSharedCommit;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved13Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectContainerId;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved14Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectIoRateControlInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved15Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectSiloRootDirectory;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved16Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectServerSiloBasicInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved17Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectServerSiloUserSharedData;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved18Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectServerSiloInitialize;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved19Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectServerSiloRunningState;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved20Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectIoAttribution;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved21Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectMemoryPartitionInformation;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved22Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectContainerTelemetryId;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved23Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectSiloSystemRoot;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved24Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectEnergyTrackingState;
}
impl _JOBOBJECTINFOCLASS {
    pub const JobObjectReserved25Information: _JOBOBJECTINFOCLASS =
        _JOBOBJECTINFOCLASS::JobObjectThreadImpersonationInformation;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation = 2,
    JobObjectBasicProcessIdList = 3,
    JobObjectBasicUIRestrictions = 4,
    JobObjectSecurityLimitInformation = 5,
    JobObjectEndOfJobTimeInformation = 6,
    JobObjectAssociateCompletionPortInformation = 7,
    JobObjectBasicAndIoAccountingInformation = 8,
    JobObjectExtendedLimitInformation = 9,
    JobObjectJobSetInformation = 10,
    JobObjectGroupInformation = 11,
    JobObjectNotificationLimitInformation = 12,
    JobObjectLimitViolationInformation = 13,
    JobObjectGroupInformationEx = 14,
    JobObjectCpuRateControlInformation = 15,
    JobObjectCompletionFilter = 16,
    JobObjectCompletionCounter = 17,
    JobObjectFreezeInformation = 18,
    JobObjectExtendedAccountingInformation = 19,
    JobObjectWakeInformation = 20,
    JobObjectBackgroundInformation = 21,
    JobObjectSchedulingRankBiasInformation = 22,
    JobObjectTimerVirtualizationInformation = 23,
    JobObjectCycleTimeNotification = 24,
    JobObjectClearEvent = 25,
    JobObjectInterferenceInformation = 26,
    JobObjectClearPeakJobMemoryUsed = 27,
    JobObjectMemoryUsageInformation = 28,
    JobObjectSharedCommit = 29,
    JobObjectContainerId = 30,
    JobObjectIoRateControlInformation = 31,
    JobObjectSiloRootDirectory = 37,
    JobObjectServerSiloBasicInformation = 38,
    JobObjectServerSiloUserSharedData = 39,
    JobObjectServerSiloInitialize = 40,
    JobObjectServerSiloRunningState = 41,
    JobObjectIoAttribution = 42,
    JobObjectMemoryPartitionInformation = 43,
    JobObjectContainerTelemetryId = 44,
    JobObjectSiloSystemRoot = 45,
    JobObjectEnergyTrackingState = 46,
    JobObjectThreadImpersonationInformation = 47,
    JobObjectNetRateControlInformation = 32,
    JobObjectNotificationLimitInformation2 = 33,
    JobObjectLimitViolationInformation2 = 34,
    JobObjectCreateSilo = 35,
    JobObjectSiloBasicInformation = 36,
    MaxJobObjectInfoClass = 48,
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeIopsCap: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeCapMin;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeCapMax: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeTimePercentCap;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeIopsReservation: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeReservationMin;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeReservationMax: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeTimePercentReservation;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeIopsCriticalReservation: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeCriticalReservationMin;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeCriticalReservationMax: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeTimePercentCriticalReservation;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeIopsSoftCap: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeSoftCapMin;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeSoftCapMax: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeTimePercentSoftCap;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeIopsLimitExcessNotify: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeLimitExcessNotifyMin;
}
impl _IO_RATE_CONTROL_TYPE {
    pub const IoRateControlTypeLimitExcessNotifyMax: _IO_RATE_CONTROL_TYPE =
        _IO_RATE_CONTROL_TYPE::IoRateControlTypeTimePercentLimitExcessNotify;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_RATE_CONTROL_TYPE {
    IoRateControlTypeCapMin = 0,
    IoRateControlTypeBandwidthCap = 1,
    IoRateControlTypeTimePercentCap = 2,
    IoRateControlTypeReservationMin = 3,
    IoRateControlTypeBandwidthReservation = 4,
    IoRateControlTypeTimePercentReservation = 5,
    IoRateControlTypeCriticalReservationMin = 6,
    IoRateControlTypeBandwidthCriticalReservation = 7,
    IoRateControlTypeTimePercentCriticalReservation = 8,
    IoRateControlTypeSoftCapMin = 9,
    IoRateControlTypeBandwidthSoftCap = 10,
    IoRateControlTypeTimePercentSoftCap = 11,
    IoRateControlTypeLimitExcessNotifyMin = 12,
    IoRateControlTypeBandwidthLimitExcessNotify = 13,
    IoRateControlTypeTimePercentLimitExcessNotify = 14,
    IoRateControlTypeMax = 15,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSFER_TYPE {
    ReadTransfer = 0,
    WriteTransfer = 1,
    OtherTransfer = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LOCK_OPERATION {
    IoReadAccess = 0,
    IoWriteAccess = 1,
    IoModifyAccess = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EX_POOL_PRIORITY {
    LowPoolPriority = 0,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrSpare0 = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    WrKeyedEvent = 21,
    WrTerminated = 22,
    WrProcessInSwap = 23,
    WrCpuRateControl = 24,
    WrCalloutStack = 25,
    WrKernel = 26,
    WrResource = 27,
    WrPushLock = 28,
    WrMutex = 29,
    WrQuantumEnd = 30,
    WrDispatchInt = 31,
    WrPreempted = 32,
    WrYieldExecution = 33,
    WrFastMutex = 34,
    WrGuardedMutex = 35,
    WrRundown = 36,
    WrAlertByThreadId = 37,
    WrDeferredPreempt = 38,
    WrPhysicalFault = 39,
    MaximumWaitReason = 40,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_FAILURE_TYPE {
    heap_failure_internal = 0,
    heap_failure_unknown = 1,
    heap_failure_generic = 2,
    heap_failure_entry_corruption = 3,
    heap_failure_multiple_entries_corruption = 4,
    heap_failure_virtual_block_corruption = 5,
    heap_failure_buffer_overrun = 6,
    heap_failure_buffer_underrun = 7,
    heap_failure_block_not_busy = 8,
    heap_failure_invalid_argument = 9,
    heap_failure_usage_after_free = 10,
    heap_failure_cross_heap_operation = 11,
    heap_failure_freelists_corruption = 12,
    heap_failure_listentry_corruption = 13,
    heap_failure_lfh_bitmap_mismatch = 14,
    heap_failure_segment_lfh_bitmap_corruption = 15,
    heap_failure_segment_lfh_double_free = 16,
    heap_failure_vs_subsegment_corruption = 17,
    heap_failure_null_heap = 18,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_REQUEST_TYPE_INTERNAL {
    PowerRequestDisplayRequiredInternal = 0,
    PowerRequestSystemRequiredInternal = 1,
    PowerRequestAwayModeRequiredInternal = 2,
    PowerRequestExecutionRequiredInternal = 3,
    PowerRequestPerfBoostRequiredInternal = 4,
    PowerRequestActiveLockScreenInternal = 5,
    PowerRequestInternalInvalid = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired = 0,
    PowerRequestSystemRequired = 1,
    PowerRequestAwayModeRequired = 2,
    PowerRequestExecutionRequired = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups = 2,
    TokenPrivileges = 3,
    TokenOwner = 4,
    TokenPrimaryGroup = 5,
    TokenDefaultDacl = 6,
    TokenSource = 7,
    TokenType = 8,
    TokenImpersonationLevel = 9,
    TokenStatistics = 10,
    TokenRestrictedSids = 11,
    TokenSessionId = 12,
    TokenGroupsAndPrivileges = 13,
    TokenSessionReference = 14,
    TokenSandBoxInert = 15,
    TokenAuditPolicy = 16,
    TokenOrigin = 17,
    TokenElevationType = 18,
    TokenLinkedToken = 19,
    TokenElevation = 20,
    TokenHasRestrictions = 21,
    TokenAccessInformation = 22,
    TokenVirtualizationAllowed = 23,
    TokenVirtualizationEnabled = 24,
    TokenIntegrityLevel = 25,
    TokenUIAccess = 26,
    TokenMandatoryPolicy = 27,
    TokenLogonSid = 28,
    TokenIsAppContainer = 29,
    TokenCapabilities = 30,
    TokenAppContainerSid = 31,
    TokenAppContainerNumber = 32,
    TokenUserClaimAttributes = 33,
    TokenDeviceClaimAttributes = 34,
    TokenRestrictedUserClaimAttributes = 35,
    TokenRestrictedDeviceClaimAttributes = 36,
    TokenDeviceGroups = 37,
    TokenRestrictedDeviceGroups = 38,
    TokenSecurityAttributes = 39,
    TokenIsRestricted = 40,
    TokenProcessTrustLevel = 41,
    TokenPrivateNameSpace = 42,
    TokenSingletonAttributes = 43,
    TokenBnoIsolation = 44,
    TokenChildProcessFlags = 45,
    MaxTokenInfoClass = 46,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IPI_TYPE {
    IpiAffinity = 0,
    IpiAllButSelf = 1,
    IpiAll = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CMP_FAILURE_INJECTION_POINT {
    CmpFailurePointPoolAllocation = 0,
    CmpFailurePointViewMapping = 1,
    CmpFailurePointViewPinning = 2,
    CmpFailurePointResourceCharging = 3,
    CmpFailurePointFileWrite = 4,
    CmpFailurePointFileRead = 5,
    CmpFailurePointCacheFlush = 6,
    CmpFailurePointFlush = 7,
    CmpFailurePointFlushAndPurge = 8,
    CmpFailurePointForceLargeBin = 9,
    CmpFailurePointDontFixAlignment = 10,
    CmpFailurePointAllocateCell = 11,
    CmpFailurePointMarkDirty = 12,
    CmpFailurePointAllocateKcb = 13,
    CmpFailurePointCreateKeyBody = 14,
    CmpFailurePointForcePoolAllocateKcb = 15,
    CmpFailurePointForceFreeKcb = 16,
    CmpFailurePointKeyEnumResumeContextVerification = 17,
    CmpFailurePointKeyEnumForceRetry = 18,
    CmpFailureInjectionPointCount = 19,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_INFO_CLASS {
    EventProviderBinaryTrackInfo = 0,
    EventProviderSetReserved1 = 1,
    EventProviderSetTraits = 2,
    EventProviderUseDescriptorType = 3,
    MaxEventInfo = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_WAKE_DEPTH {
    DeviceWakeDepthNotWakeable = 0,
    DeviceWakeDepthD0 = 1,
    DeviceWakeDepthD1 = 2,
    DeviceWakeDepthD2 = 3,
    DeviceWakeDepthD3hot = 4,
    DeviceWakeDepthD3cold = 5,
    DeviceWakeDepthMaximum = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_FILE_ACCESS_TYPE {
    PfFileAccessTypeRead = 0,
    PfFileAccessTypeWrite = 1,
    PfFileAccessTypeMax = 2,
}
#[repr(i32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6,
    MmNotMapped = -1,
}
impl _EX_GEN_RANDOM_DOMAIN {
    pub const ExGenRandomDomainFirst: _EX_GEN_RANDOM_DOMAIN =
        _EX_GEN_RANDOM_DOMAIN::ExGenRandomDomainKernel;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EX_GEN_RANDOM_DOMAIN {
    ExGenRandomDomainKernel = 0,
    ExGenRandomDomainUserVisible = 1,
    ExGenRandomDomainMax = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PP_NPAGED_LOOKASIDE_NUMBER {
    LookasideSmallIrpList = 0,
    LookasideMediumIrpList = 1,
    LookasideLargeIrpList = 2,
    LookasideMdlList = 3,
    LookasideCreateInfoList = 4,
    LookasideNameBufferList = 5,
    LookasideTwilightList = 6,
    LookasideCompletionList = 7,
    LookasideScratchBufferList = 8,
    LookasideMaximumList = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_TYPE {
    NotificationEvent = 0,
    SynchronizationEvent = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KSPIN_LOCK_QUEUE_NUMBER {
    LockQueueUnusedSpare0 = 0,
    LockQueueUnusedSpare1 = 1,
    LockQueueUnusedSpare2 = 2,
    LockQueueUnusedSpare3 = 3,
    LockQueueVacbLock = 4,
    LockQueueMasterLock = 5,
    LockQueueNonPagedPoolLock = 6,
    LockQueueIoCancelLock = 7,
    LockQueueUnusedSpare8 = 8,
    LockQueueIoVpbLock = 9,
    LockQueueIoDatabaseLock = 10,
    LockQueueIoCompletionLock = 11,
    LockQueueNtfsStructLock = 12,
    LockQueueAfdWorkQueueLock = 13,
    LockQueueBcbLock = 14,
    LockQueueUnusedSpare15 = 15,
    LockQueueUnusedSpare16 = 16,
    LockQueueMaximumLock = 17,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_MITIGATION_OPTION {
    PS_MITIGATION_OPTION_NX = 0,
    PS_MITIGATION_OPTION_SEHOP = 1,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES = 2,
    PS_MITIGATION_OPTION_HEAP_TERMINATE = 3,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR = 4,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR = 5,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS = 6,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE = 7,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE = 8,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE = 9,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD = 10,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES = 11,
    PS_MITIGATION_OPTION_FONT_DISABLE = 12,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE = 13,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL = 14,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32 = 15,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD = 16,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY = 17,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD = 18,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT = 19,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT = 20,
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK = 21,
    PS_MITIGATION_OPTION_ROP_SIMEXEC = 22,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER = 23,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS = 24,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION = 25,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER = 26,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION = 27,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SE_WS_APPX_SIGNATURE_ORIGIN {
    SE_WS_APPX_SIGNATURE_ORIGIN_NOT_VALIDATED = 0,
    SE_WS_APPX_SIGNATURE_ORIGIN_UNKNOWN = 1,
    SE_WS_APPX_SIGNATURE_ORIGIN_APPSTORE = 2,
    SE_WS_APPX_SIGNATURE_ORIGIN_WINDOWS = 3,
    SE_WS_APPX_SIGNATURE_ORIGIN_ENTERPRISE = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DMA_SPEED {
    Compatible = 0,
    TypeA = 1,
    TypeB = 2,
    TypeC = 3,
    TypeF = 4,
    MaximumDmaSpeed = 5,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DMA_WIDTH {
    Width8Bits = 0,
    Width16Bits = 1,
    Width32Bits = 2,
    Width64Bits = 3,
    WidthNoWrap = 4,
    MaximumDmaWidth = 5,
}
#[repr(i32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_DDAG_STATE {
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9,
}
#[repr(i32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_DLL_LOAD_REASON {
    LoadReasonStaticDependency = 0,
    LoadReasonStaticForwarderDependency = 1,
    LoadReasonDynamicForwarderDependency = 2,
    LoadReasonDelayloadDependency = 3,
    LoadReasonDynamicLoad = 4,
    LoadReasonAsImageLoad = 5,
    LoadReasonAsDataLoad = 6,
    LoadReasonEnclavePrimary = 7,
    LoadReasonEnclaveDependency = 8,
    LoadReasonUnknown = -1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KERNEL_STACK_LIMITS {
    BugcheckStackLimits = 0,
    DPCStackLimits = 1,
    ExpandedStackLimits = 2,
    NormalStackLimits = 3,
    Win32kStackLimits = 4,
    SwapBusyStackLimits = 5,
    IsrStackLimits = 6,
    DebuggerStackLimits = 7,
    MaximumStackLimits = 8,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DUMP_EVENTS {
    DUMP_EVENT_NONE = 0,
    DUMP_EVENT_HIBER_RESUME = 1,
    DUMP_EVENT_HIBER_RESUME_END = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POP_IO_STATUS {
    IoReady = 0,
    IoPending = 1,
    IoDone = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_POWER_CONDITION {
    PoAc = 0,
    PoDc = 1,
    PoHot = 2,
    PoConditionMaximum = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REQUESTER_TYPE {
    KernelRequester = 0,
    UserProcessRequester = 1,
    UserSharedServiceRequester = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_NOTIFICATION_TYPE {
    EtwNotificationTypeNoReply = 1,
    EtwNotificationTypeLegacyEnable = 2,
    EtwNotificationTypeEnable = 3,
    EtwNotificationTypePrivateLogger = 4,
    EtwNotificationTypePerflib = 5,
    EtwNotificationTypeAudio = 6,
    EtwNotificationTypeSession = 7,
    EtwNotificationTypeReserved = 8,
    EtwNotificationTypeCredentialUI = 9,
    EtwNotificationTypeInProcSession = 10,
    EtwNotificationTypeFilteredPrivateLogger = 11,
    EtwNotificationTypeMax = 12,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EXQUEUEINDEX {
    ExPoolUntrusted = 0,
    IoPoolUntrusted = 1,
    ExPoolMax = 8,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_DEVICE_ACTION_REQUEST {
    AssignResources = 0,
    ClearDeviceProblem = 1,
    ClearProblem = 2,
    ClearEjectProblem = 3,
    HaltDevice = 4,
    QueryPowerRelations = 5,
    Rebalance = 6,
    ReenumerateBootDevices = 7,
    ReenumerateDeviceOnly = 8,
    ReenumerateDeviceTree = 9,
    ReenumerateRootDevices = 10,
    RequeryDeviceState = 11,
    ResetDevice = 12,
    ResourceRequirementsChanged = 13,
    RestartEnumeration = 14,
    SetDeviceProblem = 15,
    StartDevice = 16,
    StartSystemDevicesPass0 = 17,
    StartSystemDevicesPass1 = 18,
    NotifyTransportRelationsChange = 19,
    NotifyEjectionRelationsChange = 20,
    ConfigureDevice = 21,
    ConfigureDeviceClass = 22,
    ConfigureDeviceExtensions = 23,
    ConfigureDeviceReset = 24,
    ClearDmaGuardProblem = 25,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_POLICY_DEVICE_TYPE {
    PolicyDeviceSystemButton = 0,
    PolicyDeviceThermalZone = 1,
    PolicyDeviceBattery = 2,
    PolicyDeviceMemory = 3,
    PolicyInitiatePowerActionAPI = 4,
    PolicySetPowerStateAPI = 5,
    PolicyImmediateDozeS4 = 6,
    PolicySystemIdle = 7,
    PolicyDeviceWakeAlarm = 8,
    PolicyDeviceFan = 9,
    PolicyCsBatterySaver = 10,
    PolicyImmediateDozeS4Predicted = 11,
    PolicyImmediateDozeS4PredictedNoWake = 12,
    PolicyImmediateDozeS4AdaptiveBudget = 13,
    PolicyImmediateDozeS4AdaptiveReserveNoWake = 14,
    PolicyDeviceMax = 15,
}
#[repr(i32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ARBITER_RESULT {
    ArbiterResultUndefined = -1,
    ArbiterResultSuccess = 0,
    ArbiterResultExternalConflict = 1,
    ArbiterResultNullRequest = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ARBITER_ACTION {
    ArbiterActionTestAllocation = 0,
    ArbiterActionRetestAllocation = 1,
    ArbiterActionCommitAllocation = 2,
    ArbiterActionRollbackAllocation = 3,
    ArbiterActionQueryAllocatedResources = 4,
    ArbiterActionWriteReservedResources = 5,
    ArbiterActionQueryConflict = 6,
    ArbiterActionQueryArbitrate = 7,
    ArbiterActionAddReserved = 8,
    ArbiterActionBootAllocation = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_PFN_CACHE_ATTRIBUTE {
    MiNonCached = 0,
    MiCached = 1,
    MiWriteCombined = 2,
    MiNotMapped = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TYPE_OF_MEMORY {
    LoaderExceptionBlock = 0,
    LoaderSystemBlock = 1,
    LoaderFree = 2,
    LoaderBad = 3,
    LoaderLoadedProgram = 4,
    LoaderFirmwareTemporary = 5,
    LoaderFirmwarePermanent = 6,
    LoaderOsloaderHeap = 7,
    LoaderOsloaderStack = 8,
    LoaderSystemCode = 9,
    LoaderHalCode = 10,
    LoaderBootDriver = 11,
    LoaderConsoleInDriver = 12,
    LoaderConsoleOutDriver = 13,
    LoaderStartupDpcStack = 14,
    LoaderStartupKernelStack = 15,
    LoaderStartupPanicStack = 16,
    LoaderStartupPcrPage = 17,
    LoaderStartupPdrPage = 18,
    LoaderRegistryData = 19,
    LoaderMemoryData = 20,
    LoaderNlsData = 21,
    LoaderSpecialMemory = 22,
    LoaderBBTMemory = 23,
    LoaderZero = 24,
    LoaderXIPRom = 25,
    LoaderHALCachedMemory = 26,
    LoaderLargePageFiller = 27,
    LoaderErrorLogMemory = 28,
    LoaderVsmMemory = 29,
    LoaderFirmwareCode = 30,
    LoaderFirmwareData = 31,
    LoaderFirmwareReserved = 32,
    LoaderEnclaveMemory = 33,
    LoaderFirmwareKsr = 34,
    LoaderEnclaveKsr = 35,
    LoaderMaximum = 36,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _VI_DEADLOCK_RESOURCE_TYPE {
    VfDeadlockUnknown = 0,
    VfDeadlockMutex = 1,
    VfDeadlockMutexAbandoned = 2,
    VfDeadlockFastMutex = 3,
    VfDeadlockFastMutexUnsafe = 4,
    VfDeadlockSpinLock = 5,
    VfDeadlockInStackQueuedSpinLock = 6,
    VfDeadlockUnusedSpinLock = 7,
    VfDeadlockEresource = 8,
    VfDeadlockTypeMaximum = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WHEA_ERROR_SOURCE_STATE {
    WheaErrSrcStateStopped = 1,
    WheaErrSrcStateStarted = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SEP_CACHED_HANDLES_ENTRY_TYPE {
    SepCachedHandlesEntryLowbox = 0,
    SepCachedHandlesEntryBnoIsolation = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CREATE_FILE_TYPE {
    CreateFileTypeNone = 0,
    CreateFileTypeNamedPipe = 1,
    CreateFileTypeMailslot = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IOP_PRIORITY_HINT {
    IopIoPriorityNotSet = 0,
    IopIoPriorityVeryLow = 1,
    IopIoPriorityLow = 2,
    IopIoPriorityNormal = 3,
    IopIoPriorityHigh = 4,
    IopIoPriorityCritical = 5,
    MaxIopIoPriorityTypes = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor = 0,
    QuerySecurityDescriptor = 1,
    DeleteSecurityDescriptor = 2,
    AssignSecurityDescriptor = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _OB_OPEN_REASON {
    ObCreateHandle = 0,
    ObOpenHandle = 1,
    ObDuplicateHandle = 2,
    ObInheritHandle = 3,
    ObMaxOpenReason = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BLOB_ID {
    BLOB_TYPE_UNKNOWN = 0,
    BLOB_TYPE_CONNECTION_INFO = 1,
    BLOB_TYPE_MESSAGE = 2,
    BLOB_TYPE_SECURITY_CONTEXT = 3,
    BLOB_TYPE_SECTION = 4,
    BLOB_TYPE_REGION = 5,
    BLOB_TYPE_VIEW = 6,
    BLOB_TYPE_RESERVE = 7,
    BLOB_TYPE_DIRECT_TRANSFER = 8,
    BLOB_TYPE_HANDLE_DATA = 9,
    BLOB_TYPE_MAX_ID = 10,
}
impl _KHETERO_CPU_POLICY {
    pub const KHeteroCpuPolicyStaticMax: _KHETERO_CPU_POLICY =
        _KHETERO_CPU_POLICY::KHeteroCpuPolicyDynamic;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KHETERO_CPU_POLICY {
    KHeteroCpuPolicyAll = 0,
    KHeteroCpuPolicyLarge = 1,
    KHeteroCpuPolicyLargeOrIdle = 2,
    KHeteroCpuPolicySmall = 3,
    KHeteroCpuPolicySmallOrIdle = 4,
    KHeteroCpuPolicyDynamic = 5,
    KHeteroCpuPolicyBiasedSmall = 6,
    KHeteroCpuPolicyBiasedLarge = 7,
    KHeteroCpuPolicyDefault = 8,
    KHeteroCpuPolicyMax = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _GPIO_PIN_IORESTRICTION_TYPE {
    IoRestrictionNone = 0,
    IoRestrictionInputOnly = 1,
    IoRestrictionOutputOnly = 2,
    IoRestrictionNoneAndPreserve = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _GPIO_PIN_CONFIG_TYPE {
    PullDefault = 0,
    PullUp = 1,
    PullDown = 2,
    PullNone = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PEP_ACPI_RESOURCE_TYPE {
    PepAcpiMemory = 0,
    PepAcpiIoPort = 1,
    PepAcpiInterrupt = 2,
    PepAcpiGpioIo = 3,
    PepAcpiGpioInt = 4,
    PepAcpiSpbI2c = 5,
    PepAcpiSpbSpi = 6,
    PepAcpiSpbUart = 7,
    PepAcpiExtendedMemory = 8,
    PepAcpiExtendedIo = 9,
}
#[repr(i32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ARBITER_REQUEST_SOURCE {
    ArbiterRequestUndefined = -1,
    ArbiterRequestLegacyReported = 0,
    ArbiterRequestHalReported = 1,
    ArbiterRequestLegacyAssigned = 2,
    ArbiterRequestPnpDetected = 3,
    ArbiterRequestPnpEnumerated = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PCW_CALLBACK_TYPE {
    PcwCallbackAddCounter = 0,
    PcwCallbackRemoveCounter = 1,
    PcwCallbackEnumerateInstances = 2,
    PcwCallbackCollectData = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_LOAD_FAILURE_TYPE {
    _None = 0,
    _CmInitializeHive = 1,
    _HvInitializeHive = 2,
    _HvpBuildMap = 3,
    _HvpBuildMapForLoaderHive = 4,
    _HvpInitMap = 5,
    _HvLoadHive = 6,
    _HvpMapHiveImage = 7,
    _HvpRecoverData = 8,
    _CmpValidateHiveSecurityDescriptors = 9,
    _HvpEnlistBinInMap = 10,
    _CmCheckRegistry = 11,
    _CmRegistryIO = 12,
    _CmCheckRegistry2 = 13,
    _CmpCheckKey = 14,
    _CmpCheckValueList = 15,
    _HvCheckHive = 16,
    _HvCheckBin = 17,
    _HvpGetLogEntryDirtyVector = 18,
    _HvpReadLogEntryHeader = 19,
    _HvpReadLogEntry = 20,
    _CmpMountPreloadedHives = 21,
    _CmpLoadHiveThread = 22,
    _CmpCheckLeaf = 23,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan = 0,
    GenericGreaterThan = 1,
    GenericEqual = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_DIRTY_VECTOR_OPERATION {
    DirtyVectorModified = 0,
    DirtyDataCaptureStart = 1,
    DirtyDataCaptureEnd = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KTM_STATE {
    KKtmUninitialized = 0,
    KKtmInitialized = 1,
    KKtmRecovering = 2,
    KKtmOnline = 3,
    KKtmRecoveryFailed = 4,
    KKtmOffline = 5,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTRANSACTION_OUTCOME {
    KTxOutcomeUninitialized = 0,
    KTxOutcomeUndetermined = 1,
    KTxOutcomeCommitted = 2,
    KTxOutcomeAborted = 3,
    KTxOutcomeUnavailable = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTRANSACTION_STATE {
    KTransactionUninitialized = 0,
    KTransactionActive = 1,
    KTransactionPreparing = 2,
    KTransactionPrepared = 3,
    KTransactionInDoubt = 4,
    KTransactionCommitted = 5,
    KTransactionAborted = 6,
    KTransactionDelegated = 7,
    KTransactionPrePreparing = 8,
    KTransactionForgotten = 9,
    KTransactionRecovering = 10,
    KTransactionPrePrepared = 11,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KRESOURCEMANAGER_STATE {
    KResourceManagerUninitialized = 0,
    KResourceManagerOffline = 1,
    KResourceManagerOnline = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HSTORAGE_TYPE {
    Stable = 0,
    Volatile = 1,
    InvalidStorage = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UoWActionType {
    UoWAddThisKey = 0,
    UoWAddChildKey = 1,
    UoWDeleteThisKey = 2,
    UoWDeleteChildKey = 3,
    UoWSetValueNew = 4,
    UoWSetValueExisting = 5,
    UoWDeleteValue = 6,
    UoWSetKeyUserFlags = 7,
    UoWSetLastWriteTime = 8,
    UoWSetSecurityDescriptor = 9,
    UoWRenameSubKey = 10,
    UoWRenameOldSubKey = 11,
    UoWRenameNewSubKey = 12,
    UoWIsolation = 13,
    UoWInvalid = 14,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KENLISTMENT_STATE {
    KEnlistmentUninitialized = 0,
    KEnlistmentActive = 256,
    KEnlistmentPreparing = 257,
    KEnlistmentPrepared = 258,
    KEnlistmentInDoubt = 259,
    KEnlistmentCommitted = 260,
    KEnlistmentCommittedNotify = 261,
    KEnlistmentCommitRequested = 262,
    KEnlistmentAborted = 263,
    KEnlistmentDelegated = 264,
    KEnlistmentDelegatedDisconnected = 265,
    KEnlistmentPrePreparing = 266,
    KEnlistmentForgotten = 267,
    KEnlistmentRecovering = 268,
    KEnlistmentAborting = 269,
    KEnlistmentReadOnly = 270,
    KEnlistmentOutcomeUnavailable = 271,
    KEnlistmentOffline = 272,
    KEnlistmentPrePrepared = 273,
    KEnlistmentInitialized = 274,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MMLISTS {
    ZeroedPageList = 0,
    FreePageList = 1,
    StandbyPageList = 2,
    ModifiedPageList = 3,
    ModifiedNoWritePageList = 4,
    BadPageList = 5,
    ActiveAndValid = 6,
    TransitionPage = 7,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    #[doc = "offset: 0x0 (0)"]
    pub _ptr: *mut CHAR,
    #[doc = "offset: 0x4 (4)"]
    pub _cnt: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub _base: *mut CHAR,
    #[doc = "offset: 0xc (12)"]
    pub _flag: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub _file: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub _charbuf: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub _bufsiz: LONG,
    #[doc = "offset: 0x1c (28)"]
    pub _tmpfname: *mut CHAR,
}
impl Default for _iobuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WHEA_ERROR_PACKET_DATA_FORMAT {
    WheaDataFormatIPFSalRecord = 0,
    WheaDataFormatXPFMCA = 1,
    WheaDataFormatMemory = 2,
    WheaDataFormatPCIExpress = 3,
    WheaDataFormatNMIPort = 4,
    WheaDataFormatPCIXBus = 5,
    WheaDataFormatPCIXDevice = 6,
    WheaDataFormatGeneric = 7,
    WheaDataFormatMax = 8,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WHEA_ERROR_SOURCE_TYPE {
    WheaErrSrcTypeMCE = 0,
    WheaErrSrcTypeCMC = 1,
    WheaErrSrcTypeCPE = 2,
    WheaErrSrcTypeNMI = 3,
    WheaErrSrcTypePCIe = 4,
    WheaErrSrcTypeGeneric = 5,
    WheaErrSrcTypeINIT = 6,
    WheaErrSrcTypeBOOT = 7,
    WheaErrSrcTypeSCIGeneric = 8,
    WheaErrSrcTypeIPFMCA = 9,
    WheaErrSrcTypeIPFCMC = 10,
    WheaErrSrcTypeIPFCPE = 11,
    WheaErrSrcTypeGenericV2 = 12,
    WheaErrSrcTypeSCIGenericV2 = 13,
    WheaErrSrcTypeMax = 14,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WHEA_ERROR_SEVERITY {
    WheaErrSevRecoverable = 0,
    WheaErrSevFatal = 1,
    WheaErrSevCorrected = 2,
    WheaErrSevInformational = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WHEA_ERROR_TYPE {
    WheaErrTypeProcessor = 0,
    WheaErrTypeMemory = 1,
    WheaErrTypePCIExpress = 2,
    WheaErrTypeNMI = 3,
    WheaErrTypePCIXBus = 4,
    WheaErrTypePCIXDevice = 5,
    WheaErrTypeGeneric = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MM_PAGE_ACCESS_TYPE {
    MmPteAccessType = 0,
    MmCcReadAheadType = 1,
    MmPfnRepurposeType = 2,
    MmMaximumPageAccessType = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_PRIORITY_HINT {
    IoPriorityVeryLow = 0,
    IoPriorityLow = 1,
    IoPriorityNormal = 2,
    IoPriorityHigh = 3,
    IoPriorityCritical = 4,
    MaxIoPriorityTypes = 5,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KPROFILE_SOURCE {
    ProfileTime = 0,
    ProfileAlignmentFixup = 1,
    ProfileTotalIssues = 2,
    ProfilePipelineDry = 3,
    ProfileLoadInstructions = 4,
    ProfilePipelineFrozen = 5,
    ProfileBranchInstructions = 6,
    ProfileTotalNonissues = 7,
    ProfileDcacheMisses = 8,
    ProfileIcacheMisses = 9,
    ProfileCacheMisses = 10,
    ProfileBranchMispredictions = 11,
    ProfileStoreInstructions = 12,
    ProfileFpInstructions = 13,
    ProfileIntegerInstructions = 14,
    Profile2Issue = 15,
    Profile3Issue = 16,
    Profile4Issue = 17,
    ProfileSpecialInstructions = 18,
    ProfileTotalCycles = 19,
    ProfileIcacheIssues = 20,
    ProfileDcacheAccesses = 21,
    ProfileMemoryBarrierCycles = 22,
    ProfileLoadLinkedIssues = 23,
    ProfileMaximum = 24,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_BUFFER_STATE {
    EtwBufferStateFree = 0,
    EtwBufferStateGeneralLogging = 1,
    EtwBufferStateCSwitch = 2,
    EtwBufferStateFlush = 3,
    EtwBufferStatePendingCompression = 4,
    EtwBufferStateCompressed = 5,
    EtwBufferStatePlaceholder = 6,
    EtwBufferStateMaximum = 7,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ETW_COMPRESSION_RESUMPTION_MODE {
    EtwCompressionModeRestart = 0,
    EtwCompressionModeNoDisable = 1,
    EtwCompressionModeNoRestart = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_PERIODIC_TIMER_STATE {
    EtwpPeriodicTimerUnset = 0,
    EtwpPeriodicTimerSet = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_RT_EVENT_LOSS {
    EtwRtEventNoLoss = 0,
    EtwRtEventLost = 1,
    EtwRtBufferLost = 2,
    EtwRtBackupLost = 3,
    EtwRtEventLossMax = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
    NotifyTypeCreate = 0,
    NotifyTypeRetired = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FS_FILTER_SECTION_SYNC_TYPE {
    SyncTypeOther = 0,
    SyncTypeCreateSection = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub ClientToken: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub ImpersonationLevel: _SECURITY_IMPERSONATION_LEVEL,
    #[doc = "offset: 0x8 (8)"]
    pub PrimaryToken: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub ProcessAuditId: *mut VOID,
}
impl Default for _SECURITY_SUBJECT_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_RELATION_LEVEL {
    RELATION_LEVEL_REMOVE_EJECT = 0,
    RELATION_LEVEL_DEPENDENT = 1,
    RELATION_LEVEL_DIRECT_DESCENDANT = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED = 1,
    SERVERSILO_SHUTTING_DOWN = 2,
    SERVERSILO_TERMINATING = 3,
    SERVERSILO_TERMINATED = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_FX_PERF_STATE_TYPE {
    PoFxPerfStateTypeDiscrete = 0,
    PoFxPerfStateTypeRange = 1,
    PoFxPerfStateTypeMaximum = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_FX_PERF_STATE_UNIT {
    PoFxPerfStateUnitOther = 0,
    PoFxPerfStateUnitFrequency = 1,
    PoFxPerfStateUnitBandwidth = 2,
    PoFxPerfStateUnitMaximum = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IRQ_PRIORITY {
    IrqPriorityUndefined = 0,
    IrqPriorityLow = 1,
    IrqPriorityNormal = 2,
    IrqPriorityHigh = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MI_SYSTEM_VA_TYPE {
    MiVaUnused = 0,
    MiVaSessionSpace = 1,
    MiVaProcessSpace = 2,
    MiVaBootLoaded = 3,
    MiVaPfnDatabase = 4,
    MiVaNonPagedPool = 5,
    MiVaPagedPool = 6,
    MiVaSpecialPoolPaged = 7,
    MiVaSystemCache = 8,
    MiVaSystemPtes = 9,
    MiVaHal = 10,
    MiVaSessionGlobalSpace = 11,
    MiVaDriverImages = 12,
    MiVaSpecialPoolNonPaged = 13,
    MiVaPagedProtoPool = 14,
    MiVaSystemPtesLarge = 15,
    MiVaKernelStacks = 16,
    MiVaMaximumType = 17,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PROFILE_DEPARTURE_STYLE {
    PDS_UPDATE_DEFAULT = 1,
    PDS_UPDATE_ON_REMOVE = 2,
    PDS_UPDATE_ON_INTERFACE = 3,
    PDS_UPDATE_ON_EJECT = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_ACTION {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
    PowerActionDisplayOff = 8,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3,
    DeviceUsageTypeBoot = 4,
    DeviceUsageTypePostDisplay = 5,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DEVICE_TEXT_TYPE {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BUS_QUERY_ID_TYPE {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4,
    BusQueryContainerID = 5,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4,
    SingleBusRelations = 5,
    TransportRelations = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsDriverPathInformation = 9,
    FileFsVolumeFlagsInformation = 10,
    FileFsSectorSizeInformation = 11,
    FileFsDataCopyInformation = 12,
    FileFsMetadataSizeInformation = 13,
    FileFsMaximumInformation = 14,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {
    DirectoryNotifyInformation = 1,
    DirectoryNotifyExtendedInformation = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileIdBothDirectoryInformation = 37,
    FileIdFullDirectoryInformation = 38,
    FileValidDataLengthInformation = 39,
    FileShortNameInformation = 40,
    FileIoCompletionNotificationInformation = 41,
    FileIoStatusBlockRangeInformation = 42,
    FileIoPriorityHintInformation = 43,
    FileSfioReserveInformation = 44,
    FileSfioVolumeInformation = 45,
    FileHardLinkInformation = 46,
    FileProcessIdsUsingFileInformation = 47,
    FileNormalizedNameInformation = 48,
    FileNetworkPhysicalNameInformation = 49,
    FileIdGlobalTxDirectoryInformation = 50,
    FileIsRemoteDeviceInformation = 51,
    FileUnusedInformation = 52,
    FileNumaNodeInformation = 53,
    FileStandardLinkInformation = 54,
    FileRemoteProtocolInformation = 55,
    FileRenameInformationBypassAccessCheck = 56,
    FileLinkInformationBypassAccessCheck = 57,
    FileVolumeNameInformation = 58,
    FileIdInformation = 59,
    FileIdExtdDirectoryInformation = 60,
    FileReplaceCompletionInformation = 61,
    FileHardLinkFullIdInformation = 62,
    FileIdExtdBothDirectoryInformation = 63,
    FileDispositionInformationEx = 64,
    FileRenameInformationEx = 65,
    FileRenameInformationExBypassAccessCheck = 66,
    FileDesiredStorageClassInformation = 67,
    FileStatInformation = 68,
    FileMemoryPartitionInformation = 69,
    FileMaximumInformation = 70,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_SESSION_STATE {
    IoSessionStateCreated = 1,
    IoSessionStateInitialized = 2,
    IoSessionStateConnected = 3,
    IoSessionStateDisconnected = 4,
    IoSessionStateDisconnectedLoggedOn = 5,
    IoSessionStateLoggedOn = 6,
    IoSessionStateLoggedOff = 7,
    IoSessionStateTerminated = 8,
    IoSessionStateMax = 9,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PLUGPLAY_EVENT_CATEGORY {
    HardwareProfileChangeEvent = 0,
    TargetDeviceChangeEvent = 1,
    DeviceClassChangeEvent = 2,
    CustomDeviceEvent = 3,
    DeviceInstallEvent = 4,
    DeviceArrivalEvent = 5,
    VetoEvent = 6,
    BlockedDriverEvent = 7,
    InvalidIDEvent = 8,
    DevicePropertyChangeEvent = 9,
    DeviceInstanceRemovalEvent = 10,
    DeviceInstanceStartedEvent = 11,
    MaxPlugEventCategory = 12,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_VETO_TYPE {
    PNP_VetoTypeUnknown = 0,
    PNP_VetoLegacyDevice = 1,
    PNP_VetoPendingClose = 2,
    PNP_VetoWindowsApp = 3,
    PNP_VetoWindowsService = 4,
    PNP_VetoOutstandingOpen = 5,
    PNP_VetoDevice = 6,
    PNP_VetoDriver = 7,
    PNP_VetoIllegalDeviceRequest = 8,
    PNP_VetoInsufficientPower = 9,
    PNP_VetoNonDisableable = 10,
    PNP_VetoLegacyDriver = 11,
    PNP_VetoInsufficientRights = 12,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POP_DEVICE_IDLE_TYPE {
    DeviceIdleNormal = 0,
    DeviceIdleDisk = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_APIC_DESTINATION_MODE {
    ApicDestinationModePhysical = 1,
    ApicDestinationModeLogicalFlat = 2,
    ApicDestinationModeLogicalClustered = 3,
    ApicDestinationModeUnknown = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_DEVNODE_QUERY_REBALANCE_VETO_REASON {
    DeviceQueryRebalanceSucceeded = 0,
    DeviceQueryStopFailed = 1,
    DeviceFailedGetNewResourceRequirement = 2,
    DeviceInUnexpectedState = 3,
    DeviceNotSupportQueryRebalance = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_REBALANCE_FAILURE {
    RebalanceFailureNone = 0,
    RebalanceFailureDisabled = 1,
    RebalanceFailureNoMemory = 2,
    RebalanceFailureQueryStopUnexpectedVeto = 3,
    RebalanceFailureNoRequirements = 4,
    RebalanceFailureNoCandidates = 5,
    RebalanceFailureNoConfiguration = 6,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_REBALANCE_REASON {
    RebalanceReasonUnknown = 0,
    RebalanceReasonRequirementsChanged = 1,
    RebalanceReasonNewDevice = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum INTERRUPT_CONNECTION_TYPE {
    InterruptTypeControllerInput = 0,
    InterruptTypeXapicMessage = 1,
    InterruptTypeHypertransport = 2,
    InterruptTypeMessageRequest = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_DEVICE_DELETE_TYPE {
    QueryRemoveDevice = 0,
    CancelRemoveDevice = 1,
    RemoveDevice = 2,
    SurpriseRemoveDevice = 3,
    EjectDevice = 4,
    RemoveFailedDevice = 5,
    RemoveUnstartedFailedDevice = 6,
    MaxDeviceDeleteType = 7,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRPLOCK {
    IRPLOCK_CANCELABLE = 0,
    IRPLOCK_CANCEL_STARTED = 1,
    IRPLOCK_CANCEL_COMPLETE = 2,
    IRPLOCK_COMPLETED = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PROFILE_STATUS {
    DOCK_NOTDOCKDEVICE = 0,
    DOCK_QUIESCENT = 1,
    DOCK_ARRIVING = 2,
    DOCK_DEPARTING = 3,
    DOCK_EJECTIRP_COMPLETED = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDWARE_COUNTER_TYPE {
    PMCCounter = 0,
    MaxHardwareCounterType = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub SystemState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x0 (0)"]
    pub DeviceState: _DEVICE_POWER_STATE,
}
impl Default for _POWER_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    Vmcs = 16,
    ACPIBus = 17,
    MaximumInterfaceType = 18,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_DEVNODE_STATE {
    DeviceNodeUnspecified = 768,
    DeviceNodeUninitialized = 769,
    DeviceNodeInitialized = 770,
    DeviceNodeDriversAdded = 771,
    DeviceNodeResourcesAssigned = 772,
    DeviceNodeStartPending = 773,
    DeviceNodeStartCompletion = 774,
    DeviceNodeStartPostWork = 775,
    DeviceNodeStarted = 776,
    DeviceNodeQueryStopped = 777,
    DeviceNodeStopped = 778,
    DeviceNodeRestartCompletion = 779,
    DeviceNodeEnumeratePending = 780,
    DeviceNodeEnumerateCompletion = 781,
    DeviceNodeAwaitingQueuedDeletion = 782,
    DeviceNodeAwaitingQueuedRemoval = 783,
    DeviceNodeQueryRemoved = 784,
    DeviceNodeRemovePendingCloses = 785,
    DeviceNodeRemoved = 786,
    DeviceNodeDeletePendingCloses = 787,
    DeviceNodeDeleted = 788,
    MaxDeviceNodeState = 789,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PEPHANDLE__ {
    #[doc = "offset: 0x0 (0)"]
    pub unused: LONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEP_CRASHDUMP_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceHandle: *mut PEPHANDLE__,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceContext: *mut VOID,
}
impl Default for _PEP_CRASHDUMP_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KINTERRUPT_POLARITY {
    pub const InterruptRisingEdge: _KINTERRUPT_POLARITY = _KINTERRUPT_POLARITY::InterruptActiveHigh;
}
impl _KINTERRUPT_POLARITY {
    pub const InterruptFallingEdge: _KINTERRUPT_POLARITY = _KINTERRUPT_POLARITY::InterruptActiveLow;
}
impl _KINTERRUPT_POLARITY {
    pub const InterruptActiveBothTriggerLow: _KINTERRUPT_POLARITY =
        _KINTERRUPT_POLARITY::InterruptActiveBoth;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KINTERRUPT_POLARITY {
    InterruptPolarityUnknown = 0,
    InterruptActiveHigh = 1,
    InterruptActiveLow = 2,
    InterruptActiveBoth = 3,
    InterruptActiveBothTriggerHigh = 4,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KINTERRUPT_MODE {
    LevelSensitive = 0,
    Latched = 1,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PPM_IDLE_BUCKET_TIME_TYPE {
    PpmIdleBucketTimeInQpc = 0,
    PpmIdleBucketTimeIn100ns = 1,
    PpmIdleBucketTimeMaximum = 2,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESSOR_CACHE_TYPE {
    CacheUnified = 0,
    CacheInstruction = 1,
    CacheData = 2,
    CacheTrace = 3,
}
impl _POOL_TYPE {
    pub const NonPagedPoolExecute: _POOL_TYPE = _POOL_TYPE::NonPagedPool;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBase: _POOL_TYPE = _POOL_TYPE::NonPagedPool;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBaseMustSucceed: _POOL_TYPE = _POOL_TYPE::NonPagedPoolMustSucceed;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBaseCacheAligned: _POOL_TYPE = _POOL_TYPE::NonPagedPoolCacheAligned;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBaseCacheAlignedMustS: _POOL_TYPE =
        _POOL_TYPE::NonPagedPoolCacheAlignedMustS;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = 516,
    NonPagedPoolSessionNx = 544,
}
impl _KHETERO_CPU_QOS {
    pub const KHeteroCpuQosHigh: _KHETERO_CPU_QOS = _KHETERO_CPU_QOS::KHeteroCpuQosDefault;
}
impl _KHETERO_CPU_QOS {
    pub const KHeteroCpuQosMax: _KHETERO_CPU_QOS = _KHETERO_CPU_QOS::KHeteroCpuQosDynamic;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KHETERO_CPU_QOS {
    KHeteroCpuQosDefault = 0,
    KHeteroCpuQosMedium = 1,
    KHeteroCpuQosLow = 2,
    KHeteroCpuQosDynamic = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROC_HYPERVISOR_STATE {
    ProcHypervisorNone = 0,
    ProcHypervisorPresent = 1,
    ProcHypervisorPower = 2,
    ProcHypervisorHvCounters = 3,
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution = 0,
    ExceptionContinueSearch = 1,
    ExceptionNestedException = 2,
    ExceptionCollidedUnwind = 3,
}
impl _TP_CALLBACK_PRIORITY {
    pub const TP_CALLBACK_PRIORITY_COUNT: _TP_CALLBACK_PRIORITY =
        _TP_CALLBACK_PRIORITY::TP_CALLBACK_PRIORITY_INVALID;
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH = 0,
    TP_CALLBACK_PRIORITY_NORMAL = 1,
    TP_CALLBACK_PRIORITY_LOW = 2,
    TP_CALLBACK_PRIORITY_INVALID = 3,
}
pub type WCHAR = u16;
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUAD {
    pub __bindgen_anon_1: _QUAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUAD__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub UseThisFieldToCopy: LONGLONG,
    #[doc = "offset: 0x0 (0)"]
    pub DoNotUseThisField: f64,
}
impl Default for _QUAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _QUAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_WRITE_WAIT_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub ActiveThread: *mut _ETHREAD,
    #[doc = "offset: 0x4 (4)"]
    pub WaitList: *mut _HIVE_WAIT_PACKET,
    #[doc = "offset: 0x8 (8)"]
    pub OwnerBoosted: ULONG,
}
impl Default for _HIVE_WRITE_WAIT_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAST_OWNER_ENTRY_INTERNAL {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub AbLockHandle: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0xa (10)"]
    pub IsSublistHead: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub IsWaiting: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub LockAddress: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub ThreadAddress: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SublistHead: _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub LockListEntry: _LIST_ENTRY,
}
impl Default for _FAST_OWNER_ENTRY_INTERNAL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _FAST_OWNER_ENTRY_INTERNAL {
    #[inline]
    pub fn Disowned(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Disowned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DynamicallyAllocated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DynamicallyAllocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CallerExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CallerExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Disowned: UCHAR,
        DynamicallyAllocated: UCHAR,
        CallerExclusive: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Disowned: u8 = unsafe { ::std::mem::transmute(Disowned) };
            Disowned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DynamicallyAllocated: u8 = unsafe { ::std::mem::transmute(DynamicallyAllocated) };
            DynamicallyAllocated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CallerExclusive: u8 = unsafe { ::std::mem::transmute(CallerExclusive) };
            CallerExclusive as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_TRACKER_STAMP {
    #[doc = "offset: 0x0 (0)"]
    pub Thread: *mut VOID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _VF_TRACKER_STAMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VF_TRACKER_STAMP {
    #[inline]
    pub fn Flags(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn OldIrql(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_OldIrql(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn NewIrql(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_NewIrql(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Processor(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_Processor(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flags: UCHAR,
        OldIrql: UCHAR,
        NewIrql: UCHAR,
        Processor: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Flags: u8 = unsafe { ::std::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let OldIrql: u8 = unsafe { ::std::mem::transmute(OldIrql) };
            OldIrql as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let NewIrql: u8 = unsafe { ::std::mem::transmute(NewIrql) };
            NewIrql as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Processor: u8 = unsafe { ::std::mem::transmute(Processor) };
            Processor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_WSLE {
    #[doc = "offset: 0x0 (0)"]
    pub u1: _MI_WSLE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_WSLE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub e1: _MI_WSLE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub e2: _MI_WSLE__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_WSLE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _MI_WSLE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Age(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Age(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Age: UCHAR,
        Protection: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Age: u8 = unsafe { ::std::mem::transmute(Age) };
            Age as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let Protection: u8 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_WSLE__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub EntireWsle: UCHAR,
}
impl Default for _MI_WSLE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_WSLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2000 (8192) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_HYPER_SPACE {
    #[doc = "offset: 0x0 (0)"]
    pub VadBitmap: [UCHAR; 6144usize],
    #[doc = "offset: 0x1800 (6144)"]
    pub PaddingToPageBoundary: [UCHAR; 2048usize],
}
impl Default for _MI_HYPER_SPACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XPF_MC_BANK_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsUCHAR: UCHAR,
}
impl Default for _XPF_MC_BANK_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _XPF_MC_BANK_FLAGS {
    #[inline]
    pub fn ClearOnInitializationRW(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ClearOnInitializationRW(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ControlDataRW(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ControlDataRW(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClearOnInitializationRW: UCHAR,
        ControlDataRW: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ClearOnInitializationRW: u8 =
                unsafe { ::std::mem::transmute(ClearOnInitializationRW) };
            ClearOnInitializationRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ControlDataRW: u8 = unsafe { ::std::mem::transmute(ControlDataRW) };
            ControlDataRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1e (30) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_AUDIT_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub PerUserPolicy: [UCHAR; 30usize],
}
#[doc = "0x1f (31) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEP_AUDIT_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub AdtTokenPolicy: _TOKEN_AUDIT_POLICY,
    #[doc = "offset: 0x1e (30)"]
    pub PolicySetStatus: UCHAR,
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_LOGGER_HANDLE {
    #[doc = "offset: 0x0 (0)"]
    pub DereferenceAndLeave: UCHAR,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CACHE_MANAGER_CALLBACKS {
    #[doc = "offset: 0x0 (0)"]
    pub AcquireForLazyWrite:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: UCHAR) -> UCHAR>,
    #[doc = "offset: 0x4 (4)"]
    pub ReleaseFromLazyWrite: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0x8 (8)"]
    pub AcquireForReadAhead:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: UCHAR) -> UCHAR>,
    #[doc = "offset: 0xc (12)"]
    pub ReleaseFromReadAhead: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMINPAGE_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMINPAGE_FLAGS {
    #[inline]
    pub fn InjectRetry(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InjectRetry(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GetExtents(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GetExtents(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrossThreadPadding(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_CrossThreadPadding(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn PrefetchSystemVmType(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_PrefetchSystemVmType(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn VaPrefetchReadBlock(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VaPrefetchReadBlock(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CollidedFlowThrough(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CollidedFlowThrough(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceCollisions(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ForceCollisions(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InPageExpanded(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InPageExpanded(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IssuedAtLowPriority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IssuedAtLowPriority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FaultFromStore(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FaultFromStore(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PagePriority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_PagePriority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PerformRelocations(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PerformRelocations(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClusteredPagePriority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ClusteredPagePriority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn MakeClusterValid(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MakeClusterValid(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ZeroLastPage(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ZeroLastPage(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserFault(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UserFault(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StandbyProtectionNeeded(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_StandbyProtectionNeeded(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PteChanged(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PteChanged(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileFault(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PageFileFault(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFilePageHashActive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PageFilePageHashActive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoalescedIo(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CoalescedIo(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VmLockNotNeeded(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VmLockNotNeeded(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InjectRetry: UCHAR,
        GetExtents: UCHAR,
        CrossThreadPadding: UCHAR,
        PrefetchSystemVmType: UCHAR,
        VaPrefetchReadBlock: UCHAR,
        CollidedFlowThrough: UCHAR,
        ForceCollisions: UCHAR,
        InPageExpanded: UCHAR,
        IssuedAtLowPriority: UCHAR,
        FaultFromStore: UCHAR,
        PagePriority: UCHAR,
        PerformRelocations: UCHAR,
        ClusteredPagePriority: UCHAR,
        MakeClusterValid: UCHAR,
        ZeroLastPage: UCHAR,
        UserFault: UCHAR,
        StandbyProtectionNeeded: UCHAR,
        PteChanged: UCHAR,
        PageFileFault: UCHAR,
        PageFilePageHashActive: UCHAR,
        CoalescedIo: UCHAR,
        VmLockNotNeeded: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InjectRetry: u8 = unsafe { ::std::mem::transmute(InjectRetry) };
            InjectRetry as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let GetExtents: u8 = unsafe { ::std::mem::transmute(GetExtents) };
            GetExtents as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let CrossThreadPadding: u8 = unsafe { ::std::mem::transmute(CrossThreadPadding) };
            CrossThreadPadding as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let PrefetchSystemVmType: u8 = unsafe { ::std::mem::transmute(PrefetchSystemVmType) };
            PrefetchSystemVmType as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let VaPrefetchReadBlock: u8 = unsafe { ::std::mem::transmute(VaPrefetchReadBlock) };
            VaPrefetchReadBlock as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CollidedFlowThrough: u8 = unsafe { ::std::mem::transmute(CollidedFlowThrough) };
            CollidedFlowThrough as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ForceCollisions: u8 = unsafe { ::std::mem::transmute(ForceCollisions) };
            ForceCollisions as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let InPageExpanded: u8 = unsafe { ::std::mem::transmute(InPageExpanded) };
            InPageExpanded as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let IssuedAtLowPriority: u8 = unsafe { ::std::mem::transmute(IssuedAtLowPriority) };
            IssuedAtLowPriority as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FaultFromStore: u8 = unsafe { ::std::mem::transmute(FaultFromStore) };
            FaultFromStore as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let PagePriority: u8 = unsafe { ::std::mem::transmute(PagePriority) };
            PagePriority as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let PerformRelocations: u8 = unsafe { ::std::mem::transmute(PerformRelocations) };
            PerformRelocations as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let ClusteredPagePriority: u8 = unsafe { ::std::mem::transmute(ClusteredPagePriority) };
            ClusteredPagePriority as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MakeClusterValid: u8 = unsafe { ::std::mem::transmute(MakeClusterValid) };
            MakeClusterValid as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ZeroLastPage: u8 = unsafe { ::std::mem::transmute(ZeroLastPage) };
            ZeroLastPage as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let UserFault: u8 = unsafe { ::std::mem::transmute(UserFault) };
            UserFault as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let StandbyProtectionNeeded: u8 =
                unsafe { ::std::mem::transmute(StandbyProtectionNeeded) };
            StandbyProtectionNeeded as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let PteChanged: u8 = unsafe { ::std::mem::transmute(PteChanged) };
            PteChanged as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let PageFileFault: u8 = unsafe { ::std::mem::transmute(PageFileFault) };
            PageFileFault as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let PageFilePageHashActive: u8 =
                unsafe { ::std::mem::transmute(PageFilePageHashActive) };
            PageFilePageHashActive as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let CoalescedIo: u8 = unsafe { ::std::mem::transmute(CoalescedIo) };
            CoalescedIo as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let VmLockNotNeeded: u8 = unsafe { ::std::mem::transmute(VmLockNotNeeded) };
            VmLockNotNeeded as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFNENTRY3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _MMPFNENTRY3 {
    #[inline]
    pub fn Priority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Priority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn OnProtectedStandby(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OnProtectedStandby(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InPageError(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InPageError(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemChargedPage(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SystemChargedPage(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RemovalRequested(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RemovalRequested(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ParityError(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ParityError(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Priority: UCHAR,
        OnProtectedStandby: UCHAR,
        InPageError: UCHAR,
        SystemChargedPage: UCHAR,
        RemovalRequested: UCHAR,
        ParityError: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Priority: u8 = unsafe { ::std::mem::transmute(Priority) };
            Priority as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OnProtectedStandby: u8 = unsafe { ::std::mem::transmute(OnProtectedStandby) };
            OnProtectedStandby as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let InPageError: u8 = unsafe { ::std::mem::transmute(InPageError) };
            InPageError as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SystemChargedPage: u8 = unsafe { ::std::mem::transmute(SystemChargedPage) };
            SystemChargedPage as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RemovalRequested: u8 = unsafe { ::std::mem::transmute(RemovalRequested) };
            RemovalRequested as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ParityError: u8 = unsafe { ::std::mem::transmute(ParityError) };
            ParityError as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFNENTRY1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _MMPFNENTRY1 {
    #[inline]
    pub fn PageLocation(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_PageLocation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteInProgress(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WriteInProgress(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Modified(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Modified(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadInProgress(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadInProgress(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheAttribute(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CacheAttribute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageLocation: UCHAR,
        WriteInProgress: UCHAR,
        Modified: UCHAR,
        ReadInProgress: UCHAR,
        CacheAttribute: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let PageLocation: u8 = unsafe { ::std::mem::transmute(PageLocation) };
            PageLocation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteInProgress: u8 = unsafe { ::std::mem::transmute(WriteInProgress) };
            WriteInProgress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Modified: u8 = unsafe { ::std::mem::transmute(Modified) };
            Modified as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ReadInProgress: u8 = unsafe { ::std::mem::transmute(ReadInProgress) };
            ReadInProgress as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let CacheAttribute: u8 = unsafe { ::std::mem::transmute(CacheAttribute) };
            CacheAttribute as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPAGE_FILE_EXPANSION_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMPAGE_FILE_EXPANSION_FLAGS {
    #[inline]
    pub fn PageFileNumber(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_PageFileNumber(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare2(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_Spare2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreCurrentCommit(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IgnoreCurrentCommit(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IncreaseMinimumSize(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IncreaseMinimumSize(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AttemptForCantExtend(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AttemptForCantExtend(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnusedSegmentDeletion(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UnusedSegmentDeletion(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileContract(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PageFileContract(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare3(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Spare3(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageFileNumber: UCHAR,
        Spare1: UCHAR,
        Spare2: UCHAR,
        IgnoreCurrentCommit: UCHAR,
        IncreaseMinimumSize: UCHAR,
        AttemptForCantExtend: UCHAR,
        UnusedSegmentDeletion: UCHAR,
        PageFileContract: UCHAR,
        Spare3: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PageFileNumber: u8 = unsafe { ::std::mem::transmute(PageFileNumber) };
            PageFileNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Spare1: u8 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Spare2: u8 = unsafe { ::std::mem::transmute(Spare2) };
            Spare2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let IgnoreCurrentCommit: u8 = unsafe { ::std::mem::transmute(IgnoreCurrentCommit) };
            IgnoreCurrentCommit as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let IncreaseMinimumSize: u8 = unsafe { ::std::mem::transmute(IncreaseMinimumSize) };
            IncreaseMinimumSize as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let AttemptForCantExtend: u8 = unsafe { ::std::mem::transmute(AttemptForCantExtend) };
            AttemptForCantExtend as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let UnusedSegmentDeletion: u8 = unsafe { ::std::mem::transmute(UnusedSegmentDeletion) };
            UnusedSegmentDeletion as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let PageFileContract: u8 = unsafe { ::std::mem::transmute(PageFileContract) };
            PageFileContract as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let Spare3: u8 = unsafe { ::std::mem::transmute(Spare3) };
            Spare3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_REBUILD_LARGE_PAGE_TIMER {
    #[doc = "offset: 0x0 (0)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x10 (16)"]
    pub SecondsLeft: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub RebuildActive: UCHAR,
    #[doc = "offset: 0x12 (18)"]
    pub NextPassDelta: UCHAR,
    #[doc = "offset: 0x13 (19)"]
    pub LargeSubPagesActive: UCHAR,
}
impl Default for _MI_REBUILD_LARGE_PAGE_TIMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsUCHAR: UCHAR,
}
impl Default for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    #[inline]
    pub fn FRUId(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FRUId(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FRUText(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FRUText(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FRUId: UCHAR,
        FRUText: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FRUId: u8 = unsafe { ::std::mem::transmute(FRUId) };
            FRUId as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FRUText: u8 = unsafe { ::std::mem::transmute(FRUText) };
            FRUText as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AccessRights: UCHAR,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
    #[inline]
    pub fn Trustlet(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Trustlet(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Ntos(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Ntos(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteHandle(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WriteHandle(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadHandle(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadHandle(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Trustlet: UCHAR,
        Ntos: UCHAR,
        WriteHandle: UCHAR,
        ReadHandle: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Trustlet: u8 = unsafe { ::std::mem::transmute(Trustlet) };
            Trustlet as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Ntos: u8 = unsafe { ::std::mem::transmute(Ntos) };
            Ntos as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WriteHandle: u8 = unsafe { ::std::mem::transmute(WriteHandle) };
            WriteHandle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReadHandle: u8 = unsafe { ::std::mem::transmute(ReadHandle) };
            ReadHandle as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SYSTEM_LOGGER {
    #[doc = "offset: 0x0 (0)"]
    pub LoggerId: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub ClockType: UCHAR,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_ADDRESS_RANGE {
    #[doc = "offset: 0x0 (0)"]
    pub Start: *mut UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub End: *mut UCHAR,
}
impl Default for _VF_ADDRESS_RANGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_PROTECTION {
    pub __bindgen_anon_1: _PS_PROTECTION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_PROTECTION__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Level: UCHAR,
    pub __bindgen_anon_1: _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Audit(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Audit(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Signer(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Signer(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: UCHAR,
        Audit: UCHAR,
        Signer: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Type: u8 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Audit: u8 = unsafe { ::std::mem::transmute(Audit) };
            Audit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Signer: u8 = unsafe { ::std::mem::transmute(Signer) };
            Signer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PS_PROTECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PS_PROTECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KEXECUTE_OPTIONS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub ExecuteOptions: UCHAR,
    #[doc = "offset: 0x0 (0)"]
    pub ExecuteOptionsNV: UCHAR,
}
impl Default for _KEXECUTE_OPTIONS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KEXECUTE_OPTIONS {
    #[inline]
    pub fn ExecuteDisable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteEnable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExecuteEnable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableThunkEmulation(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableThunkEmulation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Permanent(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Permanent(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDispatchEnable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExecuteDispatchEnable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageDispatchEnable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageDispatchEnable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableExceptionChainValidation(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableExceptionChainValidation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExecuteDisable: UCHAR,
        ExecuteEnable: UCHAR,
        DisableThunkEmulation: UCHAR,
        Permanent: UCHAR,
        ExecuteDispatchEnable: UCHAR,
        ImageDispatchEnable: UCHAR,
        DisableExceptionChainValidation: UCHAR,
        Spare: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ExecuteDisable: u8 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ExecuteEnable: u8 = unsafe { ::std::mem::transmute(ExecuteEnable) };
            ExecuteEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisableThunkEmulation: u8 = unsafe { ::std::mem::transmute(DisableThunkEmulation) };
            DisableThunkEmulation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Permanent: u8 = unsafe { ::std::mem::transmute(Permanent) };
            Permanent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ExecuteDispatchEnable: u8 = unsafe { ::std::mem::transmute(ExecuteDispatchEnable) };
            ExecuteDispatchEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ImageDispatchEnable: u8 = unsafe { ::std::mem::transmute(ImageDispatchEnable) };
            ImageDispatchEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DisableExceptionChainValidation: u8 =
                unsafe { ::std::mem::transmute(DisableExceptionChainValidation) };
            DisableExceptionChainValidation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Spare: u8 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_PERF_LOAD {
    #[doc = "offset: 0x0 (0)"]
    pub BusyPercentage: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub FrequencyPercentage: UCHAR,
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _flags {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _flags {
    #[inline]
    pub fn Removable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GroupAssigned(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupAssigned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GroupCommitted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupCommitted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GroupAssignmentFixed(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupAssignmentFixed(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Fill(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Fill(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Removable: UCHAR,
        GroupAssigned: UCHAR,
        GroupCommitted: UCHAR,
        GroupAssignmentFixed: UCHAR,
        Fill: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Removable: u8 = unsafe { ::std::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let GroupAssigned: u8 = unsafe { ::std::mem::transmute(GroupAssigned) };
            GroupAssigned as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GroupCommitted: u8 = unsafe { ::std::mem::transmute(GroupCommitted) };
            GroupCommitted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GroupAssignmentFixed: u8 = unsafe { ::std::mem::transmute(GroupAssignmentFixed) };
            GroupAssignmentFixed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Fill: u8 = unsafe { ::std::mem::transmute(Fill) };
            Fill as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x6 (6) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    #[doc = "offset: 0x0 (0)"]
    pub Value: [UCHAR; 6usize],
}
#[doc = "0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KWAIT_STATUS_REGISTER {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _KWAIT_STATUS_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KWAIT_STATUS_REGISTER {
    #[inline]
    pub fn State(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_State(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Affinity(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Affinity(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Priority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Priority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Apc(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Apc(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserApc(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UserApc(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Alert(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Alert(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        State: UCHAR,
        Affinity: UCHAR,
        Priority: UCHAR,
        Apc: UCHAR,
        UserApc: UCHAR,
        Alert: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let State: u8 = unsafe { ::std::mem::transmute(State) };
            State as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Affinity: u8 = unsafe { ::std::mem::transmute(Affinity) };
            Affinity as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Priority: u8 = unsafe { ::std::mem::transmute(Priority) };
            Priority as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Apc: u8 = unsafe { ::std::mem::transmute(Apc) };
            Apc as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UserApc: u8 = unsafe { ::std::mem::transmute(UserApc) };
            UserApc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Alert: u8 = unsafe { ::std::mem::transmute(Alert) };
            Alert as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_LINKS {
    #[doc = "offset: 0x0 (0)"]
    pub Parent: *mut _RTL_BALANCED_LINKS,
    #[doc = "offset: 0x4 (4)"]
    pub LeftChild: *mut _RTL_BALANCED_LINKS,
    #[doc = "offset: 0x8 (8)"]
    pub RightChild: *mut _RTL_BALANCED_LINKS,
    #[doc = "offset: 0xc (12)"]
    pub Balance: CHAR,
    #[doc = "offset: 0xd (13)"]
    pub Reserved: [UCHAR; 3usize],
}
impl Default for _RTL_BALANCED_LINKS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTMOBJECT_NAMESPACE_LINK {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _RTL_BALANCED_LINKS,
    #[doc = "offset: 0x10 (16)"]
    pub Expired: UCHAR,
}
impl Default for _KTMOBJECT_NAMESPACE_LINK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x6 (6) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_IDLE_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub PromotePercent: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub DemotePercent: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub PromotePercentBase: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub DemotePercentBase: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub AllowScaling: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub ForceLightIdle: UCHAR,
}
#[doc = "0x2024 (8228) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KiIoAccessMap {
    #[doc = "offset: 0x0 (0)"]
    pub DirectionMap: [UCHAR; 32usize],
    #[doc = "offset: 0x20 (32)"]
    pub IoMap: [UCHAR; 8196usize],
}
impl Default for _KiIoAccessMap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_RB_TREE {
    #[doc = "offset: 0x0 (0)"]
    pub Root: *mut _RTL_BALANCED_NODE,
    pub __bindgen_anon_1: _RTL_RB_TREE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RB_TREE__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x4 (4)"]
    pub Min: *mut _RTL_BALANCED_NODE,
}
impl Default for _RTL_RB_TREE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _RTL_RB_TREE__bindgen_ty_1 {
    #[inline]
    pub fn Encoded(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Encoded(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Encoded: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Encoded: u8 = unsafe { ::std::mem::transmute(Encoded) };
            Encoded as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _RTL_RB_TREE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = "0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt = 2,
    NtProductServer = 3,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_PAGELIST_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub ActiveSpinLock: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub ActiveThreadTree: _RTL_AVL_TREE,
}
impl Default for _MI_PAGELIST_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_COMBINE_PAGE_LISTHEAD {
    #[doc = "offset: 0x0 (0)"]
    pub Table: _RTL_AVL_TREE,
    #[doc = "offset: 0x4 (4)"]
    pub Lock: LONG,
}
impl Default for _MI_COMBINE_PAGE_LISTHEAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_FREE_ENTRY_EXTRA {
    #[doc = "offset: 0x0 (0)"]
    pub TagIndex: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub FreeBackTraceIndex: USHORT,
}
#[doc = "0x8040 (32832) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STACK_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub NumStackTraces: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub TraceCapacity: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub StackTrace: [*mut _OBJECT_REF_TRACE; 16usize],
    #[doc = "offset: 0x44 (68)"]
    pub StackTableHash: [USHORT; 16381usize],
}
impl Default for _STACK_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_NOTIFICATION_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsUSHORT: USHORT,
}
impl Default for _WHEA_NOTIFICATION_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_NOTIFICATION_FLAGS {
    #[inline]
    pub fn PollIntervalRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PollIntervalRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SwitchToPollingThresholdRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SwitchToPollingThresholdRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SwitchToPollingWindowRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SwitchToPollingWindowRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorThresholdRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ErrorThresholdRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorThresholdWindowRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ErrorThresholdWindowRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PollIntervalRW: USHORT,
        SwitchToPollingThresholdRW: USHORT,
        SwitchToPollingWindowRW: USHORT,
        ErrorThresholdRW: USHORT,
        ErrorThresholdWindowRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PollIntervalRW: u16 = unsafe { ::std::mem::transmute(PollIntervalRW) };
            PollIntervalRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SwitchToPollingThresholdRW: u16 =
                unsafe { ::std::mem::transmute(SwitchToPollingThresholdRW) };
            SwitchToPollingThresholdRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SwitchToPollingWindowRW: u16 =
                unsafe { ::std::mem::transmute(SwitchToPollingWindowRW) };
            SwitchToPollingWindowRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ErrorThresholdRW: u16 = unsafe { ::std::mem::transmute(ErrorThresholdRW) };
            ErrorThresholdRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ErrorThresholdWindowRW: u16 =
                unsafe { ::std::mem::transmute(ErrorThresholdWindowRW) };
            ErrorThresholdWindowRW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _AER_BRIDGE_DESCRIPTOR_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsUSHORT: USHORT,
}
impl Default for _AER_BRIDGE_DESCRIPTOR_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _AER_BRIDGE_DESCRIPTOR_FLAGS {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecondaryUncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecondaryUncorrectableErrorSevRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableErrorSevRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecondaryCapsAndControlRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SecondaryCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UncorrectableErrorMaskRW: USHORT,
        UncorrectableErrorSeverityRW: USHORT,
        CorrectableErrorMaskRW: USHORT,
        AdvancedCapsAndControlRW: USHORT,
        SecondaryUncorrectableErrorMaskRW: USHORT,
        SecondaryUncorrectableErrorSevRW: USHORT,
        SecondaryCapsAndControlRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UncorrectableErrorMaskRW: u16 =
                unsafe { ::std::mem::transmute(UncorrectableErrorMaskRW) };
            UncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UncorrectableErrorSeverityRW: u16 =
                unsafe { ::std::mem::transmute(UncorrectableErrorSeverityRW) };
            UncorrectableErrorSeverityRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CorrectableErrorMaskRW: u16 =
                unsafe { ::std::mem::transmute(CorrectableErrorMaskRW) };
            CorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AdvancedCapsAndControlRW: u16 =
                unsafe { ::std::mem::transmute(AdvancedCapsAndControlRW) };
            AdvancedCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SecondaryUncorrectableErrorMaskRW: u16 =
                unsafe { ::std::mem::transmute(SecondaryUncorrectableErrorMaskRW) };
            SecondaryUncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SecondaryUncorrectableErrorSevRW: u16 =
                unsafe { ::std::mem::transmute(SecondaryUncorrectableErrorSevRW) };
            SecondaryUncorrectableErrorSevRW as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SecondaryCapsAndControlRW: u16 =
                unsafe { ::std::mem::transmute(SecondaryCapsAndControlRW) };
            SecondaryCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsUSHORT: USHORT,
}
impl Default for _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UncorrectableErrorMaskRW: USHORT,
        UncorrectableErrorSeverityRW: USHORT,
        CorrectableErrorMaskRW: USHORT,
        AdvancedCapsAndControlRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UncorrectableErrorMaskRW: u16 =
                unsafe { ::std::mem::transmute(UncorrectableErrorMaskRW) };
            UncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UncorrectableErrorSeverityRW: u16 =
                unsafe { ::std::mem::transmute(UncorrectableErrorSeverityRW) };
            UncorrectableErrorSeverityRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CorrectableErrorMaskRW: u16 =
                unsafe { ::std::mem::transmute(CorrectableErrorMaskRW) };
            CorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AdvancedCapsAndControlRW: u16 =
                unsafe { ::std::mem::transmute(AdvancedCapsAndControlRW) };
            AdvancedCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsUSHORT: USHORT,
}
impl Default for _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RootErrorCommandRW(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RootErrorCommandRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UncorrectableErrorMaskRW: USHORT,
        UncorrectableErrorSeverityRW: USHORT,
        CorrectableErrorMaskRW: USHORT,
        AdvancedCapsAndControlRW: USHORT,
        RootErrorCommandRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UncorrectableErrorMaskRW: u16 =
                unsafe { ::std::mem::transmute(UncorrectableErrorMaskRW) };
            UncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UncorrectableErrorSeverityRW: u16 =
                unsafe { ::std::mem::transmute(UncorrectableErrorSeverityRW) };
            UncorrectableErrorSeverityRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CorrectableErrorMaskRW: u16 =
                unsafe { ::std::mem::transmute(CorrectableErrorMaskRW) };
            CorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AdvancedCapsAndControlRW: u16 =
                unsafe { ::std::mem::transmute(AdvancedCapsAndControlRW) };
            AdvancedCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RootErrorCommandRW: u16 = unsafe { ::std::mem::transmute(RootErrorCommandRW) };
            RootErrorCommandRW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_IPF_CPE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: UCHAR,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_IPF_CMC_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: UCHAR,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_IPF_MCA_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: UCHAR,
}
#[doc = "0x3 (3) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_XPF_NMI_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER_CREATOR_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub TypeList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub CreatorUniqueProcess: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub CreatorBackTraceIndex: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Reserved1: USHORT,
}
impl Default for _OBJECT_HEADER_CREATOR_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACL {
    #[doc = "offset: 0x0 (0)"]
    pub AclRevision: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Sbz1: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub AclSize: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub AceCount: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Sbz2: USHORT,
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Revision: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Sbz1: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Control: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Owner: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Group: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Sacl: *mut _ACL,
    #[doc = "offset: 0x10 (16)"]
    pub Dacl: *mut _ACL,
}
impl Default for _SECURITY_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SYSTEMTIME {
    #[doc = "offset: 0x0 (0)"]
    pub Year: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Month: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub DayOfWeek: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Day: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Hour: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub Minute: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub Second: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Milliseconds: USHORT,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_IRP_EXT_TRACK_OFFSET_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Validation: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: USHORT,
    pub TrackedOffsetCallback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER,
            arg2: *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER,
            arg3: LONGLONG,
        ),
    >,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEGMENT_HEAP_EXTRA {
    #[doc = "offset: 0x0 (0)"]
    pub AllocationTag: USHORT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x3 (3)"]
    pub ExtraSizeInUnits: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Settable: *mut VOID,
}
impl Default for _SEGMENT_HEAP_EXTRA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _SEGMENT_HEAP_EXTRA {
    #[inline]
    pub fn InterceptorIndex(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_InterceptorIndex(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn UserFlags(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_UserFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterceptorIndex: UCHAR,
        UserFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let InterceptorIndex: u8 = unsafe { ::std::mem::transmute(InterceptorIndex) };
            InterceptorIndex as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let UserFlags: u8 = unsafe { ::std::mem::transmute(UserFlags) };
            UserFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PCW_COUNTER_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Id: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub StructIndex: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Offset: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Size: USHORT,
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HV_GET_BIN_CONTEXT {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl _HV_GET_BIN_CONTEXT {
    #[inline]
    pub fn OutstandingReference(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OutstandingReference(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AcquiredRundown(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AcquiredRundown(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OutstandingReference: USHORT,
        AcquiredRundown: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OutstandingReference: u16 = unsafe { ::std::mem::transmute(OutstandingReference) };
            OutstandingReference as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AcquiredRundown: u16 = unsafe { ::std::mem::transmute(AcquiredRundown) };
            AcquiredRundown as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMSUBSECTION_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMSUBSECTION_FLAGS {
    #[inline]
    pub fn SubsectionAccessed(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SubsectionAccessed(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn StartingSector4132(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_StartingSector4132(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn SubsectionStatic(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SubsectionStatic(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalMemory(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GlobalMemory(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OnDereferenceList(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OnDereferenceList(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SectorEndOffset(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_SectorEndOffset(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SubsectionAccessed: USHORT,
        Protection: USHORT,
        StartingSector4132: USHORT,
        SubsectionStatic: USHORT,
        GlobalMemory: USHORT,
        Spare: USHORT,
        OnDereferenceList: USHORT,
        SectorEndOffset: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SubsectionAccessed: u16 = unsafe { ::std::mem::transmute(SubsectionAccessed) };
            SubsectionAccessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Protection: u16 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let StartingSector4132: u16 = unsafe { ::std::mem::transmute(StartingSector4132) };
            StartingSector4132 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let SubsectionStatic: u16 = unsafe { ::std::mem::transmute(SubsectionStatic) };
            SubsectionStatic as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let GlobalMemory: u16 = unsafe { ::std::mem::transmute(GlobalMemory) };
            GlobalMemory as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Spare: u16 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let OnDereferenceList: u16 = unsafe { ::std::mem::transmute(OnDereferenceList) };
            OnDereferenceList as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let SectorEndOffset: u16 = unsafe { ::std::mem::transmute(SectorEndOffset) };
            SectorEndOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEGMENT_FLAGS {
    pub __bindgen_anon_1: _SEGMENT_FLAGS__bindgen_ty_1,
    pub __bindgen_anon_2: _SEGMENT_FLAGS__bindgen_ty_2,
    pub __bindgen_anon_3: _SEGMENT_FLAGS__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT_FLAGS__bindgen_ty_1 {
    pub __bindgen_anon_1: _SEGMENT_FLAGS__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Short0: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEGMENT_FLAGS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _SEGMENT_FLAGS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn TotalNumberOfPtes4132(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_TotalNumberOfPtes4132(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare0(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePages(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LargePages(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugSymbolsLoaded(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DebugSymbolsLoaded(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteCombined(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WriteCombined(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoCache(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NoCache(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TotalNumberOfPtes4132: USHORT,
        Spare0: USHORT,
        LargePages: USHORT,
        DebugSymbolsLoaded: USHORT,
        WriteCombined: USHORT,
        NoCache: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let TotalNumberOfPtes4132: u16 =
                unsafe { ::std::mem::transmute(TotalNumberOfPtes4132) };
            TotalNumberOfPtes4132 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let Spare0: u16 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LargePages: u16 = unsafe { ::std::mem::transmute(LargePages) };
            LargePages as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let DebugSymbolsLoaded: u16 = unsafe { ::std::mem::transmute(DebugSymbolsLoaded) };
            DebugSymbolsLoaded as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let WriteCombined: u16 = unsafe { ::std::mem::transmute(WriteCombined) };
            WriteCombined as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NoCache: u16 = unsafe { ::std::mem::transmute(NoCache) };
            NoCache as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SEGMENT_FLAGS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT_FLAGS__bindgen_ty_2 {
    pub __bindgen_anon_1: _SEGMENT_FLAGS__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x2 (2)"]
    pub UChar1: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEGMENT_FLAGS__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SEGMENT_FLAGS__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Unused(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultProtectionMask(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_DefaultProtectionMask(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Binary32(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Binary32(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ContainsDebug(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ContainsDebug(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Unused: UCHAR,
        DefaultProtectionMask: UCHAR,
        Binary32: UCHAR,
        ContainsDebug: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Unused: u8 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let DefaultProtectionMask: u8 = unsafe { ::std::mem::transmute(DefaultProtectionMask) };
            DefaultProtectionMask as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Binary32: u8 = unsafe { ::std::mem::transmute(Binary32) };
            Binary32 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ContainsDebug: u8 = unsafe { ::std::mem::transmute(ContainsDebug) };
            ContainsDebug as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SEGMENT_FLAGS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT_FLAGS__bindgen_ty_3 {
    pub __bindgen_anon_1: _SEGMENT_FLAGS__bindgen_ty_3__bindgen_ty_1,
    #[doc = "offset: 0x3 (3)"]
    pub UChar2: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEGMENT_FLAGS__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SEGMENT_FLAGS__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn ForceCollision(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ForceCollision(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageSigningType(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ImageSigningType(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageSigningLevel(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ImageSigningLevel(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ForceCollision: UCHAR,
        ImageSigningType: UCHAR,
        ImageSigningLevel: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ForceCollision: u8 = unsafe { ::std::mem::transmute(ForceCollision) };
            ForceCollision as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let ImageSigningType: u8 = unsafe { ::std::mem::transmute(ImageSigningType) };
            ImageSigningType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ImageSigningLevel: u8 = unsafe { ::std::mem::transmute(ImageSigningLevel) };
            ImageSigningLevel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SEGMENT_FLAGS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SEGMENT_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Buffer: *mut WCHAR,
}
impl Default for _UNICODE_STRING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2 (2) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_REVISION {
    pub __bindgen_anon_1: _WHEA_REVISION__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_REVISION__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub MinorRevision: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub MajorRevision: UCHAR,
}
impl Default for _WHEA_REVISION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXN_PARAMETER_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub TxFsContext: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub TransactionObject: *mut VOID,
}
impl Default for _TXN_PARAMETER_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_FILTER_STRING_TOKEN_ELEMENT {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub String: *mut WCHAR,
}
impl Default for _ETW_FILTER_STRING_TOKEN_ELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_BUFFER_CONTEXT {
    pub __bindgen_anon_1: _ETW_BUFFER_CONTEXT__bindgen_ty_1,
    #[doc = "offset: 0x2 (2)"]
    pub LoggerId: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_BUFFER_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _ETW_BUFFER_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub ProcessorIndex: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_BUFFER_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ProcessorNumber: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Alignment: UCHAR,
}
impl Default for _ETW_BUFFER_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_BUFFER_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_FILTER_STRING_TOKEN {
    #[doc = "offset: 0x0 (0)"]
    pub Count: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Tokens: [_ETW_FILTER_STRING_TOKEN_ELEMENT; 1usize],
}
impl Default for _ETW_FILTER_STRING_TOKEN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INTERFACE {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub InterfaceReference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0xc (12)"]
    pub InterfaceDereference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
impl Default for _INTERFACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMSUPPORT_FLAGS {
    pub __bindgen_anon_1: _MMSUPPORT_FLAGS__bindgen_ty_1,
    #[doc = "offset: 0x2 (2)"]
    pub MemoryPriority: UCHAR,
    pub __bindgen_anon_2: _MMSUPPORT_FLAGS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMSUPPORT_FLAGS__bindgen_ty_1 {
    pub __bindgen_anon_1: _MMSUPPORT_FLAGS__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub u1: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMSUPPORT_FLAGS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _MMSUPPORT_FLAGS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn WorkingSetType(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_WorkingSetType(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn MaximumWorkingSetHard(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MaximumWorkingSetHard(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MinimumWorkingSetHard(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MinimumWorkingSetHard(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SessionMaster(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SessionMaster(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TrimmerState(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TrimmerState(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageStealers(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PageStealers(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WorkingSetType: UCHAR,
        Reserved0: UCHAR,
        MaximumWorkingSetHard: UCHAR,
        MinimumWorkingSetHard: UCHAR,
        SessionMaster: UCHAR,
        TrimmerState: UCHAR,
        Reserved: UCHAR,
        PageStealers: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let WorkingSetType: u8 = unsafe { ::std::mem::transmute(WorkingSetType) };
            WorkingSetType as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let MaximumWorkingSetHard: u8 = unsafe { ::std::mem::transmute(MaximumWorkingSetHard) };
            MaximumWorkingSetHard as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MinimumWorkingSetHard: u8 = unsafe { ::std::mem::transmute(MinimumWorkingSetHard) };
            MinimumWorkingSetHard as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SessionMaster: u8 = unsafe { ::std::mem::transmute(SessionMaster) };
            SessionMaster as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let TrimmerState: u8 = unsafe { ::std::mem::transmute(TrimmerState) };
            TrimmerState as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PageStealers: u8 = unsafe { ::std::mem::transmute(PageStealers) };
            PageStealers as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMSUPPORT_FLAGS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMSUPPORT_FLAGS__bindgen_ty_2 {
    pub __bindgen_anon_1: _MMSUPPORT_FLAGS__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x3 (3)"]
    pub u2: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMSUPPORT_FLAGS__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _MMSUPPORT_FLAGS__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn WsleDeleted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WsleDeleted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SvmEnabled(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SvmEnabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceAge(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ForceAge(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceTrim(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ForceTrim(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NewMaximum(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NewMaximum(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CommitReleaseState(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CommitReleaseState(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WsleDeleted: UCHAR,
        SvmEnabled: UCHAR,
        ForceAge: UCHAR,
        ForceTrim: UCHAR,
        NewMaximum: UCHAR,
        CommitReleaseState: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WsleDeleted: u8 = unsafe { ::std::mem::transmute(WsleDeleted) };
            WsleDeleted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SvmEnabled: u8 = unsafe { ::std::mem::transmute(SvmEnabled) };
            SvmEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ForceAge: u8 = unsafe { ::std::mem::transmute(ForceAge) };
            ForceAge as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ForceTrim: u8 = unsafe { ::std::mem::transmute(ForceTrim) };
            ForceTrim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NewMaximum: u8 = unsafe { ::std::mem::transmute(NewMaximum) };
            NewMaximum as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let CommitReleaseState: u8 = unsafe { ::std::mem::transmute(CommitReleaseState) };
            CommitReleaseState as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMSUPPORT_FLAGS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMSUPPORT_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_PERF_HISTORY_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Utility: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub AffinitizedUtility: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Frequency: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub TaggedPercent: [UCHAR; 2usize],
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KIDTENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Offset: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Selector: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Access: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub ExtendedOffset: USHORT,
}
#[doc = "0x34 (52) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_PMC_SUPPORT {
    #[doc = "offset: 0x0 (0)"]
    pub Source: [_KPROFILE_SOURCE; 8usize],
    #[doc = "offset: 0x20 (32)"]
    pub HookIdCount: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub HookId: [USHORT; 4usize],
    #[doc = "offset: 0x2c (44)"]
    pub CountersCount: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub ProcessorCtrs: [*mut _HAL_PMC_COUNTERS; 1usize],
}
impl Default for _ETW_PMC_SUPPORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Buffer: *mut CHAR,
}
impl Default for _STRING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
    #[doc = "offset: 0x0 (0)"]
    pub Group: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Number: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: UCHAR,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub DescriptorType: _SEP_CACHED_HANDLES_ENTRY_TYPE,
    pub __bindgen_anon_1: _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub PackageSid: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub IsolationPrefix: _UNICODE_STRING,
}
impl Default for _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RELATIVE_SYMLINK_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub ExposedNamespaceLength: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceNameLength: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Reserved: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub InteriorMountPoint: *mut _RELATIVE_SYMLINK_INFO,
    #[doc = "offset: 0xc (12)"]
    pub OpenedName: _UNICODE_STRING,
}
impl Default for _RELATIVE_SYMLINK_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_NAME_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub Name: _UNICODE_STRING,
}
impl Default for _OBJECT_NAME_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_AUDIT_PROCESS_CREATION_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub ImageFileName: *mut _OBJECT_NAME_INFORMATION,
}
impl Default for _SE_AUDIT_PROCESS_CREATION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEP_SILOSTATE {
    #[doc = "offset: 0x0 (0)"]
    pub SystemLogonSession: *mut _SEP_LOGON_SESSION_REFERENCES,
    #[doc = "offset: 0x4 (4)"]
    pub AnonymousLogonSession: *mut _SEP_LOGON_SESSION_REFERENCES,
    #[doc = "offset: 0x8 (8)"]
    pub AnonymousLogonToken: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub AnonymousLogonTokenNoEveryone: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub UncSystemPaths: *mut _UNICODE_STRING,
    #[doc = "offset: 0x14 (20)"]
    pub NgenPaths: *mut _CI_NGEN_PATHS,
}
impl Default for _SEP_SILOSTATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CURDIR {
    #[doc = "offset: 0x0 (0)"]
    pub DosPath: _UNICODE_STRING,
    #[doc = "offset: 0x8 (8)"]
    pub Handle: *mut VOID,
}
impl Default for _CURDIR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER_NAME_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Directory: *mut _OBJECT_DIRECTORY,
    #[doc = "offset: 0x4 (4)"]
    pub Name: _UNICODE_STRING,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: LONG,
}
impl Default for _OBJECT_HEADER_NAME_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xac (172) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_TIME_ZONE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub Bias: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub StandardName: [WCHAR; 32usize],
    #[doc = "offset: 0x44 (68)"]
    pub StandardStart: _TIME_FIELDS,
    #[doc = "offset: 0x54 (84)"]
    pub StandardBias: LONG,
    #[doc = "offset: 0x58 (88)"]
    pub DaylightName: [WCHAR; 32usize],
    #[doc = "offset: 0x98 (152)"]
    pub DaylightStart: _TIME_FIELDS,
    #[doc = "offset: 0xa8 (168)"]
    pub DaylightBias: LONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VACB_LEVEL_REFERENCE {
    #[doc = "offset: 0x0 (0)"]
    pub Reference: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub SpecialReference: LONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_CONTINUE {
    #[doc = "offset: 0x0 (0)"]
    pub ContinueStatus: LONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_PERF_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub TotalActiveSessions: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub TotalBufferMemoryNonPagedPool: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub TotalBufferMemoryPagedPool: LONG,
    #[doc = "offset: 0xc (12)"]
    pub TotalGuidsEnabled: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub TotalGuidsNotEnabled: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub TotalGuidsPreEnabled: LONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub BaseKcb: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x4 (4)"]
    pub PrepareStatus: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub ClonedKcbListHead: _LIST_ENTRY,
}
impl Default for _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_LDW_WORK_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x10 (16)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorStatus: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub Active: LONG,
    #[doc = "offset: 0x1c (28)"]
    pub FreeWhenDone: UCHAR,
}
impl Default for _MI_LDW_WORK_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub GuidCount: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub PoolUsage: [LONG; 2usize],
    #[doc = "offset: 0xc (12)"]
    pub SessionCount: LONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub SignalState: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub WaitListHead: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: LONG,
    #[doc = "offset: 0x0 (0)"]
    pub LockNV: LONG,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Signalling: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Size: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved1: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub TimerType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x2 (2)"]
    pub Hand: UCHAR,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x1 (1)"]
    pub TimerControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Absolute(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Absolute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wake(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Wake(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EncodedTolerableDelay(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_EncodedTolerableDelay(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Absolute: UCHAR,
        Wake: UCHAR,
        EncodedTolerableDelay: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Absolute: u8 = unsafe { ::std::mem::transmute(Absolute) };
            Absolute as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Wake: u8 = unsafe { ::std::mem::transmute(Wake) };
            Wake as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let EncodedTolerableDelay: u8 = unsafe { ::std::mem::transmute(EncodedTolerableDelay) };
            EncodedTolerableDelay as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "offset: 0x3 (3)"]
    pub TimerMiscFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Index(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Index(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Processor(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Processor(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Inserted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Expired(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Expired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Index: UCHAR,
        Processor: UCHAR,
        Inserted: UCHAR,
        Expired: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Index: u8 = unsafe { ::std::mem::transmute(Index) };
            Index as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Processor: u8 = unsafe { ::std::mem::transmute(Processor) };
            Processor as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Inserted: u8 = unsafe { ::std::mem::transmute(Inserted) };
            Inserted as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Expired: u8 = unsafe { ::std::mem::transmute(Expired) };
            Expired as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub Timer2Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    #[doc = "offset: 0x2 (2)"]
    pub Timer2ComponentId: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Timer2RelativeId: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    #[doc = "offset: 0x1 (1)"]
    pub Timer2Flags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Timer2Inserted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Expiring(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Expiring(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2CancelPending(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2CancelPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2SetPending(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2SetPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Running(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Running(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Disabled(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Disabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2ReservedFlags(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Timer2Inserted: UCHAR,
        Timer2Expiring: UCHAR,
        Timer2CancelPending: UCHAR,
        Timer2SetPending: UCHAR,
        Timer2Running: UCHAR,
        Timer2Disabled: UCHAR,
        Timer2ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Timer2Inserted: u8 = unsafe { ::std::mem::transmute(Timer2Inserted) };
            Timer2Inserted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Timer2Expiring: u8 = unsafe { ::std::mem::transmute(Timer2Expiring) };
            Timer2Expiring as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Timer2CancelPending: u8 = unsafe { ::std::mem::transmute(Timer2CancelPending) };
            Timer2CancelPending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Timer2SetPending: u8 = unsafe { ::std::mem::transmute(Timer2SetPending) };
            Timer2SetPending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Timer2Running: u8 = unsafe { ::std::mem::transmute(Timer2Running) };
            Timer2Running as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Timer2Disabled: u8 = unsafe { ::std::mem::transmute(Timer2Disabled) };
            Timer2Disabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Timer2ReservedFlags: u8 = unsafe { ::std::mem::transmute(Timer2ReservedFlags) };
            Timer2ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub QueueType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    #[doc = "offset: 0x2 (2)"]
    pub QueueSize: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub QueueReserved: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    #[doc = "offset: 0x1 (1)"]
    pub QueueControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableIncrement(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableIncrement(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QueueReservedControlFlags(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_QueueReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Abandoned: UCHAR,
        DisableIncrement: UCHAR,
        QueueReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Abandoned: u8 = unsafe { ::std::mem::transmute(Abandoned) };
            Abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableIncrement: u8 = unsafe { ::std::mem::transmute(DisableIncrement) };
            DisableIncrement as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let QueueReservedControlFlags: u8 =
                unsafe { ::std::mem::transmute(QueueReservedControlFlags) };
            QueueReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub ThreadType: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub ThreadReserved: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    #[doc = "offset: 0x3 (3)"]
    pub DebugActive: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    #[doc = "offset: 0x2 (2)"]
    pub ThreadControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CycleProfiling(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CycleProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CounterProfiling(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CounterProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GroupScheduling(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupScheduling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AffinitySet(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AffinitySet(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Tagged(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Tagged(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnergyProfiling(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EnergyProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Instrumented(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Instrumented(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadReservedControlFlags(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ThreadReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CycleProfiling: UCHAR,
        CounterProfiling: UCHAR,
        GroupScheduling: UCHAR,
        AffinitySet: UCHAR,
        Tagged: UCHAR,
        EnergyProfiling: UCHAR,
        Instrumented: UCHAR,
        ThreadReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CycleProfiling: u8 = unsafe { ::std::mem::transmute(CycleProfiling) };
            CycleProfiling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CounterProfiling: u8 = unsafe { ::std::mem::transmute(CounterProfiling) };
            CounterProfiling as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GroupScheduling: u8 = unsafe { ::std::mem::transmute(GroupScheduling) };
            GroupScheduling as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AffinitySet: u8 = unsafe { ::std::mem::transmute(AffinitySet) };
            AffinitySet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Tagged: u8 = unsafe { ::std::mem::transmute(Tagged) };
            Tagged as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EnergyProfiling: u8 = unsafe { ::std::mem::transmute(EnergyProfiling) };
            EnergyProfiling as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Instrumented: u8 = unsafe { ::std::mem::transmute(Instrumented) };
            Instrumented as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ThreadReservedControlFlags: u8 =
                unsafe { ::std::mem::transmute(ThreadReservedControlFlags) };
            ThreadReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub MutantType: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub MutantSize: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub DpcActive: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub MutantReserved: UCHAR,
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KMUTANT {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub MutantListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub OwnerThread: *mut _KTHREAD,
    #[doc = "offset: 0x1c (28)"]
    pub Abandoned: UCHAR,
    #[doc = "offset: 0x1d (29)"]
    pub ApcDisable: UCHAR,
}
impl Default for _KMUTANT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSEMAPHORE {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub Limit: LONG,
}
impl Default for _KSEMAPHORE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPCP_NONPAGED_PORT_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub Semaphore: _KSEMAPHORE,
    #[doc = "offset: 0x14 (20)"]
    pub BackPointer: *mut _LPCP_PORT_OBJECT,
}
impl Default for _LPCP_NONPAGED_PORT_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LPCP_PORT_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub NonPagedPortQueue: *mut _LPCP_NONPAGED_PORT_QUEUE,
    #[doc = "offset: 0x4 (4)"]
    pub Semaphore: *mut _KSEMAPHORE,
    #[doc = "offset: 0x8 (8)"]
    pub ReceiveHead: _LIST_ENTRY,
}
impl Default for _LPCP_PORT_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMDEREFERENCE_SEGMENT_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Semaphore: _KSEMAPHORE,
    #[doc = "offset: 0x14 (20)"]
    pub ControlAreaDeleteListHead: _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub UnusedSegmentDeleteListHead: _LIST_ENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub PagefileExtensionListHead: _LIST_ENTRY,
}
impl Default for _MMDEREFERENCE_SEGMENT_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEVENT {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
}
impl Default for _KEVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KWAIT_CHAIN_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Event: _KEVENT,
}
impl Default for _KWAIT_CHAIN_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_RESUME_WORKITEM {
    #[doc = "offset: 0x0 (0)"]
    pub ResumeCompleteEvent: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
}
impl Default for _MI_RESUME_WORKITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PALPC_PORT_REFERENCE_WAIT_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub DesiredReferenceNoEvent: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub DesiredReferenceNo: LONG,
}
impl Default for _PALPC_PORT_REFERENCE_WAIT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHE_UNINITIALIZE_EVENT {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _CACHE_UNINITIALIZE_EVENT,
    #[doc = "offset: 0x4 (4)"]
    pub Event: _KEVENT,
}
impl Default for _CACHE_UNINITIALIZE_EVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HIVE_WAIT_PACKET {
    #[doc = "offset: 0x0 (0)"]
    pub WakeEvent: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub Status: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub Next: *mut _HIVE_WAIT_PACKET,
}
impl Default for _HIVE_WAIT_PACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Removed: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Reserved: [UCHAR; 3usize],
    #[doc = "offset: 0x4 (4)"]
    pub IoCount: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub RemoveEvent: _KEVENT,
}
impl Default for _IO_REMOVE_LOCK_COMMON_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REMOVE_LOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Common: _IO_REMOVE_LOCK_COMMON_BLOCK,
}
impl Default for _IO_REMOVE_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KGATE {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
}
impl Default for _KGATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMMOD_WRITER_LISTHEAD {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
    pub __bindgen_anon_1: _MMMOD_WRITER_LISTHEAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMMOD_WRITER_LISTHEAD__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub Gate: _KGATE,
    #[doc = "offset: 0x8 (8)"]
    pub Event: _KEVENT,
}
impl Default for _MMMOD_WRITER_LISTHEAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMMOD_WRITER_LISTHEAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION_ZEROING {
    #[doc = "offset: 0x0 (0)"]
    pub PageEvent: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub ThreadActive: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub ThreadPriorityStatic: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub ZeroFreePageSlistMinimum: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub RebalanceZeroFreeWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x28 (40)"]
    pub ThreadCount: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub Gate: _KGATE,
    #[doc = "offset: 0x3c (60)"]
    pub ThreadContext: *mut _MI_ZERO_THREAD_CONTEXT,
}
impl Default for _MI_PARTITION_ZEROING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DOS_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub e_magic: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub e_cblp: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub e_cp: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub e_crlc: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub e_cparhdr: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub e_minalloc: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub e_maxalloc: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub e_ss: USHORT,
    #[doc = "offset: 0x10 (16)"]
    pub e_sp: USHORT,
    #[doc = "offset: 0x12 (18)"]
    pub e_csum: USHORT,
    #[doc = "offset: 0x14 (20)"]
    pub e_ip: USHORT,
    #[doc = "offset: 0x16 (22)"]
    pub e_cs: USHORT,
    #[doc = "offset: 0x18 (24)"]
    pub e_lfarlc: USHORT,
    #[doc = "offset: 0x1a (26)"]
    pub e_ovno: USHORT,
    #[doc = "offset: 0x1c (28)"]
    pub e_res: [USHORT; 4usize],
    #[doc = "offset: 0x24 (36)"]
    pub e_oemid: USHORT,
    #[doc = "offset: 0x26 (38)"]
    pub e_oeminfo: USHORT,
    #[doc = "offset: 0x28 (40)"]
    pub e_res2: [USHORT; 10usize],
    #[doc = "offset: 0x3c (60)"]
    pub e_lfanew: LONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_RESERVATION_CLUSTER_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub EntireInfo: LONG,
}
impl Default for _MI_RESERVATION_CLUSTER_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_RESERVATION_CLUSTER_INFO {
    #[inline]
    pub fn ClusterSize(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_ClusterSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn SequenceNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_SequenceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClusterSize: ULONG,
        SequenceNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let ClusterSize: u32 = unsafe { ::std::mem::transmute(ClusterSize) };
            ClusterSize as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let SequenceNumber: u32 = unsafe { ::std::mem::transmute(SequenceNumber) };
            SequenceNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_FLAGS {
    #[doc = "offset: 0x0 (0)"]
    pub EntireFlags: LONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl Default for _MI_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_FLAGS {
    #[inline]
    pub fn VerifierEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VerifierEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelVerifierEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelVerifierEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePageKernel(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LargePageKernel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StopOn4d(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StopOn4d(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InitializationPhase(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_InitializationPhase(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PageKernelStacks(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageKernelStacks(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CheckZeroPages(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CheckZeroPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessorPrewalks(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessorPrewalks(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessorPostwalks(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessorPostwalks(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoverageBuild(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoverageBuild(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessBitReplacementDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AccessBitReplacementDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CheckExecute(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CheckExecute(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtectedPagesEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProtectedPagesEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecureRelocations(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureRelocations(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StrongPageIdentity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StrongPageIdentity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StrongCodeGuarantees(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StrongCodeGuarantees(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardCodeGuarantees(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardCodeGuarantees(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecutePagePrivilegeRequired(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExecutePagePrivilegeRequired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecureKernelCfgEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureKernelCfgEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FullHvci(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FullHvci(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SlatKernelCodeProtected(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SlatKernelCodeProtected(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BootDebuggerActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BootDebuggerActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VerifierEnabled: ULONG,
        KernelVerifierEnabled: ULONG,
        LargePageKernel: ULONG,
        StopOn4d: ULONG,
        InitializationPhase: ULONG,
        PageKernelStacks: ULONG,
        CheckZeroPages: ULONG,
        ProcessorPrewalks: ULONG,
        ProcessorPostwalks: ULONG,
        CoverageBuild: ULONG,
        AccessBitReplacementDisabled: ULONG,
        CheckExecute: ULONG,
        ProtectedPagesEnabled: ULONG,
        SecureRelocations: ULONG,
        StrongPageIdentity: ULONG,
        StrongCodeGuarantees: ULONG,
        HardCodeGuarantees: ULONG,
        ExecutePagePrivilegeRequired: ULONG,
        SecureKernelCfgEnabled: ULONG,
        FullHvci: ULONG,
        SlatKernelCodeProtected: ULONG,
        BootDebuggerActive: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VerifierEnabled: u32 = unsafe { ::std::mem::transmute(VerifierEnabled) };
            VerifierEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let KernelVerifierEnabled: u32 =
                unsafe { ::std::mem::transmute(KernelVerifierEnabled) };
            KernelVerifierEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LargePageKernel: u32 = unsafe { ::std::mem::transmute(LargePageKernel) };
            LargePageKernel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let StopOn4d: u32 = unsafe { ::std::mem::transmute(StopOn4d) };
            StopOn4d as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let InitializationPhase: u32 = unsafe { ::std::mem::transmute(InitializationPhase) };
            InitializationPhase as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PageKernelStacks: u32 = unsafe { ::std::mem::transmute(PageKernelStacks) };
            PageKernelStacks as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CheckZeroPages: u32 = unsafe { ::std::mem::transmute(CheckZeroPages) };
            CheckZeroPages as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ProcessorPrewalks: u32 = unsafe { ::std::mem::transmute(ProcessorPrewalks) };
            ProcessorPrewalks as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ProcessorPostwalks: u32 = unsafe { ::std::mem::transmute(ProcessorPostwalks) };
            ProcessorPostwalks as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CoverageBuild: u32 = unsafe { ::std::mem::transmute(CoverageBuild) };
            CoverageBuild as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AccessBitReplacementDisabled: u32 =
                unsafe { ::std::mem::transmute(AccessBitReplacementDisabled) };
            AccessBitReplacementDisabled as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let CheckExecute: u32 = unsafe { ::std::mem::transmute(CheckExecute) };
            CheckExecute as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ProtectedPagesEnabled: u32 =
                unsafe { ::std::mem::transmute(ProtectedPagesEnabled) };
            ProtectedPagesEnabled as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let SecureRelocations: u32 = unsafe { ::std::mem::transmute(SecureRelocations) };
            SecureRelocations as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let StrongPageIdentity: u32 = unsafe { ::std::mem::transmute(StrongPageIdentity) };
            StrongPageIdentity as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let StrongCodeGuarantees: u32 = unsafe { ::std::mem::transmute(StrongCodeGuarantees) };
            StrongCodeGuarantees as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let HardCodeGuarantees: u32 = unsafe { ::std::mem::transmute(HardCodeGuarantees) };
            HardCodeGuarantees as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ExecutePagePrivilegeRequired: u32 =
                unsafe { ::std::mem::transmute(ExecutePagePrivilegeRequired) };
            ExecutePagePrivilegeRequired as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let SecureKernelCfgEnabled: u32 =
                unsafe { ::std::mem::transmute(SecureKernelCfgEnabled) };
            SecureKernelCfgEnabled as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let FullHvci: u32 = unsafe { ::std::mem::transmute(FullHvci) };
            FullHvci as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let SlatKernelCodeProtected: u32 =
                unsafe { ::std::mem::transmute(SlatKernelCodeProtected) };
            SlatKernelCodeProtected as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let BootDebuggerActive: u32 = unsafe { ::std::mem::transmute(BootDebuggerActive) };
            BootDebuggerActive as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CALL_HASH_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub CallersAddress: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub CallersCaller: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub CallCount: ULONG,
}
impl Default for _CALL_HASH_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_HEADER_PADDING_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub PaddingAmount: ULONG,
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DEBUG_DIRECTORY {
    #[doc = "offset: 0x0 (0)"]
    pub Characteristics: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TimeDateStamp: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MajorVersion: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub MinorVersion: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub Type: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SizeOfData: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub AddressOfRawData: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PointerToRawData: ULONG,
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NB10 {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TimeStamp: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Age: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub PdbName: [CHAR; 1usize],
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_UCR_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub SegmentEntry: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub Address: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub Size: ULONG,
}
impl Default for _HEAP_UCR_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POOL_HEADER {
    pub __bindgen_anon_1: _POOL_HEADER__bindgen_ty_1,
    pub __bindgen_anon_2: _POOL_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POOL_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _POOL_HEADER__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Ulong1: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POOL_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _POOL_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn PreviousSize(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_PreviousSize(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolIndex(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_PoolIndex(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn BlockSize(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_BlockSize(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolType(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_PoolType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PreviousSize: USHORT,
        PoolIndex: USHORT,
        BlockSize: USHORT,
        PoolType: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let PreviousSize: u16 = unsafe { ::std::mem::transmute(PreviousSize) };
            PreviousSize as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let PoolIndex: u16 = unsafe { ::std::mem::transmute(PoolIndex) };
            PoolIndex as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let BlockSize: u16 = unsafe { ::std::mem::transmute(BlockSize) };
            BlockSize as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let PoolType: u16 = unsafe { ::std::mem::transmute(PoolType) };
            PoolType as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _POOL_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POOL_HEADER__bindgen_ty_2 {
    #[doc = "offset: 0x4 (4)"]
    pub PoolTag: ULONG,
    pub __bindgen_anon_1: _POOL_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POOL_HEADER__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub AllocatorBackTraceIndex: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub PoolTagHash: USHORT,
}
impl Default for _POOL_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POOL_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Name: [UCHAR; 8usize],
    #[doc = "offset: 0x8 (8)"]
    pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub VirtualAddress: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SizeOfRawData: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PointerToRawData: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PointerToRelocations: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub PointerToLinenumbers: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub NumberOfRelocations: USHORT,
    #[doc = "offset: 0x22 (34)"]
    pub NumberOfLinenumbers: USHORT,
    #[doc = "offset: 0x24 (36)"]
    pub Characteristics: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub PhysicalAddress: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub VirtualSize: ULONG,
}
impl Default for _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IMAGE_SECTION_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_SERVICE_TAG_RECORD {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _LDR_SERVICE_TAG_RECORD,
    #[doc = "offset: 0x4 (4)"]
    pub ServiceTag: ULONG,
}
impl Default for _LDR_SERVICE_TAG_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DDAG_NODE {
    #[doc = "offset: 0x0 (0)"]
    pub Modules: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ServiceTagList: *mut _LDR_SERVICE_TAG_RECORD,
    #[doc = "offset: 0xc (12)"]
    pub LoadCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub LoadWhileUnloadingCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub LowestLink: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Dependencies: _LDRP_CSLIST,
    #[doc = "offset: 0x1c (28)"]
    pub IncomingDependencies: _LDRP_CSLIST,
    #[doc = "offset: 0x20 (32)"]
    pub State: _LDR_DDAG_STATE,
    #[doc = "offset: 0x24 (36)"]
    pub CondenseLink: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x28 (40)"]
    pub PreorderNumber: ULONG,
}
impl Default for _LDR_DDAG_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_VAD_SEQUENTIAL_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MI_VAD_SEQUENTIAL_INFO {
    #[inline]
    pub fn Length(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_Length(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn Vpn(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_Vpn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Length: ULONG, Vpn: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let Length: u32 = unsafe { ::std::mem::transmute(Length) };
            Length as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let Vpn: u32 = unsafe { ::std::mem::transmute(Vpn) };
            Vpn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMVAD_FLAGS2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMVAD_FLAGS2 {
    #[inline]
    pub fn FileOffset(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_FileOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn Large(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Large(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TrimBehind(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TrimBehind(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Inherit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Inherit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoValidationNeeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoValidationNeeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PrivateDemandZero(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrivateDemandZero(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FileOffset: ULONG,
        Large: ULONG,
        TrimBehind: ULONG,
        Inherit: ULONG,
        NoValidationNeeded: ULONG,
        PrivateDemandZero: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let FileOffset: u32 = unsafe { ::std::mem::transmute(FileOffset) };
            FileOffset as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let Large: u32 = unsafe { ::std::mem::transmute(Large) };
            Large as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let TrimBehind: u32 = unsafe { ::std::mem::transmute(TrimBehind) };
            TrimBehind as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Inherit: u32 = unsafe { ::std::mem::transmute(Inherit) };
            Inherit as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let NoValidationNeeded: u32 = unsafe { ::std::mem::transmute(NoValidationNeeded) };
            NoValidationNeeded as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let PrivateDemandZero: u32 = unsafe { ::std::mem::transmute(PrivateDemandZero) };
            PrivateDemandZero as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub Revision: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaxThrottle: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub MinThrottle: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub BusyAdjThreshold: UCHAR,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub TimeCheck: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub IncreaseTime: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DecreaseTime: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub IncreasePercent: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub DecreasePercent: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
    #[doc = "offset: 0x7 (7)"]
    pub Spare: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub Flags: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x7 (7)"]
    pub AsUCHAR: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoDomainAccounting(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NoDomainAccounting(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IncreasePolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IncreasePolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DecreasePolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DecreasePolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoDomainAccounting: UCHAR,
        IncreasePolicy: UCHAR,
        DecreasePolicy: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoDomainAccounting: u8 = unsafe { ::std::mem::transmute(NoDomainAccounting) };
            NoDomainAccounting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let IncreasePolicy: u8 = unsafe { ::std::mem::transmute(IncreasePolicy) };
            IncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let DecreasePolicy: u8 = unsafe { ::std::mem::transmute(DecreasePolicy) };
            DecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for PROCESSOR_PERFSTATE_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POOL_TRACKER_BIG_PAGES {
    #[doc = "offset: 0x0 (0)"]
    pub Va: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Key: ULONG,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0xc (12)"]
    pub NumberOfBytes: ULONG,
}
impl _POOL_TRACKER_BIG_PAGES {
    #[inline]
    pub fn Pattern(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Pattern(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_PoolType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn SlushSize(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_SlushSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Pattern: ULONG,
        PoolType: ULONG,
        SlushSize: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Pattern: u32 = unsafe { ::std::mem::transmute(Pattern) };
            Pattern as u64
        });
        __bindgen_bitfield_unit.set(8usize, 12u8, {
            let PoolType: u32 = unsafe { ::std::mem::transmute(PoolType) };
            PoolType as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let SlushSize: u32 = unsafe { ::std::mem::transmute(SlushSize) };
            SlushSize as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x204 (516) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CALL_PERFORMANCE_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub SpinLock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HashTable: [_LIST_ENTRY; 64usize],
}
impl Default for _CALL_PERFORMANCE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PPM_IDLE_SYNCHRONIZATION_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub AsLong: LONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PPM_IDLE_SYNCHRONIZATION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PPM_IDLE_SYNCHRONIZATION_STATE {
    #[inline]
    pub fn RefCount(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_RefCount(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn State(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_State(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RefCount: LONG, State: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let RefCount: u32 = unsafe { ::std::mem::transmute(RefCount) };
            RefCount as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let State: u32 = unsafe { ::std::mem::transmute(State) };
            State as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FAST_LEAF_HINT {
    pub __bindgen_anon_1: _CM_FAST_LEAF_HINT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_FAST_LEAF_HINT__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Characters: [UCHAR; 4usize],
    #[doc = "offset: 0x0 (0)"]
    pub FullHint: ULONG,
}
impl Default for _CM_FAST_LEAF_HINT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_FAST_LEAF_HINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PTE_TRACKER {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Mdl: *mut _MDL,
    #[doc = "offset: 0xc (12)"]
    pub Count: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SystemVa: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub StartVa: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Length: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Page: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x28 (40)"]
    pub StackTrace: [*mut VOID; 7usize],
}
impl Default for _PTE_TRACKER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PTE_TRACKER {
    #[inline]
    pub fn IoMapping(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoMapping(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Matched(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Matched(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheAttribute(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CacheAttribute(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn GuardPte(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuardPte(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoMapping: ULONG,
        Matched: ULONG,
        CacheAttribute: ULONG,
        GuardPte: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoMapping: u32 = unsafe { ::std::mem::transmute(IoMapping) };
            IoMapping as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Matched: u32 = unsafe { ::std::mem::transmute(Matched) };
            Matched as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let CacheAttribute: u32 = unsafe { ::std::mem::transmute(CacheAttribute) };
            CacheAttribute as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let GuardPte: u32 = unsafe { ::std::mem::transmute(GuardPte) };
            GuardPte as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x40f0 (16624) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VI_DEADLOCK_GLOBALS {
    #[doc = "offset: 0x0 (0)"]
    pub TimeAcquire: LONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub TimeRelease: LONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub ResourceDatabase: *mut _LIST_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub ResourceDatabaseCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub ResourceAddressRange: [_VF_ADDRESS_RANGE; 1023usize],
    #[doc = "offset: 0x2010 (8208)"]
    pub ThreadDatabase: *mut _LIST_ENTRY,
    #[doc = "offset: 0x2014 (8212)"]
    pub ThreadDatabaseCount: ULONG,
    #[doc = "offset: 0x2018 (8216)"]
    pub ThreadAddressRange: [_VF_ADDRESS_RANGE; 1023usize],
    #[doc = "offset: 0x4010 (16400)"]
    pub AllocationFailures: ULONG,
    #[doc = "offset: 0x4014 (16404)"]
    pub NodesTrimmedBasedOnAge: ULONG,
    #[doc = "offset: 0x4018 (16408)"]
    pub NodesTrimmedBasedOnCount: ULONG,
    #[doc = "offset: 0x401c (16412)"]
    pub NodesSearched: ULONG,
    #[doc = "offset: 0x4020 (16416)"]
    pub MaxNodesSearched: ULONG,
    #[doc = "offset: 0x4024 (16420)"]
    pub SequenceNumber: ULONG,
    #[doc = "offset: 0x4028 (16424)"]
    pub RecursionDepthLimit: ULONG,
    #[doc = "offset: 0x402c (16428)"]
    pub SearchedNodesLimit: ULONG,
    #[doc = "offset: 0x4030 (16432)"]
    pub DepthLimitHits: ULONG,
    #[doc = "offset: 0x4034 (16436)"]
    pub SearchLimitHits: ULONG,
    #[doc = "offset: 0x4038 (16440)"]
    pub StackLimitHits: ULONG,
    #[doc = "offset: 0x403c (16444)"]
    pub ABC_ACB_Skipped: ULONG,
    #[doc = "offset: 0x4040 (16448)"]
    pub OutOfOrderReleases: ULONG,
    #[doc = "offset: 0x4044 (16452)"]
    pub NodesReleasedOutOfOrder: ULONG,
    #[doc = "offset: 0x4048 (16456)"]
    pub TotalReleases: ULONG,
    #[doc = "offset: 0x404c (16460)"]
    pub RootNodesDeleted: ULONG,
    #[doc = "offset: 0x4050 (16464)"]
    pub ForgetHistoryCounter: ULONG,
    #[doc = "offset: 0x4054 (16468)"]
    pub Instigator: *mut VOID,
    #[doc = "offset: 0x4058 (16472)"]
    pub NumberOfParticipants: ULONG,
    #[doc = "offset: 0x405c (16476)"]
    pub Participant: [*mut _VI_DEADLOCK_NODE; 32usize],
    #[doc = "offset: 0x40dc (16604)"]
    pub ChildrenCountWatermark: LONG,
    #[doc = "offset: 0x40e0 (16608)"]
    pub StackType: _KERNEL_STACK_LIMITS,
    #[doc = "offset: 0x40e4 (16612)"]
    pub StackLowLimit: ULONG,
    #[doc = "offset: 0x40e8 (16616)"]
    pub StackHighLimit: ULONG,
}
impl Default for _VI_DEADLOCK_GLOBALS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LEARNING_MODE_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Settings: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub PermissiveModeEnabled: UCHAR,
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FAST_ERESOURCE_INTERNAL {
    #[doc = "offset: 0x0 (0)"]
    pub SystemResourcesList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ReservedPointer: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub ActiveCount: SHORT,
    #[doc = "offset: 0xe (14)"]
    pub Flag: USHORT,
    #[doc = "offset: 0x10 (16)"]
    pub SharedWaiters: _KWAIT_CHAIN,
    #[doc = "offset: 0x14 (20)"]
    pub ExclusiveWaiters: _KWAIT_CHAIN,
    #[doc = "offset: 0x18 (24)"]
    pub OwnerEntryListHead: _LIST_ENTRY,
    #[doc = "offset: 0x20 (32)"]
    pub ActiveEntries: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ContentionCount: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub NumberOfSharedWaiters: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub NumberOfExclusiveWaiters: ULONG,
    pub __bindgen_anon_1: _FAST_ERESOURCE_INTERNAL__bindgen_ty_1,
    #[doc = "offset: 0x34 (52)"]
    pub SpinLock: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FAST_ERESOURCE_INTERNAL__bindgen_ty_1 {
    #[doc = "offset: 0x30 (48)"]
    pub Address: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub CreatorBackTraceIndex: ULONG,
}
impl Default for _FAST_ERESOURCE_INTERNAL__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _FAST_ERESOURCE_INTERNAL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER {
    #[doc = "offset: 0x0 (0)"]
    pub Size: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CallerType: _REQUESTER_TYPE,
    pub __bindgen_anon_1: _DIAGNOSTIC_BUFFER__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub ReasonOffset: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DIAGNOSTIC_BUFFER__bindgen_ty_1 {
    pub __bindgen_anon_1: _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub ProcessImageNameOffset: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ProcessId: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ServiceTag: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x8 (8)"]
    pub DeviceDescriptionOffset: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DevicePathOffset: ULONG,
}
impl Default for _DIAGNOSTIC_BUFFER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DIAGNOSTIC_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PPM_COORDINATED_SYNCHRONIZATION {
    #[doc = "offset: 0x0 (0)"]
    pub AsLong: LONG,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PPM_COORDINATED_SYNCHRONIZATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PPM_COORDINATED_SYNCHRONIZATION {
    #[inline]
    pub fn EnterProcessor(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_EnterProcessor(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn ExitProcessor(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_ExitProcessor(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Entered(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Entered(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EntryPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_EntryPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnterProcessor: ULONG,
        ExitProcessor: ULONG,
        Transition: ULONG,
        Entered: ULONG,
        EntryPriority: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let EnterProcessor: u32 = unsafe { ::std::mem::transmute(EnterProcessor) };
            EnterProcessor as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let ExitProcessor: u32 = unsafe { ::std::mem::transmute(ExitProcessor) };
            ExitProcessor as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let Transition: u32 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Entered: u32 = unsafe { ::std::mem::transmute(Entered) };
            Entered as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let EntryPriority: u32 = unsafe { ::std::mem::transmute(EntryPriority) };
            EntryPriority as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VI_POOL_ENTRY_INUSE {
    #[doc = "offset: 0x0 (0)"]
    pub VirtualAddress: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub CallingAddress: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub NumberOfBytes: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Tag: ULONG,
}
impl Default for _VI_POOL_ENTRY_INUSE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VI_POOL_PAGE_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub NextPage: *mut _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub VerifierEntry: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Signature: ULONG,
}
impl Default for _VI_POOL_PAGE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_POOL_ENTRY {
    pub __bindgen_anon_1: _VI_POOL_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_POOL_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub PageHeader: _VI_POOL_PAGE_HEADER,
    #[doc = "offset: 0x0 (0)"]
    pub InUse: _VI_POOL_ENTRY_INUSE,
    #[doc = "offset: 0x0 (0)"]
    pub NextFree: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _VI_POOL_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VI_POOL_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_VERIFIER_POOL_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub VerifierPoolEntry: *mut _VI_POOL_ENTRY,
}
impl Default for _MI_VERIFIER_POOL_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_DEVICE_COMPLETION_REQUEST {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceNode: *mut _DEVICE_NODE,
    #[doc = "offset: 0xc (12)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub CompletionState: _PNP_DEVNODE_STATE,
    #[doc = "offset: 0x14 (20)"]
    pub IrpPended: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Status: LONG,
    #[doc = "offset: 0x1c (28)"]
    pub Information: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub ReferenceCount: LONG,
}
impl Default for _PNP_DEVICE_COMPLETION_REQUEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VI_TRACK_IRQL {
    #[doc = "offset: 0x0 (0)"]
    pub Thread: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub OldIrql: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub NewIrql: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub Processor: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub TickCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub StackTrace: [*mut VOID; 5usize],
}
impl Default for _VI_TRACK_IRQL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FrameName: *const CHAR,
}
impl Default for _TEB_ACTIVE_FRAME_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VF_TRACKER {
    #[doc = "offset: 0x0 (0)"]
    pub TrackerFlags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TrackerSize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TrackerIndex: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TraceDepth: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IOP_IRP_EXTENSION_STATUS {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ActivityId: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub IoTracking: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KSTACK_COUNT {
    #[doc = "offset: 0x0 (0)"]
    pub Value: LONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _KSTACK_COUNT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KSTACK_COUNT {
    #[inline]
    pub fn State(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_State(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn StackCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_StackCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(State: ULONG, StackCount: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let State: u32 = unsafe { ::std::mem::transmute(State) };
            State as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let StackCount: u32 = unsafe { ::std::mem::transmute(StackCount) };
            StackCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x94 (148) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_DRIVER_VERIFIER_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Level: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub RaiseIrqls: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub AcquireSpinLocks: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SynchronizeExecutions: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AllocationsAttempted: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub AllocationsSucceeded: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub AllocationsSucceededSpecialPool: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub AllocationsWithNoTag: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub TrimRequests: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Trims: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub AllocationsFailed: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub AllocationsFailedDeliberately: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub Loads: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub Unloads: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub UnTrackedPool: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub UserTrims: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub CurrentPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub CurrentNonPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub PeakPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub PeakNonPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub PagedBytes: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub NonPagedBytes: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub PeakPagedBytes: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub PeakNonPagedBytes: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub BurstAllocationsFailedDeliberately: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub SessionTrims: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub OptionChanges: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub VerifyMode: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub PreviousBucketName: _UNICODE_STRING,
    #[doc = "offset: 0x78 (120)"]
    pub ExecutePoolTypes: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub ExecutePageProtections: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub ExecutePageMappings: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub ExecuteWriteSections: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub SectionAlignmentFailures: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub UnsupportedRelocs: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub IATInExecutableSection: ULONG,
}
impl Default for _MM_DRIVER_VERIFIER_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_ATOM_TABLE_REFERENCE {
    #[doc = "offset: 0x0 (0)"]
    pub LowBoxList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub LowBoxID: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Flags: USHORT,
}
impl Default for _RTL_ATOM_TABLE_REFERENCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_ATOM_TABLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub HashLink: *mut _RTL_ATOM_TABLE_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub HandleIndex: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Atom: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Reference: _RTL_ATOM_TABLE_REFERENCE,
    #[doc = "offset: 0x18 (24)"]
    pub NameLength: UCHAR,
    #[doc = "offset: 0x1a (26)"]
    pub Name: [WCHAR; 1usize],
}
impl Default for _RTL_ATOM_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_ACTION_TRIGGER {
    #[doc = "offset: 0x0 (0)"]
    pub Type: POWER_POLICY_DEVICE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Wait: *mut _POP_TRIGGER_WAIT,
    pub __bindgen_anon_1: _POP_ACTION_TRIGGER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_ACTION_TRIGGER__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub Battery: _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub Button: _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub PercentLevel: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub Type: ULONG,
}
impl Default for _POP_ACTION_TRIGGER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_ACTION_TRIGGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_TRIGGER_WAIT {
    #[doc = "offset: 0x0 (0)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub Status: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub Trigger: *mut _POP_ACTION_TRIGGER,
}
impl Default for _POP_TRIGGER_WAIT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PI_BUS_EXTENSION {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NumberCSNs: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub ReadDataPort: *mut UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub DataPortMapped: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub AddressPort: *mut UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub AddrPortMapped: UCHAR,
    #[doc = "offset: 0x18 (24)"]
    pub CommandPort: *mut UCHAR,
    #[doc = "offset: 0x1c (28)"]
    pub CmdPortMapped: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub NextSlotNumber: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub DeviceList: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x28 (40)"]
    pub CardList: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub PhysicalBusDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x30 (48)"]
    pub FunctionalBusDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x34 (52)"]
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x38 (56)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub SystemPowerState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x40 (64)"]
    pub DevicePowerState: _DEVICE_POWER_STATE,
}
impl Default for _PI_BUS_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_EXTENSION_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub BusExtension: *mut _PI_BUS_EXTENSION,
}
impl Default for _BUS_EXTENSION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THERMAL_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub WaitForUpdate: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub Hibernate: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub Critical: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub ThermalStandby: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub ActivationReasons: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub PassiveLimit: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ActiveLevel: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub OverThrottled: UCHAR,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
    #[doc = "offset: 0x0 (0)"]
    pub Granularity: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Capacity: ULONG,
}
#[doc = "0x4c (76) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_CAPABILITIES {
    #[doc = "offset: 0x0 (0)"]
    pub PowerButtonPresent: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub SleepButtonPresent: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub LidPresent: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub SystemS1: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub SystemS2: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub SystemS3: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub SystemS4: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub SystemS5: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub HiberFilePresent: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub FullWake: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub VideoDimPresent: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub ApmPresent: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub UpsPresent: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub ThermalControl: UCHAR,
    #[doc = "offset: 0xe (14)"]
    pub ProcessorThrottle: UCHAR,
    #[doc = "offset: 0xf (15)"]
    pub ProcessorMinThrottle: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub ProcessorMaxThrottle: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub FastSystemS4: UCHAR,
    #[doc = "offset: 0x12 (18)"]
    pub Hiberboot: UCHAR,
    #[doc = "offset: 0x13 (19)"]
    pub WakeAlarmPresent: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub AoAc: UCHAR,
    #[doc = "offset: 0x15 (21)"]
    pub DiskSpinDown: UCHAR,
    #[doc = "offset: 0x16 (22)"]
    pub HiberFileType: UCHAR,
    #[doc = "offset: 0x17 (23)"]
    pub AoAcConnectivitySupported: UCHAR,
    #[doc = "offset: 0x18 (24)"]
    pub spare3: [UCHAR; 6usize],
    #[doc = "offset: 0x1e (30)"]
    pub SystemBatteriesPresent: UCHAR,
    #[doc = "offset: 0x1f (31)"]
    pub BatteriesAreShortTerm: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
    #[doc = "offset: 0x38 (56)"]
    pub AcOnLineWake: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x3c (60)"]
    pub SoftLidWake: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x40 (64)"]
    pub RtcWake: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x44 (68)"]
    pub MinDeviceWakeState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x48 (72)"]
    pub DefaultLowLatencyWake: _SYSTEM_POWER_STATE,
}
impl Default for SYSTEM_POWER_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_POOL_TRACE {
    #[doc = "offset: 0x0 (0)"]
    pub Address: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0xc (12)"]
    pub StackTrace: [*mut VOID; 13usize],
}
impl Default for _VF_POOL_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_RANGE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Count: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Stamp: ULONG,
}
impl Default for _RTL_RANGE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_AVL_TREE_NODE {
    #[doc = "offset: 0x0 (0)"]
    pub p: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub RangeSize: ULONG,
}
impl Default for _VF_AVL_TREE_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_AVL_TREE_NODE_EX {
    #[doc = "offset: 0x0 (0)"]
    pub Base: _VF_AVL_TREE_NODE,
    #[doc = "offset: 0x8 (8)"]
    pub SessionId: ULONG,
}
impl Default for _VF_AVL_TREE_NODE_EX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub TimeCheck: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DemotePercent: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub PromotePercent: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub Spare: [UCHAR; 2usize],
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub Revision: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub PolicyCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Policy: [PROCESSOR_IDLESTATE_INFO; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    #[doc = "offset: 0x2 (2)"]
    pub AsUSHORT: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    #[inline]
    pub fn AllowScaling(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AllowScaling(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disabled(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Disabled(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowScaling: USHORT,
        Disabled: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowScaling: u16 = unsafe { ::std::mem::transmute(AllowScaling) };
            AllowScaling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Disabled: u16 = unsafe { ::std::mem::transmute(Disabled) };
            Disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for PROCESSOR_IDLESTATE_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HAL_CHANNEL_MEMORY_RANGES {
    #[doc = "offset: 0x0 (0)"]
    pub PageFrameIndex: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MpnId: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Node: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Channel: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub IsPowerManageable: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub DeepPowerState: UCHAR,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HAL_NODE_RANGE {
    #[doc = "offset: 0x0 (0)"]
    pub PageFrameIndex: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Node: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PAE_PAGEINFO {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub PageFrameNumber: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub EntriesInUse: ULONG,
}
impl Default for _PAE_PAGEINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8c (140) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSPTES_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: [_LIST_ENTRY; 16usize],
    #[doc = "offset: 0x80 (128)"]
    pub Count: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub NumberOfEntries: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub NumberOfEntriesPeak: ULONG,
}
impl Default for _SYSPTES_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_IO_CACHE_STATS {
    #[doc = "offset: 0x0 (0)"]
    pub UnusedBlocks: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ActiveCacheMatch: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ActiveCacheOverride: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub UnmappedCacheFlush: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub UnmappedCacheMatch: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub UnmappedCacheConflict: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PermanentIoAttributeConflict: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub PermanentIoNodeConflict: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_RESAVAIL_FAILURES {
    #[doc = "offset: 0x0 (0)"]
    pub Wrap: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NoCharge: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_FORCED_COMMITS {
    #[doc = "offset: 0x0 (0)"]
    pub Regular: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Wrap: ULONG,
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_PROBE_RAISE_TRACKER {
    #[doc = "offset: 0x0 (0)"]
    pub UserRangeInKernel: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FaultFailed: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub WriteFaultFailed: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub LargePageFailed: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub UserAccessToKernelPte: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub BadPageLocation: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub InsufficientCharge: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub PageTableCharge: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub NoPhysicalMapping: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub NoIoReference: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub ProbeFailed: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub PteIsZero: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub StrongCodeWrite: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub ReducedCloneCommitChargeFailed: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub CopyOnWriteAtDispatchNoPages: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub EnclavePageFailed: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MM_SYSTEM_PAGE_COUNTS {
    #[doc = "offset: 0x0 (0)"]
    pub SystemCodePage: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SystemDriverPage: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TotalSystemCodePages: LONG,
    #[doc = "offset: 0xc (12)"]
    pub TotalSystemDriverPages: LONG,
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_POOL_FAILURE_REASONS {
    #[doc = "offset: 0x0 (0)"]
    pub NonPagedNoPtes: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PriorityTooLow: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub NonPagedNoPagesAvailable: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub PagedNoPtes: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SessionPagedNoPtes: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PagedNoPagesAvailable: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub SessionPagedNoPagesAvailable: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub PagedNoCommit: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub SessionPagedNoCommit: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub NonPagedNoResidentAvailable: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub NonPagedNoCommit: ULONG,
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_IO_PAGE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub IoPfnLock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub IoPfnRoot: [_RTL_AVL_TREE; 3usize],
    #[doc = "offset: 0x10 (16)"]
    pub UnusedCachedMaps: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub OldestCacheFlushTimeStamp: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub IoCacheStats: _MI_IO_CACHE_STATS,
    #[doc = "offset: 0x3c (60)"]
    pub InvariantIoSpace: _RTL_AVL_TREE,
}
impl Default for _MI_IO_PAGE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POWER_ACTION_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub Action: POWER_ACTION,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub EventCode: ULONG,
}
impl Default for POWER_ACTION_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_LEVEL {
    #[doc = "offset: 0x0 (0)"]
    pub Enable: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Spare: [UCHAR; 3usize],
    #[doc = "offset: 0x4 (4)"]
    pub BatteryLevel: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub PowerPolicy: POWER_ACTION_POLICY,
    #[doc = "offset: 0x14 (20)"]
    pub MinSystemState: _SYSTEM_POWER_STATE,
}
impl Default for SYSTEM_POWER_LEVEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_ALLOCATION_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub MemoryType: _TYPE_OF_MEMORY,
    #[doc = "offset: 0xc (12)"]
    pub BasePage: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub PageCount: ULONG,
}
impl Default for _MEMORY_ALLOCATION_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_SUSPECT_DRIVER_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Loads: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Unloads: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub BaseName: _UNICODE_STRING,
}
impl Default for _VF_SUSPECT_DRIVER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_STOP_ON_TAG {
    pub __bindgen_anon_1: _HEAP_STOP_ON_TAG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_STOP_ON_TAG__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub HeapAndTagIndex: ULONG,
    pub __bindgen_anon_1: _HEAP_STOP_ON_TAG__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_STOP_ON_TAG__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub TagIndex: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub HeapIndex: USHORT,
}
impl Default for _HEAP_STOP_ON_TAG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_STOP_ON_TAG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_STOP_ON_VALUES {
    #[doc = "offset: 0x0 (0)"]
    pub AllocAddress: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub AllocTag: _HEAP_STOP_ON_TAG,
    #[doc = "offset: 0x8 (8)"]
    pub ReAllocAddress: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ReAllocTag: _HEAP_STOP_ON_TAG,
    #[doc = "offset: 0x10 (16)"]
    pub FreeAddress: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub FreeTag: _HEAP_STOP_ON_TAG,
}
impl Default for _HEAP_STOP_ON_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_BTS_RECORD {
    #[doc = "offset: 0x0 (0)"]
    pub JumpedFrom: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub JumpedTo: *mut VOID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _VF_BTS_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VF_BTS_RECORD {
    #[inline]
    pub fn Unused1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Unused1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Predicted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Predicted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Unused2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Unused1: ULONG,
        Predicted: ULONG,
        Unused2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Unused1: u32 = unsafe { ::std::mem::transmute(Unused1) };
            Unused1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let Predicted: u32 = unsafe { ::std::mem::transmute(Predicted) };
            Predicted as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Unused2: u32 = unsafe { ::std::mem::transmute(Unused2) };
            Unused2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_REF_STACK_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Sequence: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Index: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub NumTraces: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Tag: ULONG,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_NOTIFY_ORDER_LEVEL {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ActiveCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub WaitSleep: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub ReadySleep: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub ReadyS0: _LIST_ENTRY,
    #[doc = "offset: 0x20 (32)"]
    pub WaitS0: _LIST_ENTRY,
}
impl Default for _PO_NOTIFY_ORDER_LEVEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xd0 (208) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_DEVICE_NOTIFY_ORDER {
    #[doc = "offset: 0x0 (0)"]
    pub Locked: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub WarmEjectPdoPointer: *mut *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub OrderLevel: [_PO_NOTIFY_ORDER_LEVEL; 5usize],
}
impl Default for _PO_DEVICE_NOTIFY_ORDER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x104 (260) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_DEVICE_SYS_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub IrpMinor: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub SystemState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x8 (8)"]
    pub SpinLock: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Thread: *mut _KTHREAD,
    #[doc = "offset: 0x10 (16)"]
    pub AbortEvent: *mut _KEVENT,
    #[doc = "offset: 0x14 (20)"]
    pub ReadySemaphore: *mut _KSEMAPHORE,
    #[doc = "offset: 0x18 (24)"]
    pub FinishedSemaphore: *mut _KSEMAPHORE,
    #[doc = "offset: 0x1c (28)"]
    pub Order: _PO_DEVICE_NOTIFY_ORDER,
    #[doc = "offset: 0xec (236)"]
    pub Pending: _LIST_ENTRY,
    #[doc = "offset: 0xf4 (244)"]
    pub Status: LONG,
    #[doc = "offset: 0xf8 (248)"]
    pub FailedDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0xfc (252)"]
    pub Waking: UCHAR,
    #[doc = "offset: 0xfd (253)"]
    pub Cancelled: UCHAR,
    #[doc = "offset: 0xfe (254)"]
    pub IgnoreErrors: UCHAR,
    #[doc = "offset: 0xff (255)"]
    pub IgnoreNotImplemented: UCHAR,
    #[doc = "offset: 0x100 (256)"]
    pub TimeRefreshLockAcquired: UCHAR,
}
impl Default for _POP_DEVICE_SYS_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x19c (412) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPRIQUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub EntryListHead: [_LIST_ENTRY; 32usize],
    #[doc = "offset: 0x110 (272)"]
    pub CurrentCount: [LONG; 32usize],
    #[doc = "offset: 0x190 (400)"]
    pub MaximumCount: ULONG,
    #[doc = "offset: 0x194 (404)"]
    pub ThreadListHead: _LIST_ENTRY,
}
impl Default for _KPRIQUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x19c (412) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRIAGE_EX_WORK_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub WorkPriQueue: _KPRIQUEUE,
}
impl Default for _TRIAGE_EX_WORK_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIAGE_9F_POWER {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Revision: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub IrpList: *mut _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ThreadList: *mut _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub DelayedWorkQueue: *mut _TRIAGE_EX_WORK_QUEUE,
}
impl Default for _TRIAGE_9F_POWER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIAGE_9F_PNP {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Revision: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub CompletionQueue: *mut _TRIAGE_PNP_DEVICE_COMPLETION_QUEUE,
    #[doc = "offset: 0x8 (8)"]
    pub DelayedWorkQueue: *mut _TRIAGE_EX_WORK_QUEUE,
}
impl Default for _TRIAGE_9F_PNP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOCK_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub LockTree: _RTL_AVL_TREE,
    #[doc = "offset: 0x4 (4)"]
    pub LockMdlSwitchedTree: _RTL_AVL_TREE,
    #[doc = "offset: 0x8 (8)"]
    pub Count: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Valid: ULONG,
}
impl Default for _LOCK_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_DEADLOCK_THREAD {
    #[doc = "offset: 0x0 (0)"]
    pub Thread: *mut _KTHREAD,
    #[doc = "offset: 0x4 (4)"]
    pub CurrentSpinNode: *mut _VI_DEADLOCK_NODE,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentOtherNode: *mut _VI_DEADLOCK_NODE,
    pub __bindgen_anon_1: _VI_DEADLOCK_THREAD__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub NodeCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PagingCount: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ThreadUsesEresources: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_THREAD__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _VI_DEADLOCK_THREAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VI_DEADLOCK_THREAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_DEADLOCK_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _VI_DEADLOCK_RESOURCE_TYPE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x8 (8)"]
    pub ResourceAddress: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub ThreadOwner: *mut _VI_DEADLOCK_THREAD,
    #[doc = "offset: 0x10 (16)"]
    pub ResourceList: _LIST_ENTRY,
    pub __bindgen_anon_1: _VI_DEADLOCK_RESOURCE__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub StackTrace: [*mut VOID; 8usize],
    #[doc = "offset: 0x40 (64)"]
    pub LastAcquireTrace: [*mut VOID; 8usize],
    #[doc = "offset: 0x60 (96)"]
    pub LastReleaseTrace: [*mut VOID; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_RESOURCE__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub HashChainList: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _VI_DEADLOCK_RESOURCE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VI_DEADLOCK_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VI_DEADLOCK_RESOURCE {
    #[inline]
    pub fn NodeCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_NodeCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn RecursionCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_RecursionCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NodeCount: ULONG,
        RecursionCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let NodeCount: u32 = unsafe { ::std::mem::transmute(NodeCount) };
            NodeCount as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let RecursionCount: u32 = unsafe { ::std::mem::transmute(RecursionCount) };
            RecursionCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x6c (108) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_DEADLOCK_NODE {
    #[doc = "offset: 0x0 (0)"]
    pub Parent: *mut _VI_DEADLOCK_NODE,
    #[doc = "offset: 0x4 (4)"]
    pub ChildrenList: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub SiblingsList: _LIST_ENTRY,
    pub __bindgen_anon_1: _VI_DEADLOCK_NODE__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub Root: *mut _VI_DEADLOCK_RESOURCE,
    #[doc = "offset: 0x20 (32)"]
    pub ThreadEntry: *mut _VI_DEADLOCK_THREAD,
    #[doc = "offset: 0x24 (36)"]
    pub u1: _VI_DEADLOCK_NODE__bindgen_ty_2,
    #[doc = "offset: 0x28 (40)"]
    pub ChildrenCount: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub StackTrace: [*mut VOID; 8usize],
    #[doc = "offset: 0x4c (76)"]
    pub ParentStackTrace: [*mut VOID; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_NODE__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub ResourceList: _LIST_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _VI_DEADLOCK_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_NODE__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x24 (36)"]
    pub Whole: ULONG,
}
impl Default for _VI_DEADLOCK_NODE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VI_DEADLOCK_NODE__bindgen_ty_2 {
    #[inline]
    pub fn Active(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Active(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OnlyTryAcquireUsed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OnlyTryAcquireUsed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReleasedOutOfOrder(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReleasedOutOfOrder(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SequenceNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_SequenceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Active: ULONG,
        OnlyTryAcquireUsed: ULONG,
        ReleasedOutOfOrder: ULONG,
        SequenceNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Active: u32 = unsafe { ::std::mem::transmute(Active) };
            Active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OnlyTryAcquireUsed: u32 = unsafe { ::std::mem::transmute(OnlyTryAcquireUsed) };
            OnlyTryAcquireUsed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReleasedOutOfOrder: u32 = unsafe { ::std::mem::transmute(ReleasedOutOfOrder) };
            ReleasedOutOfOrder as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let SequenceNumber: u32 = unsafe { ::std::mem::transmute(SequenceNumber) };
            SequenceNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VI_DEADLOCK_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KSYSTEM_TIME {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub High1Time: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub High2Time: LONG,
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Length: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: _WHEA_NOTIFICATION_FLAGS,
    #[doc = "offset: 0x4 (4)"]
    pub u: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Polled: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Interrupt: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x4 (4)"]
    pub LocalInterrupt: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    #[doc = "offset: 0x4 (4)"]
    pub Sci: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    #[doc = "offset: 0x4 (4)"]
    pub Nmi: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x4 (4)"]
    pub Sea: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    #[doc = "offset: 0x4 (4)"]
    pub Sei: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    #[doc = "offset: 0x4 (4)"]
    pub Gsiv: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SwitchToPollingThreshold: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SwitchToPollingWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SwitchToPollingThreshold: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SwitchToPollingWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SwitchToPollingThreshold: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SwitchToPollingWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SwitchToPollingThreshold: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SwitchToPollingWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SwitchToPollingThreshold: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SwitchToPollingWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SwitchToPollingThreshold: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SwitchToPollingWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    #[doc = "offset: 0x0 (0)"]
    pub PollInterval: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SwitchToPollingThreshold: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SwitchToPollingWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorThresholdWindow: ULONG,
}
impl Default for _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WHEA_NOTIFICATION_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCI_SLOT_NUMBER {
    #[doc = "offset: 0x0 (0)"]
    pub u: _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub bits: _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceNumber: ULONG,
        FunctionNumber: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DeviceNumber: u32 = unsafe { ::std::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let FunctionNumber: u32 = unsafe { ::std::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WHEA_PCI_SLOT_NUMBER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XPF_MCE_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _XPF_MCE_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _XPF_MCE_FLAGS {
    #[inline]
    pub fn MCG_CapabilityRW(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCG_CapabilityRW(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCG_GlobalControlRW(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCG_GlobalControlRW(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MCG_CapabilityRW: ULONG,
        MCG_GlobalControlRW: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MCG_CapabilityRW: u32 = unsafe { ::std::mem::transmute(MCG_CapabilityRW) };
            MCG_CapabilityRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MCG_GlobalControlRW: u32 = unsafe { ::std::mem::transmute(MCG_GlobalControlRW) };
            MCG_GlobalControlRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_AER_BRIDGE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Slot: _WHEA_PCI_SLOT_NUMBER,
    #[doc = "offset: 0xc (12)"]
    pub DeviceControl: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Flags: _AER_BRIDGE_DESCRIPTOR_FLAGS,
    #[doc = "offset: 0x10 (16)"]
    pub UncorrectableErrorMask: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub UncorrectableErrorSeverity: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CorrectableErrorMask: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub AdvancedCapsAndControl: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub SecondaryUncorrectableErrorMask: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub SecondaryUncorrectableErrorSev: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub SecondaryCapsAndControl: ULONG,
}
impl Default for _WHEA_AER_BRIDGE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Slot: _WHEA_PCI_SLOT_NUMBER,
    #[doc = "offset: 0xc (12)"]
    pub DeviceControl: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Flags: _AER_ENDPOINT_DESCRIPTOR_FLAGS,
    #[doc = "offset: 0x10 (16)"]
    pub UncorrectableErrorMask: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub UncorrectableErrorSeverity: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CorrectableErrorMask: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub AdvancedCapsAndControl: ULONG,
}
impl Default for _WHEA_AER_ENDPOINT_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Slot: _WHEA_PCI_SLOT_NUMBER,
    #[doc = "offset: 0xc (12)"]
    pub DeviceControl: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Flags: _AER_ROOTPORT_DESCRIPTOR_FLAGS,
    #[doc = "offset: 0x10 (16)"]
    pub UncorrectableErrorMask: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub UncorrectableErrorSeverity: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CorrectableErrorMask: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub AdvancedCapsAndControl: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub RootErrorCommand: ULONG,
}
impl Default for _WHEA_AER_ROOTPORT_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEAP_ERROR_RECORD_WRAPPER_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEAP_ERROR_RECORD_WRAPPER_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEAP_ERROR_RECORD_WRAPPER_FLAGS {
    #[inline]
    pub fn Preallocated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Preallocated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FromPersistentStore(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FromPersistentStore(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PlatformPfaControl(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformPfaControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PlatformDirectedOffline(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformDirectedOffline(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Preallocated: ULONG,
        FromPersistentStore: ULONG,
        PlatformPfaControl: ULONG,
        PlatformDirectedOffline: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Preallocated: u32 = unsafe { ::std::mem::transmute(Preallocated) };
            Preallocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FromPersistentStore: u32 = unsafe { ::std::mem::transmute(FromPersistentStore) };
            FromPersistentStore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PlatformPfaControl: u32 = unsafe { ::std::mem::transmute(PlatformPfaControl) };
            PlatformPfaControl as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PlatformDirectedOffline: u32 =
                unsafe { ::std::mem::transmute(PlatformDirectedOffline) };
            PlatformDirectedOffline as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ERROR_SOURCE_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Count: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub Items: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub InsertLock: _KEVENT,
}
impl Default for _WHEAP_ERROR_SOURCE_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBP_LOOKUP_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Directory: *mut _OBJECT_DIRECTORY,
    #[doc = "offset: 0x4 (4)"]
    pub Object: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub EntryLink: *mut *mut _OBJECT_DIRECTORY_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub HashValue: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub HashIndex: USHORT,
    #[doc = "offset: 0x12 (18)"]
    pub DirectoryLocked: UCHAR,
    #[doc = "offset: 0x13 (19)"]
    pub LockedExclusive: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub LockStateSignature: ULONG,
}
impl Default for _OBP_LOOKUP_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER_AUDIT_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
}
impl Default for _OBJECT_HEADER_AUDIT_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER_QUOTA_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub PagedPoolCharge: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NonPagedPoolCharge: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SecurityDescriptorCharge: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SecurityDescriptorQuotaBlock: *mut VOID,
}
impl Default for _OBJECT_HEADER_QUOTA_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x9c (156) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEP_TOKEN_DIAG_TRACK_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ProcessCid: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub ThreadCid: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub ImageFileName: [UCHAR; 16usize],
    #[doc = "offset: 0x18 (24)"]
    pub CreateMethod: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub CreateTrace: [ULONG; 30usize],
    #[doc = "offset: 0x94 (148)"]
    pub Count: LONG,
    #[doc = "offset: 0x98 (152)"]
    pub CaptureCount: LONG,
}
impl Default for _SEP_TOKEN_DIAG_TRACK_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOP_FILE_OBJECT_EXTENSION {
    #[doc = "offset: 0x0 (0)"]
    pub FoExtFlags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FoExtPerTypeExtension: [*mut VOID; 9usize],
    #[doc = "offset: 0x28 (40)"]
    pub FoIoPriorityHint: _IOP_PRIORITY_HINT,
}
impl Default for _IOP_FILE_OBJECT_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMOTE_PORT_VIEW {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ViewSize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ViewBase: *mut VOID,
}
impl Default for _REMOTE_PORT_VIEW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_EXTENDED_PARSE_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub RestrictedAccessMask: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Silo: *mut _EJOB,
}
impl Default for _OB_EXTENDED_PARSE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_DUMP_CONTROL {
    #[doc = "offset: 0x0 (0)"]
    pub Stream: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Detail: ULONG,
}
impl Default for _OBJECT_DUMP_CONTROL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub RootDirectory: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub ObjectName: *mut _UNICODE_STRING,
    #[doc = "offset: 0xc (12)"]
    pub Attributes: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SecurityQualityOfService: *mut VOID,
}
impl Default for _OBJECT_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_WORK_ON_BEHALF_TICKET {
    #[doc = "offset: 0x0 (0)"]
    pub ThreadId: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ThreadCreationTimeLow: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KALPC_WORK_ON_BEHALF_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Ticket: _ALPC_WORK_ON_BEHALF_TICKET,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SRWLOCK {
    pub __bindgen_anon_1: _RTL_SRWLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_SRWLOCK__bindgen_ty_1 {
    pub __bindgen_anon_1: _RTL_SRWLOCK__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub Ptr: *mut VOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_SRWLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RTL_SRWLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Locked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Locked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waiting(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Waiting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waking(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Waking(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MultipleShared(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleShared(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Shared(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Locked: ULONG,
        Waiting: ULONG,
        Waking: ULONG,
        MultipleShared: ULONG,
        Shared: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Locked: u32 = unsafe { ::std::mem::transmute(Locked) };
            Locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Waiting: u32 = unsafe { ::std::mem::transmute(Waiting) };
            Waiting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Waking: u32 = unsafe { ::std::mem::transmute(Waking) };
            Waking as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MultipleShared: u32 = unsafe { ::std::mem::transmute(MultipleShared) };
            MultipleShared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Shared: u32 = unsafe { ::std::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _RTL_SRWLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTL_SRWLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_DIRECT_EVENT {
    #[doc = "offset: 0x0 (0)"]
    pub Event: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _KALPC_DIRECT_EVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KALPC_DIRECT_EVENT {
    #[inline]
    pub fn Referenced(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Referenced(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Referenced: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Referenced: u32 = unsafe { ::std::mem::transmute(Referenced) };
            Referenced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BLOB_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub CreatedObjects: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DeletedObjects: ULONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BLOB_TYPE {
    #[doc = "offset: 0x0 (0)"]
    pub ResourceId: _BLOB_ID,
    #[doc = "offset: 0x4 (4)"]
    pub PoolTag: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub LookasideIndex: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Counters: *mut _BLOB_COUNTERS,
    #[doc = "offset: 0x14 (20)"]
    pub DeleteProcedure: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0x18 (24)"]
    pub DestroyProcedure: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID) -> LONG>,
    #[doc = "offset: 0x1c (28)"]
    pub UsualSize: ULONG,
}
impl Default for _BLOB_TYPE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_MESSAGE_ATTRIBUTES {
    #[doc = "offset: 0x0 (0)"]
    pub AllocatedAttributes: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ValidAttributes: ULONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PORT_MESSAGE {
    #[doc = "offset: 0x0 (0)"]
    pub u1: _PORT_MESSAGE__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub u2: _PORT_MESSAGE__bindgen_ty_2,
    pub __bindgen_anon_1: _PORT_MESSAGE__bindgen_ty_3,
    #[doc = "offset: 0x10 (16)"]
    pub MessageId: ULONG,
    pub __bindgen_anon_2: _PORT_MESSAGE__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub s1: _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub DataLength: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub TotalLength: SHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_2 {
    #[doc = "offset: 0x4 (4)"]
    pub s2: _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub ZeroInit: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub DataInfoOffset: SHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_3 {
    #[doc = "offset: 0x8 (8)"]
    pub ClientId: _CLIENT_ID,
    #[doc = "offset: 0x8 (8)"]
    pub DoNotUseThisField: f64,
}
impl Default for _PORT_MESSAGE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_4 {
    #[doc = "offset: 0x14 (20)"]
    pub ClientViewSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub CallbackId: ULONG,
}
impl Default for _PORT_MESSAGE__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PORT_MESSAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPCP_MESSAGE {
    pub __bindgen_anon_1: _LPCP_MESSAGE__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub SenderPort: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub RepliedToThread: *mut _ETHREAD,
    #[doc = "offset: 0x10 (16)"]
    pub PortContext: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub Request: _PORT_MESSAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LPCP_MESSAGE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    pub __bindgen_anon_1: _LPCP_MESSAGE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LPCP_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub FreeEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved0: ULONG,
}
impl Default for _LPCP_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LPCP_MESSAGE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LPCP_MESSAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_PSEUDO_TAG_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Allocs: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Frees: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Size: ULONG,
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_TAG_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Allocs: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Frees: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Size: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TagIndex: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub CreatorBackTraceIndex: USHORT,
    #[doc = "offset: 0x10 (16)"]
    pub TagName: [WCHAR; 24usize],
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_EXTENDED_ENTRY {
    pub __bindgen_anon_1: _HEAP_EXTENDED_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub UnusedBytesLength: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub EntryOffset: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub ExtendedBlockSignature: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_EXTENDED_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_EXTENDED_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub InterceptorValue: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_EXTENDED_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub FunctionIndex: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub ContextValue: USHORT,
}
impl Default for _HEAP_EXTENDED_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_EXTENDED_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_UNPACKED_ENTRY {
    pub __bindgen_anon_1: _HEAP_UNPACKED_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub PreviousSize: USHORT,
    pub __bindgen_anon_2: _HEAP_UNPACKED_ENTRY__bindgen_ty_2,
    #[doc = "offset: 0x7 (7)"]
    pub UnusedBytes: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_UNPACKED_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_UNPACKED_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub SubSegmentCode: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_UNPACKED_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub SmallTagIndex: UCHAR,
}
impl Default for _HEAP_UNPACKED_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_UNPACKED_ENTRY__bindgen_ty_2 {
    #[doc = "offset: 0x6 (6)"]
    pub SegmentOffset: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub LFHFlags: UCHAR,
}
impl Default for _HEAP_UNPACKED_ENTRY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_UNPACKED_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_TUNING_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub CommittThresholdShift: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaxPreCommittThreshold: ULONG,
}
#[doc = "0x5c (92) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub TotalMemoryReserved: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TotalMemoryCommitted: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TotalMemoryLargeUCR: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TotalSizeInVirtualBlocks: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub TotalSegments: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub TotalUCRs: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CommittOps: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub DeCommitOps: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub LockAcquires: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub LockCollisions: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub CommitRate: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub DecommittRate: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub CommitFailures: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub InBlockCommitFailures: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub PollIntervalCounter: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub DecommitsSinceLastCheck: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub HeapPollInterval: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub AllocAndFreeOps: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub AllocationIndicesActive: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub InBlockDeccommits: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub InBlockDeccomitSize: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub HighWatermarkSize: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub LastPolledSize: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RUN_ONCE {
    #[doc = "offset: 0x0 (0)"]
    pub Ptr: *mut VOID,
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _RTL_RUN_ONCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _RTL_RUN_ONCE {
    #[inline]
    pub fn State(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_State(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(State: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let State: u32 = unsafe { ::std::mem::transmute(State) };
            State as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_SUBALLOCATOR_CALLBACKS {
    #[doc = "offset: 0x0 (0)"]
    pub Allocate: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Free: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Commit: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Decommit: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ExtendContext: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VACB_LEVEL_ALLOCATION_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub VacbLevelList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub VacbLevelWithBcbListHeads: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub VacbLevelsAllocated: ULONG,
}
impl Default for VACB_LEVEL_ALLOCATION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CC_ASYNC_READ_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub CompletionRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID) -> UCHAR>,
    #[doc = "offset: 0x4 (4)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Mdl: *mut _MDL,
    #[doc = "offset: 0xc (12)"]
    pub RequestorMode: CHAR,
    #[doc = "offset: 0x10 (16)"]
    pub NestingLevel: ULONG,
}
impl Default for _CC_ASYNC_READ_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x194 (404) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASYNC_READ_THREAD_STATS {
    #[doc = "offset: 0x0 (0)"]
    pub CurrentLoad: [ULONG; 101usize],
}
impl Default for _ASYNC_READ_THREAD_STATS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VACB_ARRAY_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub VacbArrayIndex: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MappingCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub HighestMappedIndex: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Reserved: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WRITE_BEHIND_THROUGHPUT {
    #[doc = "offset: 0x0 (0)"]
    pub PagesYetToWrite: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Throughput: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARED_CACHE_MAP_LIST_CURSOR {
    #[doc = "offset: 0x0 (0)"]
    pub SharedCacheMapLinks: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
}
impl Default for _SHARED_CACHE_MAP_LIST_CURSOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PRIVATE_CACHE_MAP_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PRIVATE_CACHE_MAP_FLAGS {
    #[inline]
    pub fn DontUse(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DontUse(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadAheadActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadAheadActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadAheadEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadAheadEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PagePriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PagePriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PipelineReadAheads(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PipelineReadAheads(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Available(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_Available(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DontUse: ULONG,
        ReadAheadActive: ULONG,
        ReadAheadEnabled: ULONG,
        PagePriority: ULONG,
        PipelineReadAheads: ULONG,
        Available: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let DontUse: u32 = unsafe { ::std::mem::transmute(DontUse) };
            DontUse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ReadAheadActive: u32 = unsafe { ::std::mem::transmute(ReadAheadActive) };
            ReadAheadActive as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReadAheadEnabled: u32 = unsafe { ::std::mem::transmute(ReadAheadEnabled) };
            ReadAheadEnabled as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let PagePriority: u32 = unsafe { ::std::mem::transmute(PagePriority) };
            PagePriority as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PipelineReadAheads: u32 = unsafe { ::std::mem::transmute(PipelineReadAheads) };
            PipelineReadAheads as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let Available: u32 = unsafe { ::std::mem::transmute(Available) };
            Available as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIRTY_PAGE_STATISTICS {
    #[doc = "offset: 0x0 (0)"]
    pub DirtyPages: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DirtyPagesLastScan: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DirtyPagesScheduledLastScan: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_FX_DEVICE_STATUS {
    #[doc = "offset: 0x0 (0)"]
    pub Value: LONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _POP_FX_DEVICE_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _POP_FX_DEVICE_STATUS {
    #[inline]
    pub fn SystemTransition(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PepD0Notify(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PepD0Notify(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleTimerOn(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IdleTimerOn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreIdleTimeout(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreIdleTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IrpInUse(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IrpInUse(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IrpPending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IrpPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPNRDeviceNotified(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPNRDeviceNotified(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPNRReceivedFromPep(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPNRReceivedFromPep(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IrpFirstPendingIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IrpFirstPendingIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IrpLastPendingIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IrpLastPendingIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SIrpBlocked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SIrpBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BlockFastResume(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BlockFastResume(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SystemTransition: ULONG,
        PepD0Notify: ULONG,
        IdleTimerOn: ULONG,
        IgnoreIdleTimeout: ULONG,
        IrpInUse: ULONG,
        IrpPending: ULONG,
        DPNRDeviceNotified: ULONG,
        DPNRReceivedFromPep: ULONG,
        IrpFirstPendingIndex: ULONG,
        IrpLastPendingIndex: ULONG,
        SIrpBlocked: ULONG,
        BlockFastResume: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SystemTransition: u32 = unsafe { ::std::mem::transmute(SystemTransition) };
            SystemTransition as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PepD0Notify: u32 = unsafe { ::std::mem::transmute(PepD0Notify) };
            PepD0Notify as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IdleTimerOn: u32 = unsafe { ::std::mem::transmute(IdleTimerOn) };
            IdleTimerOn as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IgnoreIdleTimeout: u32 = unsafe { ::std::mem::transmute(IgnoreIdleTimeout) };
            IgnoreIdleTimeout as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let IrpInUse: u32 = unsafe { ::std::mem::transmute(IrpInUse) };
            IrpInUse as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let IrpPending: u32 = unsafe { ::std::mem::transmute(IrpPending) };
            IrpPending as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DPNRDeviceNotified: u32 = unsafe { ::std::mem::transmute(DPNRDeviceNotified) };
            DPNRDeviceNotified as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DPNRReceivedFromPep: u32 = unsafe { ::std::mem::transmute(DPNRReceivedFromPep) };
            DPNRReceivedFromPep as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IrpFirstPendingIndex: u32 = unsafe { ::std::mem::transmute(IrpFirstPendingIndex) };
            IrpFirstPendingIndex as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IrpLastPendingIndex: u32 = unsafe { ::std::mem::transmute(IrpLastPendingIndex) };
            IrpLastPendingIndex as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SIrpBlocked: u32 = unsafe { ::std::mem::transmute(SIrpBlocked) };
            SIrpBlocked as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let BlockFastResume: u32 = unsafe { ::std::mem::transmute(BlockFastResume) };
            BlockFastResume as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_FX_PERF_FLAGS {
    #[doc = "offset: 0x0 (0)"]
    pub Value: LONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _POP_FX_PERF_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _POP_FX_PERF_FLAGS {
    #[inline]
    pub fn Progress(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Progress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn Synchronicity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Synchronicity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RequestPepCompleted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestPepCompleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequestSucceeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestSucceeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NestedCallback(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NestedCallback(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Progress: ULONG,
        Reserved: ULONG,
        Synchronicity: ULONG,
        RequestPepCompleted: ULONG,
        RequestSucceeded: ULONG,
        NestedCallback: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Progress: u32 = unsafe { ::std::mem::transmute(Progress) };
            Progress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 24u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let Synchronicity: u32 = unsafe { ::std::mem::transmute(Synchronicity) };
            Synchronicity as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let RequestPepCompleted: u32 = unsafe { ::std::mem::transmute(RequestPepCompleted) };
            RequestPepCompleted as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let RequestSucceeded: u32 = unsafe { ::std::mem::transmute(RequestSucceeded) };
            RequestSucceeded as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let NestedCallback: u32 = unsafe { ::std::mem::transmute(NestedCallback) };
            NestedCallback as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_FX_COMPONENT_FLAGS {
    pub __bindgen_anon_1: _POP_FX_COMPONENT_FLAGS__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: _POP_FX_COMPONENT_FLAGS__bindgen_ty_2,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_COMPONENT_FLAGS__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Value: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub Value2: LONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_COMPONENT_FLAGS__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _POP_FX_COMPONENT_FLAGS__bindgen_ty_2 {
    #[inline]
    pub fn Active(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Active(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CriticalIdleOverride(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CriticalIdleOverride(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ResidentOverride(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResidentOverride(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Active: ULONG,
        CriticalIdleOverride: ULONG,
        ResidentOverride: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Active: u32 = unsafe { ::std::mem::transmute(Active) };
            Active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CriticalIdleOverride: u32 = unsafe { ::std::mem::transmute(CriticalIdleOverride) };
            CriticalIdleOverride as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ResidentOverride: u32 = unsafe { ::std::mem::transmute(ResidentOverride) };
            ResidentOverride as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _POP_FX_COMPONENT_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _POP_FX_COMPONENT_FLAGS {
    #[inline]
    pub fn RefCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_RefCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn Idling(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Idling(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RefCount: ULONG, Idling: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let RefCount: u32 = unsafe { ::std::mem::transmute(RefCount) };
            RefCount as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Idling: u32 = unsafe { ::std::mem::transmute(Idling) };
            Idling as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_CPU_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Eax: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Ebx: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Ecx: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Edx: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEP_ACPI_RESOURCE_FLAGS {
    #[doc = "offset: 0x0 (0)"]
    pub AsULong: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PEP_ACPI_RESOURCE_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PEP_ACPI_RESOURCE_FLAGS {
    #[inline]
    pub fn Shared(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wake(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wake(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ResourceUsage(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResourceUsage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SlaveMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SlaveMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AddressingMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AddressingMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SharedMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Shared: ULONG,
        Wake: ULONG,
        ResourceUsage: ULONG,
        SlaveMode: ULONG,
        AddressingMode: ULONG,
        SharedMode: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Shared: u32 = unsafe { ::std::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Wake: u32 = unsafe { ::std::mem::transmute(Wake) };
            Wake as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ResourceUsage: u32 = unsafe { ::std::mem::transmute(ResourceUsage) };
            ResourceUsage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SlaveMode: u32 = unsafe { ::std::mem::transmute(SlaveMode) };
            SlaveMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AddressingMode: u32 = unsafe { ::std::mem::transmute(AddressingMode) };
            AddressingMode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SharedMode: u32 = unsafe { ::std::mem::transmute(SharedMode) };
            SharedMode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_SPB_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _PEP_ACPI_RESOURCE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: _PEP_ACPI_RESOURCE_FLAGS,
    #[doc = "offset: 0x8 (8)"]
    pub TypeSpecificFlags: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub ResourceSourceIndex: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub ResourceSourceName: *mut _UNICODE_STRING,
    #[doc = "offset: 0x10 (16)"]
    pub VendorData: *mut CHAR,
    #[doc = "offset: 0x14 (20)"]
    pub VendorDataLength: USHORT,
}
impl Default for _PEP_ACPI_SPB_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_GPIO_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _PEP_ACPI_RESOURCE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: _PEP_ACPI_RESOURCE_FLAGS,
    #[doc = "offset: 0x8 (8)"]
    pub InterruptType: _KINTERRUPT_MODE,
    #[doc = "offset: 0xc (12)"]
    pub InterruptPolarity: _KINTERRUPT_POLARITY,
    #[doc = "offset: 0x10 (16)"]
    pub PinConfig: _GPIO_PIN_CONFIG_TYPE,
    #[doc = "offset: 0x14 (20)"]
    pub IoRestrictionType: _GPIO_PIN_IORESTRICTION_TYPE,
    #[doc = "offset: 0x18 (24)"]
    pub DriveStrength: USHORT,
    #[doc = "offset: 0x1a (26)"]
    pub DebounceTimeout: USHORT,
    #[doc = "offset: 0x1c (28)"]
    pub PinTable: *mut USHORT,
    #[doc = "offset: 0x20 (32)"]
    pub PinCount: USHORT,
    #[doc = "offset: 0x22 (34)"]
    pub ResourceSourceIndex: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub ResourceSourceName: *mut _UNICODE_STRING,
    #[doc = "offset: 0x28 (40)"]
    pub VendorData: *mut UCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub VendorDataLength: USHORT,
}
impl Default for _PEP_ACPI_GPIO_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_SPB_UART_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub SpbCommon: _PEP_ACPI_SPB_RESOURCE,
    #[doc = "offset: 0x18 (24)"]
    pub BaudRate: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub RxBufferSize: USHORT,
    #[doc = "offset: 0x1e (30)"]
    pub TxBufferSize: USHORT,
    #[doc = "offset: 0x20 (32)"]
    pub Parity: UCHAR,
    #[doc = "offset: 0x21 (33)"]
    pub LinesInUse: UCHAR,
}
impl Default for _PEP_ACPI_SPB_UART_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_SPB_SPI_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub SpbCommon: _PEP_ACPI_SPB_RESOURCE,
    #[doc = "offset: 0x18 (24)"]
    pub ConnectionSpeed: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub DataBitLength: UCHAR,
    #[doc = "offset: 0x1d (29)"]
    pub Phase: UCHAR,
    #[doc = "offset: 0x1e (30)"]
    pub Polarity: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub DeviceSelection: USHORT,
}
impl Default for _PEP_ACPI_SPB_SPI_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_SPB_I2C_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub SpbCommon: _PEP_ACPI_SPB_RESOURCE,
    #[doc = "offset: 0x18 (24)"]
    pub ConnectionSpeed: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub SlaveAddress: USHORT,
}
impl Default for _PEP_ACPI_SPB_I2C_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_GET_VERSION32 {
    #[doc = "offset: 0x0 (0)"]
    pub MajorVersion: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MinorVersion: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub ProtocolVersion: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub KernBase: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub PsLoadedModuleList: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MachineType: USHORT,
    #[doc = "offset: 0x12 (18)"]
    pub ThCallbackStack: USHORT,
    #[doc = "offset: 0x14 (20)"]
    pub NextCallback: USHORT,
    #[doc = "offset: 0x16 (22)"]
    pub FramePointer: USHORT,
    #[doc = "offset: 0x18 (24)"]
    pub KiCallUserMode: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub KeUserCallbackDispatcher: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub BreakpointWithStatus: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub DebuggerDataList: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PPC_DBGKD_CONTROL_SET {
    #[doc = "offset: 0x0 (0)"]
    pub Continue: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CurrentSymbolStart: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentSymbolEnd: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ARMCE_DBGKD_CONTROL_SET {
    #[doc = "offset: 0x0 (0)"]
    pub Continue: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CurrentSymbolStart: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentSymbolEnd: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ARM_DBGKD_CONTROL_SET {
    #[doc = "offset: 0x0 (0)"]
    pub Continue: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CurrentSymbolStart: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentSymbolEnd: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _X86_DBGKD_CONTROL_SET {
    #[doc = "offset: 0x0 (0)"]
    pub TraceFlag: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Dr7: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentSymbolStart: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub CurrentSymbolEnd: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_CONTEXT_EX {
    #[doc = "offset: 0x0 (0)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ByteCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BytesCopied: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_SWITCH_PARTITION {
    #[doc = "offset: 0x0 (0)"]
    pub Partition: ULONG,
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_GET_SET_BUS_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub BusDataType: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SlotNumber: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Length: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_READ_WRITE_MSR {
    #[doc = "offset: 0x0 (0)"]
    pub Msr: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DataValueLow: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DataValueHigh: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_BREAKPOINTEX {
    #[doc = "offset: 0x0 (0)"]
    pub BreakPointCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ContinueStatus: LONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_QUERY_SPECIAL_CALLS {
    #[doc = "offset: 0x0 (0)"]
    pub NumberOfSpecialCalls: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_RESTORE_BREAKPOINT {
    #[doc = "offset: 0x0 (0)"]
    pub BreakPointHandle: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_SET_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub ContextFlags: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_GET_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Unused: ULONG,
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_GET_INTERNAL_BREAKPOINT32 {
    #[doc = "offset: 0x0 (0)"]
    pub BreakpointAddress: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Calls: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub MaxCallsPerPeriod: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MinInstructions: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub MaxInstructions: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub TotalInstructions: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_SET_INTERNAL_BREAKPOINT32 {
    #[doc = "offset: 0x0 (0)"]
    pub BreakpointAddress: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_SET_SPECIAL_CALL32 {
    #[doc = "offset: 0x0 (0)"]
    pub SpecialCall: ULONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_READ_WRITE_IO_EXTENDED32 {
    #[doc = "offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub InterfaceType: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AddressSpace: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub IoAddress: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub DataValue: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_READ_WRITE_IO32 {
    #[doc = "offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub IoAddress: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DataValue: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_WRITE_BREAKPOINT32 {
    #[doc = "offset: 0x0 (0)"]
    pub BreakPointAddress: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub BreakPointHandle: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_WRITE_MEMORY32 {
    #[doc = "offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TransferCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ActualBytesWritten: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_READ_MEMORY32 {
    #[doc = "offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TransferCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ActualBytesRead: ULONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_LOAD_SYMBOLS32 {
    #[doc = "offset: 0x0 (0)"]
    pub PathNameLength: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub BaseOfDll: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ProcessId: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub CheckSum: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SizeOfImage: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub UnloadSymbols: UCHAR,
}
#[doc = "0x8c (140) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _X86_KTRAP_FRAME_BLUE {
    #[doc = "offset: 0x0 (0)"]
    pub DbgEbp: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DbgEip: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DbgArgMark: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TempSegCs: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Logging: UCHAR,
    #[doc = "offset: 0xf (15)"]
    pub FrameType: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub TempEsp: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Dr0: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Dr1: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Dr2: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Dr3: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Dr6: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Dr7: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub SegGs: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub SegEs: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub SegDs: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub Edx: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub Ecx: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub Eax: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub PreviousPreviousMode: UCHAR,
    #[doc = "offset: 0x45 (69)"]
    pub EntropyQueueDpc: UCHAR,
    #[doc = "offset: 0x46 (70)"]
    pub Reserved: [UCHAR; 2usize],
    #[doc = "offset: 0x48 (72)"]
    pub MxCsr: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub ExceptionList: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub SegFs: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub Edi: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub Esi: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub Ebx: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub Ebp: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub ErrCode: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub Eip: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub SegCs: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub EFlags: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub HardwareEsp: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub HardwareSegSs: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub V86Es: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub V86Ds: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub V86Fs: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub V86Gs: ULONG,
}
#[doc = "0x8c (140) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _X86_KTRAP_FRAME {
    #[doc = "offset: 0x0 (0)"]
    pub DbgEbp: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DbgEip: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DbgArgMark: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DbgArgPointer: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub TempSegCs: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub TempEsp: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Dr0: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Dr1: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Dr2: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Dr3: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Dr6: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Dr7: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub SegGs: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub SegEs: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub SegDs: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub Edx: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub Ecx: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub Eax: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub PreviousPreviousMode: UCHAR,
    #[doc = "offset: 0x49 (73)"]
    pub EntropyQueueDpc: UCHAR,
    #[doc = "offset: 0x4a (74)"]
    pub Reserved: [UCHAR; 2usize],
    #[doc = "offset: 0x4c (76)"]
    pub ExceptionList: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub SegFs: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub Edi: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub Esi: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub Ebx: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub Ebp: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub ErrCode: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub Eip: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub SegCs: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub EFlags: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub HardwareEsp: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub HardwareSegSs: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub V86Es: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub V86Ds: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub V86Fs: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub V86Gs: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_ASSIGN_RESOURCES_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub IncludeFailedDevices: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceList: [*mut _DEVICE_OBJECT; 1usize],
}
impl Default for _PNP_ASSIGN_RESOURCES_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_DEVICE_COMPLETION_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub DispatchedList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub DispatchedCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub CompletedList: _LIST_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub CompletedSemaphore: _KSEMAPHORE,
    #[doc = "offset: 0x28 (40)"]
    pub SpinLock: ULONG,
}
impl Default for _PNP_DEVICE_COMPLETION_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _STRING32 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Buffer: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CLIENT_ID32 {
    #[doc = "offset: 0x0 (0)"]
    pub UniqueProcess: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub UniqueThread: ULONG,
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionList: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub StackBase: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub StackLimit: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SubSystemTib: ULONG,
    pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub ArbitraryUserPointer: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Self_: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub FiberData: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Version: ULONG,
}
impl Default for _NT_TIB32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NT_TIB32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THERMAL_ZONE_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub Temperature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ThrottleLimit: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ThrottleReasons: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TemperatureHighPrecision: ULONG,
}
#[doc = "0xb8 (184) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYNCH_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub SpinLockAcquireCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SpinLockContentionCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SpinLockSpinCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub IpiSendRequestBroadcastCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub IpiSendRequestRoutineCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub IpiSendSoftwareInterruptCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub ExInitializeResourceCount: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ExReInitializeResourceCount: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ExDeleteResourceCount: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ExecutiveResourceAcquiresCount: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub ExecutiveResourceContentionsCount: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub ExecutiveResourceReleaseExclusiveCount: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub ExecutiveResourceReleaseSharedCount: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub ExecutiveResourceConvertsCount: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub ExAcqResExclusiveAttempts: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub ExAcqResExclusiveAcquiresExclusive: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub ExAcqResExclusiveAcquiresExclusiveRecursive: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub ExAcqResExclusiveWaits: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub ExAcqResExclusiveNotAcquires: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub ExAcqResSharedAttempts: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub ExAcqResSharedAcquiresExclusive: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub ExAcqResSharedAcquiresShared: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub ExAcqResSharedAcquiresSharedRecursive: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub ExAcqResSharedWaits: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub ExAcqResSharedNotAcquires: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub ExAcqResSharedStarveExclusiveAttempts: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub ExAcqResSharedStarveExclusiveAcquiresExclusive: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub ExAcqResSharedStarveExclusiveAcquiresShared: ULONG,
    #[doc = "offset: 0x70\n (112)"]
    pub ExAcqResSharedStarveExclusiveAcquiresSharedRecursive: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub ExAcqResSharedStarveExclusiveWaits: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub ExAcqResSharedStarveExclusiveNotAcquires: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub ExAcqResSharedWaitForExclusiveAttempts: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub ExAcqResSharedWaitForExclusiveAcquiresExclusive: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub ExAcqResSharedWaitForExclusiveAcquiresShared: ULONG,
    #[doc = "offset: 0x88\n (136)"]
    pub ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub ExAcqResSharedWaitForExclusiveWaits: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub ExAcqResSharedWaitForExclusiveNotAcquires: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub ExSetResOwnerPointerExclusive: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub ExSetResOwnerPointerSharedNew: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub ExSetResOwnerPointerSharedOld: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub ExTryToAcqExclusiveAttempts: ULONG,
    #[doc = "offset: 0xa4 (164)"]
    pub ExTryToAcqExclusiveAcquires: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub ExBoostExclusiveOwner: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub ExBoostSharedOwners: ULONG,
    #[doc = "offset: 0xb0 (176)"]
    pub ExEtwSynchTrackingNotificationsCount: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub ExEtwSynchTrackingNotificationsAccountedCount: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Data: *const VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
}
impl Default for _PCW_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HCELL {
    #[doc = "offset: 0x0 (0)"]
    pub Size: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub u: _HCELL__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HCELL__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub NewCell: _HCELL__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HCELL__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub u: _HCELL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HCELL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub UserData: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Next: ULONG,
}
impl Default for _HCELL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HCELL__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HCELL__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HCELL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_DIRTY_VECTOR_LOG_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0x4 (4)"]
    pub Operation: _CM_DIRTY_VECTOR_OPERATION,
    #[doc = "offset: 0x8 (8)"]
    pub Data: _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub Stack: [*mut VOID; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub DirtyVectorModifiedContext: _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub DirtyDataCaptureContext: _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x8 (8)"]
    pub Raw: _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub RangeCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SetBitCount: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub Context1: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Context2: ULONG,
}
impl Default for _CM_DIRTY_VECTOR_LOG_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_DIRTY_VECTOR_LOG_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KTMOH_CommitTransaction_Result {
    KTMOH_CommitTransaction_Result = 1,
    KTMOH_RollbackTransaction_Result = 2,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRANSACTION_HISTORY {
    #[doc = "offset: 0x0 (0)"]
    pub RecordType: KTMOH_CommitTransaction_Result,
    #[doc = "offset: 0x4 (4)"]
    pub Payload: ULONG,
}
impl Default for _KTRANSACTION_HISTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_AVL_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub BalancedRoot: _RTL_BALANCED_LINKS,
    #[doc = "offset: 0x10 (16)"]
    pub OrderedPointer: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub WhichOrderedElement: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub NumberGenericTableElements: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub DepthOfTree: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub RestartKey: *mut _RTL_BALANCED_LINKS,
    #[doc = "offset: 0x24 (36)"]
    pub DeleteCount: ULONG,
    pub CompareRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _RTL_AVL_TABLE,
            arg2: *mut VOID,
            arg3: *mut VOID,
        ) -> _RTL_GENERIC_COMPARE_RESULTS,
    >,
    pub AllocateRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _RTL_AVL_TABLE, arg2: ULONG) -> *mut VOID,
    >,
    pub FreeRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _RTL_AVL_TABLE, arg2: *mut VOID)>,
    #[doc = "offset: 0x34 (52)"]
    pub TableContext: *mut VOID,
}
impl Default for _RTL_AVL_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_AVL_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub RtlTable: _RTL_AVL_TABLE,
    #[doc = "offset: 0x38 (56)"]
    pub ReservedNode: *mut _VF_AVL_TREE_NODE,
    #[doc = "offset: 0x3c (60)"]
    pub NodeToFree: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub Lock: LONG,
}
impl Default for _VF_AVL_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VF_AVL_TREE {
    #[doc = "offset: 0x0 (0)"]
    pub NodeRangeSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NodeCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Tables: *mut _VF_AVL_TABLE,
    #[doc = "offset: 0xc (12)"]
    pub TablesNo: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub UseSessionId: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub u1: _VF_AVL_TREE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VF_AVL_TREE__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub NodeSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub UseLookaside: ULONG,
}
impl Default for _VF_AVL_TREE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VF_AVL_TREE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTMOBJECT_NAMESPACE {
    #[doc = "offset: 0x0 (0)"]
    pub Table: _RTL_AVL_TABLE,
    #[doc = "offset: 0x38 (56)"]
    pub Mutex: _KMUTANT,
    #[doc = "offset: 0x58 (88)"]
    pub LinksOffset: USHORT,
    #[doc = "offset: 0x5a (90)"]
    pub GuidOffset: USHORT,
    #[doc = "offset: 0x5c (92)"]
    pub Expired: UCHAR,
}
impl Default for _KTMOBJECT_NAMESPACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_CELL_REMAP_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub OldCell: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NewCell: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_UOW_SET_VALUE_KEY_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub PreparedCell: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub OldValueCell: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub NameLength: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub DataSize: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_UOW_SET_SD_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityCell: ULONG,
}
#[doc = "0x288 (648) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_DIRTY_VECTOR_LOG {
    #[doc = "offset: 0x0 (0)"]
    pub Next: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Log: [_CM_DIRTY_VECTOR_LOG_ENTRY; 16usize],
}
impl Default for _CM_DIRTY_VECTOR_LOG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_WORKITEM {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Private: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub WorkerRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0x10 (16)"]
    pub Parameter: *mut VOID,
}
impl Default for _CM_WORKITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KENLISTMENT_HISTORY {
    #[doc = "offset: 0x0 (0)"]
    pub Notification: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NewState: _KENLISTMENT_STATE,
}
impl Default for _KENLISTMENT_HISTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_TRANS_PTR {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub TransPtr: *mut VOID,
}
impl Default for _CM_TRANS_PTR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_TRANS_PTR {
    #[inline]
    pub fn LightWeight(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LightWeight(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LightWeight: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LightWeight: u32 = unsafe { ::std::mem::transmute(LightWeight) };
            LightWeight as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_COMPONENT_HASH {
    #[doc = "offset: 0x0 (0)"]
    pub Hash: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_INDEX {
    #[doc = "offset: 0x0 (0)"]
    pub Cell: ULONG,
    pub __bindgen_anon_1: _CM_INDEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_INDEX__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub NameHint: _CM_FAST_LEAF_HINT,
    #[doc = "offset: 0x4 (4)"]
    pub HashKey: _CM_COMPONENT_HASH,
}
impl Default for _CM_INDEX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_INDEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_NAME_HASH {
    #[doc = "offset: 0x0 (0)"]
    pub ConvKey: _CM_COMPONENT_HASH,
    #[doc = "offset: 0x4 (4)"]
    pub NextHash: *mut _CM_NAME_HASH,
    #[doc = "offset: 0x8 (8)"]
    pub NameLength: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub Name: [WCHAR; 1usize],
}
impl Default for _CM_NAME_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_NAME_CONTROL_BLOCK {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: _CM_NAME_CONTROL_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_NAME_CONTROL_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub NameHash: _CM_NAME_HASH,
    pub __bindgen_anon_1: _CM_NAME_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_NAME_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub ConvKey: _CM_COMPONENT_HASH,
    #[doc = "offset: 0x8 (8)"]
    pub NextHash: *mut _CM_KEY_HASH,
    #[doc = "offset: 0xc (12)"]
    pub NameLength: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Name: [WCHAR; 1usize],
}
impl Default for _CM_NAME_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_NAME_CONTROL_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_NAME_CONTROL_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_NAME_CONTROL_BLOCK {
    #[inline]
    pub fn Compressed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Compressed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RefCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_RefCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Compressed: ULONG,
        RefCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Compressed: u32 = unsafe { ::std::mem::transmute(Compressed) };
            Compressed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let RefCount: u32 = unsafe { ::std::mem::transmute(RefCount) };
            RefCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_INTENT_LOCK {
    #[doc = "offset: 0x0 (0)"]
    pub OwnerCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub OwnerTable: *mut *mut _CM_KCB_UOW,
}
impl Default for _CM_INTENT_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHED_CHILD_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    pub __bindgen_anon_1: _CACHED_CHILD_LIST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CACHED_CHILD_LIST__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub ValueList: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub RealKcb: *mut _CM_KEY_CONTROL_BLOCK,
}
impl Default for _CACHED_CHILD_LIST__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CACHED_CHILD_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PATH_HASH {
    #[doc = "offset: 0x0 (0)"]
    pub Hash: ULONG,
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
    #[doc = "offset: 0x0 (0)"]
    pub Revision: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Sbz1: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Control: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Owner: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Group: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Sacl: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Dacl: ULONG,
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KEY_SECURITY_CACHE {
    #[doc = "offset: 0x0 (0)"]
    pub Cell: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ConvKey: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub List: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub DescriptorLength: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub RealRefCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Descriptor: _SECURITY_DESCRIPTOR_RELATIVE,
}
impl Default for _CM_KEY_SECURITY_CACHE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KEY_SECURITY_CACHE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Cell: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CachedSecurity: *mut _CM_KEY_SECURITY_CACHE,
}
impl Default for _CM_KEY_SECURITY_CACHE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CHILD_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub List: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_UOW_SET_VALUE_LIST_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub RefCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ValueList: _CHILD_LIST,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_BIG_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Count: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub List: ULONG,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_KEY_SECURITY {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Reserved: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Flink: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Blink: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DescriptorLength: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Descriptor: _SECURITY_DESCRIPTOR_RELATIVE,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_KEY_VALUE {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NameLength: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub DataLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Data: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Type: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x12 (18)"]
    pub Spare: USHORT,
    #[doc = "offset: 0x14 (20)"]
    pub Name: [WCHAR; 1usize],
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CMP_OFFSET_ARRAY {
    #[doc = "offset: 0x0 (0)"]
    pub FileOffset: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DataBuffer: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub DataLength: ULONG,
}
impl Default for CMP_OFFSET_ARRAY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HV_GET_CELL_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Cell: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub BinContext: _HV_GET_BIN_CONTEXT,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_STORE_KEY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub EntireKey: ULONG,
}
impl Default for _MM_STORE_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MM_STORE_KEY {
    #[inline]
    pub fn KeyLow(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_KeyLow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn KeyHigh(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_KeyHigh(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(KeyLow: ULONG, KeyHigh: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let KeyLow: u32 = unsafe { ::std::mem::transmute(KeyLow) };
            KeyLow as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let KeyHigh: u32 = unsafe { ::std::mem::transmute(KeyHigh) };
            KeyHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_SUBSECTION_ENTRY1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MI_SUBSECTION_ENTRY1 {
    #[inline]
    pub fn CrossPartitionReferences(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_CrossPartitionReferences(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn SubsectionMappedLarge(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SubsectionMappedLarge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CrossPartitionReferences: ULONG,
        SubsectionMappedLarge: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let CrossPartitionReferences: u32 =
                unsafe { ::std::mem::transmute(CrossPartitionReferences) };
            CrossPartitionReferences as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let SubsectionMappedLarge: u32 =
                unsafe { ::std::mem::transmute(SubsectionMappedLarge) };
            SubsectionMappedLarge as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMSECURE_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _MMSECURE_FLAGS {
    #[inline]
    pub fn ReadOnly(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadWrite(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecNoChange(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecNoChange(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDelete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDelete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequiresPteReversal(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequiresPteReversal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExclusiveSecure(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExclusiveSecure(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReadOnly: ULONG,
        ReadWrite: ULONG,
        SecNoChange: ULONG,
        NoDelete: ULONG,
        RequiresPteReversal: ULONG,
        ExclusiveSecure: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadWrite: u32 = unsafe { ::std::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SecNoChange: u32 = unsafe { ::std::mem::transmute(SecNoChange) };
            SecNoChange as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoDelete: u32 = unsafe { ::std::mem::transmute(NoDelete) };
            NoDelete as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RequiresPteReversal: u32 = unsafe { ::std::mem::transmute(RequiresPteReversal) };
            RequiresPteReversal as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ExclusiveSecure: u32 = unsafe { ::std::mem::transmute(ExclusiveSecure) };
            ExclusiveSecure as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMADDRESS_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub u1: _MMADDRESS_LIST__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub EndVa: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMADDRESS_LIST__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: _MMSECURE_FLAGS,
    #[doc = "offset: 0x0 (0)"]
    pub FlagsLong: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub StartVa: *mut VOID,
}
impl Default for _MMADDRESS_LIST__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMADDRESS_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_LARGEPAGE_IMAGE_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub LargeImageBias: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Spare: [UCHAR; 3usize],
    #[doc = "offset: 0x4 (4)"]
    pub ActualImageViewSize: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMVAD_FLAGS1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMVAD_FLAGS1 {
    #[inline]
    pub fn CommitCharge(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_CommitCharge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn MemCommit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCommit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CommitCharge: ULONG,
        MemCommit: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let CommitCharge: u32 = unsafe { ::std::mem::transmute(CommitCharge) };
            CommitCharge as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let MemCommit: u32 = unsafe { ::std::mem::transmute(MemCommit) };
            MemCommit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMVAD_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMVAD_FLAGS {
    #[inline]
    pub fn VadType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VadType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferredNode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_PreferredNode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn NoChange(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoChange(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PrivateMemory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrivateMemory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PrivateFixup(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrivateFixup(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ManySubsections(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ManySubsections(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Enclave(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enclave(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeleteInProgress(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeleteInProgress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageSize64K(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageSize64K(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RfgControlStack(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RfgControlStack(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VadType: ULONG,
        Protection: ULONG,
        PreferredNode: ULONG,
        NoChange: ULONG,
        PrivateMemory: ULONG,
        PrivateFixup: ULONG,
        ManySubsections: ULONG,
        Enclave: ULONG,
        DeleteInProgress: ULONG,
        PageSize64K: ULONG,
        RfgControlStack: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VadType: u32 = unsafe { ::std::mem::transmute(VadType) };
            VadType as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Protection: u32 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let PreferredNode: u32 = unsafe { ::std::mem::transmute(PreferredNode) };
            PreferredNode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let NoChange: u32 = unsafe { ::std::mem::transmute(NoChange) };
            NoChange as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PrivateMemory: u32 = unsafe { ::std::mem::transmute(PrivateMemory) };
            PrivateMemory as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PrivateFixup: u32 = unsafe { ::std::mem::transmute(PrivateFixup) };
            PrivateFixup as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ManySubsections: u32 = unsafe { ::std::mem::transmute(ManySubsections) };
            ManySubsections as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Enclave: u32 = unsafe { ::std::mem::transmute(Enclave) };
            Enclave as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let DeleteInProgress: u32 = unsafe { ::std::mem::transmute(DeleteInProgress) };
            DeleteInProgress as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let PageSize64K: u32 = unsafe { ::std::mem::transmute(PageSize64K) };
            PageSize64K as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let RfgControlStack: u32 = unsafe { ::std::mem::transmute(RfgControlStack) };
            RfgControlStack as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MIPFNBLINK {
    pub __bindgen_anon_1: _MIPFNBLINK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MIPFNBLINK__bindgen_ty_1 {
    pub __bindgen_anon_1: _MIPFNBLINK__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub EntireField: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub Lock: LONG,
    pub __bindgen_anon_2: _MIPFNBLINK__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MIPFNBLINK__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MIPFNBLINK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Blink(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Blink(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn TbFlushStamp(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_TbFlushStamp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageBlinkDeleteBit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageBlinkDeleteBit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageBlinkLockBit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageBlinkLockBit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShareCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ShareCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn PageShareCountDeleteBit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageShareCountDeleteBit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageShareCountLockBit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageShareCountLockBit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Blink: ULONG,
        TbFlushStamp: ULONG,
        Unused: ULONG,
        PageBlinkDeleteBit: ULONG,
        PageBlinkLockBit: ULONG,
        ShareCount: ULONG,
        PageShareCountDeleteBit: ULONG,
        PageShareCountLockBit: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let Blink: u32 = unsafe { ::std::mem::transmute(Blink) };
            Blink as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let TbFlushStamp: u32 = unsafe { ::std::mem::transmute(TbFlushStamp) };
            TbFlushStamp as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let Unused: u32 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let PageBlinkDeleteBit: u32 = unsafe { ::std::mem::transmute(PageBlinkDeleteBit) };
            PageBlinkDeleteBit as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let PageBlinkLockBit: u32 = unsafe { ::std::mem::transmute(PageBlinkLockBit) };
            PageBlinkLockBit as u64
        });
        __bindgen_bitfield_unit.set(32usize, 30u8, {
            let ShareCount: u32 = unsafe { ::std::mem::transmute(ShareCount) };
            ShareCount as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let PageShareCountDeleteBit: u32 =
                unsafe { ::std::mem::transmute(PageShareCountDeleteBit) };
            PageShareCountDeleteBit as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let PageShareCountLockBit: u32 =
                unsafe { ::std::mem::transmute(PageShareCountLockBit) };
            PageShareCountLockBit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MIPFNBLINK__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MIPFNBLINK__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn LockNotUsed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_LockNotUsed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn DeleteBit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeleteBit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LockBit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LockBit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LockNotUsed: ULONG,
        DeleteBit: ULONG,
        LockBit: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let LockNotUsed: u32 = unsafe { ::std::mem::transmute(LockNotUsed) };
            LockNotUsed as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let DeleteBit: u32 = unsafe { ::std::mem::transmute(DeleteBit) };
            DeleteBit as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let LockBit: u32 = unsafe { ::std::mem::transmute(LockBit) };
            LockBit as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MIPFNBLINK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MIPFNBLINK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_ACTIVE_PFN {
    pub __bindgen_anon_1: _MI_ACTIVE_PFN__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_ACTIVE_PFN__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Leaf: _MI_ACTIVE_PFN__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub PageTable: _MI_ACTIVE_PFN__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x0 (0)"]
    pub EntireActiveField: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_ACTIVE_PFN__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MI_ACTIVE_PFN__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Tradable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Tradable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NonPagedBuddy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_NonPagedBuddy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Tradable: ULONG,
        NonPagedBuddy: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Tradable: u32 = unsafe { ::std::mem::transmute(Tradable) };
            Tradable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 28u8, {
            let NonPagedBuddy: u32 = unsafe { ::std::mem::transmute(NonPagedBuddy) };
            NonPagedBuddy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_ACTIVE_PFN__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MI_ACTIVE_PFN__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn Tradable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Tradable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WsleAge(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_WsleAge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NonPagedBuddy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_NonPagedBuddy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Tradable: ULONG,
        WsleAge: ULONG,
        NonPagedBuddy: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Tradable: u32 = unsafe { ::std::mem::transmute(Tradable) };
            Tradable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let WsleAge: u32 = unsafe { ::std::mem::transmute(WsleAge) };
            WsleAge as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let NonPagedBuddy: u32 = unsafe { ::std::mem::transmute(NonPagedBuddy) };
            NonPagedBuddy as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MI_ACTIVE_PFN__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_ACTIVE_PFN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECURITY_CONTEXT {
    pub __bindgen_anon_1: _IMAGE_SECURITY_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECURITY_CONTEXT__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub PageHashes: *mut VOID,
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
    pub __bindgen_anon_1: _IMAGE_SECURITY_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_SECURITY_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_SECURITY_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SecurityBeingCreated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SecurityBeingCreated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SecurityMandatory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecurityMandatory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageHashPointer(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_PageHashPointer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SecurityBeingCreated: ULONG,
        SecurityMandatory: ULONG,
        PageHashPointer: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SecurityBeingCreated: u32 = unsafe { ::std::mem::transmute(SecurityBeingCreated) };
            SecurityBeingCreated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SecurityMandatory: u32 = unsafe { ::std::mem::transmute(SecurityMandatory) };
            SecurityMandatory as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let PageHashPointer: u32 = unsafe { ::std::mem::transmute(PageHashPointer) };
            PageHashPointer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _IMAGE_SECURITY_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IMAGE_SECURITY_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_IMAGE_SECURITY_REFERENCE {
    #[doc = "offset: 0x0 (0)"]
    pub DynamicRelocations: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub SecurityContext: _IMAGE_SECURITY_CONTEXT,
    #[doc = "offset: 0x8 (8)"]
    pub StrongImageReference: ULONG,
}
impl Default for _MI_IMAGE_SECURITY_REFERENCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MODWRITER_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _MODWRITER_FLAGS {
    #[inline]
    pub fn KeepForever(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KeepForever(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Networked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Networked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_IoPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ModifiedStoreWrite(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ModifiedStoreWrite(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KeepForever: ULONG,
        Networked: ULONG,
        IoPriority: ULONG,
        ModifiedStoreWrite: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KeepForever: u32 = unsafe { ::std::mem::transmute(KeepForever) };
            KeepForever as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Networked: u32 = unsafe { ::std::mem::transmute(Networked) };
            Networked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let IoPriority: u32 = unsafe { ::std::mem::transmute(IoPriority) };
            IoPriority as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ModifiedStoreWrite: u32 = unsafe { ::std::mem::transmute(ModifiedStoreWrite) };
            ModifiedStoreWrite as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_EXTRA_IMAGE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub SizeOfHeaders: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SizeOfImage: ULONG,
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub TransferAddress: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub ZeroBits: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MaximumStackSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub CommittedStackSize: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SubSystemType: ULONG,
    pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1,
    pub __bindgen_anon_2: _SECTION_IMAGE_INFORMATION__bindgen_ty_2,
    #[doc = "offset: 0x1c (28)"]
    pub ImageCharacteristics: USHORT,
    #[doc = "offset: 0x1e (30)"]
    pub DllCharacteristics: USHORT,
    #[doc = "offset: 0x20 (32)"]
    pub Machine: USHORT,
    #[doc = "offset: 0x22 (34)"]
    pub ImageContainsCode: UCHAR,
    pub __bindgen_anon_3: _SECTION_IMAGE_INFORMATION__bindgen_ty_3,
    #[doc = "offset: 0x24 (36)"]
    pub LoaderFlags: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub ImageFileSize: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub CheckSum: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub SubSystemVersion: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub SubSystemMinorVersion: USHORT,
    #[doc = "offset: 0x16 (22)"]
    pub SubSystemMajorVersion: USHORT,
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
    pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub OperatingSystemVersion: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub MajorOperatingSystemVersion: USHORT,
    #[doc = "offset: 0x1a (26)"]
    pub MinorOperatingSystemVersion: USHORT,
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_3 {
    #[doc = "offset: 0x23 (35)"]
    pub ImageFlags: UCHAR,
    pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn ComPlusNativeReady(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ComPlusNativeReady(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ComPlusILOnly(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ComPlusILOnly(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageDynamicallyRelocated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageDynamicallyRelocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageMappedFlat(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageMappedFlat(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseBelow4gb(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BaseBelow4gb(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ComPlusPrefer32bit(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ComPlusPrefer32bit(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ComPlusNativeReady: UCHAR,
        ComPlusILOnly: UCHAR,
        ImageDynamicallyRelocated: UCHAR,
        ImageMappedFlat: UCHAR,
        BaseBelow4gb: UCHAR,
        ComPlusPrefer32bit: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ComPlusNativeReady: u8 = unsafe { ::std::mem::transmute(ComPlusNativeReady) };
            ComPlusNativeReady as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ComPlusILOnly: u8 = unsafe { ::std::mem::transmute(ComPlusILOnly) };
            ComPlusILOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ImageDynamicallyRelocated: u8 =
                unsafe { ::std::mem::transmute(ImageDynamicallyRelocated) };
            ImageDynamicallyRelocated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ImageMappedFlat: u8 = unsafe { ::std::mem::transmute(ImageMappedFlat) };
            ImageMappedFlat as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BaseBelow4gb: u8 = unsafe { ::std::mem::transmute(BaseBelow4gb) };
            BaseBelow4gb as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ComPlusPrefer32bit: u8 = unsafe { ::std::mem::transmute(ComPlusPrefer32bit) };
            ComPlusPrefer32bit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SECTION_IMAGE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SECTION_IMAGE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub ExportedImageInformation: _SECTION_IMAGE_INFORMATION,
    #[doc = "offset: 0x30 (48)"]
    pub InternalImageInformation: _MI_EXTRA_IMAGE_INFORMATION,
}
impl Default for _MI_SECTION_IMAGE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_CONTROL_AREA_WAIT_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _MI_CONTROL_AREA_WAIT_BLOCK,
    #[doc = "offset: 0x4 (4)"]
    pub WaitReason: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub WaitResponse: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Gate: _KGATE,
}
impl Default for _MI_CONTROL_AREA_WAIT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_DECAY_TIMER_LINKAGE {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MI_DECAY_TIMER_LINKAGE {
    #[inline]
    pub fn Spare0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreviousDecayPfn(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousDecayPfn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NextDecayPfn(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_NextDecayPfn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Spare0: ULONG,
        PreviousDecayPfn: ULONG,
        Spare1: ULONG,
        NextDecayPfn: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Spare0: u32 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let PreviousDecayPfn: u32 = unsafe { ::std::mem::transmute(PreviousDecayPfn) };
            PreviousDecayPfn as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Spare1: u32 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let NextDecayPfn: u32 = unsafe { ::std::mem::transmute(NextDecayPfn) };
            NextDecayPfn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PHYSICAL_MEMORY_RUN {
    #[doc = "offset: 0x0 (0)"]
    pub BasePage: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PageCount: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_DECAY_TIMER_LINK {
    #[doc = "offset: 0x0 (0)"]
    pub u1: _MI_DECAY_TIMER_LINK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_DECAY_TIMER_LINK__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Long: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub e1: _MI_DECAY_TIMER_LINKAGE,
}
impl Default for _MI_DECAY_TIMER_LINK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_DECAY_TIMER_LINK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_AVAILABLE_PAGE_WAIT_STATES {
    #[doc = "offset: 0x0 (0)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub EventSets: ULONG,
}
impl Default for _MI_AVAILABLE_PAGE_WAIT_STATES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PHYSICAL_MEMORY_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub NumberOfRuns: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NumberOfPages: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Run: [_PHYSICAL_MEMORY_RUN; 1usize],
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_PARTITION_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _MI_PARTITION_FLAGS {
    #[inline]
    pub fn BeingDeleted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BeingDeleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageListsInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageListsInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StoreReservedPagesCharged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StoreReservedPagesCharged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PureHoldingPartition(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PureHoldingPartition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BeingDeleted: ULONG,
        PageListsInitialized: ULONG,
        StoreReservedPagesCharged: ULONG,
        PureHoldingPartition: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BeingDeleted: u32 = unsafe { ::std::mem::transmute(BeingDeleted) };
            BeingDeleted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PageListsInitialized: u32 = unsafe { ::std::mem::transmute(PageListsInitialized) };
            PageListsInitialized as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let StoreReservedPagesCharged: u32 =
                unsafe { ::std::mem::transmute(StoreReservedPagesCharged) };
            StoreReservedPagesCharged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PureHoldingPartition: u32 = unsafe { ::std::mem::transmute(PureHoldingPartition) };
            PureHoldingPartition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_PARTITION_COMMIT {
    #[doc = "offset: 0x0 (0)"]
    pub PeakCommitment: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TotalCommitLimitMaximum: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Popups: [LONG; 2usize],
    #[doc = "offset: 0x10 (16)"]
    pub LowCommitThreshold: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub HighCommitThreshold: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub EventLock: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub SystemCommitReserve: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub OverCommit: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_CLONE_BLOCK_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MI_CLONE_BLOCK_FLAGS {
    #[inline]
    pub fn ActualCloneCommit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ActualCloneCommit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn CloneProtection(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_CloneProtection(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActualCloneCommit: ULONG,
        CloneProtection: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let ActualCloneCommit: u32 = unsafe { ::std::mem::transmute(ActualCloneCommit) };
            ActualCloneCommit as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let CloneProtection: u32 = unsafe { ::std::mem::transmute(CloneProtection) };
            CloneProtection as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPFNLIST {
    #[doc = "offset: 0x0 (0)"]
    pub Total: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ListName: _MMLISTS,
    #[doc = "offset: 0x8 (8)"]
    pub Flink: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Blink: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Lock: ULONG,
}
impl Default for _MMPFNLIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_CACHED_PTE {
    pub __bindgen_anon_1: _MI_CACHED_PTE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_CACHED_PTE__bindgen_ty_1 {
    pub __bindgen_anon_1: _MI_CACHED_PTE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Long: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_CACHED_PTE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub GlobalTimeStamp: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PteIndex: ULONG,
}
impl Default for _MI_CACHED_PTE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_CACHED_PTE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
    pub __bindgen_anon_1: _EX_PUSH_LOCK_AUTO_EXPAND_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_PUSH_LOCK_AUTO_EXPAND_STATE__bindgen_ty_1 {
    pub __bindgen_anon_1: _EX_PUSH_LOCK_AUTO_EXPAND_STATE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _EX_PUSH_LOCK_AUTO_EXPAND_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Expanded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Expanded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transitioning(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Transitioning(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Pageable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pageable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Expanded: ULONG,
        Transitioning: ULONG,
        Pageable: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Expanded: u32 = unsafe { ::std::mem::transmute(Expanded) };
            Expanded as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Transitioning: u32 = unsafe { ::std::mem::transmute(Transitioning) };
            Transitioning as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Pageable: u32 = unsafe { ::std::mem::transmute(Pageable) };
            Pageable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EX_PUSH_LOCK_AUTO_EXPAND_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_CHASH_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Key: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CHASH_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Table: *mut _RTL_CHASH_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub EntrySizeShift: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub EntryMax: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub EntryCount: ULONG,
}
impl Default for _RTL_CHASH_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HASH_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub EntryCount: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x8 (8)"]
    pub Buckets: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _RTL_HASH_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _RTL_HASH_TABLE {
    #[inline]
    pub fn MaskBitCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_MaskBitCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn BucketCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_BucketCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MaskBitCount: ULONG,
        BucketCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let MaskBitCount: u32 = unsafe { ::std::mem::transmute(MaskBitCount) };
            MaskBitCount as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let BucketCount: u32 = unsafe { ::std::mem::transmute(BucketCount) };
            BucketCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HASH_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub BucketLink: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Key: ULONG,
}
impl Default for _RTL_HASH_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    #[inline]
    pub fn Primary(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Primary(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ContainmentWarning(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContainmentWarning(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reset(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThresholdExceeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThresholdExceeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ResourceNotAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResourceNotAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LatentError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LatentError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Propagated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Propagated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Primary: ULONG,
        ContainmentWarning: ULONG,
        Reset: ULONG,
        ThresholdExceeded: ULONG,
        ResourceNotAvailable: ULONG,
        LatentError: ULONG,
        Propagated: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Primary: u32 = unsafe { ::std::mem::transmute(Primary) };
            Primary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ContainmentWarning: u32 = unsafe { ::std::mem::transmute(ContainmentWarning) };
            ContainmentWarning as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Reset: u32 = unsafe { ::std::mem::transmute(Reset) };
            Reset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ThresholdExceeded: u32 = unsafe { ::std::mem::transmute(ThresholdExceeded) };
            ThresholdExceeded as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ResourceNotAvailable: u32 = unsafe { ::std::mem::transmute(ResourceNotAvailable) };
            ResourceNotAvailable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LatentError: u32 = unsafe { ::std::mem::transmute(LatentError) };
            LatentError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Propagated: u32 = unsafe { ::std::mem::transmute(Propagated) };
            Propagated as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_HEADER_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_RECORD_HEADER_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_HEADER_FLAGS {
    #[inline]
    pub fn Recovered(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Recovered(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Recovered: ULONG,
        PreviousError: ULONG,
        Simulated: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Recovered: u32 = unsafe { ::std::mem::transmute(Recovered) };
            Recovered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PreviousError: u32 = unsafe { ::std::mem::transmute(PreviousError) };
            PreviousError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Simulated: u32 = unsafe { ::std::mem::transmute(Simulated) };
            Simulated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    #[inline]
    pub fn PlatformId(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timestamp(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Timestamp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PartitionId(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PartitionId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PlatformId: ULONG,
        Timestamp: ULONG,
        PartitionId: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PlatformId: u32 = unsafe { ::std::mem::transmute(PlatformId) };
            PlatformId as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Timestamp: u32 = unsafe { ::std::mem::transmute(Timestamp) };
            Timestamp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PartitionId: u32 = unsafe { ::std::mem::transmute(PartitionId) };
            PartitionId as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_PACKET_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_PACKET_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_PACKET_FLAGS {
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HypervisorError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HypervisorError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PlatformPfaControl(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformPfaControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PlatformDirectedOffline(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformDirectedOffline(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PreviousError: ULONG,
        Reserved1: ULONG,
        HypervisorError: ULONG,
        Simulated: ULONG,
        PlatformPfaControl: ULONG,
        PlatformDirectedOffline: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PreviousError: u32 = unsafe { ::std::mem::transmute(PreviousError) };
            PreviousError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HypervisorError: u32 = unsafe { ::std::mem::transmute(HypervisorError) };
            HypervisorError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Simulated: u32 = unsafe { ::std::mem::transmute(Simulated) };
            Simulated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PlatformPfaControl: u32 = unsafe { ::std::mem::transmute(PlatformPfaControl) };
            PlatformPfaControl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PlatformDirectedOffline: u32 =
                unsafe { ::std::mem::transmute(PlatformDirectedOffline) };
            PlatformDirectedOffline as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved2: u32 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_FLAGS {
    #[doc = "offset: 0x0 (0)"]
    pub File: _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Private: _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn FilePointerIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_FilePointerIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn HardFault(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardFault(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Image(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Image(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilePointerIndex: ULONG,
        HardFault: ULONG,
        Image: ULONG,
        Spare0: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let FilePointerIndex: u32 = unsafe { ::std::mem::transmute(FilePointerIndex) };
            FilePointerIndex as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HardFault: u32 = unsafe { ::std::mem::transmute(HardFault) };
            HardFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Image: u32 = unsafe { ::std::mem::transmute(Image) };
            Image as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Spare0: u32 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_2 {
    #[inline]
    pub fn FilePointerIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_FilePointerIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn HardFault(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardFault(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilePointerIndex: ULONG,
        HardFault: ULONG,
        Spare1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let FilePointerIndex: u32 = unsafe { ::std::mem::transmute(FilePointerIndex) };
            FilePointerIndex as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HardFault: u32 = unsafe { ::std::mem::transmute(HardFault) };
            HardFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let Spare1: u32 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MM_PAGE_ACCESS_INFO_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_PRIORITY_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Size: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ThreadPriority: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub PagePriority: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub IoPriority: _IO_PRIORITY_HINT,
}
impl Default for _IO_PRIORITY_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ECP_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub EcpList: _LIST_ENTRY,
}
impl Default for _ECP_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_DRIVER_CREATE_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Size: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub ExtraCreateParameter: *mut _ECP_LIST,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceObjectHint: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub TxnParameters: *mut _TXN_PARAMETER_BLOCK,
    #[doc = "offset: 0x10 (16)"]
    pub SiloContext: *mut _EJOB,
}
impl Default for _IO_DRIVER_CREATE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_HANDLE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub HandleAttributes: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub GrantedAccess: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    #[doc = "offset: 0x0 (0)"]
    pub GenericRead: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub GenericWrite: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub GenericExecute: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub GenericAll: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_FAST_REF {
    pub __bindgen_anon_1: _EX_FAST_REF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_FAST_REF__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Object: *mut VOID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
}
impl Default for _EX_FAST_REF__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _EX_FAST_REF__bindgen_ty_1 {
    #[inline]
    pub fn RefCnt(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_RefCnt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RefCnt: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let RefCnt: u32 = unsafe { ::std::mem::transmute(RefCnt) };
            RefCnt as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EX_FAST_REF {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXT_DELETE_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DeleteCallback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0xc (12)"]
    pub DeleteContext: *mut VOID,
}
impl Default for _EXT_DELETE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Information: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Status: LONG,
    #[doc = "offset: 0x0 (0)"]
    pub Pointer: *mut VOID,
}
impl Default for _IO_STATUS_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STATUS_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KERNEL_STACK_SEGMENT {
    #[doc = "offset: 0x0 (0)"]
    pub StackBase: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub StackLimit: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub KernelStack: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub InitialStack: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_TYPE {
    pub __bindgen_anon_1: _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1 {
    pub __bindgen_anon_1: _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub AttributeType: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Version: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub DataCount: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub SemanticType: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub AccessRights: _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub AttributeType: _PS_TRUSTLET_ATTRIBUTE_TYPE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PS_TRUSTLET_ATTRIBUTE_HEADER {
    #[inline]
    pub fn InstanceNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_InstanceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InstanceNumber: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let InstanceNumber: u32 = unsafe { ::std::mem::transmute(InstanceNumber) };
            InstanceNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXT_SET_PARAMETERS_V0 {
    #[doc = "offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub NoWakeTolerance: LONGLONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CPU_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub AsUINT32: [ULONG; 4usize],
    pub __bindgen_anon_1: _CPU_INFO__bindgen_ty_1,
    pub __bindgen_anon_2: _CPU_INFO__bindgen_ty_2,
    #[doc = "offset: 0xc (12)"]
    pub Edx: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CPU_INFO__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Eax: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Ebx: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CPU_INFO__bindgen_ty_2 {
    #[doc = "offset: 0x8 (8)"]
    pub Ecx: ULONG,
}
impl Default for _CPU_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_MANDATORY_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub Policy: ULONG,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HASH_TABLE_ITERATOR {
    #[doc = "offset: 0x0 (0)"]
    pub Hash: *mut _RTL_HASH_TABLE,
    #[doc = "offset: 0x4 (4)"]
    pub HashEntry: *mut _RTL_HASH_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Bucket: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _RTL_HASH_TABLE_ITERATOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_DIRECTORY_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ChainLink: *mut _OBJECT_DIRECTORY_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Object: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub HashValue: ULONG,
}
impl Default for _OBJECT_DIRECTORY_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_LBR_SUPPORT {
    #[doc = "offset: 0x0 (0)"]
    pub LbrHandle: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub LbrOptions: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub HookIdCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub HookId: [USHORT; 4usize],
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityAttributeCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SecurityAttributesList: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub WorkingSecurityAttributeCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub WorkingSecurityAttributesList: _LIST_ENTRY,
}
impl Default for _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
    #[doc = "offset: 0x0 (0)"]
    pub Sid: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Attributes: ULONG,
}
impl Default for _SID_AND_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEP_SID_VALUES_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub BlockLength: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub SidCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SidValuesStart: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FS_FILTER_SECTION_SYNC_OUTPUT {
    #[doc = "offset: 0x0 (0)"]
    pub StructureSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SizeReturned: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DesiredReadAlignment: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HANDLE_TABLE_ENTRY_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub AuditMask: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaxRelativeAccessMask: ULONG,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EXHANDLE {
    pub __bindgen_anon_1: _EXHANDLE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EXHANDLE__bindgen_ty_1 {
    pub __bindgen_anon_1: _EXHANDLE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub GenericHandleOverlay: *mut VOID,
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXHANDLE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _EXHANDLE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn TagBits(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TagBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Index(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Index(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TagBits: ULONG, Index: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TagBits: u32 = unsafe { ::std::mem::transmute(TagBits) };
            TagBits as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Index: u32 = unsafe { ::std::mem::transmute(Index) };
            Index as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EXHANDLE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EXHANDLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_CACHED_PTES {
    #[doc = "offset: 0x0 (0)"]
    pub Bins: [_MI_CACHED_PTE; 8usize],
    #[doc = "offset: 0x40 (64)"]
    pub CachedPteCount: LONG,
}
impl Default for _MI_CACHED_PTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub DosDevicesDirectory: *mut _OBJECT_DIRECTORY,
    #[doc = "offset: 0x4 (4)"]
    pub GlobalDosDevicesDirectory: *mut _OBJECT_DIRECTORY,
    #[doc = "offset: 0x8 (8)"]
    pub DosDevicesDirectoryHandle: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub DriveMap: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub DriveType: [UCHAR; 32usize],
    #[doc = "offset: 0x34 (52)"]
    pub ServerSilo: *mut _EJOB,
}
impl Default for _DEVICE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ImpersonationLevel: _SECURITY_IMPERSONATION_LEVEL,
    #[doc = "offset: 0x8 (8)"]
    pub ContextTrackingMode: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub EffectiveOnly: UCHAR,
}
impl Default for _SECURITY_QUALITY_OF_SERVICE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_PORT_ATTRIBUTES {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SecurityQos: _SECURITY_QUALITY_OF_SERVICE,
    #[doc = "offset: 0x10 (16)"]
    pub MaxMessageLength: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub MemoryBandwidth: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub MaxPoolUsage: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub MaxSectionSize: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub MaxViewSize: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub MaxTotalSectionSize: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub DupObjectTypes: ULONG,
}
impl Default for _ALPC_PORT_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_CREATE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub Attributes: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub RootDirectory: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub ProbeMode: CHAR,
    #[doc = "offset: 0xc (12)"]
    pub PagedPoolCharge: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub NonPagedPoolCharge: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub SecurityDescriptorCharge: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub SecurityQos: *mut _SECURITY_QUALITY_OF_SERVICE,
    #[doc = "offset: 0x20 (32)"]
    pub SecurityQualityOfService: _SECURITY_QUALITY_OF_SERVICE,
}
impl Default for _OBJECT_CREATE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HANDLE_TRACE_DB_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ClientId: _CLIENT_ID,
    #[doc = "offset: 0x8 (8)"]
    pub Handle: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Type: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub StackTrace: [*mut VOID; 16usize],
}
impl Default for _HANDLE_TRACE_DB_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HANDLE_TABLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub VolatileLowValue: LONG,
    #[doc = "offset: 0x0 (0)"]
    pub LowValue: LONG,
    pub __bindgen_anon_1: _HANDLE_TABLE_ENTRY__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_2: _HANDLE_TABLE_ENTRY__bindgen_ty_2,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HANDLE_TABLE_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub InfoTable: *mut _HANDLE_TABLE_ENTRY_INFO,
    #[doc = "offset: 0x4 (4)"]
    pub HighValue: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub NextFreeHandleEntry: *mut _HANDLE_TABLE_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub LeafHandleValue: _EXHANDLE,
}
impl Default for _HANDLE_TABLE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HANDLE_TABLE_ENTRY__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x4 (4)"]
    pub RefCountField: LONG,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _HANDLE_TABLE_ENTRY__bindgen_ty_2 {
    #[inline]
    pub fn ObjectPointerBits(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ObjectPointerBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ObjectPointerBits: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
            let ObjectPointerBits: u32 = unsafe { ::std::mem::transmute(ObjectPointerBits) };
            ObjectPointerBits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn GrantedAccessBits(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_GrantedAccessBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtectFromClose(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProtectFromClose(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoRightsUpgrade(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoRightsUpgrade(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        GrantedAccessBits: ULONG,
        ProtectFromClose: ULONG,
        NoRightsUpgrade: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let GrantedAccessBits: u32 = unsafe { ::std::mem::transmute(GrantedAccessBits) };
            GrantedAccessBits as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ProtectFromClose: u32 = unsafe { ::std::mem::transmute(ProtectFromClose) };
            ProtectFromClose as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let NoRightsUpgrade: u32 = unsafe { ::std::mem::transmute(NoRightsUpgrade) };
            NoRightsUpgrade as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _HANDLE_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _HANDLE_TABLE_ENTRY {
    #[inline]
    pub fn Unlocked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Unlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Attributes(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Attributes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Unlocked: ULONG,
        Attributes: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Unlocked: u32 = unsafe { ::std::mem::transmute(Unlocked) };
            Unlocked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let Attributes: u32 = unsafe { ::std::mem::transmute(Attributes) };
            Attributes as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn RefCnt(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_RefCnt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(RefCnt: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let RefCnt: u32 = unsafe { ::std::mem::transmute(RefCnt) };
            RefCnt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_HIGHLOW {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: ULONG,
}
#[doc = "0x248 (584) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SILO_USER_SHARED_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub ServiceSessionId: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ActiveConsoleId: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ConsoleSessionForegroundProcessId: LONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub NtProductType: _NT_PRODUCT_TYPE,
    #[doc = "offset: 0x14 (20)"]
    pub SuiteMask: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub SharedUserSessionId: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub IsMultiSessionSku: UCHAR,
    #[doc = "offset: 0x1e (30)"]
    pub NtSystemRoot: [WCHAR; 260usize],
    #[doc = "offset: 0x226 (550)"]
    pub UserModeGlobalLogger: [USHORT; 16usize],
}
impl Default for _SILO_USER_SHARED_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT_LIST_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x4 (4)"]
    pub RelationLevel: _DEVICE_RELATION_LEVEL,
    #[doc = "offset: 0x8 (8)"]
    pub Ordinal: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
}
impl Default for _DEVICE_OBJECT_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_SEQUENCE {
    #[doc = "offset: 0x0 (0)"]
    pub SequenceD1: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SequenceD2: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SequenceD3: ULONG,
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_CAPABILITIES {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x8 (8)"]
    pub Address: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub UINumber: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DeviceState: [_DEVICE_POWER_STATE; 7usize],
    #[doc = "offset: 0x2c (44)"]
    pub SystemWake: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x30 (48)"]
    pub DeviceWake: _DEVICE_POWER_STATE,
    #[doc = "offset: 0x34 (52)"]
    pub D1Latency: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub D2Latency: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub D3Latency: ULONG,
}
impl Default for _DEVICE_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceD2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LockSupported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DockDevice(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UniqueID(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SilentInstall(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD3(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NonDynamic(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromInterrupt(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecureDevice(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceD1: ULONG,
        DeviceD2: ULONG,
        LockSupported: ULONG,
        EjectSupported: ULONG,
        Removable: ULONG,
        DockDevice: ULONG,
        UniqueID: ULONG,
        SilentInstall: ULONG,
        RawDeviceOK: ULONG,
        SurpriseRemovalOK: ULONG,
        WakeFromD0: ULONG,
        WakeFromD1: ULONG,
        WakeFromD2: ULONG,
        WakeFromD3: ULONG,
        HardwareDisabled: ULONG,
        NonDynamic: ULONG,
        WarmEjectSupported: ULONG,
        NoDisplayInUI: ULONG,
        Reserved1: ULONG,
        WakeFromInterrupt: ULONG,
        SecureDevice: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeviceD1: u32 = unsafe { ::std::mem::transmute(DeviceD1) };
            DeviceD1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeviceD2: u32 = unsafe { ::std::mem::transmute(DeviceD2) };
            DeviceD2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LockSupported: u32 = unsafe { ::std::mem::transmute(LockSupported) };
            LockSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EjectSupported: u32 = unsafe { ::std::mem::transmute(EjectSupported) };
            EjectSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Removable: u32 = unsafe { ::std::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DockDevice: u32 = unsafe { ::std::mem::transmute(DockDevice) };
            DockDevice as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UniqueID: u32 = unsafe { ::std::mem::transmute(UniqueID) };
            UniqueID as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SilentInstall: u32 = unsafe { ::std::mem::transmute(SilentInstall) };
            SilentInstall as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RawDeviceOK: u32 = unsafe { ::std::mem::transmute(RawDeviceOK) };
            RawDeviceOK as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SurpriseRemovalOK: u32 = unsafe { ::std::mem::transmute(SurpriseRemovalOK) };
            SurpriseRemovalOK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let WakeFromD0: u32 = unsafe { ::std::mem::transmute(WakeFromD0) };
            WakeFromD0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WakeFromD1: u32 = unsafe { ::std::mem::transmute(WakeFromD1) };
            WakeFromD1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WakeFromD2: u32 = unsafe { ::std::mem::transmute(WakeFromD2) };
            WakeFromD2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WakeFromD3: u32 = unsafe { ::std::mem::transmute(WakeFromD3) };
            WakeFromD3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HardwareDisabled: u32 = unsafe { ::std::mem::transmute(HardwareDisabled) };
            HardwareDisabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NonDynamic: u32 = unsafe { ::std::mem::transmute(NonDynamic) };
            NonDynamic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WarmEjectSupported: u32 = unsafe { ::std::mem::transmute(WarmEjectSupported) };
            WarmEjectSupported as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let NoDisplayInUI: u32 = unsafe { ::std::mem::transmute(NoDisplayInUI) };
            NoDisplayInUI as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let WakeFromInterrupt: u32 = unsafe { ::std::mem::transmute(WakeFromInterrupt) };
            WakeFromInterrupt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SecureDevice: u32 = unsafe { ::std::mem::transmute(SecureDevice) };
            SecureDevice as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FAST_MUTEX {
    #[doc = "offset: 0x0 (0)"]
    pub Count: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub Owner: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Contention: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x1c (28)"]
    pub OldIrql: ULONG,
}
impl Default for _FAST_MUTEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4c (76) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_DEVICE_EVENT_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Status: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub EventQueueMutex: _KMUTANT,
    #[doc = "offset: 0x24 (36)"]
    pub Lock: _FAST_MUTEX,
    #[doc = "offset: 0x44 (68)"]
    pub List: _LIST_ENTRY,
}
impl Default for _PNP_DEVICE_EVENT_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HANDLE_TRACE_DEBUG_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub RefCount: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub TableSize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BitMaskFlags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub CloseCompactionLock: _FAST_MUTEX,
    #[doc = "offset: 0x2c (44)"]
    pub CurrentStackIndex: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub TraceDb: [_HANDLE_TRACE_DB_ENTRY; 1usize],
}
impl Default for _HANDLE_TRACE_DEBUG_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MM_SESSION_SPACE_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MM_SESSION_SPACE_FLAGS {
    #[inline]
    pub fn Initialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Initialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeletePending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeletePending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoolInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DynamicVaInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DynamicVaInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WsInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WsInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolDestroyed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoolDestroyed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ObjectInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ObjectInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LeakedPoolDeliberately(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LeakedPoolDeliberately(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Filler(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Filler(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Initialized: ULONG,
        DeletePending: ULONG,
        PoolInitialized: ULONG,
        DynamicVaInitialized: ULONG,
        WsInitialized: ULONG,
        PoolDestroyed: ULONG,
        ObjectInitialized: ULONG,
        LeakedPoolDeliberately: ULONG,
        Filler: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Initialized: u32 = unsafe { ::std::mem::transmute(Initialized) };
            Initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeletePending: u32 = unsafe { ::std::mem::transmute(DeletePending) };
            DeletePending as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PoolInitialized: u32 = unsafe { ::std::mem::transmute(PoolInitialized) };
            PoolInitialized as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DynamicVaInitialized: u32 = unsafe { ::std::mem::transmute(DynamicVaInitialized) };
            DynamicVaInitialized as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WsInitialized: u32 = unsafe { ::std::mem::transmute(WsInitialized) };
            WsInitialized as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PoolDestroyed: u32 = unsafe { ::std::mem::transmute(PoolDestroyed) };
            PoolDestroyed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ObjectInitialized: u32 = unsafe { ::std::mem::transmute(ObjectInitialized) };
            ObjectInitialized as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LeakedPoolDeliberately: u32 =
                unsafe { ::std::mem::transmute(LeakedPoolDeliberately) };
            LeakedPoolDeliberately as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Filler: u32 = unsafe { ::std::mem::transmute(Filler) };
            Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_MINI_COMPLETION_PACKET_USER {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub PacketType: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub KeyContext: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub ApcContext: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub IoStatus: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub IoStatusInformation: ULONG,
    pub MiniPacketCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _IO_MINI_COMPLETION_PACKET_USER, arg2: *mut VOID),
    >,
    #[doc = "offset: 0x20 (32)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub Allocated: UCHAR,
}
impl Default for _IO_MINI_COMPLETION_PACKET_USER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Packet: *mut _IO_MINI_COMPLETION_PACKET_USER,
    #[doc = "offset: 0x8 (8)"]
    pub Lookaside: *mut _ALPC_COMPLETION_PACKET_LOOKASIDE,
}
impl Default for _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_COMPLETION_PACKET_LOOKASIDE {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ActiveCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub PendingNullCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub PendingCheckCompletionListCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PendingDelete: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FreeListHead: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub CompletionPort: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub CompletionKey: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub Entry: [_ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY; 1usize],
}
impl Default for _ALPC_COMPLETION_PACKET_LOOKASIDE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OWNER_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub OwnerThread: ULONG,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OWNER_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub TableSize: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IoPriorityBoosted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerReferenced(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerReferenced(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoQoSPriorityBoosted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoQoSPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoPriorityBoosted: ULONG,
        OwnerReferenced: ULONG,
        IoQoSPriorityBoosted: ULONG,
        OwnerCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoPriorityBoosted: u32 = unsafe { ::std::mem::transmute(IoPriorityBoosted) };
            IoPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OwnerReferenced: u32 = unsafe { ::std::mem::transmute(OwnerReferenced) };
            OwnerReferenced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IoQoSPriorityBoosted: u32 = unsafe { ::std::mem::transmute(IoQoSPriorityBoosted) };
            IoQoSPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let OwnerCount: u32 = unsafe { ::std::mem::transmute(OwnerCount) };
            OwnerCount as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _OWNER_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OWNER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub ContextAsUlong: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelSoftReboot(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG,
        TargetSystemState: ULONG,
        EffectiveSystemState: ULONG,
        CurrentSystemState: ULONG,
        IgnoreHibernationPath: ULONG,
        PseudoTransition: ULONG,
        KernelSoftReboot: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let TargetSystemState: u32 = unsafe { ::std::mem::transmute(TargetSystemState) };
            TargetSystemState as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let EffectiveSystemState: u32 = unsafe { ::std::mem::transmute(EffectiveSystemState) };
            EffectiveSystemState as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CurrentSystemState: u32 = unsafe { ::std::mem::transmute(CurrentSystemState) };
            CurrentSystemState as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let IgnoreHibernationPath: u32 =
                unsafe { ::std::mem::transmute(IgnoreHibernationPath) };
            IgnoreHibernationPath as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PseudoTransition: u32 = unsafe { ::std::mem::transmute(PseudoTransition) };
            PseudoTransition as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let KernelSoftReboot: u32 = unsafe { ::std::mem::transmute(KernelSoftReboot) };
            KernelSoftReboot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let Reserved2: u32 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_CURRENT_BROADCAST {
    #[doc = "offset: 0x0 (0)"]
    pub InProgress: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub SystemContext: _SYSTEM_POWER_STATE_CONTEXT,
    #[doc = "offset: 0x8 (8)"]
    pub PowerAction: POWER_ACTION,
    #[doc = "offset: 0xc (12)"]
    pub DeviceState: *mut _POP_DEVICE_SYS_STATE,
}
impl Default for _POP_CURRENT_BROADCAST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_FILTER_PID {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Pids: [ULONG; 8usize],
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_GROUPMASK {
    #[doc = "offset: 0x0 (0)"]
    pub Masks: [ULONG; 8usize],
}
#[doc = "0x154 (340) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SYSTEM_LOGGER_SETTINGS {
    #[doc = "offset: 0x0 (0)"]
    pub EtwpSystemLogger: [_ETW_SYSTEM_LOGGER; 8usize],
    #[doc = "offset: 0x10 (16)"]
    pub EtwpActiveSystemLoggers: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub SiloGlobalGroupMask: _PERFINFO_GROUPMASK,
    #[doc = "offset: 0x34 (52)"]
    pub EtwpGroupMasks: [_PERFINFO_GROUPMASK; 9usize],
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SESSION_DRIVER_UNLOAD {
    pub __bindgen_anon_1: _MI_SESSION_DRIVER_UNLOAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_SESSION_DRIVER_UNLOAD__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Function: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT)>,
    #[doc = "offset: 0x0 (0)"]
    pub FunctionValue: ULONG,
}
impl Default for _MI_SESSION_DRIVER_UNLOAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_SESSION_DRIVER_UNLOAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1140 (4416) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POOL_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub PoolType: _POOL_TYPE,
    pub __bindgen_anon_1: _POOL_DESCRIPTOR__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub RunningAllocs: LONG,
    #[doc = "offset: 0x44 (68)"]
    pub PagesAllocated: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub BigPagesAllocated: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub BytesAllocated: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub RunningDeallocs: LONG,
    #[doc = "offset: 0x84 (132)"]
    pub PagesDeallocated: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub BigPagesDeallocated: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub BytesDeallocated: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub PoolIndex: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub PoolTypeCopy: _POOL_TYPE,
    #[doc = "offset: 0x100 (256)"]
    pub PendingFrees: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x104 (260)"]
    pub ThreadsProcessingDeferrals: LONG,
    #[doc = "offset: 0x108 (264)"]
    pub PendingFreeDepth: LONG,
    #[doc = "offset: 0x140 (320)"]
    pub ListHeads: [_LIST_ENTRY; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POOL_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub PagedLock: _FAST_MUTEX,
    #[doc = "offset: 0x4 (4)"]
    pub NonPagedLock: ULONG,
}
impl Default for _POOL_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POOL_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ERESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub SystemResourcesList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub OwnerTable: *mut _OWNER_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub ActiveCount: SHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub SharedWaiters: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub ExclusiveWaiters: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub OwnerEntry: _OWNER_ENTRY,
    #[doc = "offset: 0x20 (32)"]
    pub ActiveEntries: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ContentionCount: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub NumberOfSharedWaiters: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub NumberOfExclusiveWaiters: ULONG,
    pub __bindgen_anon_2: _ERESOURCE__bindgen_ty_2,
    #[doc = "offset: 0x34 (52)"]
    pub SpinLock: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_1 {
    #[doc = "offset: 0xe (14)"]
    pub Flag: USHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0xe (14)"]
    pub ReservedLowFlags: UCHAR,
    #[doc = "offset: 0xf (15)"]
    pub WaiterPriority: UCHAR,
}
impl Default for _ERESOURCE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_2 {
    #[doc = "offset: 0x30 (48)"]
    pub Address: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub CreatorBackTraceIndex: ULONG,
}
impl Default for _ERESOURCE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ERESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DOCK_INTERFACE {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub InterfaceReference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0xc (12)"]
    pub InterfaceDereference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    pub ProfileDepartureSetMode: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: PROFILE_DEPARTURE_STYLE) -> ULONG,
    >,
    #[doc = "offset: 0x14 (20)"]
    pub ProfileDepartureUpdate:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID) -> ULONG>,
}
impl Default for DOCK_INTERFACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaxCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TagCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub OperationCode: _PNP_DEVICE_DELETE_TYPE,
    #[doc = "offset: 0x10 (16)"]
    pub Devices: [_DEVICE_OBJECT_LIST_ENTRY; 1usize],
}
impl Default for _DEVICE_OBJECT_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RELATION_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceObjectList: *mut _DEVICE_OBJECT_LIST,
    #[doc = "offset: 0x4 (4)"]
    pub Sorted: UCHAR,
}
impl Default for _RELATION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_WAKE_FILTER {
    #[doc = "offset: 0x0 (0)"]
    pub HighEdgeFilter: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub LowEdgeFilter: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_DIAG_STACK_RECORD {
    #[doc = "offset: 0x0 (0)"]
    pub StackDepth: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Stack: [*mut VOID; 1usize],
}
impl Default for _PO_DIAG_STACK_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMSUPPORT_SHARED {
    #[doc = "offset: 0x0 (0)"]
    pub WorkingSetLock: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub ReleasedCommitDebt: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ResetPagesRepurposedCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub WsSwapSupport: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub CommitReleaseContext: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub AccessLog: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub ChargedWslePages: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ActualWslePages: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub GoodCitizenWaiting: LONG,
}
impl Default for _MMSUPPORT_SHARED {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERRUPT_HT_INTR_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: _INTERRUPT_HT_INTR_INFO__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: _INTERRUPT_HT_INTR_INFO__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _INTERRUPT_HT_INTR_INFO__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub bits: _INTERRUPT_HT_INTR_INFO__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _INTERRUPT_HT_INTR_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _INTERRUPT_HT_INTR_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Mask(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Mask(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Polarity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Polarity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MessageType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MessageType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RequestEOI(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestEOI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DestinationMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DestinationMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MessageType3(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MessageType3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Destination(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Destination(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Vector(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Vector(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAddress(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedAddress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Mask: ULONG,
        Polarity: ULONG,
        MessageType: ULONG,
        RequestEOI: ULONG,
        DestinationMode: ULONG,
        MessageType3: ULONG,
        Destination: ULONG,
        Vector: ULONG,
        ExtendedAddress: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Mask: u32 = unsafe { ::std::mem::transmute(Mask) };
            Mask as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Polarity: u32 = unsafe { ::std::mem::transmute(Polarity) };
            Polarity as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MessageType: u32 = unsafe { ::std::mem::transmute(MessageType) };
            MessageType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RequestEOI: u32 = unsafe { ::std::mem::transmute(RequestEOI) };
            RequestEOI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DestinationMode: u32 = unsafe { ::std::mem::transmute(DestinationMode) };
            DestinationMode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MessageType3: u32 = unsafe { ::std::mem::transmute(MessageType3) };
            MessageType3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Destination: u32 = unsafe { ::std::mem::transmute(Destination) };
            Destination as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Vector: u32 = unsafe { ::std::mem::transmute(Vector) };
            Vector as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let ExtendedAddress: u32 = unsafe { ::std::mem::transmute(ExtendedAddress) };
            ExtendedAddress as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _INTERRUPT_HT_INTR_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _INTERRUPT_HT_INTR_INFO__bindgen_ty_2 {
    #[doc = "offset: 0x4 (4)"]
    pub bits: _INTERRUPT_HT_INTR_INFO__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _INTERRUPT_HT_INTR_INFO__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _INTERRUPT_HT_INTR_INFO__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ExtendedDestination(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedDestination(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn PassPW(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassPW(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WaitingForEOI(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WaitingForEOI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExtendedDestination: ULONG,
        Reserved: ULONG,
        PassPW: ULONG,
        WaitingForEOI: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let ExtendedDestination: u32 = unsafe { ::std::mem::transmute(ExtendedDestination) };
            ExtendedDestination as u64
        });
        __bindgen_bitfield_unit.set(24usize, 6u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let PassPW: u32 = unsafe { ::std::mem::transmute(PassPW) };
            PassPW as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let WaitingForEOI: u32 = unsafe { ::std::mem::transmute(WaitingForEOI) };
            WaitingForEOI as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _INTERRUPT_HT_INTR_INFO__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _INTERRUPT_HT_INTR_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_PROPERTY_SET {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Lock: ULONG,
}
impl Default for _PS_PROPERTY_SET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CLIENT_SECURITY_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub ImpersonationData: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub ImpersonationToken: *mut VOID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _PS_CLIENT_SECURITY_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PS_CLIENT_SECURITY_CONTEXT {
    #[inline]
    pub fn ImpersonationLevel(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ImpersonationLevel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn EffectiveOnly(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImpersonationLevel: ULONG,
        EffectiveOnly: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let ImpersonationLevel: u32 = unsafe { ::std::mem::transmute(ImpersonationLevel) };
            ImpersonationLevel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EffectiveOnly: u32 = unsafe { ::std::mem::transmute(EffectiveOnly) };
            EffectiveOnly as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_RUNDOWN_REF {
    pub __bindgen_anon_1: _EX_RUNDOWN_REF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_RUNDOWN_REF__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub Ptr: *mut VOID,
}
impl Default for _EX_RUNDOWN_REF__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EX_RUNDOWN_REF {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HMAP_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub BlockOffset: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PermanentBinAddress: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TemporaryBinAddress: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TemporaryBinRundown: _EX_RUNDOWN_REF,
    #[doc = "offset: 0x10 (16)"]
    pub MemAlloc: ULONG,
}
impl Default for _HMAP_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2800 (10240) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HMAP_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Table: [_HMAP_ENTRY; 512usize],
}
impl Default for _HMAP_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1000 (4096) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HMAP_DIRECTORY {
    #[doc = "offset: 0x0 (0)"]
    pub Directory: [*mut _HMAP_TABLE; 1024usize],
}
impl Default for _HMAP_DIRECTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EX_RUNDOWN_REF_CACHE_AWARE {
    #[doc = "offset: 0x0 (0)"]
    pub RunRefs: *mut _EX_RUNDOWN_REF,
    #[doc = "offset: 0x4 (4)"]
    pub PoolToFree: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub RunRefSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Number: ULONG,
}
impl Default for _EX_RUNDOWN_REF_CACHE_AWARE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_PUSH_LOCK {
    pub __bindgen_anon_1: _EX_PUSH_LOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_PUSH_LOCK__bindgen_ty_1 {
    pub __bindgen_anon_1: _EX_PUSH_LOCK__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub Ptr: *mut VOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EX_PUSH_LOCK__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _EX_PUSH_LOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Locked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Locked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waiting(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Waiting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waking(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Waking(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MultipleShared(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleShared(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Shared(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Locked: ULONG,
        Waiting: ULONG,
        Waking: ULONG,
        MultipleShared: ULONG,
        Shared: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Locked: u32 = unsafe { ::std::mem::transmute(Locked) };
            Locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Waiting: u32 = unsafe { ::std::mem::transmute(Waiting) };
            Waiting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Waking: u32 = unsafe { ::std::mem::transmute(Waking) };
            Waking as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MultipleShared: u32 = unsafe { ::std::mem::transmute(MultipleShared) };
            MultipleShared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Shared: u32 = unsafe { ::std::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EX_PUSH_LOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EX_PUSH_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_ATOM_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub PushLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xc (12)"]
    pub ExHandleTable: *mut _HANDLE_TABLE,
    #[doc = "offset: 0x10 (16)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub NumberOfBuckets: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Buckets: [*mut _RTL_ATOM_TABLE_ENTRY; 1usize],
}
impl Default for _RTL_ATOM_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub PointerCount: LONG,
    pub __bindgen_anon_1: _OBJECT_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xc (12)"]
    pub TypeIndex: UCHAR,
    pub __bindgen_anon_2: _OBJECT_HEADER__bindgen_ty_2,
    #[doc = "offset: 0xe (14)"]
    pub InfoMask: UCHAR,
    pub __bindgen_anon_3: _OBJECT_HEADER__bindgen_ty_3,
    pub __bindgen_anon_4: _OBJECT_HEADER__bindgen_ty_4,
    #[doc = "offset: 0x14 (20)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub Body: _QUAD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub HandleCount: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub NextToFree: *mut VOID,
}
impl Default for _OBJECT_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER__bindgen_ty_2 {
    #[doc = "offset: 0xd (13)"]
    pub TraceFlags: UCHAR,
    pub __bindgen_anon_1: _OBJECT_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_HEADER__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _OBJECT_HEADER__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn DbgRefTrace(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DbgRefTrace(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgTracePermanent(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DbgTracePermanent(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgRefTrace: UCHAR,
        DbgTracePermanent: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgRefTrace: u8 = unsafe { ::std::mem::transmute(DbgRefTrace) };
            DbgRefTrace as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgTracePermanent: u8 = unsafe { ::std::mem::transmute(DbgTracePermanent) };
            DbgTracePermanent as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _OBJECT_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER__bindgen_ty_3 {
    #[doc = "offset: 0xf (15)"]
    pub Flags: UCHAR,
    pub __bindgen_anon_1: _OBJECT_HEADER__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_HEADER__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _OBJECT_HEADER__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn NewObject(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NewObject(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelObject(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_KernelObject(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelOnlyAccess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_KernelOnlyAccess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExclusiveObject(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExclusiveObject(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PermanentObject(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PermanentObject(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultSecurityQuota(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DefaultSecurityQuota(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SingleHandleEntry(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SingleHandleEntry(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeletedInline(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeletedInline(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NewObject: UCHAR,
        KernelObject: UCHAR,
        KernelOnlyAccess: UCHAR,
        ExclusiveObject: UCHAR,
        PermanentObject: UCHAR,
        DefaultSecurityQuota: UCHAR,
        SingleHandleEntry: UCHAR,
        DeletedInline: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NewObject: u8 = unsafe { ::std::mem::transmute(NewObject) };
            NewObject as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let KernelObject: u8 = unsafe { ::std::mem::transmute(KernelObject) };
            KernelObject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let KernelOnlyAccess: u8 = unsafe { ::std::mem::transmute(KernelOnlyAccess) };
            KernelOnlyAccess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ExclusiveObject: u8 = unsafe { ::std::mem::transmute(ExclusiveObject) };
            ExclusiveObject as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PermanentObject: u8 = unsafe { ::std::mem::transmute(PermanentObject) };
            PermanentObject as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DefaultSecurityQuota: u8 = unsafe { ::std::mem::transmute(DefaultSecurityQuota) };
            DefaultSecurityQuota as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SingleHandleEntry: u8 = unsafe { ::std::mem::transmute(SingleHandleEntry) };
            SingleHandleEntry as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DeletedInline: u8 = unsafe { ::std::mem::transmute(DeletedInline) };
            DeletedInline as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _OBJECT_HEADER__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER__bindgen_ty_4 {
    #[doc = "offset: 0x10 (16)"]
    pub ObjectCreateInfo: *mut _OBJECT_CREATE_INFORMATION,
    #[doc = "offset: 0x10 (16)"]
    pub QuotaBlockCharged: *mut VOID,
}
impl Default for _OBJECT_HEADER__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug)]
pub struct _OBJECT_REF_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub ObjectHeader: *mut _OBJECT_HEADER,
    #[doc = "offset: 0x4 (4)"]
    pub NextRef: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub ImageFileName: [UCHAR; 16usize],
    #[doc = "offset: 0x18 (24)"]
    pub NextPos: USHORT,
    #[doc = "offset: 0x1a (26)"]
    pub MaxStacks: USHORT,
    #[doc = "offset: 0x1c (28)"]
    pub StackInfo: __IncompleteArrayField<_OBJECT_REF_STACK_INFO>,
}
impl Default for _OBJECT_REF_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUMMY_FILE_OBJECT {
    #[doc = "offset: 0x0 (0)"]
    pub ObjectHeader: _OBJECT_HEADER,
    #[doc = "offset: 0x20 (32)"]
    pub FileObjectBody: [CHAR; 128usize],
}
impl Default for _DUMMY_FILE_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_HANDLE_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Handles: *mut _ALPC_HANDLE_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub TotalHandles: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Lock: _EX_PUSH_LOCK,
}
impl Default for _ALPC_HANDLE_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BLOB {
    pub __bindgen_anon_1: _BLOB__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub u1: _BLOB__bindgen_ty_2,
    #[doc = "offset: 0x9 (9)"]
    pub ResourceId: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub CachedReferences: SHORT,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub Pad: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Lock: _EX_PUSH_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BLOB__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ResourceList: _LIST_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub FreeListEntry: _SINGLE_LIST_ENTRY,
}
impl Default for _BLOB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BLOB__bindgen_ty_2 {
    #[doc = "offset: 0x8 (8)"]
    pub s1: _BLOB__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BLOB__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _BLOB__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ReferenceCache(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReferenceCache(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Lookaside(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Lookaside(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Initializing(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Initializing(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Deleted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Deleted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReferenceCache: UCHAR,
        Lookaside: UCHAR,
        Initializing: UCHAR,
        Deleted: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReferenceCache: u8 = unsafe { ::std::mem::transmute(ReferenceCache) };
            ReferenceCache as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Lookaside: u8 = unsafe { ::std::mem::transmute(Lookaside) };
            Lookaside as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Initializing: u8 = unsafe { ::std::mem::transmute(Initializing) };
            Initializing as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Deleted: u8 = unsafe { ::std::mem::transmute(Deleted) };
            Deleted as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _BLOB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _BLOB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KEY_HASH_TABLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub Owner: *mut _KTHREAD,
    #[doc = "offset: 0x8 (8)"]
    pub Entry: *mut _CM_KEY_HASH,
}
impl Default for _CM_KEY_HASH_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_PUSH_LOCK_AUTO_EXPAND {
    #[doc = "offset: 0x0 (0)"]
    pub LocalLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub State: _EX_PUSH_LOCK_AUTO_EXPAND_STATE,
    #[doc = "offset: 0x8 (8)"]
    pub Stats: ULONG,
}
impl Default for _EX_PUSH_LOCK_AUTO_EXPAND {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb0 (176) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_DIRECTORY {
    #[doc = "offset: 0x0 (0)"]
    pub HashBuckets: [*mut _OBJECT_DIRECTORY_ENTRY; 37usize],
    #[doc = "offset: 0x94 (148)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x98 (152)"]
    pub DeviceMap: *mut _DEVICE_MAP,
    #[doc = "offset: 0x9c (156)"]
    pub ShadowDirectory: *mut _OBJECT_DIRECTORY,
    #[doc = "offset: 0xa0 (160)"]
    pub NamespaceEntry: *mut VOID,
    #[doc = "offset: 0xa4 (164)"]
    pub SessionObject: *mut VOID,
    #[doc = "offset: 0xa8 (168)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub SessionId: ULONG,
}
impl Default for _OBJECT_DIRECTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_HASH_BUCKET {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: [_LIST_ENTRY; 3usize],
    #[doc = "offset: 0x18 (24)"]
    pub BucketLock: _EX_PUSH_LOCK,
}
impl Default for _ETW_HASH_BUCKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OB_HANDLE_REVOCATION_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub RevocationInfos: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xc (12)"]
    pub Rundown: _EX_RUNDOWN_REF,
}
impl Default for _OB_HANDLE_REVOCATION_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HANDLE_REVOCATION_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub RevocationBlock: *mut _OB_HANDLE_REVOCATION_BLOCK,
    #[doc = "offset: 0xc (12)"]
    pub AllowHandleRevocation: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub Padding1: [UCHAR; 3usize],
}
impl Default for _HANDLE_REVOCATION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_FOOTER {
    #[doc = "offset: 0x0 (0)"]
    pub HandleRevocationInfo: _HANDLE_REVOCATION_INFO,
    #[doc = "offset: 0x10 (16)"]
    pub ExtendedUserInfo: _OB_EXTENDED_USER_INFO,
}
impl Default for _OBJECT_FOOTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER_EXTENDED_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Footer: *mut _OBJECT_FOOTER,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
}
impl Default for _OBJECT_HEADER_EXTENDED_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_PRIV_HANDLE_DEMUX_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Tree: _RTL_RB_TREE,
    #[doc = "offset: 0x8 (8)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xc (12)"]
    pub SequenceNumber: USHORT,
}
impl Default for _ETW_PRIV_HANDLE_DEMUX_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WNF_LOCK {
    #[doc = "offset: 0x0 (0)"]
    pub PushLock: _EX_PUSH_LOCK,
}
impl Default for _WNF_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WNF_SILODRIVERSTATE {
    #[doc = "offset: 0x0 (0)"]
    pub ScopeMap: *mut _WNF_SCOPE_MAP,
    #[doc = "offset: 0x4 (4)"]
    pub PermanentNameStoreRootKey: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub PersistentNameStoreRootKey: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub PermanentNameSequenceNumber: LONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub PermanentNameSequenceNumberLock: _WNF_LOCK,
    #[doc = "offset: 0x20 (32)"]
    pub PermanentNameSequenceNumberPool: LONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub RuntimeNameSequenceNumber: LONGLONG,
}
impl Default for _WNF_SILODRIVERSTATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x130 (304) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_NAMESPACE_LOOKUPTABLE {
    #[doc = "offset: 0x0 (0)"]
    pub HashBuckets: [_LIST_ENTRY; 37usize],
    #[doc = "offset: 0x128 (296)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x12c (300)"]
    pub NumberOfPrivateSpaces: ULONG,
}
impl Default for _OBJECT_NAMESPACE_LOOKUPTABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HANDLE_TABLE_FREE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub FreeListLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub FirstFreeHandleEntry: *mut _HANDLE_TABLE_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub LastFreeHandleEntry: *mut _HANDLE_TABLE_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub HandleCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub HighWaterMark: ULONG,
}
impl Default for _HANDLE_TABLE_FREE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_RW_LOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub Thread: *mut _KTHREAD,
}
impl Default for _POP_RW_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMSESSION {
    #[doc = "offset: 0x0 (0)"]
    pub SystemSpaceViewLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub SystemSpaceViewLockPointer: *mut _EX_PUSH_LOCK,
    #[doc = "offset: 0x8 (8)"]
    pub ViewRoot: _RTL_AVL_TREE,
    #[doc = "offset: 0xc (12)"]
    pub ViewCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub BitmapFailures: ULONG,
}
impl Default for _MMSESSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_PROCESS_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub ViewListHead: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub PagedPoolQuotaCache: ULONG,
}
impl Default for _ALPC_PROCESS_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERRUPT_REMAPPING_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x4 (4)"]
    pub u: _INTERRUPT_REMAPPING_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _INTERRUPT_REMAPPING_INFO__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Msi: _INTERRUPT_REMAPPING_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _INTERRUPT_REMAPPING_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub MessageAddressHigh: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MessageAddressLow: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MessageData: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub Reserved: USHORT,
}
impl Default for _INTERRUPT_REMAPPING_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _INTERRUPT_REMAPPING_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _INTERRUPT_REMAPPING_INFO {
    #[inline]
    pub fn IrtIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_IrtIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn FlagHalInternal(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlagHalInternal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FlagTranslated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlagTranslated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IrtIndex: ULONG,
        FlagHalInternal: ULONG,
        FlagTranslated: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let IrtIndex: u32 = unsafe { ::std::mem::transmute(IrtIndex) };
            IrtIndex as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let FlagHalInternal: u32 = unsafe { ::std::mem::transmute(FlagHalInternal) };
            FlagHalInternal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let FlagTranslated: u32 = unsafe { ::std::mem::transmute(FlagTranslated) };
            FlagTranslated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_DEPENDENT {
    #[doc = "offset: 0x0 (0)"]
    pub Index: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ProviderIndex: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_PROVIDER {
    #[doc = "offset: 0x0 (0)"]
    pub Index: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Activating: UCHAR,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GUID {
    #[doc = "offset: 0x0 (0)"]
    pub Data1: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Data2: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Data3: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Data4: [UCHAR; 8usize],
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_RELATIONS {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Objects: [*mut _DEVICE_OBJECT; 1usize],
}
impl Default for _DEVICE_RELATIONS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub SortKey: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Inserted: UCHAR,
}
impl Default for _KDEVICE_QUEUE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VPB {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub VolumeLabelLength: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0xc (12)"]
    pub RealDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x10 (16)"]
    pub SerialNumber: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ReferenceCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub VolumeLabel: [WCHAR; 32usize],
}
impl Default for _VPB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CC_EXTERNAL_CACHE_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Callback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG, arg3: ULONG)>,
    #[doc = "offset: 0x4 (4)"]
    pub DirtyPageStatistics: _DIRTY_PAGE_STATISTICS,
    #[doc = "offset: 0x10 (16)"]
    pub Links: _LIST_ENTRY,
}
impl Default for _CC_EXTERNAL_CACHE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THERMAL_COOLING_INTERFACE {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub InterfaceReference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0xc (12)"]
    pub InterfaceDereference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0x10 (16)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ActiveCooling: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: UCHAR)>,
    #[doc = "offset: 0x18 (24)"]
    pub PassiveCooling: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG)>,
}
impl Default for _THERMAL_COOLING_INTERFACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_COOLING_EXTENSION {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub RequestListHead: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub Lock: _POP_RW_LOCK,
    #[doc = "offset: 0x18 (24)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x1c (28)"]
    pub NotificationEntry: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x21 (33)"]
    pub ActiveEngaged: UCHAR,
    #[doc = "offset: 0x22 (34)"]
    pub ThrottleLimit: UCHAR,
    #[doc = "offset: 0x23 (35)"]
    pub UpdatingToCurrent: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub RemovalFlushEvent: *mut _KEVENT,
    #[doc = "offset: 0x28 (40)"]
    pub PnpFlushEvent: *mut _KEVENT,
    #[doc = "offset: 0x2c (44)"]
    pub Interface: _THERMAL_COOLING_INTERFACE,
}
impl Default for _POP_COOLING_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    #[doc = "offset: 0x0 (0)"]
    pub IdleCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub BusyCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BusyReference: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TotalBusyCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ConservationIdleTime: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PerformanceIdleTime: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x1c (28)"]
    pub IdleList: _LIST_ENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub IdleType: _POP_DEVICE_IDLE_TYPE,
    #[doc = "offset: 0x28 (40)"]
    pub IdleState: _DEVICE_POWER_STATE,
    #[doc = "offset: 0x2c (44)"]
    pub CurrentState: _DEVICE_POWER_STATE,
    #[doc = "offset: 0x30 (48)"]
    pub CoolingExtension: *mut _POP_COOLING_EXTENSION,
    #[doc = "offset: 0x34 (52)"]
    pub Volume: _LIST_ENTRY,
    #[doc = "offset: 0x3c (60)"]
    pub Specific: _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1 {
    #[doc = "offset: 0x3c (60)"]
    pub Disk: _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub IdleTime: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NonIdleTime: ULONG,
}
impl Default for _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DEVICE_OBJECT_POWER_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVOBJ_EXTENSION {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub PowerFlags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    #[doc = "offset: 0x10 (16)"]
    pub ExtensionFlags: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub DeviceNode: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub AttachedTo: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x1c (28)"]
    pub StartIoCount: LONG,
    #[doc = "offset: 0x20 (32)"]
    pub StartIoKey: LONG,
    #[doc = "offset: 0x24 (36)"]
    pub StartIoFlags: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Vpb: *mut _VPB,
    #[doc = "offset: 0x2c (44)"]
    pub DependencyNode: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub InterruptContext: *mut VOID,
    #[doc = "offset: 0x34 (52)"]
    pub VerifierContext: *mut VOID,
}
impl Default for _DEVOBJ_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceListHead: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Busy: UCHAR,
}
impl Default for _KDEVICE_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3c (60) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_DEVICE_NOTIFY {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub PowerChildren: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub PowerParents: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub TargetDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x1c (28)"]
    pub OrderLevel: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x24 (36)"]
    pub DeviceName: *mut WCHAR,
    #[doc = "offset: 0x28 (40)"]
    pub DriverName: *mut WCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub ChildCount: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub ActiveChild: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub ParentCount: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub ActiveParent: ULONG,
}
impl Default for _PO_DEVICE_NOTIFY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_IDLE_DEPENDENCY {
    #[doc = "offset: 0x0 (0)"]
    pub ProcessorIndex: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ExpectedState: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub AllowDeeperStates: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub LooseDependency: UCHAR,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KQUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub EntryListHead: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub CurrentCount: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub MaximumCount: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ThreadListHead: _LIST_ENTRY,
}
impl Default for _KQUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REPLY_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub Queue: _KQUEUE,
    #[doc = "offset: 0x28 (40)"]
    pub EventsLost: LONG,
}
impl Default for _ETW_REPLY_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KWAIT_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub WaitListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub WaitType: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub BlockState: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub WaitKey: USHORT,
    pub __bindgen_anon_1: _KWAIT_BLOCK__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub Object: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SparePtr: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KWAIT_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub Thread: *mut _KTHREAD,
    #[doc = "offset: 0xc (12)"]
    pub NotificationQueue: *mut _KQUEUE,
}
impl Default for _KWAIT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KWAIT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_PERF_QOS_CLASS_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub MaxPolicyPercent: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaxEquivalentFrequencyPercent: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinPolicyPercent: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AutonomousActivityWindow: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub EnergyPerfPreference: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ProvideGuidance: UCHAR,
    #[doc = "offset: 0x15 (21)"]
    pub AllowThrottling: UCHAR,
    #[doc = "offset: 0x16 (22)"]
    pub PerfBoostMode: UCHAR,
    #[doc = "offset: 0x17 (23)"]
    pub LatencyHintPerf: UCHAR,
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY_BOOST_BITMAP {
    #[doc = "offset: 0x0 (0)"]
    pub AllFields: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub __bindgen_anon_1: _KLOCK_ENTRY_BOOST_BITMAP__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KLOCK_ENTRY_BOOST_BITMAP__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _KLOCK_ENTRY_BOOST_BITMAP__bindgen_ty_1 {
    #[inline]
    pub fn IoBoost(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IoBoost(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoQoSBoost(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IoQoSBoost(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoNormalPriorityWaiterCount(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_IoNormalPriorityWaiterCount(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoBoost: USHORT,
        IoQoSBoost: USHORT,
        IoNormalPriorityWaiterCount: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoBoost: u16 = unsafe { ::std::mem::transmute(IoBoost) };
            IoBoost as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IoQoSBoost: u16 = unsafe { ::std::mem::transmute(IoQoSBoost) };
            IoQoSBoost as u64
        });
        __bindgen_bitfield_unit.set(2usize, 8u8, {
            let IoNormalPriorityWaiterCount: u16 =
                unsafe { ::std::mem::transmute(IoNormalPriorityWaiterCount) };
            IoNormalPriorityWaiterCount as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KLOCK_ENTRY_BOOST_BITMAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KLOCK_ENTRY_BOOST_BITMAP {
    #[inline]
    pub fn AllBoosts(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_AllBoosts(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn CpuBoostsBitmap(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_CpuBoostsBitmap(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllBoosts: ULONG,
        Reserved: ULONG,
        CpuBoostsBitmap: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 17u8, {
            let AllBoosts: u32 = unsafe { ::std::mem::transmute(AllBoosts) };
            AllBoosts as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 15u8, {
            let CpuBoostsBitmap: u16 = unsafe { ::std::mem::transmute(CpuBoostsBitmap) };
            CpuBoostsBitmap as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn IoQoSWaiterCount(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_IoQoSWaiterCount(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(IoQoSWaiterCount: USHORT) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let IoQoSWaiterCount: u16 = unsafe { ::std::mem::transmute(IoQoSWaiterCount) };
            IoQoSWaiterCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KLOCK_ENTRY_LOCK_STATE {
    pub __bindgen_anon_1: _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_1,
    pub __bindgen_anon_2: _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_1 {
    pub __bindgen_anon_1: _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub LockState: *mut VOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CrossThreadReleasable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CrossThreadReleasable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Busy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Busy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn InTree(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InTree(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CrossThreadReleasable: ULONG,
        Busy: ULONG,
        Reserved: ULONG,
        InTree: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CrossThreadReleasable: u32 =
                unsafe { ::std::mem::transmute(CrossThreadReleasable) };
            CrossThreadReleasable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Busy: u32 = unsafe { ::std::mem::transmute(Busy) };
            Busy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 29u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let InTree: u32 = unsafe { ::std::mem::transmute(InTree) };
            InTree as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_2 {
    #[doc = "offset: 0x4 (4)"]
    pub SessionState: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub SessionId: ULONG,
}
impl Default for _KLOCK_ENTRY_LOCK_STATE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KLOCK_ENTRY_LOCK_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSCHEDULING_GROUP_POLICY {
    pub __bindgen_anon_1: _KSCHEDULING_GROUP_POLICY__bindgen_ty_1,
    pub __bindgen_anon_2: _KSCHEDULING_GROUP_POLICY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KSCHEDULING_GROUP_POLICY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub Weight: USHORT,
    pub __bindgen_anon_1: _KSCHEDULING_GROUP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KSCHEDULING_GROUP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub MinRate: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MaxRate: USHORT,
}
impl Default for _KSCHEDULING_GROUP_POLICY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KSCHEDULING_GROUP_POLICY__bindgen_ty_2 {
    #[doc = "offset: 0x4 (4)"]
    pub AllFlags: ULONG,
    pub __bindgen_anon_1: _KSCHEDULING_GROUP_POLICY__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KSCHEDULING_GROUP_POLICY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KSCHEDULING_GROUP_POLICY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Disabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RankBias(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RankBias(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: ULONG,
        Disabled: ULONG,
        RankBias: ULONG,
        Spare1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Disabled: u32 = unsafe { ::std::mem::transmute(Disabled) };
            Disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RankBias: u32 = unsafe { ::std::mem::transmute(RankBias) };
            RankBias as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Spare1: u32 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KSCHEDULING_GROUP_POLICY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KSCHEDULING_GROUP_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_LIST_LOOKUP {
    #[doc = "offset: 0x0 (0)"]
    pub ExtendedLookup: *mut _HEAP_LIST_LOOKUP,
    #[doc = "offset: 0x4 (4)"]
    pub ArraySize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ExtraItem: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ItemCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub OutOfRangeItems: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub BaseIndex: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub ListHead: *mut _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub ListsInUseUlong: *mut ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ListHints: *mut *mut _LIST_ENTRY,
}
impl Default for _HEAP_LIST_LOOKUP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BITMAP_RANGE {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub BasePage: LONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub FirstDirtyPage: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub LastDirtyPage: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub DirtyPages: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Bitmap: *mut ULONG,
}
impl Default for _BITMAP_RANGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x88 (136) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MBCB {
    #[doc = "offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NodeIsInZone: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub PagesToWrite: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DirtyPages: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub BitmapRanges: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub ResumeWritePage: LONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub MostRecentlyDirtiedPage: LONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub BitmapRange1: _BITMAP_RANGE,
    #[doc = "offset: 0x48 (72)"]
    pub BitmapRange2: _BITMAP_RANGE,
    #[doc = "offset: 0x68 (104)"]
    pub BitmapRange3: _BITMAP_RANGE,
}
impl Default for _MBCB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_INTERRUPT_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _PEP_ACPI_RESOURCE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub InterruptType: _KINTERRUPT_MODE,
    #[doc = "offset: 0x8 (8)"]
    pub InterruptPolarity: _KINTERRUPT_POLARITY,
    #[doc = "offset: 0xc (12)"]
    pub Flags: _PEP_ACPI_RESOURCE_FLAGS,
    #[doc = "offset: 0x10 (16)"]
    pub Count: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub Pins: *mut ULONG,
}
impl Default for _PEP_ACPI_INTERRUPT_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP {
    #[doc = "offset: 0x0 (0)"]
    pub SizeOfBitMap: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Buffer: *mut ULONG,
}
impl Default for _RTL_BITMAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FREE_DISPLAY {
    #[doc = "offset: 0x0 (0)"]
    pub RealVectorSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Hint: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Display: _RTL_BITMAP,
}
impl Default for _FREE_DISPLAY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x19c (412) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DUAL {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Map: *mut _HMAP_DIRECTORY,
    #[doc = "offset: 0x8 (8)"]
    pub SmallDir: *mut _HMAP_TABLE,
    #[doc = "offset: 0xc (12)"]
    pub Guard: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub FreeDisplay: [_FREE_DISPLAY; 24usize],
    #[doc = "offset: 0x190 (400)"]
    pub FreeBins: _LIST_ENTRY,
    #[doc = "offset: 0x198 (408)"]
    pub FreeSummary: ULONG,
}
impl Default for _DUAL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_SUB64K_FREE_RANGES {
    #[doc = "offset: 0x0 (0)"]
    pub BitMap: _RTL_BITMAP,
    #[doc = "offset: 0x8 (8)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub Vad: *mut _MMVAD_SHORT,
    #[doc = "offset: 0x14 (20)"]
    pub SetBits: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FullSetBits: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _MI_SUB64K_FREE_RANGES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_SUB64K_FREE_RANGES {
    #[inline]
    pub fn SubListIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SubListIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Hint(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Hint(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SubListIndex: ULONG, Hint: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SubListIndex: u32 = unsafe { ::std::mem::transmute(SubListIndex) };
            SubListIndex as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Hint: u32 = unsafe { ::std::mem::transmute(Hint) };
            Hint as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_VAD_EVENT_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _MI_VAD_EVENT_BLOCK,
    pub __bindgen_anon_1: _MI_VAD_EVENT_BLOCK__bindgen_ty_1,
    #[doc = "offset: 0x24 (36)"]
    pub WaitReason: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_VAD_EVENT_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Gate: _KGATE,
    #[doc = "offset: 0x4 (4)"]
    pub SecureInfo: _MMADDRESS_LIST,
    #[doc = "offset: 0x4 (4)"]
    pub BitMap: _RTL_BITMAP,
    #[doc = "offset: 0x4 (4)"]
    pub InPageSupport: *mut _MMINPAGE_SUPPORT,
    #[doc = "offset: 0x4 (4)"]
    pub LargePage: _MI_LARGEPAGE_IMAGE_INFO,
    #[doc = "offset: 0x4 (4)"]
    pub CreatingThread: *mut _ETHREAD,
    #[doc = "offset: 0x4 (4)"]
    pub PebTebRfg: _MI_SUB64K_FREE_RANGES,
    #[doc = "offset: 0x4 (4)"]
    pub RfgProtectedStack: _MI_RFG_PROTECTED_STACK,
}
impl Default for _MI_VAD_EVENT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_VAD_EVENT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PAGING_FILE_SPACE_BITMAPS {
    pub __bindgen_anon_1: _MI_PAGING_FILE_SPACE_BITMAPS__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub AllocationBitmap: _RTL_BITMAP,
    pub __bindgen_anon_2: _MI_PAGING_FILE_SPACE_BITMAPS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PAGING_FILE_SPACE_BITMAPS__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub RefCount: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub Anchor: *mut _MI_PAGING_FILE_SPACE_BITMAPS,
}
impl Default for _MI_PAGING_FILE_SPACE_BITMAPS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PAGING_FILE_SPACE_BITMAPS__bindgen_ty_2 {
    #[doc = "offset: 0xc (12)"]
    pub ReservationBitmap: _RTL_BITMAP,
    #[doc = "offset: 0xc (12)"]
    pub EvictedBitmap: _RTL_BITMAP,
}
impl Default for _MI_PAGING_FILE_SPACE_BITMAPS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_PAGING_FILE_SPACE_BITMAPS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_RATE_CONTROL_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub RateControlQuotaReference: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub OverQuotaHistory: _RTL_BITMAP,
    #[doc = "offset: 0xc (12)"]
    pub BitMapBuffer: *mut UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub BitMapBufferSize: ULONG,
}
impl Default for _JOB_RATE_CONTROL_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_DRIVER_CALLBACKS {
    #[doc = "offset: 0x0 (0)"]
    pub ComponentActive: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG)>,
    #[doc = "offset: 0x4 (4)"]
    pub ComponentIdle: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG)>,
    pub ComponentIdleState:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG, arg3: ULONG)>,
    #[doc = "offset: 0xc (12)"]
    pub DevicePowerRequired: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0x10 (16)"]
    pub DevicePowerNotRequired: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    pub PowerControl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: *mut _GUID,
            arg3: *mut VOID,
            arg4: ULONG,
            arg5: *mut VOID,
            arg6: ULONG,
            arg7: *mut ULONG,
        ) -> LONG,
    >,
    pub ComponentCriticalTransition:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG, arg3: UCHAR)>,
    pub DripsWatchdogCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _DEVICE_OBJECT, arg3: ULONG),
    >,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_COORDINATED_SELECTION {
    #[doc = "offset: 0x0 (0)"]
    pub MaximumStates: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SelectedStates: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DefaultSelection: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Selection: *mut ULONG,
}
impl Default for _PPM_COORDINATED_SELECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_SELECTION_MENU {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Entries: *mut _PPM_SELECTION_MENU_ENTRY,
}
impl Default for _PPM_SELECTION_MENU {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_SELECTION_DEPENDENCY {
    #[doc = "offset: 0x0 (0)"]
    pub Processor: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Menu: _PPM_SELECTION_MENU,
}
impl Default for _PPM_SELECTION_DEPENDENCY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_SELECTION_MENU_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub StrictDependency: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub InitiatingState: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub DependentState: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub StateIndex: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Dependencies: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DependencyList: *mut _PPM_SELECTION_DEPENDENCY,
}
impl Default for _PPM_SELECTION_MENU_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KHETERO_PROCESSOR_SET {
    #[doc = "offset: 0x0 (0)"]
    pub IdealMask: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PreferredMask: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub AvailableMask: ULONG,
}
#[doc = "0x8c (140) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRAP_FRAME {
    #[doc = "offset: 0x0 (0)"]
    pub DbgEbp: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DbgEip: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DbgArgMark: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TempSegCs: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Logging: UCHAR,
    #[doc = "offset: 0xf (15)"]
    pub FrameType: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub TempEsp: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Dr0: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Dr1: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Dr2: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Dr3: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Dr6: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Dr7: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub SegGs: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub SegEs: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub SegDs: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub Edx: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub Ecx: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub Eax: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub PreviousPreviousMode: UCHAR,
    #[doc = "offset: 0x45 (69)"]
    pub EntropyQueueDpc: UCHAR,
    #[doc = "offset: 0x46 (70)"]
    pub Reserved: [UCHAR; 2usize],
    #[doc = "offset: 0x48 (72)"]
    pub MxCsr: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    #[doc = "offset: 0x50 (80)"]
    pub SegFs: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub Edi: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub Esi: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub Ebx: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub Ebp: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub ErrCode: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub Eip: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub SegCs: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub EFlags: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub HardwareEsp: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub HardwareSegSs: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub V86Es: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub V86Ds: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub V86Fs: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub V86Gs: ULONG,
}
impl Default for _KTRAP_FRAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSTACK_CONTROL {
    #[doc = "offset: 0x0 (0)"]
    pub StackBase: ULONG,
    pub __bindgen_anon_1: _KSTACK_CONTROL__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub PreviousTrapFrame: *mut _KTRAP_FRAME,
    #[doc = "offset: 0xc (12)"]
    pub PreviousExceptionList: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub Previous: _KERNEL_STACK_SEGMENT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KSTACK_CONTROL__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub ActualLimit: ULONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _KSTACK_CONTROL__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KSTACK_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn StackExpansion(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackExpansion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(StackExpansion: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let StackExpansion: u32 = unsafe { ::std::mem::transmute(StackExpansion) };
            StackExpansion as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KSTACK_CONTROL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSPIN_LOCK_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _KSPIN_LOCK_QUEUE,
    #[doc = "offset: 0x4 (4)"]
    pub Lock: *mut ULONG,
}
impl Default for _KSPIN_LOCK_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KLOCK_QUEUE_HANDLE {
    #[doc = "offset: 0x0 (0)"]
    pub LockQueue: _KSPIN_LOCK_QUEUE,
    #[doc = "offset: 0x8 (8)"]
    pub OldIrql: UCHAR,
}
impl Default for _KLOCK_QUEUE_HANDLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Pad: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Limit: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Base: ULONG,
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KAPC {
    #[doc = "offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub SpareByte0: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Size: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub SpareByte1: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub SpareLong0: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Thread: *mut _KTHREAD,
    #[doc = "offset: 0xc (12)"]
    pub ApcListEntry: _LIST_ENTRY,
    pub __bindgen_anon_1: _KAPC__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub NormalContext: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub SystemArgument1: *mut VOID,
    #[doc = "offset: 0x28 (40)"]
    pub SystemArgument2: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub ApcStateIndex: CHAR,
    #[doc = "offset: 0x2d (45)"]
    pub ApcMode: CHAR,
    #[doc = "offset: 0x2e (46)"]
    pub Inserted: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC__bindgen_ty_1 {
    pub __bindgen_anon_1: _KAPC__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub Reserved: [*mut VOID; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KAPC__bindgen_ty_1__bindgen_ty_1 {
    pub KernelRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _KAPC,
            arg2: *mut ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut VOID),
            >,
            arg3: *mut *mut VOID,
            arg4: *mut *mut VOID,
            arg5: *mut *mut VOID,
        ),
    >,
    #[doc = "offset: 0x18 (24)"]
    pub RundownRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _KAPC)>,
    pub NormalRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut VOID),
    >,
}
impl Default for _KAPC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KAPC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_APC_ENTRY {
    pub __bindgen_anon_1: _ETW_APC_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_APC_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub SListEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub Apc: _KAPC,
}
impl Default for _ETW_APC_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_APC_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GROUP_AFFINITY {
    #[doc = "offset: 0x0 (0)"]
    pub Mask: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Group: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Reserved: [USHORT; 3usize],
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KGDTENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub LimitLow: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub BaseLow: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub HighWord: _KGDTENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KGDTENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Bytes: _KGDTENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Bits: _KGDTENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KGDTENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub BaseMid: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Flags1: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Flags2: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub BaseHi: UCHAR,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KGDTENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KGDTENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn BaseMid(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Pres(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pres(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHi(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHi(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Sys(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Sys(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved_0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved_0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default_Big(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Default_Big(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHi(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHi(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMid: ULONG,
        Type: ULONG,
        Dpl: ULONG,
        Pres: ULONG,
        LimitHi: ULONG,
        Sys: ULONG,
        Reserved_0: ULONG,
        Default_Big: ULONG,
        Granularity: ULONG,
        BaseHi: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMid: u32 = unsafe { ::std::mem::transmute(BaseMid) };
            BaseMid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Pres: u32 = unsafe { ::std::mem::transmute(Pres) };
            Pres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHi: u32 = unsafe { ::std::mem::transmute(LimitHi) };
            LimitHi as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Sys: u32 = unsafe { ::std::mem::transmute(Sys) };
            Sys as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Reserved_0: u32 = unsafe { ::std::mem::transmute(Reserved_0) };
            Reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Default_Big: u32 = unsafe { ::std::mem::transmute(Default_Big) };
            Default_Big as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHi: u32 = unsafe { ::std::mem::transmute(BaseHi) };
            BaseHi as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KGDTENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KGDTENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REQUEST_MAILBOX {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _REQUEST_MAILBOX,
    #[doc = "offset: 0x4 (4)"]
    pub RequestSummary: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub RequestPacket: _KREQUEST_PACKET,
    #[doc = "offset: 0x18 (24)"]
    pub NodeTargetCountAddr: *mut LONG,
    #[doc = "offset: 0x1c (28)"]
    pub NodeTargetCount: LONG,
}
impl Default for _REQUEST_MAILBOX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Level: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Associativity: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub LineSize: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Type: _PROCESSOR_CACHE_TYPE,
}
impl Default for _CACHE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4c (76) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THERMAL_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub ThermalStamp: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ThermalConstant1: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ThermalConstant2: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Processors: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SamplingPeriod: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub CurrentTemperature: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PassiveTripPoint: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub CriticalTripPoint: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ActiveTripPointCount: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub ActiveTripPoint: [ULONG; 10usize],
}
#[doc = "0x5c (92) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THERMAL_INFORMATION_EX {
    #[doc = "offset: 0x0 (0)"]
    pub ThermalStamp: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ThermalConstant1: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ThermalConstant2: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SamplingPeriod: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub CurrentTemperature: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PassiveTripPoint: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub ThermalStandbyTripPoint: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub CriticalTripPoint: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ActiveTripPointCount: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub ActiveTripPoint: [ULONG; 10usize],
    #[doc = "offset: 0x4c (76)"]
    pub S4TransitionTripPoint: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub MinimumThrottle: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub OverThrottleThreshold: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub PollingPeriod: ULONG,
}
#[doc = "0x54 (84) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IOP_IRP_STACK_PROFILER {
    #[doc = "offset: 0x0 (0)"]
    pub Profile: [ULONG; 20usize],
    #[doc = "offset: 0x50 (80)"]
    pub TotalIrps: ULONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDPC {
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub DpcListEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ProcessorHistory: ULONG,
    pub DeferredRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _KDPC, arg2: *mut VOID, arg3: *mut VOID, arg4: *mut VOID),
    >,
    #[doc = "offset: 0x10 (16)"]
    pub DeferredContext: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SystemArgument1: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub SystemArgument2: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub DpcData: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDPC__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub TargetInfoAsUlong: ULONG,
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Importance: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Number: USHORT,
}
impl Default for _KDPC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KDPC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_WORK_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ListLock: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ItemCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub Dpc: _KDPC,
    #[doc = "offset: 0x30 (48)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    pub WorkRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _WHEAP_WORK_QUEUE, arg2: *mut _LIST_ENTRY),
    >,
}
impl Default for _WHEAP_WORK_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEAP_INFO_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub ErrorSourceCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ErrorSourceTable: *mut _WHEAP_ERROR_SOURCE_TABLE,
    #[doc = "offset: 0x8 (8)"]
    pub WorkQueue: *mut _WHEAP_WORK_QUEUE,
}
impl Default for _WHEAP_INFO_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub DpcList: _KDPC_LIST,
    #[doc = "offset: 0x8 (8)"]
    pub DpcLock: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DpcQueueDepth: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub DpcCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ActiveDpc: *mut _KDPC,
}
impl Default for _KDPC_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BALANCED_NODE {
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1,
    pub __bindgen_anon_2: _RTL_BALANCED_NODE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Children: [*mut _RTL_BALANCED_NODE; 2usize],
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Left: *mut _RTL_BALANCED_NODE,
    #[doc = "offset: 0x4 (4)"]
    pub Right: *mut _RTL_BALANCED_NODE,
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_2 {
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub ParentValue: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _RTL_BALANCED_NODE__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Red(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Red(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Balance(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Red: UCHAR, Balance: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Red: u8 = unsafe { ::std::mem::transmute(Red) };
            Red as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let Balance: u8 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTL_BALANCED_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_PROVIDER_TRAITS {
    #[doc = "offset: 0x0 (0)"]
    pub Node: _RTL_BALANCED_NODE,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Traits: [UCHAR; 1usize],
}
impl Default for _ETW_PROVIDER_TRAITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMVAD_SHORT {
    pub __bindgen_anon_1: _MMVAD_SHORT__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub StartingVpn: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub EndingVpn: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub PushLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x1c (28)"]
    pub u: _MMVAD_SHORT__bindgen_ty_2,
    #[doc = "offset: 0x20 (32)"]
    pub u1: _MMVAD_SHORT__bindgen_ty_3,
    #[doc = "offset: 0x24 (36)"]
    pub EventList: *mut _MI_VAD_EVENT_BLOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_SHORT__bindgen_ty_1 {
    pub __bindgen_anon_1: _MMVAD_SHORT__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub VadNode: _RTL_BALANCED_NODE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMVAD_SHORT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub NextVad: *mut _MMVAD_SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub ExtraCreateInfo: *mut VOID,
}
impl Default for _MMVAD_SHORT__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMVAD_SHORT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_SHORT__bindgen_ty_2 {
    #[doc = "offset: 0x1c (28)"]
    pub LongFlags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub VadFlags: _MMVAD_FLAGS,
}
impl Default for _MMVAD_SHORT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_SHORT__bindgen_ty_3 {
    #[doc = "offset: 0x20 (32)"]
    pub LongFlags1: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub VadFlags1: _MMVAD_FLAGS1,
}
impl Default for _MMVAD_SHORT__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMVAD_SHORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PAGEFILE_BITMAPS_CACHE_ENTRY {
    pub __bindgen_anon_1: _MI_PAGEFILE_BITMAPS_CACHE_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub LocationTreeNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x18 (24)"]
    pub StartingIndex: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PAGEFILE_BITMAPS_CACHE_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub LengthTreeNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x0 (0)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _MI_PAGEFILE_BITMAPS_CACHE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_PAGEFILE_BITMAPS_CACHE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_IO_CONTROL_ENTRY {
    pub __bindgen_anon_1: _PS_IO_CONTROL_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub VolumeKey: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Rundown: _EX_RUNDOWN_REF,
    #[doc = "offset: 0x14 (20)"]
    pub IoControl: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub VolumeIoAttribution: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_IO_CONTROL_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub VolumeTreeNode: _RTL_BALANCED_NODE,
    pub __bindgen_anon_1: _PS_IO_CONTROL_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_IO_CONTROL_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub FreeListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ReservedForParentValue: ULONG,
}
impl Default for _PS_IO_CONTROL_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PS_IO_CONTROL_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PS_IO_CONTROL_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KLOCK_ENTRY {
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _KLOCK_ENTRY__bindgen_ty_2,
    pub __bindgen_anon_3: _KLOCK_ENTRY__bindgen_ty_3,
    pub __bindgen_anon_4: _KLOCK_ENTRY__bindgen_ty_4,
    #[doc = "offset: 0x28 (40)"]
    pub EntryLock: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub BoostBitmap: _KLOCK_ENTRY_BOOST_BITMAP,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub TreeNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x0 (0)"]
    pub FreeListEntry: _SINGLE_LIST_ENTRY,
}
impl Default for _KLOCK_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_2 {
    #[doc = "offset: 0xc (12)"]
    pub EntryFlags: ULONG,
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub EntryOffset: UCHAR,
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0xd (13)"]
    pub ThreadLocalFlags: UCHAR,
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn WaitingBit(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WaitingBit(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare0(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WaitingBit: UCHAR, Spare0: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WaitingBit: u8 = unsafe { ::std::mem::transmute(WaitingBit) };
            WaitingBit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Spare0: u8 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0xe (14)"]
    pub AcquiredByte: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn AcquiredBit(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AcquiredBit(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(AcquiredBit: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AcquiredBit: u8 = unsafe { ::std::mem::transmute(AcquiredBit) };
            AcquiredBit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0xf (15)"]
    pub CrossThreadFlags: UCHAR,
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn HeadNodeBit(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeadNodeBit(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoPriorityBit(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IoPriorityBit(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoQoSWaiter(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IoQoSWaiter(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HeadNodeBit: UCHAR,
        IoPriorityBit: UCHAR,
        IoQoSWaiter: UCHAR,
        Spare1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HeadNodeBit: u8 = unsafe { ::std::mem::transmute(HeadNodeBit) };
            HeadNodeBit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IoPriorityBit: u8 = unsafe { ::std::mem::transmute(IoPriorityBit) };
            IoPriorityBit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IoQoSWaiter: u8 = unsafe { ::std::mem::transmute(IoQoSWaiter) };
            IoQoSWaiter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Spare1: u8 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KLOCK_ENTRY__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn StaticState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_StaticState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn AllFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_AllFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        StaticState: ULONG,
        AllFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let StaticState: u32 = unsafe { ::std::mem::transmute(StaticState) };
            StaticState as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let AllFlags: u32 = unsafe { ::std::mem::transmute(AllFlags) };
            AllFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KLOCK_ENTRY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_3 {
    #[doc = "offset: 0x10 (16)"]
    pub LockState: _KLOCK_ENTRY_LOCK_STATE,
    #[doc = "offset: 0x10 (16)"]
    pub LockUnsafe: *mut VOID,
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KLOCK_ENTRY__bindgen_ty_3__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub CrossThreadReleasableAndBusyByte: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub Reserved: [UCHAR; 2usize],
    #[doc = "offset: 0x13 (19)"]
    pub InTreeByte: UCHAR,
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub SessionState: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SessionId: ULONG,
}
impl Default for _KLOCK_ENTRY__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KLOCK_ENTRY__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KLOCK_ENTRY__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLOCK_ENTRY__bindgen_ty_4 {
    pub __bindgen_anon_1: _KLOCK_ENTRY__bindgen_ty_4__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub CpuPriorityKey: CHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KLOCK_ENTRY__bindgen_ty_4__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub OwnerTree: _RTL_RB_TREE,
    #[doc = "offset: 0x20 (32)"]
    pub WaiterTree: _RTL_RB_TREE,
}
impl Default for _KLOCK_ENTRY__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KLOCK_ENTRY__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KLOCK_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
    #[doc = "offset: 0x0 (0)"]
    pub VirtualAddress: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
}
#[doc = "0xe0 (224) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Magic: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MajorLinkerVersion: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub MinorLinkerVersion: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub SizeOfCode: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SizeOfInitializedData: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SizeOfUninitializedData: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AddressOfEntryPoint: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub BaseOfCode: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub BaseOfData: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ImageBase: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub SectionAlignment: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub FileAlignment: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub MajorOperatingSystemVersion: USHORT,
    #[doc = "offset: 0x2a (42)"]
    pub MinorOperatingSystemVersion: USHORT,
    #[doc = "offset: 0x2c (44)"]
    pub MajorImageVersion: USHORT,
    #[doc = "offset: 0x2e (46)"]
    pub MinorImageVersion: USHORT,
    #[doc = "offset: 0x30 (48)"]
    pub MajorSubsystemVersion: USHORT,
    #[doc = "offset: 0x32 (50)"]
    pub MinorSubsystemVersion: USHORT,
    #[doc = "offset: 0x34 (52)"]
    pub Win32VersionValue: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub SizeOfImage: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub SizeOfHeaders: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub CheckSum: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub Subsystem: USHORT,
    #[doc = "offset: 0x46 (70)"]
    pub DllCharacteristics: USHORT,
    #[doc = "offset: 0x48 (72)"]
    pub SizeOfStackReserve: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub SizeOfStackCommit: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub SizeOfHeapReserve: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub SizeOfHeapCommit: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub LoaderFlags: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub NumberOfRvaAndSizes: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub DataDirectory: [_IMAGE_DATA_DIRECTORY; 16usize],
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Machine: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NumberOfSections: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub TimeDateStamp: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub PointerToSymbolTable: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub NumberOfSymbols: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SizeOfOptionalHeader: USHORT,
    #[doc = "offset: 0x12 (18)"]
    pub Characteristics: USHORT,
}
#[doc = "0xf8 (248) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FileHeader: _IMAGE_FILE_HEADER,
    #[doc = "offset: 0x18 (24)"]
    pub OptionalHeader: _IMAGE_OPTIONAL_HEADER,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: LONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_SOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub SourceName: [CHAR; 8usize],
    #[doc = "offset: 0x8 (8)"]
    pub SourceIdentifier: _LUID,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_CONTROL {
    #[doc = "offset: 0x0 (0)"]
    pub TokenId: _LUID,
    #[doc = "offset: 0x8 (8)"]
    pub AuthenticationId: _LUID,
    #[doc = "offset: 0x10 (16)"]
    pub ModifiedId: _LUID,
    #[doc = "offset: 0x18 (24)"]
    pub TokenSource: _TOKEN_SOURCE,
}
#[doc = "0x3c (60) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_CLIENT_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityQos: _SECURITY_QUALITY_OF_SERVICE,
    #[doc = "offset: 0xc (12)"]
    pub ClientToken: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub DirectlyAccessClientToken: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub DirectAccessEffectiveOnly: UCHAR,
    #[doc = "offset: 0x12 (18)"]
    pub ServerIsRemote: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub ClientTokenControl: _TOKEN_CONTROL,
}
impl Default for _SECURITY_CLIENT_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    #[doc = "offset: 0x0 (0)"]
    pub Luid: _LUID,
    #[doc = "offset: 0x8 (8)"]
    pub Attributes: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_PRIVILEGES {
    #[doc = "offset: 0x0 (0)"]
    pub PrivilegeCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Privileges: [_LUID_AND_ATTRIBUTES; 1usize],
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    #[doc = "offset: 0x0 (0)"]
    pub PrivilegeCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Control: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Privilege: [_LUID_AND_ATTRIBUTES; 1usize],
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _INITIAL_PRIVILEGE_SET {
    #[doc = "offset: 0x0 (0)"]
    pub PrivilegeCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Control: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Privilege: [_LUID_AND_ATTRIBUTES; 3usize],
}
#[doc = "0x74 (116) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACCESS_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub OperationID: _LUID,
    #[doc = "offset: 0x8 (8)"]
    pub SecurityEvaluated: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub GenerateAudit: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub GenerateOnClose: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub PrivilegesAllocated: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub RemainingDesiredAccess: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PreviouslyGrantedAccess: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub OriginalDesiredAccess: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub SubjectSecurityContext: _SECURITY_SUBJECT_CONTEXT,
    #[doc = "offset: 0x2c (44)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub AuxData: *mut VOID,
    #[doc = "offset: 0x34 (52)"]
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    #[doc = "offset: 0x60 (96)"]
    pub AuditPrivileges: UCHAR,
    #[doc = "offset: 0x64 (100)"]
    pub ObjectName: _UNICODE_STRING,
    #[doc = "offset: 0x6c (108)"]
    pub ObjectTypeName: _UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ACCESS_STATE__bindgen_ty_1 {
    #[doc = "offset: 0x34 (52)"]
    pub InitialPrivilegeSet: _INITIAL_PRIVILEGE_SET,
    #[doc = "offset: 0x34 (52)"]
    pub PrivilegeSet: _PRIVILEGE_SET,
}
impl Default for _ACCESS_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ACCESS_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SECURITY_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityQos: *mut _SECURITY_QUALITY_OF_SERVICE,
    #[doc = "offset: 0x4 (4)"]
    pub AccessState: *mut _ACCESS_STATE,
    #[doc = "offset: 0x8 (8)"]
    pub DesiredAccess: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub FullCreateOptions: ULONG,
}
impl Default for _IO_SECURITY_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Shift: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TableSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Pivot: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DivisorMask: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub NumEntries: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub NonEmptyBuckets: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub NumEnumerators: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Directory: *mut VOID,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEP_LOWBOX_NUMBER_MAPPING {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub Bitmap: _RTL_BITMAP,
    #[doc = "offset: 0xc (12)"]
    pub HashTable: *mut _RTL_DYNAMIC_HASH_TABLE,
    #[doc = "offset: 0x10 (16)"]
    pub Active: UCHAR,
}
impl Default for _SEP_LOWBOX_NUMBER_MAPPING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SESSION_LOWBOX_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub SessionId: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub LowboxMap: _SEP_LOWBOX_NUMBER_MAPPING,
}
impl Default for _SESSION_LOWBOX_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEP_CACHED_HANDLES_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub HashTable: *mut _RTL_DYNAMIC_HASH_TABLE,
}
impl Default for _SEP_CACHED_HANDLES_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Linkage: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Signature: ULONG,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEP_CACHED_HANDLES_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub HashEntry: _RTL_DYNAMIC_HASH_TABLE_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub EntryDescriptor: _SEP_CACHED_HANDLES_ENTRY_DESCRIPTOR,
    #[doc = "offset: 0x1c (28)"]
    pub HandleCount: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Handles: *mut *mut VOID,
}
impl Default for _SEP_CACHED_HANDLES_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEP_LOWBOX_NUMBER_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub HashEntry: _RTL_DYNAMIC_HASH_TABLE_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub PackageSid: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub LowboxNumber: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub AtomTable: *mut VOID,
}
impl Default for _SEP_LOWBOX_NUMBER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
    pub __bindgen_anon_1: _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub ChainHead: *mut _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub BucketIndex: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub HashEntry: _RTL_DYNAMIC_HASH_TABLE_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub CurEntry: *mut _LIST_ENTRY,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub ChainHead: *mut _LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub PrevLinkage: *mut _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Signature: ULONG,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOATING_SAVE_AREA {
    #[doc = "offset: 0x0 (0)"]
    pub ControlWord: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub StatusWord: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TagWord: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ErrorOffset: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorSelector: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub DataOffset: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub DataSelector: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub RegisterArea: [UCHAR; 80usize],
    #[doc = "offset: 0x6c (108)"]
    pub Spare0: ULONG,
}
impl Default for _FLOATING_SAVE_AREA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXCEPTION_RECORD32 {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionCode: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub ExceptionFlags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ExceptionRecord: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ExceptionAddress: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub NumberParameters: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ExceptionInformation: [ULONG; 15usize],
}
#[doc = "0x54 (84) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKM_EXCEPTION32 {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionRecord: _EXCEPTION_RECORD32,
    #[doc = "offset: 0x50 (80)"]
    pub FirstChance: ULONG,
}
#[doc = "0x2cc (716) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub ContextFlags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Dr0: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Dr1: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Dr2: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Dr3: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Dr6: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Dr7: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub FloatSave: _FLOATING_SAVE_AREA,
    #[doc = "offset: 0x8c (140)"]
    pub SegGs: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub SegFs: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub SegEs: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub SegDs: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub Edi: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub Esi: ULONG,
    #[doc = "offset: 0xa4 (164)"]
    pub Ebx: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub Edx: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub Ecx: ULONG,
    #[doc = "offset: 0xb0 (176)"]
    pub Eax: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub Ebp: ULONG,
    #[doc = "offset: 0xb8 (184)"]
    pub Eip: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub SegCs: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub EFlags: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub Esp: ULONG,
    #[doc = "offset: 0xc8 (200)"]
    pub SegSs: ULONG,
    #[doc = "offset: 0xcc (204)"]
    pub ExtendedRegisters: [UCHAR; 512usize],
}
impl Default for _CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    #[doc = "offset: 0x4 (4)"]
    pub ContextRecord: *mut _CONTEXT,
}
impl Default for _EXCEPTION_POINTERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub Handler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _EXCEPTION_RECORD,
            arg2: *mut VOID,
            arg3: *mut _CONTEXT,
            arg4: *mut VOID,
        ) -> _EXCEPTION_DISPOSITION,
    >,
}
impl Default for _EXCEPTION_REGISTRATION_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionCode: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub ExceptionFlags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    #[doc = "offset: 0xc (12)"]
    pub ExceptionAddress: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub NumberParameters: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ExceptionInformation: [ULONG; 15usize],
}
impl Default for _EXCEPTION_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DRIVE_LETTER_CURDIR {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Length: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub TimeStamp: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DosPath: _STRING,
}
impl Default for _RTL_DRIVE_LETTER_CURDIR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    #[doc = "offset: 0x0 (0)"]
    pub DebugInfo: *mut _RTL_CRITICAL_SECTION_DEBUG,
    #[doc = "offset: 0x4 (4)"]
    pub LockCount: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub RecursionCount: LONG,
    #[doc = "offset: 0xc (12)"]
    pub OwningThread: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub LockSemaphore: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SpinCount: ULONG,
}
impl Default for _RTL_CRITICAL_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_LOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: _HEAP_LOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_LOCK__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub CriticalSection: _RTL_CRITICAL_SECTION,
    #[doc = "offset: 0x0 (0)"]
    pub Resource: _ERESOURCE,
}
impl Default for _HEAP_LOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub CreatorBackTraceIndex: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    #[doc = "offset: 0x8 (8)"]
    pub ProcessLocksList: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub EntryCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ContentionCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub CreatorBackTraceIndexHigh: USHORT,
    #[doc = "offset: 0x1e (30)"]
    pub SpareUSHORT: USHORT,
}
impl Default for _RTL_CRITICAL_SECTION_DEBUG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2a4 (676) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_USER_PROCESS_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub MaximumLength: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Length: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DebugFlags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ConsoleHandle: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub ConsoleFlags: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub StandardInput: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub StandardOutput: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub StandardError: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub CurrentDirectory: _CURDIR,
    #[doc = "offset: 0x30 (48)"]
    pub DllPath: _UNICODE_STRING,
    #[doc = "offset: 0x38 (56)"]
    pub ImagePathName: _UNICODE_STRING,
    #[doc = "offset: 0x40 (64)"]
    pub CommandLine: _UNICODE_STRING,
    #[doc = "offset: 0x48 (72)"]
    pub Environment: *mut VOID,
    #[doc = "offset: 0x4c (76)"]
    pub StartingX: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub StartingY: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub CountX: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub CountY: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub CountCharsX: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub CountCharsY: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub FillAttribute: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub WindowFlags: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub ShowWindowFlags: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub WindowTitle: _UNICODE_STRING,
    #[doc = "offset: 0x78 (120)"]
    pub DesktopInfo: _UNICODE_STRING,
    #[doc = "offset: 0x80 (128)"]
    pub ShellInfo: _UNICODE_STRING,
    #[doc = "offset: 0x88 (136)"]
    pub RuntimeData: _UNICODE_STRING,
    #[doc = "offset: 0x90 (144)"]
    pub CurrentDirectores: [_RTL_DRIVE_LETTER_CURDIR; 32usize],
    #[doc = "offset: 0x290 (656)"]
    pub EnvironmentSize: ULONG,
    #[doc = "offset: 0x294 (660)"]
    pub EnvironmentVersion: ULONG,
    #[doc = "offset: 0x298 (664)"]
    pub PackageDependencyData: *mut VOID,
    #[doc = "offset: 0x29c (668)"]
    pub ProcessGroupId: ULONG,
    #[doc = "offset: 0x2a0 (672)"]
    pub LoaderThreads: ULONG,
}
impl Default for _RTL_USER_PROCESS_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB_LDR_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Initialized: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub SsHandle: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub InLoadOrderModuleList: _LIST_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub InMemoryOrderModuleList: _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub InInitializationOrderModuleList: _LIST_ENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub EntryInProgress: *mut VOID,
    #[doc = "offset: 0x28 (40)"]
    pub ShutdownInProgress: UCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub ShutdownThreadId: *mut VOID,
}
impl Default for _PEB_LDR_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
    #[doc = "offset: 0x0 (0)"]
    pub Previous: *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME,
    #[doc = "offset: 0x4 (4)"]
    pub ActivationContext: *mut _ACTIVATION_CONTEXT,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
}
impl Default for _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACCESS_REASONS {
    #[doc = "offset: 0x0 (0)"]
    pub Data: [ULONG; 32usize],
}
#[doc = "0x88 (136) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
    #[doc = "offset: 0x0 (0)"]
    pub SidCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SidAttr: *mut _SID_AND_ATTRIBUTES,
    #[doc = "offset: 0x8 (8)"]
    pub Hash: [ULONG; 32usize],
}
impl Default for _SID_AND_ATTRIBUTES_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ACCESS_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub SidHash: *mut _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x4 (4)"]
    pub RestrictedSidHash: *mut _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x8 (8)"]
    pub Privileges: *mut _TOKEN_PRIVILEGES,
    #[doc = "offset: 0xc (12)"]
    pub AuthenticationId: _LUID,
    #[doc = "offset: 0x14 (20)"]
    pub TokenType: _TOKEN_TYPE,
    #[doc = "offset: 0x18 (24)"]
    pub ImpersonationLevel: _SECURITY_IMPERSONATION_LEVEL,
    #[doc = "offset: 0x1c (28)"]
    pub MandatoryPolicy: _TOKEN_MANDATORY_POLICY,
    #[doc = "offset: 0x20 (32)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub AppContainerNumber: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub PackageSid: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub CapabilitiesHash: *mut _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x30 (48)"]
    pub TrustLevelSid: *mut VOID,
    #[doc = "offset: 0x34 (52)"]
    pub SecurityAttributes: *mut VOID,
}
impl Default for _TOKEN_ACCESS_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x130 (304) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceGroupsCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub pDeviceGroups: *mut _SID_AND_ATTRIBUTES,
    #[doc = "offset: 0x8 (8)"]
    pub RestrictedDeviceGroupsCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub pRestrictedDeviceGroups: *mut _SID_AND_ATTRIBUTES,
    #[doc = "offset: 0x10 (16)"]
    pub DeviceGroupsHash: _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x98 (152)"]
    pub RestrictedDeviceGroupsHash: _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x120 (288)"]
    pub pUserSecurityAttributes: *mut _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION,
    #[doc = "offset: 0x124 (292)"]
    pub pDeviceSecurityAttributes: *mut _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION,
    #[doc = "offset: 0x128 (296)"]
    pub pRestrictedUserSecurityAttributes: *mut _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION,
    #[doc = "offset: 0x12c (300)"]
    pub pRestrictedDeviceSecurityAttributes: *mut _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION,
}
impl Default for _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x6c (108) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEP_LOGON_SESSION_REFERENCES {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _SEP_LOGON_SESSION_REFERENCES,
    #[doc = "offset: 0x4 (4)"]
    pub LogonId: _LUID,
    #[doc = "offset: 0xc (12)"]
    pub BuddyLogonId: _LUID,
    #[doc = "offset: 0x14 (20)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub pDeviceMap: *mut _DEVICE_MAP,
    #[doc = "offset: 0x20 (32)"]
    pub Token: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub AccountName: _UNICODE_STRING,
    #[doc = "offset: 0x2c (44)"]
    pub AuthorityName: _UNICODE_STRING,
    #[doc = "offset: 0x34 (52)"]
    pub CachedHandlesTable: _SEP_CACHED_HANDLES_TABLE,
    #[doc = "offset: 0x3c (60)"]
    pub SharedDataLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x40 (64)"]
    pub SharedClaimAttributes: *mut _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION,
    #[doc = "offset: 0x44 (68)"]
    pub SharedSidValues: *mut _SEP_SID_VALUES_BLOCK,
    #[doc = "offset: 0x48 (72)"]
    pub RevocationBlock: _OB_HANDLE_REVOCATION_BLOCK,
    #[doc = "offset: 0x58 (88)"]
    pub ServerSilo: *mut _EJOB,
    #[doc = "offset: 0x5c (92)"]
    pub SiblingAuthId: _LUID,
    #[doc = "offset: 0x64 (100)"]
    pub TokenList: _LIST_ENTRY,
}
impl Default for _SEP_LOGON_SESSION_REFERENCES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VI_VERIFIER_ISSUE {
    #[doc = "offset: 0x0 (0)"]
    pub IssueType: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Address: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Parameters: [ULONG; 2usize],
}
impl Default for _VI_VERIFIER_ISSUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_STATE_NAME {
    #[doc = "offset: 0x0 (0)"]
    pub Data: [ULONG; 2usize],
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_UOW_KEY_STATE_MODIFICATION {
    #[doc = "offset: 0x0 (0)"]
    pub RefCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SubKeyListCount: [ULONG; 2usize],
    #[doc = "offset: 0xc (12)"]
    pub NewSubKeyList: [ULONG; 2usize],
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_PERF_HISTORY {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Slot: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub UtilityTotal: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AffinitizedUtilityTotal: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub FrequencyTotal: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub TaggedPercentTotal: [ULONG; 2usize],
    #[doc = "offset: 0x1c (28)"]
    pub HistoryList: [_PROC_PERF_HISTORY_ENTRY; 1usize],
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Previous: *mut _TEB_ACTIVE_FRAME,
    #[doc = "offset: 0x8 (8)"]
    pub Context: *mut _TEB_ACTIVE_FRAME_CONTEXT,
}
impl Default for _TEB_ACTIVE_FRAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4e0 (1248) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDI_TEB_BATCH32 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x4 (4)"]
    pub HDC: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _GDI_TEB_BATCH32 {
    #[inline]
    pub fn Offset(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Offset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn HasRenderingCommand(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasRenderingCommand(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Offset: ULONG,
        HasRenderingCommand: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let Offset: u32 = unsafe { ::std::mem::transmute(Offset) };
            Offset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let HasRenderingCommand: u32 = unsafe { ::std::mem::transmute(HasRenderingCommand) };
            HasRenderingCommand as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RSDS {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Guid: _GUID,
    #[doc = "offset: 0x14 (20)"]
    pub Age: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PdbName: [CHAR; 1usize],
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CVDD {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub NB10: _NB10,
    #[doc = "offset: 0x0 (0)"]
    pub RsDs: _RSDS,
}
impl Default for _CVDD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_DEBUGID_TRACKING_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ConsumersNotified: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub Spare: [UCHAR; 3usize],
    #[doc = "offset: 0xc (12)"]
    pub DebugIdSize: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DebugId: _CVDD,
}
impl Default for _ETW_DEBUGID_TRACKING_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x34 (52) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_WORKITEM {
    #[doc = "offset: 0x0 (0)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    pub Routine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut _IO_WORKITEM),
    >,
    #[doc = "offset: 0x14 (20)"]
    pub IoObject: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub WorkOnBehalfThread: *mut _ETHREAD,
    #[doc = "offset: 0x20 (32)"]
    pub Type: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ActivityId: _GUID,
}
impl Default for _IO_WORKITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_DEVICE_ACTION_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0xc (12)"]
    pub RequestType: _PNP_DEVICE_ACTION_REQUEST,
    #[doc = "offset: 0x10 (16)"]
    pub ReorderingBarrier: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub RequestArgument: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CompletionEvent: *mut _KEVENT,
    #[doc = "offset: 0x1c (28)"]
    pub CompletionStatus: *mut LONG,
    #[doc = "offset: 0x20 (32)"]
    pub ActivityId: _GUID,
    #[doc = "offset: 0x30 (48)"]
    pub RefCount: LONG,
    #[doc = "offset: 0x34 (52)"]
    pub Dequeued: UCHAR,
    #[doc = "offset: 0x38 (56)"]
    pub CancelLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x3c (60)"]
    pub CancelRequested: UCHAR,
}
impl Default for _PNP_DEVICE_ACTION_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x13 (19) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TlgProviderMetadata_t {
    #[doc = "offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub ProviderId: _GUID,
    #[doc = "offset: 0x11 (17)"]
    pub RemainingSize: USHORT,
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub SectionOffset: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SectionLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Revision: _WHEA_REVISION,
    #[doc = "offset: 0xa (10)"]
    pub ValidBits: _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS,
    #[doc = "offset: 0xb (11)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub Flags: _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS,
    #[doc = "offset: 0x10 (16)"]
    pub SectionType: _GUID,
    #[doc = "offset: 0x20 (32)"]
    pub FRUId: _GUID,
    #[doc = "offset: 0x30 (48)"]
    pub SectionSeverity: _WHEA_ERROR_SEVERITY,
    #[doc = "offset: 0x34 (52)"]
    pub FRUText: [CHAR; 20usize],
}
impl Default for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc4 (196) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AUX_ACCESS_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub PrivilegesUsed: *mut _PRIVILEGE_SET,
    #[doc = "offset: 0x4 (4)"]
    pub GenericMapping: _GENERIC_MAPPING,
    #[doc = "offset: 0x14 (20)"]
    pub AccessesToAudit: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub MaximumAuditMask: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub TransactionId: _GUID,
    #[doc = "offset: 0x2c (44)"]
    pub NewSecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub ExistingSecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x34 (52)"]
    pub ParentSecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub DeRefSecurityDescriptor:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID)>,
    #[doc = "offset: 0x3c (60)"]
    pub SDLock: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub AccessReasons: _ACCESS_REASONS,
    #[doc = "offset: 0xc0 (192)"]
    pub GenerateStagingEvents: UCHAR,
}
impl Default for _AUX_ACCESS_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KEY_BODY {
    #[doc = "offset: 0x0 (0)"]
    pub Type: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub KeyControlBlock: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x8 (8)"]
    pub NotifyBlock: *mut _CM_NOTIFY_BLOCK,
    #[doc = "offset: 0xc (12)"]
    pub ProcessID: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub KeyBodyList: _LIST_ENTRY,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x1c (28)"]
    pub Trans: _CM_TRANS_PTR,
    #[doc = "offset: 0x20 (32)"]
    pub KtmUow: *mut _GUID,
    #[doc = "offset: 0x24 (36)"]
    pub ContextListHead: _LIST_ENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub EnumerationResumeContext: *mut VOID,
}
impl Default for _CM_KEY_BODY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_KEY_BODY {
    #[inline]
    pub fn Flags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn HandleTags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_HandleTags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Flags: ULONG, HandleTags: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Flags: u32 = unsafe { ::std::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let HandleTags: u32 = unsafe { ::std::mem::transmute(HandleTags) };
            HandleTags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_NOTIFY_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub HiveList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub PostList: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub KeyControlBlock: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x14 (20)"]
    pub KeyBody: *mut _CM_KEY_BODY,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x1c (28)"]
    pub SubjectContext: _SECURITY_SUBJECT_CONTEXT,
}
impl Default for _CM_NOTIFY_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_NOTIFY_BLOCK {
    #[inline]
    pub fn Filter(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Filter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn WatchTree(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WatchTree(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NotifyPending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NotifyPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Filter: ULONG,
        WatchTree: ULONG,
        NotifyPending: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let Filter: u32 = unsafe { ::std::mem::transmute(Filter) };
            Filter as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let WatchTree: u32 = unsafe { ::std::mem::transmute(WatchTree) };
            WatchTree as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let NotifyPending: u32 = unsafe { ::std::mem::transmute(NotifyPending) };
            NotifyPending as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERIODIC_CAPTURE_STATE_GUIDS {
    #[doc = "offset: 0x0 (0)"]
    pub ProviderCount: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Providers: *mut _GUID,
}
impl Default for _PERIODIC_CAPTURE_STATE_GUIDS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISALLOWED_GUIDS {
    #[doc = "offset: 0x0 (0)"]
    pub Count: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Guids: *mut _GUID,
}
impl Default for _DISALLOWED_GUIDS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_DECODE_CONTROL_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _ETW_DECODE_CONTROL_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Decode: _GUID,
    #[doc = "offset: 0x14 (20)"]
    pub Control: _GUID,
    #[doc = "offset: 0x24 (36)"]
    pub ConsumersNotified: UCHAR,
}
impl Default for _ETW_DECODE_CONTROL_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub EventGuid: _GUID,
    #[doc = "offset: 0x10 (16)"]
    pub EventCategory: _PLUGPLAY_EVENT_CATEGORY,
    #[doc = "offset: 0x14 (20)"]
    pub Result: *mut ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub TotalSize: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub DeviceObject: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub u: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0x24 (36)"]
    pub DeviceClass: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x24 (36)"]
    pub TargetDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x24 (36)"]
    pub InstallDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3,
    #[doc = "offset: 0x24 (36)"]
    pub CustomNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4,
    #[doc = "offset: 0x24 (36)"]
    pub ProfileNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x24 (36)"]
    pub PowerNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6,
    #[doc = "offset: 0x24 (36)"]
    pub VetoNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7,
    #[doc = "offset: 0x24 (36)"]
    pub BlockedDriverNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8,
    #[doc = "offset: 0x24 (36)"]
    pub InvalidIDNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9,
    #[doc = "offset: 0x24 (36)"]
    pub PowerSettingNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_10,
    #[doc = "offset: 0x24 (36)"]
    pub PropertyChangeNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_11,
    #[doc = "offset: 0x24 (36)"]
    pub DeviceInstanceNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_12,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ClassGuid: _GUID,
    #[doc = "offset: 0x10 (16)"]
    pub SymbolicLinkName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationStructure: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceId: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub Notification: *mut VOID,
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationCode: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NotificationData: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
    #[doc = "offset: 0x0 (0)"]
    pub VetoType: _PNP_VETO_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceIdVetoNameBuffer: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8 {
    #[doc = "offset: 0x0 (0)"]
    pub BlockedDriverGuid: _GUID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9 {
    #[doc = "offset: 0x0 (0)"]
    pub ParentId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_10 {
    #[doc = "offset: 0x0 (0)"]
    pub PowerSettingGuid: _GUID,
    #[doc = "offset: 0x10 (16)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub SessionId: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub DataLength: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Data: [UCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_11 {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_12 {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceId: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PLUGPLAY_EVENT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x88 (136) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_DEVICE_EVENT_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Argument: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ArgumentStatus: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub CallerEvent: *mut _KEVENT,
    #[doc = "offset: 0x14 (20)"]
    pub Callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0x18 (24)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub VetoType: *mut _PNP_VETO_TYPE,
    #[doc = "offset: 0x20 (32)"]
    pub VetoName: *mut _UNICODE_STRING,
    #[doc = "offset: 0x24 (36)"]
    pub RefCount: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Cancel: UCHAR,
    #[doc = "offset: 0x30 (48)"]
    pub Parent: *mut _PNP_DEVICE_EVENT_ENTRY,
    #[doc = "offset: 0x34 (52)"]
    pub ActivityId: _GUID,
    #[doc = "offset: 0x44 (68)"]
    pub Data: _PLUGPLAY_EVENT_BLOCK,
}
impl Default for _PNP_DEVICE_EVENT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4e0 (1248) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDI_TEB_BATCH {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x4 (4)"]
    pub HDC: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _GDI_TEB_BATCH {
    #[inline]
    pub fn Offset(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Offset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn HasRenderingCommand(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasRenderingCommand(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Offset: ULONG,
        HasRenderingCommand: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let Offset: u32 = unsafe { ::std::mem::transmute(Offset) };
            Offset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let HasRenderingCommand: u32 = unsafe { ::std::mem::transmute(HasRenderingCommand) };
            HasRenderingCommand as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STACK {
    #[doc = "offset: 0x0 (0)"]
    pub ActiveFrame: *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME,
    #[doc = "offset: 0x4 (4)"]
    pub FrameListCache: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub NextCookieSequenceNumber: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub StackId: ULONG,
}
impl Default for _ACTIVATION_CONTEXT_STACK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x6c (108) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBP_SYSTEM_DOS_DEVICE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub GlobalDeviceMap: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub LocalDeviceCount: [ULONG; 26usize],
}
#[doc = "0x1a4 (420) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBP_SILODRIVERSTATE {
    #[doc = "offset: 0x0 (0)"]
    pub SystemDeviceMap: *mut _DEVICE_MAP,
    #[doc = "offset: 0x4 (4)"]
    pub SystemDosDeviceState: _OBP_SYSTEM_DOS_DEVICE_STATE,
    #[doc = "offset: 0x70 (112)"]
    pub DeviceMapLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x74 (116)"]
    pub PrivateNamespaceLookupTable: _OBJECT_NAMESPACE_LOOKUPTABLE,
}
impl Default for _OBP_SILODRIVERSTATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    #[doc = "offset: 0x4 (4)"]
    pub StackBase: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub StackLimit: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub SubSystemTib: *mut VOID,
    pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub ArbitraryUserPointer: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub FiberData: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub Version: ULONG,
}
impl Default for _NT_TIB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NT_TIB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3 {
    #[doc = "offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Pool: *mut _TP_POOL,
    #[doc = "offset: 0x8 (8)"]
    pub CleanupGroup: *mut _TP_CLEANUP_GROUP,
    pub CleanupGroupCancelCallback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID)>,
    #[doc = "offset: 0x10 (16)"]
    pub RaceDll: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub ActivationContext: *mut _ACTIVATION_CONTEXT,
    pub FinalizationCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _TP_CALLBACK_INSTANCE, arg2: *mut VOID),
    >,
    #[doc = "offset: 0x1c (28)"]
    pub u: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub CallbackPriority: _TP_CALLBACK_PRIORITY,
    #[doc = "offset: 0x24 (36)"]
    pub Size: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
    #[doc = "offset: 0x1c (28)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub s: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LongFunction(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LongFunction(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Persistent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Persistent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Private(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Private(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LongFunction: ULONG,
        Persistent: ULONG,
        Private: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LongFunction: u32 = unsafe { ::std::mem::transmute(LongFunction) };
            LongFunction as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Persistent: u32 = unsafe { ::std::mem::transmute(Persistent) };
            Persistent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Private: u32 = unsafe { ::std::mem::transmute(Private) };
            Private as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TP_CALLBACK_ENVIRON_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSTATE_FEATURE {
    #[doc = "offset: 0x0 (0)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
}
#[doc = "0x128 (296) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KENTROPY_TIMING_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub EntropyCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Buffer: [ULONG; 64usize],
    #[doc = "offset: 0x104 (260)"]
    pub Dpc: _KDPC,
    #[doc = "offset: 0x124 (292)"]
    pub LastDeliveredBuffer: ULONG,
}
impl Default for _KENTROPY_TIMING_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    #[doc = "offset: 0x0 (0)"]
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: LONG,
}
impl Default for _LARGE_INTEGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAST_ERESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub Reserved1: [*mut VOID; 3usize],
    #[doc = "offset: 0xc (12)"]
    pub Reserved2: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Reserved3: [*mut VOID; 4usize],
    #[doc = "offset: 0x20 (32)"]
    pub Reserved4: [ULONG; 4usize],
    #[doc = "offset: 0x30 (48)"]
    pub Reserved6: [*mut VOID; 2usize],
}
impl Default for _FAST_ERESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ROM_OPTIONAL_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Magic: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MajorLinkerVersion: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub MinorLinkerVersion: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub SizeOfCode: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SizeOfInitializedData: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SizeOfUninitializedData: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AddressOfEntryPoint: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub BaseOfCode: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub BaseOfData: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub BaseOfBss: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub GprMask: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub CprMask: [ULONG; 4usize],
    #[doc = "offset: 0x34 (52)"]
    pub GpValue: ULONG,
}
#[doc = "0x20ac (8364) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTSS {
    #[doc = "offset: 0x0 (0)"]
    pub Backlink: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Reserved0: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Esp0: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Ss0: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub Reserved1: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub NotUsed1: [ULONG; 4usize],
    #[doc = "offset: 0x1c (28)"]
    pub CR3: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Eip: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub EFlags: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Eax: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Ecx: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub Edx: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub Ebx: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub Esp: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub Ebp: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub Esi: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub Edi: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub Es: USHORT,
    #[doc = "offset: 0x4a (74)"]
    pub Reserved2: USHORT,
    #[doc = "offset: 0x4c (76)"]
    pub Cs: USHORT,
    #[doc = "offset: 0x4e (78)"]
    pub Reserved3: USHORT,
    #[doc = "offset: 0x50 (80)"]
    pub Ss: USHORT,
    #[doc = "offset: 0x52 (82)"]
    pub Reserved4: USHORT,
    #[doc = "offset: 0x54 (84)"]
    pub Ds: USHORT,
    #[doc = "offset: 0x56 (86)"]
    pub Reserved5: USHORT,
    #[doc = "offset: 0x58 (88)"]
    pub Fs: USHORT,
    #[doc = "offset: 0x5a (90)"]
    pub Reserved6: USHORT,
    #[doc = "offset: 0x5c (92)"]
    pub Gs: USHORT,
    #[doc = "offset: 0x5e (94)"]
    pub Reserved7: USHORT,
    #[doc = "offset: 0x60 (96)"]
    pub LDT: USHORT,
    #[doc = "offset: 0x62 (98)"]
    pub Reserved8: USHORT,
    #[doc = "offset: 0x64 (100)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x66 (102)"]
    pub IoMapBase: USHORT,
    #[doc = "offset: 0x68 (104)"]
    pub IoMaps: [_KiIoAccessMap; 1usize],
    #[doc = "offset: 0x208c (8332)"]
    pub IntDirectionMap: [UCHAR; 32usize],
}
impl Default for _KTSS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SYSTEM_TRIM_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub ExpansionLock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TrimInProgressCount: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub PeriodicWorkingSetEvent: _KEVENT,
    #[doc = "offset: 0x18 (24)"]
    pub TrimAllPageFaultCount: [ULONG; 3usize],
}
impl Default for _MI_SYSTEM_TRIM_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xe8 (232) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_POLICY {
    #[doc = "offset: 0x0 (0)"]
    pub Revision: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PowerButton: POWER_ACTION_POLICY,
    #[doc = "offset: 0x10 (16)"]
    pub SleepButton: POWER_ACTION_POLICY,
    #[doc = "offset: 0x1c (28)"]
    pub LidClose: POWER_ACTION_POLICY,
    #[doc = "offset: 0x28 (40)"]
    pub LidOpenWake: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x2c (44)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub Idle: POWER_ACTION_POLICY,
    #[doc = "offset: 0x3c (60)"]
    pub IdleTimeout: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub IdleSensitivity: UCHAR,
    #[doc = "offset: 0x41 (65)"]
    pub DynamicThrottle: UCHAR,
    #[doc = "offset: 0x42 (66)"]
    pub Spare2: [UCHAR; 2usize],
    #[doc = "offset: 0x44 (68)"]
    pub MinSleep: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x48 (72)"]
    pub MaxSleep: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x4c (76)"]
    pub ReducedLatencySleep: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x50 (80)"]
    pub WinLogonFlags: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub Spare3: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub DozeS4Timeout: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub BroadcastCapacityResolution: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
    #[doc = "offset: 0xc0 (192)"]
    pub VideoTimeout: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub VideoDimDisplay: UCHAR,
    #[doc = "offset: 0xc8 (200)"]
    pub VideoReserved: [ULONG; 3usize],
    #[doc = "offset: 0xd4 (212)"]
    pub SpindownTimeout: ULONG,
    #[doc = "offset: 0xd8 (216)"]
    pub OptimizeForPower: UCHAR,
    #[doc = "offset: 0xd9 (217)"]
    pub FanThrottleTolerance: UCHAR,
    #[doc = "offset: 0xda (218)"]
    pub ForcedThrottle: UCHAR,
    #[doc = "offset: 0xdb (219)"]
    pub MinThrottle: UCHAR,
    #[doc = "offset: 0xdc (220)"]
    pub OverThrottled: POWER_ACTION_POLICY,
}
impl Default for _SYSTEM_POWER_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x144 (324) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_POWER_SETTING_VALUES {
    #[doc = "offset: 0x0 (0)"]
    pub StructureSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PopPolicy: _SYSTEM_POWER_POLICY,
    #[doc = "offset: 0xec (236)"]
    pub CurrentAcDcPowerState: SYSTEM_POWER_CONDITION,
    #[doc = "offset: 0xf0 (240)"]
    pub AwayModeEnabled: UCHAR,
    #[doc = "offset: 0xf1 (241)"]
    pub AwayModeEngaged: UCHAR,
    #[doc = "offset: 0xf2 (242)"]
    pub AwayModePolicyAllowed: UCHAR,
    #[doc = "offset: 0xf4 (244)"]
    pub AwayModeIgnoreUserPresent: LONG,
    #[doc = "offset: 0xf8 (248)"]
    pub AwayModeIgnoreAction: LONG,
    #[doc = "offset: 0xfc (252)"]
    pub DisableFastS4: UCHAR,
    #[doc = "offset: 0xfd (253)"]
    pub DisableStandbyStates: UCHAR,
    #[doc = "offset: 0x100 (256)"]
    pub UnattendSleepTimeout: ULONG,
    #[doc = "offset: 0x104 (260)"]
    pub DiskIgnoreTime: ULONG,
    #[doc = "offset: 0x108 (264)"]
    pub DeviceIdlePolicy: ULONG,
    #[doc = "offset: 0x10c (268)"]
    pub VideoDimTimeout: ULONG,
    #[doc = "offset: 0x110 (272)"]
    pub VideoNormalBrightness: ULONG,
    #[doc = "offset: 0x114 (276)"]
    pub VideoDimBrightness: ULONG,
    #[doc = "offset: 0x118 (280)"]
    pub AlsOffset: ULONG,
    #[doc = "offset: 0x11c (284)"]
    pub AlsEnabled: ULONG,
    #[doc = "offset: 0x120 (288)"]
    pub EsBrightness: ULONG,
    #[doc = "offset: 0x124 (292)"]
    pub SwitchShutdownForced: UCHAR,
    #[doc = "offset: 0x128 (296)"]
    pub SystemCoolingPolicy: ULONG,
    #[doc = "offset: 0x12c (300)"]
    pub MediaBufferingEngaged: UCHAR,
    #[doc = "offset: 0x12d (301)"]
    pub AudioActivity: UCHAR,
    #[doc = "offset: 0x12e (302)"]
    pub FullscreenVideoPlayback: UCHAR,
    #[doc = "offset: 0x130 (304)"]
    pub EsBatteryThreshold: ULONG,
    #[doc = "offset: 0x134 (308)"]
    pub EsAggressive: UCHAR,
    #[doc = "offset: 0x135 (309)"]
    pub EsUserAwaySetting: UCHAR,
    #[doc = "offset: 0x138 (312)"]
    pub ConnectivityInStandby: ULONG,
    #[doc = "offset: 0x13c (316)"]
    pub DisconnectedStandbyMode: ULONG,
    #[doc = "offset: 0x140 (320)"]
    pub UserPresencePredictionEnabled: ULONG,
}
impl Default for _POP_POWER_SETTING_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x100 (256) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KNODE {
    #[doc = "offset: 0x0 (0)"]
    pub IdleNonParkedCpuSet: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub IdleSmtSet: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub IdleCpuSet: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub DeepIdleSet: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub IdleConstrainedSet: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub NonParkedSet: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub ParkLock: LONG,
    #[doc = "offset: 0x50 (80)"]
    pub Seed: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub SiblingMask: ULONG,
    pub __bindgen_anon_1: _KNODE__bindgen_ty_1,
    #[doc = "offset: 0x90 (144)"]
    pub SharedReadyQueueLeaders: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub ProximityId: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub Lowest: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub Highest: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub MaximumProcessors: UCHAR,
    #[doc = "offset: 0xa1 (161)"]
    pub Flags: _flags,
    #[doc = "offset: 0xa2 (162)"]
    pub Spare10: UCHAR,
    #[doc = "offset: 0xa4 (164)"]
    pub HeteroSets: [_KHETERO_PROCESSOR_SET; 5usize],
    #[doc = "offset: 0xe0 (224)"]
    pub PpmConfiguredQosSets: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KNODE__bindgen_ty_1 {
    #[doc = "offset: 0x84 (132)"]
    pub Affinity: _GROUP_AFFINITY,
    pub __bindgen_anon_1: _KNODE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KNODE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x84 (132)"]
    pub AffinityFill: [UCHAR; 6usize],
    #[doc = "offset: 0x8a (138)"]
    pub NodeNumber: USHORT,
    #[doc = "offset: 0x8c (140)"]
    pub PrimaryNodeNumber: USHORT,
    #[doc = "offset: 0x8e (142)"]
    pub Stride: UCHAR,
    #[doc = "offset: 0x8f (143)"]
    pub Spare0: UCHAR,
}
impl Default for _KNODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KNODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x140 (320) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ENODE {
    #[doc = "offset: 0x0 (0)"]
    pub Ncb: _KNODE,
    #[doc = "offset: 0x100 (256)"]
    pub HotAddProcessorWorkItem: _WORK_QUEUE_ITEM,
}
impl Default for _ENODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c0 (448) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_WORK_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub WorkPriQueue: _KPRIQUEUE,
    #[doc = "offset: 0x19c (412)"]
    pub Partition: *mut _EX_PARTITION,
    #[doc = "offset: 0x1a0 (416)"]
    pub Node: *mut _ENODE,
    #[doc = "offset: 0x1a4 (420)"]
    pub WorkItemsProcessed: ULONG,
    #[doc = "offset: 0x1a8 (424)"]
    pub WorkItemsProcessedLastPass: ULONG,
    #[doc = "offset: 0x1ac (428)"]
    pub ThreadCount: LONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x1b4 (436)"]
    pub MaxThreads: LONG,
    #[doc = "offset: 0x1b8 (440)"]
    pub QueueIndex: _EXQUEUEINDEX,
    #[doc = "offset: 0x1bc (444)"]
    pub AllThreadsExitedEvent: *mut _KEVENT,
}
impl Default for _EX_WORK_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _EX_WORK_QUEUE {
    #[inline]
    pub fn MinThreads(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_MinThreads(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn TryFailed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TryFailed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MinThreads: LONG,
        TryFailed: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let MinThreads: u32 = unsafe { ::std::mem::transmute(MinThreads) };
            MinThreads as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let TryFailed: u32 = unsafe { ::std::mem::transmute(TryFailed) };
            TryFailed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_INDEX_HINT_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HashKey: [ULONG; 1usize],
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_KEY_INDEX {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Count: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub List: [ULONG; 1usize],
}
#[doc = "0x400 (1024) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_NODE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub LargePageFreeCount: [[ULONG; 2usize]; 2usize],
    #[doc = "offset: 0x10 (16)"]
    pub LargePagesCount: [[[[ULONG; 1usize]; 2usize]; 2usize]; 2usize],
    #[doc = "offset: 0x30 (48)"]
    pub LargePages: [[[[_LIST_ENTRY; 1usize]; 2usize]; 2usize]; 1usize],
    #[doc = "offset: 0x50 (80)"]
    pub MediumPages: [[[[_LIST_ENTRY; 16usize]; 1usize]; 2usize]; 2usize],
    #[doc = "offset: 0x250 (592)"]
    pub MediumPagesCount: [[[[ULONG; 16usize]; 1usize]; 2usize]; 2usize],
    #[doc = "offset: 0x350 (848)"]
    pub LargePageRebuildTimer: _MI_REBUILD_LARGE_PAGE_TIMER,
    #[doc = "offset: 0x380 (896)"]
    pub FreePageListHeadsBitmap: [_RTL_BITMAP; 2usize],
    #[doc = "offset: 0x390 (912)"]
    pub FreePageListHeadsBitmapBuffer: [ULONG; 16usize],
    #[doc = "offset: 0x3d0 (976)"]
    pub FreeCount: [ULONG; 2usize],
    #[doc = "offset: 0x3d8 (984)"]
    pub TotalPages: [ULONG; 1usize],
    #[doc = "offset: 0x3dc (988)"]
    pub TotalPagesEntireNode: ULONG,
    #[doc = "offset: 0x3e0 (992)"]
    pub MmShiftedColor: ULONG,
    #[doc = "offset: 0x3e4 (996)"]
    pub Color: ULONG,
    #[doc = "offset: 0x3e8 (1000)"]
    pub ChannelFreeCount: [[ULONG; 2usize]; 1usize],
    #[doc = "offset: 0x3f0 (1008)"]
    pub Flags: _MI_NODE_INFORMATION__bindgen_ty_1,
    #[doc = "offset: 0x3f4 (1012)"]
    pub NodeLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x3f8 (1016)"]
    pub ChannelStatus: UCHAR,
    #[doc = "offset: 0x3f9 (1017)"]
    pub ChannelOrdering: [UCHAR; 1usize],
    #[doc = "offset: 0x3fa (1018)"]
    pub LockedChannelOrdering: [UCHAR; 1usize],
    #[doc = "offset: 0x3fb (1019)"]
    pub PowerAttribute: [UCHAR; 1usize],
    #[doc = "offset: 0x3fc (1020)"]
    pub LargePageLock: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_NODE_INFORMATION__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MI_NODE_INFORMATION__bindgen_ty_1 {
    #[inline]
    pub fn ChannelsHotCold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ChannelsHotCold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ChannelsHotCold: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ChannelsHotCold: u32 = unsafe { ::std::mem::transmute(ChannelsHotCold) };
            ChannelsHotCold as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MI_NODE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xe4 (228) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION_CORE {
    #[doc = "offset: 0x0 (0)"]
    pub PartitionId: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub u: _MI_PARTITION_CORE__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub Signature: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub MemoryConfigurationChanged: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub NodeInformation: *mut _MI_NODE_INFORMATION,
    #[doc = "offset: 0x14 (20)"]
    pub PageRoot: _RTL_AVL_TREE,
    #[doc = "offset: 0x18 (24)"]
    pub MemoryNodeRuns: *mut _PHYSICAL_MEMORY_DESCRIPTOR,
    #[doc = "offset: 0x1c (28)"]
    pub MemoryBlockReferences: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub PfnUnmapWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x30 (48)"]
    pub PfnUnmapCount: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub PfnUnmapWaitList: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub MemoryRuns: *mut _PHYSICAL_MEMORY_DESCRIPTOR,
    #[doc = "offset: 0x3c (60)"]
    pub ExitEvent: _KEVENT,
    #[doc = "offset: 0x4c (76)"]
    pub SystemThreadHandles: [*mut VOID; 5usize],
    #[doc = "offset: 0x60 (96)"]
    pub PartitionObject: *mut _EPARTITION,
    #[doc = "offset: 0x64 (100)"]
    pub PartitionSystemThreadsLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x68 (104)"]
    pub DynamicMemoryPushLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x6c (108)"]
    pub DynamicMemoryLock: LONG,
    #[doc = "offset: 0x70 (112)"]
    pub PfnUnmapActive: UCHAR,
    #[doc = "offset: 0x74 (116)"]
    pub TemporaryMemoryEvent: _KEVENT,
    #[doc = "offset: 0x84 (132)"]
    pub RootDirectory: *mut VOID,
    #[doc = "offset: 0x88 (136)"]
    pub KernelObjectsDirectory: *mut VOID,
    #[doc = "offset: 0x8c (140)"]
    pub MemoryEvents: [*mut _KEVENT; 11usize],
    #[doc = "offset: 0xb8 (184)"]
    pub MemoryEventHandles: [*mut VOID; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PARTITION_CORE__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub LongFlags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: _MI_PARTITION_FLAGS,
}
impl Default for _MI_PARTITION_CORE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_PARTITION_CORE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID {
    #[doc = "offset: 0x0 (0)"]
    pub Revision: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub SubAuthorityCount: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub IdentifierAuthority: _SID_IDENTIFIER_AUTHORITY,
    #[doc = "offset: 0x8 (8)"]
    pub SubAuthority: [ULONG; 1usize],
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub NextEntryOffset: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SidLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Sid: _SID,
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub CompressionFormatAndEngine: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub CompressionUnitShift: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub ChunkShift: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub ClusterShift: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub NumberOfChunks: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub CompressedChunkSizes: [ULONG; 1usize],
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PPM_STATE_SELECTION {
    #[doc = "offset: 0x0 (0)"]
    pub SelectedState: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub VetoedStates: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub VetoReason: [ULONG; 1usize],
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KAFFINITY_EX {
    #[doc = "offset: 0x0 (0)"]
    pub Count: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Bitmap: [ULONG; 1usize],
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAFFINITY_ENUMERATION_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Affinity: *mut _KAFFINITY_EX,
    #[doc = "offset: 0x4 (4)"]
    pub CurrentMask: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentIndex: USHORT,
}
impl Default for _KAFFINITY_ENUMERATION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_DESCRIPTION {
    #[doc = "offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Master: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub ScatterGather: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub DemandMode: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub AutoInitialize: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub Dma32BitAddresses: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub IgnoreCount: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub Dma64BitAddresses: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DmaChannel: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = "offset: 0x18 (24)"]
    pub DmaWidth: _DMA_WIDTH,
    #[doc = "offset: 0x1c (28)"]
    pub DmaSpeed: _DMA_SPEED,
    #[doc = "offset: 0x20 (32)"]
    pub MaximumLength: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub DmaPort: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub DmaAddressWidth: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub DmaControllerInstance: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub DmaRequestLine: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub DeviceAddress: _LARGE_INTEGER,
}
impl Default for _DEVICE_DESCRIPTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa8 (168) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub InLoadOrderLinks: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub InMemoryOrderLinks: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub InInitializationOrderLinks: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub DllBase: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub EntryPoint: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub SizeOfImage: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub FullDllName: _UNICODE_STRING,
    #[doc = "offset: 0x2c (44)"]
    pub BaseDllName: _UNICODE_STRING,
    pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x38 (56)"]
    pub ObsoleteLoadCount: USHORT,
    #[doc = "offset: 0x3a (58)"]
    pub TlsIndex: USHORT,
    #[doc = "offset: 0x3c (60)"]
    pub HashLinks: _LIST_ENTRY,
    #[doc = "offset: 0x44 (68)"]
    pub TimeDateStamp: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub EntryPointActivationContext: *mut _ACTIVATION_CONTEXT,
    #[doc = "offset: 0x4c (76)"]
    pub Lock: *mut VOID,
    #[doc = "offset: 0x50 (80)"]
    pub DdagNode: *mut _LDR_DDAG_NODE,
    #[doc = "offset: 0x54 (84)"]
    pub NodeModuleLink: _LIST_ENTRY,
    #[doc = "offset: 0x5c (92)"]
    pub LoadContext: *mut _LDRP_LOAD_CONTEXT,
    #[doc = "offset: 0x60 (96)"]
    pub ParentDllBase: *mut VOID,
    #[doc = "offset: 0x64 (100)"]
    pub SwitchBackContext: *mut VOID,
    #[doc = "offset: 0x68 (104)"]
    pub BaseAddressIndexNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x74 (116)"]
    pub MappingInfoIndexNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x80 (128)"]
    pub OriginalBase: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub LoadTime: _LARGE_INTEGER,
    #[doc = "offset: 0x90 (144)"]
    pub BaseNameHashValue: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub LoadReason: _LDR_DLL_LOAD_REASON,
    #[doc = "offset: 0x98 (152)"]
    pub ImplicitPathOptions: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub ReferenceCount: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub DependentLoadFlags: ULONG,
    #[doc = "offset: 0xa4 (164)"]
    pub SigningLevel: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x34 (52)"]
    pub FlagGroup: [UCHAR; 4usize],
    #[doc = "offset: 0x34 (52)"]
    pub Flags: ULONG,
    pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn PackagedBinary(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PackagedBinary(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MarkedForRemoval(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MarkedForRemoval(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageDll(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImageDll(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoadNotificationsSent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoadNotificationsSent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TelemetryEntryProcessed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TelemetryEntryProcessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessStaticImport(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessStaticImport(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InLegacyLists(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InLegacyLists(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InIndexes(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InIndexes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShimDll(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ShimDll(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InExceptionTable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InExceptionTable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LoadInProgress(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoadInProgress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoadConfigProcessed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoadConfigProcessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EntryProcessed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EntryProcessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtectDelayLoad(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProtectDelayLoad(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags3(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DontCallForThreads(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DontCallForThreads(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessAttachCalled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessAttachCalled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessAttachFailed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessAttachFailed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CorDeferredValidate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorDeferredValidate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CorImage(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorImage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DontRelocate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DontRelocate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CorILOnly(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorILOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags5(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags5(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Redirected(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Redirected(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags6(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags6(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CompatDatabaseProcessed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompatDatabaseProcessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PackagedBinary: ULONG,
        MarkedForRemoval: ULONG,
        ImageDll: ULONG,
        LoadNotificationsSent: ULONG,
        TelemetryEntryProcessed: ULONG,
        ProcessStaticImport: ULONG,
        InLegacyLists: ULONG,
        InIndexes: ULONG,
        ShimDll: ULONG,
        InExceptionTable: ULONG,
        ReservedFlags1: ULONG,
        LoadInProgress: ULONG,
        LoadConfigProcessed: ULONG,
        EntryProcessed: ULONG,
        ProtectDelayLoad: ULONG,
        ReservedFlags3: ULONG,
        DontCallForThreads: ULONG,
        ProcessAttachCalled: ULONG,
        ProcessAttachFailed: ULONG,
        CorDeferredValidate: ULONG,
        CorImage: ULONG,
        DontRelocate: ULONG,
        CorILOnly: ULONG,
        ReservedFlags5: ULONG,
        Redirected: ULONG,
        ReservedFlags6: ULONG,
        CompatDatabaseProcessed: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PackagedBinary: u32 = unsafe { ::std::mem::transmute(PackagedBinary) };
            PackagedBinary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MarkedForRemoval: u32 = unsafe { ::std::mem::transmute(MarkedForRemoval) };
            MarkedForRemoval as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ImageDll: u32 = unsafe { ::std::mem::transmute(ImageDll) };
            ImageDll as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LoadNotificationsSent: u32 =
                unsafe { ::std::mem::transmute(LoadNotificationsSent) };
            LoadNotificationsSent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TelemetryEntryProcessed: u32 =
                unsafe { ::std::mem::transmute(TelemetryEntryProcessed) };
            TelemetryEntryProcessed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ProcessStaticImport: u32 = unsafe { ::std::mem::transmute(ProcessStaticImport) };
            ProcessStaticImport as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let InLegacyLists: u32 = unsafe { ::std::mem::transmute(InLegacyLists) };
            InLegacyLists as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let InIndexes: u32 = unsafe { ::std::mem::transmute(InIndexes) };
            InIndexes as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ShimDll: u32 = unsafe { ::std::mem::transmute(ShimDll) };
            ShimDll as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let InExceptionTable: u32 = unsafe { ::std::mem::transmute(InExceptionTable) };
            InExceptionTable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let ReservedFlags1: u32 = unsafe { ::std::mem::transmute(ReservedFlags1) };
            ReservedFlags1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LoadInProgress: u32 = unsafe { ::std::mem::transmute(LoadInProgress) };
            LoadInProgress as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LoadConfigProcessed: u32 = unsafe { ::std::mem::transmute(LoadConfigProcessed) };
            LoadConfigProcessed as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EntryProcessed: u32 = unsafe { ::std::mem::transmute(EntryProcessed) };
            EntryProcessed as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ProtectDelayLoad: u32 = unsafe { ::std::mem::transmute(ProtectDelayLoad) };
            ProtectDelayLoad as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ReservedFlags3: u32 = unsafe { ::std::mem::transmute(ReservedFlags3) };
            ReservedFlags3 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DontCallForThreads: u32 = unsafe { ::std::mem::transmute(DontCallForThreads) };
            DontCallForThreads as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ProcessAttachCalled: u32 = unsafe { ::std::mem::transmute(ProcessAttachCalled) };
            ProcessAttachCalled as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ProcessAttachFailed: u32 = unsafe { ::std::mem::transmute(ProcessAttachFailed) };
            ProcessAttachFailed as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let CorDeferredValidate: u32 = unsafe { ::std::mem::transmute(CorDeferredValidate) };
            CorDeferredValidate as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let CorImage: u32 = unsafe { ::std::mem::transmute(CorImage) };
            CorImage as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let DontRelocate: u32 = unsafe { ::std::mem::transmute(DontRelocate) };
            DontRelocate as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let CorILOnly: u32 = unsafe { ::std::mem::transmute(CorILOnly) };
            CorILOnly as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let ReservedFlags5: u32 = unsafe { ::std::mem::transmute(ReservedFlags5) };
            ReservedFlags5 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let Redirected: u32 = unsafe { ::std::mem::transmute(Redirected) };
            Redirected as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let ReservedFlags6: u32 = unsafe { ::std::mem::transmute(ReservedFlags6) };
            ReservedFlags6 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let CompatDatabaseProcessed: u32 =
                unsafe { ::std::mem::transmute(CompatDatabaseProcessed) };
            CompatDatabaseProcessed as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LDR_DATA_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_SYMBOLIC_LINK {
    #[doc = "offset: 0x0 (0)"]
    pub CreationTime: _LARGE_INTEGER,
    pub __bindgen_anon_1: _OBJECT_SYMBOLIC_LINK__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub DosDeviceDriveIndex: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub AccessMask: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_SYMBOLIC_LINK__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub LinkTarget: _UNICODE_STRING,
    pub __bindgen_anon_1: _OBJECT_SYMBOLIC_LINK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_SYMBOLIC_LINK__bindgen_ty_1__bindgen_ty_1 {
    pub Callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _OBJECT_SYMBOLIC_LINK,
            arg2: *mut VOID,
            arg3: *mut _UNICODE_STRING,
            arg4: *mut *mut VOID,
        ) -> LONG,
    >,
    #[doc = "offset: 0xc (12)"]
    pub CallbackContext: *mut VOID,
}
impl Default for _OBJECT_SYMBOLIC_LINK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_SYMBOLIC_LINK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_SYMBOLIC_LINK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_BAD_MEMORY_EVENT_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub BugCheckCode: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Active: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub Data: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub PhysicalAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
}
impl Default for _MI_BAD_MEMORY_EVENT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa8 (168) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_ERROR_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub BadMemoryEventEntry: _MI_BAD_MEMORY_EVENT_ENTRY,
    #[doc = "offset: 0x28 (40)"]
    pub PageOfInterest: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub ProbeRaises: _MI_PROBE_RAISE_TRACKER,
    #[doc = "offset: 0x6c (108)"]
    pub ForcedCommits: _MI_FORCED_COMMITS,
    #[doc = "offset: 0x74 (116)"]
    pub WsleFailures: [ULONG; 1usize],
    #[doc = "offset: 0x78 (120)"]
    pub PageHashErrors: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub CheckZeroCount: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub ZeroedPageSingleBitErrorsDetected: LONG,
    #[doc = "offset: 0x84 (132)"]
    pub BadPagesDetected: LONG,
    #[doc = "offset: 0x88 (136)"]
    pub ScrubPasses: LONG,
    #[doc = "offset: 0x8c (140)"]
    pub ScrubBadPagesFound: LONG,
    #[doc = "offset: 0x90 (144)"]
    pub UserViewFailures: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub UserViewCollisionFailures: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub ResavailFailures: _MI_RESAVAIL_FAILURES,
    #[doc = "offset: 0xa0 (160)"]
    pub PendingBadPages: UCHAR,
    #[doc = "offset: 0xa1 (161)"]
    pub InitFailure: UCHAR,
    #[doc = "offset: 0xa2 (162)"]
    pub StopBadMaps: UCHAR,
}
impl Default for _MI_ERROR_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x34 (52) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub ErrStatusBlockLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub RelatedErrorSourceId: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ErrStatusAddressSpaceID: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub ErrStatusAddressBitWidth: UCHAR,
    #[doc = "offset: 0xe (14)"]
    pub ErrStatusAddressBitOffset: UCHAR,
    #[doc = "offset: 0xf (15)"]
    pub ErrStatusAddressAccessSize: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub ErrStatusAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub Notify: _WHEA_NOTIFICATION_DESCRIPTOR,
}
impl Default for _WHEA_GENERIC_ERROR_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x110 (272) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRACE_LOGFILE_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub BufferSize: ULONG,
    pub __bindgen_anon_1: _TRACE_LOGFILE_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub ProviderVersion: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub NumberOfProcessors: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub EndTime: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub TimerResolution: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub MaximumFileSize: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub LogFileMode: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub BuffersWritten: ULONG,
    pub __bindgen_anon_2: _TRACE_LOGFILE_HEADER__bindgen_ty_2,
    #[doc = "offset: 0x38 (56)"]
    pub LoggerName: *mut WCHAR,
    #[doc = "offset: 0x3c (60)"]
    pub LogFileName: *mut WCHAR,
    #[doc = "offset: 0x40 (64)"]
    pub TimeZone: _RTL_TIME_ZONE_INFORMATION,
    #[doc = "offset: 0xf0 (240)"]
    pub BootTime: _LARGE_INTEGER,
    #[doc = "offset: 0xf8 (248)"]
    pub PerfFreq: _LARGE_INTEGER,
    #[doc = "offset: 0x100 (256)"]
    pub StartTime: _LARGE_INTEGER,
    #[doc = "offset: 0x108 (264)"]
    pub ReservedFlags: ULONG,
    #[doc = "offset: 0x10c (268)"]
    pub BuffersLost: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TRACE_LOGFILE_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub VersionDetail: _TRACE_LOGFILE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_LOGFILE_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub MajorVersion: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub MinorVersion: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub SubVersion: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub SubMinorVersion: UCHAR,
}
impl Default for _TRACE_LOGFILE_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TRACE_LOGFILE_HEADER__bindgen_ty_2 {
    #[doc = "offset: 0x28 (40)"]
    pub LogInstanceGuid: _GUID,
    pub __bindgen_anon_1: _TRACE_LOGFILE_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_LOGFILE_HEADER__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x28 (40)"]
    pub StartBuffers: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub PointerSize: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub EventsLost: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub CpuSpeedInMHz: ULONG,
}
impl Default for _TRACE_LOGFILE_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TRACE_LOGFILE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CryptoIndex: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AlgorithmId: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DataUnitSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub KeySize: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub KeyHash: [UCHAR; 32usize],
    #[doc = "offset: 0x38 (56)"]
    pub KeyVirtualAddress: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub KeyPhysicalAddress: _LARGE_INTEGER,
}
impl Default for _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VACB {
    #[doc = "offset: 0x0 (0)"]
    pub BaseAddress: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub SharedCacheMap: *mut _SHARED_CACHE_MAP,
    #[doc = "offset: 0x8 (8)"]
    pub Overlay: _VACB__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub ArrayHead: *mut _VACB_ARRAY_HEADER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VACB__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub FileOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub ActiveCount: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Links: _LIST_ENTRY,
}
impl Default for _VACB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VACB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOGGED_STREAM_CALLBACK_V1 {
    #[doc = "offset: 0x0 (0)"]
    pub LogHandle: *mut VOID,
    pub FlushToLsnRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: _LARGE_INTEGER)>,
}
impl Default for _LOGGED_STREAM_CALLBACK_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_IO_MEMORY_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _PEP_ACPI_RESOURCE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Information: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub Alignment: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Length: ULONG,
}
impl Default for _PEP_ACPI_IO_MEMORY_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HBIN {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FileOffset: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Size: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Reserved1: [ULONG; 2usize],
    #[doc = "offset: 0x14 (20)"]
    pub TimeStamp: _LARGE_INTEGER,
    #[doc = "offset: 0x1c (28)"]
    pub Spare: ULONG,
}
impl Default for _HBIN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSRTL_ADVANCED_FCB_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NodeByteSize: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub IsFastIoPossible: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub Flags2: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x8 (8)"]
    pub Resource: *mut _ERESOURCE,
    #[doc = "offset: 0xc (12)"]
    pub PagingIoResource: *mut _ERESOURCE,
    #[doc = "offset: 0x10 (16)"]
    pub AllocationSize: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub FileSize: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub ValidDataLength: _LARGE_INTEGER,
    #[doc = "offset: 0x28 (40)"]
    pub FastMutex: *mut _FAST_MUTEX,
    #[doc = "offset: 0x2c (44)"]
    pub FilterContexts: _LIST_ENTRY,
    #[doc = "offset: 0x34 (52)"]
    pub PushLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x38 (56)"]
    pub FileContextSupportPointer: *mut *mut VOID,
    pub __bindgen_anon_1: _FSRTL_ADVANCED_FCB_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub ReservedContext: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FSRTL_ADVANCED_FCB_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x3c (60)"]
    pub Oplock: *mut VOID,
    #[doc = "offset: 0x3c (60)"]
    pub ReservedForRemote: *mut VOID,
}
impl Default for _FSRTL_ADVANCED_FCB_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _FSRTL_ADVANCED_FCB_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _FSRTL_ADVANCED_FCB_HEADER {
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Version(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: UCHAR, Version: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Version: u8 = unsafe { ::std::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REF_CLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub StartTime: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub StartPerfClock: _LARGE_INTEGER,
}
impl Default for _ETW_REF_CLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_LAST_ENABLE_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub EnableFlags: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub LoggerId: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub Level: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _ETW_LAST_ENABLE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _ETW_LAST_ENABLE_INFO {
    #[inline]
    pub fn Enabled(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Enabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InternalFlag(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_InternalFlag(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enabled: UCHAR,
        InternalFlag: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enabled: u8 = unsafe { ::std::mem::transmute(Enabled) };
            Enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let InternalFlag: u8 = unsafe { ::std::mem::transmute(InternalFlag) };
            InternalFlag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub ShareDisposition: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Generic: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Port: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x4 (4)"]
    pub Interrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    #[doc = "offset: 0x4 (4)"]
    pub MessageInterrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    #[doc = "offset: 0x4 (4)"]
    pub Memory: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x4 (4)"]
    pub Dma: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    #[doc = "offset: 0x4 (4)"]
    pub DmaV3: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    #[doc = "offset: 0x4 (4)"]
    pub DevicePrivate: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    #[doc = "offset: 0x4 (4)"]
    pub BusNumber: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceSpecificData: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    #[doc = "offset: 0x4 (4)"]
    pub Memory40: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    #[doc = "offset: 0x4 (4)"]
    pub Memory48: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    #[doc = "offset: 0x4 (4)"]
    pub Memory64: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    #[doc = "offset: 0x4 (4)"]
    pub Connection: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub Length: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub Length: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub Level: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Group: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Affinity: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Raw:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Translated:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Group: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MessageCount: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Affinity: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub Level: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Group: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Affinity: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub Length: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub Channel: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Port: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved1: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    #[doc = "offset: 0x0 (0)"]
    pub Channel: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub RequestLine: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TransferWidth: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub Reserved2: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub Reserved3: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    #[doc = "offset: 0x0 (0)"]
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Length: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    #[doc = "offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved1: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub Length40: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub Length48: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    #[doc = "offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub Length64: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    #[doc = "offset: 0x0 (0)"]
    pub Class: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved2: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub IdLowPart: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub IdHighPart: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub AllocateFromCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub AllocateFrom: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
}
impl Default for _ARBITER_RETEST_ALLOCATION_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_TEST_ALLOCATION_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub AllocateFromCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub AllocateFrom: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
}
impl Default for _ARBITER_TEST_ALLOCATION_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Version: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Revision: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Count: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub PartialDescriptors: [_CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
impl Default for _CM_PARTIAL_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub AllocatedResources: *mut *mut _CM_PARTIAL_RESOURCE_LIST,
}
impl Default for _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub PartialResourceList: _CM_PARTIAL_RESOURCE_LIST,
}
impl Default for _CM_FULL_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_RESOURCE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub List: [_CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
impl Default for _CM_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEP_RM_LSA_CONNECTION_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub LsaProcessHandle: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub LsaCommandPortHandle: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub SepRmThreadHandle: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub RmCommandPortHandle: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub RmCommandServerPortHandle: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub LsaCommandPortSectionHandle: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub LsaCommandPortSectionSize: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub LsaViewPortMemory: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub RmViewPortMemory: *mut VOID,
    #[doc = "offset: 0x28 (40)"]
    pub LsaCommandPortMemoryDelta: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub LsaCommandPortActive: UCHAR,
}
impl Default for _SEP_RM_LSA_CONNECTION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub MailslotQuota: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaximumMessageSize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ReadTimeout: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub TimeoutSpecified: UCHAR,
}
impl Default for _MAILSLOT_CREATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub NamedPipeType: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ReadMode: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CompletionMode: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub MaximumInstances: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub InboundQuota: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub OutboundQuota: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub DefaultTimeout: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub TimeoutSpecified: UCHAR,
}
impl Default for _NAMED_PIPE_CREATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Option: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub ShareDisposition: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Spare1: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Spare2: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub Port: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub Memory: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x8 (8)"]
    pub Interrupt: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    #[doc = "offset: 0x8 (8)"]
    pub Dma: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    #[doc = "offset: 0x8 (8)"]
    pub DmaV3: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x8 (8)"]
    pub Generic: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    #[doc = "offset: 0x8 (8)"]
    pub DevicePrivate: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    #[doc = "offset: 0x8 (8)"]
    pub BusNumber: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    #[doc = "offset: 0x8 (8)"]
    pub ConfigData: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    #[doc = "offset: 0x8 (8)"]
    pub Memory40: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    #[doc = "offset: 0x8 (8)"]
    pub Memory48: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    #[doc = "offset: 0x8 (8)"]
    pub Memory64: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    #[doc = "offset: 0x8 (8)"]
    pub Connection: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Alignment: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Alignment: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub MinimumVector: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaximumVector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub AffinityPolicy: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub Group: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub PriorityPolicy: _IRQ_PRIORITY,
    #[doc = "offset: 0x10 (16)"]
    pub TargetedProcessors: ULONG,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub MinimumChannel: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaximumChannel: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub RequestLine: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Channel: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TransferWidth: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Alignment: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    #[doc = "offset: 0x0 (0)"]
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MinBusNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MaxBusNumber: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    #[doc = "offset: 0x0 (0)"]
    pub Priority: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved1: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    #[doc = "offset: 0x0 (0)"]
    pub Length40: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Alignment40: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    #[doc = "offset: 0x0 (0)"]
    pub Length48: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Alignment48: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    #[doc = "offset: 0x0 (0)"]
    pub Length64: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Alignment64: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    #[doc = "offset: 0x0 (0)"]
    pub Class: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Type: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved2: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub IdLowPart: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub IdHighPart: ULONG,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Version: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Revision: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Count: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Descriptors: [_IO_RESOURCE_DESCRIPTOR; 1usize],
}
impl Default for _IO_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub ListSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = "offset: 0x8 (8)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SlotNumber: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Reserved: [ULONG; 3usize],
    #[doc = "offset: 0x1c (28)"]
    pub AlternativeLists: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub List: [_IO_RESOURCE_LIST; 1usize],
}
impl Default for _IO_RESOURCE_REQUIREMENTS_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_RESOURCE_REQUEST {
    #[doc = "offset: 0x0 (0)"]
    pub PhysicalDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub AllocationType: _ARBITER_REQUEST_SOURCE,
    #[doc = "offset: 0xc (12)"]
    pub Priority: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Position: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ResourceRequirements: *mut _IO_RESOURCE_REQUIREMENTS_LIST,
    #[doc = "offset: 0x18 (24)"]
    pub ReqList: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub ResourceAssignment: *mut _CM_RESOURCE_LIST,
    #[doc = "offset: 0x20 (32)"]
    pub TranslatedResourceAssignment: *mut _CM_RESOURCE_LIST,
    #[doc = "offset: 0x24 (36)"]
    pub Status: LONG,
}
impl Default for _PNP_RESOURCE_REQUEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_LIST_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub AlternativeCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Alternatives: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = "offset: 0x10 (16)"]
    pub PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub RequestSource: _ARBITER_REQUEST_SOURCE,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub WorkSpace: LONG,
    #[doc = "offset: 0x20 (32)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = "offset: 0x24 (36)"]
    pub SlotNumber: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Assignment: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
    #[doc = "offset: 0x30 (48)"]
    pub SelectedAlternative: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = "offset: 0x34 (52)"]
    pub Result: _ARBITER_RESULT,
}
impl Default for _ARBITER_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub ResourceType: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub AlternativeCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ResourceRequests: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = "offset: 0xc (12)"]
    pub ArbiterInstance: *mut VOID,
}
impl Default for _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub CreationTime: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub LastAccessTime: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub ChangeTime: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub AllocationSize: _LARGE_INTEGER,
    #[doc = "offset: 0x28 (40)"]
    pub EndOfFile: _LARGE_INTEGER,
    #[doc = "offset: 0x30 (48)"]
    pub FileAttributes: ULONG,
}
impl Default for _FILE_NETWORK_OPEN_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub AllocationSize: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub EndOfFile: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub NumberOfLinks: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub DeletePending: UCHAR,
    #[doc = "offset: 0x15 (21)"]
    pub Directory: UCHAR,
}
impl Default for _FILE_STANDARD_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub CreationTime: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub LastAccessTime: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub ChangeTime: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub FileAttributes: ULONG,
}
impl Default for _FILE_BASIC_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x88 (136) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OPEN_PACKET {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub FinalStatus: LONG,
    #[doc = "offset: 0xc (12)"]
    pub Information: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ParseCheck: ULONG,
    pub __bindgen_anon_1: _OPEN_PACKET__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub OriginalAttributes: *mut _OBJECT_ATTRIBUTES,
    #[doc = "offset: 0x20 (32)"]
    pub AllocationSize: _LARGE_INTEGER,
    #[doc = "offset: 0x28 (40)"]
    pub CreateOptions: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub FileAttributes: USHORT,
    #[doc = "offset: 0x2e (46)"]
    pub ShareAccess: USHORT,
    #[doc = "offset: 0x30 (48)"]
    pub EaBuffer: *mut VOID,
    #[doc = "offset: 0x34 (52)"]
    pub EaLength: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub Options: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub Disposition: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub BasicInformation: *mut _FILE_BASIC_INFORMATION,
    #[doc = "offset: 0x44 (68)"]
    pub NetworkInformation: *mut _FILE_NETWORK_OPEN_INFORMATION,
    #[doc = "offset: 0x48 (72)"]
    pub FileInformation: *mut VOID,
    #[doc = "offset: 0x4c (76)"]
    pub CreateFileType: _CREATE_FILE_TYPE,
    #[doc = "offset: 0x50 (80)"]
    pub MailslotOrPipeParameters: *mut VOID,
    #[doc = "offset: 0x54 (84)"]
    pub Override: UCHAR,
    #[doc = "offset: 0x55 (85)"]
    pub QueryOnly: UCHAR,
    #[doc = "offset: 0x56 (86)"]
    pub DeleteOnly: UCHAR,
    #[doc = "offset: 0x57 (87)"]
    pub FullAttributes: UCHAR,
    #[doc = "offset: 0x58 (88)"]
    pub LocalFileObject: *mut _DUMMY_FILE_OBJECT,
    #[doc = "offset: 0x5c (92)"]
    pub InternalFlags: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub AccessMode: CHAR,
    #[doc = "offset: 0x64 (100)"]
    pub DriverCreateContext: _IO_DRIVER_CREATE_CONTEXT,
    #[doc = "offset: 0x78 (120)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
    #[doc = "offset: 0x7c (124)"]
    pub FileInformationLength: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub FilterQuery: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OPEN_PACKET__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub RelatedFileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub ReferencedDeviceObject: *mut _DEVICE_OBJECT,
}
impl Default for _OPEN_PACKET__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OPEN_PACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUMP_INITIALIZATION_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MemoryBlock: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub CommonBuffer: [*mut VOID; 2usize],
    #[doc = "offset: 0x18 (24)"]
    pub PhysicalAddress: [_LARGE_INTEGER; 2usize],
    #[doc = "offset: 0x28 (40)"]
    pub StallRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: ULONG)>,
    #[doc = "offset: 0x2c (44)"]
    pub OpenRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: _LARGE_INTEGER) -> UCHAR>,
    pub WriteRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _LARGE_INTEGER, arg2: *mut _MDL) -> LONG,
    >,
    #[doc = "offset: 0x34 (52)"]
    pub FinishRoutine: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "offset: 0x38 (56)"]
    pub AdapterObject: *mut _ADAPTER_OBJECT,
    #[doc = "offset: 0x3c (60)"]
    pub MappedRegisterBase: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub PortConfiguration: *mut VOID,
    #[doc = "offset: 0x44 (68)"]
    pub CrashDump: UCHAR,
    #[doc = "offset: 0x45 (69)"]
    pub MarkMemoryOnly: UCHAR,
    #[doc = "offset: 0x46 (70)"]
    pub HiberResume: UCHAR,
    #[doc = "offset: 0x47 (71)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0x48 (72)"]
    pub MaximumTransferSize: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub CommonBufferSize: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub TargetAddress: *mut VOID,
    pub WritePendingRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LONG,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _MDL,
            arg4: *mut VOID,
        ) -> LONG,
    >,
    #[doc = "offset: 0x58 (88)"]
    pub PartitionStyle: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub DiskInfo: _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1,
    pub ReadRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: LONG, arg2: *mut _LARGE_INTEGER, arg3: *mut _MDL) -> LONG,
    >,
    pub GetDriveTelemetryRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: ULONG, arg2: ULONG, arg3: *mut VOID, arg4: ULONG) -> LONG,
    >,
    #[doc = "offset: 0x74 (116)"]
    pub LogSectionTruncateSize: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub Parameters: [ULONG; 16usize],
    pub GetTransferSizesRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ULONG, arg2: *mut ULONG)>,
    pub DumpNotifyRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: _DUMP_EVENTS, arg2: *mut VOID, arg3: ULONG),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1 {
    #[doc = "offset: 0x5c (92)"]
    pub Mbr: _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x5c (92)"]
    pub Gpt: _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CheckSum: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub DiskId: _GUID,
}
impl Default for _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DUMP_INITIALIZATION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x100 (256) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUMP_STACK_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Init: _DUMP_INITIALIZATION_CONTEXT,
    #[doc = "offset: 0xc0 (192)"]
    pub PartitionOffset: _LARGE_INTEGER,
    pub __bindgen_anon_1: _DUMP_STACK_CONTEXT__bindgen_ty_1,
    #[doc = "offset: 0xcc (204)"]
    pub UseStorageInfo: UCHAR,
    #[doc = "offset: 0xd0 (208)"]
    pub PointersLength: ULONG,
    #[doc = "offset: 0xd4 (212)"]
    pub ModulePrefix: *mut WCHAR,
    #[doc = "offset: 0xd8 (216)"]
    pub DriverList: _LIST_ENTRY,
    #[doc = "offset: 0xe0 (224)"]
    pub InitMsg: _STRING,
    #[doc = "offset: 0xe8 (232)"]
    pub ProgMsg: _STRING,
    #[doc = "offset: 0xf0 (240)"]
    pub DoneMsg: _STRING,
    #[doc = "offset: 0xf8 (248)"]
    pub FileObject: *mut VOID,
    #[doc = "offset: 0xfc (252)"]
    pub UsageType: _DEVICE_USAGE_NOTIFICATION_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DUMP_STACK_CONTEXT__bindgen_ty_1 {
    #[doc = "offset: 0xc8 (200)"]
    pub DumpPointers: *mut VOID,
    #[doc = "offset: 0xc8 (200)"]
    pub StorageInfo: *mut VOID,
}
impl Default for _DUMP_STACK_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DUMP_STACK_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub Vpb: *mut _VPB,
    #[doc = "offset: 0xc (12)"]
    pub FsContext: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub FsContext2: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SectionObjectPointer: *mut _SECTION_OBJECT_POINTERS,
    #[doc = "offset: 0x18 (24)"]
    pub PrivateCacheMap: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub FinalStatus: LONG,
    #[doc = "offset: 0x20 (32)"]
    pub RelatedFileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x24 (36)"]
    pub LockOperation: UCHAR,
    #[doc = "offset: 0x25 (37)"]
    pub DeletePending: UCHAR,
    #[doc = "offset: 0x26 (38)"]
    pub ReadAccess: UCHAR,
    #[doc = "offset: 0x27 (39)"]
    pub WriteAccess: UCHAR,
    #[doc = "offset: 0x28 (40)"]
    pub DeleteAccess: UCHAR,
    #[doc = "offset: 0x29 (41)"]
    pub SharedRead: UCHAR,
    #[doc = "offset: 0x2a (42)"]
    pub SharedWrite: UCHAR,
    #[doc = "offset: 0x2b (43)"]
    pub SharedDelete: UCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub FileName: _UNICODE_STRING,
    #[doc = "offset: 0x38 (56)"]
    pub CurrentByteOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x40 (64)"]
    pub Waiters: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub Busy: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub LastLock: *mut VOID,
    #[doc = "offset: 0x4c (76)"]
    pub Lock: _KEVENT,
    #[doc = "offset: 0x5c (92)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x6c (108)"]
    pub CompletionContext: *mut _IO_COMPLETION_CONTEXT,
    #[doc = "offset: 0x70 (112)"]
    pub IrpListLock: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub IrpList: _LIST_ENTRY,
    #[doc = "offset: 0x7c (124)"]
    pub FileObjectExtension: *mut VOID,
}
impl Default for _FILE_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x70 (112) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub MdlAddress: *mut _MDL,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub ThreadListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub IoStatus: _IO_STATUS_BLOCK,
    #[doc = "offset: 0x20 (32)"]
    pub RequestorMode: CHAR,
    #[doc = "offset: 0x21 (33)"]
    pub PendingReturned: UCHAR,
    #[doc = "offset: 0x22 (34)"]
    pub StackCount: CHAR,
    #[doc = "offset: 0x23 (35)"]
    pub CurrentLocation: CHAR,
    #[doc = "offset: 0x24 (36)"]
    pub Cancel: UCHAR,
    #[doc = "offset: 0x25 (37)"]
    pub CancelIrql: UCHAR,
    #[doc = "offset: 0x26 (38)"]
    pub ApcEnvironment: CHAR,
    #[doc = "offset: 0x27 (39)"]
    pub AllocationFlags: UCHAR,
    #[doc = "offset: 0x28 (40)"]
    pub UserIosb: *mut _IO_STATUS_BLOCK,
    #[doc = "offset: 0x2c (44)"]
    pub UserEvent: *mut _KEVENT,
    #[doc = "offset: 0x30 (48)"]
    pub Overlay: _IRP__bindgen_ty_2,
    pub CancelRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP)>,
    #[doc = "offset: 0x3c (60)"]
    pub UserBuffer: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub Tail: _IRP__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub MasterIrp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub IrpCount: LONG,
    #[doc = "offset: 0xc (12)"]
    pub SystemBuffer: *mut VOID,
}
impl Default for _IRP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    #[doc = "offset: 0x30 (48)"]
    pub AsynchronousParameters: _IRP__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x30 (48)"]
    pub AllocationSize: _LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub UserApcContext: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _IO_STATUS_BLOCK, arg3: ULONG),
    >,
    #[doc = "offset: 0x0 (0)"]
    pub IssuingProcess: *mut VOID,
}
impl Default for _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3 {
    #[doc = "offset: 0x40 (64)"]
    pub Overlay: _IRP__bindgen_ty_3__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub Apc: _KAPC,
    #[doc = "offset: 0x40 (64)"]
    pub CompletionKey: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0x14 (20)"]
    pub AuxiliaryBuffer: *mut CHAR,
    #[doc = "offset: 0x18 (24)"]
    pub ListEntry: _LIST_ENTRY,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x24 (36)"]
    pub OriginalFileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x28 (40)"]
    pub IrpExtension: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceQueueEntry: _KDEVICE_QUEUE_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub DriverContext: [*mut VOID; 4usize],
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x20 (32)"]
    pub CurrentStackLocation: *mut _IO_STACK_LOCATION,
    #[doc = "offset: 0x20 (32)"]
    pub PacketType: ULONG,
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VF_WATCHDOG_IRP {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub DueTickCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Inserted: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub TrackedStackLocation: CHAR,
    #[doc = "offset: 0x12 (18)"]
    pub CancelTimeoutTicks: USHORT,
}
impl Default for _VF_WATCHDOG_IRP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WAITING_IRP {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub CompletionRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _IRP)>,
    #[doc = "offset: 0x10 (16)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub Event: *mut _KEVENT,
    #[doc = "offset: 0x18 (24)"]
    pub Information: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub BreakAllRH: UCHAR,
    #[doc = "offset: 0x1d (29)"]
    pub OplockBreakNotify: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub FileObject: *mut _FILE_OBJECT,
}
impl Default for _WAITING_IRP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x100 (256) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOV_FORCED_PENDING_TRACE {
    #[doc = "offset: 0x0 (0)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0x4 (4)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0x8 (8)"]
    pub StackTrace: [*mut VOID; 62usize],
}
impl Default for _IOV_FORCED_PENDING_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOV_IRP_TRACE {
    #[doc = "offset: 0x0 (0)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0x4 (4)"]
    pub Thread: *mut _KTHREAD,
    pub __bindgen_anon_1: _IOV_IRP_TRACE__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub Irql: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub StackTrace: [*mut VOID; 12usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOV_IRP_TRACE__bindgen_ty_1 {
    pub __bindgen_anon_1: _IOV_IRP_TRACE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub CombinedApcDisable: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IOV_IRP_TRACE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub KernelApcDisable: SHORT,
    #[doc = "offset: 0xa (10)"]
    pub SpecialApcDisable: SHORT,
}
impl Default for _IOV_IRP_TRACE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IOV_IRP_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIAGE_POP_IRP_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub Pdo: *mut _DEVICE_OBJECT,
}
impl Default for _TRIAGE_POP_IRP_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIAGE_POP_FX_DEVICE {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub IrpData: *mut _TRIAGE_POP_IRP_DATA,
    #[doc = "offset: 0x10 (16)"]
    pub Status: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub PowerReqCall: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub PowerNotReqCall: LONG,
    #[doc = "offset: 0x1c (28)"]
    pub DeviceNode: *mut _TRIAGE_DEVICE_NODE,
}
impl Default for _TRIAGE_POP_FX_DEVICE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIAGE_DEVICE_NODE {
    #[doc = "offset: 0x0 (0)"]
    pub Sibling: *mut _TRIAGE_DEVICE_NODE,
    #[doc = "offset: 0x4 (4)"]
    pub Child: *mut _TRIAGE_DEVICE_NODE,
    #[doc = "offset: 0x8 (8)"]
    pub Parent: *mut _TRIAGE_DEVICE_NODE,
    #[doc = "offset: 0xc (12)"]
    pub LastChild: *mut _TRIAGE_DEVICE_NODE,
    #[doc = "offset: 0x10 (16)"]
    pub PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub InstancePath: _UNICODE_STRING,
    #[doc = "offset: 0x1c (28)"]
    pub ServiceName: _UNICODE_STRING,
    #[doc = "offset: 0x24 (36)"]
    pub PendingIrp: *mut _IRP,
    #[doc = "offset: 0x28 (40)"]
    pub FxDevice: *mut _TRIAGE_POP_FX_DEVICE,
}
impl Default for _TRIAGE_DEVICE_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_POLICY_DEVICE {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceType: POWER_POLICY_DEVICE_TYPE,
    #[doc = "offset: 0xc (12)"]
    pub Notification: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub Name: _UNICODE_STRING,
    #[doc = "offset: 0x18 (24)"]
    pub Device: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x1c (28)"]
    pub Irp: *mut _IRP,
}
impl Default for _POP_POLICY_DEVICE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_IRP_WORKER_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0xc (12)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0x10 (16)"]
    pub Device: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub Static: UCHAR,
}
impl Default for _POP_IRP_WORKER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FS_FILTER_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub AcquireForModifiedPageWriter: _FS_FILTER_PARAMETERS__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub ReleaseForModifiedPageWriter: _FS_FILTER_PARAMETERS__bindgen_ty_2,
    #[doc = "offset: 0x0 (0)"]
    pub AcquireForSectionSynchronization: _FS_FILTER_PARAMETERS__bindgen_ty_3,
    #[doc = "offset: 0x0 (0)"]
    pub NotifyStreamFileObject: _FS_FILTER_PARAMETERS__bindgen_ty_4,
    #[doc = "offset: 0x0 (0)"]
    pub QueryOpen: _FS_FILTER_PARAMETERS__bindgen_ty_5,
    #[doc = "offset: 0x0 (0)"]
    pub Others: _FS_FILTER_PARAMETERS__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub EndingOffset: *mut _LARGE_INTEGER,
    #[doc = "offset: 0x4 (4)"]
    pub ResourceToRelease: *mut *mut _ERESOURCE,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub ResourceToRelease: *mut _ERESOURCE,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub SyncType: _FS_FILTER_SECTION_SYNC_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub PageProtection: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub OutputInformation: *mut _FS_FILTER_SECTION_SYNC_OUTPUT,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationType: _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub SafeToRecurse: UCHAR,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0x4 (4)"]
    pub FileInformation: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Length: *mut ULONG,
    #[doc = "offset: 0xc (12)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
    #[doc = "offset: 0x10 (16)"]
    pub CompletionStatus: LONG,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub Argument1: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Argument2: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Argument3: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Argument4: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub Argument5: *mut VOID,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _FS_FILTER_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FS_FILTER_CALLBACK_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub SizeOfFsFilterCallbackData: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Operation: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0xc (12)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x10 (16)"]
    pub Parameters: _FS_FILTER_PARAMETERS,
}
impl Default for _FS_FILTER_CALLBACK_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FS_FILTER_CALLBACKS {
    #[doc = "offset: 0x0 (0)"]
    pub SizeOfFsFilterCallbacks: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
    pub PreAcquireForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostAcquireForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreReleaseForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostReleaseForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreAcquireForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostAcquireForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreReleaseForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostReleaseForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreAcquireForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostAcquireForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreReleaseForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostReleaseForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreQueryOpen: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostQueryOpen: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION {
    #[doc = "offset: 0x0 (0)"]
    pub MajorFunction: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub MinorFunction: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Control: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x18 (24)"]
    pub FileObject: *mut _FILE_OBJECT,
    pub CompletionRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP, arg3: *mut VOID) -> LONG,
    >,
    #[doc = "offset: 0x20 (32)"]
    pub Context: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Create: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub CreatePipe: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x4 (4)"]
    pub CreateMailslot: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    #[doc = "offset: 0x4 (4)"]
    pub Read: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    #[doc = "offset: 0x4 (4)"]
    pub Write: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x4 (4)"]
    pub QueryDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    #[doc = "offset: 0x4 (4)"]
    pub NotifyDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    #[doc = "offset: 0x4 (4)"]
    pub NotifyDirectoryEx: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    #[doc = "offset: 0x4 (4)"]
    pub QueryFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    #[doc = "offset: 0x4 (4)"]
    pub SetFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    #[doc = "offset: 0x4 (4)"]
    pub QueryEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    #[doc = "offset: 0x4 (4)"]
    pub SetEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    #[doc = "offset: 0x4 (4)"]
    pub QueryVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    #[doc = "offset: 0x4 (4)"]
    pub SetVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    #[doc = "offset: 0x4 (4)"]
    pub FileSystemControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    #[doc = "offset: 0x4 (4)"]
    pub LockControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceIoControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    #[doc = "offset: 0x4 (4)"]
    pub QuerySecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    #[doc = "offset: 0x4 (4)"]
    pub SetSecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    #[doc = "offset: 0x4 (4)"]
    pub MountVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    #[doc = "offset: 0x4 (4)"]
    pub VerifyVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    #[doc = "offset: 0x4 (4)"]
    pub Scsi: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    #[doc = "offset: 0x4 (4)"]
    pub QueryQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    #[doc = "offset: 0x4 (4)"]
    pub SetQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    #[doc = "offset: 0x4 (4)"]
    pub QueryDeviceRelations: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    #[doc = "offset: 0x4 (4)"]
    pub QueryInterface: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceCapabilities: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    #[doc = "offset: 0x4 (4)"]
    pub FilterResourceRequirements: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    #[doc = "offset: 0x4 (4)"]
    pub ReadWriteConfig: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    #[doc = "offset: 0x4 (4)"]
    pub SetLock: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    #[doc = "offset: 0x4 (4)"]
    pub QueryId: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    #[doc = "offset: 0x4 (4)"]
    pub QueryDeviceText: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    #[doc = "offset: 0x4 (4)"]
    pub UsageNotification: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    #[doc = "offset: 0x4 (4)"]
    pub WaitWake: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    #[doc = "offset: 0x4 (4)"]
    pub PowerSequence: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    #[doc = "offset: 0x4 (4)"]
    pub Power: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    #[doc = "offset: 0x4 (4)"]
    pub StartDevice: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    #[doc = "offset: 0x4 (4)"]
    pub WMI: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
    #[doc = "offset: 0x4 (4)"]
    pub Others: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityContext: *mut _IO_SECURITY_CONTEXT,
    #[doc = "offset: 0x4 (4)"]
    pub Options: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub FileAttributes: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub ShareAccess: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub EaLength: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityContext: *mut _IO_SECURITY_CONTEXT,
    #[doc = "offset: 0x4 (4)"]
    pub Options: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub ShareAccess: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub Parameters: *mut _NAMED_PIPE_CREATE_PARAMETERS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityContext: *mut _IO_SECURITY_CONTEXT,
    #[doc = "offset: 0x4 (4)"]
    pub Options: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub ShareAccess: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub Parameters: *mut _MAILSLOT_CREATE_PARAMETERS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Key: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ByteOffset: _LARGE_INTEGER,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Key: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ByteOffset: _LARGE_INTEGER,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FileName: *mut _UNICODE_STRING,
    #[doc = "offset: 0x8 (8)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
    #[doc = "offset: 0xc (12)"]
    pub FileIndex: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CompletionFilter: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CompletionFilter: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DirectoryNotifyInformationClass: _DIRECTORY_NOTIFY_INFORMATION_CLASS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
    #[doc = "offset: 0x8 (8)"]
    pub FileObject: *mut _FILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub __bindgen_anon_1:
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub ClusterCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DeleteHandle: *mut VOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub ReplaceIfExists: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub AdvanceOnly: UCHAR,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub EaList: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub EaListLength: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub EaIndex: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FsInformationClass: _FSINFOCLASS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FsInformationClass: _FSINFOCLASS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    #[doc = "offset: 0x0 (0)"]
    pub OutputBufferLength: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub InputBufferLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub FsControlCode: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Type3InputBuffer: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: *mut _LARGE_INTEGER,
    #[doc = "offset: 0x4 (4)"]
    pub Key: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ByteOffset: _LARGE_INTEGER,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    #[doc = "offset: 0x0 (0)"]
    pub OutputBufferLength: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub InputBufferLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub IoControlCode: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Type3InputBuffer: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityInformation: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    #[doc = "offset: 0x0 (0)"]
    pub SecurityInformation: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SecurityDescriptor: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    #[doc = "offset: 0x0 (0)"]
    pub Vpb: *mut _VPB,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    #[doc = "offset: 0x0 (0)"]
    pub Vpb: *mut _VPB,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    #[doc = "offset: 0x0 (0)"]
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub StartSid: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub SidList: *mut _FILE_GET_QUOTA_INFORMATION,
    #[doc = "offset: 0xc (12)"]
    pub SidListLength: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _DEVICE_RELATION_TYPE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    #[doc = "offset: 0x0 (0)"]
    pub InterfaceType: *mut _GUID,
    #[doc = "offset: 0x4 (4)"]
    pub Size: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Version: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Interface: *mut _INTERFACE,
    #[doc = "offset: 0xc (12)"]
    pub InterfaceSpecificData: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    #[doc = "offset: 0x0 (0)"]
    pub Capabilities: *mut _DEVICE_CAPABILITIES,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    #[doc = "offset: 0x0 (0)"]
    pub IoResourceRequirementList: *mut _IO_RESOURCE_REQUIREMENTS_LIST,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    #[doc = "offset: 0x0 (0)"]
    pub WhichSpace: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Buffer: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Offset: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Length: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    #[doc = "offset: 0x0 (0)"]
    pub IdType: BUS_QUERY_ID_TYPE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub LocaleId: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    #[doc = "offset: 0x0 (0)"]
    pub InPath: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Reserved: [UCHAR; 3usize],
    #[doc = "offset: 0x4 (4)"]
    pub Type: _DEVICE_USAGE_NOTIFICATION_TYPE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    #[doc = "offset: 0x0 (0)"]
    pub PowerState: _SYSTEM_POWER_STATE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    #[doc = "offset: 0x0 (0)"]
    pub PowerSequence: *mut _POWER_SEQUENCE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Type: _POWER_STATE_TYPE,
    #[doc = "offset: 0x8 (8)"]
    pub State: _POWER_STATE,
    #[doc = "offset: 0xc (12)"]
    pub ShutdownType: POWER_ACTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub SystemContext: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub SystemPowerStateContext: _SYSTEM_POWER_STATE_CONTEXT,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    #[doc = "offset: 0x0 (0)"]
    pub AllocatedResources: *mut _CM_RESOURCE_LIST,
    #[doc = "offset: 0x4 (4)"]
    pub AllocatedResourcesTranslated: *mut _CM_RESOURCE_LIST,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    #[doc = "offset: 0x0 (0)"]
    pub ProviderId: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DataPath: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub BufferSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Buffer: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    #[doc = "offset: 0x0 (0)"]
    pub Argument1: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Argument2: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Argument3: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Argument4: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK {
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1,
    pub DeviceRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _DEVICE_OBJECT,
            arg2: *mut _IRP,
            arg3: *mut VOID,
            arg4: *mut VOID,
        ) -> _IO_ALLOCATION_ACTION,
    >,
    #[doc = "offset: 0x14 (20)"]
    pub DeviceContext: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub NumberOfMapRegisters: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub DeviceObject: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub CurrentIrp: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub BufferChainingDpc: *mut _KDPC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub WaitQueueEntry: _KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub DmaWaitEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub NumberOfChannels: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncCallback(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SyncCallback(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DmaContext(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DmaContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ZeroMapRegisters(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ZeroMapRegisters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncCallback: ULONG,
        DmaContext: ULONG,
        ZeroMapRegisters: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncCallback: u32 = unsafe { ::std::mem::transmute(SyncCallback) };
            SyncCallback as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DmaContext: u32 = unsafe { ::std::mem::transmute(DmaContext) };
            DmaContext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ZeroMapRegisters: u32 = unsafe { ::std::mem::transmute(ZeroMapRegisters) };
            ZeroMapRegisters as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WAIT_CONTEXT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PENDING_RELATIONS_LIST_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x18 (24)"]
    pub DeviceEvent: *mut _PNP_DEVICE_EVENT_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x20 (32)"]
    pub RelationsList: *mut _RELATION_LIST,
    #[doc = "offset: 0x24 (36)"]
    pub EjectIrp: *mut _IRP,
    #[doc = "offset: 0x28 (40)"]
    pub Lock: IRPLOCK,
    #[doc = "offset: 0x2c (44)"]
    pub Problem: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub ProfileChangingEject: UCHAR,
    #[doc = "offset: 0x31 (49)"]
    pub DisplaySafeRemovalDialog: UCHAR,
    #[doc = "offset: 0x34 (52)"]
    pub LightestSleepState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x38 (56)"]
    pub DockInterface: *mut DOCK_INTERFACE,
    #[doc = "offset: 0x3c (60)"]
    pub DequeuePending: UCHAR,
    #[doc = "offset: 0x40 (64)"]
    pub DeleteType: _PNP_DEVICE_DELETE_TYPE,
}
impl Default for _PENDING_RELATIONS_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_IRP_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub CurrentIrp: *mut _IRP,
    #[doc = "offset: 0x4 (4)"]
    pub PendingIrpList: *mut _IRP,
}
impl Default for _PO_IRP_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_IRP_MANAGER {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceIrpQueue: _PO_IRP_QUEUE,
    #[doc = "offset: 0x8 (8)"]
    pub SystemIrpQueue: _PO_IRP_QUEUE,
}
impl Default for _PO_IRP_MANAGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LIST_ENTRY32 {
    #[doc = "offset: 0x0 (0)"]
    pub Flink: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Blink: ULONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STACK32 {
    #[doc = "offset: 0x0 (0)"]
    pub ActiveFrame: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FrameListCache: LIST_ENTRY32,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub NextCookieSequenceNumber: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub StackId: ULONG,
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_TRIAGE_DUMP_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub BadPageCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub BadPagesDetected: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub ZeroedPageSingleBitErrorsDetected: LONG,
    #[doc = "offset: 0xc (12)"]
    pub ScrubPasses: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub ScrubBadPagesFound: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub PageHashErrors: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FeatureBits: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub TimeZoneId: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Flags: _MI_FLAGS,
    #[doc = "offset: 0x28 (40)"]
    pub VsmConnection: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub ExceptionChainTerminator: *mut _EXCEPTION_REGISTRATION_RECORD,
    #[doc = "offset: 0x30 (48)"]
    pub ExceptionChainTerminatorRecord: _EXCEPTION_REGISTRATION_RECORD,
}
impl Default for _MI_TRIAGE_DUMP_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTLP_RANGE_LIST_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub End: ULONGLONG,
    pub __bindgen_anon_1: _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub Attributes: UCHAR,
    #[doc = "offset: 0x19 (25)"]
    pub PublicFlags: UCHAR,
    #[doc = "offset: 0x1a (26)"]
    pub PrivateFlags: USHORT,
    #[doc = "offset: 0x1c (28)"]
    pub ListEntry: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub Allocated: _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub Merged: _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub UserData: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Owner: *mut VOID,
}
impl Default for _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
}
impl Default for _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTLP_RANGE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xf0 (240) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_WMITRACE_WORK {
    #[doc = "offset: 0x0 (0)"]
    pub LoggerId: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SiloSessionId: ULONG,
    pub __bindgen_anon_1: _ETW_WMITRACE_WORK__bindgen_ty_1,
    #[doc = "offset: 0xe8 (232)"]
    pub Status: LONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_WMITRACE_WORK__bindgen_ty_1 {
    pub __bindgen_anon_1: _ETW_WMITRACE_WORK__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _ETW_WMITRACE_WORK__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_WMITRACE_WORK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub LoggerName: [CHAR; 65usize],
    #[doc = "offset: 0x49 (73)"]
    pub FileName: [CHAR; 129usize],
    #[doc = "offset: 0xcc (204)"]
    pub MaximumFileSize: ULONG,
    #[doc = "offset: 0xd0 (208)"]
    pub MinBuffers: ULONG,
    #[doc = "offset: 0xd4 (212)"]
    pub MaxBuffers: ULONG,
    #[doc = "offset: 0xd8 (216)"]
    pub BufferSize: ULONG,
    #[doc = "offset: 0xdc (220)"]
    pub Mode: ULONG,
    #[doc = "offset: 0xe0 (224)"]
    pub FlushTimer: ULONG,
}
impl Default for _ETW_WMITRACE_WORK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_WMITRACE_WORK__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x8 (8)"]
    pub MatchAny: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub MatchAll: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub EnableProperty: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Guid: _GUID,
    #[doc = "offset: 0x2c (44)"]
    pub Level: UCHAR,
}
impl Default for _ETW_WMITRACE_WORK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_WMITRACE_WORK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER2_COLLECTION {
    #[doc = "offset: 0x0 (0)"]
    pub Tree: _RTL_RB_TREE,
    #[doc = "offset: 0x8 (8)"]
    pub NextDueTime: ULONGLONG,
}
impl Default for _KTIMER2_COLLECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRITICAL_PROCESS_EXCEPTION_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub ReportId: _GUID,
    #[doc = "offset: 0x10 (16)"]
    pub ModuleName: _UNICODE_STRING,
    #[doc = "offset: 0x18 (24)"]
    pub ModuleTimestamp: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ModuleSize: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Offset: ULONGLONG,
}
impl Default for _CRITICAL_PROCESS_EXCEPTION_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1f8 (504) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_HIBER_PERF {
    #[doc = "offset: 0x0 (0)"]
    pub HiberIoTicks: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub HiberIoCpuTicks: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub HiberInitTicks: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub HiberHiberFileTicks: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub HiberCompressTicks: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub HiberSharedBufferTicks: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub HiberChecksumTicks: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub HiberChecksumIoTicks: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub TotalHibernateTime: _LARGE_INTEGER,
    #[doc = "offset: 0x48 (72)"]
    pub HibernateCompleteTimestamp: _LARGE_INTEGER,
    #[doc = "offset: 0x50 (80)"]
    pub POSTTime: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub ResumeBootMgrTime: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub BootmgrUserInputTime: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub ResumeAppTicks: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub ResumeAppStartTimestamp: ULONGLONG,
    #[doc = "offset: 0x70 (112)"]
    pub ResumeLibraryInitTicks: ULONGLONG,
    #[doc = "offset: 0x78 (120)"]
    pub ResumeInitTicks: ULONGLONG,
    #[doc = "offset: 0x80 (128)"]
    pub ResumeRestoreImageStartTimestamp: ULONGLONG,
    #[doc = "offset: 0x88 (136)"]
    pub ResumeHiberFileTicks: ULONGLONG,
    #[doc = "offset: 0x90 (144)"]
    pub ResumeIoTicks: ULONGLONG,
    #[doc = "offset: 0x98 (152)"]
    pub ResumeDecompressTicks: ULONGLONG,
    #[doc = "offset: 0xa0 (160)"]
    pub ResumeAllocateTicks: ULONGLONG,
    #[doc = "offset: 0xa8 (168)"]
    pub ResumeUserInOutTicks: ULONGLONG,
    #[doc = "offset: 0xb0 (176)"]
    pub ResumeMapTicks: ULONGLONG,
    #[doc = "offset: 0xb8 (184)"]
    pub ResumeUnmapTicks: ULONGLONG,
    #[doc = "offset: 0xc0 (192)"]
    pub ResumeChecksumTicks: ULONGLONG,
    #[doc = "offset: 0xc8 (200)"]
    pub ResumeChecksumIoTicks: ULONGLONG,
    #[doc = "offset: 0xd0 (208)"]
    pub ResumeKernelSwitchTimestamp: ULONGLONG,
    #[doc = "offset: 0xd8 (216)"]
    pub CyclesPerMs: ULONGLONG,
    #[doc = "offset: 0xe0 (224)"]
    pub WriteLogDataTimestamp: ULONGLONG,
    #[doc = "offset: 0xe8 (232)"]
    pub KernelReturnFromHandler: ULONGLONG,
    #[doc = "offset: 0xf0 (240)"]
    pub TimeStampCounterAtSwitchTime: ULONGLONG,
    #[doc = "offset: 0xf8 (248)"]
    pub HalTscOffset: ULONGLONG,
    #[doc = "offset: 0x100 (256)"]
    pub HvlTscOffset: ULONGLONG,
    #[doc = "offset: 0x108 (264)"]
    pub SleeperThreadEnd: ULONGLONG,
    #[doc = "offset: 0x110 (272)"]
    pub PostCmosUpdateTimestamp: ULONGLONG,
    #[doc = "offset: 0x118 (280)"]
    pub KernelReturnSystemPowerStateTimestamp: ULONGLONG,
    #[doc = "offset: 0x120 (288)"]
    pub IoBoundedness: ULONGLONG,
    #[doc = "offset: 0x128 (296)"]
    pub KernelDecompressTicks: ULONGLONG,
    #[doc = "offset: 0x130 (304)"]
    pub KernelIoTicks: ULONGLONG,
    #[doc = "offset: 0x138 (312)"]
    pub KernelCopyTicks: ULONGLONG,
    #[doc = "offset: 0x140 (320)"]
    pub ReadCheckCount: ULONGLONG,
    #[doc = "offset: 0x148 (328)"]
    pub KernelInitTicks: ULONGLONG,
    #[doc = "offset: 0x150 (336)"]
    pub KernelResumeHiberFileTicks: ULONGLONG,
    #[doc = "offset: 0x158 (344)"]
    pub KernelIoCpuTicks: ULONGLONG,
    #[doc = "offset: 0x160 (352)"]
    pub KernelSharedBufferTicks: ULONGLONG,
    #[doc = "offset: 0x168 (360)"]
    pub KernelAnimationTicks: ULONGLONG,
    #[doc = "offset: 0x170 (368)"]
    pub KernelChecksumTicks: ULONGLONG,
    #[doc = "offset: 0x178 (376)"]
    pub KernelChecksumIoTicks: ULONGLONG,
    #[doc = "offset: 0x180 (384)"]
    pub AnimationStart: _LARGE_INTEGER,
    #[doc = "offset: 0x188 (392)"]
    pub AnimationStop: _LARGE_INTEGER,
    #[doc = "offset: 0x190 (400)"]
    pub DeviceResumeTime: ULONG,
    #[doc = "offset: 0x198 (408)"]
    pub SecurePagesProcessed: ULONGLONG,
    #[doc = "offset: 0x1a0 (416)"]
    pub BootPagesProcessed: ULONGLONG,
    #[doc = "offset: 0x1a8 (424)"]
    pub KernelPagesProcessed: ULONGLONG,
    #[doc = "offset: 0x1b0 (432)"]
    pub BootBytesWritten: ULONGLONG,
    #[doc = "offset: 0x1b8 (440)"]
    pub KernelBytesWritten: ULONGLONG,
    #[doc = "offset: 0x1c0 (448)"]
    pub BootPagesWritten: ULONGLONG,
    #[doc = "offset: 0x1c8 (456)"]
    pub KernelPagesWritten: ULONGLONG,
    #[doc = "offset: 0x1d0 (464)"]
    pub BytesWritten: ULONGLONG,
    #[doc = "offset: 0x1d8 (472)"]
    pub PagesWritten: ULONG,
    #[doc = "offset: 0x1dc (476)"]
    pub FileRuns: ULONG,
    #[doc = "offset: 0x1e0 (480)"]
    pub NoMultiStageResumeReason: ULONG,
    #[doc = "offset: 0x1e4 (484)"]
    pub MaxHuffRatio: ULONG,
    #[doc = "offset: 0x1e8 (488)"]
    pub AdjustedTotalResumeTime: ULONGLONG,
    #[doc = "offset: 0x1f0 (496)"]
    pub ResumeCompleteTimestamp: ULONGLONG,
}
impl Default for _PO_HIBER_PERF {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x338 (824) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PO_MEMORY_IMAGE {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ImageType: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CheckSum: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub LengthSelf: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub PageSelf: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PageSize: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub SystemTime: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub InterruptTime: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub FeatureFlags: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub HiberFlags: UCHAR,
    #[doc = "offset: 0x31 (49)"]
    pub spare: [UCHAR; 3usize],
    #[doc = "offset: 0x34 (52)"]
    pub NoHiberPtes: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub HiberVa: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub NoFreePages: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub FreeMapCheck: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub WakeCheck: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub NumPagesForLoader: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub FirstBootRestorePage: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub FirstKernelRestorePage: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub FirstChecksumRestorePage: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub NoChecksumEntries: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub PerfInfo: _PO_HIBER_PERF,
    #[doc = "offset: 0x260 (608)"]
    pub FirmwareRuntimeInformationPages: ULONG,
    #[doc = "offset: 0x264 (612)"]
    pub FirmwareRuntimeInformation: [ULONG; 1usize],
    #[doc = "offset: 0x268 (616)"]
    pub SiLogOffset: ULONG,
    #[doc = "offset: 0x26c (620)"]
    pub NoBootLoaderLogPages: ULONG,
    #[doc = "offset: 0x270 (624)"]
    pub BootLoaderLogPages: [ULONG; 24usize],
    #[doc = "offset: 0x2d0 (720)"]
    pub NotUsed: ULONG,
    #[doc = "offset: 0x2d4 (724)"]
    pub ResumeContextCheck: ULONG,
    #[doc = "offset: 0x2d8 (728)"]
    pub ResumeContextPages: ULONG,
    #[doc = "offset: 0x2dc (732)"]
    pub Hiberboot: UCHAR,
    #[doc = "offset: 0x2e0 (736)"]
    pub HvCr3: ULONGLONG,
    #[doc = "offset: 0x2e8 (744)"]
    pub HvEntryPoint: ULONGLONG,
    #[doc = "offset: 0x2f0 (752)"]
    pub HvReservedTransitionAddress: ULONGLONG,
    #[doc = "offset: 0x2f8 (760)"]
    pub HvReservedTransitionAddressSize: ULONGLONG,
    #[doc = "offset: 0x300 (768)"]
    pub BootFlags: ULONGLONG,
    #[doc = "offset: 0x308 (776)"]
    pub RestoreProcessorStateRoutine: ULONGLONG,
    #[doc = "offset: 0x310 (784)"]
    pub HighestPhysicalPage: ULONG,
    #[doc = "offset: 0x314 (788)"]
    pub BitlockerKeyPfns: [ULONG; 4usize],
    #[doc = "offset: 0x324 (804)"]
    pub HardwareSignature: ULONG,
    #[doc = "offset: 0x328 (808)"]
    pub SMBiosTablePhysicalAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x330 (816)"]
    pub SMBiosTableLength: ULONG,
    #[doc = "offset: 0x334 (820)"]
    pub SMBiosMajorVersion: UCHAR,
    #[doc = "offset: 0x335 (821)"]
    pub SMBiosMinorVersion: UCHAR,
}
impl Default for PO_MEMORY_IMAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_IO_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub DumpMdl: *mut _MDL,
    #[doc = "offset: 0x4 (4)"]
    pub IoStatus: _POP_IO_STATUS,
    #[doc = "offset: 0x8 (8)"]
    pub IoStartCount: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub IoBytesCompleted: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub IoBytesInProgress: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub RequestSize: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub IoLocation: _LARGE_INTEGER,
    #[doc = "offset: 0x30 (48)"]
    pub FileOffset: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub Buffer: *mut VOID,
    #[doc = "offset: 0x3c (60)"]
    pub AsyncCapable: UCHAR,
    #[doc = "offset: 0x40 (64)"]
    pub BytesToRead: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub Pages: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub HighestChecksumIndex: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub PreviousChecksum: USHORT,
}
impl Default for _POP_IO_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_TRUSTLET_TKSESSION_ID {
    #[doc = "offset: 0x0 (0)"]
    pub SessionId: [ULONGLONG; 4usize],
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_INTERLOCKED_TIMER_DELAY_VALUES {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub All: ULONGLONG,
}
impl Default for _PS_INTERLOCKED_TIMER_DELAY_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PS_INTERLOCKED_TIMER_DELAY_VALUES {
    #[inline]
    pub fn DelayMs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set_DelayMs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn CoalescingWindowMs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set_CoalescingWindowMs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NewTimerWheel(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NewTimerWheel(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Retry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Retry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Locked(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Locked(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DelayMs: ULONGLONG,
        CoalescingWindowMs: ULONGLONG,
        Reserved: ULONGLONG,
        NewTimerWheel: ULONGLONG,
        Retry: ULONGLONG,
        Locked: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let DelayMs: u64 = unsafe { ::std::mem::transmute(DelayMs) };
            DelayMs as u64
        });
        __bindgen_bitfield_unit.set(30usize, 30u8, {
            let CoalescingWindowMs: u64 = unsafe { ::std::mem::transmute(CoalescingWindowMs) };
            CoalescingWindowMs as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let NewTimerWheel: u64 = unsafe { ::std::mem::transmute(NewTimerWheel) };
            NewTimerWheel as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let Retry: u64 = unsafe { ::std::mem::transmute(Retry) };
            Retry as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let Locked: u64 = unsafe { ::std::mem::transmute(Locked) };
            Locked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETWP_NOTIFICATION_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationType: _ETW_NOTIFICATION_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub NotificationSize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub RefCount: LONG,
    #[doc = "offset: 0xc (12)"]
    pub ReplyRequested: UCHAR,
    pub __bindgen_anon_1: _ETWP_NOTIFICATION_HEADER__bindgen_ty_1,
    pub __bindgen_anon_2: _ETWP_NOTIFICATION_HEADER__bindgen_ty_2,
    pub __bindgen_anon_3: _ETWP_NOTIFICATION_HEADER__bindgen_ty_3,
    #[doc = "offset: 0x20 (32)"]
    pub TargetPID: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub SourcePID: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub DestinationGuid: _GUID,
    #[doc = "offset: 0x38 (56)"]
    pub SourceGuid: _GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETWP_NOTIFICATION_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub ReplyIndex: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Timeout: ULONG,
}
impl Default for _ETWP_NOTIFICATION_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETWP_NOTIFICATION_HEADER__bindgen_ty_2 {
    #[doc = "offset: 0x14 (20)"]
    pub ReplyCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub NotifyeeCount: ULONG,
}
impl Default for _ETWP_NOTIFICATION_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETWP_NOTIFICATION_HEADER__bindgen_ty_3 {
    #[doc = "offset: 0x18 (24)"]
    pub ReplyHandle: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub ReplyObject: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub RegIndex: ULONG,
}
impl Default for _ETWP_NOTIFICATION_HEADER__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETWP_NOTIFICATION_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 14usize]>,
}
impl _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES {
    #[inline]
    pub fn NumberOfPtes(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_NumberOfPtes(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn PartitionId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_PartitionId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SectionOffset(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_SectionOffset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NumberOfPtes: ULONGLONG,
        PartitionId: ULONGLONG,
        Spare: ULONGLONG,
        SectionOffset: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 14usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 14usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let NumberOfPtes: u64 = unsafe { ::std::mem::transmute(NumberOfPtes) };
            NumberOfPtes as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let PartitionId: u64 = unsafe { ::std::mem::transmute(PartitionId) };
            PartitionId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let Spare: u64 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(64usize, 48u8, {
            let SectionOffset: u64 = unsafe { ::std::mem::transmute(SectionOffset) };
            SectionOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_STATUS {
    #[doc = "offset: 0x0 (0)"]
    pub ErrorStatus: ULONGLONG,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for _WHEA_ERROR_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_STATUS {
    #[inline]
    pub fn Reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Address(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Address(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Control(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Control(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Data(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Data(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Responder(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Responder(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Requester(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Requester(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FirstError(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FirstError(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 41u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 41u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONGLONG,
        ErrorType: ULONGLONG,
        Address: ULONGLONG,
        Control: ULONGLONG,
        Data: ULONGLONG,
        Responder: ULONGLONG,
        Requester: ULONGLONG,
        FirstError: ULONGLONG,
        Overflow: ULONGLONG,
        Reserved2: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ErrorType: u64 = unsafe { ::std::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Address: u64 = unsafe { ::std::mem::transmute(Address) };
            Address as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Control: u64 = unsafe { ::std::mem::transmute(Control) };
            Control as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Data: u64 = unsafe { ::std::mem::transmute(Data) };
            Data as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Responder: u64 = unsafe { ::std::mem::transmute(Responder) };
            Responder as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Requester: u64 = unsafe { ::std::mem::transmute(Requester) };
            Requester as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let FirstError: u64 = unsafe { ::std::mem::transmute(FirstError) };
            FirstError as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Overflow: u64 = unsafe { ::std::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(23usize, 41u8, {
            let Reserved2: u64 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub ValidBits: ULONGLONG,
}
impl Default for _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddressMask(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddressMask(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Node(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Node(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Card(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Card(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Module(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Module(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bank(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bank(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Device(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Device(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Row(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Row(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Column(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Column(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BitPosition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BitPosition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 49u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 49u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        PhysicalAddress: ULONGLONG,
        PhysicalAddressMask: ULONGLONG,
        Node: ULONGLONG,
        Card: ULONGLONG,
        Module: ULONGLONG,
        Bank: ULONGLONG,
        Device: ULONGLONG,
        Row: ULONGLONG,
        Column: ULONGLONG,
        BitPosition: ULONGLONG,
        RequesterId: ULONGLONG,
        ResponderId: ULONGLONG,
        TargetId: ULONGLONG,
        ErrorType: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::std::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PhysicalAddressMask: u64 = unsafe { ::std::mem::transmute(PhysicalAddressMask) };
            PhysicalAddressMask as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Node: u64 = unsafe { ::std::mem::transmute(Node) };
            Node as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Card: u64 = unsafe { ::std::mem::transmute(Card) };
            Card as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Module: u64 = unsafe { ::std::mem::transmute(Module) };
            Module as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Bank: u64 = unsafe { ::std::mem::transmute(Bank) };
            Bank as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Device: u64 = unsafe { ::std::mem::transmute(Device) };
            Device as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Row: u64 = unsafe { ::std::mem::transmute(Row) };
            Row as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Column: u64 = unsafe { ::std::mem::transmute(Column) };
            Column as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BitPosition: u64 = unsafe { ::std::mem::transmute(BitPosition) };
            BitPosition as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let RequesterId: u64 = unsafe { ::std::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ResponderId: u64 = unsafe { ::std::mem::transmute(ResponderId) };
            ResponderId as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TargetId: u64 = unsafe { ::std::mem::transmute(TargetId) };
            TargetId as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ErrorType: u64 = unsafe { ::std::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(15usize, 49u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x49 (73) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_MEMORY_ERROR_SECTION {
    #[doc = "offset: 0x0 (0)"]
    pub ValidBits: _WHEA_MEMORY_ERROR_SECTION_VALIDBITS,
    #[doc = "offset: 0x8 (8)"]
    pub ErrorStatus: _WHEA_ERROR_STATUS,
    #[doc = "offset: 0x10 (16)"]
    pub PhysicalAddress: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub PhysicalAddressMask: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub Node: USHORT,
    #[doc = "offset: 0x22 (34)"]
    pub Card: USHORT,
    #[doc = "offset: 0x24 (36)"]
    pub Module: USHORT,
    #[doc = "offset: 0x26 (38)"]
    pub Bank: USHORT,
    #[doc = "offset: 0x28 (40)"]
    pub Device: USHORT,
    #[doc = "offset: 0x2a (42)"]
    pub Row: USHORT,
    #[doc = "offset: 0x2c (44)"]
    pub Column: USHORT,
    #[doc = "offset: 0x2e (46)"]
    pub BitPosition: USHORT,
    #[doc = "offset: 0x30 (48)"]
    pub RequesterId: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub ResponderId: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub TargetId: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub ErrorType: UCHAR,
}
impl Default for _WHEA_MEMORY_ERROR_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TraceLoggingMetadata_t {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Size: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Version: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub Flags: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub Magic: ULONGLONG,
}
#[doc = "0x160 (352) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_THERMAL_TELEMETRY_TRACKER {
    #[doc = "offset: 0x0 (0)"]
    pub AccountingDisabled: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub LastPassiveUpdateTime: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub TotalPassiveTime: [ULONGLONG; 21usize],
    #[doc = "offset: 0xb8 (184)"]
    pub PassiveTimeSnap: [ULONGLONG; 21usize],
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_CONFLICT_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub OwningObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub Start: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub End: ULONGLONG,
}
impl Default for _ARBITER_CONFLICT_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_QUERY_CONFLICT_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x4 (4)"]
    pub ConflictingResource: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = "offset: 0x8 (8)"]
    pub ConflictCount: *mut ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Conflicts: *mut *mut _ARBITER_CONFLICT_INFO,
}
impl Default for _ARBITER_QUERY_CONFLICT_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARBITER_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub Parameters: _ARBITER_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARBITER_PARAMETERS__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub TestAllocation: _ARBITER_TEST_ALLOCATION_PARAMETERS,
    #[doc = "offset: 0x0 (0)"]
    pub RetestAllocation: _ARBITER_RETEST_ALLOCATION_PARAMETERS,
    #[doc = "offset: 0x0 (0)"]
    pub BootAllocation: _ARBITER_BOOT_ALLOCATION_PARAMETERS,
    #[doc = "offset: 0x0 (0)"]
    pub QueryAllocatedResources: _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS,
    #[doc = "offset: 0x0 (0)"]
    pub QueryConflict: _ARBITER_QUERY_CONFLICT_PARAMETERS,
    #[doc = "offset: 0x0 (0)"]
    pub QueryArbitrate: _ARBITER_QUERY_ARBITRATE_PARAMETERS,
    #[doc = "offset: 0x0 (0)"]
    pub AddReserved: _ARBITER_ADD_RESERVED_PARAMETERS,
}
impl Default for _ARBITER_PARAMETERS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ARBITER_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_INTERFACE {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub InterfaceReference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0xc (12)"]
    pub InterfaceDereference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    pub ArbiterHandler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: _ARBITER_ACTION,
            arg3: *mut _ARBITER_PARAMETERS,
        ) -> LONG,
    >,
    #[doc = "offset: 0x14 (20)"]
    pub Flags: ULONG,
}
impl Default for _ARBITER_INTERFACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PI_RESOURCE_ARBITER_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceArbiterList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ResourceType: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub ArbiterInterface: *mut _ARBITER_INTERFACE,
    #[doc = "offset: 0x10 (16)"]
    pub DeviceNode: *mut _DEVICE_NODE,
    #[doc = "offset: 0x14 (20)"]
    pub ResourceList: _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub BestResourceList: _LIST_ENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub BestConfig: _LIST_ENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub ActiveArbiterList: _LIST_ENTRY,
    #[doc = "offset: 0x34 (52)"]
    pub State: UCHAR,
    #[doc = "offset: 0x35 (53)"]
    pub ResourcesChanged: UCHAR,
}
impl Default for _PI_RESOURCE_ARBITER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_RANGE {
    #[doc = "offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub End: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub UserData: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub Owner: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub Attributes: UCHAR,
    #[doc = "offset: 0x19 (25)"]
    pub Flags: UCHAR,
}
impl Default for _RTL_RANGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_ALTERNATIVE {
    #[doc = "offset: 0x0 (0)"]
    pub Minimum: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Maximum: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Length: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub Alignment: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub Priority: LONG,
    #[doc = "offset: 0x24 (36)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Descriptor: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = "offset: 0x2c (44)"]
    pub Reserved: [ULONG; 3usize],
}
impl Default for _ARBITER_ALTERNATIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ARBITER_ORDERING {
    #[doc = "offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub End: ULONGLONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_ORDERING_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Count: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Maximum: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Orderings: *mut _ARBITER_ORDERING,
}
impl Default for _ARBITER_ORDERING_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_ALLOCATION_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub End: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub CurrentMinimum: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CurrentMaximum: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub Entry: *mut _ARBITER_LIST_ENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub CurrentAlternative: *mut _ARBITER_ALTERNATIVE,
    #[doc = "offset: 0x28 (40)"]
    pub AlternativeCount: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Alternatives: *mut _ARBITER_ALTERNATIVE,
    #[doc = "offset: 0x30 (48)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x32 (50)"]
    pub RangeAttributes: UCHAR,
    #[doc = "offset: 0x33 (51)"]
    pub RangeAvailableAttributes: UCHAR,
    #[doc = "offset: 0x34 (52)"]
    pub WorkSpace: ULONG,
}
impl Default for _ARBITER_ALLOCATION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NON_PAGED_DEBUG_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Machine: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub Characteristics: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub TimeDateStamp: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub CheckSum: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub SizeOfImage: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub ImageBase: ULONGLONG,
}
#[doc = "0x5c (92) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KLDR_DATA_TABLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub InLoadOrderLinks: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ExceptionTable: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub ExceptionTableSize: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub GpValue: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub NonPagedDebugInfo: *mut _NON_PAGED_DEBUG_INFO,
    #[doc = "offset: 0x18 (24)"]
    pub DllBase: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub EntryPoint: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub SizeOfImage: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub FullDllName: _UNICODE_STRING,
    #[doc = "offset: 0x2c (44)"]
    pub BaseDllName: _UNICODE_STRING,
    #[doc = "offset: 0x34 (52)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub LoadCount: USHORT,
    #[doc = "offset: 0x3a (58)"]
    pub u1: _KLDR_DATA_TABLE_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x3c (60)"]
    pub SectionPointer: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub CheckSum: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub CoverageSectionSize: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub CoverageSection: *mut VOID,
    #[doc = "offset: 0x4c (76)"]
    pub LoadedImports: *mut VOID,
    #[doc = "offset: 0x50 (80)"]
    pub Spare: *mut VOID,
    #[doc = "offset: 0x54 (84)"]
    pub SizeOfImageNotRounded: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub TimeDateStamp: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KLDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x3a (58)"]
    pub EntireField: USHORT,
}
impl Default for _KLDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KLDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn SignatureLevel(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_SignatureLevel(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SignatureType(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_SignatureType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SignatureLevel: USHORT,
        SignatureType: USHORT,
        Unused: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SignatureLevel: u16 = unsafe { ::std::mem::transmute(SignatureLevel) };
            SignatureLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let SignatureType: u16 = unsafe { ::std::mem::transmute(SignatureType) };
            SignatureType as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Unused: u16 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KLDR_DATA_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x6c (108) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SYSTEM_IMAGE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub FixupList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub LoadLock: _KMUTANT,
    #[doc = "offset: 0x28 (40)"]
    pub FixupLock: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub FirstLoadEver: UCHAR,
    #[doc = "offset: 0x2d (45)"]
    pub LargePageAll: UCHAR,
    #[doc = "offset: 0x30 (48)"]
    pub LastPage: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub LargePageList: _LIST_ENTRY,
    #[doc = "offset: 0x3c (60)"]
    pub StrongCodeLoadFailureList: _LIST_ENTRY,
    #[doc = "offset: 0x44 (68)"]
    pub BeingDeleted: *mut _KLDR_DATA_TABLE_ENTRY,
    #[doc = "offset: 0x48 (72)"]
    pub MappingRangesPushLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4c (76)"]
    pub MappingRanges: [*mut _MI_DRIVER_VA; 2usize],
    #[doc = "offset: 0x54 (84)"]
    pub PageCount: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub PageCounts: _MM_SYSTEM_PAGE_COUNTS,
    #[doc = "offset: 0x68 (104)"]
    pub CollidedLock: _EX_PUSH_LOCK,
}
impl Default for _MI_SYSTEM_IMAGE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_ZERO_COST_COUNTS {
    #[doc = "offset: 0x0 (0)"]
    pub NativeSum: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub CachedSum: ULONGLONG,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SECTION {
    #[doc = "offset: 0x0 (0)"]
    pub SectionNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0xc (12)"]
    pub StartingVpn: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub EndingVpn: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub u1: _SECTION__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub SizeOfSection: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub u: _SECTION__bindgen_ty_2,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = "offset: 0x14 (20)"]
    pub FileObject: *mut _FILE_OBJECT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _SECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _SECTION__bindgen_ty_1 {
    #[inline]
    pub fn RemoteImageFileObject(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RemoteImageFileObject(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RemoteDataFileObject(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RemoteDataFileObject(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RemoteImageFileObject: ULONG,
        RemoteDataFileObject: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RemoteImageFileObject: u32 =
                unsafe { ::std::mem::transmute(RemoteImageFileObject) };
            RemoteImageFileObject as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RemoteDataFileObject: u32 = unsafe { ::std::mem::transmute(RemoteDataFileObject) };
            RemoteDataFileObject as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION__bindgen_ty_2 {
    #[doc = "offset: 0x20 (32)"]
    pub LongFlags: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Flags: _MMSECTION_FLAGS,
}
impl Default for _SECTION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _SECTION {
    #[inline]
    pub fn InitialPageProtection(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_InitialPageProtection(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn SessionId(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_SessionId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn NoValidationNeeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoValidationNeeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InitialPageProtection: ULONG,
        SessionId: ULONG,
        NoValidationNeeded: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let InitialPageProtection: u32 =
                unsafe { ::std::mem::transmute(InitialPageProtection) };
            InitialPageProtection as u64
        });
        __bindgen_bitfield_unit.set(12usize, 19u8, {
            let SessionId: u32 = unsafe { ::std::mem::transmute(SessionId) };
            SessionId as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let NoValidationNeeded: u32 = unsafe { ::std::mem::transmute(NoValidationNeeded) };
            NoValidationNeeded as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_COMBINE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub ActiveSpinLock: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub CombiningThreadCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ActiveThreadTree: _RTL_AVL_TREE,
    #[doc = "offset: 0x10 (16)"]
    pub ZeroPageHashValue: ULONGLONG,
}
impl Default for _MI_COMBINE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POOL_TRACKER_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Key: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub NonPagedBytes: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub NonPagedAllocs: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub NonPagedFrees: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub PagedBytes: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub PagedAllocs: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub PagedFrees: ULONGLONG,
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub BankNumber: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub ClearOnInitialization: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub StatusDataFormat: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Flags: _XPF_MC_BANK_FLAGS,
    #[doc = "offset: 0x4 (4)"]
    pub ControlMsr: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub StatusMsr: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AddressMsr: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MiscMsr: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ControlData: ULONGLONG,
}
impl Default for _WHEA_XPF_MC_BANK_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3a4 (932) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_CMC_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub NumberOfBanks: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Notify: _WHEA_NOTIFICATION_DESCRIPTOR,
    #[doc = "offset: 0x24 (36)"]
    pub Banks: [_WHEA_XPF_MC_BANK_DESCRIPTOR; 32usize],
}
impl Default for _WHEA_XPF_CMC_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub ErrStatusBlockLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub RelatedErrorSourceId: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ErrStatusAddressSpaceID: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub ErrStatusAddressBitWidth: UCHAR,
    #[doc = "offset: 0xe (14)"]
    pub ErrStatusAddressBitOffset: UCHAR,
    #[doc = "offset: 0xf (15)"]
    pub ErrStatusAddressAccessSize: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub ErrStatusAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub Notify: _WHEA_NOTIFICATION_DESCRIPTOR,
    #[doc = "offset: 0x34 (52)"]
    pub ReadAckAddressSpaceID: UCHAR,
    #[doc = "offset: 0x35 (53)"]
    pub ReadAckAddressBitWidth: UCHAR,
    #[doc = "offset: 0x36 (54)"]
    pub ReadAckAddressBitOffset: UCHAR,
    #[doc = "offset: 0x37 (55)"]
    pub ReadAckAddressAccessSize: UCHAR,
    #[doc = "offset: 0x38 (56)"]
    pub ReadAckAddress: _LARGE_INTEGER,
    #[doc = "offset: 0x40 (64)"]
    pub ReadAckPreserveMask: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub ReadAckWriteMask: ULONGLONG,
}
impl Default for _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x398 (920) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_MCE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Enabled: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub NumberOfBanks: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: _XPF_MCE_FLAGS,
    #[doc = "offset: 0x8 (8)"]
    pub MCG_Capability: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub MCG_GlobalControl: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub Banks: [_WHEA_XPF_MC_BANK_DESCRIPTOR; 32usize],
}
impl Default for _WHEA_XPF_MCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3cc (972) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Version: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Type: _WHEA_ERROR_SOURCE_TYPE,
    #[doc = "offset: 0xc (12)"]
    pub State: _WHEA_ERROR_SOURCE_STATE,
    #[doc = "offset: 0x10 (16)"]
    pub MaxRawDataLength: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub NumRecordsToPreallocate: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub MaxSectionsPerRecord: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ErrorSourceId: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub PlatformErrorSourceId: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Info: _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0x28 (40)"]
    pub XpfMceDescriptor: _WHEA_XPF_MCE_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub XpfCmcDescriptor: _WHEA_XPF_CMC_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub XpfNmiDescriptor: _WHEA_XPF_NMI_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub IpfMcaDescriptor: _WHEA_IPF_MCA_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub IpfCmcDescriptor: _WHEA_IPF_CMC_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub IpfCpeDescriptor: _WHEA_IPF_CPE_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub AerRootportDescriptor: _WHEA_AER_ROOTPORT_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub AerEndpointDescriptor: _WHEA_AER_ENDPOINT_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub AerBridgeDescriptor: _WHEA_AER_BRIDGE_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub GenErrDescriptor: _WHEA_GENERIC_ERROR_DESCRIPTOR,
    #[doc = "offset: 0x28 (40)"]
    pub GenErrDescriptorV2: _WHEA_GENERIC_ERROR_DESCRIPTOR_V2,
}
impl Default for _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WHEA_ERROR_SOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEP_LUID_TO_INDEX_MAP_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub HashEntry: _RTL_DYNAMIC_HASH_TABLE_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub Luid: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub IndexIntoGlobalSingletonTable: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub MarkedForDeletion: UCHAR,
}
impl Default for _SEP_LUID_TO_INDEX_MAP_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEP_TOKEN_PRIVILEGES {
    #[doc = "offset: 0x0 (0)"]
    pub Present: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Enabled: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub EnabledByDefault: ULONGLONG,
}
#[doc = "0x2a8 (680) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN {
    #[doc = "offset: 0x0 (0)"]
    pub TokenSource: _TOKEN_SOURCE,
    #[doc = "offset: 0x10 (16)"]
    pub TokenId: _LUID,
    #[doc = "offset: 0x18 (24)"]
    pub AuthenticationId: _LUID,
    #[doc = "offset: 0x20 (32)"]
    pub ParentTokenId: _LUID,
    #[doc = "offset: 0x28 (40)"]
    pub ExpirationTime: _LARGE_INTEGER,
    #[doc = "offset: 0x30 (48)"]
    pub TokenLock: *mut _ERESOURCE,
    #[doc = "offset: 0x34 (52)"]
    pub ModifiedId: _LUID,
    #[doc = "offset: 0x40 (64)"]
    pub Privileges: _SEP_TOKEN_PRIVILEGES,
    #[doc = "offset: 0x58 (88)"]
    pub AuditPolicy: _SEP_AUDIT_POLICY,
    #[doc = "offset: 0x78 (120)"]
    pub SessionId: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub UserAndGroupCount: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub RestrictedSidCount: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub VariableLength: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub DynamicCharged: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub DynamicAvailable: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub DefaultOwnerIndex: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub UserAndGroups: *mut _SID_AND_ATTRIBUTES,
    #[doc = "offset: 0x98 (152)"]
    pub RestrictedSids: *mut _SID_AND_ATTRIBUTES,
    #[doc = "offset: 0x9c (156)"]
    pub PrimaryGroup: *mut VOID,
    #[doc = "offset: 0xa0 (160)"]
    pub DynamicPart: *mut ULONG,
    #[doc = "offset: 0xa4 (164)"]
    pub DefaultDacl: *mut _ACL,
    #[doc = "offset: 0xa8 (168)"]
    pub TokenType: _TOKEN_TYPE,
    #[doc = "offset: 0xac (172)"]
    pub ImpersonationLevel: _SECURITY_IMPERSONATION_LEVEL,
    #[doc = "offset: 0xb0 (176)"]
    pub TokenFlags: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub TokenInUse: UCHAR,
    #[doc = "offset: 0xb8 (184)"]
    pub IntegrityLevelIndex: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub MandatoryPolicy: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub LogonSession: *mut _SEP_LOGON_SESSION_REFERENCES,
    #[doc = "offset: 0xc4 (196)"]
    pub OriginatingLogonSession: _LUID,
    #[doc = "offset: 0xcc (204)"]
    pub SidHash: _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x154 (340)"]
    pub RestrictedSidHash: _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x1dc (476)"]
    pub pSecurityAttributes: *mut _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION,
    #[doc = "offset: 0x1e0 (480)"]
    pub Package: *mut VOID,
    #[doc = "offset: 0x1e4 (484)"]
    pub Capabilities: *mut _SID_AND_ATTRIBUTES,
    #[doc = "offset: 0x1e8 (488)"]
    pub CapabilityCount: ULONG,
    #[doc = "offset: 0x1ec (492)"]
    pub CapabilitiesHash: _SID_AND_ATTRIBUTES_HASH,
    #[doc = "offset: 0x274 (628)"]
    pub LowboxNumberEntry: *mut _SEP_LOWBOX_NUMBER_ENTRY,
    #[doc = "offset: 0x278 (632)"]
    pub LowboxHandlesEntry: *mut _SEP_CACHED_HANDLES_ENTRY,
    #[doc = "offset: 0x27c (636)"]
    pub pClaimAttributes: *mut _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION,
    #[doc = "offset: 0x280 (640)"]
    pub TrustLevelSid: *mut VOID,
    #[doc = "offset: 0x284 (644)"]
    pub TrustLinkedToken: *mut _TOKEN,
    #[doc = "offset: 0x288 (648)"]
    pub IntegrityLevelSidValue: *mut VOID,
    #[doc = "offset: 0x28c (652)"]
    pub TokenSidValues: *mut _SEP_SID_VALUES_BLOCK,
    #[doc = "offset: 0x290 (656)"]
    pub IndexEntry: *mut _SEP_LUID_TO_INDEX_MAP_ENTRY,
    #[doc = "offset: 0x294 (660)"]
    pub DiagnosticInfo: *mut _SEP_TOKEN_DIAG_TRACK_ENTRY,
    #[doc = "offset: 0x298 (664)"]
    pub BnoIsolationHandlesEntry: *mut _SEP_CACHED_HANDLES_ENTRY,
    #[doc = "offset: 0x29c (668)"]
    pub SessionObject: *mut VOID,
    #[doc = "offset: 0x2a0 (672)"]
    pub VariablePart: ULONG,
}
impl Default for _TOKEN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    #[doc = "offset: 0x0 (0)"]
    pub Buffer: *mut VOID,
    #[doc = "offset: 0x0 (0)"]
    pub Alignment: ULONGLONG,
}
impl Default for _FILE_SEGMENT_ELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_ADAPTER_CRYPTO_PARAMETERS {
    #[doc = "offset: 0x0 (0)"]
    pub Tweak: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub KeyDescriptor: *mut _IO_ADAPTER_CRYPTO_KEY_DESCRIPTOR,
}
impl Default for _IO_ADAPTER_CRYPTO_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOP_IRP_EXTENSION {
    pub __bindgen_anon_1: _IOP_IRP_EXTENSION__bindgen_ty_1,
    #[doc = "offset: 0x2 (2)"]
    pub TypesAllocated: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub GenericExtension: [UCHAR; 4usize],
    #[doc = "offset: 0x8 (8)"]
    pub VerifierContext: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub DiskIoAttributionHandle: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ActivityId: _GUID,
    pub __bindgen_anon_2: _IOP_IRP_EXTENSION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOP_IRP_EXTENSION__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ExtensionFlags: USHORT,
    pub __bindgen_anon_1: _IOP_IRP_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IOP_IRP_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IOP_IRP_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Allocated(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Allocated(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PropagateId(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PropagateId(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Allocated: USHORT,
        PropagateId: USHORT,
        SpareBits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Allocated: u16 = unsafe { ::std::mem::transmute(Allocated) };
            Allocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PropagateId: u16 = unsafe { ::std::mem::transmute(PropagateId) };
            PropagateId as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let SpareBits: u16 = unsafe { ::std::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _IOP_IRP_EXTENSION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOP_IRP_EXTENSION__bindgen_ty_2 {
    #[doc = "offset: 0x20 (32)"]
    pub Timestamp: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub ZeroingOffset: ULONG,
    pub __bindgen_anon_1: _IOP_IRP_EXTENSION__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub AdapterCryptoParameters: _IO_ADAPTER_CRYPTO_PARAMETERS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOP_IRP_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x20 (32)"]
    pub FsTrackOffsetBlob: *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER,
    #[doc = "offset: 0x24 (36)"]
    pub FsTrackedOffset: LONGLONG,
}
impl Default for _IOP_IRP_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IOP_IRP_EXTENSION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IOP_IRP_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub u1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub s1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub Value: LONGLONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Head(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Head(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn Tail(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Tail(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn ActiveThreadCount(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_ActiveThreadCount(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Head: ULONGLONG,
        Tail: ULONGLONG,
        ActiveThreadCount: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let Head: u64 = unsafe { ::std::mem::transmute(Head) };
            Head as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let Tail: u64 = unsafe { ::std::mem::transmute(Tail) };
            Tail as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let ActiveThreadCount: u64 = unsafe { ::std::mem::transmute(ActiveThreadCount) };
            ActiveThreadCount as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ALPC_COMPLETION_LIST_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x180 (384) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub StartMagic: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub TotalSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ListOffset: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ListSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub BitmapOffset: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub BitmapSize: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub DataOffset: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub DataSize: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub AttributeFlags: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub AttributeSize: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub State: _ALPC_COMPLETION_LIST_STATE,
    #[doc = "offset: 0x48 (72)"]
    pub LastMessageId: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub LastCallbackId: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub PostCount: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub ReturnCount: ULONG,
    #[doc = "offset: 0x100 (256)"]
    pub LogSequenceNumber: ULONG,
    #[doc = "offset: 0x140 (320)"]
    pub UserLock: _RTL_SRWLOCK,
    #[doc = "offset: 0x148 (328)"]
    pub EndMagic: ULONGLONG,
}
impl Default for _ALPC_COMPLETION_LIST_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY_EXTRA {
    pub __bindgen_anon_1: _HEAP_ENTRY_EXTRA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY_EXTRA__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_ENTRY_EXTRA__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub ZeroInit: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_ENTRY_EXTRA__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub AllocatorBackTraceIndex: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub TagIndex: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Settable: ULONG,
}
impl Default for _HEAP_ENTRY_EXTRA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY_EXTRA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY {
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub UnpackedEntry: _HEAP_UNPACKED_ENTRY,
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x0 (0)"]
    pub ExtendedEntry: _HEAP_EXTENDED_ENTRY,
    pub __bindgen_anon_3: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x0 (0)"]
    pub AgregateCode: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub SmallTagIndex: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub SubSegmentCode: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PreviousSize: USHORT,
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x7 (7)"]
    pub UnusedBytes: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x6 (6)"]
    pub SegmentOffset: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub LFHFlags: UCHAR,
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub FunctionIndex: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub ContextValue: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub InterceptorValue: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub UnusedBytesLength: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub EntryOffset: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub ExtendedBlockSignature: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub Code1: ULONG,
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Code234: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Code2: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Code3: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub Code4: UCHAR,
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY {
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub FreeList: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub HeapEntry: _HEAP_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub UnpackedEntry: _HEAP_UNPACKED_ENTRY,
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x0 (0)"]
    pub ExtendedEntry: _HEAP_EXTENDED_ENTRY,
    pub __bindgen_anon_3: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x0 (0)"]
    pub AgregateCode: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub SmallTagIndex: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub SubSegmentCode: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PreviousSize: USHORT,
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x7 (7)"]
    pub UnusedBytes: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x6 (6)"]
    pub SegmentOffset: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub LFHFlags: UCHAR,
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub FunctionIndex: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub ContextValue: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub InterceptorValue: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub UnusedBytesLength: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub EntryOffset: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub ExtendedBlockSignature: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub Code1: ULONG,
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Code234: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Code2: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Code3: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub Code4: UCHAR,
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ExtraStuff: _HEAP_ENTRY_EXTRA,
    #[doc = "offset: 0x10 (16)"]
    pub CommitSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ReserveSize: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub BusyBlock: _HEAP_ENTRY,
}
impl Default for _HEAP_VIRTUAL_ALLOC_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_SEGMENT {
    #[doc = "offset: 0x0 (0)"]
    pub Entry: _HEAP_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub SegmentSignature: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SegmentFlags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SegmentListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub Heap: *mut _HEAP,
    #[doc = "offset: 0x1c (28)"]
    pub BaseAddress: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub NumberOfPages: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub FirstEntry: *mut _HEAP_ENTRY,
    #[doc = "offset: 0x28 (40)"]
    pub LastValidEntry: *mut _HEAP_ENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub NumberOfUnCommittedPages: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub NumberOfUnCommittedRanges: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub SegmentAllocatorBackTraceIndex: USHORT,
    #[doc = "offset: 0x36 (54)"]
    pub Reserved: USHORT,
    #[doc = "offset: 0x38 (56)"]
    pub UCRSegmentList: _LIST_ENTRY,
}
impl Default for _HEAP_SEGMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x248 (584) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP {
    pub __bindgen_anon_1: _HEAP__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub ForceFlags: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub CompatibilityFlags: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub EncodeFlagMask: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub Encoding: _HEAP_ENTRY,
    #[doc = "offset: 0x58 (88)"]
    pub Interceptor: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub VirtualMemoryThreshold: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub SegmentReserve: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub SegmentCommit: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub DeCommitFreeBlockThreshold: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub DeCommitTotalFreeThreshold: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub TotalFreeSize: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub MaximumAllocationSize: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub ProcessHeapsListIndex: USHORT,
    #[doc = "offset: 0x7e (126)"]
    pub HeaderValidateLength: USHORT,
    #[doc = "offset: 0x80 (128)"]
    pub HeaderValidateCopy: *mut VOID,
    #[doc = "offset: 0x84 (132)"]
    pub NextAvailableTagIndex: USHORT,
    #[doc = "offset: 0x86 (134)"]
    pub MaximumTagIndex: USHORT,
    #[doc = "offset: 0x88 (136)"]
    pub TagEntries: *mut _HEAP_TAG_ENTRY,
    #[doc = "offset: 0x8c (140)"]
    pub UCRList: _LIST_ENTRY,
    #[doc = "offset: 0x94 (148)"]
    pub AlignRound: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub AlignMask: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub VirtualAllocdBlocks: _LIST_ENTRY,
    #[doc = "offset: 0xa4 (164)"]
    pub SegmentList: _LIST_ENTRY,
    #[doc = "offset: 0xac (172)"]
    pub AllocatorBackTraceIndex: USHORT,
    #[doc = "offset: 0xb0 (176)"]
    pub NonDedicatedListLength: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub BlocksIndex: *mut VOID,
    #[doc = "offset: 0xb8 (184)"]
    pub UCRIndex: *mut VOID,
    #[doc = "offset: 0xbc (188)"]
    pub PseudoTagEntries: *mut _HEAP_PSEUDO_TAG_ENTRY,
    #[doc = "offset: 0xc0 (192)"]
    pub FreeLists: _LIST_ENTRY,
    #[doc = "offset: 0xc8 (200)"]
    pub LockVariable: *mut _HEAP_LOCK,
    pub CommitRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut *mut VOID, arg3: *mut ULONG) -> LONG,
    >,
    #[doc = "offset: 0xd0 (208)"]
    pub StackTraceInitVar: _RTL_RUN_ONCE,
    #[doc = "offset: 0xd4 (212)"]
    pub FrontEndHeap: *mut VOID,
    #[doc = "offset: 0xd8 (216)"]
    pub FrontHeapLockCount: USHORT,
    #[doc = "offset: 0xda (218)"]
    pub FrontEndHeapType: UCHAR,
    #[doc = "offset: 0xdb (219)"]
    pub RequestedFrontEndHeapType: UCHAR,
    #[doc = "offset: 0xdc (220)"]
    pub FrontEndHeapUsageData: *mut USHORT,
    #[doc = "offset: 0xe0 (224)"]
    pub FrontEndHeapMaximumIndex: USHORT,
    #[doc = "offset: 0xe2 (226)"]
    pub FrontEndHeapStatusBitmap: [UCHAR; 257usize],
    #[doc = "offset: 0x1e4 (484)"]
    pub Counters: _HEAP_COUNTERS,
    #[doc = "offset: 0x240 (576)"]
    pub TuningParameters: _HEAP_TUNING_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Segment: _HEAP_SEGMENT,
    pub __bindgen_anon_1: _HEAP__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Entry: _HEAP_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub SegmentSignature: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SegmentFlags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SegmentListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub Heap: *mut _HEAP,
    #[doc = "offset: 0x1c (28)"]
    pub BaseAddress: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub NumberOfPages: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub FirstEntry: *mut _HEAP_ENTRY,
    #[doc = "offset: 0x28 (40)"]
    pub LastValidEntry: *mut _HEAP_ENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub NumberOfUnCommittedPages: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub NumberOfUnCommittedRanges: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub SegmentAllocatorBackTraceIndex: USHORT,
    #[doc = "offset: 0x36 (54)"]
    pub Reserved: USHORT,
    #[doc = "offset: 0x38 (56)"]
    pub UCRSegmentList: _LIST_ENTRY,
}
impl Default for _HEAP__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PRIVATE_CACHE_MAP {
    pub __bindgen_anon_1: _PRIVATE_CACHE_MAP__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub ReadAheadMask: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x10 (16)"]
    pub FileOffset1: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub BeyondLastByte1: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub FileOffset2: _LARGE_INTEGER,
    #[doc = "offset: 0x28 (40)"]
    pub BeyondLastByte2: _LARGE_INTEGER,
    #[doc = "offset: 0x30 (48)"]
    pub SequentialReadCount: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub ReadAheadLength: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub ReadAheadOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x40 (64)"]
    pub ReadAheadBeyondLastByte: _LARGE_INTEGER,
    #[doc = "offset: 0x48 (72)"]
    pub PrevReadAheadBeyondLastByte: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub ReadAheadSpinLock: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub PipelinedReadAheadRequestSize: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub ReadAheadGrowth: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub PrivateLinks: _LIST_ENTRY,
    #[doc = "offset: 0x64 (100)"]
    pub ReadAheadWorkItem: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PRIVATE_CACHE_MAP__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = "offset: 0x0 (0)"]
    pub Flags: _PRIVATE_CACHE_MAP_FLAGS,
}
impl Default for _PRIVATE_CACHE_MAP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PRIVATE_CACHE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIRTY_PAGE_THRESHOLDS {
    #[doc = "offset: 0x0 (0)"]
    pub DirtyPageThreshold: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub DirtyPageThresholdTop: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DirtyPageThresholdBottom: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DirtyPageTarget: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AggregateAvailablePages: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub AggregateDirtyPages: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub AvailableHistory: ULONG,
}
#[doc = "0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOG_HANDLE_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub LogHandle: *mut VOID,
    pub FlushToLsnRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: _LARGE_INTEGER)>,
    pub QueryLogHandleInfoRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut USHORT)>,
    #[doc = "offset: 0xc (12)"]
    pub DirtyPageStatistics: _DIRTY_PAGE_STATISTICS,
    #[doc = "offset: 0x18 (24)"]
    pub DirtyPageThresholds: _DIRTY_PAGE_THRESHOLDS,
    #[doc = "offset: 0x40 (64)"]
    pub AdditionalPagesToWrite: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub CcLWScanDPThreshold: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub LargestLsnForCurrentLWScan: _LARGE_INTEGER,
    #[doc = "offset: 0x50 (80)"]
    pub RelatedFileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x54 (84)"]
    pub LargestLsnFileObjectKey: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub LastLWTimeStamp: _LARGE_INTEGER,
    #[doc = "offset: 0x60 (96)"]
    pub Flags: ULONG,
}
impl Default for _LOG_HANDLE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOGGED_STREAM_CALLBACK_V2 {
    #[doc = "offset: 0x0 (0)"]
    pub LogHandleContext: *mut _LOG_HANDLE_CONTEXT,
}
impl Default for _LOGGED_STREAM_CALLBACK_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x90 (144) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VOLUME_CACHE_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NodeByteCode: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub UseCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0xc (12)"]
    pub VolumeCacheMapLinks: _LIST_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub DirtyPages: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub LogHandleContext: _LOG_HANDLE_CONTEXT,
    #[doc = "offset: 0x80 (128)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub PagesQueuedToDisk: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub LoggedPagesQueuedToDisk: ULONG,
}
impl Default for _VOLUME_CACHE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PPM_POLICY_SETTINGS_MASK {
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: _PPM_POLICY_SETTINGS_MASK__bindgen_ty_1,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PPM_POLICY_SETTINGS_MASK__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _PPM_POLICY_SETTINGS_MASK__bindgen_ty_1 {
    #[inline]
    pub fn IdlePromoteThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IdlePromoteThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeteroDecreaseTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeteroDecreaseTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeteroIncreaseTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeteroIncreaseTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeteroDecreaseThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeteroDecreaseThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeteroIncreaseThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeteroIncreaseThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Class0FloorPerformance(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Class0FloorPerformance(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Class1InitialPerformance(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Class1InitialPerformance(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnergyPerfPreference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnergyPerfPreference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AutonomousActivityWindow(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutonomousActivityWindow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AutonomousMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutonomousMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DutyCycling(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DutyCycling(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FrequencyCap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FrequencyCap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadPolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadPolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShortThreadPolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ShortThreadPolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IdlePromoteThreshold: ULONG,
        HeteroDecreaseTime: ULONG,
        HeteroIncreaseTime: ULONG,
        HeteroDecreaseThreshold: ULONG,
        HeteroIncreaseThreshold: ULONG,
        Class0FloorPerformance: ULONG,
        Class1InitialPerformance: ULONG,
        EnergyPerfPreference: ULONG,
        AutonomousActivityWindow: ULONG,
        AutonomousMode: ULONG,
        DutyCycling: ULONG,
        FrequencyCap: ULONG,
        ThreadPolicy: ULONG,
        ShortThreadPolicy: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IdlePromoteThreshold: u32 = unsafe { ::std::mem::transmute(IdlePromoteThreshold) };
            IdlePromoteThreshold as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HeteroDecreaseTime: u32 = unsafe { ::std::mem::transmute(HeteroDecreaseTime) };
            HeteroDecreaseTime as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HeteroIncreaseTime: u32 = unsafe { ::std::mem::transmute(HeteroIncreaseTime) };
            HeteroIncreaseTime as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let HeteroDecreaseThreshold: u32 =
                unsafe { ::std::mem::transmute(HeteroDecreaseThreshold) };
            HeteroDecreaseThreshold as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeteroIncreaseThreshold: u32 =
                unsafe { ::std::mem::transmute(HeteroIncreaseThreshold) };
            HeteroIncreaseThreshold as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Class0FloorPerformance: u32 =
                unsafe { ::std::mem::transmute(Class0FloorPerformance) };
            Class0FloorPerformance as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Class1InitialPerformance: u32 =
                unsafe { ::std::mem::transmute(Class1InitialPerformance) };
            Class1InitialPerformance as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EnergyPerfPreference: u32 = unsafe { ::std::mem::transmute(EnergyPerfPreference) };
            EnergyPerfPreference as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let AutonomousActivityWindow: u32 =
                unsafe { ::std::mem::transmute(AutonomousActivityWindow) };
            AutonomousActivityWindow as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AutonomousMode: u32 = unsafe { ::std::mem::transmute(AutonomousMode) };
            AutonomousMode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DutyCycling: u32 = unsafe { ::std::mem::transmute(DutyCycling) };
            DutyCycling as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FrequencyCap: u32 = unsafe { ::std::mem::transmute(FrequencyCap) };
            FrequencyCap as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ThreadPolicy: u32 = unsafe { ::std::mem::transmute(ThreadPolicy) };
            ThreadPolicy as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ShortThreadPolicy: u32 = unsafe { ::std::mem::transmute(ShortThreadPolicy) };
            ShortThreadPolicy as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PPM_POLICY_SETTINGS_MASK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PPM_POLICY_SETTINGS_MASK {
    #[inline]
    pub fn PerfDecreaseTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfDecreaseTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfIncreaseTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfIncreaseTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfDecreasePolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfDecreasePolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfIncreasePolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfIncreasePolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfDecreaseThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfDecreaseThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfIncreaseThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfIncreaseThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfMinPolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfMinPolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfMaxPolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfMaxPolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfTimeCheck(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfTimeCheck(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfBoostPolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfBoostPolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfBoostMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfBoostMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowThrottling(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowThrottling(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerfHistoryCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerfHistoryCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ParkingPerfState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ParkingPerfState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LatencyHintPerf(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LatencyHintPerf(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LatencyHintUnpark(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LatencyHintUnpark(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingMinCores(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingMinCores(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingMaxCores(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingMaxCores(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingDecreasePolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingDecreasePolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingIncreasePolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingIncreasePolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingDecreaseTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingDecreaseTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingIncreaseTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingIncreaseTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingOverUtilizationThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingOverUtilizationThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingDistributeUtility(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingDistributeUtility(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingConcurrencyThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingConcurrencyThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingHeadroomThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingHeadroomThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CoreParkingDistributionThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoreParkingDistributionThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleAllowScaling(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IdleAllowScaling(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleDisable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IdleDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleTimeCheck(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IdleTimeCheck(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleDemoteThreshold(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IdleDemoteThreshold(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PerfDecreaseTime: ULONG,
        PerfIncreaseTime: ULONG,
        PerfDecreasePolicy: ULONG,
        PerfIncreasePolicy: ULONG,
        PerfDecreaseThreshold: ULONG,
        PerfIncreaseThreshold: ULONG,
        PerfMinPolicy: ULONG,
        PerfMaxPolicy: ULONG,
        PerfTimeCheck: ULONG,
        PerfBoostPolicy: ULONG,
        PerfBoostMode: ULONG,
        AllowThrottling: ULONG,
        PerfHistoryCount: ULONG,
        ParkingPerfState: ULONG,
        LatencyHintPerf: ULONG,
        LatencyHintUnpark: ULONG,
        CoreParkingMinCores: ULONG,
        CoreParkingMaxCores: ULONG,
        CoreParkingDecreasePolicy: ULONG,
        CoreParkingIncreasePolicy: ULONG,
        CoreParkingDecreaseTime: ULONG,
        CoreParkingIncreaseTime: ULONG,
        CoreParkingOverUtilizationThreshold: ULONG,
        CoreParkingDistributeUtility: ULONG,
        CoreParkingConcurrencyThreshold: ULONG,
        CoreParkingHeadroomThreshold: ULONG,
        CoreParkingDistributionThreshold: ULONG,
        IdleAllowScaling: ULONG,
        IdleDisable: ULONG,
        IdleTimeCheck: ULONG,
        IdleDemoteThreshold: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PerfDecreaseTime: u32 = unsafe { ::std::mem::transmute(PerfDecreaseTime) };
            PerfDecreaseTime as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PerfIncreaseTime: u32 = unsafe { ::std::mem::transmute(PerfIncreaseTime) };
            PerfIncreaseTime as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PerfDecreasePolicy: u32 = unsafe { ::std::mem::transmute(PerfDecreasePolicy) };
            PerfDecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PerfIncreasePolicy: u32 = unsafe { ::std::mem::transmute(PerfIncreasePolicy) };
            PerfIncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PerfDecreaseThreshold: u32 =
                unsafe { ::std::mem::transmute(PerfDecreaseThreshold) };
            PerfDecreaseThreshold as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PerfIncreaseThreshold: u32 =
                unsafe { ::std::mem::transmute(PerfIncreaseThreshold) };
            PerfIncreaseThreshold as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PerfMinPolicy: u32 = unsafe { ::std::mem::transmute(PerfMinPolicy) };
            PerfMinPolicy as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PerfMaxPolicy: u32 = unsafe { ::std::mem::transmute(PerfMaxPolicy) };
            PerfMaxPolicy as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PerfTimeCheck: u32 = unsafe { ::std::mem::transmute(PerfTimeCheck) };
            PerfTimeCheck as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PerfBoostPolicy: u32 = unsafe { ::std::mem::transmute(PerfBoostPolicy) };
            PerfBoostPolicy as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PerfBoostMode: u32 = unsafe { ::std::mem::transmute(PerfBoostMode) };
            PerfBoostMode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AllowThrottling: u32 = unsafe { ::std::mem::transmute(AllowThrottling) };
            AllowThrottling as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PerfHistoryCount: u32 = unsafe { ::std::mem::transmute(PerfHistoryCount) };
            PerfHistoryCount as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ParkingPerfState: u32 = unsafe { ::std::mem::transmute(ParkingPerfState) };
            ParkingPerfState as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let LatencyHintPerf: u32 = unsafe { ::std::mem::transmute(LatencyHintPerf) };
            LatencyHintPerf as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let LatencyHintUnpark: u32 = unsafe { ::std::mem::transmute(LatencyHintUnpark) };
            LatencyHintUnpark as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CoreParkingMinCores: u32 = unsafe { ::std::mem::transmute(CoreParkingMinCores) };
            CoreParkingMinCores as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let CoreParkingMaxCores: u32 = unsafe { ::std::mem::transmute(CoreParkingMaxCores) };
            CoreParkingMaxCores as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CoreParkingDecreasePolicy: u32 =
                unsafe { ::std::mem::transmute(CoreParkingDecreasePolicy) };
            CoreParkingDecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let CoreParkingIncreasePolicy: u32 =
                unsafe { ::std::mem::transmute(CoreParkingIncreasePolicy) };
            CoreParkingIncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let CoreParkingDecreaseTime: u32 =
                unsafe { ::std::mem::transmute(CoreParkingDecreaseTime) };
            CoreParkingDecreaseTime as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let CoreParkingIncreaseTime: u32 =
                unsafe { ::std::mem::transmute(CoreParkingIncreaseTime) };
            CoreParkingIncreaseTime as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let CoreParkingOverUtilizationThreshold: u32 =
                unsafe { ::std::mem::transmute(CoreParkingOverUtilizationThreshold) };
            CoreParkingOverUtilizationThreshold as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let CoreParkingDistributeUtility: u32 =
                unsafe { ::std::mem::transmute(CoreParkingDistributeUtility) };
            CoreParkingDistributeUtility as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let CoreParkingConcurrencyThreshold: u32 =
                unsafe { ::std::mem::transmute(CoreParkingConcurrencyThreshold) };
            CoreParkingConcurrencyThreshold as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CoreParkingHeadroomThreshold: u32 =
                unsafe { ::std::mem::transmute(CoreParkingHeadroomThreshold) };
            CoreParkingHeadroomThreshold as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let CoreParkingDistributionThreshold: u32 =
                unsafe { ::std::mem::transmute(CoreParkingDistributionThreshold) };
            CoreParkingDistributionThreshold as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let IdleAllowScaling: u32 = unsafe { ::std::mem::transmute(IdleAllowScaling) };
            IdleAllowScaling as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let IdleDisable: u32 = unsafe { ::std::mem::transmute(IdleDisable) };
            IdleDisable as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let IdleTimeCheck: u32 = unsafe { ::std::mem::transmute(IdleTimeCheck) };
            IdleTimeCheck as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let IdleDemoteThreshold: u32 = unsafe { ::std::mem::transmute(IdleDemoteThreshold) };
            IdleDemoteThreshold as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 19u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PPM_ENGINE_SETTINGS {
    #[doc = "offset: 0x0 (0)"]
    pub ExplicitSetting: [_PPM_POLICY_SETTINGS_MASK; 2usize],
    #[doc = "offset: 0x10 (16)"]
    pub ThrottlingPolicy: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub PerfTimeCheck: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PerfHistoryCount: [UCHAR; 2usize],
    #[doc = "offset: 0x1a (26)"]
    pub PerfMinPolicy: [UCHAR; 2usize],
    #[doc = "offset: 0x1c (28)"]
    pub PerfMaxPolicy: [UCHAR; 2usize],
    #[doc = "offset: 0x1e (30)"]
    pub PerfDecreaseTime: [UCHAR; 2usize],
    #[doc = "offset: 0x20 (32)"]
    pub PerfIncreaseTime: [UCHAR; 2usize],
    #[doc = "offset: 0x22 (34)"]
    pub PerfDecreasePolicy: [UCHAR; 2usize],
    #[doc = "offset: 0x24 (36)"]
    pub PerfIncreasePolicy: [UCHAR; 2usize],
    #[doc = "offset: 0x26 (38)"]
    pub PerfDecreaseThreshold: [UCHAR; 2usize],
    #[doc = "offset: 0x28 (40)"]
    pub PerfIncreaseThreshold: [UCHAR; 2usize],
    #[doc = "offset: 0x2c (44)"]
    pub PerfFrequencyCap: [ULONG; 2usize],
    #[doc = "offset: 0x34 (52)"]
    pub PerfBoostPolicy: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub PerfBoostMode: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub PerfReductionTolerance: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub EnergyPerfPreference: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub AutonomousActivityWindow: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub AutonomousPreference: UCHAR,
    #[doc = "offset: 0x49 (73)"]
    pub LatencyHintPerf: [UCHAR; 2usize],
    #[doc = "offset: 0x4b (75)"]
    pub LatencyHintUnpark: [UCHAR; 2usize],
    #[doc = "offset: 0x4d (77)"]
    pub DutyCycling: UCHAR,
    #[doc = "offset: 0x4e (78)"]
    pub ParkingPerfState: [UCHAR; 2usize],
    #[doc = "offset: 0x50 (80)"]
    pub DistributeUtility: UCHAR,
    #[doc = "offset: 0x51 (81)"]
    pub CoreParkingOverUtilizationThreshold: UCHAR,
    #[doc = "offset: 0x52 (82)"]
    pub CoreParkingConcurrencyThreshold: UCHAR,
    #[doc = "offset: 0x53 (83)"]
    pub CoreParkingHeadroomThreshold: UCHAR,
    #[doc = "offset: 0x54 (84)"]
    pub CoreParkingDistributionThreshold: UCHAR,
    #[doc = "offset: 0x55 (85)"]
    pub CoreParkingDecreasePolicy: UCHAR,
    #[doc = "offset: 0x56 (86)"]
    pub CoreParkingIncreasePolicy: UCHAR,
    #[doc = "offset: 0x58 (88)"]
    pub CoreParkingDecreaseTime: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub CoreParkingIncreaseTime: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub CoreParkingMinCores: [UCHAR; 2usize],
    #[doc = "offset: 0x62 (98)"]
    pub CoreParkingMaxCores: [UCHAR; 2usize],
    #[doc = "offset: 0x64 (100)"]
    pub AllowScaling: UCHAR,
    #[doc = "offset: 0x65 (101)"]
    pub IdleDisabled: UCHAR,
    #[doc = "offset: 0x68 (104)"]
    pub IdleTimeCheck: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub IdleDemotePercent: UCHAR,
    #[doc = "offset: 0x6d (109)"]
    pub IdlePromotePercent: UCHAR,
    #[doc = "offset: 0x6e (110)"]
    pub HeteroDecreaseTime: UCHAR,
    #[doc = "offset: 0x6f (111)"]
    pub HeteroIncreaseTime: UCHAR,
    #[doc = "offset: 0x70 (112)"]
    pub HeteroDecreaseThreshold: [UCHAR; 32usize],
    #[doc = "offset: 0x90 (144)"]
    pub HeteroIncreaseThreshold: [UCHAR; 32usize],
    #[doc = "offset: 0xb0 (176)"]
    pub Class0FloorPerformance: UCHAR,
    #[doc = "offset: 0xb1 (177)"]
    pub Class1InitialPerformance: UCHAR,
    #[doc = "offset: 0xb4 (180)"]
    pub ThreadPolicies: [_KHETERO_CPU_POLICY; 2usize],
}
impl Default for _PPM_ENGINE_SETTINGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c8 (456) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_PPM_PROFILE {
    #[doc = "offset: 0x0 (0)"]
    pub Name: *mut WCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Id: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub Guid: _GUID,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Priority: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub Settings: [_PPM_ENGINE_SETTINGS; 2usize],
    #[doc = "offset: 0x1a0 (416)"]
    pub StartTime: ULONGLONG,
    #[doc = "offset: 0x1a8 (424)"]
    pub Count: ULONGLONG,
    #[doc = "offset: 0x1b0 (432)"]
    pub MaxDuration: ULONGLONG,
    #[doc = "offset: 0x1b8 (440)"]
    pub MinDuration: ULONGLONG,
    #[doc = "offset: 0x1c0 (448)"]
    pub TotalDuration: ULONGLONG,
}
impl Default for _POP_PPM_PROFILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_PLATFORM_STATE_RESIDENCY {
    #[doc = "offset: 0x0 (0)"]
    pub Residency: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub TransitionCount: ULONGLONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_PLATFORM_STATE_RESIDENCIES {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub States: [_PROCESSOR_PLATFORM_STATE_RESIDENCY; 1usize],
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEP_ACPI_EXTENDED_ADDRESS {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _PEP_ACPI_RESOURCE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: _PEP_ACPI_RESOURCE_FLAGS,
    #[doc = "offset: 0x8 (8)"]
    pub ResourceFlags: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub GeneralFlags: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub TypeSpecificFlags: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub RevisionId: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub Reserved: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub Granularity: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub MinimumAddress: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub MaximumAddress: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub TranslationAddress: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub AddressLength: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub TypeAttribute: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub DescriptorName: *mut _UNICODE_STRING,
}
impl Default for _PEP_ACPI_EXTENDED_ADDRESS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEP_ACPI_RESOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _PEP_ACPI_RESOURCE_TYPE,
    #[doc = "offset: 0x0 (0)"]
    pub IoMemory: _PEP_ACPI_IO_MEMORY_RESOURCE,
    #[doc = "offset: 0x0 (0)"]
    pub Interrupt: _PEP_ACPI_INTERRUPT_RESOURCE,
    #[doc = "offset: 0x0 (0)"]
    pub Gpio: _PEP_ACPI_GPIO_RESOURCE,
    #[doc = "offset: 0x0 (0)"]
    pub SpbI2c: _PEP_ACPI_SPB_I2C_RESOURCE,
    #[doc = "offset: 0x0 (0)"]
    pub SpbSpi: _PEP_ACPI_SPB_SPI_RESOURCE,
    #[doc = "offset: 0x0 (0)"]
    pub SpbUart: _PEP_ACPI_SPB_UART_RESOURCE,
    #[doc = "offset: 0x0 (0)"]
    pub ExtendedAddress: _PEP_ACPI_EXTENDED_ADDRESS,
}
impl Default for _PEP_ACPI_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ARM64_DBGKD_CONTROL_SET {
    #[doc = "offset: 0x0 (0)"]
    pub Continue: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TraceFlag: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentSymbolStart: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub CurrentSymbolEnd: ULONGLONG,
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _AMD64_DBGKD_CONTROL_SET {
    #[doc = "offset: 0x0 (0)"]
    pub TraceFlag: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Dr7: ULONGLONG,
    #[doc = "offset: 0xc (12)"]
    pub CurrentSymbolStart: ULONGLONG,
    #[doc = "offset: 0x14 (20)"]
    pub CurrentSymbolEnd: ULONGLONG,
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IA64_DBGKD_CONTROL_SET {
    #[doc = "offset: 0x0 (0)"]
    pub Continue: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CurrentSymbolStart: ULONGLONG,
    #[doc = "offset: 0xc (12)"]
    pub CurrentSymbolEnd: ULONGLONG,
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_ANY_CONTROL_SET {
    pub __bindgen_anon_1: _DBGKD_ANY_CONTROL_SET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_ANY_CONTROL_SET__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub X86ControlSet: _X86_DBGKD_CONTROL_SET,
    #[doc = "offset: 0x0 (0)"]
    pub AlphaControlSet: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub IA64ControlSet: _IA64_DBGKD_CONTROL_SET,
    #[doc = "offset: 0x0 (0)"]
    pub Amd64ControlSet: _AMD64_DBGKD_CONTROL_SET,
    #[doc = "offset: 0x0 (0)"]
    pub ArmControlSet: _ARM_DBGKD_CONTROL_SET,
    #[doc = "offset: 0x0 (0)"]
    pub Arm64ControlSet: _ARM64_DBGKD_CONTROL_SET,
    #[doc = "offset: 0x0 (0)"]
    pub ArmCeControlSet: _ARMCE_DBGKD_CONTROL_SET,
    #[doc = "offset: 0x0 (0)"]
    pub PpcControlSet: _PPC_DBGKD_CONTROL_SET,
}
impl Default for _DBGKD_ANY_CONTROL_SET__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_ANY_CONTROL_SET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_CONTINUE2 {
    #[doc = "offset: 0x0 (0)"]
    pub ContinueStatus: LONG,
    pub __bindgen_anon_1: _DBGKD_CONTINUE2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_CONTINUE2__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub ControlSet: _X86_DBGKD_CONTROL_SET,
    #[doc = "offset: 0x4 (4)"]
    pub AnyControlSet: _DBGKD_ANY_CONTROL_SET,
}
impl Default for _DBGKD_CONTINUE2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_CONTINUE2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_WRITE_CUSTOM_BREAKPOINT {
    #[doc = "offset: 0x0 (0)"]
    pub BreakPointAddress: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub BreakPointInstruction: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub BreakPointHandle: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub BreakPointInstructionSize: UCHAR,
    #[doc = "offset: 0x15 (21)"]
    pub BreakPointInstructionAlignment: UCHAR,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_QUERY_MEMORY {
    #[doc = "offset: 0x0 (0)"]
    pub Address: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub AddressSpace: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Flags: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_FILL_MEMORY {
    #[doc = "offset: 0x0 (0)"]
    pub Address: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Length: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Flags: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub PatternLength: USHORT,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_SEARCH_MEMORY {
    pub __bindgen_anon_1: _DBGKD_SEARCH_MEMORY__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub SearchLength: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub PatternLength: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_SEARCH_MEMORY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub SearchAddress: ULONGLONG,
    #[doc = "offset: 0x0 (0)"]
    pub FoundAddress: ULONGLONG,
}
impl Default for _DBGKD_SEARCH_MEMORY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_SEARCH_MEMORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_GET_VERSION64 {
    #[doc = "offset: 0x0 (0)"]
    pub MajorVersion: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MinorVersion: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub ProtocolVersion: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub KdSecondaryVersion: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub MachineType: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub MaxPacketType: UCHAR,
    #[doc = "offset: 0xb (11)"]
    pub MaxStateChange: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub MaxManipulate: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub Simulation: UCHAR,
    #[doc = "offset: 0xe (14)"]
    pub Unused: [USHORT; 1usize],
    #[doc = "offset: 0x10 (16)"]
    pub KernBase: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub PsLoadedModuleList: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub DebuggerDataList: ULONGLONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_GET_INTERNAL_BREAKPOINT64 {
    #[doc = "offset: 0x0 (0)"]
    pub BreakpointAddress: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Calls: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MaxCallsPerPeriod: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub MinInstructions: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub MaxInstructions: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub TotalInstructions: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_SET_INTERNAL_BREAKPOINT64 {
    #[doc = "offset: 0x0 (0)"]
    pub BreakpointAddress: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_SET_SPECIAL_CALL64 {
    #[doc = "offset: 0x0 (0)"]
    pub SpecialCall: ULONGLONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_READ_WRITE_IO_EXTENDED64 {
    #[doc = "offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub InterfaceType: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AddressSpace: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub IoAddress: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub DataValue: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_READ_WRITE_IO64 {
    #[doc = "offset: 0x0 (0)"]
    pub IoAddress: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub DataSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DataValue: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_WRITE_BREAKPOINT64 {
    #[doc = "offset: 0x0 (0)"]
    pub BreakPointAddress: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub BreakPointHandle: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_WRITE_MEMORY64 {
    #[doc = "offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub TransferCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ActualBytesWritten: ULONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_READ_MEMORY64 {
    #[doc = "offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub TransferCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ActualBytesRead: ULONG,
}
#[doc = "0x34 (52) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_MANIPULATE_STATE32 {
    #[doc = "offset: 0x0 (0)"]
    pub ApiNumber: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ProcessorLevel: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Processor: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub ReturnStatus: LONG,
    #[doc = "offset: 0xc (12)"]
    pub u: _DBGKD_MANIPULATE_STATE32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_MANIPULATE_STATE32__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub ReadMemory: _DBGKD_READ_MEMORY32,
    #[doc = "offset: 0xc (12)"]
    pub WriteMemory: _DBGKD_WRITE_MEMORY32,
    #[doc = "offset: 0xc (12)"]
    pub ReadMemory64: _DBGKD_READ_MEMORY64,
    #[doc = "offset: 0xc (12)"]
    pub WriteMemory64: _DBGKD_WRITE_MEMORY64,
    #[doc = "offset: 0xc (12)"]
    pub GetContext: _DBGKD_GET_CONTEXT,
    #[doc = "offset: 0xc (12)"]
    pub SetContext: _DBGKD_SET_CONTEXT,
    #[doc = "offset: 0xc (12)"]
    pub WriteBreakPoint: _DBGKD_WRITE_BREAKPOINT32,
    #[doc = "offset: 0xc (12)"]
    pub RestoreBreakPoint: _DBGKD_RESTORE_BREAKPOINT,
    #[doc = "offset: 0xc (12)"]
    pub Continue: _DBGKD_CONTINUE,
    #[doc = "offset: 0xc (12)"]
    pub Continue2: _DBGKD_CONTINUE2,
    #[doc = "offset: 0xc (12)"]
    pub ReadWriteIo: _DBGKD_READ_WRITE_IO32,
    #[doc = "offset: 0xc (12)"]
    pub ReadWriteIoExtended: _DBGKD_READ_WRITE_IO_EXTENDED32,
    #[doc = "offset: 0xc (12)"]
    pub QuerySpecialCalls: _DBGKD_QUERY_SPECIAL_CALLS,
    #[doc = "offset: 0xc (12)"]
    pub SetSpecialCall: _DBGKD_SET_SPECIAL_CALL32,
    #[doc = "offset: 0xc (12)"]
    pub SetInternalBreakpoint: _DBGKD_SET_INTERNAL_BREAKPOINT32,
    #[doc = "offset: 0xc (12)"]
    pub GetInternalBreakpoint: _DBGKD_GET_INTERNAL_BREAKPOINT32,
    #[doc = "offset: 0xc (12)"]
    pub GetVersion32: _DBGKD_GET_VERSION32,
    #[doc = "offset: 0xc (12)"]
    pub BreakPointEx: _DBGKD_BREAKPOINTEX,
    #[doc = "offset: 0xc (12)"]
    pub ReadWriteMsr: _DBGKD_READ_WRITE_MSR,
    #[doc = "offset: 0xc (12)"]
    pub SearchMemory: _DBGKD_SEARCH_MEMORY,
    #[doc = "offset: 0xc (12)"]
    pub GetContextEx: _DBGKD_CONTEXT_EX,
    #[doc = "offset: 0xc (12)"]
    pub SetContextEx: _DBGKD_CONTEXT_EX,
}
impl Default for _DBGKD_MANIPULATE_STATE32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_MANIPULATE_STATE32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_MANIPULATE_STATE64 {
    #[doc = "offset: 0x0 (0)"]
    pub ApiNumber: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ProcessorLevel: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Processor: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub ReturnStatus: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub u: _DBGKD_MANIPULATE_STATE64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_MANIPULATE_STATE64__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub ReadMemory: _DBGKD_READ_MEMORY64,
    #[doc = "offset: 0x10 (16)"]
    pub WriteMemory: _DBGKD_WRITE_MEMORY64,
    #[doc = "offset: 0x10 (16)"]
    pub GetContext: _DBGKD_GET_CONTEXT,
    #[doc = "offset: 0x10 (16)"]
    pub SetContext: _DBGKD_SET_CONTEXT,
    #[doc = "offset: 0x10 (16)"]
    pub WriteBreakPoint: _DBGKD_WRITE_BREAKPOINT64,
    #[doc = "offset: 0x10 (16)"]
    pub RestoreBreakPoint: _DBGKD_RESTORE_BREAKPOINT,
    #[doc = "offset: 0x10 (16)"]
    pub Continue: _DBGKD_CONTINUE,
    #[doc = "offset: 0x10 (16)"]
    pub Continue2: _DBGKD_CONTINUE2,
    #[doc = "offset: 0x10 (16)"]
    pub ReadWriteIo: _DBGKD_READ_WRITE_IO64,
    #[doc = "offset: 0x10 (16)"]
    pub ReadWriteIoExtended: _DBGKD_READ_WRITE_IO_EXTENDED64,
    #[doc = "offset: 0x10 (16)"]
    pub QuerySpecialCalls: _DBGKD_QUERY_SPECIAL_CALLS,
    #[doc = "offset: 0x10 (16)"]
    pub SetSpecialCall: _DBGKD_SET_SPECIAL_CALL64,
    #[doc = "offset: 0x10 (16)"]
    pub SetInternalBreakpoint: _DBGKD_SET_INTERNAL_BREAKPOINT64,
    #[doc = "offset: 0x10 (16)"]
    pub GetInternalBreakpoint: _DBGKD_GET_INTERNAL_BREAKPOINT64,
    #[doc = "offset: 0x10 (16)"]
    pub GetVersion64: _DBGKD_GET_VERSION64,
    #[doc = "offset: 0x10 (16)"]
    pub BreakPointEx: _DBGKD_BREAKPOINTEX,
    #[doc = "offset: 0x10 (16)"]
    pub ReadWriteMsr: _DBGKD_READ_WRITE_MSR,
    #[doc = "offset: 0x10 (16)"]
    pub SearchMemory: _DBGKD_SEARCH_MEMORY,
    #[doc = "offset: 0x10 (16)"]
    pub GetSetBusData: _DBGKD_GET_SET_BUS_DATA,
    #[doc = "offset: 0x10 (16)"]
    pub FillMemory: _DBGKD_FILL_MEMORY,
    #[doc = "offset: 0x10 (16)"]
    pub QueryMemory: _DBGKD_QUERY_MEMORY,
    #[doc = "offset: 0x10 (16)"]
    pub SwitchPartition: _DBGKD_SWITCH_PARTITION,
    #[doc = "offset: 0x10 (16)"]
    pub GetContextEx: _DBGKD_CONTEXT_EX,
    #[doc = "offset: 0x10 (16)"]
    pub SetContextEx: _DBGKD_CONTEXT_EX,
    #[doc = "offset: 0x10 (16)"]
    pub WriteCustomBreakPoint: _DBGKD_WRITE_CUSTOM_BREAKPOINT,
}
impl Default for _DBGKD_MANIPULATE_STATE64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_MANIPULATE_STATE64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKD_LOAD_SYMBOLS64 {
    #[doc = "offset: 0x0 (0)"]
    pub PathNameLength: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BaseOfDll: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub ProcessId: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CheckSum: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub SizeOfImage: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub UnloadSymbols: UCHAR,
}
#[doc = "0x98 (152) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXCEPTION_RECORD64 {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionCode: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub ExceptionFlags: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ExceptionRecord: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub ExceptionAddress: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub NumberParameters: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub __unusedAlignment: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ExceptionInformation: [ULONGLONG; 15usize],
}
#[doc = "0xa0 (160) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DBGKM_EXCEPTION64 {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionRecord: _EXCEPTION_RECORD64,
    #[doc = "offset: 0x98 (152)"]
    pub FirstChance: ULONG,
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCGEN_TRACE_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub RegistrationHandle: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Logger: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub MatchAnyKeyword: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub MatchAllKeyword: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub IsEnabled: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Level: UCHAR,
    #[doc = "offset: 0x29 (41)"]
    pub Reserve: UCHAR,
    #[doc = "offset: 0x2a (42)"]
    pub EnableBitsCount: USHORT,
    #[doc = "offset: 0x2c (44)"]
    pub EnableBitMask: *mut ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub EnableKeyWords: *const ULONGLONG,
    #[doc = "offset: 0x34 (52)"]
    pub EnableLevel: *const UCHAR,
}
impl Default for _MCGEN_TRACE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    #[doc = "offset: 0x0 (0)"]
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: ULONG,
}
impl Default for _ULARGE_INTEGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HV_PARTITION_PRIVILEGE_MASK {
    #[doc = "offset: 0x0 (0)"]
    pub AsUINT64: ULONGLONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for _HV_PARTITION_PRIVILEGE_MASK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _HV_PARTITION_PRIVILEGE_MASK {
    #[inline]
    pub fn AccessVpRunTimeReg(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessVpRunTimeReg(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessPartitionReferenceCounter(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessPartitionReferenceCounter(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessSynicRegs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessSynicRegs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessSyntheticTimerRegs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessSyntheticTimerRegs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessIntrCtrlRegs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessIntrCtrlRegs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessHypercallMsrs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessHypercallMsrs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessVpIndex(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessVpIndex(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessResetReg(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessResetReg(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessStatsReg(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessStatsReg(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessPartitionReferenceTsc(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessPartitionReferenceTsc(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessGuestIdleReg(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessGuestIdleReg(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessFrequencyRegs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessFrequencyRegs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessDebugRegs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessDebugRegs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessReenlightenmentControls(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessReenlightenmentControls(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessRootSchedulerReg(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessRootSchedulerReg(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn CreatePartitions(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CreatePartitions(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessPartitionId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessPartitionId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessMemoryPool(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessMemoryPool(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AdjustMessageBuffers(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AdjustMessageBuffers(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostMessages(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PostMessages(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SignalEvents(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SignalEvents(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CreatePort(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CreatePort(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ConnectPort(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ConnectPort(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessStats(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessStats(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Debugging(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Debugging(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CpuManagement(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CpuManagement(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ConfigureProfiler(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ConfigureProfiler(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessVpExitTracing(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessVpExitTracing(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExtendedGvaRangesForFlushVirtualAddressList(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EnableExtendedGvaRangesForFlushVirtualAddressList(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessVsm(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessVsm(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessVpRegisters(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AccessVpRegisters(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnusedBit(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UnusedBit(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FastHypercallOutput(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FastHypercallOutput(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExtendedHypercalls(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EnableExtendedHypercalls(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StartVirtualProcessor(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StartVirtualProcessor(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AccessVpRunTimeReg: ULONGLONG,
        AccessPartitionReferenceCounter: ULONGLONG,
        AccessSynicRegs: ULONGLONG,
        AccessSyntheticTimerRegs: ULONGLONG,
        AccessIntrCtrlRegs: ULONGLONG,
        AccessHypercallMsrs: ULONGLONG,
        AccessVpIndex: ULONGLONG,
        AccessResetReg: ULONGLONG,
        AccessStatsReg: ULONGLONG,
        AccessPartitionReferenceTsc: ULONGLONG,
        AccessGuestIdleReg: ULONGLONG,
        AccessFrequencyRegs: ULONGLONG,
        AccessDebugRegs: ULONGLONG,
        AccessReenlightenmentControls: ULONGLONG,
        AccessRootSchedulerReg: ULONGLONG,
        Reserved1: ULONGLONG,
        CreatePartitions: ULONGLONG,
        AccessPartitionId: ULONGLONG,
        AccessMemoryPool: ULONGLONG,
        AdjustMessageBuffers: ULONGLONG,
        PostMessages: ULONGLONG,
        SignalEvents: ULONGLONG,
        CreatePort: ULONGLONG,
        ConnectPort: ULONGLONG,
        AccessStats: ULONGLONG,
        Reserved2: ULONGLONG,
        Debugging: ULONGLONG,
        CpuManagement: ULONGLONG,
        ConfigureProfiler: ULONGLONG,
        AccessVpExitTracing: ULONGLONG,
        EnableExtendedGvaRangesForFlushVirtualAddressList: ULONGLONG,
        AccessVsm: ULONGLONG,
        AccessVpRegisters: ULONGLONG,
        UnusedBit: ULONGLONG,
        FastHypercallOutput: ULONGLONG,
        EnableExtendedHypercalls: ULONGLONG,
        StartVirtualProcessor: ULONGLONG,
        Reserved3: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AccessVpRunTimeReg: u64 = unsafe { ::std::mem::transmute(AccessVpRunTimeReg) };
            AccessVpRunTimeReg as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AccessPartitionReferenceCounter: u64 =
                unsafe { ::std::mem::transmute(AccessPartitionReferenceCounter) };
            AccessPartitionReferenceCounter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AccessSynicRegs: u64 = unsafe { ::std::mem::transmute(AccessSynicRegs) };
            AccessSynicRegs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AccessSyntheticTimerRegs: u64 =
                unsafe { ::std::mem::transmute(AccessSyntheticTimerRegs) };
            AccessSyntheticTimerRegs as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AccessIntrCtrlRegs: u64 = unsafe { ::std::mem::transmute(AccessIntrCtrlRegs) };
            AccessIntrCtrlRegs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AccessHypercallMsrs: u64 = unsafe { ::std::mem::transmute(AccessHypercallMsrs) };
            AccessHypercallMsrs as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let AccessVpIndex: u64 = unsafe { ::std::mem::transmute(AccessVpIndex) };
            AccessVpIndex as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AccessResetReg: u64 = unsafe { ::std::mem::transmute(AccessResetReg) };
            AccessResetReg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let AccessStatsReg: u64 = unsafe { ::std::mem::transmute(AccessStatsReg) };
            AccessStatsReg as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AccessPartitionReferenceTsc: u64 =
                unsafe { ::std::mem::transmute(AccessPartitionReferenceTsc) };
            AccessPartitionReferenceTsc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let AccessGuestIdleReg: u64 = unsafe { ::std::mem::transmute(AccessGuestIdleReg) };
            AccessGuestIdleReg as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AccessFrequencyRegs: u64 = unsafe { ::std::mem::transmute(AccessFrequencyRegs) };
            AccessFrequencyRegs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let AccessDebugRegs: u64 = unsafe { ::std::mem::transmute(AccessDebugRegs) };
            AccessDebugRegs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AccessReenlightenmentControls: u64 =
                unsafe { ::std::mem::transmute(AccessReenlightenmentControls) };
            AccessReenlightenmentControls as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let AccessRootSchedulerReg: u64 =
                unsafe { ::std::mem::transmute(AccessRootSchedulerReg) };
            AccessRootSchedulerReg as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let CreatePartitions: u64 = unsafe { ::std::mem::transmute(CreatePartitions) };
            CreatePartitions as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let AccessPartitionId: u64 = unsafe { ::std::mem::transmute(AccessPartitionId) };
            AccessPartitionId as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let AccessMemoryPool: u64 = unsafe { ::std::mem::transmute(AccessMemoryPool) };
            AccessMemoryPool as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let AdjustMessageBuffers: u64 = unsafe { ::std::mem::transmute(AdjustMessageBuffers) };
            AdjustMessageBuffers as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let PostMessages: u64 = unsafe { ::std::mem::transmute(PostMessages) };
            PostMessages as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let SignalEvents: u64 = unsafe { ::std::mem::transmute(SignalEvents) };
            SignalEvents as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let CreatePort: u64 = unsafe { ::std::mem::transmute(CreatePort) };
            CreatePort as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let ConnectPort: u64 = unsafe { ::std::mem::transmute(ConnectPort) };
            ConnectPort as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let AccessStats: u64 = unsafe { ::std::mem::transmute(AccessStats) };
            AccessStats as u64
        });
        __bindgen_bitfield_unit.set(41usize, 2u8, {
            let Reserved2: u64 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let Debugging: u64 = unsafe { ::std::mem::transmute(Debugging) };
            Debugging as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let CpuManagement: u64 = unsafe { ::std::mem::transmute(CpuManagement) };
            CpuManagement as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let ConfigureProfiler: u64 = unsafe { ::std::mem::transmute(ConfigureProfiler) };
            ConfigureProfiler as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let AccessVpExitTracing: u64 = unsafe { ::std::mem::transmute(AccessVpExitTracing) };
            AccessVpExitTracing as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let EnableExtendedGvaRangesForFlushVirtualAddressList: u64 =
                unsafe { ::std::mem::transmute(EnableExtendedGvaRangesForFlushVirtualAddressList) };
            EnableExtendedGvaRangesForFlushVirtualAddressList as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let AccessVsm: u64 = unsafe { ::std::mem::transmute(AccessVsm) };
            AccessVsm as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let AccessVpRegisters: u64 = unsafe { ::std::mem::transmute(AccessVpRegisters) };
            AccessVpRegisters as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let UnusedBit: u64 = unsafe { ::std::mem::transmute(UnusedBit) };
            UnusedBit as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let FastHypercallOutput: u64 = unsafe { ::std::mem::transmute(FastHypercallOutput) };
            FastHypercallOutput as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let EnableExtendedHypercalls: u64 =
                unsafe { ::std::mem::transmute(EnableExtendedHypercalls) };
            EnableExtendedHypercalls as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let StartVirtualProcessor: u64 =
                unsafe { ::std::mem::transmute(StartVirtualProcessor) };
            StartVirtualProcessor as u64
        });
        __bindgen_bitfield_unit.set(54usize, 10u8, {
            let Reserved3: u64 = unsafe { ::std::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HV_X64_HYPERVISOR_FEATURES {
    #[doc = "offset: 0x0 (0)"]
    pub PartitionPrivileges: _HV_PARTITION_PRIVILEGE_MASK,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for _HV_X64_HYPERVISOR_FEATURES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _HV_X64_HYPERVISOR_FEATURES {
    #[inline]
    pub fn MaxSupportedCState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MaxSupportedCState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn HpetNeededForC3PowerState_Deprecated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HpetNeededForC3PowerState_Deprecated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn MwaitAvailable_Deprecated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MwaitAvailable_Deprecated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuestDebuggingAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuestDebuggingAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PerformanceMonitorsAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerformanceMonitorsAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CpuDynamicPartitioningAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CpuDynamicPartitioningAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XmmRegistersForFastHypercallAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XmmRegistersForFastHypercallAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuestIdleAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuestIdleAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HypervisorSleepStateSupportAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HypervisorSleepStateSupportAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NumaDistanceQueryAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NumaDistanceQueryAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FrequencyRegsAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FrequencyRegsAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SyntheticMachineCheckAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SyntheticMachineCheckAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuestCrashRegsAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuestCrashRegsAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugRegsAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DebugRegsAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Npiep1Available(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Npiep1Available(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableHypervisorAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableHypervisorAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedGvaRangesForFlushVirtualAddressListAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedGvaRangesForFlushVirtualAddressListAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FastHypercallOutputAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FastHypercallOutputAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SvmFeaturesAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SvmFeaturesAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SintPollingModeAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SintPollingModeAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HypercallMsrLockAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HypercallMsrLockAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectSyntheticTimers(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectSyntheticTimers(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RegisterPatAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RegisterPatAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RegisterBndcfgsAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RegisterBndcfgsAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WatchdogTimerAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WatchdogTimerAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SyntheticTimeUnhaltedTimerAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SyntheticTimeUnhaltedTimerAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceDomainsAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceDomainsAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MaxSupportedCState: ULONG,
        HpetNeededForC3PowerState_Deprecated: ULONG,
        Reserved: ULONG,
        MwaitAvailable_Deprecated: ULONG,
        GuestDebuggingAvailable: ULONG,
        PerformanceMonitorsAvailable: ULONG,
        CpuDynamicPartitioningAvailable: ULONG,
        XmmRegistersForFastHypercallAvailable: ULONG,
        GuestIdleAvailable: ULONG,
        HypervisorSleepStateSupportAvailable: ULONG,
        NumaDistanceQueryAvailable: ULONG,
        FrequencyRegsAvailable: ULONG,
        SyntheticMachineCheckAvailable: ULONG,
        GuestCrashRegsAvailable: ULONG,
        DebugRegsAvailable: ULONG,
        Npiep1Available: ULONG,
        DisableHypervisorAvailable: ULONG,
        ExtendedGvaRangesForFlushVirtualAddressListAvailable: ULONG,
        FastHypercallOutputAvailable: ULONG,
        SvmFeaturesAvailable: ULONG,
        SintPollingModeAvailable: ULONG,
        HypercallMsrLockAvailable: ULONG,
        DirectSyntheticTimers: ULONG,
        RegisterPatAvailable: ULONG,
        RegisterBndcfgsAvailable: ULONG,
        WatchdogTimerAvailable: ULONG,
        SyntheticTimeUnhaltedTimerAvailable: ULONG,
        DeviceDomainsAvailable: ULONG,
        Reserved1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let MaxSupportedCState: u32 = unsafe { ::std::mem::transmute(MaxSupportedCState) };
            MaxSupportedCState as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HpetNeededForC3PowerState_Deprecated: u32 =
                unsafe { ::std::mem::transmute(HpetNeededForC3PowerState_Deprecated) };
            HpetNeededForC3PowerState_Deprecated as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let MwaitAvailable_Deprecated: u32 =
                unsafe { ::std::mem::transmute(MwaitAvailable_Deprecated) };
            MwaitAvailable_Deprecated as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let GuestDebuggingAvailable: u32 =
                unsafe { ::std::mem::transmute(GuestDebuggingAvailable) };
            GuestDebuggingAvailable as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let PerformanceMonitorsAvailable: u32 =
                unsafe { ::std::mem::transmute(PerformanceMonitorsAvailable) };
            PerformanceMonitorsAvailable as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let CpuDynamicPartitioningAvailable: u32 =
                unsafe { ::std::mem::transmute(CpuDynamicPartitioningAvailable) };
            CpuDynamicPartitioningAvailable as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let XmmRegistersForFastHypercallAvailable: u32 =
                unsafe { ::std::mem::transmute(XmmRegistersForFastHypercallAvailable) };
            XmmRegistersForFastHypercallAvailable as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let GuestIdleAvailable: u32 = unsafe { ::std::mem::transmute(GuestIdleAvailable) };
            GuestIdleAvailable as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let HypervisorSleepStateSupportAvailable: u32 =
                unsafe { ::std::mem::transmute(HypervisorSleepStateSupportAvailable) };
            HypervisorSleepStateSupportAvailable as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let NumaDistanceQueryAvailable: u32 =
                unsafe { ::std::mem::transmute(NumaDistanceQueryAvailable) };
            NumaDistanceQueryAvailable as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let FrequencyRegsAvailable: u32 =
                unsafe { ::std::mem::transmute(FrequencyRegsAvailable) };
            FrequencyRegsAvailable as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let SyntheticMachineCheckAvailable: u32 =
                unsafe { ::std::mem::transmute(SyntheticMachineCheckAvailable) };
            SyntheticMachineCheckAvailable as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let GuestCrashRegsAvailable: u32 =
                unsafe { ::std::mem::transmute(GuestCrashRegsAvailable) };
            GuestCrashRegsAvailable as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let DebugRegsAvailable: u32 = unsafe { ::std::mem::transmute(DebugRegsAvailable) };
            DebugRegsAvailable as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let Npiep1Available: u32 = unsafe { ::std::mem::transmute(Npiep1Available) };
            Npiep1Available as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let DisableHypervisorAvailable: u32 =
                unsafe { ::std::mem::transmute(DisableHypervisorAvailable) };
            DisableHypervisorAvailable as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let ExtendedGvaRangesForFlushVirtualAddressListAvailable: u32 = unsafe {
                ::std::mem::transmute(ExtendedGvaRangesForFlushVirtualAddressListAvailable)
            };
            ExtendedGvaRangesForFlushVirtualAddressListAvailable as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let FastHypercallOutputAvailable: u32 =
                unsafe { ::std::mem::transmute(FastHypercallOutputAvailable) };
            FastHypercallOutputAvailable as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let SvmFeaturesAvailable: u32 = unsafe { ::std::mem::transmute(SvmFeaturesAvailable) };
            SvmFeaturesAvailable as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let SintPollingModeAvailable: u32 =
                unsafe { ::std::mem::transmute(SintPollingModeAvailable) };
            SintPollingModeAvailable as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let HypercallMsrLockAvailable: u32 =
                unsafe { ::std::mem::transmute(HypercallMsrLockAvailable) };
            HypercallMsrLockAvailable as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let DirectSyntheticTimers: u32 =
                unsafe { ::std::mem::transmute(DirectSyntheticTimers) };
            DirectSyntheticTimers as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let RegisterPatAvailable: u32 = unsafe { ::std::mem::transmute(RegisterPatAvailable) };
            RegisterPatAvailable as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let RegisterBndcfgsAvailable: u32 =
                unsafe { ::std::mem::transmute(RegisterBndcfgsAvailable) };
            RegisterBndcfgsAvailable as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let WatchdogTimerAvailable: u32 =
                unsafe { ::std::mem::transmute(WatchdogTimerAvailable) };
            WatchdogTimerAvailable as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let SyntheticTimeUnhaltedTimerAvailable: u32 =
                unsafe { ::std::mem::transmute(SyntheticTimeUnhaltedTimerAvailable) };
            SyntheticTimeUnhaltedTimerAvailable as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let DeviceDomainsAvailable: u32 =
                unsafe { ::std::mem::transmute(DeviceDomainsAvailable) };
            DeviceDomainsAvailable as u64
        });
        __bindgen_bitfield_unit.set(57usize, 7u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _STRING64 {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Buffer: ULONGLONG,
}
#[doc = "0x4e8 (1256) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDI_TEB_BATCH64 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x8 (8)"]
    pub HDC: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _GDI_TEB_BATCH64 {
    #[inline]
    pub fn Offset(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Offset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn HasRenderingCommand(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasRenderingCommand(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Offset: ULONG,
        HasRenderingCommand: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let Offset: u32 = unsafe { ::std::mem::transmute(Offset) };
            Offset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let HasRenderingCommand: u32 = unsafe { ::std::mem::transmute(HasRenderingCommand) };
            HasRenderingCommand as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CLIENT_ID64 {
    #[doc = "offset: 0x0 (0)"]
    pub UniqueProcess: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub UniqueThread: ULONGLONG,
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB64 {
    #[doc = "offset: 0x0 (0)"]
    pub ExceptionList: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub StackBase: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub StackLimit: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub SubSystemTib: ULONGLONG,
    pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
    #[doc = "offset: 0x28 (40)"]
    pub ArbitraryUserPointer: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub Self_: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB64__bindgen_ty_1 {
    #[doc = "offset: 0x20 (32)"]
    pub FiberData: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub Version: ULONG,
}
impl Default for _NT_TIB64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NT_TIB64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1000 (4096) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TEB32 {
    #[doc = "offset: 0x0 (0)"]
    pub NtTib: _NT_TIB32,
    #[doc = "offset: 0x1c (28)"]
    pub EnvironmentPointer: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ClientId: _CLIENT_ID32,
    #[doc = "offset: 0x28 (40)"]
    pub ActiveRpcHandle: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub ThreadLocalStoragePointer: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub ProcessEnvironmentBlock: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub LastErrorValue: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub CountOfOwnedCriticalSections: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub CsrClientThread: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub Win32ThreadInfo: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub User32Reserved: [ULONG; 26usize],
    #[doc = "offset: 0xac (172)"]
    pub UserReserved: [ULONG; 5usize],
    #[doc = "offset: 0xc0 (192)"]
    pub WOW32Reserved: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub CurrentLocale: ULONG,
    #[doc = "offset: 0xc8 (200)"]
    pub FpSoftwareStatusRegister: ULONG,
    #[doc = "offset: 0xcc (204)"]
    pub ReservedForDebuggerInstrumentation: [ULONG; 16usize],
    #[doc = "offset: 0x10c (268)"]
    pub SystemReserved1: [ULONG; 26usize],
    #[doc = "offset: 0x174 (372)"]
    pub PlaceholderCompatibilityMode: CHAR,
    #[doc = "offset: 0x175 (373)"]
    pub PlaceholderReserved: [CHAR; 11usize],
    #[doc = "offset: 0x180 (384)"]
    pub ProxiedProcessId: ULONG,
    #[doc = "offset: 0x184 (388)"]
    pub _ActivationStack: _ACTIVATION_CONTEXT_STACK32,
    #[doc = "offset: 0x19c (412)"]
    pub WorkingOnBehalfTicket: [UCHAR; 8usize],
    #[doc = "offset: 0x1a4 (420)"]
    pub ExceptionCode: LONG,
    #[doc = "offset: 0x1a8 (424)"]
    pub ActivationContextStackPointer: ULONG,
    #[doc = "offset: 0x1ac (428)"]
    pub InstrumentationCallbackSp: ULONG,
    #[doc = "offset: 0x1b0 (432)"]
    pub InstrumentationCallbackPreviousPc: ULONG,
    #[doc = "offset: 0x1b4 (436)"]
    pub InstrumentationCallbackPreviousSp: ULONG,
    #[doc = "offset: 0x1b8 (440)"]
    pub InstrumentationCallbackDisabled: UCHAR,
    #[doc = "offset: 0x1b9 (441)"]
    pub SpareBytes: [UCHAR; 23usize],
    #[doc = "offset: 0x1d0 (464)"]
    pub TxFsContext: ULONG,
    #[doc = "offset: 0x1d4 (468)"]
    pub GdiTebBatch: _GDI_TEB_BATCH32,
    #[doc = "offset: 0x6b4 (1716)"]
    pub RealClientId: _CLIENT_ID32,
    #[doc = "offset: 0x6bc (1724)"]
    pub GdiCachedProcessHandle: ULONG,
    #[doc = "offset: 0x6c0 (1728)"]
    pub GdiClientPID: ULONG,
    #[doc = "offset: 0x6c4 (1732)"]
    pub GdiClientTID: ULONG,
    #[doc = "offset: 0x6c8 (1736)"]
    pub GdiThreadLocalInfo: ULONG,
    #[doc = "offset: 0x6cc (1740)"]
    pub Win32ClientInfo: [ULONG; 62usize],
    #[doc = "offset: 0x7c4 (1988)"]
    pub glDispatchTable: [ULONG; 233usize],
    #[doc = "offset: 0xb68 (2920)"]
    pub glReserved1: [ULONG; 29usize],
    #[doc = "offset: 0xbdc (3036)"]
    pub glReserved2: ULONG,
    #[doc = "offset: 0xbe0 (3040)"]
    pub glSectionInfo: ULONG,
    #[doc = "offset: 0xbe4 (3044)"]
    pub glSection: ULONG,
    #[doc = "offset: 0xbe8 (3048)"]
    pub glTable: ULONG,
    #[doc = "offset: 0xbec (3052)"]
    pub glCurrentRC: ULONG,
    #[doc = "offset: 0xbf0 (3056)"]
    pub glContext: ULONG,
    #[doc = "offset: 0xbf4 (3060)"]
    pub LastStatusValue: ULONG,
    #[doc = "offset: 0xbf8 (3064)"]
    pub StaticUnicodeString: _STRING32,
    #[doc = "offset: 0xc00 (3072)"]
    pub StaticUnicodeBuffer: [WCHAR; 261usize],
    #[doc = "offset: 0xe0c (3596)"]
    pub DeallocationStack: ULONG,
    #[doc = "offset: 0xe10 (3600)"]
    pub TlsSlots: [ULONG; 64usize],
    #[doc = "offset: 0xf10 (3856)"]
    pub TlsLinks: LIST_ENTRY32,
    #[doc = "offset: 0xf18 (3864)"]
    pub Vdm: ULONG,
    #[doc = "offset: 0xf1c (3868)"]
    pub ReservedForNtRpc: ULONG,
    #[doc = "offset: 0xf20 (3872)"]
    pub DbgSsReserved: [ULONG; 2usize],
    #[doc = "offset: 0xf28 (3880)"]
    pub HardErrorMode: ULONG,
    #[doc = "offset: 0xf2c (3884)"]
    pub Instrumentation: [ULONG; 9usize],
    #[doc = "offset: 0xf50 (3920)"]
    pub ActivityId: _GUID,
    #[doc = "offset: 0xf60 (3936)"]
    pub SubProcessTag: ULONG,
    #[doc = "offset: 0xf64 (3940)"]
    pub PerflibData: ULONG,
    #[doc = "offset: 0xf68 (3944)"]
    pub EtwTraceData: ULONG,
    #[doc = "offset: 0xf6c (3948)"]
    pub WinSockData: ULONG,
    #[doc = "offset: 0xf70 (3952)"]
    pub GdiBatchCount: ULONG,
    pub __bindgen_anon_1: _TEB32__bindgen_ty_1,
    #[doc = "offset: 0xf78 (3960)"]
    pub GuaranteedStackBytes: ULONG,
    #[doc = "offset: 0xf7c (3964)"]
    pub ReservedForPerf: ULONG,
    #[doc = "offset: 0xf80 (3968)"]
    pub ReservedForOle: ULONG,
    #[doc = "offset: 0xf84 (3972)"]
    pub WaitingOnLoaderLock: ULONG,
    #[doc = "offset: 0xf88 (3976)"]
    pub SavedPriorityState: ULONG,
    #[doc = "offset: 0xf8c (3980)"]
    pub ReservedForCodeCoverage: ULONG,
    #[doc = "offset: 0xf90 (3984)"]
    pub ThreadPoolData: ULONG,
    #[doc = "offset: 0xf94 (3988)"]
    pub TlsExpansionSlots: ULONG,
    #[doc = "offset: 0xf98 (3992)"]
    pub MuiGeneration: ULONG,
    #[doc = "offset: 0xf9c (3996)"]
    pub IsImpersonating: ULONG,
    #[doc = "offset: 0xfa0 (4000)"]
    pub NlsCache: ULONG,
    #[doc = "offset: 0xfa4 (4004)"]
    pub pShimData: ULONG,
    #[doc = "offset: 0xfa8 (4008)"]
    pub HeapVirtualAffinity: USHORT,
    #[doc = "offset: 0xfaa (4010)"]
    pub LowFragHeapDataSlot: USHORT,
    #[doc = "offset: 0xfac (4012)"]
    pub CurrentTransactionHandle: ULONG,
    #[doc = "offset: 0xfb0 (4016)"]
    pub ActiveFrame: ULONG,
    #[doc = "offset: 0xfb4 (4020)"]
    pub FlsData: ULONG,
    #[doc = "offset: 0xfb8 (4024)"]
    pub PreferredLanguages: ULONG,
    #[doc = "offset: 0xfbc (4028)"]
    pub UserPrefLanguages: ULONG,
    #[doc = "offset: 0xfc0 (4032)"]
    pub MergedPrefLanguages: ULONG,
    #[doc = "offset: 0xfc4 (4036)"]
    pub MuiImpersonation: ULONG,
    pub __bindgen_anon_2: _TEB32__bindgen_ty_2,
    pub __bindgen_anon_3: _TEB32__bindgen_ty_3,
    #[doc = "offset: 0xfcc (4044)"]
    pub TxnScopeEnterCallback: ULONG,
    #[doc = "offset: 0xfd0 (4048)"]
    pub TxnScopeExitCallback: ULONG,
    #[doc = "offset: 0xfd4 (4052)"]
    pub TxnScopeContext: ULONG,
    #[doc = "offset: 0xfd8 (4056)"]
    pub LockCount: ULONG,
    #[doc = "offset: 0xfdc (4060)"]
    pub WowTebOffset: LONG,
    #[doc = "offset: 0xfe0 (4064)"]
    pub ResourceRetValue: ULONG,
    #[doc = "offset: 0xfe4 (4068)"]
    pub ReservedForWdf: ULONG,
    #[doc = "offset: 0xfe8 (4072)"]
    pub ReservedForCrt: ULONGLONG,
    #[doc = "offset: 0xff0 (4080)"]
    pub EffectiveContainerId: _GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_1 {
    #[doc = "offset: 0xf74 (3956)"]
    pub CurrentIdealProcessor: _PROCESSOR_NUMBER,
    #[doc = "offset: 0xf74 (3956)"]
    pub IdealProcessorValue: ULONG,
    pub __bindgen_anon_1: _TEB32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB32__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0xf74 (3956)"]
    pub ReservedPad0: UCHAR,
    #[doc = "offset: 0xf75 (3957)"]
    pub ReservedPad1: UCHAR,
    #[doc = "offset: 0xf76 (3958)"]
    pub ReservedPad2: UCHAR,
    #[doc = "offset: 0xf77 (3959)"]
    pub IdealProcessor: UCHAR,
}
impl Default for _TEB32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_2 {
    #[doc = "offset: 0xfc8 (4040)"]
    pub CrossTebFlags: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB32__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _TEB32__bindgen_ty_2 {
    #[inline]
    pub fn SpareCrossTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let SpareCrossTebBits: u16 = unsafe { ::std::mem::transmute(SpareCrossTebBits) };
            SpareCrossTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_3 {
    #[doc = "offset: 0xfca (4042)"]
    pub SameTebFlags: USHORT,
    pub __bindgen_anon_1: _TEB32__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB32__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB32__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SafeThunkCall(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SafeThunkCall(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InDebugPrint(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InDebugPrint(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasFiberData(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HasFiberData(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipThreadAttach(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SkipThreadAttach(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WerInShipAssertCode(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WerInShipAssertCode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RanProcessInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RanProcessInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClonedThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ClonedThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SuppressDebugMsg(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SuppressDebugMsg(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableUserStackWalk(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DisableUserStackWalk(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlExceptionAttached(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InitialThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InitialThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SessionAware(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SessionAware(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoadOwner(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoadOwner(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoaderWorker(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoaderWorker(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipLoaderInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SkipLoaderInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareSameTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SafeThunkCall: USHORT,
        InDebugPrint: USHORT,
        HasFiberData: USHORT,
        SkipThreadAttach: USHORT,
        WerInShipAssertCode: USHORT,
        RanProcessInit: USHORT,
        ClonedThread: USHORT,
        SuppressDebugMsg: USHORT,
        DisableUserStackWalk: USHORT,
        RtlExceptionAttached: USHORT,
        InitialThread: USHORT,
        SessionAware: USHORT,
        LoadOwner: USHORT,
        LoaderWorker: USHORT,
        SkipLoaderInit: USHORT,
        SpareSameTebBits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SafeThunkCall: u16 = unsafe { ::std::mem::transmute(SafeThunkCall) };
            SafeThunkCall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InDebugPrint: u16 = unsafe { ::std::mem::transmute(InDebugPrint) };
            InDebugPrint as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HasFiberData: u16 = unsafe { ::std::mem::transmute(HasFiberData) };
            HasFiberData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SkipThreadAttach: u16 = unsafe { ::std::mem::transmute(SkipThreadAttach) };
            SkipThreadAttach as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WerInShipAssertCode: u16 = unsafe { ::std::mem::transmute(WerInShipAssertCode) };
            WerInShipAssertCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RanProcessInit: u16 = unsafe { ::std::mem::transmute(RanProcessInit) };
            RanProcessInit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ClonedThread: u16 = unsafe { ::std::mem::transmute(ClonedThread) };
            ClonedThread as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SuppressDebugMsg: u16 = unsafe { ::std::mem::transmute(SuppressDebugMsg) };
            SuppressDebugMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DisableUserStackWalk: u16 = unsafe { ::std::mem::transmute(DisableUserStackWalk) };
            DisableUserStackWalk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RtlExceptionAttached: u16 = unsafe { ::std::mem::transmute(RtlExceptionAttached) };
            RtlExceptionAttached as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let InitialThread: u16 = unsafe { ::std::mem::transmute(InitialThread) };
            InitialThread as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let SessionAware: u16 = unsafe { ::std::mem::transmute(SessionAware) };
            SessionAware as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LoadOwner: u16 = unsafe { ::std::mem::transmute(LoadOwner) };
            LoadOwner as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LoaderWorker: u16 = unsafe { ::std::mem::transmute(LoaderWorker) };
            LoaderWorker as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let SkipLoaderInit: u16 = unsafe { ::std::mem::transmute(SkipLoaderInit) };
            SkipLoaderInit as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SpareSameTebBits: u16 = unsafe { ::std::mem::transmute(SpareSameTebBits) };
            SpareSameTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TEB32__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TEB32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILESYSTEM_DISK_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub FsBytesRead: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub FsBytesWritten: ULONGLONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SESSION_PERF_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub BufferMemoryPagedPool: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub BufferMemoryNonPagedPool: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub EventsLoggedCount: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub EventsLost: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub NumConsumers: LONG,
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PCW_PROCESSOR_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub IdleTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub AvailableTime: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub UserTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub KernelTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub Interrupts: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub DpcTime: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub InterruptTime: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub ClockInterrupts: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub DpcCount: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub DpcRate: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub C1Time: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub C2Time: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub C3Time: ULONGLONG,
    #[doc = "offset: 0x60 (96)"]
    pub C1Transitions: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub C2Transitions: ULONGLONG,
    #[doc = "offset: 0x70 (112)"]
    pub C3Transitions: ULONGLONG,
    #[doc = "offset: 0x78 (120)"]
    pub StallTime: ULONGLONG,
    #[doc = "offset: 0x80 (128)"]
    pub ParkingStatus: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub CurrentFrequency: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub PercentMaxFrequency: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub StateFlags: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub NominalThroughput: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub ActiveThroughput: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub ScaledThroughput: ULONGLONG,
    #[doc = "offset: 0xa0 (160)"]
    pub ScaledKernelThroughput: ULONGLONG,
    #[doc = "offset: 0xa8 (168)"]
    pub AverageIdleTime: ULONGLONG,
    #[doc = "offset: 0xb0 (176)"]
    pub IdleBreakEvents: ULONGLONG,
    #[doc = "offset: 0xb8 (184)"]
    pub PerformanceLimit: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub PerformanceLimitFlags: ULONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_MASK_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub CounterMask: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub InstanceMask: *mut _UNICODE_STRING,
    #[doc = "offset: 0xc (12)"]
    pub InstanceId: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub CollectMultiple: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub Buffer: *mut _PCW_BUFFER,
    #[doc = "offset: 0x18 (24)"]
    pub CancelEvent: *mut _KEVENT,
}
impl Default for _PCW_MASK_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_COUNTER_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub CounterMask: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub InstanceMask: *mut _UNICODE_STRING,
}
impl Default for _PCW_COUNTER_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCW_CALLBACK_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub AddCounter: _PCW_COUNTER_INFORMATION,
    #[doc = "offset: 0x0 (0)"]
    pub RemoveCounter: _PCW_COUNTER_INFORMATION,
    #[doc = "offset: 0x0 (0)"]
    pub EnumerateInstances: _PCW_MASK_INFORMATION,
    #[doc = "offset: 0x0 (0)"]
    pub CollectData: _PCW_MASK_INFORMATION,
}
impl Default for _PCW_CALLBACK_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_REGISTRATION_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Name: *mut _UNICODE_STRING,
    #[doc = "offset: 0x8 (8)"]
    pub CounterCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Counters: *mut _PCW_COUNTER_DESCRIPTOR,
    pub Callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: _PCW_CALLBACK_TYPE,
            arg2: *mut _PCW_CALLBACK_INFORMATION,
            arg3: *mut VOID,
        ) -> LONG,
    >,
    #[doc = "offset: 0x14 (20)"]
    pub CallbackContext: *mut VOID,
}
impl Default for _PCW_REGISTRATION_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x340 (832) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSWITCH_CONTEXT_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub ullOsMaxVersionTested: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub ulTargetPlatform: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ullContextMinimum: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub guPlatform: _GUID,
    #[doc = "offset: 0x28 (40)"]
    pub guMinPlatform: _GUID,
    #[doc = "offset: 0x38 (56)"]
    pub ulContextSource: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub ulElementCount: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub guElements: [_GUID; 48usize],
}
impl Default for tagSWITCH_CONTEXT_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagSWITCH_CONTEXT_ATTRIBUTE {
    #[doc = "offset: 0x0 (0)"]
    pub ulContextUpdateCounter: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub fAllowContextUpdate: LONG,
    #[doc = "offset: 0xc (12)"]
    pub fEnableTrace: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub EtwHandle: ULONGLONG,
}
#[doc = "0x358 (856) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSWITCH_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Attribute: tagSWITCH_CONTEXT_ATTRIBUTE,
    #[doc = "offset: 0x18 (24)"]
    pub Data: tagSWITCH_CONTEXT_DATA,
}
impl Default for tagSWITCH_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLS_LSN {
    #[doc = "offset: 0x0 (0)"]
    pub offset: _CLS_LSN__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub ullOffset: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CLS_LSN__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub idxRecord: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub cidContainer: ULONG,
}
impl Default for _CLS_LSN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HVIEW_MAP_ENTRY {
    pub __bindgen_anon_1: _HVIEW_MAP_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Bcb: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub PinnedPages: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Size: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HVIEW_MAP_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ViewStart: *mut VOID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _HVIEW_MAP_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _HVIEW_MAP_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn IsPinned(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsPinned(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(IsPinned: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsPinned: u32 = unsafe { ::std::mem::transmute(IsPinned) };
            IsPinned as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _HVIEW_MAP_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x600 (1536) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HVIEW_MAP_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub Entries: [_HVIEW_MAP_ENTRY; 64usize],
}
impl Default for _HVIEW_MAP_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x200 (512) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HVIEW_MAP_DIRECTORY {
    #[doc = "offset: 0x0 (0)"]
    pub Tables: [*mut _HVIEW_MAP_TABLE; 128usize],
}
impl Default for _HVIEW_MAP_DIRECTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HVIEW_MAP_PIN_LOG_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ViewOffset: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Pinned: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub PinMask: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Thread: *mut _KTHREAD,
    #[doc = "offset: 0x14 (20)"]
    pub Stack: [*mut VOID; 6usize],
}
impl Default for _HVIEW_MAP_PIN_LOG_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x308 (776) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HVIEW_MAP_PIN_LOG {
    #[doc = "offset: 0x0 (0)"]
    pub Next: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Entries: [_HVIEW_MAP_PIN_LOG_ENTRY; 16usize],
}
impl Default for _HVIEW_MAP_PIN_LOG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x320 (800) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HVIEW_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub MappedLength: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x8 (8)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0xc (12)"]
    pub Directory: *mut _HVIEW_MAP_DIRECTORY,
    #[doc = "offset: 0x10 (16)"]
    pub PagesCharged: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PinLog: _HVIEW_MAP_PIN_LOG,
}
impl Default for _HVIEW_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1000 (4096) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HBASE_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Sequence1: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Sequence2: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TimeStamp: _LARGE_INTEGER,
    #[doc = "offset: 0x14 (20)"]
    pub Major: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Minor: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Type: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Format: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub RootCell: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Length: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Cluster: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub FileName: [UCHAR; 64usize],
    #[doc = "offset: 0x70 (112)"]
    pub RmId: _GUID,
    #[doc = "offset: 0x80 (128)"]
    pub LogId: _GUID,
    #[doc = "offset: 0x90 (144)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub TmId: _GUID,
    #[doc = "offset: 0xa4 (164)"]
    pub GuidSignature: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub LastReorganizeTime: ULONGLONG,
    #[doc = "offset: 0xb0 (176)"]
    pub Reserved1: [ULONG; 83usize],
    #[doc = "offset: 0x1fc (508)"]
    pub CheckSum: ULONG,
    #[doc = "offset: 0x200 (512)"]
    pub Reserved2: [ULONG; 882usize],
    #[doc = "offset: 0xfc8 (4040)"]
    pub ThawTmId: _GUID,
    #[doc = "offset: 0xfd8 (4056)"]
    pub ThawRmId: _GUID,
    #[doc = "offset: 0xfe8 (4072)"]
    pub ThawLogId: _GUID,
    #[doc = "offset: 0xff8 (4088)"]
    pub BootType: ULONG,
    #[doc = "offset: 0xffc (4092)"]
    pub BootRecover: ULONG,
}
impl Default for _HBASE_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x6f0 (1776) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HHIVE {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    pub GetCellRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _HHIVE,
            arg2: ULONG,
            arg3: *mut _HV_GET_CELL_CONTEXT,
        ) -> *mut _CELL_DATA,
    >,
    pub ReleaseCellRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _HHIVE, arg2: *mut _HV_GET_CELL_CONTEXT),
    >,
    #[doc = "offset: 0xc (12)"]
    pub Allocate: ::std::option::Option<
        unsafe extern "C" fn(arg1: ULONG, arg2: UCHAR, arg3: ULONG) -> *mut VOID,
    >,
    #[doc = "offset: 0x10 (16)"]
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG)>,
    pub FileWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _HHIVE,
            arg2: ULONG,
            arg3: *mut CMP_OFFSET_ARRAY,
            arg4: ULONG,
            arg5: *mut ULONG,
            arg6: ULONG,
        ) -> UCHAR,
    >,
    pub FileRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _HHIVE,
            arg2: ULONG,
            arg3: *mut ULONG,
            arg4: *mut VOID,
            arg5: ULONG,
        ) -> UCHAR,
    >,
    #[doc = "offset: 0x1c (28)"]
    pub HiveLoadFailure: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub BaseBlock: *mut _HBASE_BLOCK,
    #[doc = "offset: 0x24 (36)"]
    pub DirtyVector: _RTL_BITMAP,
    #[doc = "offset: 0x2c (44)"]
    pub DirtyCount: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub DirtyAlloc: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub UnreconciledVector: _RTL_BITMAP,
    #[doc = "offset: 0x3c (60)"]
    pub UnreconciledCount: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub BaseBlockAlloc: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub Cluster: ULONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x49 (73)"]
    pub DirtyFlag: UCHAR,
    #[doc = "offset: 0x4c (76)"]
    pub HvBinHeadersUse: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub HvFreeCellsUse: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub HvUsedCellsUse: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub CmUsedCellsUse: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub HiveFlags: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub CurrentLog: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub CurrentLogSequence: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub CurrentLogMinimumSequence: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub CurrentLogOffset: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub MinimumLogSequence: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub LogFileSizeCap: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub LogDataPresent: [UCHAR; 2usize],
    #[doc = "offset: 0x7a (122)"]
    pub PrimaryFileValid: UCHAR,
    #[doc = "offset: 0x7b (123)"]
    pub BaseBlockDirty: UCHAR,
    #[doc = "offset: 0x80 (128)"]
    pub LastLogSwapTime: _LARGE_INTEGER,
    pub __bindgen_anon_1: _HHIVE__bindgen_ty_1,
    #[doc = "offset: 0x8a (138)"]
    pub LogEntriesRecovered: [UCHAR; 2usize],
    #[doc = "offset: 0x8c (140)"]
    pub RefreshCount: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub StorageTypeCount: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub Version: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub ViewMap: _HVIEW_MAP,
    #[doc = "offset: 0x3b8 (952)"]
    pub Storage: [_DUAL; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HHIVE__bindgen_ty_1 {
    pub __bindgen_anon_1: _HHIVE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x88 (136)"]
    pub RecoveryInformation: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HHIVE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _HHIVE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FirstLogFile(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FirstLogFile(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn SecondLogFile(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_SecondLogFile(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderRecovered(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HeaderRecovered(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LegacyRecoveryIndicated(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LegacyRecoveryIndicated(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RecoveryInformationReserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_RecoveryInformationReserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FirstLogFile: USHORT,
        SecondLogFile: USHORT,
        HeaderRecovered: USHORT,
        LegacyRecoveryIndicated: USHORT,
        RecoveryInformationReserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let FirstLogFile: u16 = unsafe { ::std::mem::transmute(FirstLogFile) };
            FirstLogFile as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let SecondLogFile: u16 = unsafe { ::std::mem::transmute(SecondLogFile) };
            SecondLogFile as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HeaderRecovered: u16 = unsafe { ::std::mem::transmute(HeaderRecovered) };
            HeaderRecovered as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LegacyRecoveryIndicated: u16 =
                unsafe { ::std::mem::transmute(LegacyRecoveryIndicated) };
            LegacyRecoveryIndicated as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let RecoveryInformationReserved: u16 =
                unsafe { ::std::mem::transmute(RecoveryInformationReserved) };
            RecoveryInformationReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _HHIVE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HHIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _HHIVE {
    #[inline]
    pub fn Flat(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Flat(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemCacheBacked(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SystemCacheBacked(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flat: UCHAR,
        ReadOnly: UCHAR,
        SystemCacheBacked: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Flat: u8 = unsafe { ::std::mem::transmute(Flat) };
            Flat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadOnly: u8 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SystemCacheBacked: u8 = unsafe { ::std::mem::transmute(SystemCacheBacked) };
            SystemCacheBacked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0xf20 (3872) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMHIVE {
    #[doc = "offset: 0x0 (0)"]
    pub Hive: _HHIVE,
    #[doc = "offset: 0x6f0 (1776)"]
    pub FileHandles: [*mut VOID; 6usize],
    #[doc = "offset: 0x708 (1800)"]
    pub NotifyList: _LIST_ENTRY,
    #[doc = "offset: 0x710 (1808)"]
    pub HiveList: _LIST_ENTRY,
    #[doc = "offset: 0x718 (1816)"]
    pub PreloadedHiveList: _LIST_ENTRY,
    #[doc = "offset: 0x720 (1824)"]
    pub FailedUnloadList: _LIST_ENTRY,
    #[doc = "offset: 0x728 (1832)"]
    pub HiveRundown: _EX_RUNDOWN_REF,
    #[doc = "offset: 0x72c (1836)"]
    pub ParseCacheEntries: _LIST_ENTRY,
    #[doc = "offset: 0x734 (1844)"]
    pub KcbCacheTable: *mut _CM_KEY_HASH_TABLE_ENTRY,
    #[doc = "offset: 0x738 (1848)"]
    pub KcbCacheTableSize: ULONG,
    #[doc = "offset: 0x73c (1852)"]
    pub DeletedKcbTable: *mut _CM_KEY_HASH_TABLE_ENTRY,
    #[doc = "offset: 0x740 (1856)"]
    pub DeletedKcbTableSize: ULONG,
    #[doc = "offset: 0x744 (1860)"]
    pub Identity: ULONG,
    #[doc = "offset: 0x748 (1864)"]
    pub HiveLock: *mut _FAST_MUTEX,
    #[doc = "offset: 0x74c (1868)"]
    pub WriterLock: *mut _FAST_MUTEX,
    #[doc = "offset: 0x750 (1872)"]
    pub FlusherLock: *mut _ERESOURCE,
    #[doc = "offset: 0x754 (1876)"]
    pub FlushDirtyVector: _RTL_BITMAP,
    #[doc = "offset: 0x75c (1884)"]
    pub FlushDirtyVectorSize: ULONG,
    #[doc = "offset: 0x760 (1888)"]
    pub FlushLogEntry: *mut UCHAR,
    #[doc = "offset: 0x764 (1892)"]
    pub FlushLogEntrySize: ULONG,
    #[doc = "offset: 0x768 (1896)"]
    pub FlushHiveTruncated: ULONG,
    #[doc = "offset: 0x76c (1900)"]
    pub FlushBaseBlockDirty: UCHAR,
    #[doc = "offset: 0x770 (1904)"]
    pub CapturedUnreconciledVector: _RTL_BITMAP,
    #[doc = "offset: 0x778 (1912)"]
    pub CapturedUnreconciledVectorSize: ULONG,
    #[doc = "offset: 0x77c (1916)"]
    pub UnreconciledOffsetArray: *mut CMP_OFFSET_ARRAY,
    #[doc = "offset: 0x780 (1920)"]
    pub UnreconciledOffsetArrayCount: ULONG,
    #[doc = "offset: 0x784 (1924)"]
    pub UnreconciledBaseBlock: *mut _HBASE_BLOCK,
    #[doc = "offset: 0x788 (1928)"]
    pub SecurityLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x78c (1932)"]
    pub UseCount: ULONG,
    #[doc = "offset: 0x790 (1936)"]
    pub LastShrinkHiveSize: ULONG,
    #[doc = "offset: 0x798 (1944)"]
    pub ActualFileSize: _LARGE_INTEGER,
    #[doc = "offset: 0x7a0 (1952)"]
    pub LogFileSizes: [_LARGE_INTEGER; 2usize],
    #[doc = "offset: 0x7b0 (1968)"]
    pub FileFullPath: _UNICODE_STRING,
    #[doc = "offset: 0x7b8 (1976)"]
    pub FileUserName: _UNICODE_STRING,
    #[doc = "offset: 0x7c0 (1984)"]
    pub HiveRootPath: _UNICODE_STRING,
    #[doc = "offset: 0x7c8 (1992)"]
    pub SecurityCount: ULONG,
    #[doc = "offset: 0x7cc (1996)"]
    pub SecurityCacheSize: ULONG,
    #[doc = "offset: 0x7d0 (2000)"]
    pub SecurityHitHint: LONG,
    #[doc = "offset: 0x7d4 (2004)"]
    pub SecurityCache: *mut _CM_KEY_SECURITY_CACHE_ENTRY,
    #[doc = "offset: 0x7d8 (2008)"]
    pub SecurityHash: [_LIST_ENTRY; 64usize],
    #[doc = "offset: 0x9d8 (2520)"]
    pub UnloadEventCount: ULONG,
    #[doc = "offset: 0x9dc (2524)"]
    pub UnloadEventArray: *mut *mut _KEVENT,
    #[doc = "offset: 0x9e0 (2528)"]
    pub RootKcb: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x9e4 (2532)"]
    pub Frozen: UCHAR,
    #[doc = "offset: 0x9e8 (2536)"]
    pub UnloadWorkItem: *mut _CM_WORKITEM,
    #[doc = "offset: 0x9ec (2540)"]
    pub UnloadWorkItemHolder: _CM_WORKITEM,
    #[doc = "offset: 0xa00 (2560)"]
    pub GrowOnlyMode: UCHAR,
    #[doc = "offset: 0xa04 (2564)"]
    pub GrowOffset: ULONG,
    #[doc = "offset: 0xa08 (2568)"]
    pub KcbConvertListHead: _LIST_ENTRY,
    #[doc = "offset: 0xa10 (2576)"]
    pub CellRemapArray: *mut _CM_CELL_REMAP_BLOCK,
    #[doc = "offset: 0xa14 (2580)"]
    pub DirtyVectorLog: _CM_DIRTY_VECTOR_LOG,
    #[doc = "offset: 0xc9c (3228)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xca0 (3232)"]
    pub TrustClassEntry: _LIST_ENTRY,
    #[doc = "offset: 0xca8 (3240)"]
    pub DirtyTime: ULONGLONG,
    #[doc = "offset: 0xcb0 (3248)"]
    pub UnreconciledTime: ULONGLONG,
    #[doc = "offset: 0xcb8 (3256)"]
    pub CmRm: *mut _CM_RM,
    #[doc = "offset: 0xcbc (3260)"]
    pub CmRmInitFailPoint: ULONG,
    #[doc = "offset: 0xcc0 (3264)"]
    pub CmRmInitFailStatus: LONG,
    #[doc = "offset: 0xcc4 (3268)"]
    pub CreatorOwner: *mut _KTHREAD,
    #[doc = "offset: 0xcc8 (3272)"]
    pub RundownThread: *mut _KTHREAD,
    #[doc = "offset: 0xcd0 (3280)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = "offset: 0xcd8 (3288)"]
    pub FlushQueue: _HIVE_WRITE_WAIT_QUEUE,
    #[doc = "offset: 0xce4 (3300)"]
    pub ReconcileQueue: _HIVE_WRITE_WAIT_QUEUE,
    pub __bindgen_anon_1: _CMHIVE__bindgen_ty_1,
    #[doc = "offset: 0xcf4 (3316)"]
    pub PrimaryFileSizeBeforeLastFlush: ULONG,
    #[doc = "offset: 0xcf8 (3320)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0xcfc (3324)"]
    pub UnloadHistoryIndex: LONG,
    #[doc = "offset: 0xd00 (3328)"]
    pub UnloadHistory: [ULONG; 128usize],
    #[doc = "offset: 0xf00 (3840)"]
    pub BootStart: ULONG,
    #[doc = "offset: 0xf04 (3844)"]
    pub UnaccessedStart: ULONG,
    #[doc = "offset: 0xf08 (3848)"]
    pub UnaccessedEnd: ULONG,
    #[doc = "offset: 0xf0c (3852)"]
    pub LoadedKeyCount: ULONG,
    #[doc = "offset: 0xf10 (3856)"]
    pub HandleClosePending: ULONG,
    #[doc = "offset: 0xf14 (3860)"]
    pub HandleClosePendingEvent: _EX_PUSH_LOCK,
    #[doc = "offset: 0xf18 (3864)"]
    pub FinalFlushSucceeded: UCHAR,
    #[doc = "offset: 0xf19 (3865)"]
    pub FailedUnload: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMHIVE__bindgen_ty_1 {
    #[doc = "offset: 0xcf0 (3312)"]
    pub FlushFlags: ULONG,
    pub __bindgen_anon_1: _CMHIVE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CMHIVE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _CMHIVE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FlushActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlushActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReconcileActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReconcileActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PrimaryFilePurged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrimaryFilePurged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DiskFileBad(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DiskFileBad(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FlushActive: ULONG,
        ReconcileActive: ULONG,
        PrimaryFilePurged: ULONG,
        DiskFileBad: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FlushActive: u32 = unsafe { ::std::mem::transmute(FlushActive) };
            FlushActive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReconcileActive: u32 = unsafe { ::std::mem::transmute(ReconcileActive) };
            ReconcileActive as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PrimaryFilePurged: u32 = unsafe { ::std::mem::transmute(PrimaryFilePurged) };
            PrimaryFilePurged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DiskFileBad: u32 = unsafe { ::std::mem::transmute(DiskFileBad) };
            DiskFileBad as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CMHIVE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CMHIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HIVE_LIST_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub FileName: *mut WCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub BaseName: *mut WCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub RegRootName: *mut WCHAR,
    #[doc = "offset: 0xc (12)"]
    pub CmHive: *mut _CMHIVE,
    #[doc = "offset: 0x10 (16)"]
    pub HHiveFlags: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub CmHiveFlags: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CmKcbCacheSize: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub CmHive2: *mut _CMHIVE,
    #[doc = "offset: 0x20 (32)"]
    pub HiveMounted: UCHAR,
    #[doc = "offset: 0x21 (33)"]
    pub ThreadFinished: UCHAR,
    #[doc = "offset: 0x22 (34)"]
    pub ThreadStarted: UCHAR,
    #[doc = "offset: 0x23 (35)"]
    pub Allocate: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub WinPERequired: UCHAR,
    #[doc = "offset: 0x28 (40)"]
    pub StartEvent: _KEVENT,
    #[doc = "offset: 0x38 (56)"]
    pub FinishedEvent: _KEVENT,
    #[doc = "offset: 0x48 (72)"]
    pub MountLock: _KEVENT,
    #[doc = "offset: 0x58 (88)"]
    pub FilePath: _UNICODE_STRING,
}
impl Default for _HIVE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_RM {
    #[doc = "offset: 0x0 (0)"]
    pub RmListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub TransactionListHead: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub TmHandle: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub Tm: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub RmHandle: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub KtmRm: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub RefCount: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ContainerNum: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub ContainerSize: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub CmHive: *mut _CMHIVE,
    #[doc = "offset: 0x34 (52)"]
    pub LogFileObject: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub MarshallingContext: *mut VOID,
    #[doc = "offset: 0x3c (60)"]
    pub RmFlags: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub LogStartStatus1: LONG,
    #[doc = "offset: 0x44 (68)"]
    pub LogStartStatus2: LONG,
    #[doc = "offset: 0x48 (72)"]
    pub BaseLsn: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub RmLock: *mut _ERESOURCE,
}
impl Default for _CM_RM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x70 (112) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_TRANS {
    #[doc = "offset: 0x0 (0)"]
    pub TransactionListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub KCBUoWListHead: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub LazyCommitListEntry: _LIST_ENTRY,
    pub __bindgen_anon_1: _CM_TRANS__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub Trans: _CM_TRANS_PTR,
    #[doc = "offset: 0x20 (32)"]
    pub CmRm: *mut _CM_RM,
    #[doc = "offset: 0x24 (36)"]
    pub KtmEnlistmentObject: *mut _KENLISTMENT,
    #[doc = "offset: 0x28 (40)"]
    pub KtmEnlistmentHandle: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub KtmUow: _GUID,
    #[doc = "offset: 0x40 (64)"]
    pub StartLsn: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub HiveCount: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub HiveArray: [*mut _CMHIVE; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_TRANS__bindgen_ty_1 {
    pub __bindgen_anon_1: _CM_TRANS__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub TransState: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_TRANS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _CM_TRANS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Prepared(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Prepared(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Aborted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Aborted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Committed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Committed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Initializing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Initializing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Invalid(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Invalid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UseReservation(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UseReservation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TmCallbacksActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TmCallbacksActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LightWeight(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LightWeight(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Freed1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Freed1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Freed2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Freed2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Freed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Freed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Prepared: ULONG,
        Aborted: ULONG,
        Committed: ULONG,
        Initializing: ULONG,
        Invalid: ULONG,
        UseReservation: ULONG,
        TmCallbacksActive: ULONG,
        LightWeight: ULONG,
        Freed1: ULONG,
        Freed2: ULONG,
        Spare1: ULONG,
        Freed: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Prepared: u32 = unsafe { ::std::mem::transmute(Prepared) };
            Prepared as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Aborted: u32 = unsafe { ::std::mem::transmute(Aborted) };
            Aborted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Committed: u32 = unsafe { ::std::mem::transmute(Committed) };
            Committed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Initializing: u32 = unsafe { ::std::mem::transmute(Initializing) };
            Initializing as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Invalid: u32 = unsafe { ::std::mem::transmute(Invalid) };
            Invalid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UseReservation: u32 = unsafe { ::std::mem::transmute(UseReservation) };
            UseReservation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let TmCallbacksActive: u32 = unsafe { ::std::mem::transmute(TmCallbacksActive) };
            TmCallbacksActive as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LightWeight: u32 = unsafe { ::std::mem::transmute(LightWeight) };
            LightWeight as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Freed1: u32 = unsafe { ::std::mem::transmute(Freed1) };
            Freed1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Freed2: u32 = unsafe { ::std::mem::transmute(Freed2) };
            Freed2 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let Spare1: u32 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Freed: u32 = unsafe { ::std::mem::transmute(Freed) };
            Freed as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CM_TRANS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_TRANS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KCB_UOW {
    #[doc = "offset: 0x0 (0)"]
    pub TransactionListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub KCBLock: *mut _CM_INTENT_LOCK,
    #[doc = "offset: 0xc (12)"]
    pub KeyLock: *mut _CM_INTENT_LOCK,
    #[doc = "offset: 0x10 (16)"]
    pub KCBListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub KeyControlBlock: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x1c (28)"]
    pub Transaction: *mut _CM_TRANS,
    #[doc = "offset: 0x20 (32)"]
    pub UoWState: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ActionType: UoWActionType,
    #[doc = "offset: 0x28 (40)"]
    pub StorageType: HSTORAGE_TYPE,
    #[doc = "offset: 0x2c (44)"]
    pub ParentUoW: *mut _CM_KCB_UOW,
    pub __bindgen_anon_1: _CM_KCB_UOW__bindgen_ty_1,
    pub __bindgen_anon_2: _CM_KCB_UOW__bindgen_ty_2,
    pub __bindgen_anon_3: _CM_KCB_UOW__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KCB_UOW__bindgen_ty_1 {
    #[doc = "offset: 0x30 (48)"]
    pub ChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x30 (48)"]
    pub VolatileKeyCell: ULONG,
    pub __bindgen_anon_1: _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x30 (48)"]
    pub UserFlags: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub LastWriteTime: _LARGE_INTEGER,
    pub __bindgen_anon_2: _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x30 (48)"]
    pub OldValueCell: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub NewValueCell: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x30 (48)"]
    pub TxCachedSecurity: *mut _CM_KEY_SECURITY_CACHE,
    #[doc = "offset: 0x34 (52)"]
    pub TxSecurityCell: ULONG,
}
impl Default for _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x30 (48)"]
    pub OldChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x34 (52)"]
    pub NewChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
}
impl Default for _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x30 (48)"]
    pub OtherChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x34 (52)"]
    pub ThisVolatileKeyCell: ULONG,
}
impl Default for _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KCB_UOW__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KCB_UOW__bindgen_ty_2 {
    #[doc = "offset: 0x38 (56)"]
    pub PrepareDataPointer: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub SecurityData: *mut _CM_UOW_SET_SD_DATA,
    #[doc = "offset: 0x38 (56)"]
    pub ModifyKeysData: *mut _CM_UOW_KEY_STATE_MODIFICATION,
    #[doc = "offset: 0x38 (56)"]
    pub SetValueData: *mut _CM_UOW_SET_VALUE_LIST_DATA,
}
impl Default for _CM_KCB_UOW__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KCB_UOW__bindgen_ty_3 {
    #[doc = "offset: 0x3c (60)"]
    pub ValueData: *mut _CM_UOW_SET_VALUE_KEY_DATA,
    #[doc = "offset: 0x3c (60)"]
    pub DiscardReplaceContext: *mut _CMP_DISCARD_AND_REPLACE_KCB_CONTEXT,
}
impl Default for _CM_KCB_UOW__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KCB_UOW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KEY_HASH {
    #[doc = "offset: 0x0 (0)"]
    pub ConvKey: _CM_PATH_HASH,
    #[doc = "offset: 0x4 (4)"]
    pub NextHash: *mut _CM_KEY_HASH,
    #[doc = "offset: 0x8 (8)"]
    pub KeyHive: *mut _HHIVE,
    #[doc = "offset: 0xc (12)"]
    pub KeyCell: ULONG,
}
impl Default for _CM_KEY_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb0 (176) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KEY_CONTROL_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub RefCount: ULONG,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: _CM_KEY_CONTROL_BLOCK__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub KcbPushlock: _EX_PUSH_LOCK,
    pub __bindgen_anon_2: _CM_KEY_CONTROL_BLOCK__bindgen_ty_2,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x21 (33)"]
    pub LayerSemantics: UCHAR,
    #[doc = "offset: 0x22 (34)"]
    pub LayerHeight: SHORT,
    #[doc = "offset: 0x24 (36)"]
    pub ParentKcb: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = "offset: 0x28 (40)"]
    pub NameBlock: *mut _CM_NAME_CONTROL_BLOCK,
    #[doc = "offset: 0x2c (44)"]
    pub CachedSecurity: *mut _CM_KEY_SECURITY_CACHE,
    #[doc = "offset: 0x30 (48)"]
    pub ValueCache: _CACHED_CHILD_LIST,
    pub __bindgen_anon_3: _CM_KEY_CONTROL_BLOCK__bindgen_ty_3,
    pub __bindgen_anon_4: _CM_KEY_CONTROL_BLOCK__bindgen_ty_4,
    #[doc = "offset: 0x44 (68)"]
    pub KeyBodyArray: [*mut _CM_KEY_BODY; 4usize],
    #[doc = "offset: 0x58 (88)"]
    pub KcbLastWriteTime: _LARGE_INTEGER,
    #[doc = "offset: 0x60 (96)"]
    pub KcbMaxNameLen: USHORT,
    #[doc = "offset: 0x62 (98)"]
    pub KcbMaxValueNameLen: USHORT,
    #[doc = "offset: 0x64 (100)"]
    pub KcbMaxValueDataLen: ULONG,
    pub _bitfield_align_3: [u16; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x6c (108)"]
    pub LayerInfo: *mut _CM_KCB_LAYER_INFO,
    #[doc = "offset: 0x70 (112)"]
    pub KCBUoWListHead: _LIST_ENTRY,
    pub __bindgen_anon_5: _CM_KEY_CONTROL_BLOCK__bindgen_ty_5,
    #[doc = "offset: 0x80 (128)"]
    pub TransKCBOwner: *mut _CM_TRANS,
    #[doc = "offset: 0x84 (132)"]
    pub KCBLock: _CM_INTENT_LOCK,
    #[doc = "offset: 0x8c (140)"]
    pub KeyLock: _CM_INTENT_LOCK,
    #[doc = "offset: 0x94 (148)"]
    pub TransValueCache: _CHILD_LIST,
    #[doc = "offset: 0x9c (156)"]
    pub TransValueListOwner: *mut _CM_TRANS,
    pub __bindgen_anon_6: _CM_KEY_CONTROL_BLOCK__bindgen_ty_6,
    #[doc = "offset: 0xa8 (168)"]
    pub SequenceNumber: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub KeyHash: _CM_KEY_HASH,
    pub __bindgen_anon_1: _CM_KEY_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KEY_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub ConvKey: _CM_PATH_HASH,
    #[doc = "offset: 0xc (12)"]
    pub NextHash: *mut _CM_KEY_HASH,
    #[doc = "offset: 0x10 (16)"]
    pub KeyHive: *mut _HHIVE,
    #[doc = "offset: 0x14 (20)"]
    pub KeyCell: ULONG,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_2 {
    #[doc = "offset: 0x1c (28)"]
    pub Owner: *mut _KTHREAD,
    #[doc = "offset: 0x1c (28)"]
    pub SharedCount: LONG,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_3 {
    #[doc = "offset: 0x38 (56)"]
    pub IndexHint: *mut _CM_INDEX_HINT_BLOCK,
    #[doc = "offset: 0x38 (56)"]
    pub HashKey: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub SubKeyCount: ULONG,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_4 {
    #[doc = "offset: 0x3c (60)"]
    pub KeyBodyListHead: _LIST_ENTRY,
    #[doc = "offset: 0x3c (60)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_5 {
    #[doc = "offset: 0x78 (120)"]
    pub DelayQueueEntry: _LIST_ENTRY,
    #[doc = "offset: 0x78 (120)"]
    pub Stolen: *mut UCHAR,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_6 {
    #[doc = "offset: 0xa0 (160)"]
    pub FullKCBName: *mut _UNICODE_STRING,
    pub __bindgen_anon_1: _CM_KEY_CONTROL_BLOCK__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_KEY_CONTROL_BLOCK__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _CM_KEY_CONTROL_BLOCK__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn FullKCBNameStale(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FullKCBNameStale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FullKCBNameStale: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FullKCBNameStale: u32 = unsafe { ::std::mem::transmute(FullKCBNameStale) };
            FullKCBNameStale as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KEY_CONTROL_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_KEY_CONTROL_BLOCK {
    #[inline]
    pub fn ExtFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ExtFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn PrivateAlloc(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrivateAlloc(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Discarded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Discarded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HiveUnloaded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HiveUnloaded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Decommissioned(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Decommissioned(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareExtFlag(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SpareExtFlag(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TotalLevels(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_TotalLevels(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExtFlags: ULONG,
        PrivateAlloc: ULONG,
        Discarded: ULONG,
        HiveUnloaded: ULONG,
        Decommissioned: ULONG,
        SpareExtFlag: ULONG,
        TotalLevels: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ExtFlags: u32 = unsafe { ::std::mem::transmute(ExtFlags) };
            ExtFlags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PrivateAlloc: u32 = unsafe { ::std::mem::transmute(PrivateAlloc) };
            PrivateAlloc as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Discarded: u32 = unsafe { ::std::mem::transmute(Discarded) };
            Discarded as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let HiveUnloaded: u32 = unsafe { ::std::mem::transmute(HiveUnloaded) };
            HiveUnloaded as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Decommissioned: u32 = unsafe { ::std::mem::transmute(Decommissioned) };
            Decommissioned as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SpareExtFlag: u32 = unsafe { ::std::mem::transmute(SpareExtFlag) };
            SpareExtFlag as u64
        });
        __bindgen_bitfield_unit.set(21usize, 10u8, {
            let TotalLevels: u32 = unsafe { ::std::mem::transmute(TotalLevels) };
            TotalLevels as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn DelayedDeref(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DelayedDeref(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DelayedClose(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DelayedClose(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Parking(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Parking(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        DelayedDeref: UCHAR,
        DelayedClose: UCHAR,
        Parking: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DelayedDeref: u8 = unsafe { ::std::mem::transmute(DelayedDeref) };
            DelayedDeref as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DelayedClose: u8 = unsafe { ::std::mem::transmute(DelayedClose) };
            DelayedClose as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Parking: u8 = unsafe { ::std::mem::transmute(Parking) };
            Parking as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn KcbUserFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_KcbUserFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn KcbVirtControlFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_KcbVirtControlFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn KcbDebug(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_KcbDebug(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Flags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        KcbUserFlags: ULONG,
        KcbVirtControlFlags: ULONG,
        KcbDebug: ULONG,
        Flags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let KcbUserFlags: u32 = unsafe { ::std::mem::transmute(KcbUserFlags) };
            KcbUserFlags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let KcbVirtControlFlags: u32 = unsafe { ::std::mem::transmute(KcbVirtControlFlags) };
            KcbVirtControlFlags as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let KcbDebug: u32 = unsafe { ::std::mem::transmute(KcbDebug) };
            KcbDebug as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Flags: u32 = unsafe { ::std::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KEY_REFERENCE {
    #[doc = "offset: 0x0 (0)"]
    pub KeyCell: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub KeyHive: *mut _HHIVE,
}
impl Default for _CM_KEY_REFERENCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KEY_NODE {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = "offset: 0xc (12)"]
    pub AccessBits: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0xe (14)"]
    pub Spare2: USHORT,
    #[doc = "offset: 0x10 (16)"]
    pub Parent: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub SubKeyCounts: [ULONG; 2usize],
    pub __bindgen_anon_1: _CM_KEY_NODE__bindgen_ty_1,
    #[doc = "offset: 0x2c (44)"]
    pub Security: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub Class: ULONG,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x38 (56)"]
    pub MaxClassLen: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub MaxValueNameLen: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub MaxValueDataLen: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub WorkVar: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub NameLength: USHORT,
    #[doc = "offset: 0x4a (74)"]
    pub ClassLength: USHORT,
    #[doc = "offset: 0x4c (76)"]
    pub Name: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_NODE__bindgen_ty_1 {
    pub __bindgen_anon_1: _CM_KEY_NODE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub ChildHiveReference: _CM_KEY_REFERENCE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_KEY_NODE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x1c (28)"]
    pub SubKeyLists: [ULONG; 2usize],
    #[doc = "offset: 0x24 (36)"]
    pub ValueList: _CHILD_LIST,
}
impl Default for _CM_KEY_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KEY_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_KEY_NODE {
    #[inline]
    pub fn LayerSemantics(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_LayerSemantics(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn InheritClass(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InheritClass(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LayerSemantics: UCHAR,
        Spare1: UCHAR,
        InheritClass: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let LayerSemantics: u8 = unsafe { ::std::mem::transmute(LayerSemantics) };
            LayerSemantics as u64
        });
        __bindgen_bitfield_unit.set(2usize, 5u8, {
            let Spare1: u8 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let InheritClass: u8 = unsafe { ::std::mem::transmute(InheritClass) };
            InheritClass as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn MaxNameLen(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_MaxNameLen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn UserFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_UserFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn VirtControlFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_VirtControlFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Debug(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Debug(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        MaxNameLen: ULONG,
        UserFlags: ULONG,
        VirtControlFlags: ULONG,
        Debug: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let MaxNameLen: u32 = unsafe { ::std::mem::transmute(MaxNameLen) };
            MaxNameLen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let UserFlags: u32 = unsafe { ::std::mem::transmute(UserFlags) };
            UserFlags as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let VirtControlFlags: u32 = unsafe { ::std::mem::transmute(VirtControlFlags) };
            VirtControlFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Debug: u32 = unsafe { ::std::mem::transmute(Debug) };
            Debug as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _u {
    #[doc = "offset: 0x0 (0)"]
    pub KeyNode: _CM_KEY_NODE,
    #[doc = "offset: 0x0 (0)"]
    pub KeyValue: _CM_KEY_VALUE,
    #[doc = "offset: 0x0 (0)"]
    pub KeySecurity: _CM_KEY_SECURITY,
    #[doc = "offset: 0x0 (0)"]
    pub KeyIndex: _CM_KEY_INDEX,
    #[doc = "offset: 0x0 (0)"]
    pub ValueData: _CM_BIG_DATA,
    #[doc = "offset: 0x0 (0)"]
    pub KeyList: [ULONG; 1usize],
    #[doc = "offset: 0x0 (0)"]
    pub KeyString: [WCHAR; 1usize],
}
impl Default for _u {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CELL_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub u: _u,
}
impl Default for _CELL_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x54 (84) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_CACHED_VALUE_INDEX {
    #[doc = "offset: 0x0 (0)"]
    pub CellIndex: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Data: _CM_CACHED_VALUE_INDEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_CACHED_VALUE_INDEX__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub CellData: _CELL_DATA,
    #[doc = "offset: 0x4 (4)"]
    pub List: [ULONG; 1usize],
}
impl Default for _CM_CACHED_VALUE_INDEX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_CACHED_VALUE_INDEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x11c (284) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE {
    #[doc = "offset: 0x0 (0)"]
    pub Hive: *mut _HHIVE,
    #[doc = "offset: 0x4 (4)"]
    pub Index: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub RecoverableIndex: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Locations: [_HIVE_LOAD_FAILURE__bindgen_ty_1; 8usize],
    #[doc = "offset: 0x68 (104)"]
    pub RecoverableLocations: [_HIVE_LOAD_FAILURE__bindgen_ty_2; 8usize],
    #[doc = "offset: 0xc8 (200)"]
    pub RegistryIO: _HIVE_LOAD_FAILURE__bindgen_ty_3,
    #[doc = "offset: 0xd4 (212)"]
    pub CheckRegistry2: _HIVE_LOAD_FAILURE__bindgen_ty_4,
    #[doc = "offset: 0xd8 (216)"]
    pub CheckKey: _HIVE_LOAD_FAILURE__bindgen_ty_5,
    #[doc = "offset: 0xe8 (232)"]
    pub CheckValueList: _HIVE_LOAD_FAILURE__bindgen_ty_6,
    #[doc = "offset: 0xf8 (248)"]
    pub CheckHive: _HIVE_LOAD_FAILURE__bindgen_ty_7,
    #[doc = "offset: 0x104 (260)"]
    pub CheckHive1: _HIVE_LOAD_FAILURE__bindgen_ty_8,
    #[doc = "offset: 0x110 (272)"]
    pub CheckBin: _HIVE_LOAD_FAILURE__bindgen_ty_9,
    #[doc = "offset: 0x118 (280)"]
    pub RecoverData: _HIVE_LOAD_FAILURE__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Failure: _CM_LOAD_FAILURE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Status: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub Point: ULONG,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub Failure: _CM_LOAD_FAILURE_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Status: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub Point: ULONG,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub Action: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Handle: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Status: LONG,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub CheckStack: *mut VOID,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub Cell: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub CellPoint: *mut _CELL_DATA,
    #[doc = "offset: 0x8 (8)"]
    pub RootPoint: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Index: ULONG,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub List: *mut _CELL_DATA,
    #[doc = "offset: 0x4 (4)"]
    pub Index: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Cell: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub CellPoint: *mut _CELL_DATA,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_7 {
    #[doc = "offset: 0x0 (0)"]
    pub Space: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MapPoint: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BinPoint: *mut _HBIN,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_8 {
    #[doc = "offset: 0x0 (0)"]
    pub Space: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MapPoint: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub BinPoint: *mut _HBIN,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_9 {
    #[doc = "offset: 0x0 (0)"]
    pub Bin: *mut _HBIN,
    #[doc = "offset: 0x4 (4)"]
    pub CellPoint: *mut _HCELL,
}
impl Default for _HIVE_LOAD_FAILURE__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HIVE_LOAD_FAILURE__bindgen_ty_10 {
    #[doc = "offset: 0x0 (0)"]
    pub FileOffset: ULONG,
}
impl Default for _HIVE_LOAD_FAILURE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMEXTEND_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub CommittedSize: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub ReferenceCount: ULONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAPPED_FILE_SEGMENT {
    #[doc = "offset: 0x0 (0)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = "offset: 0x4 (4)"]
    pub TotalNumberOfPtes: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SegmentFlags: _SEGMENT_FLAGS,
    #[doc = "offset: 0xc (12)"]
    pub NumberOfCommittedPages: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SizeOfSegment: ULONGLONG,
    pub __bindgen_anon_1: _MAPPED_FILE_SEGMENT__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub SegmentLock: _EX_PUSH_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MAPPED_FILE_SEGMENT__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub ExtendInfo: *mut _MMEXTEND_INFO,
    #[doc = "offset: 0x18 (24)"]
    pub BasedAddress: *mut VOID,
}
impl Default for _MAPPED_FILE_SEGMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MAPPED_FILE_SEGMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MI_PAGE_COMBINE_STATISTICS {
    #[doc = "offset: 0x0 (0)"]
    pub PagesScannedActive: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub PagesScannedStandby: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub PagesCombined: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CombineScanCount: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub CombinedBlocksInUse: LONG,
    #[doc = "offset: 0x20 (32)"]
    pub SumCombinedBlocksReferenceCount: LONG,
}
#[doc = "0xd8 (216) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_PAGE_COMBINING_SUPPORT {
    #[doc = "offset: 0x0 (0)"]
    pub Partition: *mut _MI_PARTITION,
    #[doc = "offset: 0x4 (4)"]
    pub ArbitraryPfnMapList: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub FreeCombinePoolItem: _MI_COMBINE_WORKITEM,
    #[doc = "offset: 0x20 (32)"]
    pub CombiningThreadCount: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub CombinePageFreeList: _LIST_ENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub CombineFreeListLock: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub CombinePageListHeads: [_MI_COMBINE_PAGE_LISTHEAD; 16usize],
    #[doc = "offset: 0xb0 (176)"]
    pub PageCombineStats: _MI_PAGE_COMBINE_STATISTICS,
}
impl Default for _MI_PAGE_COMBINING_SUPPORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_MODWRITE_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub PagesLoad: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub PagesAverage: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub AverageAvailablePages: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub PagesWritten: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub WritesIssued: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub IgnoredReservationsCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FreedReservationsCount: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub WriteBurstCount: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub IgnoreReservationsStartTime: ULONGLONG,
    #[doc = "offset:\n 0x28\n (40)"]
    pub ReservationClusterInfo: _MI_RESERVATION_CLUSTER_INFO,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x2e (46)"]
    pub Spare1: USHORT,
}
impl Default for _MI_MODWRITE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_MODWRITE_DATA {
    #[inline]
    pub fn IgnoreReservations(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IgnoreReservations(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IgnoreReservations: USHORT,
        Spare: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IgnoreReservations: u16 = unsafe { ::std::mem::transmute(IgnoreReservations) };
            IgnoreReservations as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let Spare: u16 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x34 (52) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPAGE_FILE_EXPANSION {
    #[doc = "offset: 0x0 (0)"]
    pub Segment: *mut _SEGMENT,
    #[doc = "offset: 0x4 (4)"]
    pub DereferenceList: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub Partition: *mut _MI_PARTITION,
    #[doc = "offset: 0x10 (16)"]
    pub RequestedExpansionSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ActualExpansion: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x28 (40)"]
    pub InProgress: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub u1: _MMPAGE_FILE_EXPANSION__bindgen_ty_1,
    #[doc = "offset: 0x30 (48)"]
    pub ActiveEntry: *mut *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPAGE_FILE_EXPANSION__bindgen_ty_1 {
    #[doc = "offset: 0x2c (44)"]
    pub LongFlags: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Flags: _MMPAGE_FILE_EXPANSION_FLAGS,
}
impl Default for _MMPAGE_FILE_EXPANSION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMPAGE_FILE_EXPANSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c8 (456) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION_MODWRITES {
    #[doc = "offset: 0x0 (0)"]
    pub AttemptForCantExtend: _MMPAGE_FILE_EXPANSION,
    #[doc = "offset: 0x34 (52)"]
    pub PageFileContract: _MMPAGE_FILE_EXPANSION,
    #[doc = "offset: 0x68 (104)"]
    pub NumberOfMappedMdls: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub NumberOfMappedMdlsInUse: LONG,
    #[doc = "offset: 0x70 (112)"]
    pub NumberOfMappedMdlsInUsePeak: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub MappedFileHeader: _MMMOD_WRITER_LISTHEAD,
    #[doc = "offset: 0x8c (140)"]
    pub NeedMappedMdl: UCHAR,
    #[doc = "offset: 0x8d (141)"]
    pub NeedPageFileMdl: UCHAR,
    #[doc = "offset: 0x8e (142)"]
    pub ModwriterActive: UCHAR,
    #[doc = "offset: 0x8f (143)"]
    pub TransitionInserted: UCHAR,
    #[doc = "offset: 0x90 (144)"]
    pub LastModifiedWriteError: LONG,
    #[doc = "offset: 0x94 (148)"]
    pub LastMappedWriteError: LONG,
    #[doc = "offset: 0x98 (152)"]
    pub MappedFileWriteSucceeded: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub MappedWriteBurstCount: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub LowPriorityModWritesOutstanding: ULONG,
    #[doc = "offset: 0xa4 (164)"]
    pub BoostModWriteIoPriorityEvent: _KEVENT,
    #[doc = "offset: 0xb4 (180)"]
    pub ModifiedWriterThreadPriority: LONG,
    #[doc = "offset: 0xb8 (184)"]
    pub ModifiedPagesLowPriorityGoal: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub ModifiedPageWriterEvent: _KEVENT,
    #[doc = "offset: 0xcc (204)"]
    pub ModifiedWriterExitedEvent: _KEVENT,
    #[doc = "offset: 0xdc (220)"]
    pub WriteAllPagefilePages: LONG,
    #[doc = "offset: 0xe0 (224)"]
    pub WriteAllMappedPages: LONG,
    #[doc = "offset: 0xe4 (228)"]
    pub MappedPageWriterEvent: _KEVENT,
    #[doc = "offset: 0xf8 (248)"]
    pub ModWriteData: _MI_MODWRITE_DATA,
    #[doc = "offset: 0x128 (296)"]
    pub RescanPageFilesEvent: _KEVENT,
    #[doc = "offset: 0x138 (312)"]
    pub PagingFileHeader: _MMMOD_WRITER_LISTHEAD,
    #[doc = "offset: 0x150 (336)"]
    pub ModifiedPageWriterThread: *mut _ETHREAD,
    #[doc = "offset: 0x154 (340)"]
    pub ModifiedPageWriterRundown: _EX_RUNDOWN_REF,
    #[doc = "offset: 0x158 (344)"]
    pub PagefileScanWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x168 (360)"]
    pub PagefileScanCount: ULONG,
    #[doc = "offset: 0x16c (364)"]
    pub ClusterWritesDisabled: [LONG; 2usize],
    #[doc = "offset: 0x174 (372)"]
    pub NotifyStoreMemoryConditions: _KEVENT,
    #[doc = "offset: 0x184 (388)"]
    pub DelayMappedWrite: UCHAR,
    #[doc = "offset: 0x188 (392)"]
    pub PagefileReservationsEnabled: ULONG,
    #[doc = "offset: 0x18c (396)"]
    pub PageFileCreationLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x190 (400)"]
    pub TrimPagefileWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x1a0 (416)"]
    pub LastTrimPagefileTime: ULONGLONG,
    #[doc = "offset: 0x1a8 (424)"]
    pub WsSwapPagefileContractWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x1b8 (440)"]
    pub WsSwapPageFileContractionInProgress: LONG,
    #[doc = "offset: 0x1bc (444)"]
    pub WorkingSetSwapLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x1c0 (448)"]
    pub WorkingSetInswapLock: LONG,
}
impl Default for _MI_PARTITION_MODWRITES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_FILTER_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Ptr: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Size: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Type: ULONG,
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TlgProvider_t {
    #[doc = "offset: 0x0 (0)"]
    pub LevelPlus1: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ProviderMetadataPtr: *const USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub KeywordAny: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub KeywordAll: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub RegHandle: ULONGLONG,
    pub EnableCallback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _GUID,
            arg2: ULONG,
            arg3: UCHAR,
            arg4: ULONGLONG,
            arg5: ULONGLONG,
            arg6: *mut _EVENT_FILTER_DESCRIPTOR,
            arg7: *mut VOID,
        ),
    >,
    #[doc = "offset: 0x24 (36)"]
    pub CallbackContext: *mut VOID,
    #[doc = "offset: 0x28 (40)"]
    pub AnnotationFunc:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
impl Default for _TlgProvider_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PERSISTENCE_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsULONGLONG: ULONGLONG,
}
impl Default for _WHEA_PERSISTENCE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_PERSISTENCE_INFO {
    #[inline]
    pub fn Signature(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Signature(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Length(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Length(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn Identifier(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Identifier(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Attributes(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Attributes(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DoNotLog(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DoNotLog(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Signature: ULONGLONG,
        Length: ULONGLONG,
        Identifier: ULONGLONG,
        Attributes: ULONGLONG,
        DoNotLog: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Signature: u64 = unsafe { ::std::mem::transmute(Signature) };
            Signature as u64
        });
        __bindgen_bitfield_unit.set(16usize, 24u8, {
            let Length: u64 = unsafe { ::std::mem::transmute(Length) };
            Length as u64
        });
        __bindgen_bitfield_unit.set(40usize, 16u8, {
            let Identifier: u64 = unsafe { ::std::mem::transmute(Identifier) };
            Identifier as u64
        });
        __bindgen_bitfield_unit.set(56usize, 2u8, {
            let Attributes: u64 = unsafe { ::std::mem::transmute(Attributes) };
            Attributes as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let DoNotLog: u64 = unsafe { ::std::mem::transmute(DoNotLog) };
            DoNotLog as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_TIMESTAMP {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub AsLARGE_INTEGER: _LARGE_INTEGER,
}
impl Default for _WHEA_TIMESTAMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_TIMESTAMP {
    #[inline]
    pub fn Seconds(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Seconds(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Minutes(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Minutes(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Hours(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Hours(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Precise(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Precise(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Day(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Day(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Month(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Month(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Year(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Year(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Century(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Century(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Seconds: ULONGLONG,
        Minutes: ULONGLONG,
        Hours: ULONGLONG,
        Precise: ULONGLONG,
        Reserved: ULONGLONG,
        Day: ULONGLONG,
        Month: ULONGLONG,
        Year: ULONGLONG,
        Century: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Seconds: u64 = unsafe { ::std::mem::transmute(Seconds) };
            Seconds as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Minutes: u64 = unsafe { ::std::mem::transmute(Minutes) };
            Minutes as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Hours: u64 = unsafe { ::std::mem::transmute(Hours) };
            Hours as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let Precise: u64 = unsafe { ::std::mem::transmute(Precise) };
            Precise as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let Day: u64 = unsafe { ::std::mem::transmute(Day) };
            Day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let Month: u64 = unsafe { ::std::mem::transmute(Month) };
            Month as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let Year: u64 = unsafe { ::std::mem::transmute(Year) };
            Year as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let Century: u64 = unsafe { ::std::mem::transmute(Century) };
            Century as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Revision: _WHEA_REVISION,
    #[doc = "offset: 0x6 (6)"]
    pub SignatureEnd: ULONG,
    #[doc = "offset: 0xa (10)"]
    pub SectionCount: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub Severity: _WHEA_ERROR_SEVERITY,
    #[doc = "offset: 0x10 (16)"]
    pub ValidBits: _WHEA_ERROR_RECORD_HEADER_VALIDBITS,
    #[doc = "offset: 0x14 (20)"]
    pub Length: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Timestamp: _WHEA_TIMESTAMP,
    #[doc = "offset: 0x20 (32)"]
    pub PlatformId: _GUID,
    #[doc = "offset: 0x30 (48)"]
    pub PartitionId: _GUID,
    #[doc = "offset: 0x40 (64)"]
    pub CreatorId: _GUID,
    #[doc = "offset: 0x50 (80)"]
    pub NotifyType: _GUID,
    #[doc = "offset: 0x60 (96)"]
    pub RecordId: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub Flags: _WHEA_ERROR_RECORD_HEADER_FLAGS,
    #[doc = "offset: 0x6c (108)"]
    pub PersistenceInfo: _WHEA_PERSISTENCE_INFO,
    #[doc = "offset: 0x74 (116)"]
    pub Reserved: [UCHAR; 12usize],
}
impl Default for _WHEA_ERROR_RECORD_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc8 (200) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _WHEA_ERROR_RECORD_HEADER,
    #[doc = "offset: 0x80 (128)"]
    pub SectionDescriptor: [_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR; 1usize],
}
impl Default for _WHEA_ERROR_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xe4 (228) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ERROR_RECORD_WRAPPER {
    #[doc = "offset: 0x0 (0)"]
    pub WorkEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Length: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ProcessorNumber: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Flags: _WHEAP_ERROR_RECORD_WRAPPER_FLAGS,
    #[doc = "offset: 0x14 (20)"]
    pub InUse: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub ErrorSource: *mut _WHEAP_ERROR_SOURCE,
    #[doc = "offset: 0x1c (28)"]
    pub ErrorRecord: _WHEA_ERROR_RECORD,
}
impl Default for _WHEAP_ERROR_RECORD_WRAPPER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x418 (1048) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ERROR_SOURCE {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub FailedAllocations: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub PlatformErrorSourceId: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorCount: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub RecordCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub RecordLength: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub PoolTag: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Type: _WHEA_ERROR_SOURCE_TYPE,
    #[doc = "offset: 0x24 (36)"]
    pub Records: *mut _WHEAP_ERROR_RECORD_WRAPPER,
    #[doc = "offset: 0x28 (40)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub SectionCount: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub SectionLength: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub TickCountAtLastError: _LARGE_INTEGER,
    #[doc = "offset: 0x40 (64)"]
    pub AccumulatedErrors: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub TotalErrors: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub Deferred: UCHAR,
    #[doc = "offset: 0x49 (73)"]
    pub Descriptor: _WHEA_ERROR_SOURCE_DESCRIPTOR,
}
impl Default for _WHEAP_ERROR_SOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_PACKET_V2 {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Version: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Length: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Flags: _WHEA_ERROR_PACKET_FLAGS,
    #[doc = "offset: 0x10 (16)"]
    pub ErrorType: _WHEA_ERROR_TYPE,
    #[doc = "offset: 0x14 (20)"]
    pub ErrorSeverity: _WHEA_ERROR_SEVERITY,
    #[doc = "offset: 0x18 (24)"]
    pub ErrorSourceId: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ErrorSourceType: _WHEA_ERROR_SOURCE_TYPE,
    #[doc = "offset: 0x20 (32)"]
    pub NotifyType: _GUID,
    #[doc = "offset: 0x30 (48)"]
    pub Context: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub DataFormat: _WHEA_ERROR_PACKET_DATA_FORMAT,
    #[doc = "offset: 0x3c (60)"]
    pub Reserved1: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub DataOffset: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub DataLength: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub PshedDataOffset: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub PshedDataLength: ULONG,
}
impl Default for _WHEA_ERROR_PACKET_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO {
    pub __bindgen_anon_1: _MM_PAGE_ACCESS_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: _MM_PAGE_ACCESS_INFO_FLAGS,
    #[doc = "offset: 0x0 (0)"]
    pub FileOffset: ULONGLONG,
    #[doc = "offset: 0x0 (0)"]
    pub VirtualAddress: *mut VOID,
    pub __bindgen_anon_1: _MM_PAGE_ACCESS_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x4 (4)"]
    pub PointerProtoPte: *mut VOID,
}
impl Default for _MM_PAGE_ACCESS_INFO__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MM_PAGE_ACCESS_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DontUse0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DontUse0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DontUse0: ULONG, Spare0: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let DontUse0: u32 = unsafe { ::std::mem::transmute(DontUse0) };
            DontUse0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Spare0: u32 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MM_PAGE_ACCESS_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_PAGE_ACCESS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_HEADER_EXTENDED_DATA_ITEM {
    #[doc = "offset: 0x0 (0)"]
    pub Reserved1: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub ExtType: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x6 (6)"]
    pub DataSize: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub DataPtr: ULONGLONG,
}
impl _EVENT_HEADER_EXTENDED_DATA_ITEM {
    #[inline]
    pub fn Linkage(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Linkage(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Linkage: USHORT,
        Reserved2: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Linkage: u16 = unsafe { ::std::mem::transmute(Linkage) };
            Linkage as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let Reserved2: u16 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Id: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Channel: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Level: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub Opcode: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub Task: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Keyword: ULONGLONG,
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub HeaderType: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub EventProperty: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub ThreadId: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ProcessId: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub TimeStamp: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub ProviderId: _GUID,
    #[doc = "offset: 0x28 (40)"]
    pub EventDescriptor: _EVENT_DESCRIPTOR,
    pub __bindgen_anon_1: _EVENT_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub ActivityId: _GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _EVENT_HEADER__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x38 (56)"]
    pub ProcessorTime: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x38 (56)"]
    pub KernelTime: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub UserTime: ULONG,
}
impl Default for _EVENT_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EVENT_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_RECORD {
    #[doc = "offset: 0x0 (0)"]
    pub EventHeader: _EVENT_HEADER,
    #[doc = "offset: 0x50 (80)"]
    pub BufferContext: _ETW_BUFFER_CONTEXT,
    #[doc = "offset: 0x54 (84)"]
    pub ExtendedDataCount: USHORT,
    #[doc = "offset: 0x56 (86)"]
    pub UserDataLength: USHORT,
    #[doc = "offset: 0x58 (88)"]
    pub ExtendedData: *mut _EVENT_HEADER_EXTENDED_DATA_ITEM,
    #[doc = "offset: 0x5c (92)"]
    pub UserData: *mut VOID,
    #[doc = "offset: 0x60 (96)"]
    pub UserContext: *mut VOID,
}
impl Default for _EVENT_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR {
    #[doc = "offset: 0x0 (0)"]
    pub Ptr: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Size: ULONG,
    pub __bindgen_anon_1: _EVENT_DATA_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub Reserved: ULONG,
    pub __bindgen_anon_1: _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub Type: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0xe (14)"]
    pub Reserved2: USHORT,
}
impl Default for _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EVENT_DATA_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_BUFFER_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub BufferSize: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SavedOffset: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentOffset: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub TimeStamp: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub SequenceNumber: LONGLONG,
    pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x28 (40)"]
    pub ClientContext: _ETW_BUFFER_CONTEXT,
    #[doc = "offset: 0x2c (44)"]
    pub State: _ETW_BUFFER_STATE,
    #[doc = "offset: 0x30 (48)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub BufferFlag: USHORT,
    #[doc = "offset: 0x36 (54)"]
    pub BufferType: USHORT,
    pub __bindgen_anon_2: _WMI_BUFFER_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub SlistEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x20 (32)"]
    pub NextBuffer: *mut _WMI_BUFFER_HEADER,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ClockType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_ClockType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Frequency(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Frequency(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClockType: ULONGLONG,
        Frequency: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ClockType: u64 = unsafe { ::std::mem::transmute(ClockType) };
            ClockType as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Frequency: u64 = unsafe { ::std::mem::transmute(Frequency) };
            Frequency as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_2 {
    #[doc = "offset: 0x38 (56)"]
    pub Padding1: [ULONG; 4usize],
    #[doc = "offset: 0x38 (56)"]
    pub ReferenceTime: _ETW_REF_CLOCK,
    #[doc = "offset: 0x38 (56)"]
    pub GlobalEntry: _LIST_ENTRY,
    pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x38 (56)"]
    pub Pointer0: *mut VOID,
    #[doc = "offset: 0x3c (60)"]
    pub Pointer1: *mut VOID,
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_BUFFER_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_FILTER_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Id: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub Reserved: [UCHAR; 5usize],
    #[doc = "offset: 0x8 (8)"]
    pub InstanceId: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Size: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub NextOffset: ULONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_FILTER_LEVEL_KW {
    #[doc = "offset: 0x0 (0)"]
    pub MatchAnyKeyword: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub MatchAllKeyword: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Level: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub FilterIn: UCHAR,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_FILTER_EVENT_NAME_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub FilterIn: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub Level: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub MatchAnyKeyword: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub MatchAllKeyword: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub NameTable: _RTL_HASH_TABLE,
}
impl Default for _ETW_FILTER_EVENT_NAME_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_ENABLE_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub IsEnabled: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Level: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub LoggerId: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub EnableProperty: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Reserved2: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MatchAnyKeyword: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub MatchAllKeyword: ULONGLONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_PERF_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Context: *mut VOID,
}
impl Default for _PO_FX_PERF_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_LIST {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_LIST {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OneEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OneEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filler0(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_filler0(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filler1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u64) }
    }
    #[inline]
    pub fn set_filler1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        OneEntry: ULONGLONG,
        filler0: ULONGLONG,
        Prototype: ULONGLONG,
        filler1: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OneEntry: u64 = unsafe { ::std::mem::transmute(OneEntry) };
            OneEntry as u64
        });
        __bindgen_bitfield_unit.set(2usize, 8u8, {
            let filler0: u64 = unsafe { ::std::mem::transmute(filler0) };
            filler0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let filler1: u64 = unsafe { ::std::mem::transmute(filler1) };
            filler1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_SUBSECTION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_SUBSECTION {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused0(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Unused0(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u64) }
    }
    #[inline]
    pub fn set_Unused1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn SubsectionAddress(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_SubsectionAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Unused0: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Unused1: ULONGLONG,
        SubsectionAddress: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let Unused0: u64 = unsafe { ::std::mem::transmute(Unused0) };
            Unused0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let Unused1: u64 = unsafe { ::std::mem::transmute(Unused1) };
            Unused1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let SubsectionAddress: u64 = unsafe { ::std::mem::transmute(SubsectionAddress) };
            SubsectionAddress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_TRANSITION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_TRANSITION {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn IoTracker(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IoTracker(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 26u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 26u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Write: ULONGLONG,
        Spare: ULONGLONG,
        IoTracker: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Transition: ULONGLONG,
        PageFrameNumber: ULONGLONG,
        Unused: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let Spare: u64 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let IoTracker: u64 = unsafe { ::std::mem::transmute(IoTracker) };
            IoTracker as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Transition: u64 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(12usize, 26u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(38usize, 26u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_TIMESTAMP {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_TIMESTAMP {
    #[inline]
    pub fn MustBeZero(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MustBeZero(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileLow(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileLow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalTimeStamp(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_GlobalTimeStamp(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MustBeZero: ULONGLONG,
        PageFileLow: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Transition: ULONGLONG,
        Unused: ULONGLONG,
        GlobalTimeStamp: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MustBeZero: u64 = unsafe { ::std::mem::transmute(MustBeZero) };
            MustBeZero as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let PageFileLow: u64 = unsafe { ::std::mem::transmute(PageFileLow) };
            PageFileLow as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Transition: u64 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let GlobalTimeStamp: u64 = unsafe { ::std::mem::transmute(GlobalTimeStamp) };
            GlobalTimeStamp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_SOFTWARE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_SOFTWARE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileLow(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileLow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileReserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileReserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileAllocated(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileAllocated(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileHigh(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileHigh(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        PageFileLow: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Transition: ULONGLONG,
        PageFileReserved: ULONGLONG,
        PageFileAllocated: ULONGLONG,
        Unused: ULONGLONG,
        PageFileHigh: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let PageFileLow: u64 = unsafe { ::std::mem::transmute(PageFileLow) };
            PageFileLow as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Transition: u64 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PageFileReserved: u64 = unsafe { ::std::mem::transmute(PageFileReserved) };
            PageFileReserved as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PageFileAllocated: u64 = unsafe { ::std::mem::transmute(PageFileAllocated) };
            PageFileAllocated as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let PageFileHigh: u64 = unsafe { ::std::mem::transmute(PageFileHigh) };
            PageFileHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_PROTOTYPE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_PROTOTYPE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DemandFillProto(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DemandFillProto(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HiberVerifyConverted(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HiberVerifyConverted(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Unused1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Combined(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Combined(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtoAddress(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_ProtoAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        DemandFillProto: ULONGLONG,
        HiberVerifyConverted: ULONGLONG,
        Unused1: ULONGLONG,
        ReadOnly: ULONGLONG,
        Combined: ULONGLONG,
        Prototype: ULONGLONG,
        Protection: ULONGLONG,
        Unused: ULONGLONG,
        ProtoAddress: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DemandFillProto: u64 = unsafe { ::std::mem::transmute(DemandFillProto) };
            DemandFillProto as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HiberVerifyConverted: u64 = unsafe { ::std::mem::transmute(HiberVerifyConverted) };
            HiberVerifyConverted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Unused1: u64 = unsafe { ::std::mem::transmute(Unused1) };
            Unused1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReadOnly: u64 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Combined: u64 = unsafe { ::std::mem::transmute(Combined) };
            Combined as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let ProtoAddress: u64 = unsafe { ::std::mem::transmute(ProtoAddress) };
            ProtoAddress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPTE_HARDWARE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_HARDWARE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 26u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 25u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn NoExecute(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NoExecute(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Dirty1: ULONGLONG,
        Owner: ULONGLONG,
        WriteThrough: ULONGLONG,
        CacheDisable: ULONGLONG,
        Accessed: ULONGLONG,
        Dirty: ULONGLONG,
        LargePage: ULONGLONG,
        Global: ULONGLONG,
        CopyOnWrite: ULONGLONG,
        Unused: ULONGLONG,
        Write: ULONGLONG,
        PageFrameNumber: ULONGLONG,
        reserved1: ULONGLONG,
        NoExecute: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Dirty1: u64 = unsafe { ::std::mem::transmute(Dirty1) };
            Dirty1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u64 = unsafe { ::std::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u64 = unsafe { ::std::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u64 = unsafe { ::std::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u64 = unsafe { ::std::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CopyOnWrite: u64 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(12usize, 26u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(38usize, 25u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let NoExecute: u64 = unsafe { ::std::mem::transmute(NoExecute) };
            NoExecute as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HARDWARE_PTE {
    pub __bindgen_anon_1: _HARDWARE_PTE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HARDWARE_PTE__bindgen_ty_1 {
    pub __bindgen_anon_1: _HARDWARE_PTE__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _HARDWARE_PTE__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HARDWARE_PTE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _HARDWARE_PTE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 26u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 25u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn NoExecute(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NoExecute(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Write: ULONGLONG,
        Owner: ULONGLONG,
        WriteThrough: ULONGLONG,
        CacheDisable: ULONGLONG,
        Accessed: ULONGLONG,
        Dirty: ULONGLONG,
        LargePage: ULONGLONG,
        Global: ULONGLONG,
        CopyOnWrite: ULONGLONG,
        Prototype: ULONGLONG,
        reserved0: ULONGLONG,
        PageFrameNumber: ULONGLONG,
        reserved1: ULONGLONG,
        NoExecute: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u64 = unsafe { ::std::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u64 = unsafe { ::std::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u64 = unsafe { ::std::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u64 = unsafe { ::std::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CopyOnWrite: u64 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved0: u64 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 26u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(38usize, 25u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let NoExecute: u64 = unsafe { ::std::mem::transmute(NoExecute) };
            NoExecute as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HARDWARE_PTE__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighPart: ULONG,
}
impl Default for _HARDWARE_PTE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HARDWARE_PTE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ENERGY_STATE_DURATION {
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    pub __bindgen_anon_1: _ENERGY_STATE_DURATION__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ENERGY_STATE_DURATION__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub LastChangeTime: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ENERGY_STATE_DURATION__bindgen_ty_1 {
    #[inline]
    pub fn Duration(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Duration(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Duration: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let Duration: u32 = unsafe { ::std::mem::transmute(Duration) };
            Duration as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ENERGY_STATE_DURATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _ENERGY_STATE_DURATION {
    #[inline]
    pub fn IsInState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsInState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(IsInState: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsInState: u32 = unsafe { ::std::mem::transmute(IsInState) };
            IsInState as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTE {
    #[doc = "offset: 0x0 (0)"]
    pub u: _MMPTE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPTE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Long: ULONGLONG,
    #[doc = "offset: 0x0 (0)"]
    pub VolatileLong: ULONGLONG,
    #[doc = "offset: 0x0 (0)"]
    pub HighLow: _MMPTE_HIGHLOW,
    #[doc = "offset: 0x0 (0)"]
    pub Flush: _HARDWARE_PTE,
    #[doc = "offset: 0x0 (0)"]
    pub Hard: _MMPTE_HARDWARE,
    #[doc = "offset: 0x0 (0)"]
    pub Proto: _MMPTE_PROTOTYPE,
    #[doc = "offset: 0x0 (0)"]
    pub Soft: _MMPTE_SOFTWARE,
    #[doc = "offset: 0x0 (0)"]
    pub TimeStamp: _MMPTE_TIMESTAMP,
    #[doc = "offset: 0x0 (0)"]
    pub Trans: _MMPTE_TRANSITION,
    #[doc = "offset: 0x0 (0)"]
    pub Subsect: _MMPTE_SUBSECTION,
    #[doc = "offset: 0x0 (0)"]
    pub List: _MMPTE_LIST,
}
impl Default for _MMPTE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMPTE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PAE_ENTRY {
    pub __bindgen_anon_1: _PAE_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PAE_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub PteEntry: [_MMPTE; 4usize],
    #[doc = "offset: 0x0 (0)"]
    pub PaeEntry: _PAE_PAGEINFO,
    #[doc = "offset: 0x0 (0)"]
    pub NextPae: _SINGLE_LIST_ENTRY,
}
impl Default for _PAE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PAE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMCLONE_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub ProtoPte: _MMPTE,
    pub __bindgen_anon_1: _MMCLONE_BLOCK__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub CloneRefCount: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMCLONE_BLOCK__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub CloneCommitCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub u1: _MI_CLONE_BLOCK_FLAGS,
}
impl Default for _MMCLONE_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMCLONE_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_DRIVER_VA {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _MI_DRIVER_VA,
    #[doc = "offset: 0x4 (4)"]
    pub PointerPte: *mut _MMPTE,
    #[doc = "offset: 0x8 (8)"]
    pub BitMap: _RTL_BITMAP,
    #[doc = "offset: 0x10 (16)"]
    pub Hint: ULONG,
}
impl Default for _MI_DRIVER_VA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x90 (144) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_DEBUGGER_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub TransientWrite: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub CodePageEdited: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub DebugPte: *mut _MMPTE,
    #[doc = "offset: 0x8 (8)"]
    pub PoisonedTb: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub InDebugger: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub Pfns: [*mut VOID; 32usize],
}
impl Default for _MI_DEBUGGER_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SHUTDOWN_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub CrashDumpInitialized: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub ConnectedStandbyActive: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub ZeroPageFileAtShutdown: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub SystemShutdown: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ShutdownFlushInProgress: LONG,
    #[doc = "offset: 0xc (12)"]
    pub MirroringActive: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ResumeItem: _MI_RESUME_WORKITEM,
    #[doc = "offset: 0x30 (48)"]
    pub MirrorHoldsPfn: *mut _ETHREAD,
    #[doc = "offset: 0x34 (52)"]
    pub MirrorBitMaps: [_RTL_BITMAP; 2usize],
    #[doc = "offset: 0x44 (68)"]
    pub CrashDumpPte: *mut _MMPTE,
}
impl Default for _MI_SHUTDOWN_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PER_SESSION_PROTOS {
    pub __bindgen_anon_1: _MI_PER_SESSION_PROTOS__bindgen_ty_1,
    pub __bindgen_anon_2: _MI_PER_SESSION_PROTOS__bindgen_ty_2,
    #[doc = "offset: 0x10 (16)"]
    pub SubsectionBase: *mut _MMPTE,
    #[doc = "offset: 0x14 (20)"]
    pub u2: _MI_PER_SESSION_PROTOS__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PER_SESSION_PROTOS__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub SessionProtoNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x0 (0)"]
    pub FreeList: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub DriverAddress: *mut VOID,
}
impl Default for _MI_PER_SESSION_PROTOS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PER_SESSION_PROTOS__bindgen_ty_2 {
    #[doc = "offset: 0xc (12)"]
    pub SessionId: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Subsection: *mut _SUBSECTION,
}
impl Default for _MI_PER_SESSION_PROTOS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PER_SESSION_PROTOS__bindgen_ty_3 {
    #[doc = "offset: 0x14 (20)"]
    pub ReferenceCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub NumberOfPtesToFree: ULONG,
}
impl Default for _MI_PER_SESSION_PROTOS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_PER_SESSION_PROTOS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SUBSECTION {
    #[doc = "offset: 0x0 (0)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = "offset: 0x4 (4)"]
    pub SubsectionBase: *mut _MMPTE,
    #[doc = "offset: 0x8 (8)"]
    pub NextSubsection: *mut _SUBSECTION,
    pub __bindgen_anon_1: _SUBSECTION__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub u: _SUBSECTION__bindgen_ty_2,
    #[doc = "offset: 0x14 (20)"]
    pub StartingSector: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub NumberOfFullSectors: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub PtesInSubsection: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub u1: _SUBSECTION__bindgen_ty_3,
    pub __bindgen_anon_2: _SUBSECTION__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SUBSECTION__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub GlobalPerSessionHead: _RTL_AVL_TREE,
    #[doc = "offset: 0xc (12)"]
    pub CreationWaitList: *mut _MI_CONTROL_AREA_WAIT_BLOCK,
    #[doc = "offset: 0xc (12)"]
    pub SessionDriverProtos: *mut _MI_PER_SESSION_PROTOS,
}
impl Default for _SUBSECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SUBSECTION__bindgen_ty_2 {
    #[doc = "offset: 0x10 (16)"]
    pub LongFlags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SubsectionFlags: _MMSUBSECTION_FLAGS,
}
impl Default for _SUBSECTION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SUBSECTION__bindgen_ty_3 {
    #[doc = "offset: 0x20 (32)"]
    pub e1: _MI_SUBSECTION_ENTRY1,
    #[doc = "offset: 0x20 (32)"]
    pub EntireField: ULONG,
}
impl Default for _SUBSECTION__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SUBSECTION__bindgen_ty_4 {
    pub __bindgen_anon_1: _SUBSECTION__bindgen_ty_4__bindgen_ty_1,
    #[doc = "offset: 0x24 (36)"]
    pub u2: _SUBSECTION__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SUBSECTION__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SUBSECTION__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn UnusedPtes(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_UnusedPtes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtentQueryNeeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtentQueryNeeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirtyPages(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirtyPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UnusedPtes: ULONG,
        ExtentQueryNeeded: ULONG,
        DirtyPages: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let UnusedPtes: u32 = unsafe { ::std::mem::transmute(UnusedPtes) };
            UnusedPtes as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ExtentQueryNeeded: u32 = unsafe { ::std::mem::transmute(ExtentQueryNeeded) };
            ExtentQueryNeeded as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DirtyPages: u32 = unsafe { ::std::mem::transmute(DirtyPages) };
            DirtyPages as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SUBSECTION__bindgen_ty_4__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SUBSECTION__bindgen_ty_4__bindgen_ty_2 {
    #[inline]
    pub fn AlignmentNoAccessPtes(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_AlignmentNoAccessPtes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn DirtyPages(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirtyPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AlignmentNoAccessPtes: ULONG,
        DirtyPages: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let AlignmentNoAccessPtes: u32 =
                unsafe { ::std::mem::transmute(AlignmentNoAccessPtes) };
            AlignmentNoAccessPtes as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DirtyPages: u32 = unsafe { ::std::mem::transmute(DirtyPages) };
            DirtyPages as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SUBSECTION__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SUBSECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MSUBSECTION {
    #[doc = "offset: 0x0 (0)"]
    pub Core: _SUBSECTION,
    #[doc = "offset: 0x28 (40)"]
    pub SubsectionNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x34 (52)"]
    pub DereferenceList: _LIST_ENTRY,
    #[doc = "offset: 0x3c (60)"]
    pub NumberOfMappedViews: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub NumberOfPfnReferences: ULONG,
}
impl Default for _MSUBSECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPFN {
    pub __bindgen_anon_1: _MMPFN__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub u2: _MIPFNBLINK,
    #[doc = "offset: 0x14 (20)"]
    pub u3: _MMPFN__bindgen_ty_2,
    #[doc = "offset: 0x18 (24)"]
    pub u4: _MMPFN__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub TreeNode: _RTL_BALANCED_NODE,
    pub __bindgen_anon_1: _MMPFN__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPFN__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub u1: _MMPFN__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_1: _MMPFN__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x8 (8)"]
    pub OriginalPte: _MMPTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub NextSlistPfn: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut VOID,
    #[doc = "offset: 0x0 (0)"]
    pub Flink: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub Active: _MI_ACTIVE_PFN,
}
impl Default for _MMPFN__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x4 (4)"]
    pub PteAddress: *mut _MMPTE,
    #[doc = "offset: 0x4 (4)"]
    pub VolatilePteAddress: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub PteLong: ULONG,
}
impl Default for _MMPFN__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMPFN__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMPFN__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_2 {
    pub __bindgen_anon_1: _MMPFN__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: _MMPFN__bindgen_ty_2__bindgen_ty_2,
    #[doc = "offset: 0x14 (20)"]
    pub e4: _MMPFN__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub ReferenceCount: USHORT,
    #[doc = "offset: 0x16 (22)"]
    pub e1: _MMPFNENTRY1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "offset: 0x17 (23)"]
    pub e3: _MMPFNENTRY3,
    #[doc = "offset: 0x14 (20)"]
    pub e2: _MMPFN__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ReferenceCount: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN__bindgen_ty_2__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub EntireField: ULONG,
}
impl Default for _MMPFN__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x18 (24)"]
    pub EntireField: ULONG,
}
impl Default for _MMPFN__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMPFN__bindgen_ty_3 {
    #[inline]
    pub fn PteFrame(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_PteFrame(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn PageIdentity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PageIdentity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PrototypePte(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrototypePte(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageColor(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PageColor(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PteFrame: ULONG,
        PageIdentity: ULONG,
        PrototypePte: ULONG,
        PageColor: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let PteFrame: u32 = unsafe { ::std::mem::transmute(PteFrame) };
            PteFrame as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let PageIdentity: u32 = unsafe { ::std::mem::transmute(PageIdentity) };
            PageIdentity as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let PrototypePte: u32 = unsafe { ::std::mem::transmute(PrototypePte) };
            PrototypePte as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let PageColor: u32 = unsafe { ::std::mem::transmute(PageColor) };
            PageColor as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMPFN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_COMMON_PAGE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub PageOfOnesPfn: *mut _MMPFN,
    #[doc = "offset: 0x4 (4)"]
    pub PageOfOnes: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DummyPagePfn: *mut _MMPFN,
    #[doc = "offset: 0xc (12)"]
    pub DummyPage: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub PageOfZeroes: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ZeroMapping: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub OnesMapping: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub ZeroCrc: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub OnesCrc: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub BitmapGapFrames: [ULONG; 2usize],
    #[doc = "offset: 0x38 (56)"]
    pub PfnGapFrames: [ULONG; 2usize],
}
impl Default for _MI_COMMON_PAGE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEGMENT {
    #[doc = "offset: 0x0 (0)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = "offset: 0x4 (4)"]
    pub TotalNumberOfPtes: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SegmentFlags: _SEGMENT_FLAGS,
    #[doc = "offset: 0xc (12)"]
    pub NumberOfCommittedPages: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SizeOfSegment: ULONGLONG,
    pub __bindgen_anon_1: _SEGMENT__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub SegmentLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x20 (32)"]
    pub u1: _SEGMENT__bindgen_ty_2,
    #[doc = "offset: 0x24 (36)"]
    pub u2: _SEGMENT__bindgen_ty_3,
    #[doc = "offset: 0x28 (40)"]
    pub PrototypePte: *mut _MMPTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub ExtendInfo: *mut _MMEXTEND_INFO,
    #[doc = "offset: 0x18 (24)"]
    pub BasedAddress: *mut VOID,
}
impl Default for _SEGMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT__bindgen_ty_2 {
    #[doc = "offset: 0x20 (32)"]
    pub ImageCommitment: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub CreatingProcessId: ULONG,
}
impl Default for _SEGMENT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT__bindgen_ty_3 {
    #[doc = "offset: 0x24 (36)"]
    pub ImageInformation: *mut _MI_SECTION_IMAGE_INFORMATION,
    #[doc = "offset: 0x24 (36)"]
    pub FirstMappedVa: *mut VOID,
}
impl Default for _SEGMENT__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SEGMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CONTROL_AREA {
    #[doc = "offset: 0x0 (0)"]
    pub Segment: *mut _SEGMENT,
    #[doc = "offset: 0x4 (4)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub NumberOfSectionReferences: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub NumberOfPfnReferences: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub NumberOfMappedViews: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub NumberOfUserReferences: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub u: _CONTROL_AREA__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub FilePointer: _EX_FAST_REF,
    #[doc = "offset: 0x24 (36)"]
    pub ControlAreaLock: LONG,
    #[doc = "offset: 0x28 (40)"]
    pub ModifiedWriteCount: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub WaitList: *mut _MI_CONTROL_AREA_WAIT_BLOCK,
    #[doc = "offset: 0x30 (48)"]
    pub u2: _CONTROL_AREA__bindgen_ty_2,
    #[doc = "offset: 0x3c (60)"]
    pub FileObjectLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x40 (64)"]
    pub LockedPages: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub u3: _CONTROL_AREA__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_1 {
    #[doc = "offset: 0x1c (28)"]
    pub LongFlags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Flags: _MMSECTION_FLAGS,
}
impl Default for _CONTROL_AREA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_2 {
    #[doc = "offset: 0x30 (48)"]
    pub e2: _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub NumberOfSystemCacheViews: ULONG,
    #[doc = "offset: 0x0 (0)"]
    pub ImageRelocationStartBit: ULONG,
}
impl Default for _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x4 (4)"]
    pub WritableUserReferences: LONG,
    pub __bindgen_anon_1: _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ImageRelocationSizeIn64k(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ImageRelocationSizeIn64k(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemImage(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemImage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StrongCode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_StrongCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CantMove(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CantMove(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BitMap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BitMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImageActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImageRelocationSizeIn64k: ULONG,
        LargePage: ULONG,
        SystemImage: ULONG,
        StrongCode: ULONG,
        CantMove: ULONG,
        BitMap: ULONG,
        ImageActive: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ImageRelocationSizeIn64k: u32 =
                unsafe { ::std::mem::transmute(ImageRelocationSizeIn64k) };
            ImageRelocationSizeIn64k as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let LargePage: u32 = unsafe { ::std::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let SystemImage: u32 = unsafe { ::std::mem::transmute(SystemImage) };
            SystemImage as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let StrongCode: u32 = unsafe { ::std::mem::transmute(StrongCode) };
            StrongCode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let CantMove: u32 = unsafe { ::std::mem::transmute(CantMove) };
            CantMove as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let BitMap: u32 = unsafe { ::std::mem::transmute(BitMap) };
            BitMap as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ImageActive: u32 = unsafe { ::std::mem::transmute(ImageActive) };
            ImageActive as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x8 (8)"]
    pub FlushInProgressCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub NumberOfSubsections: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SeImageStub: *mut _MI_IMAGE_SECURITY_REFERENCE,
}
impl Default for _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CONTROL_AREA__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x48 (72)"]
    pub ImageCrossPartitionCharge: ULONG,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl Default for _CONTROL_AREA__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CONTROL_AREA__bindgen_ty_3 {
    #[inline]
    pub fn IoAttributionContext(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_IoAttributionContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoAttributionContext: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
            let IoAttributionContext: u32 = unsafe { ::std::mem::transmute(IoAttributionContext) };
            IoAttributionContext as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn CommittedPageCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_CommittedPageCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(CommittedPageCount: ULONG) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let CommittedPageCount: u32 = unsafe { ::std::mem::transmute(CommittedPageCount) };
            CommittedPageCount as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CONTROL_AREA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x140 (320) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SECTION_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub SectionObjectPointersLock: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub SectionBasedRoot: _RTL_AVL_TREE,
    #[doc = "offset: 0x8 (8)"]
    pub SectionBasedLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xc (12)"]
    pub UnusedSegmentPagedPool: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub DataSectionProtectionMask: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub HighSectionBase: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub PhysicalSubsection: _MSUBSECTION,
    #[doc = "offset: 0x60 (96)"]
    pub PhysicalControlArea: _CONTROL_AREA,
    #[doc = "offset: 0xb0 (176)"]
    pub PurgingExtentPages: _MMPFNLIST,
    #[doc = "offset: 0xc4 (196)"]
    pub DanglingExtentPages: *mut _MMPFN,
    #[doc = "offset: 0xc8 (200)"]
    pub DanglingExtentsWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0xd8 (216)"]
    pub DanglingExtentsWorkerActive: UCHAR,
    #[doc = "offset: 0xd9 (217)"]
    pub PurgingExtentsNeedWatchdog: UCHAR,
    #[doc = "offset: 0xdc (220)"]
    pub PageFileSectionHead: _RTL_AVL_TREE,
    #[doc = "offset: 0xe0 (224)"]
    pub PageFileSectionListSpinLock: LONG,
    #[doc = "offset: 0xe4 (228)"]
    pub ImageBias: ULONG,
    #[doc = "offset: 0xe8 (232)"]
    pub RelocateBitmapsLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xec (236)"]
    pub ImageBitMap: _RTL_BITMAP,
    #[doc = "offset: 0xf4 (244)"]
    pub ApiSetSection: *mut VOID,
    #[doc = "offset: 0xf8 (248)"]
    pub ApiSetSchema: *mut VOID,
    #[doc = "offset: 0xfc (252)"]
    pub ApiSetSchemaSize: ULONG,
    #[doc = "offset: 0x100 (256)"]
    pub LostDataFiles: ULONG,
    #[doc = "offset: 0x104 (260)"]
    pub LostDataPages: ULONG,
    #[doc = "offset: 0x108 (264)"]
    pub ImageFailureReason: ULONG,
    #[doc = "offset: 0x10c (268)"]
    pub CfgBitMapSection32: *mut _SECTION,
    #[doc = "offset: 0x110 (272)"]
    pub CfgBitMapControlArea32: *mut _CONTROL_AREA,
    #[doc = "offset: 0x114 (276)"]
    pub ImageCfgFailure: ULONG,
    #[doc = "offset: 0x118 (280)"]
    pub ImageChecksumBreakpoint: ULONG,
    #[doc = "offset: 0x11c (284)"]
    pub ImageSizeBreakpoint: ULONG,
    #[doc = "offset: 0x120 (288)"]
    pub ImageValidationFailed: LONG,
}
impl Default for _MI_SECTION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PTE_CHAIN_HEAD {
    #[doc = "offset: 0x0 (0)"]
    pub Flink: _MMPTE,
    #[doc = "offset: 0x8 (8)"]
    pub Blink: _MMPTE,
    #[doc = "offset: 0x10 (16)"]
    pub PteBase: *mut _MMPTE,
}
impl Default for _MI_PTE_CHAIN_HEAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SPECIAL_POOL {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Paged: _MI_PTE_CHAIN_HEAD,
    #[doc = "offset: 0x20 (32)"]
    pub NonPaged: _MI_PTE_CHAIN_HEAD,
    #[doc = "offset: 0x38 (56)"]
    pub PagesInUse: ULONG,
}
impl Default for _MI_SPECIAL_POOL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMWSL_INSTANCE {
    #[doc = "offset: 0x0 (0)"]
    pub NextPteToTrim: *mut _MMPTE,
    #[doc = "offset: 0x4 (4)"]
    pub NextPteToAge: *mut _MMPTE,
    #[doc = "offset: 0x8 (8)"]
    pub NextPteToAccessClear: *mut _MMPTE,
    #[doc = "offset: 0xc (12)"]
    pub LastAccessClearingRemainder: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub LastAgingRemainder: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub LockedEntries: ULONG,
}
impl Default for _MMWSL_INSTANCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1500 (5376) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SYSTEM_VA_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub SystemTablesLock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub SystemVaBias: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SystemAvailableVaLow: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub VirtualBias: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SystemRangeStart: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub SystemCachePdeCount: [UCHAR; 1024usize],
    #[doc = "offset: 0x414 (1044)"]
    pub SystemCacheReverseMaps: [*mut VOID; 1024usize],
    #[doc = "offset: 0x1414 (5140)"]
    pub DeleteKvaLock: LONG,
    #[doc = "offset: 0x1418 (5144)"]
    pub WsleArrays: [*mut _MI_WSLE; 5usize],
    #[doc = "offset: 0x142c (5164)"]
    pub PagableHyperSpace: *mut _MI_HYPER_SPACE,
    #[doc = "offset: 0x1430 (5168)"]
    pub HyperSpaceEnd: *mut VOID,
    #[doc = "offset: 0x1434 (5172)"]
    pub FreeSystemCacheVa: _KEVENT,
    #[doc = "offset: 0x1444 (5188)"]
    pub SystemVaLock: ULONG,
    #[doc = "offset: 0x1448 (5192)"]
    pub SystemCacheViewLock: ULONG,
    #[doc = "offset: 0x144c (5196)"]
    pub SystemWorkingSetList: [_MMWSL_INSTANCE; 5usize],
}
impl Default for _MI_SYSTEM_VA_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMSUPPORT_INSTANCE {
    #[doc = "offset: 0x0 (0)"]
    pub NextPageColor: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub LastTrimStamp: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub PageFaultCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub TrimmedPageCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub VmWorkingSetList: *mut _MMWSL_INSTANCE,
    #[doc = "offset: 0x10 (16)"]
    pub WorkingSetExpansionLinks: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub AgeDistribution: [ULONG; 8usize],
    #[doc = "offset: 0x38 (56)"]
    pub ExitOutswapGate: *mut _KGATE,
    #[doc = "offset: 0x3c (60)"]
    pub MinimumWorkingSetSize: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub WorkingSetLeafSize: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub WorkingSetLeafPrivateSize: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub WorkingSetSize: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub WorkingSetPrivateSize: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub MaximumWorkingSetSize: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub PeakWorkingSetSize: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub HardFaultCount: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub u1: _MMSUPPORT_INSTANCE__bindgen_ty_1,
    #[doc = "offset: 0x60 (96)"]
    pub Reserved0: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub Flags: _MMSUPPORT_FLAGS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMSUPPORT_INSTANCE__bindgen_ty_1 {
    #[doc = "offset: 0x5c (92)"]
    pub InstancedWorkingSet: *mut VOID,
}
impl Default for _MMSUPPORT_INSTANCE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMSUPPORT_INSTANCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SYSTEM_PTE_TYPE {
    #[doc = "offset: 0x0 (0)"]
    pub Bitmap: _RTL_BITMAP,
    #[doc = "offset: 0x8 (8)"]
    pub BasePte: *mut _MMPTE,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub VaType: _MI_SYSTEM_VA_TYPE,
    #[doc = "offset: 0x14 (20)"]
    pub FailureCount: *mut ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PteFailures: ULONG,
    pub __bindgen_anon_1: _MI_SYSTEM_PTE_TYPE__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub Vm: *mut _MMSUPPORT_INSTANCE,
    #[doc = "offset: 0x24 (36)"]
    pub TotalSystemPtes: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Hint: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub LowestBitEverAllocated: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub CachedPtes: *mut _MI_CACHED_PTES,
    #[doc = "offset: 0x34 (52)"]
    pub TotalFreeSystemPtes: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_SYSTEM_PTE_TYPE__bindgen_ty_1 {
    #[doc = "offset: 0x1c (28)"]
    pub SpinLock: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub GlobalPushLock: *mut _EX_PUSH_LOCK,
}
impl Default for _MI_SYSTEM_PTE_TYPE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_SYSTEM_PTE_TYPE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8c (140) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMSUPPORT_FULL {
    #[doc = "offset: 0x0 (0)"]
    pub Instance: _MMSUPPORT_INSTANCE,
    #[doc = "offset: 0x68 (104)"]
    pub Shared: _MMSUPPORT_SHARED,
}
impl Default for _MMSUPPORT_FULL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PAGED_POOL_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub PagedPoolAllocationMap: _RTL_BITMAP,
    #[doc = "offset: 0xc (12)"]
    pub FirstPteForPagedPool: *mut _MMPTE,
    #[doc = "offset: 0x10 (16)"]
    pub MaximumSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PagedPoolHint: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub AllocatedPagedPool: ULONG,
}
impl Default for _MM_PAGED_POOL_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8c0 (2240) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_VISIBLE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub SpecialPool: _MI_SPECIAL_POOL,
    #[doc = "offset: 0x40 (64)"]
    pub SessionWsList: _LIST_ENTRY,
    #[doc = "offset: 0x48 (72)"]
    pub SessionIdBitmap: *mut _RTL_BITMAP,
    #[doc = "offset: 0x4c (76)"]
    pub PagedPoolInfo: _MM_PAGED_POOL_INFO,
    #[doc = "offset: 0x68 (104)"]
    pub MaximumNonPagedPoolInPages: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub SizeOfPagedPoolInPages: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub SystemPteInfo: _MI_SYSTEM_PTE_TYPE,
    #[doc = "offset: 0xa8 (168)"]
    pub NonPagedPoolCommit: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub SmallNonPagedPtesCommit: ULONG,
    #[doc = "offset: 0xb0 (176)"]
    pub BootCommit: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub MdlPagesAllocated: ULONG,
    #[doc = "offset: 0xb8 (184)"]
    pub SystemPageTableCommit: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub SpecialPagesInUse: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub ProcessCommit: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub DriverCommit: LONG,
    #[doc = "offset: 0xc8 (200)"]
    pub PfnDatabaseCommit: ULONG,
    #[doc = "offset: 0x100 (256)"]
    pub SystemWs: [_MMSUPPORT_FULL; 3usize],
    #[doc = "offset: 0x2c0 (704)"]
    pub SystemCacheShared: _MMSUPPORT_SHARED,
    #[doc = "offset: 0x2e4 (740)"]
    pub MapCacheFailures: ULONG,
    #[doc = "offset: 0x2e8 (744)"]
    pub PagefileHashPages: ULONG,
    #[doc = "offset: 0x2ec (748)"]
    pub PteHeader: _SYSPTES_HEADER,
    #[doc = "offset: 0x378 (888)"]
    pub SessionSpecialPool: *mut _MI_SPECIAL_POOL,
    #[doc = "offset: 0x37c (892)"]
    pub SystemVaTypeCount: [ULONG; 17usize],
    #[doc = "offset: 0x3c0 (960)"]
    pub SystemVaType: [UCHAR; 1024usize],
    #[doc = "offset: 0x7c0 (1984)"]
    pub SystemVaTypeCountFailures: [ULONG; 17usize],
    #[doc = "offset: 0x804 (2052)"]
    pub SystemVaTypeCountLimit: [ULONG; 17usize],
    #[doc = "offset: 0x848 (2120)"]
    pub SystemVaTypeCountPeak: [ULONG; 17usize],
    #[doc = "offset: 0x88c (2188)"]
    pub SystemAvailableVa: ULONG,
}
impl Default for _MI_VISIBLE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4dc (1244) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_POOL_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub MaximumNonPagedPoolThreshold: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NonPagedPoolSListMaximum: [ULONG; 3usize],
    #[doc = "offset: 0x10 (16)"]
    pub AllocatedNonPagedPool: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub BadPoolHead: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub HighEventSets: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub HighEventSetsValid: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub PoolFailures: [[ULONG; 3usize]; 3usize],
    #[doc = "offset: 0x44 (68)"]
    pub PoolFailureReasons: _MI_POOL_FAILURE_REASONS,
    #[doc = "offset: 0x70 (112)"]
    pub LowPagedPoolThreshold: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub HighPagedPoolThreshold: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub SpecialPoolPdesMax: LONG,
    #[doc = "offset: 0x7c (124)"]
    pub NonPagedPoolNodes: [UCHAR; 1024usize],
    #[doc = "offset: 0x47c (1148)"]
    pub PagedProtoPoolInfo: _MM_PAGED_POOL_INFO,
    #[doc = "offset: 0x498 (1176)"]
    pub PagedPoolSListMaximum: ULONG,
    #[doc = "offset: 0x49c (1180)"]
    pub PreemptiveTrims: [ULONG; 4usize],
    #[doc = "offset: 0x4ac (1196)"]
    pub SpecialPagesInUsePeak: ULONG,
    #[doc = "offset: 0x4b0 (1200)"]
    pub SpecialPoolRejected: [ULONG; 6usize],
    #[doc = "offset: 0x4c8 (1224)"]
    pub SpecialPagesNonPaged: ULONG,
    #[doc = "offset: 0x4cc (1228)"]
    pub SpecialPoolPdes: LONG,
    #[doc = "offset: 0x4d0 (1232)"]
    pub SessionSpecialPoolPdesMax: ULONG,
    #[doc = "offset: 0x4d4 (1236)"]
    pub TotalPagedPoolQuota: ULONG,
    #[doc = "offset: 0x4d8 (1240)"]
    pub TotalNonPagedPoolQuota: ULONG,
}
impl Default for _MI_POOL_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET {
    #[doc = "offset: 0x0 (0)"]
    pub Name: _UNICODE_STRING,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Unit: _PO_FX_PERF_STATE_UNIT,
    #[doc = "offset: 0x14 (20)"]
    pub Type: _PO_FX_PERF_STATE_TYPE,
    pub __bindgen_anon_1: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub Discrete: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub Range: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub States: *mut _PO_FX_PERF_STATE,
}
impl Default for _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub Minimum: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Maximum: ULONGLONG,
}
impl Default for _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PO_FX_COMPONENT_PERF_SET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TIMELINE_BITMAP {
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    pub __bindgen_anon_1: _TIMELINE_BITMAP__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Bitmap: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TIMELINE_BITMAP__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub EndTime: ULONG,
}
impl Default for _TIMELINE_BITMAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION {
    pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1,
    pub __bindgen_anon_2: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2,
    #[doc = "offset: 0x98 (152)"]
    pub KeyboardInput: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub MouseInput: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Timelines: [_TIMELINE_BITMAP; 14usize],
    pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub CpuTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x8 (8)"]
    pub DiskTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x10 (16)"]
    pub NetworkTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x18 (24)"]
    pub MBBTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x20 (32)"]
    pub ForegroundTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x28 (40)"]
    pub DesktopVisibleTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x30 (48)"]
    pub CompositionRenderedTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x38 (56)"]
    pub CompositionDirtyGeneratedTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x40 (64)"]
    pub CompositionDirtyPropagatedTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x48 (72)"]
    pub InputTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x50 (80)"]
    pub AudioInTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x58 (88)"]
    pub AudioOutTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x60 (96)"]
    pub DisplayRequiredTimeline: _TIMELINE_BITMAP,
    #[doc = "offset: 0x68 (104)"]
    pub KeyboardInputTimeline: _TIMELINE_BITMAP,
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2 {
    #[doc = "offset: 0x70 (112)"]
    pub Durations: [_ENERGY_STATE_DURATION; 5usize],
    pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x70 (112)"]
    pub InputDuration: _ENERGY_STATE_DURATION,
    #[doc = "offset: 0x78 (120)"]
    pub AudioInDuration: _ENERGY_STATE_DURATION,
    #[doc = "offset: 0x80 (128)"]
    pub AudioOutDuration: _ENERGY_STATE_DURATION,
    #[doc = "offset: 0x88 (136)"]
    pub DisplayRequiredDuration: _ENERGY_STATE_DURATION,
    #[doc = "offset: 0x90 (144)"]
    pub PSMBackgroundDuration: _ENERGY_STATE_DURATION,
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JOBOBJECT_ENERGY_TRACKING_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    pub __bindgen_anon_1: _JOBOBJECT_ENERGY_TRACKING_STATE__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub DesiredState: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_ENERGY_TRACKING_STATE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub UpdateMask: ULONG,
}
impl Default for _JOBOBJECT_ENERGY_TRACKING_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS_VALUES {
    #[doc = "offset: 0x0 (0)"]
    pub KernelTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub UserTime: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub ReadyTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CycleTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub ContextSwitches: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub ReadOperationCount: LONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub WriteOperationCount: LONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub OtherOperationCount: LONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub ReadTransferCount: LONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub WriteTransferCount: LONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub OtherTransferCount: LONGLONG,
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_JOB_WAKE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationChannel: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub WakeCounters: [ULONGLONG; 7usize],
    #[doc = "offset: 0x40 (64)"]
    pub NoWakeCounter: ULONGLONG,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_DISK_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub BytesRead: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub BytesWritten: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub ReadOperationCount: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub WriteOperationCount: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub FlushOperationCount: ULONGLONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_FX_PERF_SET {
    #[doc = "offset: 0x0 (0)"]
    pub PerfSet: *mut _PO_FX_COMPONENT_PERF_SET,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentPerf: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub CurrentPerfStamp: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CurrentPerfNominal: UCHAR,
}
impl Default for _POP_FX_PERF_SET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_PERF_STATE_CHANGE {
    #[doc = "offset: 0x0 (0)"]
    pub Set: ULONG,
    pub __bindgen_anon_1: _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub StateIndex: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub StateValue: ULONGLONG,
}
impl Default for _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PO_FX_PERF_STATE_CHANGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_PROCESS_WAKE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationChannel: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub WakeCounters: [ULONG; 7usize],
    #[doc = "offset: 0x24 (36)"]
    pub WakeFilter: _JOBOBJECT_WAKE_FILTER,
    #[doc = "offset: 0x2c (44)"]
    pub NoWakeCounter: ULONG,
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_IDLE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub TransitionLatency: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub ResidencyRequirement: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub NominalPower: ULONG,
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_VETO_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub VetoReason: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ReferenceCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub HitCount: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub LastActivationTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub TotalActiveTime: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub CsActivationTime: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub CsActiveTime: ULONGLONG,
}
impl Default for _PPM_VETO_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_VETO_ACCOUNTING {
    #[doc = "offset: 0x0 (0)"]
    pub VetoPresent: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub VetoListHead: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub CsAccountingBlocks: UCHAR,
    #[doc = "offset: 0xd (13)"]
    pub BlocksDrips: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub PreallocatedVetoCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub PreallocatedVetoList: *mut _PPM_VETO_ENTRY,
}
impl Default for _PPM_VETO_ACCOUNTING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PPM_PLATFORM_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub LevelId: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Latency: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub BreakEvenDuration: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub VetoAccounting: _PPM_VETO_ACCOUNTING,
    #[doc = "offset: 0x28 (40)"]
    pub TransitionDebugger: UCHAR,
    #[doc = "offset: 0x29 (41)"]
    pub Platform: UCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub DependencyListCount: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub Processors: _KAFFINITY_EX,
    #[doc = "offset: 0x3c (60)"]
    pub Name: _UNICODE_STRING,
    #[doc = "offset: 0x44 (68)"]
    pub DependencyLists: *mut _PPM_SELECTION_DEPENDENCY,
    #[doc = "offset:\n 0x48 (72)"]
    pub Synchronization: _PPM_COORDINATED_SYNCHRONIZATION,
    #[doc = "offset: 0x50 (80)"]
    pub EnterTime: ULONGLONG,
    pub __bindgen_anon_1: _PPM_PLATFORM_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PPM_PLATFORM_STATE__bindgen_ty_1 {
    #[doc = "offset: 0x80 (128)"]
    pub RefCount: LONG,
    #[doc = "offset: 0x80 (128)"]
    pub CacheAlign0: [UCHAR; 64usize],
}
impl Default for _PPM_PLATFORM_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PPM_PLATFORM_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_IDLE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub DomainMembers: _KAFFINITY_EX,
    #[doc = "offset: 0xc (12)"]
    pub Name: _UNICODE_STRING,
    #[doc = "offset: 0x14 (20)"]
    pub Latency: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub BreakEvenDuration: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Power: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub StateFlags: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub VetoAccounting: _PPM_VETO_ACCOUNTING,
    #[doc = "offset: 0x3c (60)"]
    pub StateType: UCHAR,
    #[doc = "offset: 0x3d (61)"]
    pub InterruptsEnabled: UCHAR,
    #[doc = "offset: 0x3e (62)"]
    pub Interruptible: UCHAR,
    #[doc = "offset: 0x3f (63)"]
    pub ContextRetained: UCHAR,
    #[doc = "offset: 0x40 (64)"]
    pub CacheCoherent: UCHAR,
    #[doc = "offset: 0x41 (65)"]
    pub WakesSpuriously: UCHAR,
    #[doc = "offset: 0x42 (66)"]
    pub PlatformOnly: UCHAR,
    #[doc = "offset: 0x43 (67)"]
    pub NoCState: UCHAR,
}
impl Default for _PPM_IDLE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERRUPT_VECTOR_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Type: INTERRUPT_CONNECTION_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Irql: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub Polarity: _KINTERRUPT_POLARITY,
    #[doc = "offset: 0x10 (16)"]
    pub Mode: _KINTERRUPT_MODE,
    #[doc = "offset: 0x14 (20)"]
    pub TargetProcessors: _GROUP_AFFINITY,
    #[doc = "offset: 0x20 (32)"]
    pub IntRemapInfo: _INTERRUPT_REMAPPING_INFO,
    #[doc = "offset: 0x30 (48)"]
    pub ControllerInput: _INTERRUPT_VECTOR_DATA__bindgen_ty_1,
    #[doc = "offset: 0x38 (56)"]
    pub HvDeviceId: ULONGLONG,
    pub __bindgen_anon_1: _INTERRUPT_VECTOR_DATA__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _INTERRUPT_VECTOR_DATA__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Gsiv: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _INTERRUPT_VECTOR_DATA__bindgen_ty_1 {
    #[inline]
    pub fn WakeInterrupt(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WakeInterrupt: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WakeInterrupt: u32 = unsafe { ::std::mem::transmute(WakeInterrupt) };
            WakeInterrupt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _INTERRUPT_VECTOR_DATA__bindgen_ty_2 {
    #[doc = "offset: 0x40 (64)"]
    pub XapicMessage: _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub Hypertransport: _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_2,
    #[doc = "offset: 0x40 (64)"]
    pub GenericMessage: _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_3,
    #[doc = "offset: 0x40 (64)"]
    pub MessageRequest: _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Address: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub DataPayload: ULONG,
}
impl Default for _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub IntrInfo: _INTERRUPT_HT_INTR_INFO,
}
impl Default for _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub Address: _LARGE_INTEGER,
    #[doc = "offset: 0x8 (8)"]
    pub DataPayload: ULONG,
}
impl Default for _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub DestinationMode: HAL_APIC_DESTINATION_MODE,
}
impl Default for _INTERRUPT_VECTOR_DATA__bindgen_ty_2__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _INTERRUPT_VECTOR_DATA__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _INTERRUPT_VECTOR_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERRUPT_CONNECTION_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Vectors: [_INTERRUPT_VECTOR_DATA; 1usize],
}
impl Default for _INTERRUPT_CONNECTION_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REBALANCE_TRACE_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub DeviceCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub RebalancePhase: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reason: [_PNP_REBALANCE_REASON; 2usize],
    #[doc = "offset: 0x10 (16)"]
    pub Failure: [_PNP_REBALANCE_FAILURE; 2usize],
    #[doc = "offset: 0x18 (24)"]
    pub SubtreeRoot: *mut _DEVICE_NODE,
    #[doc = "offset: 0x1c (28)"]
    pub SubtreeIncludesRoot: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub TriggerRoot: *mut _DEVICE_NODE,
    #[doc = "offset: 0x24 (36)"]
    pub RebalanceDueToDynamicPartitioning: UCHAR,
    #[doc = "offset: 0x28 (40)"]
    pub BeginTime: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub VetoNode: [*mut _DEVICE_NODE; 2usize],
    #[doc = "offset: 0x38 (56)"]
    pub VetoQueryRebalanceReason: [_PNP_DEVNODE_QUERY_REBALANCE_VETO_REASON; 2usize],
    #[doc = "offset: 0x40 (64)"]
    pub ConflictContext: _PNP_RESOURCE_CONFLICT_TRACE_CONTEXT,
}
impl Default for _PNP_REBALANCE_TRACE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_IDLE_STATE_BUCKET {
    #[doc = "offset: 0x0 (0)"]
    pub TotalTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinTime: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub MaxTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub Count: ULONG,
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_SELECTION_STATISTICS {
    #[doc = "offset: 0x0 (0)"]
    pub SelectedCount: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub VetoCount: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub PreVetoCount: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub WrongProcessorCount: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub LatencyCount: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub IdleDurationCount: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub DeviceDependencyCount: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub ProcessorDependencyCount: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub PlatformOnlyCount: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub InterruptibleCount: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub LegacyOverrideCount: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub CstateCheckCount: ULONGLONG,
    #[doc = "offset: 0x60 (96)"]
    pub NoCStateCount: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub CoordinatedDependencyCount: ULONGLONG,
    #[doc = "offset: 0x70 (112)"]
    pub NotClockOwnerCount: ULONGLONG,
    #[doc = "offset: 0x78 (120)"]
    pub PreVetoAccounting: *mut _PPM_VETO_ACCOUNTING,
}
impl Default for _PPM_SELECTION_STATISTICS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3f0 (1008) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLATFORM_IDLE_STATE_ACCOUNTING {
    #[doc = "offset: 0x0 (0)"]
    pub CancelCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub FailureCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub SuccessCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MaxTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub MinTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub TotalTime: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub InvalidBucketIndex: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub SelectionStatistics: _PPM_SELECTION_STATISTICS,
    #[doc = "offset: 0xb0 (176)"]
    pub IdleTimeBuckets: [_PROC_IDLE_STATE_BUCKET; 26usize],
}
impl Default for _PLATFORM_IDLE_STATE_ACCOUNTING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x408 (1032) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLATFORM_IDLE_ACCOUNTING {
    #[doc = "offset: 0x0 (0)"]
    pub ResetCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub StateCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DeepSleepCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TimeUnit: PPM_IDLE_BUCKET_TIME_TYPE,
    #[doc = "offset: 0x10 (16)"]
    pub StartTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub State: [_PLATFORM_IDLE_STATE_ACCOUNTING; 1usize],
}
impl Default for _PLATFORM_IDLE_ACCOUNTING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x100 (256) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PPM_PLATFORM_STATES {
    #[doc = "offset: 0x0 (0)"]
    pub StateCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub InterfaceVersion: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ProcessorCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub CoordinatedInterface: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub IdleTest: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG, arg3: ULONG) -> ULONG,
    >,
    pub IdlePreExecute: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: ULONG,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut ULONG,
        ) -> LONG,
    >,
    pub IdleComplete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: ULONG,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut ULONG,
        ),
    >,
    pub QueryPlatformStateResidency: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: *mut _PROCESSOR_PLATFORM_STATE_RESIDENCIES,
        ) -> LONG,
    >,
    #[doc = "offset: 0x20 (32)"]
    pub Accounting: *mut _PLATFORM_IDLE_ACCOUNTING,
    #[doc = "offset: 0x40 (64)"]
    pub State: [_PPM_PLATFORM_STATE; 1usize],
}
impl Default for _PPM_PLATFORM_STATES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COUNTER_READING {
    #[doc = "offset: 0x0 (0)"]
    pub Type: _HARDWARE_COUNTER_TYPE,
    #[doc = "offset: 0x4 (4)"]
    pub Index: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Start: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Total: ULONGLONG,
}
impl Default for _COUNTER_READING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c0 (448) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_PERFORMANCE_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Version: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub ProcessorNumber: _PROCESSOR_NUMBER,
    #[doc = "offset: 0x8 (8)"]
    pub ContextSwitches: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub HwCountersCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub UpdateCount: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub WaitReasonBitMap: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub HardwareCounters: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub CycleTime: _COUNTER_READING,
    #[doc = "offset: 0x40 (64)"]
    pub HwCounters: [_COUNTER_READING; 16usize],
}
impl Default for _THREAD_PERFORMANCE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _M128A {
    #[doc = "offset: 0x0 (0)"]
    pub Low: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub High: LONGLONG,
}
#[doc = "0x200 (512) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_FORMAT {
    #[doc = "offset: 0x0 (0)"]
    pub ControlWord: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub StatusWord: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub TagWord: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub Reserved1: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub ErrorOpcode: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub ErrorOffset: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ErrorSelector: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Reserved2: USHORT,
    #[doc = "offset: 0x10 (16)"]
    pub DataOffset: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub DataSelector: USHORT,
    #[doc = "offset: 0x16 (22)"]
    pub Reserved3: USHORT,
    #[doc = "offset: 0x18 (24)"]
    pub MxCsr: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub MxCsr_Mask: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub FloatRegisters: [_M128A; 8usize],
    #[doc = "offset: 0xa0 (160)"]
    pub XmmRegisters: [_M128A; 8usize],
    #[doc = "offset: 0x120 (288)"]
    pub Reserved4: [UCHAR; 224usize],
}
impl Default for _XSAVE_FORMAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_LOG_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Timestamp: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Operation: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub Component: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub Processor: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub Process: USHORT,
    #[doc = "offset: 0xe (14)"]
    pub Thread: USHORT,
    #[doc = "offset: 0x10 (16)"]
    pub Information: ULONGLONG,
}
#[doc = "0x3e8 (1000) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_IDLE_STATE_ACCOUNTING {
    #[doc = "offset: 0x0 (0)"]
    pub TotalTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub CancelCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub FailureCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SuccessCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub InvalidBucketIndex: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub MinTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub MaxTime: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub SelectionStatistics: _PPM_SELECTION_STATISTICS,
    #[doc = "offset: 0xa8 (168)"]
    pub IdleTimeBuckets: [_PROC_IDLE_STATE_BUCKET; 26usize],
}
impl Default for _PROC_IDLE_STATE_ACCOUNTING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_IDLE_CONSTRAINTS {
    #[doc = "offset: 0x0 (0)"]
    pub TotalTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub IdleTime: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub ExpectedIdleDuration: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub MaxIdleDuration: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub OverrideState: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub TimeCheck: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub PromotePercent: UCHAR,
    #[doc = "offset: 0x29 (41)"]
    pub DemotePercent: UCHAR,
    #[doc = "offset: 0x2a (42)"]
    pub Parked: UCHAR,
    #[doc = "offset: 0x2b (43)"]
    pub Interruptible: UCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub PlatformIdle: UCHAR,
    #[doc = "offset: 0x2d (45)"]
    pub ExpectedWakeReason: UCHAR,
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_IDLE_PREPARE_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Constraints: _PROCESSOR_IDLE_CONSTRAINTS,
    #[doc = "offset: 0x38 (56)"]
    pub DependencyCount: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub DependencyUsed: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub DependencyArray: *mut _PROCESSOR_IDLE_DEPENDENCY,
    #[doc = "offset: 0x44 (68)"]
    pub PlatformIdleStateIndex: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub ProcessorIdleStateIndex: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub IdleSelectFailureMask: ULONG,
}
impl Default for _PROCESSOR_IDLE_PREPARE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ISRDPCSTATS {
    #[doc = "offset: 0x0 (0)"]
    pub IsrTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub IsrTimeStart: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub IsrCount: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub DpcTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub DpcTimeStart: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub DpcCount: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub IsrActive: UCHAR,
    #[doc = "offset: 0x31 (49)"]
    pub Reserved: [UCHAR; 15usize],
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POP_FX_ACCOUNTING {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Active: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub DripsRequiredState: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Level: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub ActiveStamp: LONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CsActiveTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub CriticalActiveTime: LONGLONG,
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _PS_TRUSTLET_ATTRIBUTE_HEADER,
    #[doc = "offset: 0x8 (8)"]
    pub Data: [ULONGLONG; 1usize],
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_CREATE_ATTRIBUTES {
    #[doc = "offset: 0x0 (0)"]
    pub TrustletIdentity: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Attributes: [_PS_TRUSTLET_ATTRIBUTE_DATA; 1usize],
}
impl Default for _PS_TRUSTLET_CREATE_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERF_CONTROL_STATE_SELECTION {
    #[doc = "offset: 0x0 (0)"]
    pub SelectedState: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub SelectedPercent: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub SelectedFrequency: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MinPercent: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub MaxPercent: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub TolerancePercent: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub EppPercent: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub AutonomousActivityWindow: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Autonomous: UCHAR,
    #[doc = "offset: 0x25 (37)"]
    pub InheritFromDomain: UCHAR,
}
#[doc = "0x100 (256) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSCB {
    #[doc = "offset: 0x0 (0)"]
    pub GenerationCycles: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinQuotaCycleTarget: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub MaxQuotaCycleTarget: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub RankCycleTarget: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub LongTermCycles: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub LastReportedCycles: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub OverQuotaHistory: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub ReadyTime: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub InsertTime: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub PerProcessorList: _LIST_ENTRY,
    #[doc = "offset: 0x50 (80)"]
    pub QueueNode: _RTL_BALANCED_NODE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x5d (93)"]
    pub Depth: UCHAR,
    #[doc = "offset: 0x5e (94)"]
    pub ReadySummary: USHORT,
    #[doc = "offset: 0x60 (96)"]
    pub Rank: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub ShareRank: *mut ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub OwnerShareRank: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub ReadyListHead: [_LIST_ENTRY; 16usize],
    #[doc = "offset: 0xec (236)"]
    pub ChildScbQueue: _RTL_RB_TREE,
    #[doc = "offset: 0xf4 (244)"]
    pub Parent: *mut _KSCB,
    #[doc = "offset: 0xf8 (248)"]
    pub Root: *mut _KSCB,
}
impl Default for _KSCB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KSCB {
    #[inline]
    pub fn Inserted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MaxOverQuota(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MaxOverQuota(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MinOverQuota(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MinOverQuota(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RankBias(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RankBias(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SoftCap(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SoftCap(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShareRankOwner(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ShareRankOwner(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Inserted: UCHAR,
        MaxOverQuota: UCHAR,
        MinOverQuota: UCHAR,
        RankBias: UCHAR,
        SoftCap: UCHAR,
        ShareRankOwner: UCHAR,
        Spare1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Inserted: u8 = unsafe { ::std::mem::transmute(Inserted) };
            Inserted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MaxOverQuota: u8 = unsafe { ::std::mem::transmute(MaxOverQuota) };
            MaxOverQuota as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MinOverQuota: u8 = unsafe { ::std::mem::transmute(MinOverQuota) };
            MinOverQuota as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RankBias: u8 = unsafe { ::std::mem::transmute(RankBias) };
            RankBias as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SoftCap: u8 = unsafe { ::std::mem::transmute(SoftCap) };
            SoftCap as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ShareRankOwner: u8 = unsafe { ::std::mem::transmute(ShareRankOwner) };
            ShareRankOwner as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Spare1: u8 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0xb0 (176) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPROCESS {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub ProfileListHead: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub DirectoryTableBase: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub LdtDescriptor: _KGDTENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub Int21Descriptor: _KIDTENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub ThreadListHead: _LIST_ENTRY,
    #[doc = "offset: 0x34 (52)"]
    pub ProcessLock: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub DeepFreezeStartTime: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub Affinity: _KAFFINITY_EX,
    #[doc = "offset: 0x4c (76)"]
    pub ReadyListHead: _LIST_ENTRY,
    #[doc = "offset: 0x54 (84)"]
    pub SwapListEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x58 (88)"]
    pub ActiveProcessors: _KAFFINITY_EX,
    pub __bindgen_anon_1: _KPROCESS__bindgen_ty_1,
    #[doc = "offset: 0x68 (104)"]
    pub BasePriority: CHAR,
    #[doc = "offset: 0x69 (105)"]
    pub QuantumReset: CHAR,
    #[doc = "offset: 0x6a (106)"]
    pub Visited: UCHAR,
    #[doc = "offset: 0x6b (107)"]
    pub Flags: _KEXECUTE_OPTIONS,
    #[doc = "offset: 0x6c (108)"]
    pub ThreadSeed: [ULONG; 1usize],
    #[doc = "offset: 0x70 (112)"]
    pub IdealNode: [USHORT; 1usize],
    #[doc = "offset: 0x72 (114)"]
    pub IdealGlobalNode: USHORT,
    #[doc = "offset: 0x74 (116)"]
    pub Spare1: USHORT,
    #[doc = "offset: 0x76 (118)"]
    pub IopmOffset: USHORT,
    #[doc = "offset: 0x78 (120)"]
    pub SchedulingGroup: *mut _KSCHEDULING_GROUP,
    #[doc = "offset: 0x7c (124)"]
    pub StackCount: _KSTACK_COUNT,
    #[doc = "offset: 0x80 (128)"]
    pub ProcessListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x88 (136)"]
    pub CycleTime: ULONGLONG,
    #[doc = "offset: 0x90 (144)"]
    pub ContextSwitches: ULONGLONG,
    #[doc = "offset: 0x98 (152)"]
    pub FreezeCount: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub KernelTime: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub UserTime: ULONG,
    #[doc = "offset: 0xa4 (164)"]
    pub ReadyTime: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub VdmTrapcHandler: *mut VOID,
    #[doc = "offset: 0xac (172)"]
    pub ProcessTimerDelay: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPROCESS__bindgen_ty_1 {
    pub __bindgen_anon_1: _KPROCESS__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x64 (100)"]
    pub ProcessFlags: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KPROCESS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KPROCESS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AutoAlignment(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoAlignment(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableBoost(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableBoost(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableQuantum(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableQuantum(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeepFreeze(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeepFreeze(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TimerVirtualization(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TimerVirtualization(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CheckStackExtents(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CheckStackExtents(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PpmPolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PpmPolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ActiveGroupsMask(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ActiveGroupsMask(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AutoAlignment: LONG,
        DisableBoost: LONG,
        DisableQuantum: LONG,
        DeepFreeze: ULONG,
        TimerVirtualization: ULONG,
        CheckStackExtents: ULONG,
        PpmPolicy: ULONG,
        ActiveGroupsMask: ULONG,
        ReservedFlags: LONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AutoAlignment: u32 = unsafe { ::std::mem::transmute(AutoAlignment) };
            AutoAlignment as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableBoost: u32 = unsafe { ::std::mem::transmute(DisableBoost) };
            DisableBoost as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisableQuantum: u32 = unsafe { ::std::mem::transmute(DisableQuantum) };
            DisableQuantum as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DeepFreeze: u32 = unsafe { ::std::mem::transmute(DeepFreeze) };
            DeepFreeze as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TimerVirtualization: u32 = unsafe { ::std::mem::transmute(TimerVirtualization) };
            TimerVirtualization as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CheckStackExtents: u32 = unsafe { ::std::mem::transmute(CheckStackExtents) };
            CheckStackExtents as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let PpmPolicy: u32 = unsafe { ::std::mem::transmute(PpmPolicy) };
            PpmPolicy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ActiveGroupsMask: u32 = unsafe { ::std::mem::transmute(ActiveGroupsMask) };
            ActiveGroupsMask as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KPROCESS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPROCESS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KAPC_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub ApcListHead: [_LIST_ENTRY; 2usize],
    #[doc = "offset: 0x10 (16)"]
    pub Process: *mut _KPROCESS,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1,
    #[doc = "offset: 0x15 (21)"]
    pub KernelApcPending: UCHAR,
    #[doc = "offset: 0x16 (22)"]
    pub UserApcPending: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC_STATE__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub InProgressFlags: UCHAR,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelApcInProgress(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_KernelApcInProgress(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpecialApcInProgress(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SpecialApcInProgress(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelApcInProgress: UCHAR,
        SpecialApcInProgress: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelApcInProgress: u8 = unsafe { ::std::mem::transmute(KernelApcInProgress) };
            KernelApcInProgress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SpecialApcInProgress: u8 = unsafe { ::std::mem::transmute(SpecialApcInProgress) };
            SpecialApcInProgress as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KAPC_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KAPC_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1a8 (424) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD_COUNTERS {
    #[doc = "offset: 0x0 (0)"]
    pub WaitReasonBitMap: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub UserData: *mut _THREAD_PERFORMANCE_DATA,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ContextSwitches: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CycleTimeBias: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub HardwareCounters: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub HwCounter: [_COUNTER_READING; 16usize],
}
impl Default for _KTHREAD_COUNTERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x180 (384) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSCHEDULING_GROUP {
    #[doc = "offset: 0x0 (0)"]
    pub Policy: _KSCHEDULING_GROUP_POLICY,
    #[doc = "offset: 0x8 (8)"]
    pub RelativeWeight: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ChildMinRate: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ChildMinWeight: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ChildTotalWeight: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub QueryHistoryTimeStamp: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub NotificationCycles: LONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub MaxQuotaLimitCycles: LONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub MaxQuotaCyclesRemaining: LONGLONG,
    pub __bindgen_anon_1: _KSCHEDULING_GROUP__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub NotificationDpc: *mut _KDPC,
    #[doc = "offset: 0x44 (68)"]
    pub ChildList: _LIST_ENTRY,
    #[doc = "offset: 0x4c (76)"]
    pub Parent: *mut _KSCHEDULING_GROUP,
    #[doc = "offset: 0x80 (128)"]
    pub PerProcessor: [_KSCB; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KSCHEDULING_GROUP__bindgen_ty_1 {
    #[doc = "offset: 0x38 (56)"]
    pub SchedulingGroupList: _LIST_ENTRY,
    #[doc = "offset: 0x38 (56)"]
    pub Sibling: _LIST_ENTRY,
}
impl Default for _KSCHEDULING_GROUP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KSCHEDULING_GROUP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Mask: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub CompactionMask: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Reserved2: [ULONGLONG; 6usize],
}
#[doc = "0x240 (576) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA {
    #[doc = "offset: 0x0 (0)"]
    pub LegacyState: _XSAVE_FORMAT,
    #[doc = "offset: 0x200 (512)"]
    pub Header: _XSAVE_AREA_HEADER,
}
impl Default for _XSAVE_AREA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Mask: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Length: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Reserved1: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Area: *mut _XSAVE_AREA,
    #[doc = "offset: 0x14 (20)"]
    pub Reserved2: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Buffer: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub Reserved3: ULONG,
}
impl Default for _XSTATE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_SAVE {
    pub __bindgen_anon_1: _XSTATE_SAVE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_SAVE__bindgen_ty_1 {
    pub __bindgen_anon_1: _XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x0 (0)"]
    pub XStateContext: _XSTATE_CONTEXT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Reserved1: LONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Reserved2: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Prev: *mut _XSTATE_SAVE,
    #[doc = "offset: 0x10 (16)"]
    pub Reserved3: *mut _XSAVE_AREA,
    #[doc = "offset: 0x14 (20)"]
    pub Thread: *mut _KTHREAD,
    #[doc = "offset: 0x18 (24)"]
    pub Reserved4: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub Level: UCHAR,
}
impl Default for _XSTATE_SAVE__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _XSTATE_SAVE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _XSTATE_SAVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x60 (96) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEBS_DS_SAVE_AREA {
    #[doc = "offset: 0x0 (0)"]
    pub BtsBufferBase: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub BtsIndex: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub BtsAbsoluteMaximum: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub BtsInterruptThreshold: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub PebsBufferBase: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub PebsIndex: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub PebsAbsoluteMaximum: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub PebsInterruptThreshold: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub PebsCounterReset0: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub PebsCounterReset1: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub PebsCounterReset2: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub PebsCounterReset3: ULONGLONG,
}
#[doc = "0x60 (96) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_PROFILE_CONTROL_AREA {
    #[doc = "offset: 0x0 (0)"]
    pub PebsDsSaveArea: _PEBS_DS_SAVE_AREA,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PPM_CONCURRENCY_ACCOUNTING {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Processors: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ActiveProcessors: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub LastUpdateTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub TotalTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub AccumulatedTime: [ULONGLONG; 1usize],
}
#[doc = "0x410 (1040) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_IDLE_ACCOUNTING {
    #[doc = "offset: 0x0 (0)"]
    pub StateCount: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TotalTransitions: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ResetCount: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub AbortCount: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub StartTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub PriorIdleTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub TimeUnit: PPM_IDLE_BUCKET_TIME_TYPE,
    #[doc = "offset: 0x28 (40)"]
    pub State: [_PROC_IDLE_STATE_ACCOUNTING; 1usize],
}
impl Default for _PROC_IDLE_ACCOUNTING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x150 (336) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PPM_IDLE_STATES {
    #[doc = "offset: 0x0 (0)"]
    pub InterfaceVersion: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub IdleOverride: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub EstimateIdleDuration: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub ExitLatencyTraceEnabled: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub NonInterruptibleTransition: UCHAR,
    #[doc = "offset: 0x5 (5)"]
    pub UnaccountedTransition: UCHAR,
    #[doc = "offset: 0x6 (6)"]
    pub IdleDurationLimited: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub IdleCheckLimited: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub ExitLatencyCountdown: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TargetState: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ActualState: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub OldState: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub OverrideIndex: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ProcessorIdleCount: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Type: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub LevelId: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub ReasonFlags: USHORT,
    #[doc = "offset: 0x38 (56)"]
    pub InitiateWakeStamp: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub PreviousStatus: LONG,
    #[doc = "offset: 0x44 (68)"]
    pub PreviousCancelReason: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub PrimaryProcessorMask: _KAFFINITY_EX,
    #[doc = "offset: 0x54 (84)"]
    pub SecondaryProcessorMask: _KAFFINITY_EX,
    pub IdlePrepare:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _PROCESSOR_IDLE_PREPARE_INFO)>,
    pub IdlePreExecute: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: ULONG,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut ULONG,
        ) -> LONG,
    >,
    pub IdleExecute: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: ULONGLONG,
            arg3: ULONG,
            arg4: ULONG,
            arg5: ULONG,
            arg6: *mut ULONG,
        ) -> LONG,
    >,
    pub IdlePreselect: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _PROCESSOR_IDLE_CONSTRAINTS) -> ULONG,
    >,
    #[doc = "offset: 0x70 (112)"]
    pub IdleTest: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG, arg3: ULONG) -> ULONG,
    >,
    #[doc = "offset: 0x74 (116)"]
    pub IdleAvailabilityCheck:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG) -> ULONG>,
    pub IdleComplete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: ULONG,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut ULONG,
        ),
    >,
    #[doc = "offset: 0x7c (124)"]
    pub IdleCancel: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG)>,
    #[doc = "offset: 0x80 (128)"]
    pub IdleIsHalted: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID) -> UCHAR>,
    #[doc = "offset: 0x84 (132)"]
    pub IdleInitiateWake: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID) -> UCHAR>,
    #[doc = "offset: 0x88 (136)"]
    pub PrepareInfo: _PROCESSOR_IDLE_PREPARE_INFO,
    #[doc = "offset: 0xd8 (216)"]
    pub DeepIdleSnapshot: _KAFFINITY_EX,
    #[doc = "offset: 0xe4 (228)"]
    pub Tracing: *mut _PERFINFO_PPM_STATE_SELECTION,
    #[doc = "offset: 0xe8 (232)"]
    pub CoordinatedTracing: *mut _PERFINFO_PPM_STATE_SELECTION,
    #[doc = "offset: 0xec (236)"]
    pub ProcessorMenu: _PPM_SELECTION_MENU,
    #[doc = "offset: 0xf4 (244)"]
    pub CoordinatedMenu: _PPM_SELECTION_MENU,
    #[doc = "offset: 0xfc (252)"]
    pub CoordinatedSelection: _PPM_COORDINATED_SELECTION,
    #[doc = "offset: 0x10c (268)"]
    pub State: [_PPM_IDLE_STATE; 1usize],
}
impl Default for _PPM_IDLE_STATES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER_EXPIRATION_TRACE {
    #[doc = "offset: 0x0 (0)"]
    pub InterruptTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub PerformanceCounter: _LARGE_INTEGER,
}
impl Default for _KTIMER_EXPIRATION_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_IDLE_SNAP {
    #[doc = "offset: 0x0 (0)"]
    pub Time: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Idle: ULONGLONG,
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PPM_FFH_THROTTLE_STATE_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub EnableLogging: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub MismatchCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Initialized: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub LastValue: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub LastLogTickCount: _LARGE_INTEGER,
}
impl Default for _PPM_FFH_THROTTLE_STATE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x54 (84) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KSPECIAL_REGISTERS {
    #[doc = "offset: 0x0 (0)"]
    pub Cr0: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Cr2: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Cr3: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub Cr4: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub KernelDr0: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub KernelDr1: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub KernelDr2: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub KernelDr3: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub KernelDr6: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub KernelDr7: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Gdtr: _DESCRIPTOR,
    #[doc = "offset: 0x30 (48)"]
    pub Idtr: _DESCRIPTOR,
    #[doc = "offset: 0x38 (56)"]
    pub Tr: USHORT,
    #[doc = "offset: 0x3a (58)"]
    pub Ldtr: USHORT,
    #[doc = "offset: 0x3c (60)"]
    pub Xcr0: ULONGLONG,
    #[doc = "offset: 0x44 (68)"]
    pub ExceptionList: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub Reserved: [ULONG; 3usize],
}
#[doc = "0x320 (800) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESSOR_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub ContextFrame: _CONTEXT,
    #[doc = "offset: 0x2cc (716)"]
    pub SpecialRegisters: _KSPECIAL_REGISTERS,
}
impl Default for _KPROCESSOR_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x140 (320) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSHARED_READY_QUEUE {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ReadySummary: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ReadyListHead: [_LIST_ENTRY; 32usize],
    #[doc = "offset: 0x108 (264)"]
    pub RunningSummary: [CHAR; 32usize],
    #[doc = "offset: 0x128 (296)"]
    pub Span: UCHAR,
    #[doc = "offset: 0x129 (297)"]
    pub LowProcIndex: UCHAR,
    #[doc = "offset: 0x12a (298)"]
    pub QueueIndex: UCHAR,
    #[doc = "offset: 0x12b (299)"]
    pub ProcCount: UCHAR,
    #[doc = "offset: 0x12c (300)"]
    pub ScanOwner: UCHAR,
    #[doc = "offset: 0x12d (301)"]
    pub Spare: [UCHAR; 3usize],
    #[doc = "offset: 0x130 (304)"]
    pub Affinity: ULONG,
    #[doc = "offset: 0x134 (308)"]
    pub ReadyThreadCount: ULONG,
    #[doc = "offset: 0x138 (312)"]
    pub ReadyQueueExpectedRunTime: ULONGLONG,
}
impl Default for _KSHARED_READY_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa8 (168) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_INSTANCE {
    #[doc = "offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MutexEvent: *mut _KEVENT,
    #[doc = "offset: 0x8 (8)"]
    pub Name: *mut WCHAR,
    #[doc = "offset: 0xc (12)"]
    pub OrderingName: *mut WCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub ResourceType: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub Allocation: *mut _RTL_RANGE_LIST,
    #[doc = "offset: 0x18 (24)"]
    pub PossibleAllocation: *mut _RTL_RANGE_LIST,
    #[doc = "offset: 0x1c (28)"]
    pub OrderingList: _ARBITER_ORDERING_LIST,
    #[doc = "offset: 0x24 (36)"]
    pub ReservedList: _ARBITER_ORDERING_LIST,
    #[doc = "offset: 0x2c (44)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x30 (48)"]
    pub Interface: *mut _ARBITER_INTERFACE,
    #[doc = "offset: 0x34 (52)"]
    pub AllocationStackMaxSize: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub AllocationStack: *mut _ARBITER_ALLOCATION_STATE,
    pub UnpackRequirement: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _IO_RESOURCE_DESCRIPTOR,
            arg2: *mut ULONGLONG,
            arg3: *mut ULONGLONG,
            arg4: *mut ULONGLONG,
            arg5: *mut ULONGLONG,
        ) -> LONG,
    >,
    pub PackResource: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _IO_RESOURCE_DESCRIPTOR,
            arg2: ULONGLONG,
            arg3: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
        ) -> LONG,
    >,
    pub UnpackResource: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
            arg2: *mut ULONGLONG,
            arg3: *mut ULONGLONG,
        ) -> LONG,
    >,
    pub ScoreRequirement:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _IO_RESOURCE_DESCRIPTOR) -> LONG>,
    pub TestAllocation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_TEST_ALLOCATION_PARAMETERS,
        ) -> LONG,
    >,
    pub RetestAllocation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_RETEST_ALLOCATION_PARAMETERS,
        ) -> LONG,
    >,
    #[doc = "offset: 0x54 (84)"]
    pub CommitAllocation:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE) -> LONG>,
    pub RollbackAllocation:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE) -> LONG>,
    pub BootAllocation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_BOOT_ALLOCATION_PARAMETERS,
        ) -> LONG,
    >,
    pub QueryArbitrate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_QUERY_ARBITRATE_PARAMETERS,
        ) -> LONG,
    >,
    pub QueryConflict: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_QUERY_CONFLICT_PARAMETERS,
        ) -> LONG,
    >,
    pub AddReserved: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ADD_RESERVED_PARAMETERS,
        ) -> LONG,
    >,
    pub StartArbiter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE, arg2: *mut _CM_RESOURCE_LIST) -> LONG,
    >,
    pub PreprocessEntry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> LONG,
    >,
    pub AllocateEntry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> LONG,
    >,
    pub GetNextAllocationRange: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> UCHAR,
    >,
    pub FindSuitableRange: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> UCHAR,
    >,
    pub AddAllocation: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE, arg2: *mut _ARBITER_ALLOCATION_STATE),
    >,
    pub BacktrackAllocation: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE, arg2: *mut _ARBITER_ALLOCATION_STATE),
    >,
    pub OverrideConflict: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> UCHAR,
    >,
    pub InitializeRangeList: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: ULONG,
            arg3: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
            arg4: *mut _RTL_RANGE_LIST,
        ) -> LONG,
    >,
    #[doc = "offset: 0x90 (144)"]
    pub TransactionInProgress: UCHAR,
    #[doc = "offset: 0x94 (148)"]
    pub TransactionEvent: *mut _KEVENT,
    #[doc = "offset: 0x98 (152)"]
    pub Extension: *mut VOID,
    #[doc = "offset: 0x9c (156)"]
    pub BusDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0xa0 (160)"]
    pub ConflictCallbackContext: *mut VOID,
    pub ConflictCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _RTL_RANGE) -> UCHAR,
    >,
}
impl Default for _ARBITER_INSTANCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_SILO_TRACING_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub ProcessorBuffers: *mut _EX_FAST_REF,
    #[doc = "offset: 0x4 (4)"]
    pub EventsLoggedCount: *mut ULONGLONG,
}
impl Default for _ETW_SILO_TRACING_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROC_FEEDBACK_COUNTER {
    pub __bindgen_anon_1: _PROC_FEEDBACK_COUNTER__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub LastActualCount: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub LastReferenceCount: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CachedValue: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Affinitized: UCHAR,
    #[doc = "offset: 0x21 (33)"]
    pub Differential: UCHAR,
    #[doc = "offset: 0x22 (34)"]
    pub DiscardIdleTime: UCHAR,
    #[doc = "offset: 0x23 (35)"]
    pub Scaling: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub Context: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROC_FEEDBACK_COUNTER__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub InstantaneousRead:
        ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: *mut ULONG)>,
    pub DifferentialRead: ::std::option::Option<
        unsafe extern "C" fn(arg1: ULONG, arg2: UCHAR, arg3: *mut ULONGLONG, arg4: *mut ULONGLONG),
    >,
}
impl Default for _PROC_FEEDBACK_COUNTER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PROC_FEEDBACK_COUNTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x6 (6)"]
    pub CpuId: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Next: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Depth: USHORT,
}
impl Default for _SLIST_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SLIST_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_KERNEL_GLOBALS {
    #[doc = "offset: 0x0 (0)"]
    pub AccessBufferAgeThreshold: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub AccessBufferRef: _EX_RUNDOWN_REF,
    #[doc = "offset: 0xc (12)"]
    pub AccessBufferExistsEvent: _KEVENT,
    #[doc = "offset: 0x1c (28)"]
    pub AccessBufferMax: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub AccessBufferList: _SLIST_HEADER,
    #[doc = "offset: 0x28 (40)"]
    pub StreamSequenceNumber: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub ScenarioPrefetchCount: LONG,
}
impl Default for _PF_KERNEL_GLOBALS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_LOOKASIDE {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _SLIST_HEADER,
    #[doc = "offset: 0x8 (8)"]
    pub Depth: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub MaximumDepth: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub TotalAllocates: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AllocateMisses: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub TotalFrees: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FreeMisses: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub LastTotalAllocates: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub LastAllocateMisses: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Counters: [ULONG; 2usize],
}
impl Default for _HEAP_LOOKASIDE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHED_KSTACK_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub SListHead: _SLIST_HEADER,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumFree: LONG,
    #[doc = "offset: 0xc (12)"]
    pub Misses: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub MissesLast: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub AllStacksInUse: ULONG,
}
impl Default for _CACHED_KSTACK_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb0 (176) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SYSTEM_NODE_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub PagedPoolSListHead: _SLIST_HEADER,
    #[doc = "offset: 0x8 (8)"]
    pub NonPagedPoolSListHead: [_SLIST_HEADER; 3usize],
    #[doc = "offset: 0x20 (32)"]
    pub NonPagedPoolSListHeadNx: [_SLIST_HEADER; 3usize],
    #[doc = "offset: 0x38 (56)"]
    pub CachedKernelStacks: [_CACHED_KSTACK_LIST; 2usize],
    #[doc = "offset: 0x68 (104)"]
    pub NonPagedPoolLowestPage: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub NonPagedPoolHighestPage: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub AllocatedNonPagedPool: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub PartialLargePoolRegions: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub PagesInPartialLargePoolRegions: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub CachedNonPagedPoolCount: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub NonPagedPoolSpinLock: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub CachedNonPagedPool: *mut _MMPFN,
    #[doc = "offset: 0x88 (136)"]
    pub NonPagedPoolFirstVa: *mut VOID,
    #[doc = "offset: 0x8c (140)"]
    pub NonPagedPoolLastVa: *mut VOID,
    #[doc = "offset: 0x90 (144)"]
    pub NonPagedBitMap: [_RTL_BITMAP; 3usize],
    #[doc = "offset: 0xa8 (168)"]
    pub NonPagedHint: [ULONG; 2usize],
}
impl Default for _MI_SYSTEM_NODE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_HARDWARE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub NodeMask: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NumaLastRangeIndex: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub NumaTableCaptured: UCHAR,
    #[doc = "offset: 0x9 (9)"]
    pub NodeShift: UCHAR,
    #[doc = "offset: 0xa (10)"]
    pub ChannelShift: UCHAR,
    #[doc = "offset: 0xc (12)"]
    pub NodeGraph: *mut USHORT,
    #[doc = "offset: 0x10 (16)"]
    pub SystemNodeInformation: *mut _MI_SYSTEM_NODE_INFORMATION,
    #[doc = "offset: 0x14 (20)"]
    pub NumaMemoryRanges: *mut _HAL_NODE_RANGE,
    #[doc = "offset: 0x18 (24)"]
    pub ChannelMemoryRanges: *mut _HAL_CHANNEL_MEMORY_RANGES,
    #[doc = "offset: 0x1c (28)"]
    pub SecondLevelCacheSize: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub FirstLevelCacheSize: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub PhysicalAddressBits: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub TotalPagesAllowed: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub SecondaryColorMask: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub SecondaryColors: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub MediumPageColors: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub FlushTbForAttributeChange: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub FlushCacheForAttributeChange: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub FlushCacheForPageAttributeChange: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub CacheFlushPromoteThreshold: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub FlushTbThreshold: ULONG,
    pub OptimalZeroingAttribute: [[_MI_PFN_CACHE_ATTRIBUTE; 4usize]; 4usize],
    #[doc = "offset: 0x8c (140)"]
    pub AttributeChangeRequiresReZero: UCHAR,
    #[doc = "offset: 0x90 (144)"]
    pub ZeroCostCounts: [_MI_ZERO_COST_COUNTS; 2usize],
    #[doc = "offset: 0xb0 (176)"]
    pub HighestPossiblePhysicalPage: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub EnclaveRegions: _RTL_AVL_TREE,
    #[doc = "offset: 0xb8 (184)"]
    pub VsmKernelPageCount: ULONG,
}
impl Default for _MI_HARDWARE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PAGING_IO_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub PageFileHead: _RTL_AVL_TREE,
    #[doc = "offset: 0x4 (4)"]
    pub PageFileHeadSpinLock: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub PrefetchSeekThreshold: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub InPageSupportSListHead: [_SLIST_HEADER; 2usize],
    #[doc = "offset: 0x20 (32)"]
    pub InPageSupportSListMinimum: [UCHAR; 2usize],
    #[doc = "offset: 0x24 (36)"]
    pub InPageSinglePages: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub DelayPageFaults: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub FileCompressionBoundary: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub MdlsAdjusted: UCHAR,
}
impl Default for _MI_PAGING_IO_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PROCESS_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub SystemDllBase: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub ColorSeed: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub RotatingUniprocessorNumber: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub CriticalSectionTimeout: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub ProcessList: _LIST_ENTRY,
    #[doc = "offset: 0x20 (32)"]
    pub SharedUserDataPte: *mut _MMPTE,
    #[doc = "offset: 0x24 (36)"]
    pub VadSecureCookie: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub FreePaeEntries: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub FirstFreePae: _PAE_ENTRY,
    #[doc = "offset: 0x50 (80)"]
    pub AllocatedPaePages: LONG,
    #[doc = "offset: 0x54 (84)"]
    pub PaeLock: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub PaeEntrySList: _SLIST_HEADER,
}
impl Default for _MI_PROCESS_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb0 (176) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VF_TARGET_VERIFIED_DRIVER_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub SuspectDriverEntry: *mut _VF_SUSPECT_DRIVER_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub WMICallback: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub EtwHandlesListHead: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub u1: _VF_TARGET_VERIFIED_DRIVER_DATA__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub Signature: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PoolPageHeaders: _SLIST_HEADER,
    #[doc = "offset: 0x20 (32)"]
    pub PoolTrackers: _SLIST_HEADER,
    #[doc = "offset: 0x28 (40)"]
    pub CurrentPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub CurrentNonPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub PeakPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub PeakNonPagedPoolAllocations: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub PagedBytes: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub NonPagedBytes: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub PeakPagedBytes: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub PeakNonPagedBytes: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub RaiseIrqls: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub AcquireSpinLocks: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub SynchronizeExecutions: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub AllocationsWithNoTag: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub AllocationsFailed: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub AllocationsFailedDeliberately: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub LockedBytes: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub PeakLockedBytes: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub MappedLockedBytes: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub PeakMappedLockedBytes: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub MappedIoSpaceBytes: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub PeakMappedIoSpaceBytes: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub PagesForMdlBytes: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub PeakPagesForMdlBytes: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub ContiguousMemoryBytes: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub PeakContiguousMemoryBytes: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub ContiguousMemoryListHead: _LIST_ENTRY,
    #[doc = "offset: 0x90 (144)"]
    pub ExecutePoolTypes: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub ExecutePageProtections: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub ExecutePageMappings: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub ExecuteWriteSections: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub SectionAlignmentFailures: ULONG,
    #[doc = "offset: 0xa4 (164)"]
    pub UnsupportedRelocs: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub IATInExecutableSection: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VF_TARGET_VERIFIED_DRIVER_DATA__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub Flags: _VF_TARGET_VERIFIED_DRIVER_DATA__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub Whole: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VF_TARGET_VERIFIED_DRIVER_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VF_TARGET_VERIFIED_DRIVER_DATA__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MissedEtwRegistration(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MissedEtwRegistration(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MissedEtwRegistration: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MissedEtwRegistration: u32 =
                unsafe { ::std::mem::transmute(MissedEtwRegistration) };
            MissedEtwRegistration as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VF_TARGET_VERIFIED_DRIVER_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VF_TARGET_VERIFIED_DRIVER_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VF_TARGET_DRIVER {
    #[doc = "offset: 0x0 (0)"]
    pub TreeNode: _VF_AVL_TREE_NODE_EX,
    #[doc = "offset: 0xc (12)"]
    pub u1: _VF_TARGET_DRIVER__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub VerifiedData: *mut _VF_TARGET_VERIFIED_DRIVER_DATA,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VF_TARGET_DRIVER__bindgen_ty_1 {
    #[doc = "offset: 0xc (12)"]
    pub AllSharedExportThunks: _VF_TARGET_ALL_SHARED_EXPORT_THUNKS,
    #[doc = "offset: 0xc (12)"]
    pub Flags: _VF_TARGET_DRIVER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VF_TARGET_DRIVER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VF_TARGET_DRIVER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SnapSharedExportsFailed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SnapSharedExportsFailed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SnapSharedExportsFailed: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SnapSharedExportsFailed: u32 =
                unsafe { ::std::mem::transmute(SnapSharedExportsFailed) };
            SnapSharedExportsFailed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VF_TARGET_DRIVER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VF_TARGET_DRIVER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x7c0 (1984) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION_PAGE_LISTS {
    #[doc = "offset: 0x0 (0)"]
    pub FreePagesByColor: [*mut _MMPFNLIST; 2usize],
    #[doc = "offset: 0x40 (64)"]
    pub ZeroedPageListHead: _MMPFNLIST,
    #[doc = "offset: 0x80 (128)"]
    pub FreePageListHead: _MMPFNLIST,
    #[doc = "offset: 0xc0 (192)"]
    pub StandbyPageListHead: _MMPFNLIST,
    #[doc = "offset: 0x100 (256)"]
    pub StandbyPageListByPriority: [_MMPFNLIST; 8usize],
    #[doc = "offset: 0x1c0 (448)"]
    pub ModifiedPageListNoReservation: _MMPFNLIST,
    #[doc = "offset: 0x200 (512)"]
    pub ModifiedPageListByReservation: [_MMPFNLIST; 16usize],
    #[doc = "offset: 0x340 (832)"]
    pub MappedPageListHead: [_MMPFNLIST; 16usize],
    #[doc = "offset: 0x480 (1152)"]
    pub BadPageListHead: _MMPFNLIST,
    #[doc = "offset: 0x4c0 (1216)"]
    pub EnclavePageListHead: _MMPFNLIST,
    #[doc = "offset: 0x4d4 (1236)"]
    pub FreePageSlist: [*mut _SLIST_HEADER; 2usize],
    #[doc = "offset: 0x4dc (1244)"]
    pub PageLocationList: [*mut _MMPFNLIST; 8usize],
    #[doc = "offset: 0x4fc (1276)"]
    pub StandbyRepurposedByPriority: [ULONG; 8usize],
    #[doc = "offset: 0x540 (1344)"]
    pub TransitionSharedPages: ULONG,
    #[doc = "offset: 0x544 (1348)"]
    pub TransitionSharedPagesPeak: [ULONG; 3usize],
    #[doc = "offset: 0x550 (1360)"]
    pub MappedPageListHeadEvent: [_KEVENT; 16usize],
    #[doc = "offset: 0x650 (1616)"]
    pub DecayClusterTimerHeads: [_MI_DECAY_TIMER_LINK; 4usize],
    #[doc = "offset: 0x660 (1632)"]
    pub DecayHand: ULONG,
    #[doc = "offset: 0x664 (1636)"]
    pub StandbyListDiscard: UCHAR,
    #[doc = "offset: 0x665 (1637)"]
    pub FreeListDiscard: UCHAR,
    #[doc = "offset: 0x666 (1638)"]
    pub LargePfnBitMapsReady: UCHAR,
    #[doc = "offset: 0x668 (1640)"]
    pub LastDecayHandUpdateTime: ULONGLONG,
    #[doc = "offset: 0x670 (1648)"]
    pub LastChanceLdwContext: _MI_LDW_WORK_CONTEXT,
    #[doc = "offset: 0x6c0 (1728)"]
    pub AvailableEventsLock: ULONG,
    #[doc = "offset: 0x6c4 (1732)"]
    pub AvailablePageWaitStates: [_MI_AVAILABLE_PAGE_WAIT_STATES; 3usize],
    #[doc = "offset: 0x700 (1792)"]
    pub MirrorListLocks: *mut VOID,
    #[doc = "offset: 0x740 (1856)"]
    pub TransitionPrivatePages: ULONG,
    #[doc = "offset: 0x744 (1860)"]
    pub LargePfnBitMap: [_RTL_BITMAP; 1usize],
    #[doc = "offset: 0x74c (1868)"]
    pub LowMemoryThreshold: ULONG,
    #[doc = "offset: 0x750 (1872)"]
    pub HighMemoryThreshold: ULONG,
    #[doc = "offset: 0x780 (1920)"]
    pub LargePfnBitMapLock: ULONG,
}
impl Default for _MI_PARTITION_PAGE_LISTS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x288 (648) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_STACK_TRACE_BLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub Flags: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub RelatedTimestamp: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0x14 (20)"]
    pub StackWalkDpc: _KDPC,
    #[doc = "offset: 0x38 (56)"]
    pub ApcListHead: _SLIST_HEADER,
    #[doc = "offset: 0x40 (64)"]
    pub ApcEntry: [_ETW_APC_ENTRY; 12usize],
    #[doc = "offset: 0x280 (640)"]
    pub ApcCount: LONG,
    #[doc = "offset: 0x284 (644)"]
    pub MaxApcCount: LONG,
}
impl Default for _ETW_STACK_TRACE_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub Depth: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub MaximumDepth: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE__bindgen_ty_2,
    #[doc = "offset: 0x14 (20)"]
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE__bindgen_ty_3,
    #[doc = "offset: 0x1c (28)"]
    pub Type: _POOL_TYPE,
    #[doc = "offset: 0x20 (32)"]
    pub Tag: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE__bindgen_ty_5,
    #[doc = "offset: 0x30 (48)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x38 (56)"]
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE__bindgen_ty_6,
    #[doc = "offset: 0x40 (64)"]
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _SLIST_HEADER,
    #[doc = "offset: 0x0 (0)"]
    pub SingleListHead: _SINGLE_LIST_ENTRY,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_2 {
    #[doc = "offset: 0x10 (16)"]
    pub AllocateMisses: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_3 {
    #[doc = "offset: 0x18 (24)"]
    pub FreeMisses: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FreeHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_4 {
    pub AllocateEx: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: _POOL_TYPE,
            arg2: ULONG,
            arg3: ULONG,
            arg4: *mut _LOOKASIDE_LIST_EX,
        ) -> *mut VOID,
    >,
    pub Allocate: ::std::option::Option<
        unsafe extern "C" fn(arg1: _POOL_TYPE, arg2: ULONG, arg3: ULONG) -> *mut VOID,
    >,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_5 {
    pub FreeEx:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _LOOKASIDE_LIST_EX)>,
    #[doc = "offset: 0x2c (44)"]
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_6 {
    #[doc = "offset: 0x3c (60)"]
    pub LastAllocateMisses: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub LastAllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _GENERAL_LOOKASIDE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PAGED_LOOKASIDE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub L: _GENERAL_LOOKASIDE,
    #[doc = "offset: 0x80 (128)"]
    pub Lock__ObsoleteButDoNotDelete: _FAST_MUTEX,
}
impl Default for _PAGED_LOOKASIDE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NPAGED_LOOKASIDE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub L: _GENERAL_LOOKASIDE,
    #[doc = "offset: 0x80 (128)"]
    pub Lock__ObsoleteButDoNotDelete: ULONG,
}
impl Default for _NPAGED_LOOKASIDE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x180 (384) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SYSTEM_PTE_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub MdlTrackerLookaside: _NPAGED_LOOKASIDE_LIST,
    #[doc = "offset: 0xc0 (192)"]
    pub DeadPteTrackerSListHead: _SLIST_HEADER,
    #[doc = "offset: 0xc8 (200)"]
    pub PteTrackerLock: ULONG,
    #[doc = "offset: 0xcc (204)"]
    pub PteTrackingBitmap: _RTL_BITMAP,
    #[doc = "offset: 0xd4 (212)"]
    pub CachedPteHeads: *mut _MI_CACHED_PTES,
    #[doc = "offset: 0xd8 (216)"]
    pub CachedKernelStackPteHeads: *mut _MI_CACHED_PTES,
    #[doc = "offset: 0xdc (220)"]
    pub SystemViewPteInfo: _MI_SYSTEM_PTE_TYPE,
    #[doc = "offset: 0x114 (276)"]
    pub KernelStackPteInfo: _MI_SYSTEM_PTE_TYPE,
    #[doc = "offset: 0x14c (332)"]
    pub StackGrowthFailures: ULONG,
    #[doc = "offset: 0x150 (336)"]
    pub KernelStackPages: UCHAR,
    #[doc = "offset: 0x151 (337)"]
    pub TrackPtesAborted: UCHAR,
    #[doc = "offset: 0x152 (338)"]
    pub AdjustCounter: UCHAR,
    #[doc = "offset: 0x154 (340)"]
    pub ReservedMappingLock: LONG,
    #[doc = "offset: 0x158 (344)"]
    pub ReservedMappingTree: _RTL_AVL_TREE,
    #[doc = "offset: 0x15c (348)"]
    pub ReservedMappingPageTablePfns: *mut _MMPFN,
    #[doc = "offset: 0x160 (352)"]
    pub OutswappedKernelStackRoot: _RTL_AVL_TREE,
    #[doc = "offset: 0x164 (356)"]
    pub OutswappedKernelStackLock: LONG,
}
impl Default for _MI_SYSTEM_PTE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x7000 (28672) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_SESSION_SPACE {
    #[doc = "offset: 0x0 (0)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub u: _MM_SESSION_SPACE__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub SessionId: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ProcessReferenceToSession: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub ProcessList: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub SessionPageDirectoryIndex: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub NonPagablePages: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub CommittedPages: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub PagedPoolStart: *mut VOID,
    #[doc = "offset: 0x28 (40)"]
    pub PagedPoolEnd: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub SessionObject: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub SessionObjectHandle: *mut VOID,
    #[doc = "offset: 0x34 (52)"]
    pub SessionPoolAllocationFailures: [ULONG; 4usize],
    #[doc = "offset: 0x44 (68)"]
    pub ImageTree: _RTL_AVL_TREE,
    #[doc = "offset: 0x48 (72)"]
    pub LocaleId: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub AttachCount: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub AttachGate: _KGATE,
    #[doc = "offset: 0x60 (96)"]
    pub WsListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x68 (104)"]
    pub PagedPoolInfo: _MM_PAGED_POOL_INFO,
    #[doc = "offset: 0xc0 (192)"]
    pub Lookaside: [_GENERAL_LOOKASIDE; 24usize],
    #[doc = "offset: 0xcc0 (3264)"]
    pub Session: _MMSESSION,
    #[doc = "offset: 0xd00 (3328)"]
    pub Vm: _MMSUPPORT_FULL,
    #[doc = "offset: 0xdc0 (3520)"]
    pub WorkingSetList: _MMWSL_INSTANCE,
    #[doc = "offset: 0xe00 (3584)"]
    pub PagedPool: _POOL_DESCRIPTOR,
    #[doc = "offset: 0x1f40 (8000)"]
    pub DriverUnload: _MI_SESSION_DRIVER_UNLOAD,
    #[doc = "offset: 0x1f48 (8008)"]
    pub PageTables: [_MMPTE; 1024usize],
    #[doc = "offset: 0x3f48 (16200)"]
    pub PagedPoolBitBuffer: [ULONG; 32usize],
    #[doc = "offset: 0x3fc8 (16328)"]
    pub SpecialPool: _MI_SPECIAL_POOL,
    #[doc = "offset: 0x4008 (16392)"]
    pub SessionPteLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x400c (16396)"]
    pub PoolBigEntriesInUse: LONG,
    #[doc = "offset: 0x4010 (16400)"]
    pub PagedPoolPdeCount: ULONG,
    #[doc = "offset: 0x4014 (16404)"]
    pub SpecialPoolPdeCount: ULONG,
    #[doc = "offset: 0x4018 (16408)"]
    pub DynamicSessionPdeCount: ULONG,
    #[doc = "offset: 0x401c (16412)"]
    pub SystemPteInfo: _MI_SYSTEM_PTE_TYPE,
    #[doc = "offset: 0x4054 (16468)"]
    pub PoolTrackTableExpansion: *mut VOID,
    #[doc = "offset: 0x4058 (16472)"]
    pub PoolTrackTableExpansionSize: ULONG,
    #[doc = "offset: 0x405c (16476)"]
    pub PoolTrackBigPages: *mut VOID,
    #[doc = "offset: 0x4060 (16480)"]
    pub PoolTrackBigPagesSize: ULONG,
    #[doc = "offset: 0x4064 (16484)"]
    pub IoState: _IO_SESSION_STATE,
    #[doc = "offset: 0x4068 (16488)"]
    pub IoStateSequence: ULONG,
    #[doc = "offset: 0x406c (16492)"]
    pub IoNotificationEvent: _KEVENT,
    #[doc = "offset: 0x407c (16508)"]
    pub ServerSilo: *mut _EJOB,
    #[doc = "offset: 0x4080 (16512)"]
    pub CreateTime: ULONGLONG,
    #[doc = "offset: 0x5000 (20480)"]
    pub PoolTags: [UCHAR; 8192usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_SESSION_SPACE__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub LongFlags: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Flags: _MM_SESSION_SPACE_FLAGS,
}
impl Default for _MM_SESSION_SPACE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_SESSION_SPACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PP_LOOKASIDE_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub P: *mut _GENERAL_LOOKASIDE,
    #[doc = "offset: 0x4 (4)"]
    pub L: *mut _GENERAL_LOOKASIDE,
}
impl Default for _PP_LOOKASIDE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE_POOL {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE_POOL__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub Depth: USHORT,
    #[doc = "offset: 0xa (10)"]
    pub MaximumDepth: USHORT,
    #[doc = "offset: 0xc (12)"]
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE_POOL__bindgen_ty_2,
    #[doc = "offset: 0x14 (20)"]
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE_POOL__bindgen_ty_3,
    #[doc = "offset: 0x1c (28)"]
    pub Type: _POOL_TYPE,
    #[doc = "offset: 0x20 (32)"]
    pub Tag: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE_POOL__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE_POOL__bindgen_ty_5,
    #[doc = "offset: 0x30 (48)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x38 (56)"]
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE_POOL__bindgen_ty_6,
    #[doc = "offset: 0x40 (64)"]
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub ListHead: _SLIST_HEADER,
    #[doc = "offset: 0x0 (0)"]
    pub SingleListHead: _SINGLE_LIST_ENTRY,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    #[doc = "offset: 0x10 (16)"]
    pub AllocateMisses: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    #[doc = "offset: 0x18 (24)"]
    pub FreeMisses: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FreeHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    pub AllocateEx: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: _POOL_TYPE,
            arg2: ULONG,
            arg3: ULONG,
            arg4: *mut _LOOKASIDE_LIST_EX,
        ) -> *mut VOID,
    >,
    pub Allocate: ::std::option::Option<
        unsafe extern "C" fn(arg1: _POOL_TYPE, arg2: ULONG, arg3: ULONG) -> *mut VOID,
    >,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    pub FreeEx:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _LOOKASIDE_LIST_EX)>,
    #[doc = "offset: 0x2c (44)"]
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    #[doc = "offset: 0x3c (60)"]
    pub LastAllocateMisses: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub LastAllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _GENERAL_LOOKASIDE_POOL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOOKASIDE_LIST_EX {
    #[doc = "offset: 0x0 (0)"]
    pub L: _GENERAL_LOOKASIDE_POOL,
}
impl Default for _LOOKASIDE_LIST_EX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER_TABLE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Entry: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub Time: _ULARGE_INTEGER,
}
impl Default for _KTIMER_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub DueTime: _ULARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub TimerListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x20 (32)"]
    pub Dpc: *mut _KDPC,
    #[doc = "offset: 0x24 (36)"]
    pub Period: ULONG,
}
impl Default for _KTIMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LAZY_WRITER {
    #[doc = "offset: 0x0 (0)"]
    pub ScanDpc: _KDPC,
    #[doc = "offset: 0x20 (32)"]
    pub ScanTimer: _KTIMER,
    #[doc = "offset: 0x48 (72)"]
    pub ScanActive: UCHAR,
    #[doc = "offset: 0x49 (73)"]
    pub OtherWork: UCHAR,
    #[doc = "offset: 0x4a (74)"]
    pub PendingTeardownScan: UCHAR,
    #[doc = "offset: 0x4b (75)"]
    pub PendingPeriodicScan: UCHAR,
    #[doc = "offset: 0x4c (76)"]
    pub PendingLowMemoryScan: UCHAR,
    #[doc = "offset: 0x4d (77)"]
    pub PendingPowerScan: UCHAR,
    #[doc = "offset: 0x4e (78)"]
    pub PendingCoalescingFlushScan: UCHAR,
}
impl Default for _LAZY_WRITER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x280 (640) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CC_PARTITION {
    #[doc = "offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NodeByteSize: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub PartitionObject: *mut _EPARTITION,
    #[doc = "offset: 0x8 (8)"]
    pub CleanSharedCacheMapList: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub CleanSharedCacheMapWithLogHandleList: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub DirtySharedCacheMapList: _SHARED_CACHE_MAP_LIST_CURSOR,
    #[doc = "offset: 0x24 (36)"]
    pub LazyWriteCursor: _SHARED_CACHE_MAP_LIST_CURSOR,
    #[doc = "offset: 0x30 (48)"]
    pub DirtySharedCacheMapWithLogHandleList: _LIST_ENTRY,
    #[doc = "offset: 0x40 (64)"]
    pub PrivateLock: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub ConsecutiveWorklessLazyScanCount: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub ForcedDisableLazywriteScan: UCHAR,
    #[doc = "offset: 0x80 (128)"]
    pub WorkQueueLock: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub NumberWorkerThreads: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub NumberActiveWorkerThreads: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub IdleWorkerThreadList: _LIST_ENTRY,
    #[doc = "offset: 0x94 (148)"]
    pub FastTeardownWorkQueue: _LIST_ENTRY,
    #[doc = "offset: 0x9c (156)"]
    pub ExpressWorkQueue: _LIST_ENTRY,
    #[doc = "offset: 0xa4 (164)"]
    pub RegularWorkQueue: _LIST_ENTRY,
    #[doc = "offset: 0xac (172)"]
    pub PostTickWorkQueue: _LIST_ENTRY,
    #[doc = "offset: 0xb4 (180)"]
    pub IdleExtraWriteBehindThreadList: _LIST_ENTRY,
    #[doc = "offset: 0xbc (188)"]
    pub ActiveExtraWriteBehindThreads: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub MaxExtraWriteBehindThreads: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub QueueThrottle: UCHAR,
    #[doc = "offset: 0xc8 (200)"]
    pub PostTickWorkItemCount: ULONG,
    #[doc = "offset: 0xcc (204)"]
    pub ThreadsActiveBeforeThrottle: ULONG,
    #[doc = "offset: 0xd0 (208)"]
    pub ExtraWBThreadsActiveBeforeThrottle: ULONG,
    #[doc = "offset: 0xd4 (212)"]
    pub ExecutingWriteBehindWorkItems: ULONG,
    #[doc = "offset: 0xd8 (216)"]
    pub ExecutingHighPriorityWorkItem: ULONG,
    #[doc = "offset: 0xdc (220)"]
    pub LowMemoryEvent: _KEVENT,
    #[doc = "offset: 0xec (236)"]
    pub PowerEvent: _KEVENT,
    #[doc = "offset: 0xfc (252)"]
    pub PeriodicEvent: _KEVENT,
    #[doc = "offset: 0x10c (268)"]
    pub WaitingForTeardownEvent: _KEVENT,
    #[doc = "offset: 0x11c (284)"]
    pub CoalescingFlushEvent: _KEVENT,
    #[doc = "offset: 0x12c (300)"]
    pub PagesYetToWrite: ULONG,
    #[doc = "offset: 0x130 (304)"]
    pub LazyWriter: _LAZY_WRITER,
    #[doc = "offset: 0x180 (384)"]
    pub DirtyPageStatistics: _DIRTY_PAGE_STATISTICS,
    #[doc = "offset: 0x190 (400)"]
    pub DirtyPageThresholds: _DIRTY_PAGE_THRESHOLDS,
    #[doc = "offset: 0x1b8 (440)"]
    pub ThroughputStats: *mut _WRITE_BEHIND_THROUGHPUT,
    #[doc = "offset: 0x1bc (444)"]
    pub ThroughputTrend: LONG,
    #[doc = "offset: 0x1c0 (448)"]
    pub AverageAvailablePages: ULONGLONG,
    #[doc = "offset: 0x1c8 (456)"]
    pub AverageDirtyPages: ULONGLONG,
    #[doc = "offset: 0x1d0 (464)"]
    pub PagesSkippedDueToHotSpot: ULONGLONG,
    #[doc = "offset: 0x1d8 (472)"]
    pub PrevRegularQueueItemRunTime: _LARGE_INTEGER,
    #[doc = "offset: 0x1e0 (480)"]
    pub PrevExtraWBThreadCheckTime: _LARGE_INTEGER,
    #[doc = "offset: 0x1e8 (488)"]
    pub AddExtraWriteBehindThreads: UCHAR,
    #[doc = "offset: 0x1e9 (489)"]
    pub RemoveExtraThreadPending: UCHAR,
    #[doc = "offset: 0x1ec (492)"]
    pub DeferredWrites: _LIST_ENTRY,
    #[doc = "offset: 0x200 (512)"]
    pub DeferredWriteSpinLock: ULONG,
    #[doc = "offset: 0x204 (516)"]
    pub IdleAsyncReadWorkerThreadList: *mut _LIST_ENTRY,
    #[doc = "offset: 0x208 (520)"]
    pub NumberActiveAsyncReadWorkerThreads: *mut ULONG,
    #[doc = "offset: 0x20c (524)"]
    pub NumberActiveCompleteAsyncReadWorkItems: *mut ULONG,
    #[doc = "offset: 0x210 (528)"]
    pub AsyncReadWorkQueue: *mut _LIST_ENTRY,
    #[doc = "offset: 0x214 (532)"]
    pub AsyncReadCompletionWorkQueue: *mut _LIST_ENTRY,
    #[doc = "offset: 0x218 (536)"]
    pub NewAsyncReadRequestEvent: *mut _KEVENT,
    #[doc = "offset: 0x21c (540)"]
    pub ReaderThreadsStats: *mut _ASYNC_READ_THREAD_STATS,
    #[doc = "offset: 0x220 (544)"]
    pub AsyncReadWorkQueueLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x224 (548)"]
    pub VacbFreeHighPriorityList: _LIST_ENTRY,
    #[doc = "offset: 0x22c (556)"]
    pub NumberOfFreeHighPriorityVacbs: ULONG,
    #[doc = "offset: 0x230 (560)"]
    pub LowPriWorkerThread: *mut _ETHREAD,
    #[doc = "offset: 0x234 (564)"]
    pub LowPriSharedCacheMap: *mut _SHARED_CACHE_MAP,
    #[doc = "offset: 0x238 (568)"]
    pub LowPriOldCpuPriority: LONG,
    #[doc = "offset: 0x23c (572)"]
    pub LowPriOldIoPriority: _IO_PRIORITY_HINT,
    #[doc = "offset: 0x240 (576)"]
    pub LowPriorityWorkerThreadLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x244 (580)"]
    pub MaxNumberOfWriteBehindThreads: ULONG,
    #[doc = "offset: 0x248 (584)"]
    pub CoalescingState: UCHAR,
    #[doc = "offset: 0x249 (585)"]
    pub RundownStarted: UCHAR,
    #[doc = "offset: 0x24c (588)"]
    pub RefCount: LONG,
    #[doc = "offset: 0x250 (592)"]
    pub ExitEvent: _KEVENT,
    #[doc = "offset: 0x260 (608)"]
    pub FinalDereferenceEvent: _KEVENT,
    #[doc = "offset: 0x270 (624)"]
    pub LazyWriteScanThreadHandle: *mut VOID,
}
impl Default for _CC_PARTITION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEFERRED_WRITE {
    #[doc = "offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NodeByteSize: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub BytesToWrite: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DeferredWriteLinks: _LIST_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub Event: *mut _KEVENT,
    #[doc = "offset: 0x18 (24)"]
    pub PostRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID)>,
    #[doc = "offset: 0x1c (28)"]
    pub Context1: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub Context2: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub Partition: *mut _CC_PARTITION,
}
impl Default for _DEFERRED_WRITE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x178 (376) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHARED_CACHE_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub NodeByteSize: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub OpenCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub FileSize: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub BcbList: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub SectionSize: _LARGE_INTEGER,
    #[doc = "offset: 0x20 (32)"]
    pub ValidDataLength: _LARGE_INTEGER,
    #[doc = "offset: 0x28 (40)"]
    pub ValidDataGoal: _LARGE_INTEGER,
    #[doc = "offset: 0x30 (48)"]
    pub InitialVacbs: [*mut _VACB; 4usize],
    #[doc = "offset: 0x40 (64)"]
    pub Vacbs: *mut *mut _VACB,
    #[doc = "offset: 0x44 (68)"]
    pub FileObjectFastRef: _EX_FAST_REF,
    #[doc = "offset: 0x48 (72)"]
    pub VacbLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4c (76)"]
    pub DirtyPages: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub LoggedStreamLinks: _LIST_ENTRY,
    #[doc = "offset: 0x58 (88)"]
    pub SharedCacheMapLinks: _LIST_ENTRY,
    #[doc = "offset: 0x60 (96)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub Status: LONG,
    #[doc = "offset: 0x68 (104)"]
    pub Mbcb: *mut _MBCB,
    #[doc = "offset: 0x6c (108)"]
    pub Section: *mut VOID,
    #[doc = "offset: 0x70 (112)"]
    pub CreateEvent: *mut _KEVENT,
    #[doc = "offset: 0x74 (116)"]
    pub WaitOnActiveCount: *mut _KEVENT,
    #[doc = "offset: 0x78 (120)"]
    pub PagesToWrite: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub BeyondLastFlush: LONGLONG,
    #[doc = "offset: 0x88 (136)"]
    pub Callbacks: *mut _CACHE_MANAGER_CALLBACKS,
    #[doc = "offset: 0x8c (140)"]
    pub LazyWriteContext: *mut VOID,
    #[doc = "offset: 0x90 (144)"]
    pub PrivateList: _LIST_ENTRY,
    pub __bindgen_anon_1: _SHARED_CACHE_MAP__bindgen_ty_1,
    #[doc = "offset: 0xa0 (160)"]
    pub LargestLSN: _LARGE_INTEGER,
    #[doc = "offset: 0xa8 (168)"]
    pub DirtyPageThreshold: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub LazyWritePassCount: ULONG,
    #[doc = "offset: 0xb0 (176)"]
    pub UninitializeEvent: *mut _CACHE_UNINITIALIZE_EVENT,
    #[doc = "offset: 0xb4 (180)"]
    pub BcbLock: _FAST_MUTEX,
    #[doc = "offset: 0xd8 (216)"]
    pub LastUnmapBehindOffset: _LARGE_INTEGER,
    #[doc = "offset: 0xe0 (224)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0xf0 (240)"]
    pub HighWaterMappingOffset: _LARGE_INTEGER,
    #[doc = "offset: 0xf8 (248)"]
    pub PrivateCacheMap: _PRIVATE_CACHE_MAP,
    #[doc = "offset: 0x160 (352)"]
    pub WriteBehindWorkQueueEntry: *mut VOID,
    #[doc = "offset: 0x164 (356)"]
    pub VolumeCacheMap: *mut _VOLUME_CACHE_MAP,
    #[doc = "offset: 0x168 (360)"]
    pub ProcImagePathHash: ULONG,
    #[doc = "offset: 0x16c (364)"]
    pub WritesInProgress: ULONG,
    #[doc = "offset: 0x170 (368)"]
    pub AsyncReadRequestCount: ULONG,
    #[doc = "offset: 0x174 (372)"]
    pub Partition: *mut _CC_PARTITION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SHARED_CACHE_MAP__bindgen_ty_1 {
    #[doc = "offset: 0x98 (152)"]
    pub V1: _LOGGED_STREAM_CALLBACK_V1,
    #[doc = "offset: 0x98 (152)"]
    pub V2: _LOGGED_STREAM_CALLBACK_V2,
}
impl Default for _SHARED_CACHE_MAP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SHARED_CACHE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1e0 (480) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTRANSACTION {
    #[doc = "offset: 0x0 (0)"]
    pub OutcomeEvent: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub cookie: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Mutex: _KMUTANT,
    #[doc = "offset: 0x34 (52)"]
    pub TreeTx: *mut _KTRANSACTION,
    #[doc = "offset: 0x38 (56)"]
    pub GlobalNamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = "offset: 0x4c (76)"]
    pub TmNamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = "offset: 0x60 (96)"]
    pub UOW: _GUID,
    #[doc = "offset: 0x70 (112)"]
    pub State: _KTRANSACTION_STATE,
    #[doc = "offset: 0x74 (116)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub EnlistmentHead: _LIST_ENTRY,
    #[doc = "offset: 0x80 (128)"]
    pub EnlistmentCount: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub RecoverableEnlistmentCount: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub PrePrepareRequiredEnlistmentCount: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub PrepareRequiredEnlistmentCount: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub OutcomeRequiredEnlistmentCount: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub PendingResponses: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub SuperiorEnlistment: *mut _KENLISTMENT,
    #[doc = "offset: 0xa0 (160)"]
    pub LastLsn: _CLS_LSN,
    #[doc = "offset: 0xa8 (168)"]
    pub PromotedEntry: _LIST_ENTRY,
    #[doc = "offset: 0xb0 (176)"]
    pub PromoterTransaction: *mut _KTRANSACTION,
    #[doc = "offset: 0xb4 (180)"]
    pub PromotePropagation: *mut VOID,
    #[doc = "offset: 0xb8 (184)"]
    pub IsolationLevel: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub IsolationFlags: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub Timeout: _LARGE_INTEGER,
    #[doc = "offset: 0xc8 (200)"]
    pub Description: _UNICODE_STRING,
    #[doc = "offset: 0xd0 (208)"]
    pub RollbackThread: *mut _KTHREAD,
    #[doc = "offset: 0xd4 (212)"]
    pub RollbackWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0xe4 (228)"]
    pub RollbackDpc: _KDPC,
    #[doc = "offset: 0x108 (264)"]
    pub RollbackTimer: _KTIMER,
    #[doc = "offset: 0x130 (304)"]
    pub LsnOrderedEntry: _LIST_ENTRY,
    #[doc = "offset: 0x138 (312)"]
    pub Outcome: _KTRANSACTION_OUTCOME,
    #[doc = "offset: 0x13c (316)"]
    pub Tm: *mut _KTM,
    #[doc = "offset: 0x140 (320)"]
    pub CommitReservation: LONGLONG,
    #[doc = "offset: 0x148 (328)"]
    pub TransactionHistory: [_KTRANSACTION_HISTORY; 10usize],
    #[doc = "offset: 0x198 (408)"]
    pub TransactionHistoryCount: ULONG,
    #[doc = "offset: 0x19c (412)"]
    pub DTCPrivateInformation: *mut VOID,
    #[doc = "offset: 0x1a0 (416)"]
    pub DTCPrivateInformationLength: ULONG,
    #[doc = "offset: 0x1a4 (420)"]
    pub DTCPrivateInformationMutex: _KMUTANT,
    #[doc = "offset: 0x1c4 (452)"]
    pub PromotedTxSelfHandle: *mut VOID,
    #[doc = "offset: 0x1c8 (456)"]
    pub PendingPromotionCount: ULONG,
    #[doc = "offset: 0x1cc (460)"]
    pub PromotionCompletedEvent: _KEVENT,
}
impl Default for _KTRANSACTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x180 (384) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION_SEGMENTS {
    #[doc = "offset: 0x0 (0)"]
    pub SegmentListLock: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub DeleteOnCloseCount: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub FsControlAreaCount: LONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub PfControlAreaCount: LONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub DeleteSubsectionCleanup: _KEVENT,
    #[doc = "offset: 0x28 (40)"]
    pub UnusedSegmentCleanup: _KEVENT,
    #[doc = "offset: 0x38 (56)"]
    pub SubsectionDeletePtes: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub AttemptForCantExtend: _MMPAGE_FILE_EXPANSION,
    #[doc = "offset: 0x70 (112)"]
    pub DereferenceSegmentHeader: _MMDEREFERENCE_SEGMENT_HEADER,
    #[doc = "offset: 0x9c (156)"]
    pub DeleteOnCloseList: _LIST_ENTRY,
    #[doc = "offset: 0xa8 (168)"]
    pub DeleteOnCloseTimer: _KTIMER,
    #[doc = "offset: 0xd0 (208)"]
    pub DeleteOnCloseTimerActive: UCHAR,
    #[doc = "offset: 0xd1 (209)"]
    pub SegmentDereferenceThreadExists: UCHAR,
    #[doc = "offset: 0xd4 (212)"]
    pub UnusedSegmentPagedPool: ULONG,
    #[doc = "offset: 0xd8 (216)"]
    pub UnusedSegmentList: _LIST_ENTRY,
    #[doc = "offset: 0xe0 (224)"]
    pub UnusedSubsectionList: _LIST_ENTRY,
    #[doc = "offset: 0xe8 (232)"]
    pub DeleteSubsectionList: _LIST_ENTRY,
    #[doc = "offset: 0xf0 (240)"]
    pub ControlAreaDeleteEvent: _KEVENT,
    #[doc = "offset: 0x100 (256)"]
    pub ControlAreaDeleteList: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x108 (264)"]
    pub FreeSystemCache: _MI_PTE_CHAIN_HEAD,
    #[doc = "offset: 0x120 (288)"]
    pub CloneDereferenceEvent: _KEVENT,
    #[doc = "offset: 0x130 (304)"]
    pub CloneProtosSListHead: _SLIST_HEADER,
    #[doc = "offset: 0x138 (312)"]
    pub SystemCacheInitLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x13c (316)"]
    pub PagefileExtensionWaiters: ULONG,
    #[doc = "offset: 0x140 (320)"]
    pub PagefileExtensionRequests: ULONG,
    #[doc = "offset: 0x144 (324)"]
    pub PagefileExtensionWaitEvent: _KEVENT,
}
impl Default for _MI_PARTITION_SEGMENTS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_FX_WORK_ORDER_WATCHDOG_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Timer: _KTIMER,
    #[doc = "offset: 0x28 (40)"]
    pub Dpc: _KDPC,
    #[doc = "offset: 0x48 (72)"]
    pub WorkOrder: *mut _POP_FX_WORK_ORDER,
}
impl Default for _POP_FX_WORK_ORDER_WATCHDOG_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_FX_WORK_ORDER {
    #[doc = "offset: 0x0 (0)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x10 (16)"]
    pub WorkCount: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub Context: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub WatchdogTimerInfo: *mut _POP_FX_WORK_ORDER_WATCHDOG_INFO,
}
impl Default for _POP_FX_WORK_ORDER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x70 (112) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_FX_PLUGIN {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Version: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Flags: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub WorkQueue: _KQUEUE,
    pub AcceptDeviceNotification:
        ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: *mut VOID) -> UCHAR>,
    pub AcceptProcessorNotification: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut PEPHANDLE__, arg2: ULONG, arg3: *mut VOID) -> UCHAR,
    >,
    #[doc = "offset: 0x48 (72)"]
    pub AcceptAcpiNotification:
        ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: *mut VOID) -> UCHAR>,
    #[doc = "offset: 0x4c (76)"]
    pub WorkOrderCount: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub WorkOrders: [_POP_FX_WORK_ORDER; 1usize],
}
impl Default for _POP_FX_PLUGIN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1840 (6208) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub TimerExpiry: [*mut _KTIMER; 16usize],
    #[doc = "offset: 0x40 (64)"]
    pub TimerEntries: [_KTIMER_TABLE_ENTRY; 256usize],
}
impl Default for _KTIMER_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x468 (1128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEB {
    #[doc = "offset: 0x0 (0)"]
    pub InheritedAddressSpace: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub ReadImageFileExecOptions: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub BeingDebugged: UCHAR,
    pub __bindgen_anon_1: _PEB__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub Mutant: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub ImageBaseAddress: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Ldr: *mut _PEB_LDR_DATA,
    #[doc = "offset: 0x10 (16)"]
    pub ProcessParameters: *mut _RTL_USER_PROCESS_PARAMETERS,
    #[doc = "offset: 0x14 (20)"]
    pub SubSystemData: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub ProcessHeap: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub FastPebLock: *mut _RTL_CRITICAL_SECTION,
    #[doc = "offset: 0x20 (32)"]
    pub AtlThunkSListPtr: *mut _SLIST_HEADER,
    #[doc = "offset: 0x24 (36)"]
    pub IFEOKey: *mut VOID,
    pub __bindgen_anon_2: _PEB__bindgen_ty_2,
    pub __bindgen_anon_3: _PEB__bindgen_ty_3,
    #[doc = "offset: 0x30 (48)"]
    pub SystemReserved: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub AtlThunkSListPtr32: *mut _SLIST_HEADER,
    #[doc = "offset: 0x38 (56)"]
    pub ApiSetMap: *mut VOID,
    #[doc = "offset: 0x3c (60)"]
    pub TlsExpansionCounter: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub TlsBitmap: *mut VOID,
    #[doc = "offset: 0x44 (68)"]
    pub TlsBitmapBits: [ULONG; 2usize],
    #[doc = "offset: 0x4c (76)"]
    pub ReadOnlySharedMemoryBase: *mut VOID,
    #[doc = "offset: 0x50 (80)"]
    pub SharedData: *mut VOID,
    #[doc = "offset: 0x54 (84)"]
    pub ReadOnlyStaticServerData: *mut *mut VOID,
    #[doc = "offset: 0x58 (88)"]
    pub AnsiCodePageData: *mut VOID,
    #[doc = "offset: 0x5c (92)"]
    pub OemCodePageData: *mut VOID,
    #[doc = "offset: 0x60 (96)"]
    pub UnicodeCaseTableData: *mut VOID,
    #[doc = "offset: 0x64 (100)"]
    pub NumberOfProcessors: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub NtGlobalFlag: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub CriticalSectionTimeout: _LARGE_INTEGER,
    #[doc = "offset: 0x78 (120)"]
    pub HeapSegmentReserve: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub HeapSegmentCommit: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub HeapDeCommitTotalFreeThreshold: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub HeapDeCommitFreeBlockThreshold: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub NumberOfHeaps: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub MaximumNumberOfHeaps: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub ProcessHeaps: *mut *mut VOID,
    #[doc = "offset: 0x94 (148)"]
    pub GdiSharedHandleTable: *mut VOID,
    #[doc = "offset: 0x98 (152)"]
    pub ProcessStarterHelper: *mut VOID,
    #[doc = "offset: 0x9c (156)"]
    pub GdiDCAttributeList: ULONG,
    #[doc = "offset: 0xa0 (160)"]
    pub LoaderLock: *mut _RTL_CRITICAL_SECTION,
    #[doc = "offset: 0xa4 (164)"]
    pub OSMajorVersion: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub OSMinorVersion: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub OSBuildNumber: USHORT,
    #[doc = "offset: 0xae (174)"]
    pub OSCSDVersion: USHORT,
    #[doc = "offset: 0xb0 (176)"]
    pub OSPlatformId: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub ImageSubsystem: ULONG,
    #[doc = "offset: 0xb8 (184)"]
    pub ImageSubsystemMajorVersion: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub ImageSubsystemMinorVersion: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub ActiveProcessAffinityMask: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub GdiHandleBuffer: [ULONG; 34usize],
    #[doc = "offset: 0x14c (332)"]
    pub PostProcessInitRoutine: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "offset: 0x150 (336)"]
    pub TlsExpansionBitmap: *mut VOID,
    #[doc = "offset: 0x154 (340)"]
    pub TlsExpansionBitmapBits: [ULONG; 32usize],
    #[doc = "offset: 0x1d4 (468)"]
    pub SessionId: ULONG,
    #[doc = "offset: 0x1d8 (472)"]
    pub AppCompatFlags: _ULARGE_INTEGER,
    #[doc = "offset: 0x1e0 (480)"]
    pub AppCompatFlagsUser: _ULARGE_INTEGER,
    #[doc = "offset: 0x1e8 (488)"]
    pub pShimData: *mut VOID,
    #[doc = "offset: 0x1ec (492)"]
    pub AppCompatInfo: *mut VOID,
    #[doc = "offset: 0x1f0 (496)"]
    pub CSDVersion: _UNICODE_STRING,
    #[doc = "offset: 0x1f8 (504)"]
    pub ActivationContextData: *mut _ACTIVATION_CONTEXT_DATA,
    #[doc = "offset: 0x1fc (508)"]
    pub ProcessAssemblyStorageMap: *mut _ASSEMBLY_STORAGE_MAP,
    #[doc = "offset: 0x200 (512)"]
    pub SystemDefaultActivationContextData: *mut _ACTIVATION_CONTEXT_DATA,
    #[doc = "offset: 0x204 (516)"]
    pub SystemAssemblyStorageMap: *mut _ASSEMBLY_STORAGE_MAP,
    #[doc = "offset: 0x208 (520)"]
    pub MinimumStackCommit: ULONG,
    #[doc = "offset: 0x20c (524)"]
    pub FlsCallback: *mut _FLS_CALLBACK_INFO,
    #[doc = "offset: 0x210 (528)"]
    pub FlsListHead: _LIST_ENTRY,
    #[doc = "offset: 0x218 (536)"]
    pub FlsBitmap: *mut VOID,
    #[doc = "offset: 0x21c (540)"]
    pub FlsBitmapBits: [ULONG; 4usize],
    #[doc = "offset: 0x22c (556)"]
    pub FlsHighIndex: ULONG,
    #[doc = "offset: 0x230 (560)"]
    pub WerRegistrationData: *mut VOID,
    #[doc = "offset: 0x234 (564)"]
    pub WerShipAssertPtr: *mut VOID,
    #[doc = "offset: 0x238 (568)"]
    pub pUnused: *mut VOID,
    #[doc = "offset: 0x23c (572)"]
    pub pImageHeaderHash: *mut VOID,
    pub __bindgen_anon_4: _PEB__bindgen_ty_4,
    #[doc = "offset: 0x248 (584)"]
    pub CsrServerReadOnlySharedMemoryBase: ULONGLONG,
    #[doc = "offset: 0x250 (592)"]
    pub TppWorkerpListLock: ULONG,
    #[doc = "offset: 0x254 (596)"]
    pub TppWorkerpList: _LIST_ENTRY,
    #[doc = "offset: 0x25c (604)"]
    pub WaitOnAddressHashTable: [*mut VOID; 128usize],
    #[doc = "offset: 0x45c (1116)"]
    pub TelemetryCoverageHeader: *mut VOID,
    #[doc = "offset: 0x460 (1120)"]
    pub CloudFileFlags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_1 {
    #[doc = "offset: 0x3 (3)"]
    pub BitField: UCHAR,
    pub __bindgen_anon_1: _PEB__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PEB__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ImageUsesLargePages(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageUsesLargePages(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsProtectedProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsProtectedProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsImageDynamicallyRelocated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsImageDynamicallyRelocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipPatchingUser32Forwarders(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SkipPatchingUser32Forwarders(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsPackagedProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsPackagedProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsAppContainer(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsAppContainer(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsProtectedProcessLight(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsProtectedProcessLight(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsLongPathAwareProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsLongPathAwareProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImageUsesLargePages: UCHAR,
        IsProtectedProcess: UCHAR,
        IsImageDynamicallyRelocated: UCHAR,
        SkipPatchingUser32Forwarders: UCHAR,
        IsPackagedProcess: UCHAR,
        IsAppContainer: UCHAR,
        IsProtectedProcessLight: UCHAR,
        IsLongPathAwareProcess: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ImageUsesLargePages: u8 = unsafe { ::std::mem::transmute(ImageUsesLargePages) };
            ImageUsesLargePages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsProtectedProcess: u8 = unsafe { ::std::mem::transmute(IsProtectedProcess) };
            IsProtectedProcess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IsImageDynamicallyRelocated: u8 =
                unsafe { ::std::mem::transmute(IsImageDynamicallyRelocated) };
            IsImageDynamicallyRelocated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SkipPatchingUser32Forwarders: u8 =
                unsafe { ::std::mem::transmute(SkipPatchingUser32Forwarders) };
            SkipPatchingUser32Forwarders as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let IsPackagedProcess: u8 = unsafe { ::std::mem::transmute(IsPackagedProcess) };
            IsPackagedProcess as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let IsAppContainer: u8 = unsafe { ::std::mem::transmute(IsAppContainer) };
            IsAppContainer as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let IsProtectedProcessLight: u8 =
                unsafe { ::std::mem::transmute(IsProtectedProcessLight) };
            IsProtectedProcessLight as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let IsLongPathAwareProcess: u8 =
                unsafe { ::std::mem::transmute(IsLongPathAwareProcess) };
            IsLongPathAwareProcess as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_2 {
    #[doc = "offset: 0x28 (40)"]
    pub CrossProcessFlags: ULONG,
    pub __bindgen_anon_1: _PEB__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ProcessInJob(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInJob(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInitializing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInitializing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVEH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVCH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingFTH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingFTH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessPreviouslyThrottled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessPreviouslyThrottled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessCurrentlyThrottled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessCurrentlyThrottled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedBits0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedBits0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProcessInJob: ULONG,
        ProcessInitializing: ULONG,
        ProcessUsingVEH: ULONG,
        ProcessUsingVCH: ULONG,
        ProcessUsingFTH: ULONG,
        ProcessPreviouslyThrottled: ULONG,
        ProcessCurrentlyThrottled: ULONG,
        ReservedBits0: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProcessInJob: u32 = unsafe { ::std::mem::transmute(ProcessInJob) };
            ProcessInJob as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ProcessInitializing: u32 = unsafe { ::std::mem::transmute(ProcessInitializing) };
            ProcessInitializing as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessUsingVEH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVEH) };
            ProcessUsingVEH as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessUsingVCH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVCH) };
            ProcessUsingVCH as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ProcessUsingFTH: u32 = unsafe { ::std::mem::transmute(ProcessUsingFTH) };
            ProcessUsingFTH as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ProcessPreviouslyThrottled: u32 =
                unsafe { ::std::mem::transmute(ProcessPreviouslyThrottled) };
            ProcessPreviouslyThrottled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ProcessCurrentlyThrottled: u32 =
                unsafe { ::std::mem::transmute(ProcessCurrentlyThrottled) };
            ProcessCurrentlyThrottled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let ReservedBits0: u32 = unsafe { ::std::mem::transmute(ReservedBits0) };
            ReservedBits0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_3 {
    #[doc = "offset: 0x2c (44)"]
    pub KernelCallbackTable: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub UserSharedInfoPtr: *mut VOID,
}
impl Default for _PEB__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_4 {
    #[doc = "offset: 0x240 (576)"]
    pub TracingFlags: ULONG,
    pub __bindgen_anon_1: _PEB__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn HeapTracingEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeapTracingEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CritSecTracingEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CritSecTracingEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LibLoaderTracingEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LibLoaderTracingEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareTracingBits(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_SpareTracingBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HeapTracingEnabled: ULONG,
        CritSecTracingEnabled: ULONG,
        LibLoaderTracingEnabled: ULONG,
        SpareTracingBits: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HeapTracingEnabled: u32 = unsafe { ::std::mem::transmute(HeapTracingEnabled) };
            HeapTracingEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CritSecTracingEnabled: u32 =
                unsafe { ::std::mem::transmute(CritSecTracingEnabled) };
            CritSecTracingEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LibLoaderTracingEnabled: u32 =
                unsafe { ::std::mem::transmute(LibLoaderTracingEnabled) };
            LibLoaderTracingEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let SpareTracingBits: u32 = unsafe { ::std::mem::transmute(SpareTracingBits) };
            SpareTracingBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PEB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3e8 (1000) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EPROCESS {
    #[doc = "offset: 0x0 (0)"]
    pub Pcb: _KPROCESS,
    #[doc = "offset: 0xb0 (176)"]
    pub ProcessLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xb4 (180)"]
    pub UniqueProcessId: *mut VOID,
    #[doc = "offset: 0xb8 (184)"]
    pub ActiveProcessLinks: _LIST_ENTRY,
    #[doc = "offset: 0xc0 (192)"]
    pub RundownProtect: _EX_RUNDOWN_REF,
    #[doc = "offset: 0xc4 (196)"]
    pub VdmObjects: *mut VOID,
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_1,
    pub __bindgen_anon_2: _EPROCESS__bindgen_ty_2,
    #[doc = "offset: 0xd0 (208)"]
    pub CreateTime: _LARGE_INTEGER,
    #[doc = "offset: 0xd8 (216)"]
    pub ProcessQuotaUsage: [ULONG; 2usize],
    #[doc = "offset: 0xe0 (224)"]
    pub ProcessQuotaPeak: [ULONG; 2usize],
    #[doc = "offset: 0xe8 (232)"]
    pub PeakVirtualSize: ULONG,
    #[doc = "offset: 0xec (236)"]
    pub VirtualSize: ULONG,
    #[doc = "offset: 0xf0 (240)"]
    pub SessionProcessLinks: _LIST_ENTRY,
    pub __bindgen_anon_3: _EPROCESS__bindgen_ty_3,
    #[doc = "offset: 0xfc (252)"]
    pub Token: _EX_FAST_REF,
    #[doc = "offset: 0x100 (256)"]
    pub MmReserved: ULONG,
    #[doc = "offset: 0x104 (260)"]
    pub AddressCreationLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x108 (264)"]
    pub PageTableCommitmentLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x10c (268)"]
    pub RotateInProgress: *mut _ETHREAD,
    #[doc = "offset: 0x110 (272)"]
    pub ForkInProgress: *mut _ETHREAD,
    #[doc = "offset: 0x114 (276)"]
    pub CommitChargeJob: *mut _EJOB,
    #[doc = "offset: 0x118 (280)"]
    pub CloneRoot: _RTL_AVL_TREE,
    #[doc = "offset: 0x11c (284)"]
    pub NumberOfPrivatePages: ULONG,
    #[doc = "offset: 0x120 (288)"]
    pub NumberOfLockedPages: ULONG,
    #[doc = "offset: 0x124 (292)"]
    pub Win32Process: *mut VOID,
    #[doc = "offset: 0x128 (296)"]
    pub Job: *mut _EJOB,
    #[doc = "offset: 0x12c (300)"]
    pub SectionObject: *mut VOID,
    #[doc = "offset: 0x130 (304)"]
    pub SectionBaseAddress: *mut VOID,
    #[doc = "offset: 0x134 (308)"]
    pub Cookie: ULONG,
    #[doc = "offset: 0x138 (312)"]
    pub WorkingSetWatch: *mut _PAGEFAULT_HISTORY,
    #[doc = "offset: 0x13c (316)"]
    pub Win32WindowStation: *mut VOID,
    #[doc = "offset: 0x140 (320)"]
    pub InheritedFromUniqueProcessId: *mut VOID,
    #[doc = "offset: 0x144 (324)"]
    pub LdtInformation: *mut VOID,
    #[doc = "offset: 0x148 (328)"]
    pub OwnerProcessId: ULONG,
    #[doc = "offset: 0x14c (332)"]
    pub Peb: *mut _PEB,
    #[doc = "offset: 0x150 (336)"]
    pub Session: *mut _MM_SESSION_SPACE,
    #[doc = "offset: 0x154 (340)"]
    pub AweInfo: *mut VOID,
    #[doc = "offset: 0x158 (344)"]
    pub QuotaBlock: *mut _EPROCESS_QUOTA_BLOCK,
    #[doc = "offset: 0x15c (348)"]
    pub ObjectTable: *mut _HANDLE_TABLE,
    #[doc = "offset: 0x160 (352)"]
    pub DebugPort: *mut VOID,
    #[doc = "offset: 0x164 (356)"]
    pub PaeTop: *mut VOID,
    #[doc = "offset: 0x168 (360)"]
    pub DeviceMap: *mut VOID,
    #[doc = "offset: 0x16c (364)"]
    pub EtwDataSource: *mut VOID,
    #[doc = "offset: 0x170 (368)"]
    pub PageDirectoryPte: ULONGLONG,
    #[doc = "offset: 0x178 (376)"]
    pub ImageFilePointer: *mut _FILE_OBJECT,
    #[doc = "offset: 0x17c (380)"]
    pub ImageFileName: [UCHAR; 15usize],
    #[doc = "offset: 0x18b (395)"]
    pub PriorityClass: UCHAR,
    #[doc = "offset: 0x18c (396)"]
    pub SecurityPort: *mut VOID,
    #[doc = "offset: 0x190 (400)"]
    pub SeAuditProcessCreationInfo: _SE_AUDIT_PROCESS_CREATION_INFO,
    #[doc = "offset: 0x194 (404)"]
    pub JobLinks: _LIST_ENTRY,
    #[doc = "offset: 0x19c (412)"]
    pub HighestUserAddress: *mut VOID,
    #[doc = "offset: 0x1a0 (416)"]
    pub ThreadListHead: _LIST_ENTRY,
    #[doc = "offset: 0x1a8 (424)"]
    pub ActiveThreads: ULONG,
    #[doc = "offset: 0x1ac (428)"]
    pub ImagePathHash: ULONG,
    #[doc = "offset: 0x1b0 (432)"]
    pub DefaultHardErrorProcessing: ULONG,
    #[doc = "offset: 0x1b4 (436)"]
    pub LastThreadExitStatus: LONG,
    #[doc = "offset: 0x1b8 (440)"]
    pub PrefetchTrace: _EX_FAST_REF,
    #[doc = "offset: 0x1bc (444)"]
    pub LockedPagesList: *mut VOID,
    #[doc = "offset: 0x1c0 (448)"]
    pub ReadOperationCount: _LARGE_INTEGER,
    #[doc = "offset: 0x1c8 (456)"]
    pub WriteOperationCount: _LARGE_INTEGER,
    #[doc = "offset: 0x1d0 (464)"]
    pub OtherOperationCount: _LARGE_INTEGER,
    #[doc = "offset: 0x1d8 (472)"]
    pub ReadTransferCount: _LARGE_INTEGER,
    #[doc = "offset: 0x1e0 (480)"]
    pub WriteTransferCount: _LARGE_INTEGER,
    #[doc = "offset: 0x1e8 (488)"]
    pub OtherTransferCount: _LARGE_INTEGER,
    #[doc = "offset: 0x1f0 (496)"]
    pub CommitChargeLimit: ULONG,
    #[doc = "offset: 0x1f4 (500)"]
    pub CommitCharge: ULONG,
    #[doc = "offset: 0x1f8 (504)"]
    pub CommitChargePeak: ULONG,
    #[doc = "offset: 0x1fc (508)"]
    pub Vm: _MMSUPPORT_FULL,
    #[doc = "offset: 0x288 (648)"]
    pub MmProcessLinks: _LIST_ENTRY,
    #[doc = "offset: 0x290 (656)"]
    pub ModifiedPageCount: ULONG,
    #[doc = "offset: 0x294 (660)"]
    pub ExitStatus: LONG,
    #[doc = "offset: 0x298 (664)"]
    pub VadRoot: _RTL_AVL_TREE,
    #[doc = "offset: 0x29c (668)"]
    pub VadHint: *mut VOID,
    #[doc = "offset: 0x2a0 (672)"]
    pub VadCount: ULONG,
    #[doc = "offset: 0x2a4 (676)"]
    pub VadPhysicalPages: ULONG,
    #[doc = "offset: 0x2a8 (680)"]
    pub VadPhysicalPagesLimit: ULONG,
    #[doc = "offset: 0x2ac (684)"]
    pub AlpcContext: _ALPC_PROCESS_CONTEXT,
    #[doc = "offset: 0x2bc (700)"]
    pub TimerResolutionLink: _LIST_ENTRY,
    #[doc = "offset: 0x2c4 (708)"]
    pub TimerResolutionStackRecord: *mut _PO_DIAG_STACK_RECORD,
    #[doc = "offset: 0x2c8 (712)"]
    pub RequestedTimerResolution: ULONG,
    #[doc = "offset: 0x2cc (716)"]
    pub SmallestTimerResolution: ULONG,
    #[doc = "offset: 0x2d0 (720)"]
    pub ExitTime: _LARGE_INTEGER,
    #[doc = "offset: 0x2d8 (728)"]
    pub ActiveThreadsHighWatermark: ULONG,
    #[doc = "offset: 0x2dc (732)"]
    pub LargePrivateVadCount: ULONG,
    #[doc = "offset: 0x2e0 (736)"]
    pub ThreadListLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x2e4 (740)"]
    pub WnfContext: *mut VOID,
    #[doc = "offset: 0x2e8 (744)"]
    pub ServerSilo: *mut _EJOB,
    #[doc = "offset: 0x2ec (748)"]
    pub SignatureLevel: UCHAR,
    #[doc = "offset: 0x2ed (749)"]
    pub SectionSignatureLevel: UCHAR,
    #[doc = "offset: 0x2ee (750)"]
    pub Protection: _PS_PROTECTION,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_4: _EPROCESS__bindgen_ty_4,
    #[doc = "offset: 0x2f4 (756)"]
    pub DeviceAsid: LONG,
    #[doc = "offset: 0x2f8 (760)"]
    pub SvmData: *mut VOID,
    #[doc = "offset: 0x2fc (764)"]
    pub SvmProcessLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x300 (768)"]
    pub SvmLock: ULONG,
    #[doc = "offset: 0x304 (772)"]
    pub SvmProcessDeviceListHead: _LIST_ENTRY,
    #[doc = "offset: 0x310 (784)"]
    pub LastFreezeInterruptTime: ULONGLONG,
    #[doc = "offset: 0x318 (792)"]
    pub DiskCounters: *mut _PROCESS_DISK_COUNTERS,
    #[doc = "offset: 0x31c (796)"]
    pub PicoContext: *mut VOID,
    #[doc = "offset: 0x320 (800)"]
    pub HighPriorityFaultsAllowed: ULONG,
    #[doc = "offset: 0x324 (804)"]
    pub InstrumentationCallback: *mut VOID,
    #[doc = "offset: 0x328 (808)"]
    pub EnergyContext: *mut _PO_PROCESS_ENERGY_CONTEXT,
    #[doc = "offset: 0x32c (812)"]
    pub VmContext: *mut VOID,
    #[doc = "offset: 0x330 (816)"]
    pub SequenceNumber: ULONGLONG,
    #[doc = "offset: 0x338 (824)"]
    pub CreateInterruptTime: ULONGLONG,
    #[doc = "offset: 0x340 (832)"]
    pub CreateUnbiasedInterruptTime: ULONGLONG,
    #[doc = "offset: 0x348 (840)"]
    pub TotalUnbiasedFrozenTime: ULONGLONG,
    #[doc = "offset: 0x350 (848)"]
    pub LastAppStateUpdateTime: ULONGLONG,
    pub _bitfield_align_2: [u64; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = "offset: 0x360 (864)"]
    pub SharedCommitCharge: ULONG,
    #[doc = "offset: 0x364 (868)"]
    pub SharedCommitLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x368 (872)"]
    pub SharedCommitLinks: _LIST_ENTRY,
    pub __bindgen_anon_5: _EPROCESS__bindgen_ty_5,
    #[doc = "offset: 0x378 (888)"]
    pub DiskIoAttribution: *mut VOID,
    #[doc = "offset: 0x37c (892)"]
    pub DxgProcess: *mut VOID,
    #[doc = "offset: 0x380 (896)"]
    pub Win32KFilterSet: ULONG,
    #[doc = "offset:\n 0x388\n (904)"]
    pub ProcessTimerDelay: _PS_INTERLOCKED_TIMER_DELAY_VALUES,
    #[doc = "offset: 0x390 (912)"]
    pub KTimerSets: ULONG,
    #[doc = "offset: 0x394 (916)"]
    pub KTimer2Sets: ULONG,
    #[doc = "offset: 0x398 (920)"]
    pub ThreadTimerSets: ULONG,
    #[doc = "offset: 0x39c (924)"]
    pub VirtualTimerListLock: ULONG,
    #[doc = "offset: 0x3a0 (928)"]
    pub VirtualTimerListHead: _LIST_ENTRY,
    pub __bindgen_anon_6: _EPROCESS__bindgen_ty_6,
    pub __bindgen_anon_7: _EPROCESS__bindgen_ty_7,
    pub __bindgen_anon_8: _EPROCESS__bindgen_ty_8,
    #[doc = "offset: 0x3e0 (992)"]
    pub PartitionObject: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_1 {
    #[doc = "offset: 0xc8 (200)"]
    pub Flags2: ULONG,
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _EPROCESS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn JobNotReallyActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JobNotReallyActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccountingFolded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AccountingFolded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NewProcessReported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NewProcessReported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExitProcessReported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExitProcessReported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReportCommitChanges(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReportCommitChanges(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LastReportMemory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LastReportMemory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceWakeCharge(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForceWakeCharge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrossSessionCreate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CrossSessionCreate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NeedsHandleRundown(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NeedsHandleRundown(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RefTraceEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RefTraceEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PicoCreated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PicoCreated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EmptyJobEvaluated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EmptyJobEvaluated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultPagePriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DefaultPagePriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PrimaryTokenFrozen(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrimaryTokenFrozen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessVerifierTarget(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessVerifierTarget(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RestrictSetThreadContext(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RestrictSetThreadContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AffinityPermanent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AffinityPermanent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AffinityUpdateEnable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AffinityUpdateEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PropagateNode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PropagateNode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExplicitAffinity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExplicitAffinity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessExecutionState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessExecutionState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableReadVmLogging(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableReadVmLogging(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableWriteVmLogging(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableWriteVmLogging(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FatalAccessTerminationRequested(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FatalAccessTerminationRequested(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableSystemAllowedCpuSet(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableSystemAllowedCpuSet(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessStateChangeRequest(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessStateChangeRequest(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessStateChangeInProgress(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessStateChangeInProgress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InPrivate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InPrivate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        JobNotReallyActive: ULONG,
        AccountingFolded: ULONG,
        NewProcessReported: ULONG,
        ExitProcessReported: ULONG,
        ReportCommitChanges: ULONG,
        LastReportMemory: ULONG,
        ForceWakeCharge: ULONG,
        CrossSessionCreate: ULONG,
        NeedsHandleRundown: ULONG,
        RefTraceEnabled: ULONG,
        PicoCreated: ULONG,
        EmptyJobEvaluated: ULONG,
        DefaultPagePriority: ULONG,
        PrimaryTokenFrozen: ULONG,
        ProcessVerifierTarget: ULONG,
        RestrictSetThreadContext: ULONG,
        AffinityPermanent: ULONG,
        AffinityUpdateEnable: ULONG,
        PropagateNode: ULONG,
        ExplicitAffinity: ULONG,
        ProcessExecutionState: ULONG,
        EnableReadVmLogging: ULONG,
        EnableWriteVmLogging: ULONG,
        FatalAccessTerminationRequested: ULONG,
        DisableSystemAllowedCpuSet: ULONG,
        ProcessStateChangeRequest: ULONG,
        ProcessStateChangeInProgress: ULONG,
        InPrivate: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let JobNotReallyActive: u32 = unsafe { ::std::mem::transmute(JobNotReallyActive) };
            JobNotReallyActive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AccountingFolded: u32 = unsafe { ::std::mem::transmute(AccountingFolded) };
            AccountingFolded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NewProcessReported: u32 = unsafe { ::std::mem::transmute(NewProcessReported) };
            NewProcessReported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ExitProcessReported: u32 = unsafe { ::std::mem::transmute(ExitProcessReported) };
            ExitProcessReported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ReportCommitChanges: u32 = unsafe { ::std::mem::transmute(ReportCommitChanges) };
            ReportCommitChanges as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LastReportMemory: u32 = unsafe { ::std::mem::transmute(LastReportMemory) };
            LastReportMemory as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ForceWakeCharge: u32 = unsafe { ::std::mem::transmute(ForceWakeCharge) };
            ForceWakeCharge as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CrossSessionCreate: u32 = unsafe { ::std::mem::transmute(CrossSessionCreate) };
            CrossSessionCreate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let NeedsHandleRundown: u32 = unsafe { ::std::mem::transmute(NeedsHandleRundown) };
            NeedsHandleRundown as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RefTraceEnabled: u32 = unsafe { ::std::mem::transmute(RefTraceEnabled) };
            RefTraceEnabled as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PicoCreated: u32 = unsafe { ::std::mem::transmute(PicoCreated) };
            PicoCreated as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EmptyJobEvaluated: u32 = unsafe { ::std::mem::transmute(EmptyJobEvaluated) };
            EmptyJobEvaluated as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let DefaultPagePriority: u32 = unsafe { ::std::mem::transmute(DefaultPagePriority) };
            DefaultPagePriority as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PrimaryTokenFrozen: u32 = unsafe { ::std::mem::transmute(PrimaryTokenFrozen) };
            PrimaryTokenFrozen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ProcessVerifierTarget: u32 =
                unsafe { ::std::mem::transmute(ProcessVerifierTarget) };
            ProcessVerifierTarget as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let RestrictSetThreadContext: u32 =
                unsafe { ::std::mem::transmute(RestrictSetThreadContext) };
            RestrictSetThreadContext as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let AffinityPermanent: u32 = unsafe { ::std::mem::transmute(AffinityPermanent) };
            AffinityPermanent as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let AffinityUpdateEnable: u32 = unsafe { ::std::mem::transmute(AffinityUpdateEnable) };
            AffinityUpdateEnable as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let PropagateNode: u32 = unsafe { ::std::mem::transmute(PropagateNode) };
            PropagateNode as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ExplicitAffinity: u32 = unsafe { ::std::mem::transmute(ExplicitAffinity) };
            ExplicitAffinity as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let ProcessExecutionState: u32 =
                unsafe { ::std::mem::transmute(ProcessExecutionState) };
            ProcessExecutionState as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EnableReadVmLogging: u32 = unsafe { ::std::mem::transmute(EnableReadVmLogging) };
            EnableReadVmLogging as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let EnableWriteVmLogging: u32 = unsafe { ::std::mem::transmute(EnableWriteVmLogging) };
            EnableWriteVmLogging as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let FatalAccessTerminationRequested: u32 =
                unsafe { ::std::mem::transmute(FatalAccessTerminationRequested) };
            FatalAccessTerminationRequested as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let DisableSystemAllowedCpuSet: u32 =
                unsafe { ::std::mem::transmute(DisableSystemAllowedCpuSet) };
            DisableSystemAllowedCpuSet as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let ProcessStateChangeRequest: u32 =
                unsafe { ::std::mem::transmute(ProcessStateChangeRequest) };
            ProcessStateChangeRequest as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ProcessStateChangeInProgress: u32 =
                unsafe { ::std::mem::transmute(ProcessStateChangeInProgress) };
            ProcessStateChangeInProgress as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let InPrivate: u32 = unsafe { ::std::mem::transmute(InPrivate) };
            InPrivate as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPROCESS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_2 {
    #[doc = "offset: 0xcc (204)"]
    pub Flags: ULONG,
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _EPROCESS__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn CreateReported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CreateReported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDebugInherit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDebugInherit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessExiting(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessExiting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessDelete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessDelete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ManageExecutableMemoryWrites(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ManageExecutableMemoryWrites(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VmDeleted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VmDeleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OutswapEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OutswapEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Outswapped(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Outswapped(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FailFastOnCommitFail(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FailFastOnCommitFail(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wow64VaSpace4Gb(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wow64VaSpace4Gb(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AddressSpaceInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AddressSpaceInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SetTimerResolution(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetTimerResolution(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BreakOnTermination(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BreakOnTermination(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeprioritizeViews(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeprioritizeViews(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteWatch(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteWatch(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInSession(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInSession(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OverrideAddressSpace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OverrideAddressSpace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasAddressSpace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasAddressSpace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LaunchPrefetched(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LaunchPrefetched(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Background(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Background(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VmTopDown(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VmTopDown(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageNotifyDone(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImageNotifyDone(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PdeUpdateNeeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PdeUpdateNeeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VdmAllowed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VdmAllowed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessRundown(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessRundown(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInserted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultIoPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DefaultIoPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessSelfDelete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessSelfDelete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetTimerResolutionLink(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetTimerResolutionLink(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CreateReported: ULONG,
        NoDebugInherit: ULONG,
        ProcessExiting: ULONG,
        ProcessDelete: ULONG,
        ManageExecutableMemoryWrites: ULONG,
        VmDeleted: ULONG,
        OutswapEnabled: ULONG,
        Outswapped: ULONG,
        FailFastOnCommitFail: ULONG,
        Wow64VaSpace4Gb: ULONG,
        AddressSpaceInitialized: ULONG,
        SetTimerResolution: ULONG,
        BreakOnTermination: ULONG,
        DeprioritizeViews: ULONG,
        WriteWatch: ULONG,
        ProcessInSession: ULONG,
        OverrideAddressSpace: ULONG,
        HasAddressSpace: ULONG,
        LaunchPrefetched: ULONG,
        Background: ULONG,
        VmTopDown: ULONG,
        ImageNotifyDone: ULONG,
        PdeUpdateNeeded: ULONG,
        VdmAllowed: ULONG,
        ProcessRundown: ULONG,
        ProcessInserted: ULONG,
        DefaultIoPriority: ULONG,
        ProcessSelfDelete: ULONG,
        SetTimerResolutionLink: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CreateReported: u32 = unsafe { ::std::mem::transmute(CreateReported) };
            CreateReported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoDebugInherit: u32 = unsafe { ::std::mem::transmute(NoDebugInherit) };
            NoDebugInherit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessExiting: u32 = unsafe { ::std::mem::transmute(ProcessExiting) };
            ProcessExiting as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessDelete: u32 = unsafe { ::std::mem::transmute(ProcessDelete) };
            ProcessDelete as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ManageExecutableMemoryWrites: u32 =
                unsafe { ::std::mem::transmute(ManageExecutableMemoryWrites) };
            ManageExecutableMemoryWrites as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let VmDeleted: u32 = unsafe { ::std::mem::transmute(VmDeleted) };
            VmDeleted as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OutswapEnabled: u32 = unsafe { ::std::mem::transmute(OutswapEnabled) };
            OutswapEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Outswapped: u32 = unsafe { ::std::mem::transmute(Outswapped) };
            Outswapped as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let FailFastOnCommitFail: u32 = unsafe { ::std::mem::transmute(FailFastOnCommitFail) };
            FailFastOnCommitFail as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Wow64VaSpace4Gb: u32 = unsafe { ::std::mem::transmute(Wow64VaSpace4Gb) };
            Wow64VaSpace4Gb as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let AddressSpaceInitialized: u32 =
                unsafe { ::std::mem::transmute(AddressSpaceInitialized) };
            AddressSpaceInitialized as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SetTimerResolution: u32 = unsafe { ::std::mem::transmute(SetTimerResolution) };
            SetTimerResolution as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let BreakOnTermination: u32 = unsafe { ::std::mem::transmute(BreakOnTermination) };
            BreakOnTermination as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let DeprioritizeViews: u32 = unsafe { ::std::mem::transmute(DeprioritizeViews) };
            DeprioritizeViews as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WriteWatch: u32 = unsafe { ::std::mem::transmute(WriteWatch) };
            WriteWatch as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ProcessInSession: u32 = unsafe { ::std::mem::transmute(ProcessInSession) };
            ProcessInSession as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let OverrideAddressSpace: u32 = unsafe { ::std::mem::transmute(OverrideAddressSpace) };
            OverrideAddressSpace as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let HasAddressSpace: u32 = unsafe { ::std::mem::transmute(HasAddressSpace) };
            HasAddressSpace as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let LaunchPrefetched: u32 = unsafe { ::std::mem::transmute(LaunchPrefetched) };
            LaunchPrefetched as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Background: u32 = unsafe { ::std::mem::transmute(Background) };
            Background as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let VmTopDown: u32 = unsafe { ::std::mem::transmute(VmTopDown) };
            VmTopDown as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ImageNotifyDone: u32 = unsafe { ::std::mem::transmute(ImageNotifyDone) };
            ImageNotifyDone as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let PdeUpdateNeeded: u32 = unsafe { ::std::mem::transmute(PdeUpdateNeeded) };
            PdeUpdateNeeded as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let VdmAllowed: u32 = unsafe { ::std::mem::transmute(VdmAllowed) };
            VdmAllowed as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ProcessRundown: u32 = unsafe { ::std::mem::transmute(ProcessRundown) };
            ProcessRundown as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ProcessInserted: u32 = unsafe { ::std::mem::transmute(ProcessInserted) };
            ProcessInserted as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let DefaultIoPriority: u32 = unsafe { ::std::mem::transmute(DefaultIoPriority) };
            DefaultIoPriority as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ProcessSelfDelete: u32 = unsafe { ::std::mem::transmute(ProcessSelfDelete) };
            ProcessSelfDelete as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let SetTimerResolutionLink: u32 =
                unsafe { ::std::mem::transmute(SetTimerResolutionLink) };
            SetTimerResolutionLink as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPROCESS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_3 {
    #[doc = "offset: 0xf8 (248)"]
    pub ExceptionPortData: *mut VOID,
    #[doc = "offset: 0xf8 (248)"]
    pub ExceptionPortValue: ULONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _EPROCESS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _EPROCESS__bindgen_ty_3 {
    #[inline]
    pub fn ExceptionPortState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ExceptionPortState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ExceptionPortState: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ExceptionPortState: u32 = unsafe { ::std::mem::transmute(ExceptionPortState) };
            ExceptionPortState as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_4 {
    #[doc = "offset: 0x2f0 (752)"]
    pub Flags3: ULONG,
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _EPROCESS__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn Minimal(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Minimal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReplacingPageRoot(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplacingPageRoot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Crashed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Crashed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn JobVadsAreTracked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JobVadsAreTracked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VadTrackingDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VadTrackingDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuxiliaryProcess(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuxiliaryProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SubsystemProcess(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SubsystemProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IndirectCpuSets(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IndirectCpuSets(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RelinquishedCommit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RelinquishedCommit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HighGraphicsPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HighGraphicsPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CommitFailLogged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CommitFailLogged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReserveFailLogged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReserveFailLogged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemProcess(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HideImageBaseAddresses(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HideImageBaseAddresses(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Minimal: ULONG,
        ReplacingPageRoot: ULONG,
        Crashed: ULONG,
        JobVadsAreTracked: ULONG,
        VadTrackingDisabled: ULONG,
        AuxiliaryProcess: ULONG,
        SubsystemProcess: ULONG,
        IndirectCpuSets: ULONG,
        RelinquishedCommit: ULONG,
        HighGraphicsPriority: ULONG,
        CommitFailLogged: ULONG,
        ReserveFailLogged: ULONG,
        SystemProcess: ULONG,
        HideImageBaseAddresses: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Minimal: u32 = unsafe { ::std::mem::transmute(Minimal) };
            Minimal as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReplacingPageRoot: u32 = unsafe { ::std::mem::transmute(ReplacingPageRoot) };
            ReplacingPageRoot as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Crashed: u32 = unsafe { ::std::mem::transmute(Crashed) };
            Crashed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let JobVadsAreTracked: u32 = unsafe { ::std::mem::transmute(JobVadsAreTracked) };
            JobVadsAreTracked as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let VadTrackingDisabled: u32 = unsafe { ::std::mem::transmute(VadTrackingDisabled) };
            VadTrackingDisabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AuxiliaryProcess: u32 = unsafe { ::std::mem::transmute(AuxiliaryProcess) };
            AuxiliaryProcess as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SubsystemProcess: u32 = unsafe { ::std::mem::transmute(SubsystemProcess) };
            SubsystemProcess as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let IndirectCpuSets: u32 = unsafe { ::std::mem::transmute(IndirectCpuSets) };
            IndirectCpuSets as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RelinquishedCommit: u32 = unsafe { ::std::mem::transmute(RelinquishedCommit) };
            RelinquishedCommit as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HighGraphicsPriority: u32 = unsafe { ::std::mem::transmute(HighGraphicsPriority) };
            HighGraphicsPriority as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CommitFailLogged: u32 = unsafe { ::std::mem::transmute(CommitFailLogged) };
            CommitFailLogged as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ReserveFailLogged: u32 = unsafe { ::std::mem::transmute(ReserveFailLogged) };
            ReserveFailLogged as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SystemProcess: u32 = unsafe { ::std::mem::transmute(SystemProcess) };
            SystemProcess as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let HideImageBaseAddresses: u32 =
                unsafe { ::std::mem::transmute(HideImageBaseAddresses) };
            HideImageBaseAddresses as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPROCESS__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_5 {
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_5__bindgen_ty_1,
    pub __bindgen_anon_2: _EPROCESS__bindgen_ty_5__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS__bindgen_ty_5__bindgen_ty_1 {
    #[doc = "offset: 0x370 (880)"]
    pub AllowedCpuSets: ULONG,
    #[doc = "offset: 0x374 (884)"]
    pub DefaultCpuSets: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EPROCESS__bindgen_ty_5__bindgen_ty_2 {
    #[doc = "offset: 0x370 (880)"]
    pub AllowedCpuSetsIndirect: *mut ULONG,
    #[doc = "offset: 0x374 (884)"]
    pub DefaultCpuSetsIndirect: *mut ULONG,
}
impl Default for _EPROCESS__bindgen_ty_5__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EPROCESS__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_6 {
    #[doc = "offset: 0x3a8 (936)"]
    pub WakeChannel: _WNF_STATE_NAME,
    #[doc = "offset: 0x3a8 (936)"]
    pub WakeInfo: _PS_PROCESS_WAKE_INFORMATION,
}
impl Default for _EPROCESS__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_7 {
    #[doc = "offset: 0x3d8 (984)"]
    pub MitigationFlags: ULONG,
    #[doc = "offset: 0x3d8 (984)"]
    pub MitigationFlagsValues: _EPROCESS__bindgen_ty_7__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _EPROCESS__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn ControlFlowGuardEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ControlFlowGuardEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ControlFlowGuardExportSuppressionEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ControlFlowGuardExportSuppressionEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ControlFlowGuardStrict(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ControlFlowGuardStrict(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowStrippedImages(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowStrippedImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceRelocateImages(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForceRelocateImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HighEntropyASLREnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HighEntropyASLREnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackRandomizationDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackRandomizationDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtensionPointDisable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtensionPointDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableDynamicCode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableDynamicCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableDynamicCodeAllowOptOut(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableDynamicCodeAllowOptOut(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableDynamicCodeAllowRemoteDowngrade(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableDynamicCodeAllowRemoteDowngrade(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditDisableDynamicCode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditDisableDynamicCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowWin32kSystemCalls(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowWin32kSystemCalls(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditDisallowWin32kSystemCalls(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditDisallowWin32kSystemCalls(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableFilteredWin32kAPIs(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableFilteredWin32kAPIs(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditFilteredWin32kAPIs(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditFilteredWin32kAPIs(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableNonSystemFonts(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableNonSystemFonts(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNonSystemFontLoading(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNonSystemFontLoading(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferSystem32Images(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreferSystem32Images(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProhibitRemoteImageMap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProhibitRemoteImageMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditProhibitRemoteImageMap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditProhibitRemoteImageMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProhibitLowILImageMap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProhibitLowILImageMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditProhibitLowILImageMap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditProhibitLowILImageMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SignatureMitigationOptIn(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SignatureMitigationOptIn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditBlockNonMicrosoftBinaries(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditBlockNonMicrosoftBinaries(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditBlockNonMicrosoftBinariesAllowStore(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditBlockNonMicrosoftBinariesAllowStore(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoaderIntegrityContinuityEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoaderIntegrityContinuityEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditLoaderIntegrityContinuity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditLoaderIntegrityContinuity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableModuleTamperingProtection(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableModuleTamperingProtection(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableModuleTamperingProtectionNoInherit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableModuleTamperingProtectionNoInherit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ControlFlowGuardEnabled: ULONG,
        ControlFlowGuardExportSuppressionEnabled: ULONG,
        ControlFlowGuardStrict: ULONG,
        DisallowStrippedImages: ULONG,
        ForceRelocateImages: ULONG,
        HighEntropyASLREnabled: ULONG,
        StackRandomizationDisabled: ULONG,
        ExtensionPointDisable: ULONG,
        DisableDynamicCode: ULONG,
        DisableDynamicCodeAllowOptOut: ULONG,
        DisableDynamicCodeAllowRemoteDowngrade: ULONG,
        AuditDisableDynamicCode: ULONG,
        DisallowWin32kSystemCalls: ULONG,
        AuditDisallowWin32kSystemCalls: ULONG,
        EnableFilteredWin32kAPIs: ULONG,
        AuditFilteredWin32kAPIs: ULONG,
        DisableNonSystemFonts: ULONG,
        AuditNonSystemFontLoading: ULONG,
        PreferSystem32Images: ULONG,
        ProhibitRemoteImageMap: ULONG,
        AuditProhibitRemoteImageMap: ULONG,
        ProhibitLowILImageMap: ULONG,
        AuditProhibitLowILImageMap: ULONG,
        SignatureMitigationOptIn: ULONG,
        AuditBlockNonMicrosoftBinaries: ULONG,
        AuditBlockNonMicrosoftBinariesAllowStore: ULONG,
        LoaderIntegrityContinuityEnabled: ULONG,
        AuditLoaderIntegrityContinuity: ULONG,
        EnableModuleTamperingProtection: ULONG,
        EnableModuleTamperingProtectionNoInherit: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ControlFlowGuardEnabled: u32 =
                unsafe { ::std::mem::transmute(ControlFlowGuardEnabled) };
            ControlFlowGuardEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ControlFlowGuardExportSuppressionEnabled: u32 =
                unsafe { ::std::mem::transmute(ControlFlowGuardExportSuppressionEnabled) };
            ControlFlowGuardExportSuppressionEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ControlFlowGuardStrict: u32 =
                unsafe { ::std::mem::transmute(ControlFlowGuardStrict) };
            ControlFlowGuardStrict as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DisallowStrippedImages: u32 =
                unsafe { ::std::mem::transmute(DisallowStrippedImages) };
            DisallowStrippedImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ForceRelocateImages: u32 = unsafe { ::std::mem::transmute(ForceRelocateImages) };
            ForceRelocateImages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let HighEntropyASLREnabled: u32 =
                unsafe { ::std::mem::transmute(HighEntropyASLREnabled) };
            HighEntropyASLREnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let StackRandomizationDisabled: u32 =
                unsafe { ::std::mem::transmute(StackRandomizationDisabled) };
            StackRandomizationDisabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ExtensionPointDisable: u32 =
                unsafe { ::std::mem::transmute(ExtensionPointDisable) };
            ExtensionPointDisable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DisableDynamicCode: u32 = unsafe { ::std::mem::transmute(DisableDynamicCode) };
            DisableDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DisableDynamicCodeAllowOptOut: u32 =
                unsafe { ::std::mem::transmute(DisableDynamicCodeAllowOptOut) };
            DisableDynamicCodeAllowOptOut as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DisableDynamicCodeAllowRemoteDowngrade: u32 =
                unsafe { ::std::mem::transmute(DisableDynamicCodeAllowRemoteDowngrade) };
            DisableDynamicCodeAllowRemoteDowngrade as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AuditDisableDynamicCode: u32 =
                unsafe { ::std::mem::transmute(AuditDisableDynamicCode) };
            AuditDisableDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DisallowWin32kSystemCalls: u32 =
                unsafe { ::std::mem::transmute(DisallowWin32kSystemCalls) };
            DisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AuditDisallowWin32kSystemCalls: u32 =
                unsafe { ::std::mem::transmute(AuditDisallowWin32kSystemCalls) };
            AuditDisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EnableFilteredWin32kAPIs: u32 =
                unsafe { ::std::mem::transmute(EnableFilteredWin32kAPIs) };
            EnableFilteredWin32kAPIs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let AuditFilteredWin32kAPIs: u32 =
                unsafe { ::std::mem::transmute(AuditFilteredWin32kAPIs) };
            AuditFilteredWin32kAPIs as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DisableNonSystemFonts: u32 =
                unsafe { ::std::mem::transmute(DisableNonSystemFonts) };
            DisableNonSystemFonts as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let AuditNonSystemFontLoading: u32 =
                unsafe { ::std::mem::transmute(AuditNonSystemFontLoading) };
            AuditNonSystemFontLoading as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PreferSystem32Images: u32 = unsafe { ::std::mem::transmute(PreferSystem32Images) };
            PreferSystem32Images as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ProhibitRemoteImageMap: u32 =
                unsafe { ::std::mem::transmute(ProhibitRemoteImageMap) };
            ProhibitRemoteImageMap as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let AuditProhibitRemoteImageMap: u32 =
                unsafe { ::std::mem::transmute(AuditProhibitRemoteImageMap) };
            AuditProhibitRemoteImageMap as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ProhibitLowILImageMap: u32 =
                unsafe { ::std::mem::transmute(ProhibitLowILImageMap) };
            ProhibitLowILImageMap as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let AuditProhibitLowILImageMap: u32 =
                unsafe { ::std::mem::transmute(AuditProhibitLowILImageMap) };
            AuditProhibitLowILImageMap as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SignatureMitigationOptIn: u32 =
                unsafe { ::std::mem::transmute(SignatureMitigationOptIn) };
            SignatureMitigationOptIn as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AuditBlockNonMicrosoftBinaries: u32 =
                unsafe { ::std::mem::transmute(AuditBlockNonMicrosoftBinaries) };
            AuditBlockNonMicrosoftBinaries as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let AuditBlockNonMicrosoftBinariesAllowStore: u32 =
                unsafe { ::std::mem::transmute(AuditBlockNonMicrosoftBinariesAllowStore) };
            AuditBlockNonMicrosoftBinariesAllowStore as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let LoaderIntegrityContinuityEnabled: u32 =
                unsafe { ::std::mem::transmute(LoaderIntegrityContinuityEnabled) };
            LoaderIntegrityContinuityEnabled as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let AuditLoaderIntegrityContinuity: u32 =
                unsafe { ::std::mem::transmute(AuditLoaderIntegrityContinuity) };
            AuditLoaderIntegrityContinuity as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let EnableModuleTamperingProtection: u32 =
                unsafe { ::std::mem::transmute(EnableModuleTamperingProtection) };
            EnableModuleTamperingProtection as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let EnableModuleTamperingProtectionNoInherit: u32 =
                unsafe { ::std::mem::transmute(EnableModuleTamperingProtectionNoInherit) };
            EnableModuleTamperingProtectionNoInherit as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPROCESS__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_8 {
    #[doc = "offset: 0x3dc (988)"]
    pub MitigationFlags2: ULONG,
    #[doc = "offset: 0x3dc (988)"]
    pub MitigationFlags2Values: _EPROCESS__bindgen_ty_8__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _EPROCESS__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn EnableExportAddressFilter(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilter(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExportAddressFilterPlus(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilterPlus(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilterPlus(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilterPlus(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopStackPivot(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopStackPivot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopStackPivot(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopStackPivot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopCallerCheck(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopCallerCheck(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopCallerCheck(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopCallerCheck(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopSimExec(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopSimExec(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopSimExec(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopSimExec(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableImportAddressFilter(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableImportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditImportAddressFilter(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditImportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableExportAddressFilter: ULONG,
        AuditExportAddressFilter: ULONG,
        EnableExportAddressFilterPlus: ULONG,
        AuditExportAddressFilterPlus: ULONG,
        EnableRopStackPivot: ULONG,
        AuditRopStackPivot: ULONG,
        EnableRopCallerCheck: ULONG,
        AuditRopCallerCheck: ULONG,
        EnableRopSimExec: ULONG,
        AuditRopSimExec: ULONG,
        EnableImportAddressFilter: ULONG,
        AuditImportAddressFilter: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilter) };
            EnableExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilter) };
            AuditExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilterPlus) };
            EnableExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilterPlus) };
            AuditExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableRopStackPivot: u32 = unsafe { ::std::mem::transmute(EnableRopStackPivot) };
            EnableRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AuditRopStackPivot: u32 = unsafe { ::std::mem::transmute(AuditRopStackPivot) };
            AuditRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EnableRopCallerCheck: u32 = unsafe { ::std::mem::transmute(EnableRopCallerCheck) };
            EnableRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditRopCallerCheck: u32 = unsafe { ::std::mem::transmute(AuditRopCallerCheck) };
            AuditRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EnableRopSimExec: u32 = unsafe { ::std::mem::transmute(EnableRopSimExec) };
            EnableRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AuditRopSimExec: u32 = unsafe { ::std::mem::transmute(AuditRopSimExec) };
            AuditRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EnableImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableImportAddressFilter) };
            EnableImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AuditImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditImportAddressFilter) };
            AuditImportAddressFilter as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPROCESS__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EPROCESS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _EPROCESS {
    #[inline]
    pub fn HangCount(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_HangCount(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn GhostCount(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_GhostCount(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HangCount: UCHAR,
        GhostCount: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let HangCount: u8 = unsafe { ::std::mem::transmute(HangCount) };
            HangCount as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let GhostCount: u8 = unsafe { ::std::mem::transmute(GhostCount) };
            GhostCount as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn LastAppStateUptime(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_LastAppStateUptime(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn LastAppState(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(61usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_LastAppState(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_2.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        LastAppStateUptime: ULONGLONG,
        LastAppState: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 61u8, {
            let LastAppStateUptime: u64 = unsafe { ::std::mem::transmute(LastAppStateUptime) };
            LastAppStateUptime as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let LastAppState: u64 = unsafe { ::std::mem::transmute(LastAppState) };
            LastAppState as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RH_OP_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub OplockRequestIrp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub OplockRequestFileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x10 (16)"]
    pub OplockRequestProcess: *mut _EPROCESS,
    #[doc = "offset: 0x14 (20)"]
    pub OplockOwnerThread: *mut _ETHREAD,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub AtomicLinks: _LIST_ENTRY,
}
impl Default for _RH_OP_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NONOPAQUE_OPLOCK {
    #[doc = "offset: 0x0 (0)"]
    pub IrpExclusiveOplock: *mut _IRP,
    #[doc = "offset: 0x4 (4)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub ExclusiveOplockOwner: *mut _EPROCESS,
    #[doc = "offset: 0xc (12)"]
    pub ExclusiveOplockOwnerThread: *mut _ETHREAD,
    #[doc = "offset: 0x10 (16)"]
    pub WaiterPriority: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub IrpOplocksR: _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub IrpOplocksRH: _LIST_ENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub RHBreakQueue: _LIST_ENTRY,
    #[doc = "offset: 0x2c (44)"]
    pub WaitingIrps: _LIST_ENTRY,
    #[doc = "offset: 0x34 (52)"]
    pub DelayAckFileObjectQueue: _LIST_ENTRY,
    #[doc = "offset: 0x3c (60)"]
    pub AtomicQueue: _LIST_ENTRY,
    #[doc = "offset: 0x44 (68)"]
    pub DeleterParentKey: *mut _GUID,
    #[doc = "offset: 0x48 (72)"]
    pub OplockState: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub FastMutex: *mut _FAST_MUTEX,
}
impl Default for _NONOPAQUE_OPLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4c (76) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMVAD {
    #[doc = "offset: 0x0 (0)"]
    pub Core: _MMVAD_SHORT,
    #[doc = "offset: 0x28 (40)"]
    pub u2: _MMVAD__bindgen_ty_1,
    #[doc = "offset: 0x2c (44)"]
    pub Subsection: *mut _SUBSECTION,
    #[doc = "offset: 0x30 (48)"]
    pub FirstPrototypePte: *mut _MMPTE,
    #[doc = "offset: 0x34 (52)"]
    pub LastContiguousPte: *mut _MMPTE,
    #[doc = "offset: 0x38 (56)"]
    pub ViewLinks: _LIST_ENTRY,
    #[doc = "offset: 0x40 (64)"]
    pub VadsProcess: *mut _EPROCESS,
    #[doc = "offset: 0x44 (68)"]
    pub u4: _MMVAD__bindgen_ty_2,
    #[doc = "offset: 0x48 (72)"]
    pub FileObject: *mut _FILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD__bindgen_ty_1 {
    #[doc = "offset: 0x28 (40)"]
    pub LongFlags2: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub VadFlags2: _MMVAD_FLAGS2,
}
impl Default for _MMVAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD__bindgen_ty_2 {
    #[doc = "offset: 0x44 (68)"]
    pub SequentialVa: _MI_VAD_SEQUENTIAL_INFO,
    #[doc = "offset: 0x44 (68)"]
    pub ExtendedInfo: *mut _MMEXTEND_INFO,
}
impl Default for _MMVAD__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMVAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_SHUTDOWN_BUG_CHECK {
    #[doc = "offset: 0x0 (0)"]
    pub InitiatingThread: *mut _ETHREAD,
    #[doc = "offset: 0x4 (4)"]
    pub InitiatingProcess: *mut _EPROCESS,
    #[doc = "offset: 0x8 (8)"]
    pub ThreadId: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub ProcessId: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub Code: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub Parameter1: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Parameter2: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Parameter3: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Parameter4: ULONG,
}
impl Default for _POP_SHUTDOWN_BUG_CHECK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa4 (164) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPCP_PORT_OBJECT {
    #[doc = "offset: 0x0 (0)"]
    pub ConnectionPort: *mut _LPCP_PORT_OBJECT,
    #[doc = "offset: 0x4 (4)"]
    pub ConnectedPort: *mut _LPCP_PORT_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub MsgQueue: _LPCP_PORT_QUEUE,
    #[doc = "offset: 0x18 (24)"]
    pub Creator: _CLIENT_ID,
    #[doc = "offset: 0x20 (32)"]
    pub ClientSectionBase: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub ServerSectionBase: *mut VOID,
    #[doc = "offset: 0x28 (40)"]
    pub PortContext: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub ClientThread: *mut _ETHREAD,
    #[doc = "offset: 0x30 (48)"]
    pub SecurityQos: _SECURITY_QUALITY_OF_SERVICE,
    #[doc = "offset: 0x3c (60)"]
    pub StaticSecurity: _SECURITY_CLIENT_CONTEXT,
    #[doc = "offset: 0x78 (120)"]
    pub LpcReplyChainHead: _LIST_ENTRY,
    #[doc = "offset: 0x80 (128)"]
    pub LpcDataInfoChainHead: _LIST_ENTRY,
    pub __bindgen_anon_1: _LPCP_PORT_OBJECT__bindgen_ty_1,
    #[doc = "offset: 0x8c (140)"]
    pub MaxMessageLength: USHORT,
    #[doc = "offset: 0x8e (142)"]
    pub MaxConnectionInfoLength: USHORT,
    #[doc = "offset: 0x90 (144)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub WaitEvent: _KEVENT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LPCP_PORT_OBJECT__bindgen_ty_1 {
    #[doc = "offset: 0x88 (136)"]
    pub ServerProcess: *mut _EPROCESS,
    #[doc = "offset: 0x88 (136)"]
    pub MappingProcess: *mut _EPROCESS,
}
impl Default for _LPCP_PORT_OBJECT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LPCP_PORT_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DIAGNOSTIC_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub CallerType: _REQUESTER_TYPE,
    pub __bindgen_anon_1: _DIAGNOSTIC_CONTEXT__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub ReasonSize: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DIAGNOSTIC_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _DIAGNOSTIC_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DIAGNOSTIC_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x4 (4)"]
    pub Process: *mut _EPROCESS,
    #[doc = "offset: 0x8 (8)"]
    pub ServiceTag: ULONG,
}
impl Default for _DIAGNOSTIC_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DIAGNOSTIC_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DIAGNOSTIC_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb8 (184) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETIMER {
    #[doc = "offset: 0x0 (0)"]
    pub KeTimer: _KTIMER,
    #[doc = "offset: 0x28 (40)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub TimerApc: _KAPC,
    #[doc = "offset: 0x5c (92)"]
    pub TimerDpc: _KDPC,
    #[doc = "offset: 0x7c (124)"]
    pub ActiveTimerListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x84 (132)"]
    pub Period: ULONG,
    pub __bindgen_anon_1: _ETIMER__bindgen_ty_1,
    #[doc = "offset: 0x89 (137)"]
    pub DueTimeType: UCHAR,
    #[doc = "offset: 0x8a (138)"]
    pub Spare2: USHORT,
    #[doc = "offset: 0x8c (140)"]
    pub WakeReason: *mut _DIAGNOSTIC_CONTEXT,
    #[doc = "offset: 0x90 (144)"]
    pub WakeTimerListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x98 (152)"]
    pub VirtualizedTimerCookie: *mut VOID,
    #[doc = "offset: 0x9c (156)"]
    pub VirtualizedTimerLinks: _LIST_ENTRY,
    #[doc = "offset: 0xa8 (168)"]
    pub DueTime: ULONGLONG,
    #[doc = "offset: 0xb0 (176)"]
    pub CoalescingWindow: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETIMER__bindgen_ty_1 {
    #[doc = "offset: 0x88 (136)"]
    pub TimerFlags: CHAR,
    pub __bindgen_anon_1: _ETIMER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETIMER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _ETIMER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ApcAssociated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ApcAssociated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FlushDpcs(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FlushDpcs(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Paused(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Paused(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ApcAssociated: UCHAR,
        FlushDpcs: UCHAR,
        Paused: UCHAR,
        Spare1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ApcAssociated: u8 = unsafe { ::std::mem::transmute(ApcAssociated) };
            ApcAssociated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FlushDpcs: u8 = unsafe { ::std::mem::transmute(FlushDpcs) };
            FlushDpcs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Paused: u8 = unsafe { ::std::mem::transmute(Paused) };
            Paused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Spare1: u8 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETIMER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETIMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_REVERSE_VIEW_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub ViewLinks: _LIST_ENTRY,
    pub __bindgen_anon_1: _MI_REVERSE_VIEW_MAP__bindgen_ty_1,
    pub __bindgen_anon_2: _MI_REVERSE_VIEW_MAP__bindgen_ty_2,
    pub __bindgen_anon_3: _MI_REVERSE_VIEW_MAP__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_REVERSE_VIEW_MAP__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub SystemCacheVa: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub SessionViewVa: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub VadsProcess: *mut _EPROCESS,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _MI_REVERSE_VIEW_MAP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_REVERSE_VIEW_MAP__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Type: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_REVERSE_VIEW_MAP__bindgen_ty_2 {
    #[doc = "offset: 0xc (12)"]
    pub Subsection: *mut _SUBSECTION,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _MI_REVERSE_VIEW_MAP__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_REVERSE_VIEW_MAP__bindgen_ty_2 {
    #[inline]
    pub fn SubsectionType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SubsectionType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SubsectionType: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SubsectionType: u32 = unsafe { ::std::mem::transmute(SubsectionType) };
            SubsectionType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_REVERSE_VIEW_MAP__bindgen_ty_3 {
    #[doc = "offset: 0x10 (16)"]
    pub SystemCacheAttributes: _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES,
    #[doc = "offset: 0x10 (16)"]
    pub SectionOffset: ULONGLONG,
}
impl Default for _MI_REVERSE_VIEW_MAP__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_REVERSE_VIEW_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x103c (4156) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SESSION_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub SystemSession: _MMSESSION,
    #[doc = "offset: 0x14 (20)"]
    pub DetachTimeStamp: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub CodePageEdited: UCHAR,
    #[doc = "offset: 0x1c (28)"]
    pub DynamicPoolBitBuffer: *mut ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub VaReferenceCount: [LONG; 1024usize],
    #[doc = "offset: 0x1020 (4128)"]
    pub DynamicPtesBitBuffer: *mut ULONG,
    #[doc = "offset: 0x1024 (4132)"]
    pub IdLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x1028 (4136)"]
    pub LeaderProcess: *mut _EPROCESS,
    #[doc = "offset: 0x102c (4140)"]
    pub InitializeLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x1030 (4144)"]
    pub WorkingSetList: *mut _MMWSL_INSTANCE,
    #[doc = "offset: 0x1034 (4148)"]
    pub SessionBase: *mut VOID,
    #[doc = "offset: 0x1038 (4152)"]
    pub SessionCore: *mut VOID,
}
impl Default for _MI_SESSION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOCK_TRACKER {
    #[doc = "offset: 0x0 (0)"]
    pub LockTrackerNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0xc (12)"]
    pub Mdl: *mut _MDL,
    #[doc = "offset: 0x10 (16)"]
    pub StartVa: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub Count: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Length: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Who: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Hash: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Page: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub StackTrace: [*mut VOID; 8usize],
    #[doc = "offset: 0x4c (76)"]
    pub Process: *mut _EPROCESS,
}
impl Default for _LOCK_TRACKER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HANDLE_COUNT_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Process: *mut _EPROCESS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _OBJECT_HANDLE_COUNT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _OBJECT_HANDLE_COUNT_ENTRY {
    #[inline]
    pub fn HandleCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_HandleCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn LockCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_LockCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HandleCount: ULONG,
        LockCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let HandleCount: u32 = unsafe { ::std::mem::transmute(HandleCount) };
            HandleCount as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let LockCount: u32 = unsafe { ::std::mem::transmute(LockCount) };
            LockCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HANDLE_COUNT_DATABASE {
    #[doc = "offset: 0x0 (0)"]
    pub CountEntries: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HandleCountEntries: [_OBJECT_HANDLE_COUNT_ENTRY; 1usize],
}
impl Default for _OBJECT_HANDLE_COUNT_DATABASE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_HEADER_HANDLE_INFO {
    pub __bindgen_anon_1: _OBJECT_HEADER_HANDLE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER_HANDLE_INFO__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub HandleCountDataBase: *mut _OBJECT_HANDLE_COUNT_DATABASE,
    #[doc = "offset: 0x0 (0)"]
    pub SingleEntry: _OBJECT_HANDLE_COUNT_ENTRY,
}
impl Default for _OBJECT_HEADER_HANDLE_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_HEADER_HANDLE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER_PROCESS_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub ExclusiveProcess: *mut _EPROCESS,
    #[doc = "offset: 0x4 (4)"]
    pub Reserved: ULONG,
}
impl Default for _OBJECT_HEADER_PROCESS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_TYPE_INITIALIZER {
    #[doc = "offset: 0x0 (0)"]
    pub Length: USHORT,
    pub __bindgen_anon_1: _OBJECT_TYPE_INITIALIZER__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub ObjectTypeCode: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub InvalidAttributes: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub GenericMapping: _GENERIC_MAPPING,
    #[doc = "offset: 0x1c (28)"]
    pub ValidAccessMask: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub RetainAccess: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub PoolType: _POOL_TYPE,
    #[doc = "offset: 0x28 (40)"]
    pub DefaultPagedPoolCharge: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub DefaultNonPagedPoolCharge: ULONG,
    pub DumpProcedure: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _OBJECT_DUMP_CONTROL),
    >,
    pub OpenProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: _OB_OPEN_REASON,
            arg2: CHAR,
            arg3: *mut _EPROCESS,
            arg4: *mut VOID,
            arg5: *mut ULONG,
            arg6: ULONG,
        ) -> LONG,
    >,
    pub CloseProcedure: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _EPROCESS, arg2: *mut VOID, arg3: ULONG, arg4: ULONG),
    >,
    #[doc = "offset: 0x3c (60)"]
    pub DeleteProcedure: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    pub __bindgen_anon_2: _OBJECT_TYPE_INITIALIZER__bindgen_ty_2,
    pub SecurityProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: _SECURITY_OPERATION_CODE,
            arg3: *mut ULONG,
            arg4: *mut VOID,
            arg5: *mut ULONG,
            arg6: *mut *mut VOID,
            arg7: _POOL_TYPE,
            arg8: *mut _GENERIC_MAPPING,
            arg9: CHAR,
        ) -> LONG,
    >,
    pub QueryNameProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: UCHAR,
            arg3: *mut _OBJECT_NAME_INFORMATION,
            arg4: ULONG,
            arg5: *mut ULONG,
            arg6: CHAR,
        ) -> LONG,
    >,
    pub OkayToCloseProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _EPROCESS,
            arg2: *mut VOID,
            arg3: *mut VOID,
            arg4: CHAR,
        ) -> UCHAR,
    >,
    #[doc = "offset: 0x50 (80)"]
    pub WaitObjectFlagMask: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub WaitObjectFlagOffset: USHORT,
    #[doc = "offset: 0x56 (86)"]
    pub WaitObjectPointerOffset: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_TYPE_INITIALIZER__bindgen_ty_1 {
    #[doc = "offset: 0x2 (2)"]
    pub ObjectTypeFlags: USHORT,
    pub __bindgen_anon_1: _OBJECT_TYPE_INITIALIZER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_TYPE_INITIALIZER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _OBJECT_TYPE_INITIALIZER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CaseInsensitive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CaseInsensitive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnnamedObjectsOnly(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UnnamedObjectsOnly(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UseDefaultObject(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UseDefaultObject(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecurityRequired(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SecurityRequired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MaintainHandleCount(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MaintainHandleCount(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MaintainTypeList(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MaintainTypeList(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsObjectCallbacks(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SupportsObjectCallbacks(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheAligned(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CacheAligned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UseExtendedParameters(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UseExtendedParameters(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseInsensitive: UCHAR,
        UnnamedObjectsOnly: UCHAR,
        UseDefaultObject: UCHAR,
        SecurityRequired: UCHAR,
        MaintainHandleCount: UCHAR,
        MaintainTypeList: UCHAR,
        SupportsObjectCallbacks: UCHAR,
        CacheAligned: UCHAR,
        UseExtendedParameters: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseInsensitive: u8 = unsafe { ::std::mem::transmute(CaseInsensitive) };
            CaseInsensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UnnamedObjectsOnly: u8 = unsafe { ::std::mem::transmute(UnnamedObjectsOnly) };
            UnnamedObjectsOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UseDefaultObject: u8 = unsafe { ::std::mem::transmute(UseDefaultObject) };
            UseDefaultObject as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SecurityRequired: u8 = unsafe { ::std::mem::transmute(SecurityRequired) };
            SecurityRequired as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MaintainHandleCount: u8 = unsafe { ::std::mem::transmute(MaintainHandleCount) };
            MaintainHandleCount as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MaintainTypeList: u8 = unsafe { ::std::mem::transmute(MaintainTypeList) };
            MaintainTypeList as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SupportsObjectCallbacks: u8 =
                unsafe { ::std::mem::transmute(SupportsObjectCallbacks) };
            SupportsObjectCallbacks as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CacheAligned: u8 = unsafe { ::std::mem::transmute(CacheAligned) };
            CacheAligned as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UseExtendedParameters: u8 = unsafe { ::std::mem::transmute(UseExtendedParameters) };
            UseExtendedParameters as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _OBJECT_TYPE_INITIALIZER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_TYPE_INITIALIZER__bindgen_ty_2 {
    pub ParseProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: *mut VOID,
            arg3: *mut _ACCESS_STATE,
            arg4: CHAR,
            arg5: ULONG,
            arg6: *mut _UNICODE_STRING,
            arg7: *mut _UNICODE_STRING,
            arg8: *mut VOID,
            arg9: *mut _SECURITY_QUALITY_OF_SERVICE,
            arg10: *mut *mut VOID,
        ) -> LONG,
    >,
    pub ParseProcedureEx: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: *mut VOID,
            arg3: *mut _ACCESS_STATE,
            arg4: CHAR,
            arg5: ULONG,
            arg6: *mut _UNICODE_STRING,
            arg7: *mut _UNICODE_STRING,
            arg8: *mut VOID,
            arg9: *mut _SECURITY_QUALITY_OF_SERVICE,
            arg10: *mut _OB_EXTENDED_PARSE_PARAMETERS,
            arg11: *mut *mut VOID,
        ) -> LONG,
    >,
}
impl Default for _OBJECT_TYPE_INITIALIZER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_TYPE_INITIALIZER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x90 (144) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_TYPE {
    #[doc = "offset: 0x0 (0)"]
    pub TypeList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Name: _UNICODE_STRING,
    #[doc = "offset: 0x10 (16)"]
    pub DefaultObject: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub Index: UCHAR,
    #[doc = "offset: 0x18 (24)"]
    pub TotalNumberOfObjects: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub TotalNumberOfHandles: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub HighWaterNumberOfObjects: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub HighWaterNumberOfHandles: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub TypeInfo: _OBJECT_TYPE_INITIALIZER,
    #[doc = "offset: 0x80 (128)"]
    pub TypeLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x84 (132)"]
    pub Key: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub CallbackList: _LIST_ENTRY,
}
impl Default for _OBJECT_TYPE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_DUPLICATE_OBJECT_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub SourceProcess: *mut _EPROCESS,
    #[doc = "offset: 0x4 (4)"]
    pub SourceHandle: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub Object: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub TargetAccess: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub ObjectInfo: _HANDLE_TABLE_ENTRY_INFO,
    #[doc = "offset: 0x18 (24)"]
    pub HandleAttributes: ULONG,
}
impl Default for _OB_DUPLICATE_OBJECT_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KALPC_HANDLE_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub ObjectType: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Count: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub DuplicateContext: _OB_DUPLICATE_OBJECT_STATE,
}
impl Default for _KALPC_HANDLE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_SECURITY_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub HandleTable: *mut _ALPC_HANDLE_TABLE,
    #[doc = "offset: 0x4 (4)"]
    pub ContextHandle: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub OwningProcess: *mut _EPROCESS,
    #[doc = "offset: 0xc (12)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x10 (16)"]
    pub DynamicSecurity: _SECURITY_CLIENT_CONTEXT,
    #[doc = "offset: 0x4c (76)"]
    pub u1: _KALPC_SECURITY_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_SECURITY_DATA__bindgen_ty_1 {
    #[doc = "offset: 0x4c (76)"]
    pub s1: _KALPC_SECURITY_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KALPC_SECURITY_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_SECURITY_DATA__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Revoked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Revoked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Impersonated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Impersonated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Revoked: ULONG,
        Impersonated: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Revoked: u32 = unsafe { ::std::mem::transmute(Revoked) };
            Revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Impersonated: u32 = unsafe { ::std::mem::transmute(Impersonated) };
            Impersonated as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_SECURITY_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_SECURITY_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_MESSAGE_ATTRIBUTES {
    #[doc = "offset: 0x0 (0)"]
    pub ClientContext: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub ServerContext: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub PortContext: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub CancelPortContext: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub SecurityData: *mut _KALPC_SECURITY_DATA,
    #[doc = "offset: 0x14 (20)"]
    pub View: *mut _KALPC_VIEW,
    #[doc = "offset: 0x18 (24)"]
    pub HandleData: *mut _KALPC_HANDLE_DATA,
    #[doc = "offset: 0x1c (28)"]
    pub DirectEvent: _KALPC_DIRECT_EVENT,
    #[doc = "offset: 0x20 (32)"]
    pub WorkOnBehalfData: _KALPC_WORK_ON_BEHALF_DATA,
}
impl Default for _KALPC_MESSAGE_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x98 (152) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_MESSAGE {
    #[doc = "offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub PortQueue: *mut _ALPC_PORT,
    #[doc = "offset: 0xc (12)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x10 (16)"]
    pub WaitingThread: *mut _ETHREAD,
    #[doc = "offset: 0x14 (20)"]
    pub u1: _KALPC_MESSAGE__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub SequenceNo: LONG,
    pub __bindgen_anon_1: _KALPC_MESSAGE__bindgen_ty_2,
    #[doc = "offset: 0x20 (32)"]
    pub CancelSequencePort: *mut _ALPC_PORT,
    #[doc = "offset: 0x24 (36)"]
    pub CancelQueuePort: *mut _ALPC_PORT,
    #[doc = "offset: 0x28 (40)"]
    pub CancelSequenceNo: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub CancelListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x34 (52)"]
    pub Reserve: *mut _KALPC_RESERVE,
    #[doc = "offset: 0x38 (56)"]
    pub MessageAttributes: _KALPC_MESSAGE_ATTRIBUTES,
    #[doc = "offset: 0x60 (96)"]
    pub DataUserVa: *mut VOID,
    #[doc = "offset: 0x64 (100)"]
    pub CommunicationInfo: *mut _ALPC_COMMUNICATION_INFO,
    #[doc = "offset: 0x68 (104)"]
    pub ConnectionPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x6c (108)"]
    pub ServerThread: *mut _ETHREAD,
    #[doc = "offset: 0x70 (112)"]
    pub WakeReference: *mut VOID,
    #[doc = "offset: 0x74 (116)"]
    pub WakeReference2: *mut VOID,
    #[doc = "offset: 0x78 (120)"]
    pub ExtensionBuffer: *mut VOID,
    #[doc = "offset: 0x7c (124)"]
    pub ExtensionBufferSize: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub PortMessage: _PORT_MESSAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_MESSAGE__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub s1: _KALPC_MESSAGE__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x14 (20)"]
    pub State: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KALPC_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _KALPC_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn QueueType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_QueueType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn QueuePortType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_QueuePortType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Canceled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Canceled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Ready(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Ready(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReleaseMessage(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReleaseMessage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedQuota(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SharedQuota(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReplyWaitReply(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplyWaitReply(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerPortReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerPortReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReserveReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReserveReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReceiverReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ViewAttributeRetrieved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ViewAttributeRetrieved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InDispatch(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InDispatch(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        QueueType: ULONG,
        QueuePortType: ULONG,
        Canceled: ULONG,
        Ready: ULONG,
        ReleaseMessage: ULONG,
        SharedQuota: ULONG,
        ReplyWaitReply: ULONG,
        OwnerPortReference: ULONG,
        ReserveReference: ULONG,
        ReceiverReference: ULONG,
        ViewAttributeRetrieved: ULONG,
        InDispatch: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let QueueType: u32 = unsafe { ::std::mem::transmute(QueueType) };
            QueueType as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let QueuePortType: u32 = unsafe { ::std::mem::transmute(QueuePortType) };
            QueuePortType as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Canceled: u32 = unsafe { ::std::mem::transmute(Canceled) };
            Canceled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Ready: u32 = unsafe { ::std::mem::transmute(Ready) };
            Ready as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ReleaseMessage: u32 = unsafe { ::std::mem::transmute(ReleaseMessage) };
            ReleaseMessage as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SharedQuota: u32 = unsafe { ::std::mem::transmute(SharedQuota) };
            SharedQuota as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ReplyWaitReply: u32 = unsafe { ::std::mem::transmute(ReplyWaitReply) };
            ReplyWaitReply as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let OwnerPortReference: u32 = unsafe { ::std::mem::transmute(OwnerPortReference) };
            OwnerPortReference as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ReserveReference: u32 = unsafe { ::std::mem::transmute(ReserveReference) };
            ReserveReference as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ReceiverReference: u32 = unsafe { ::std::mem::transmute(ReceiverReference) };
            ReceiverReference as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ViewAttributeRetrieved: u32 =
                unsafe { ::std::mem::transmute(ViewAttributeRetrieved) };
            ViewAttributeRetrieved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let InDispatch: u32 = unsafe { ::std::mem::transmute(InDispatch) };
            InDispatch as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_MESSAGE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_MESSAGE__bindgen_ty_2 {
    #[doc = "offset: 0x1c (28)"]
    pub QuotaProcess: *mut _EPROCESS,
    #[doc = "offset: 0x1c (28)"]
    pub QuotaBlock: *mut VOID,
}
impl Default for _KALPC_MESSAGE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_MESSAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_DISPATCH_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub PortObject: *mut _ALPC_PORT,
    #[doc = "offset: 0x4 (4)"]
    pub Message: *mut _KALPC_MESSAGE,
    #[doc = "offset: 0x8 (8)"]
    pub CommunicationInfo: *mut _ALPC_COMMUNICATION_INFO,
    #[doc = "offset: 0xc (12)"]
    pub TargetThread: *mut _ETHREAD,
    #[doc = "offset: 0x10 (16)"]
    pub TargetPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x14 (20)"]
    pub DirectEvent: _KALPC_DIRECT_EVENT,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub TotalLength: USHORT,
    #[doc = "offset: 0x1e (30)"]
    pub Type: USHORT,
    #[doc = "offset: 0x20 (32)"]
    pub DataInfoOffset: USHORT,
    #[doc = "offset: 0x22 (34)"]
    pub SignalCompletion: UCHAR,
    #[doc = "offset: 0x23 (35)"]
    pub PostedToCompletionList: UCHAR,
}
impl Default for _ALPC_DISPATCH_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KALPC_RESERVE {
    #[doc = "offset: 0x0 (0)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x4 (4)"]
    pub HandleTable: *mut _ALPC_HANDLE_TABLE,
    #[doc = "offset: 0x8 (8)"]
    pub Handle: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Message: *mut _KALPC_MESSAGE,
    #[doc = "offset: 0x10 (16)"]
    pub Active: LONG,
}
impl Default for _KALPC_RESERVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMMUNICATION_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub ConnectionPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x4 (4)"]
    pub ServerCommunicationPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x8 (8)"]
    pub ClientCommunicationPort: *mut _ALPC_PORT,
    #[doc = "offset: 0xc (12)"]
    pub CommunicationList: _LIST_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub HandleTable: _ALPC_HANDLE_TABLE,
    #[doc = "offset: 0x24 (36)"]
    pub CloseMessage: *mut _KALPC_MESSAGE,
}
impl Default for _ALPC_COMMUNICATION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST {
    #[doc = "offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = "offset: 0xc (12)"]
    pub CompletionListLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x10 (16)"]
    pub Mdl: *mut _MDL,
    #[doc = "offset: 0x14 (20)"]
    pub UserVa: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub UserLimit: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub DataUserVa: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub SystemVa: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub TotalSize: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub Header: *mut _ALPC_COMPLETION_LIST_HEADER,
    #[doc = "offset: 0x2c (44)"]
    pub List: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub ListSize: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub Bitmap: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub BitmapSize: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub Data: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub DataSize: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub BitmapLimit: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub BitmapNextHint: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub ConcurrencyCount: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub AttributeFlags: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub AttributeSize: ULONG,
}
impl Default for _ALPC_COMPLETION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x11c (284) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_PORT {
    #[doc = "offset: 0x0 (0)"]
    pub PortListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub CommunicationInfo: *mut _ALPC_COMMUNICATION_INFO,
    #[doc = "offset: 0xc (12)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = "offset: 0x10 (16)"]
    pub CompletionPort: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub CompletionKey: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub CompletionPacketLookaside: *mut _ALPC_COMPLETION_PACKET_LOOKASIDE,
    #[doc = "offset: 0x1c (28)"]
    pub PortContext: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub StaticSecurity: _SECURITY_CLIENT_CONTEXT,
    #[doc = "offset: 0x5c (92)"]
    pub IncomingQueueLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x60 (96)"]
    pub MainQueue: _LIST_ENTRY,
    #[doc = "offset: 0x68 (104)"]
    pub LargeMessageQueue: _LIST_ENTRY,
    #[doc = "offset: 0x70 (112)"]
    pub PendingQueueLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x74 (116)"]
    pub PendingQueue: _LIST_ENTRY,
    #[doc = "offset: 0x7c (124)"]
    pub DirectQueueLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x80 (128)"]
    pub DirectQueue: _LIST_ENTRY,
    #[doc = "offset: 0x88 (136)"]
    pub WaitQueueLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x8c (140)"]
    pub WaitQueue: _LIST_ENTRY,
    pub __bindgen_anon_1: _ALPC_PORT__bindgen_ty_1,
    #[doc = "offset: 0x98 (152)"]
    pub PortAttributes: _ALPC_PORT_ATTRIBUTES,
    #[doc = "offset: 0xc4 (196)"]
    pub ResourceListLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xc8 (200)"]
    pub ResourceListHead: _LIST_ENTRY,
    #[doc = "offset: 0xd0 (208)"]
    pub PortObjectLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0xd4 (212)"]
    pub CompletionList: *mut _ALPC_COMPLETION_LIST,
    #[doc = "offset: 0xd8 (216)"]
    pub CallbackObject: *mut _CALLBACK_OBJECT,
    #[doc = "offset: 0xdc (220)"]
    pub CallbackContext: *mut VOID,
    #[doc = "offset: 0xe0 (224)"]
    pub CanceledQueue: _LIST_ENTRY,
    #[doc = "offset: 0xe8 (232)"]
    pub SequenceNo: LONG,
    #[doc = "offset: 0xec (236)"]
    pub ReferenceNo: LONG,
    #[doc = "offset: 0xf0 (240)"]
    pub ReferenceNoWait: *mut _PALPC_PORT_REFERENCE_WAIT_BLOCK,
    #[doc = "offset: 0xf4 (244)"]
    pub u1: _ALPC_PORT__bindgen_ty_2,
    #[doc = "offset: 0xf8 (248)"]
    pub TargetQueuePort: *mut _ALPC_PORT,
    #[doc = "offset: 0xfc (252)"]
    pub TargetSequencePort: *mut _ALPC_PORT,
    #[doc = "offset: 0x100 (256)"]
    pub CachedMessage: *mut _KALPC_MESSAGE,
    #[doc = "offset: 0x104 (260)"]
    pub MainQueueLength: ULONG,
    #[doc = "offset: 0x108 (264)"]
    pub LargeMessageQueueLength: ULONG,
    #[doc = "offset: 0x10c (268)"]
    pub PendingQueueLength: ULONG,
    #[doc = "offset: 0x110 (272)"]
    pub DirectQueueLength: ULONG,
    #[doc = "offset: 0x114 (276)"]
    pub CanceledQueueLength: ULONG,
    #[doc = "offset: 0x118 (280)"]
    pub WaitQueueLength: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_PORT__bindgen_ty_1 {
    #[doc = "offset: 0x94 (148)"]
    pub Semaphore: *mut _KSEMAPHORE,
    #[doc = "offset: 0x94 (148)"]
    pub DummyEvent: *mut _KEVENT,
}
impl Default for _ALPC_PORT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_PORT__bindgen_ty_2 {
    #[doc = "offset: 0xf4 (244)"]
    pub s1: _ALPC_PORT__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0xf4 (244)"]
    pub State: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_PORT__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _ALPC_PORT__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Initialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Initialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ConnectionPending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConnectionPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ConnectionRefused(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConnectionRefused(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disconnected(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Disconnected(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Closed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Closed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoFlushOnClose(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoFlushOnClose(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReturnExtendedInfo(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReturnExtendedInfo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waitable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Waitable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DynamicSecurity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DynamicSecurity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wow64CompletionList(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wow64CompletionList(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Lpc(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Lpc(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LpcToLpc(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LpcToLpc(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasCompletionList(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasCompletionList(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HadCompletionList(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HadCompletionList(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableCompletionList(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableCompletionList(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Initialized: ULONG,
        Type: ULONG,
        ConnectionPending: ULONG,
        ConnectionRefused: ULONG,
        Disconnected: ULONG,
        Closed: ULONG,
        NoFlushOnClose: ULONG,
        ReturnExtendedInfo: ULONG,
        Waitable: ULONG,
        DynamicSecurity: ULONG,
        Wow64CompletionList: ULONG,
        Lpc: ULONG,
        LpcToLpc: ULONG,
        HasCompletionList: ULONG,
        HadCompletionList: ULONG,
        EnableCompletionList: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Initialized: u32 = unsafe { ::std::mem::transmute(Initialized) };
            Initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ConnectionPending: u32 = unsafe { ::std::mem::transmute(ConnectionPending) };
            ConnectionPending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ConnectionRefused: u32 = unsafe { ::std::mem::transmute(ConnectionRefused) };
            ConnectionRefused as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Disconnected: u32 = unsafe { ::std::mem::transmute(Disconnected) };
            Disconnected as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Closed: u32 = unsafe { ::std::mem::transmute(Closed) };
            Closed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NoFlushOnClose: u32 = unsafe { ::std::mem::transmute(NoFlushOnClose) };
            NoFlushOnClose as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReturnExtendedInfo: u32 = unsafe { ::std::mem::transmute(ReturnExtendedInfo) };
            ReturnExtendedInfo as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Waitable: u32 = unsafe { ::std::mem::transmute(Waitable) };
            Waitable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DynamicSecurity: u32 = unsafe { ::std::mem::transmute(DynamicSecurity) };
            DynamicSecurity as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Wow64CompletionList: u32 = unsafe { ::std::mem::transmute(Wow64CompletionList) };
            Wow64CompletionList as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Lpc: u32 = unsafe { ::std::mem::transmute(Lpc) };
            Lpc as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LpcToLpc: u32 = unsafe { ::std::mem::transmute(LpcToLpc) };
            LpcToLpc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HasCompletionList: u32 = unsafe { ::std::mem::transmute(HasCompletionList) };
            HasCompletionList as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let HadCompletionList: u32 = unsafe { ::std::mem::transmute(HadCompletionList) };
            HadCompletionList as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let EnableCompletionList: u32 = unsafe { ::std::mem::transmute(EnableCompletionList) };
            EnableCompletionList as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ALPC_PORT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ALPC_PORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_SECTION {
    #[doc = "offset: 0x0 (0)"]
    pub SectionObject: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub HandleTable: *mut _ALPC_HANDLE_TABLE,
    #[doc = "offset: 0xc (12)"]
    pub SectionHandle: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = "offset: 0x14 (20)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x18 (24)"]
    pub u1: _KALPC_SECTION__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub NumberOfRegions: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub RegionListHead: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_SECTION__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub s1: _KALPC_SECTION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KALPC_SECTION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_SECTION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Internal(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Internal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Secure(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Secure(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Internal: ULONG, Secure: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Internal: u32 = unsafe { ::std::mem::transmute(Internal) };
            Internal as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Secure: u32 = unsafe { ::std::mem::transmute(Secure) };
            Secure as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_SECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_REGION {
    #[doc = "offset: 0x0 (0)"]
    pub RegionListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Section: *mut _KALPC_SECTION,
    #[doc = "offset: 0xc (12)"]
    pub Offset: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Size: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ViewSize: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub u1: _KALPC_REGION__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub NumberOfViews: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ViewListHead: _LIST_ENTRY,
    #[doc = "offset: 0x28 (40)"]
    pub ReadOnlyView: *mut _KALPC_VIEW,
    #[doc = "offset: 0x2c (44)"]
    pub ReadWriteView: *mut _KALPC_VIEW,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_REGION__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub s1: _KALPC_REGION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KALPC_REGION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_REGION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Secure(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Secure(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Secure: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Secure: u32 = unsafe { ::std::mem::transmute(Secure) };
            Secure as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_REGION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_REGION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x34 (52) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_VIEW {
    #[doc = "offset: 0x0 (0)"]
    pub ViewListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Region: *mut _KALPC_REGION,
    #[doc = "offset: 0xc (12)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = "offset: 0x10 (16)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = "offset: 0x14 (20)"]
    pub Address: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub Size: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub SecureViewHandle: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub WriteAccessHandle: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub u1: _KALPC_VIEW__bindgen_ty_1,
    #[doc = "offset: 0x28 (40)"]
    pub NumberOfOwnerMessages: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub ProcessViewListEntry: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_VIEW__bindgen_ty_1 {
    #[doc = "offset: 0x24 (36)"]
    pub s1: _KALPC_VIEW__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KALPC_VIEW__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_VIEW__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn WriteAccess(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteAccess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AutoRelease(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoRelease(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceUnlink(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForceUnlink(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemSpace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemSpace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WriteAccess: ULONG,
        AutoRelease: ULONG,
        ForceUnlink: ULONG,
        SystemSpace: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WriteAccess: u32 = unsafe { ::std::mem::transmute(WriteAccess) };
            WriteAccess as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AutoRelease: u32 = unsafe { ::std::mem::transmute(AutoRelease) };
            AutoRelease as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ForceUnlink: u32 = unsafe { ::std::mem::transmute(ForceUnlink) };
            ForceUnlink as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SystemSpace: u32 = unsafe { ::std::mem::transmute(SystemSpace) };
            SystemSpace as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_VIEW__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_VIEW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub WorkQueueLinks: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Parameters: _WORK_QUEUE_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x48 (72)"]
    pub Function: UCHAR,
    #[doc = "offset: 0x4c (76)"]
    pub Partition: *mut _CC_PARTITION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WORK_QUEUE_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub Read: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x8 (8)"]
    pub Write: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_2,
    #[doc = "offset: 0x8 (8)"]
    pub Event: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_3,
    #[doc = "offset: 0x8 (8)"]
    pub Notification: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_4,
    #[doc = "offset: 0x8 (8)"]
    pub LowPriWrite: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_5,
    #[doc = "offset: 0x8 (8)"]
    pub AsyncRead: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x4 (4)"]
    pub DiskIoAttribution: *mut VOID,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub SharedCacheMap: *mut _SHARED_CACHE_MAP,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub Event: *mut _KEVENT,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "offset: 0x0 (0)"]
    pub Reason: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "offset: 0x0 (0)"]
    pub SharedCacheMap: *mut _SHARED_CACHE_MAP,
    #[doc = "offset: 0x4 (4)"]
    pub IoStatus: *mut _IO_STATUS_BLOCK,
    #[doc = "offset: 0x8 (8)"]
    pub CallerWaitEvent: _KEVENT,
    #[doc = "offset: 0x18 (24)"]
    pub IsLowPriWriteBehind: UCHAR,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "offset: 0x0 (0)"]
    pub SharedCacheMap: *mut _SHARED_CACHE_MAP,
    #[doc = "offset: 0x8 (8)"]
    pub FileOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x10 (16)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub Length: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PrefetchList: *mut _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub PrefetchPagePriority: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Mdl: *mut _MDL,
    #[doc = "offset: 0x24 (36)"]
    pub IoStatusBlock: *mut _IO_STATUS_BLOCK,
    #[doc = "offset: 0x28 (40)"]
    pub CallbackContext: *mut _CC_ASYNC_READ_CONTEXT,
    #[doc = "offset: 0x2c (44)"]
    pub OriginatingProcess: *mut _EPROCESS,
    #[doc = "offset: 0x30 (48)"]
    pub IoIssuerThread: *mut _ETHREAD,
    #[doc = "offset: 0x34 (52)"]
    pub DiskIoAttribution: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub RequestorMode: CHAR,
    #[doc = "offset: 0x3c (60)"]
    pub NestingLevel: ULONG,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WORK_QUEUE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KRESOURCEMANAGER_COMPLETION_BINDING {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationListHead: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Port: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub Key: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub BindingProcess: *mut _EPROCESS,
}
impl Default for _KRESOURCEMANAGER_COMPLETION_BINDING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x154 (340) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KRESOURCEMANAGER {
    #[doc = "offset: 0x0 (0)"]
    pub NotificationAvailable: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub cookie: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub State: _KRESOURCEMANAGER_STATE,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub Mutex: _KMUTANT,
    #[doc = "offset: 0x3c (60)"]
    pub NamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = "offset: 0x50 (80)"]
    pub RmId: _GUID,
    #[doc = "offset: 0x60 (96)"]
    pub NotificationQueue: _KQUEUE,
    #[doc = "offset: 0x88 (136)"]
    pub NotificationMutex: _KMUTANT,
    #[doc = "offset: 0xa8 (168)"]
    pub EnlistmentHead: _LIST_ENTRY,
    #[doc = "offset: 0xb0 (176)"]
    pub EnlistmentCount: ULONG,
    pub NotificationRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _KENLISTMENT,
            arg2: *mut VOID,
            arg3: *mut VOID,
            arg4: ULONG,
            arg5: *mut _LARGE_INTEGER,
            arg6: ULONG,
            arg7: *mut VOID,
        ) -> LONG,
    >,
    #[doc = "offset: 0xb8 (184)"]
    pub Key: *mut VOID,
    #[doc = "offset: 0xbc (188)"]
    pub ProtocolListHead: _LIST_ENTRY,
    #[doc = "offset: 0xc4 (196)"]
    pub PendingPropReqListHead: _LIST_ENTRY,
    #[doc = "offset: 0xcc (204)"]
    pub CRMListEntry: _LIST_ENTRY,
    #[doc = "offset: 0xd4 (212)"]
    pub Tm: *mut _KTM,
    #[doc = "offset: 0xd8 (216)"]
    pub Description: _UNICODE_STRING,
    #[doc = "offset: 0xe0 (224)"]
    pub Enlistments: _KTMOBJECT_NAMESPACE,
    #[doc = "offset: 0x140 (320)"]
    pub CompletionBinding: _KRESOURCEMANAGER_COMPLETION_BINDING,
}
impl Default for _KRESOURCEMANAGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x238 (568) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTM {
    #[doc = "offset: 0x0 (0)"]
    pub cookie: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub Mutex: _KMUTANT,
    #[doc = "offset: 0x24 (36)"]
    pub State: KTM_STATE,
    #[doc = "offset: 0x28 (40)"]
    pub NamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = "offset: 0x3c (60)"]
    pub TmIdentity: _GUID,
    #[doc = "offset: 0x4c (76)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub VolatileFlags: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub LogFileName: _UNICODE_STRING,
    #[doc = "offset: 0x5c (92)"]
    pub LogFileObject: *mut _FILE_OBJECT,
    #[doc = "offset: 0x60 (96)"]
    pub MarshallingContext: *mut VOID,
    #[doc = "offset: 0x64 (100)"]
    pub LogManagementContext: *mut VOID,
    #[doc = "offset: 0x68 (104)"]
    pub Transactions: _KTMOBJECT_NAMESPACE,
    #[doc = "offset: 0xc8 (200)"]
    pub ResourceManagers: _KTMOBJECT_NAMESPACE,
    #[doc = "offset: 0x128 (296)"]
    pub LsnOrderedMutex: _KMUTANT,
    #[doc = "offset: 0x148 (328)"]
    pub LsnOrderedList: _LIST_ENTRY,
    #[doc = "offset: 0x150 (336)"]
    pub CommitVirtualClock: _LARGE_INTEGER,
    #[doc = "offset: 0x158 (344)"]
    pub CommitVirtualClockMutex: _FAST_MUTEX,
    #[doc = "offset: 0x178 (376)"]
    pub BaseLsn: _CLS_LSN,
    #[doc = "offset: 0x180 (384)"]
    pub CurrentReadLsn: _CLS_LSN,
    #[doc = "offset: 0x188 (392)"]
    pub LastRecoveredLsn: _CLS_LSN,
    #[doc = "offset: 0x190 (400)"]
    pub TmRmHandle: *mut VOID,
    #[doc = "offset: 0x194 (404)"]
    pub TmRm: *mut _KRESOURCEMANAGER,
    #[doc = "offset: 0x198 (408)"]
    pub LogFullNotifyEvent: _KEVENT,
    #[doc = "offset: 0x1a8 (424)"]
    pub CheckpointWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x1b8 (440)"]
    pub CheckpointTargetLsn: _CLS_LSN,
    #[doc = "offset: 0x1c0 (448)"]
    pub LogFullCompletedWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x1d0 (464)"]
    pub LogWriteResource: _ERESOURCE,
    #[doc = "offset: 0x208 (520)"]
    pub LogFlags: ULONG,
    #[doc = "offset: 0x20c (524)"]
    pub LogFullStatus: LONG,
    #[doc = "offset: 0x210 (528)"]
    pub RecoveryStatus: LONG,
    #[doc = "offset: 0x218 (536)"]
    pub LastCheckBaseLsn: _CLS_LSN,
    #[doc = "offset: 0x220 (544)"]
    pub RestartOrderedList: _LIST_ENTRY,
    #[doc = "offset: 0x228 (552)"]
    pub OfflineWorkItem: _WORK_QUEUE_ITEM,
}
impl Default for _KTM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x168 (360) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KENLISTMENT {
    #[doc = "offset: 0x0 (0)"]
    pub cookie: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = "offset: 0x18 (24)"]
    pub EnlistmentId: _GUID,
    #[doc = "offset: 0x28 (40)"]
    pub Mutex: _KMUTANT,
    #[doc = "offset: 0x48 (72)"]
    pub NextSameTx: _LIST_ENTRY,
    #[doc = "offset: 0x50 (80)"]
    pub NextSameRm: _LIST_ENTRY,
    #[doc = "offset: 0x58 (88)"]
    pub ResourceManager: *mut _KRESOURCEMANAGER,
    #[doc = "offset: 0x5c (92)"]
    pub Transaction: *mut _KTRANSACTION,
    #[doc = "offset: 0x60 (96)"]
    pub State: _KENLISTMENT_STATE,
    #[doc = "offset: 0x64 (100)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub NotificationMask: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub Key: *mut VOID,
    #[doc = "offset: 0x70 (112)"]
    pub KeyRefCount: ULONG,
    #[doc = "offset: 0x74 (116)"]
    pub RecoveryInformation: *mut VOID,
    #[doc = "offset: 0x78 (120)"]
    pub RecoveryInformationLength: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub DynamicNameInformation: *mut VOID,
    #[doc = "offset: 0x80 (128)"]
    pub DynamicNameInformationLength: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub FinalNotification: *mut _KTMNOTIFICATION_PACKET,
    #[doc = "offset: 0x88 (136)"]
    pub SupSubEnlistment: *mut _KENLISTMENT,
    #[doc = "offset: 0x8c (140)"]
    pub SupSubEnlHandle: *mut VOID,
    #[doc = "offset: 0x90 (144)"]
    pub SubordinateTxHandle: *mut VOID,
    #[doc = "offset: 0x94 (148)"]
    pub CrmEnlistmentEnId: _GUID,
    #[doc = "offset: 0xa4 (164)"]
    pub CrmEnlistmentTmId: _GUID,
    #[doc = "offset: 0xb4 (180)"]
    pub CrmEnlistmentRmId: _GUID,
    #[doc = "offset: 0xc4 (196)"]
    pub NextHistory: ULONG,
    #[doc = "offset: 0xc8 (200)"]
    pub History: [_KENLISTMENT_HISTORY; 20usize],
}
impl Default for _KENLISTMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x44 (68) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EPARTITION {
    #[doc = "offset: 0x0 (0)"]
    pub MmPartition: *mut VOID,
    #[doc = "offset: 0x4 (4)"]
    pub CcPartition: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub ExPartition: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub HardReferenceCount: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub OpenHandleCount: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub ActivePartitionLinks: _LIST_ENTRY,
    #[doc = "offset: 0x1c (28)"]
    pub ParentPartition: *mut _EPARTITION,
    #[doc = "offset: 0x20 (32)"]
    pub TeardownWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x30 (48)"]
    pub TeardownLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x34 (52)"]
    pub SystemProcess: *mut _EPROCESS,
    #[doc = "offset: 0x38 (56)"]
    pub SystemProcessHandle: *mut VOID,
    pub __bindgen_anon_1: _EPARTITION__bindgen_ty_1,
    #[doc = "offset: 0x40 (64)"]
    pub Padding: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPARTITION__bindgen_ty_1 {
    #[doc = "offset: 0x3c (60)"]
    pub PartitionFlags: ULONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _EPARTITION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _EPARTITION__bindgen_ty_1 {
    #[inline]
    pub fn PairedWithJob(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PairedWithJob(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PairedWithJob: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PairedWithJob: u32 = unsafe { ::std::mem::transmute(PairedWithJob) };
            PairedWithJob as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPARTITION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION_STORES {
    #[doc = "offset: 0x0 (0)"]
    pub WriteAllStoreHintedPages: _MI_PARTITION_STORES__bindgen_ty_1,
    #[doc = "offset: 0x4 (4)"]
    pub VirtualPageFileNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub Registered: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ReadClusterSizeMax: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub EvictFlushRequestCount: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub ModifiedWriteDisableCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub WriteIssueFailures: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub WritesOutstanding: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub EvictFlushLock: LONG,
    #[doc = "offset: 0x24 (36)"]
    pub EvictionThread: *mut _ETHREAD,
    #[doc = "offset: 0x28 (40)"]
    pub EvictEvent: _KEVENT,
    #[doc = "offset: 0x38 (56)"]
    pub WriteSupportSListHead: _SLIST_HEADER,
    #[doc = "offset: 0x40 (64)"]
    pub EvictFlushCompleteEvent: _KEVENT,
    #[doc = "offset: 0x50 (80)"]
    pub ModifiedWriteFailedBitmap: *mut _RTL_BITMAP,
    #[doc = "offset: 0x54 (84)"]
    pub StoreProcess: *mut _EPROCESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PARTITION_STORES__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x0 (0)"]
    pub Long: LONG,
}
impl Default for _MI_PARTITION_STORES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_PARTITION_STORES__bindgen_ty_1 {
    #[inline]
    pub fn FlushCompleting(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlushCompleting(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FlushInProgress(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_FlushInProgress(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FlushCompleting: LONG,
        FlushInProgress: LONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FlushCompleting: u32 = unsafe { ::std::mem::transmute(FlushCompleting) };
            FlushCompleting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let FlushInProgress: u32 = unsafe { ::std::mem::transmute(FlushInProgress) };
            FlushInProgress as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MI_PARTITION_STORES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x4 (4)"]
    pub Type: _MM_PAGE_ACCESS_TYPE,
    pub __bindgen_anon_1: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub CreateTime: ULONGLONG,
    pub __bindgen_anon_2: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_2,
    pub __bindgen_anon_3: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub EmptySequenceNumber: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CurrentFileIndex: ULONG,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_2 {
    #[doc = "offset: 0x18 (24)"]
    pub EmptyTime: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub TempEntry: *mut _MM_PAGE_ACCESS_INFO,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3 {
    pub __bindgen_anon_1: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_1 {
    #[doc = "offset: 0x20 (32)"]
    pub PageEntry: *mut _MM_PAGE_ACCESS_INFO,
    #[doc = "offset: 0x24 (36)"]
    pub FileEntry: *mut ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub FirstFileEntry: *mut ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub Process: *mut _EPROCESS,
    #[doc = "offset: 0x30 (48)"]
    pub SessionId: ULONG,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_2 {
    #[doc = "offset: 0x20 (32)"]
    pub PageFrameEntry: *mut ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub LastPageFrameEntry: *mut ULONG,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_STANDBY_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub FirstDecayPage: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub PfnDecayFreeSList: _SLIST_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub PfnRepurposeLog: *mut _MM_PAGE_ACCESS_INFO_HEADER,
    #[doc = "offset: 0x14 (20)"]
    pub AllocatePfnRepurposeDpc: _KDPC,
}
impl Default for _MI_STANDBY_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_ACCESS_LOG_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub CcAccessLog: *mut _MM_PAGE_ACCESS_INFO_HEADER,
    #[doc = "offset: 0x4 (4)"]
    pub DisableAccessLogging: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x14 (20)"]
    pub Enabled: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub MinLoggingPriority: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub AccessLoggingLock: ULONG,
}
impl Default for _MI_ACCESS_LOG_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REALTIME_CONSUMER {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ProcessHandle: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub ProcessObject: *mut _EPROCESS,
    #[doc = "offset: 0x10 (16)"]
    pub NextNotDelivered: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub RealtimeConnectContext: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub DisconnectEvent: *mut _KEVENT,
    #[doc = "offset: 0x1c (28)"]
    pub DataAvailableEvent: *mut _KEVENT,
    #[doc = "offset: 0x20 (32)"]
    pub UserBufferCount: *mut ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub UserBufferListHead: *mut _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x28 (40)"]
    pub BuffersLost: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub EmptyBuffersCount: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub LoggerId: USHORT,
    pub __bindgen_anon_1: _ETW_REALTIME_CONSUMER__bindgen_ty_1,
    #[doc = "offset: 0x34 (52)"]
    pub ReservedBufferSpaceBitMap: _RTL_BITMAP,
    #[doc = "offset: 0x3c (60)"]
    pub ReservedBufferSpace: *mut UCHAR,
    #[doc = "offset: 0x40 (64)"]
    pub ReservedBufferSpaceSize: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub UserPagesAllocated: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub UserPagesReused: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub EventsLostCount: *mut ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub BuffersLostCount: *mut ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub SiloState: *mut _ETW_SILODRIVERSTATE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_REALTIME_CONSUMER__bindgen_ty_1 {
    #[doc = "offset: 0x32 (50)"]
    pub Flags: UCHAR,
    pub __bindgen_anon_1: _ETW_REALTIME_CONSUMER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_REALTIME_CONSUMER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _ETW_REALTIME_CONSUMER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ShutDownRequested(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ShutDownRequested(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NewBuffersLost(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NewBuffersLost(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disconnected(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Disconnected(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Notified(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Notified(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ShutDownRequested: UCHAR,
        NewBuffersLost: UCHAR,
        Disconnected: UCHAR,
        Notified: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ShutDownRequested: u8 = unsafe { ::std::mem::transmute(ShutDownRequested) };
            ShutDownRequested as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NewBuffersLost: u8 = unsafe { ::std::mem::transmute(NewBuffersLost) };
            NewBuffersLost as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Disconnected: u8 = unsafe { ::std::mem::transmute(Disconnected) };
            Disconnected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Notified: u8 = unsafe { ::std::mem::transmute(Notified) };
            Notified as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETW_REALTIME_CONSUMER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_REALTIME_CONSUMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x5a0 (1440) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_LOGGER_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub LoggerId: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub BufferSize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MaximumEventSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub LoggerMode: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub AcceptNewEvents: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub EventMarker: [ULONG; 1usize],
    #[doc = "offset: 0x18 (24)"]
    pub ErrorMarker: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub SizeMask: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub GetCpuClock: ::std::option::Option<unsafe extern "C" fn() -> LONGLONG>,
    #[doc = "offset: 0x24 (36)"]
    pub LoggerThread: *mut _ETHREAD,
    #[doc = "offset: 0x28 (40)"]
    pub LoggerStatus: LONG,
    #[doc = "offset: 0x2c (44)"]
    pub FailureReason: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub BufferQueue: _ETW_BUFFER_QUEUE,
    #[doc = "offset: 0x38 (56)"]
    pub OverflowQueue: _ETW_BUFFER_QUEUE,
    #[doc = "offset: 0x40 (64)"]
    pub GlobalList: _LIST_ENTRY,
    #[doc = "offset: 0x48 (72)"]
    pub DebugIdTrackingList: _LIST_ENTRY,
    #[doc = "offset: 0x50 (80)"]
    pub DecodeControlList: *mut _ETW_DECODE_CONTROL_ENTRY,
    #[doc = "offset: 0x54 (84)"]
    pub DecodeControlCount: ULONG,
    pub __bindgen_anon_1: _WMI_LOGGER_CONTEXT__bindgen_ty_1,
    #[doc = "offset: 0x5c (92)"]
    pub LoggerName: _UNICODE_STRING,
    #[doc = "offset: 0x64 (100)"]
    pub LogFileName: _UNICODE_STRING,
    #[doc = "offset: 0x6c (108)"]
    pub LogFilePattern: _UNICODE_STRING,
    #[doc = "offset: 0x74 (116)"]
    pub NewLogFileName: _UNICODE_STRING,
    #[doc = "offset: 0x7c (124)"]
    pub ClockType: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub LastFlushedBuffer: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub FlushTimer: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub FlushThreshold: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub ByteOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x98 (152)"]
    pub MinimumBuffers: ULONG,
    #[doc = "offset: 0x9c (156)"]
    pub BuffersAvailable: LONG,
    #[doc = "offset: 0xa0 (160)"]
    pub NumberOfBuffers: LONG,
    #[doc = "offset: 0xa4 (164)"]
    pub MaximumBuffers: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub EventsLost: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub PeakBuffersCount: LONG,
    #[doc = "offset: 0xb0 (176)"]
    pub BuffersWritten: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub LogBuffersLost: ULONG,
    #[doc = "offset: 0xb8 (184)"]
    pub RealTimeBuffersDelivered: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub RealTimeBuffersLost: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub SequencePtr: *mut LONG,
    #[doc = "offset: 0xc4 (196)"]
    pub LocalSequence: ULONG,
    #[doc = "offset: 0xc8 (200)"]
    pub InstanceGuid: _GUID,
    #[doc = "offset: 0xd8 (216)"]
    pub MaximumFileSize: ULONG,
    #[doc = "offset: 0xdc (220)"]
    pub FileCounter: LONG,
    #[doc = "offset: 0xe0 (224)"]
    pub PoolType: _POOL_TYPE,
    #[doc = "offset: 0xe8 (232)"]
    pub ReferenceTime: _ETW_REF_CLOCK,
    #[doc = "offset: 0xf8 (248)"]
    pub CollectionOn: LONG,
    #[doc = "offset: 0xfc (252)"]
    pub ProviderInfoSize: ULONG,
    #[doc = "offset: 0x100 (256)"]
    pub Consumers: _LIST_ENTRY,
    #[doc = "offset: 0x108 (264)"]
    pub NumConsumers: ULONG,
    #[doc = "offset: 0x10c (268)"]
    pub TransitionConsumer: *mut _ETW_REALTIME_CONSUMER,
    #[doc = "offset: 0x110 (272)"]
    pub RealtimeLogfileHandle: *mut VOID,
    #[doc = "offset: 0x114 (276)"]
    pub RealtimeLogfileName: _UNICODE_STRING,
    #[doc = "offset: 0x120 (288)"]
    pub RealtimeWriteOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x128 (296)"]
    pub RealtimeReadOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x130 (304)"]
    pub RealtimeLogfileSize: _LARGE_INTEGER,
    #[doc = "offset: 0x138 (312)"]
    pub RealtimeLogfileUsage: ULONGLONG,
    #[doc = "offset: 0x140 (320)"]
    pub RealtimeMaximumFileSize: ULONGLONG,
    #[doc = "offset: 0x148 (328)"]
    pub RealtimeBuffersSaved: ULONG,
    #[doc = "offset: 0x150 (336)"]
    pub RealtimeReferenceTime: _ETW_REF_CLOCK,
    #[doc = "offset: 0x160 (352)"]
    pub NewRTEventsLost: _ETW_RT_EVENT_LOSS,
    #[doc = "offset: 0x164 (356)"]
    pub LoggerEvent: _KEVENT,
    #[doc = "offset: 0x174 (372)"]
    pub FlushEvent: _KEVENT,
    #[doc = "offset: 0x188 (392)"]
    pub FlushTimeOutTimer: _KTIMER,
    #[doc = "offset: 0x1b0 (432)"]
    pub LoggerDpc: _KDPC,
    #[doc = "offset: 0x1d0 (464)"]
    pub LoggerMutex: _KMUTANT,
    #[doc = "offset: 0x1f0 (496)"]
    pub LoggerLock: _EX_PUSH_LOCK,
    pub __bindgen_anon_2: _WMI_LOGGER_CONTEXT__bindgen_ty_2,
    #[doc = "offset: 0x1f8 (504)"]
    pub ClientSecurityContext: _SECURITY_CLIENT_CONTEXT,
    #[doc = "offset: 0x234 (564)"]
    pub TokenAccessInformation: *mut _TOKEN_ACCESS_INFORMATION,
    #[doc = "offset: 0x238 (568)"]
    pub SecurityDescriptor: _EX_FAST_REF,
    #[doc = "offset: 0x240 (576)"]
    pub StartTime: _LARGE_INTEGER,
    #[doc = "offset: 0x248 (584)"]
    pub LogFileHandle: *mut VOID,
    #[doc = "offset: 0x250 (592)"]
    pub BufferSequenceNumber: LONGLONG,
    pub __bindgen_anon_3: _WMI_LOGGER_CONTEXT__bindgen_ty_3,
    pub __bindgen_anon_4: _WMI_LOGGER_CONTEXT__bindgen_ty_4,
    #[doc = "offset: 0x260 (608)"]
    pub StackTraceBlock: _ETW_STACK_TRACE_BLOCK,
    #[doc = "offset: 0x4e8 (1256)"]
    pub HookIdMap: _RTL_BITMAP,
    #[doc = "offset: 0x4f0 (1264)"]
    pub StackCache: *mut _ETW_STACK_CACHE,
    #[doc = "offset: 0x4f4 (1268)"]
    pub PmcData: *mut _ETW_PMC_SUPPORT,
    #[doc = "offset: 0x4f8 (1272)"]
    pub LbrData: *mut _ETW_LBR_SUPPORT,
    #[doc = "offset: 0x4fc (1276)"]
    pub BinaryTrackingList: _LIST_ENTRY,
    #[doc = "offset: 0x504 (1284)"]
    pub ScratchArray: *mut *mut _WMI_BUFFER_HEADER,
    #[doc = "offset: 0x508 (1288)"]
    pub DisallowedGuids: _DISALLOWED_GUIDS,
    #[doc = "offset: 0x510 (1296)"]
    pub RelativeTimerDueTime: LONGLONG,
    #[doc = "offset: 0x518 (1304)"]
    pub PeriodicCaptureStateGuids: _PERIODIC_CAPTURE_STATE_GUIDS,
    #[doc = "offset: 0x520 (1312)"]
    pub PeriodicCaptureStateTimer: *mut _EX_TIMER,
    #[doc = "offset: 0x524 (1316)"]
    pub PeriodicCaptureStateTimerState: _ETW_PERIODIC_TIMER_STATE,
    #[doc = "offset: 0x528 (1320)"]
    pub SoftRestartContext: *mut _ETW_SOFT_RESTART_CONTEXT,
    #[doc = "offset: 0x52c (1324)"]
    pub SiloState: *mut _ETW_SILODRIVERSTATE,
    #[doc = "offset: 0x530 (1328)"]
    pub CompressionWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x540 (1344)"]
    pub CompressionWorkItemState: LONG,
    #[doc = "offset: 0x544 (1348)"]
    pub CompressionLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x548 (1352)"]
    pub CompressionTarget: *mut _WMI_BUFFER_HEADER,
    #[doc = "offset: 0x54c (1356)"]
    pub CompressionWorkspace: *mut VOID,
    #[doc = "offset: 0x550 (1360)"]
    pub CompressionOn: LONG,
    #[doc = "offset: 0x554 (1364)"]
    pub CompressionRatioGuess: ULONG,
    #[doc = "offset: 0x558 (1368)"]
    pub PartialBufferCompressionLevel: ULONG,
    #[doc = "offset: 0x55c (1372)"]
    pub CompressionResumptionMode: ETW_COMPRESSION_RESUMPTION_MODE,
    #[doc = "offset: 0x560 (1376)"]
    pub PlaceholderList: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x564 (1380)"]
    pub CompressionDpc: _KDPC,
    #[doc = "offset: 0x588 (1416)"]
    pub LastBufferSwitchTime: _LARGE_INTEGER,
    #[doc = "offset: 0x590 (1424)"]
    pub BufferWriteDuration: _LARGE_INTEGER,
    #[doc = "offset: 0x598 (1432)"]
    pub BufferCompressDuration: _LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_CONTEXT__bindgen_ty_1 {
    #[doc = "offset: 0x58 (88)"]
    pub BatchedBufferList: *mut _WMI_BUFFER_HEADER,
    #[doc = "offset: 0x58 (88)"]
    pub CurrentBuffer: _EX_FAST_REF,
}
impl Default for _WMI_LOGGER_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_CONTEXT__bindgen_ty_2 {
    #[doc = "offset: 0x1f4 (500)"]
    pub BufferListSpinLock: ULONG,
    #[doc = "offset: 0x1f4 (500)"]
    pub BufferListPushLock: _EX_PUSH_LOCK,
}
impl Default for _WMI_LOGGER_CONTEXT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_CONTEXT__bindgen_ty_3 {
    #[doc = "offset: 0x258 (600)"]
    pub Flags: ULONG,
    pub __bindgen_anon_1: _WMI_LOGGER_CONTEXT__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_LOGGER_CONTEXT__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WMI_LOGGER_CONTEXT__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn Persistent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Persistent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AutoLogger(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoLogger(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FsReady(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FsReady(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RealTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wow(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelTrace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelTrace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoMoreEnable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoMoreEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackTracing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackTracing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorLogged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorLogged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RealtimeLoggerContextFreed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RealtimeLoggerContextFreed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PebsTracing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PebsTracing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PmcCounters(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PmcCounters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageAlignBuffers(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PageAlignBuffers(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackLookasideListAllocated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackLookasideListAllocated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecurityTrace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecurityTrace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LastBranchTracing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LastBranchTracing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemLoggerIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SystemLoggerIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn StackCaching(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackCaching(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareFlags2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_SpareFlags2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Persistent: ULONG,
        AutoLogger: ULONG,
        FsReady: ULONG,
        RealTime: ULONG,
        Wow: ULONG,
        KernelTrace: ULONG,
        NoMoreEnable: ULONG,
        StackTracing: ULONG,
        ErrorLogged: ULONG,
        RealtimeLoggerContextFreed: ULONG,
        PebsTracing: ULONG,
        PmcCounters: ULONG,
        PageAlignBuffers: ULONG,
        StackLookasideListAllocated: ULONG,
        SecurityTrace: ULONG,
        LastBranchTracing: ULONG,
        SystemLoggerIndex: ULONG,
        StackCaching: ULONG,
        SpareFlags2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Persistent: u32 = unsafe { ::std::mem::transmute(Persistent) };
            Persistent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AutoLogger: u32 = unsafe { ::std::mem::transmute(AutoLogger) };
            AutoLogger as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FsReady: u32 = unsafe { ::std::mem::transmute(FsReady) };
            FsReady as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RealTime: u32 = unsafe { ::std::mem::transmute(RealTime) };
            RealTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Wow: u32 = unsafe { ::std::mem::transmute(Wow) };
            Wow as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let KernelTrace: u32 = unsafe { ::std::mem::transmute(KernelTrace) };
            KernelTrace as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NoMoreEnable: u32 = unsafe { ::std::mem::transmute(NoMoreEnable) };
            NoMoreEnable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let StackTracing: u32 = unsafe { ::std::mem::transmute(StackTracing) };
            StackTracing as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ErrorLogged: u32 = unsafe { ::std::mem::transmute(ErrorLogged) };
            ErrorLogged as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RealtimeLoggerContextFreed: u32 =
                unsafe { ::std::mem::transmute(RealtimeLoggerContextFreed) };
            RealtimeLoggerContextFreed as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PebsTracing: u32 = unsafe { ::std::mem::transmute(PebsTracing) };
            PebsTracing as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PmcCounters: u32 = unsafe { ::std::mem::transmute(PmcCounters) };
            PmcCounters as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PageAlignBuffers: u32 = unsafe { ::std::mem::transmute(PageAlignBuffers) };
            PageAlignBuffers as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let StackLookasideListAllocated: u32 =
                unsafe { ::std::mem::transmute(StackLookasideListAllocated) };
            StackLookasideListAllocated as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let SecurityTrace: u32 = unsafe { ::std::mem::transmute(SecurityTrace) };
            SecurityTrace as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let LastBranchTracing: u32 = unsafe { ::std::mem::transmute(LastBranchTracing) };
            LastBranchTracing as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let SystemLoggerIndex: u32 = unsafe { ::std::mem::transmute(SystemLoggerIndex) };
            SystemLoggerIndex as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let StackCaching: u32 = unsafe { ::std::mem::transmute(StackCaching) };
            StackCaching as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let SpareFlags2: u32 = unsafe { ::std::mem::transmute(SpareFlags2) };
            SpareFlags2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _WMI_LOGGER_CONTEXT__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_CONTEXT__bindgen_ty_4 {
    #[doc = "offset: 0x25c (604)"]
    pub RequestFlag: ULONG,
    pub __bindgen_anon_1: _WMI_LOGGER_CONTEXT__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_LOGGER_CONTEXT__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WMI_LOGGER_CONTEXT__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn DbgRequestNewFile(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestNewFile(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestUpdateFile(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestUpdateFile(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestFlush(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestFlush(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestDisableRealtime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestDisableRealtime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestDisconnectConsumer(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestDisconnectConsumer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestConnectConsumer(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestConnectConsumer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestNotifyConsumer(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestNotifyConsumer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestUpdateHeader(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestUpdateHeader(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestDeferredFlush(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestDeferredFlush(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestDeferredFlushTimer(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestDeferredFlushTimer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestFlushTimer(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestFlushTimer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRequestUpdateDebugger(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgRequestUpdateDebugger(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSpareRequestFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_DbgSpareRequestFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgRequestNewFile: ULONG,
        DbgRequestUpdateFile: ULONG,
        DbgRequestFlush: ULONG,
        DbgRequestDisableRealtime: ULONG,
        DbgRequestDisconnectConsumer: ULONG,
        DbgRequestConnectConsumer: ULONG,
        DbgRequestNotifyConsumer: ULONG,
        DbgRequestUpdateHeader: ULONG,
        DbgRequestDeferredFlush: ULONG,
        DbgRequestDeferredFlushTimer: ULONG,
        DbgRequestFlushTimer: ULONG,
        DbgRequestUpdateDebugger: ULONG,
        DbgSpareRequestFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgRequestNewFile: u32 = unsafe { ::std::mem::transmute(DbgRequestNewFile) };
            DbgRequestNewFile as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgRequestUpdateFile: u32 = unsafe { ::std::mem::transmute(DbgRequestUpdateFile) };
            DbgRequestUpdateFile as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgRequestFlush: u32 = unsafe { ::std::mem::transmute(DbgRequestFlush) };
            DbgRequestFlush as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgRequestDisableRealtime: u32 =
                unsafe { ::std::mem::transmute(DbgRequestDisableRealtime) };
            DbgRequestDisableRealtime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgRequestDisconnectConsumer: u32 =
                unsafe { ::std::mem::transmute(DbgRequestDisconnectConsumer) };
            DbgRequestDisconnectConsumer as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgRequestConnectConsumer: u32 =
                unsafe { ::std::mem::transmute(DbgRequestConnectConsumer) };
            DbgRequestConnectConsumer as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgRequestNotifyConsumer: u32 =
                unsafe { ::std::mem::transmute(DbgRequestNotifyConsumer) };
            DbgRequestNotifyConsumer as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DbgRequestUpdateHeader: u32 =
                unsafe { ::std::mem::transmute(DbgRequestUpdateHeader) };
            DbgRequestUpdateHeader as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DbgRequestDeferredFlush: u32 =
                unsafe { ::std::mem::transmute(DbgRequestDeferredFlush) };
            DbgRequestDeferredFlush as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DbgRequestDeferredFlushTimer: u32 =
                unsafe { ::std::mem::transmute(DbgRequestDeferredFlushTimer) };
            DbgRequestDeferredFlushTimer as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DbgRequestFlushTimer: u32 = unsafe { ::std::mem::transmute(DbgRequestFlushTimer) };
            DbgRequestFlushTimer as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DbgRequestUpdateDebugger: u32 =
                unsafe { ::std::mem::transmute(DbgRequestUpdateDebugger) };
            DbgRequestUpdateDebugger as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let DbgSpareRequestFlags: u32 = unsafe { ::std::mem::transmute(DbgSpareRequestFlags) };
            DbgSpareRequestFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _WMI_LOGGER_CONTEXT__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_LOGGER_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGK_SILOSTATE {
    #[doc = "offset: 0x0 (0)"]
    pub ErrorPortLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x4 (4)"]
    pub ErrorPort: *mut _DBGKP_ERROR_PORT,
    #[doc = "offset: 0x8 (8)"]
    pub ErrorProcess: *mut _EPROCESS,
    #[doc = "offset: 0xc (12)"]
    pub ErrorPortRegisteredEvent: *mut _KEVENT,
}
impl Default for _DBGK_SILOSTATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2a0 (672) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ESERVERSILO_GLOBALS {
    #[doc = "offset: 0x0 (0)"]
    pub ObSiloState: _OBP_SILODRIVERSTATE,
    #[doc = "offset: 0x1a4 (420)"]
    pub SeSiloState: _SEP_SILOSTATE,
    #[doc = "offset: 0x1c0 (448)"]
    pub SeRmSiloState: _SEP_RM_LSA_CONNECTION_STATE,
    #[doc = "offset: 0x1f0 (496)"]
    pub EtwSiloState: *mut _ETW_SILODRIVERSTATE,
    #[doc = "offset: 0x1f4 (500)"]
    pub MiSessionLeaderProcess: *mut _EPROCESS,
    #[doc = "offset: 0x1f8 (504)"]
    pub ExpDefaultErrorPortProcess: *mut _EPROCESS,
    #[doc = "offset: 0x1fc (508)"]
    pub ExpDefaultErrorPort: *mut VOID,
    #[doc = "offset: 0x200 (512)"]
    pub HardErrorState: ULONG,
    #[doc = "offset: 0x208 (520)"]
    pub WnfSiloState: _WNF_SILODRIVERSTATE,
    #[doc = "offset: 0x238 (568)"]
    pub DbgkSiloState: _DBGK_SILOSTATE,
    #[doc = "offset: 0x248 (584)"]
    pub PsProtectedCurrentDirectory: _UNICODE_STRING,
    #[doc = "offset: 0x250 (592)"]
    pub PsProtectedEnvironment: _UNICODE_STRING,
    #[doc = "offset: 0x258 (600)"]
    pub ApiSetSection: *mut VOID,
    #[doc = "offset: 0x25c (604)"]
    pub ApiSetSchema: *mut VOID,
    #[doc = "offset: 0x260 (608)"]
    pub OneCoreForwardersEnabled: UCHAR,
    #[doc = "offset: 0x264 (612)"]
    pub NtSystemRoot: _UNICODE_STRING,
    #[doc = "offset: 0x26c (620)"]
    pub SiloRootDirectoryName: _UNICODE_STRING,
    #[doc = "offset: 0x274 (628)"]
    pub Storage: *mut _PSP_STORAGE,
    #[doc = "offset: 0x278 (632)"]
    pub State: _SERVERSILO_STATE,
    #[doc = "offset: 0x27c (636)"]
    pub ExitStatus: LONG,
    #[doc = "offset: 0x280 (640)"]
    pub DeleteEvent: *mut _KEVENT,
    #[doc = "offset: 0x284 (644)"]
    pub UserSharedData: *mut _SILO_USER_SHARED_DATA,
    #[doc = "offset: 0x288 (648)"]
    pub UserSharedSection: *mut VOID,
    #[doc = "offset: 0x28c (652)"]
    pub TerminateWorkItem: _WORK_QUEUE_ITEM,
}
impl Default for _ESERVERSILO_GLOBALS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HANDLE_TABLE {
    #[doc = "offset: 0x0 (0)"]
    pub NextHandleNeedingPool: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ExtraInfoPages: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub TableCode: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub QuotaProcess: *mut _EPROCESS,
    #[doc = "offset: 0x10 (16)"]
    pub HandleTableList: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub UniqueProcessId: ULONG,
    pub __bindgen_anon_1: _HANDLE_TABLE__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub HandleContentionEvent: _EX_PUSH_LOCK,
    #[doc = "offset: 0x24 (36)"]
    pub HandleTableLock: _EX_PUSH_LOCK,
    pub __bindgen_anon_2: _HANDLE_TABLE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HANDLE_TABLE__bindgen_ty_1 {
    #[doc = "offset: 0x1c (28)"]
    pub Flags: ULONG,
    pub __bindgen_anon_1: _HANDLE_TABLE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HANDLE_TABLE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _HANDLE_TABLE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn StrictFIFO(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_StrictFIFO(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableHandleExceptions(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EnableHandleExceptions(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Rundown(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Rundown(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Duplicated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Duplicated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RaiseUMExceptionOnInvalidHandleClose(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RaiseUMExceptionOnInvalidHandleClose(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        StrictFIFO: UCHAR,
        EnableHandleExceptions: UCHAR,
        Rundown: UCHAR,
        Duplicated: UCHAR,
        RaiseUMExceptionOnInvalidHandleClose: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let StrictFIFO: u8 = unsafe { ::std::mem::transmute(StrictFIFO) };
            StrictFIFO as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableHandleExceptions: u8 =
                unsafe { ::std::mem::transmute(EnableHandleExceptions) };
            EnableHandleExceptions as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Rundown: u8 = unsafe { ::std::mem::transmute(Rundown) };
            Rundown as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Duplicated: u8 = unsafe { ::std::mem::transmute(Duplicated) };
            Duplicated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RaiseUMExceptionOnInvalidHandleClose: u8 =
                unsafe { ::std::mem::transmute(RaiseUMExceptionOnInvalidHandleClose) };
            RaiseUMExceptionOnInvalidHandleClose as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _HANDLE_TABLE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HANDLE_TABLE__bindgen_ty_2 {
    #[doc = "offset: 0x40 (64)"]
    pub FreeLists: [_HANDLE_TABLE_FREE_LIST; 1usize],
    pub __bindgen_anon_1: _HANDLE_TABLE__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HANDLE_TABLE__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x40 (64)"]
    pub ActualEntry: [UCHAR; 20usize],
    #[doc = "offset: 0x54 (84)"]
    pub DebugInfo: *mut _HANDLE_TRACE_DEBUG_INFO,
}
impl Default for _HANDLE_TABLE__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HANDLE_TABLE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HANDLE_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FAST_IO_DISPATCH {
    #[doc = "offset: 0x0 (0)"]
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: UCHAR,
            arg5: ULONG,
            arg6: UCHAR,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: UCHAR,
            arg5: ULONG,
            arg6: *mut VOID,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: UCHAR,
            arg5: ULONG,
            arg6: *mut VOID,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoQueryBasicInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut _FILE_BASIC_INFORMATION,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoQueryStandardInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut _FILE_STANDARD_INFORMATION,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _LARGE_INTEGER,
            arg4: *mut _EPROCESS,
            arg5: ULONG,
            arg6: UCHAR,
            arg7: UCHAR,
            arg8: *mut _IO_STATUS_BLOCK,
            arg9: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoUnlockSingle: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _LARGE_INTEGER,
            arg4: *mut _EPROCESS,
            arg5: ULONG,
            arg6: *mut _IO_STATUS_BLOCK,
            arg7: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoUnlockAll: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _EPROCESS,
            arg3: *mut _IO_STATUS_BLOCK,
            arg4: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoUnlockAllByKey: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut VOID,
            arg3: ULONG,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoDeviceControl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut VOID,
            arg4: ULONG,
            arg5: *mut VOID,
            arg6: ULONG,
            arg7: ULONG,
            arg8: *mut _IO_STATUS_BLOCK,
            arg9: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub AcquireFileForNtCreateSection:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _FILE_OBJECT)>,
    pub ReleaseFileForNtCreateSection:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _FILE_OBJECT)>,
    pub FastIoDetachDevice: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _DEVICE_OBJECT),
    >,
    pub FastIoQueryNetworkOpenInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut _FILE_NETWORK_OPEN_INFORMATION,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub AcquireForModWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut *mut _ERESOURCE,
            arg4: *mut _DEVICE_OBJECT,
        ) -> LONG,
    >,
    pub MdlRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut *mut _MDL,
            arg6: *mut _IO_STATUS_BLOCK,
            arg7: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlReadComplete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _MDL,
            arg3: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub PrepareMdlWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut *mut _MDL,
            arg6: *mut _IO_STATUS_BLOCK,
            arg7: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlWriteComplete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _MDL,
            arg4: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoReadCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut VOID,
            arg6: *mut *mut _MDL,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _COMPRESSED_DATA_INFO,
            arg9: ULONG,
            arg10: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoWriteCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut VOID,
            arg6: *mut *mut _MDL,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _COMPRESSED_DATA_INFO,
            arg9: ULONG,
            arg10: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlReadCompleteCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _MDL,
            arg3: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlWriteCompleteCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _MDL,
            arg4: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoQueryOpen: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _IRP,
            arg2: *mut _FILE_NETWORK_OPEN_INFORMATION,
            arg3: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub ReleaseForModWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _ERESOURCE,
            arg3: *mut _DEVICE_OBJECT,
        ) -> LONG,
    >,
    pub AcquireForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FILE_OBJECT, arg2: *mut _DEVICE_OBJECT) -> LONG,
    >,
    pub ReleaseForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FILE_OBJECT, arg2: *mut _DEVICE_OBJECT) -> LONG,
    >,
}
#[doc = "0xa8 (168) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_OBJECT {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub DriverStart: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub DriverSize: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub DriverSection: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub DriverExtension: *mut _DRIVER_EXTENSION,
    #[doc = "offset: 0x1c (28)"]
    pub DriverName: _UNICODE_STRING,
    #[doc = "offset: 0x24 (36)"]
    pub HardwareDatabase: *mut _UNICODE_STRING,
    #[doc = "offset: 0x28 (40)"]
    pub FastIoDispatch: *mut _FAST_IO_DISPATCH,
    pub DriverInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT, arg2: *mut _UNICODE_STRING) -> LONG,
    >,
    pub DriverStartIo:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP)>,
    #[doc = "offset: 0x34 (52)"]
    pub DriverUnload: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT)>,
    pub MajorFunction: [::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP) -> LONG,
    >; 28usize],
}
impl Default for _DRIVER_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VF_DRIVER_IO_CALLBACKS {
    pub DriverInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT, arg2: *mut _UNICODE_STRING) -> LONG,
    >,
    pub DriverStartIo:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP)>,
    #[doc = "offset: 0x8 (8)"]
    pub DriverUnload: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT)>,
    pub AddDevice: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT, arg2: *mut _DEVICE_OBJECT) -> LONG,
    >,
    pub MajorFunction: [::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP) -> LONG,
    >; 28usize],
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_EXTENSION {
    #[doc = "offset: 0x0 (0)"]
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT, arg2: *mut _DEVICE_OBJECT) -> LONG,
    >,
    #[doc = "offset: 0x8 (8)"]
    pub Count: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ServiceKeyName: _UNICODE_STRING,
    #[doc = "offset: 0x14 (20)"]
    pub ClientDriverExtension: *mut _IO_CLIENT_EXTENSION,
    #[doc = "offset: 0x18 (24)"]
    pub FsFilterCallbacks: *mut _FS_FILTER_CALLBACKS,
    #[doc = "offset: 0x1c (28)"]
    pub KseCallbacks: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub DvCallbacks: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub VerifierContext: *mut VOID,
}
impl Default for _DRIVER_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb8 (184) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub ReferenceCount: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub DriverObject: *mut _DRIVER_OBJECT,
    #[doc = "offset: 0xc (12)"]
    pub NextDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x10 (16)"]
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub CurrentIrp: *mut _IRP,
    #[doc = "offset: 0x18 (24)"]
    pub Timer: *mut _IO_TIMER,
    #[doc = "offset: 0x1c (28)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub Characteristics: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub Vpb: *mut _VPB,
    #[doc = "offset: 0x28 (40)"]
    pub DeviceExtension: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub DeviceType: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub StackSize: CHAR,
    #[doc = "offset: 0x34 (52)"]
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    #[doc = "offset: 0x5c (92)"]
    pub AlignmentRequirement: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub DeviceQueue: _KDEVICE_QUEUE,
    #[doc = "offset: 0x74 (116)"]
    pub Dpc: _KDPC,
    #[doc = "offset: 0x94 (148)"]
    pub ActiveThreadCount: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = "offset: 0x9c (156)"]
    pub DeviceLock: _KEVENT,
    #[doc = "offset: 0xac (172)"]
    pub SectorSize: USHORT,
    #[doc = "offset: 0xae (174)"]
    pub Spare1: USHORT,
    #[doc = "offset: 0xb0 (176)"]
    pub DeviceObjectExtension: *mut _DEVOBJ_EXTENSION,
    #[doc = "offset: 0xb4 (180)"]
    pub Reserved: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT__bindgen_ty_1 {
    #[doc = "offset: 0x34 (52)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x34 (52)"]
    pub Wcb: _WAIT_CONTEXT_BLOCK,
}
impl Default for _DEVICE_OBJECT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DEVICE_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x198 (408) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_FX_DEVICE {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub IrpData: *mut _POP_IRP_DATA,
    #[doc = "offset: 0x10 (16)"]
    pub Status: _POP_FX_DEVICE_STATUS,
    #[doc = "offset: 0x14 (20)"]
    pub PowerReqCall: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub PowerNotReqCall: LONG,
    #[doc = "offset: 0x1c (28)"]
    pub DevNode: *mut _DEVICE_NODE,
    #[doc = "offset: 0x20 (32)"]
    pub DpmContext: *mut PEPHANDLE__,
    #[doc = "offset: 0x24 (36)"]
    pub Plugin: *mut _POP_FX_PLUGIN,
    #[doc = "offset: 0x28 (40)"]
    pub PluginHandle: *mut PEPHANDLE__,
    #[doc = "offset: 0x2c (44)"]
    pub AcpiPlugin: *mut _POP_FX_PLUGIN,
    #[doc = "offset: 0x30 (48)"]
    pub AcpiPluginHandle: *mut PEPHANDLE__,
    #[doc = "offset: 0x34 (52)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x38 (56)"]
    pub TargetDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x3c (60)"]
    pub Callbacks: _POP_FX_DRIVER_CALLBACKS,
    #[doc = "offset: 0x5c (92)"]
    pub DriverContext: *mut VOID,
    #[doc = "offset: 0x60 (96)"]
    pub AcpiLink: _LIST_ENTRY,
    #[doc = "offset: 0x68 (104)"]
    pub DeviceId: _UNICODE_STRING,
    #[doc = "offset: 0x70 (112)"]
    pub RemoveLock: _IO_REMOVE_LOCK,
    #[doc = "offset: 0x88 (136)"]
    pub AcpiRemoveLock: _IO_REMOVE_LOCK,
    #[doc = "offset: 0xa0 (160)"]
    pub WorkOrder: _POP_FX_WORK_ORDER,
    #[doc = "offset: 0xbc (188)"]
    pub IdleLock: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub IdleTimer: _KTIMER,
    #[doc = "offset: 0xe8 (232)"]
    pub IdleDpc: _KDPC,
    #[doc = "offset: 0x108 (264)"]
    pub IdleTimeout: ULONGLONG,
    #[doc = "offset: 0x110 (272)"]
    pub IdleStamp: ULONGLONG,
    #[doc = "offset: 0x118 (280)"]
    pub NextIrpDeviceObject: [*mut _DEVICE_OBJECT; 2usize],
    #[doc = "offset: 0x120 (288)"]
    pub NextIrpPowerState: [_POWER_STATE; 2usize],
    pub NextIrpCallerCompletion: [::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _DEVICE_OBJECT,
            arg2: UCHAR,
            arg3: _POWER_STATE,
            arg4: *mut VOID,
            arg5: *mut _IO_STATUS_BLOCK,
        ),
    >; 2usize],
    #[doc = "offset: 0x130 (304)"]
    pub NextIrpCallerContext: [*mut VOID; 2usize],
    #[doc = "offset: 0x138 (312)"]
    pub IrpCompleteEvent: _KEVENT,
    pub PowerOnDumpDeviceCallback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _PEP_CRASHDUMP_INFORMATION) -> UCHAR>,
    #[doc = "offset: 0x150 (336)"]
    pub Accounting: _POP_FX_ACCOUNTING,
    #[doc = "offset: 0x178 (376)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x17c (380)"]
    pub ComponentCount: ULONG,
    #[doc = "offset: 0x180 (384)"]
    pub Components: *mut *mut _POP_FX_COMPONENT,
    #[doc = "offset: 0x184 (388)"]
    pub LogEntries: ULONG,
    #[doc = "offset: 0x188 (392)"]
    pub Log: *mut _POP_FX_LOG_ENTRY,
    #[doc = "offset: 0x18c (396)"]
    pub LogIndex: LONG,
    #[doc = "offset: 0x190 (400)"]
    pub DripsWatchdogDriverObject: *mut _DRIVER_OBJECT,
}
impl Default for _POP_FX_DEVICE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_FX_COMPONENT {
    #[doc = "offset: 0x0 (0)"]
    pub Id: _GUID,
    #[doc = "offset: 0x10 (16)"]
    pub Index: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub WorkOrder: _POP_FX_WORK_ORDER,
    #[doc = "offset: 0x30 (48)"]
    pub Device: *mut _POP_FX_DEVICE,
    #[doc = "offset: 0x34 (52)"]
    pub Flags: _POP_FX_COMPONENT_FLAGS,
    #[doc = "offset: 0x3c (60)"]
    pub Resident: LONG,
    #[doc = "offset: 0x40 (64)"]
    pub ActiveEvent: _KEVENT,
    #[doc = "offset: 0x50 (80)"]
    pub IdleLock: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub IdleConditionComplete: LONG,
    #[doc = "offset: 0x58 (88)"]
    pub IdleStateComplete: LONG,
    #[doc = "offset: 0x60 (96)"]
    pub IdleStamp: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub CurrentIdleState: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub IdleStateCount: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub IdleStates: *mut _POP_FX_IDLE_STATE,
    #[doc = "offset: 0x74 (116)"]
    pub DeepestWakeableIdleState: ULONG,
    #[doc = "offset: 0x78 (120)"]
    pub ProviderCount: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub Providers: *mut _POP_FX_PROVIDER,
    #[doc = "offset: 0x80 (128)"]
    pub IdleProviderCount: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub DependentCount: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub Dependents: *mut _POP_FX_DEPENDENT,
    #[doc = "offset: 0x90 (144)"]
    pub Accounting: _POP_FX_ACCOUNTING,
    #[doc = "offset: 0xb8 (184)"]
    pub Performance: *mut _POP_FX_PERF_INFO,
}
impl Default for _POP_FX_COMPONENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_FX_PERF_INFO {
    #[doc = "offset: 0x0 (0)"]
    pub Component: *mut _POP_FX_COMPONENT,
    #[doc = "offset: 0x4 (4)"]
    pub CompletedEvent: _KEVENT,
    pub ComponentPerfState: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG, arg3: UCHAR, arg4: *mut VOID),
    >,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: _POP_FX_PERF_FLAGS,
    #[doc = "offset: 0x1c (28)"]
    pub LastChange: *mut _PO_FX_PERF_STATE_CHANGE,
    #[doc = "offset: 0x20 (32)"]
    pub LastChangeCount: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub LastChangeStamp: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub LastChangeNominal: UCHAR,
    #[doc = "offset: 0x31 (49)"]
    pub PepRegistered: UCHAR,
    #[doc = "offset: 0x32 (50)"]
    pub QueryOnIdleStates: UCHAR,
    #[doc = "offset: 0x34 (52)"]
    pub RequestDriverContext: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub WorkOrder: _POP_FX_WORK_ORDER,
    #[doc = "offset: 0x54 (84)"]
    pub SetsCount: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub Sets: *mut _POP_FX_PERF_SET,
}
impl Default for _POP_FX_PERF_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1d4 (468) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_NODE {
    #[doc = "offset: 0x0 (0)"]
    pub Sibling: *mut _DEVICE_NODE,
    #[doc = "offset: 0x4 (4)"]
    pub Child: *mut _DEVICE_NODE,
    #[doc = "offset: 0x8 (8)"]
    pub Parent: *mut _DEVICE_NODE,
    #[doc = "offset: 0xc (12)"]
    pub LastChild: *mut _DEVICE_NODE,
    #[doc = "offset: 0x10 (16)"]
    pub PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub InstancePath: _UNICODE_STRING,
    #[doc = "offset: 0x1c (28)"]
    pub ServiceName: _UNICODE_STRING,
    #[doc = "offset: 0x24 (36)"]
    pub PendingIrp: *mut _IRP,
    #[doc = "offset: 0x28 (40)"]
    pub FxDevice: *mut _POP_FX_DEVICE,
    #[doc = "offset: 0x2c (44)"]
    pub FxDeviceLock: LONG,
    #[doc = "offset: 0x30 (48)"]
    pub FxRemoveEvent: _KEVENT,
    #[doc = "offset: 0x40 (64)"]
    pub FxActivationCount: LONG,
    #[doc = "offset: 0x44 (68)"]
    pub FxSleepCount: LONG,
    #[doc = "offset: 0x48 (72)"]
    pub Plugin: *mut _POP_FX_PLUGIN,
    #[doc = "offset: 0x4c (76)"]
    pub Level: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub CurrentPowerState: _POWER_STATE,
    #[doc = "offset: 0x54 (84)"]
    pub Notify: _PO_DEVICE_NOTIFY,
    #[doc = "offset: 0x90 (144)"]
    pub PoIrpManager: _PO_IRP_MANAGER,
    #[doc = "offset: 0xa0 (160)"]
    pub UniqueId: _UNICODE_STRING,
    #[doc = "offset: 0xa8 (168)"]
    pub PowerFlags: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub State: _PNP_DEVNODE_STATE,
    #[doc = "offset: 0xb0 (176)"]
    pub PreviousState: _PNP_DEVNODE_STATE,
    #[doc = "offset: 0xb4 (180)"]
    pub StateHistory: [_PNP_DEVNODE_STATE; 20usize],
    #[doc = "offset: 0x104 (260)"]
    pub StateHistoryEntry: ULONG,
    #[doc = "offset: 0x108 (264)"]
    pub CompletionStatus: LONG,
    #[doc = "offset: 0x10c (268)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x110 (272)"]
    pub UserFlags: ULONG,
    #[doc = "offset: 0x114 (276)"]
    pub Problem: ULONG,
    #[doc = "offset: 0x118 (280)"]
    pub ProblemStatus: LONG,
    #[doc = "offset: 0x11c (284)"]
    pub ResourceList: *mut _CM_RESOURCE_LIST,
    #[doc = "offset: 0x120 (288)"]
    pub ResourceListTranslated: *mut _CM_RESOURCE_LIST,
    #[doc = "offset: 0x124 (292)"]
    pub DuplicatePDO: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x128 (296)"]
    pub ResourceRequirements: *mut _IO_RESOURCE_REQUIREMENTS_LIST,
    #[doc = "offset: 0x12c (300)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = "offset: 0x130 (304)"]
    pub BusNumber: ULONG,
    #[doc = "offset: 0x134 (308)"]
    pub ChildInterfaceType: _INTERFACE_TYPE,
    #[doc = "offset: 0x138 (312)"]
    pub ChildBusNumber: ULONG,
    #[doc = "offset: 0x13c (316)"]
    pub ChildBusTypeIndex: USHORT,
    #[doc = "offset: 0x13e (318)"]
    pub RemovalPolicy: UCHAR,
    #[doc = "offset: 0x13f (319)"]
    pub HardwareRemovalPolicy: UCHAR,
    #[doc = "offset: 0x140 (320)"]
    pub TargetDeviceNotify: _LIST_ENTRY,
    #[doc = "offset: 0x148 (328)"]
    pub DeviceArbiterList: _LIST_ENTRY,
    #[doc = "offset: 0x150 (336)"]
    pub DeviceTranslatorList: _LIST_ENTRY,
    #[doc = "offset: 0x158 (344)"]
    pub NoTranslatorMask: USHORT,
    #[doc = "offset: 0x15a (346)"]
    pub QueryTranslatorMask: USHORT,
    #[doc = "offset: 0x15c (348)"]
    pub NoArbiterMask: USHORT,
    #[doc = "offset: 0x15e (350)"]
    pub QueryArbiterMask: USHORT,
    #[doc = "offset: 0x160 (352)"]
    pub OverUsed1: _DEVICE_NODE__bindgen_ty_1,
    #[doc = "offset: 0x164 (356)"]
    pub OverUsed2: _DEVICE_NODE__bindgen_ty_2,
    #[doc = "offset: 0x168 (360)"]
    pub BootResources: *mut _CM_RESOURCE_LIST,
    #[doc = "offset: 0x16c (364)"]
    pub BootResourcesTranslated: *mut _CM_RESOURCE_LIST,
    #[doc = "offset: 0x170 (368)"]
    pub CapabilityFlags: ULONG,
    #[doc = "offset: 0x174 (372)"]
    pub DockInfo: _DEVICE_NODE__bindgen_ty_3,
    #[doc = "offset: 0x184 (388)"]
    pub DisableableDepends: ULONG,
    #[doc = "offset: 0x188 (392)"]
    pub PendedSetInterfaceState: _LIST_ENTRY,
    #[doc = "offset: 0x190 (400)"]
    pub LegacyBusListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x198 (408)"]
    pub DriverUnloadRetryCount: ULONG,
    #[doc = "offset: 0x19c (412)"]
    pub PreviousParent: *mut _DEVICE_NODE,
    #[doc = "offset: 0x1a0 (416)"]
    pub DeletedChildren: LONG,
    #[doc = "offset: 0x1a4 (420)"]
    pub NumaNodeIndex: ULONG,
    #[doc = "offset: 0x1a8 (424)"]
    pub ContainerID: _GUID,
    #[doc = "offset: 0x1b8 (440)"]
    pub OverrideFlags: UCHAR,
    #[doc = "offset: 0x1bc (444)"]
    pub DeviceIdsHash: ULONG,
    #[doc = "offset: 0x1c0 (448)"]
    pub RequiresUnloadedDriver: UCHAR,
    #[doc = "offset: 0x1c4 (452)"]
    pub PendingEjectRelations: *mut _PENDING_RELATIONS_LIST_ENTRY,
    #[doc = "offset: 0x1c8 (456)"]
    pub StateFlags: ULONG,
    #[doc = "offset: 0x1cc (460)"]
    pub RebalanceContext: *mut _PNP_REBALANCE_TRACE_CONTEXT,
    #[doc = "offset: 0x1d0 (464)"]
    pub IommuExtension: *mut _DEVICE_NODE_IOMMU_EXTENSION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_NODE__bindgen_ty_1 {
    #[doc = "offset: 0x160 (352)"]
    pub LegacyDeviceNode: *mut _DEVICE_NODE,
    #[doc = "offset: 0x160 (352)"]
    pub PendingDeviceRelations: *mut _DEVICE_RELATIONS,
    #[doc = "offset: 0x160 (352)"]
    pub Information: *mut VOID,
}
impl Default for _DEVICE_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_NODE__bindgen_ty_2 {
    #[doc = "offset: 0x164 (356)"]
    pub NextResourceDeviceNode: *mut _DEVICE_NODE,
}
impl Default for _DEVICE_NODE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_NODE__bindgen_ty_3 {
    #[doc = "offset: 0x0 (0)"]
    pub DockStatus: PROFILE_STATUS,
    #[doc = "offset: 0x4 (4)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0xc (12)"]
    pub SerialNumber: *mut WCHAR,
}
impl Default for _DEVICE_NODE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DEVICE_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x90 (144) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_IRP_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0xc (12)"]
    pub Pdo: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x10 (16)"]
    pub TargetDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x14 (20)"]
    pub CurrentDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x18 (24)"]
    pub WatchdogStart: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub WatchdogTimer: _KTIMER,
    #[doc = "offset: 0x48 (72)"]
    pub WatchdogDpc: _KDPC,
    #[doc = "offset: 0x68 (104)"]
    pub MinorFunction: UCHAR,
    #[doc = "offset: 0x6c (108)"]
    pub PowerStateType: _POWER_STATE_TYPE,
    #[doc = "offset: 0x70 (112)"]
    pub PowerState: _POWER_STATE,
    #[doc = "offset: 0x74 (116)"]
    pub WatchdogEnabled: UCHAR,
    #[doc = "offset: 0x78 (120)"]
    pub FxDevice: *mut _POP_FX_DEVICE,
    #[doc = "offset: 0x7c (124)"]
    pub SystemTransition: UCHAR,
    #[doc = "offset: 0x7d (125)"]
    pub NotifyPEP: UCHAR,
    pub __bindgen_anon_1: _POP_IRP_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_IRP_DATA__bindgen_ty_1 {
    #[doc = "offset: 0x80 (128)"]
    pub Device: _POP_IRP_DATA__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x80 (128)"]
    pub System: _POP_IRP_DATA__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_IRP_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub CallerCompletion: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _DEVICE_OBJECT,
            arg2: UCHAR,
            arg3: _POWER_STATE,
            arg4: *mut VOID,
            arg5: *mut _IO_STATUS_BLOCK,
        ),
    >,
    #[doc = "offset: 0x4 (4)"]
    pub CallerContext: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub CallerDevice: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0xc (12)"]
    pub SystemWake: UCHAR,
}
impl Default for _POP_IRP_DATA__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_IRP_DATA__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "offset: 0x0 (0)"]
    pub NotifyDevice: *mut _PO_DEVICE_NOTIFY,
    #[doc = "offset: 0x4 (4)"]
    pub FxDeviceActivated: UCHAR,
}
impl Default for _POP_IRP_DATA__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_IRP_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_IRP_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MDL {
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _MDL,
    #[doc = "offset: 0x4 (4)"]
    pub Size: SHORT,
    #[doc = "offset: 0x6 (6)"]
    pub MdlFlags: SHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Process: *mut _EPROCESS,
    #[doc = "offset: 0xc (12)"]
    pub MappedSystemVa: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub StartVa: *mut VOID,
    #[doc = "offset: 0x14 (20)"]
    pub ByteCount: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub ByteOffset: ULONG,
}
impl Default for _MDL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PAGEFILE_TRACES {
    #[doc = "offset: 0x0 (0)"]
    pub Status: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub PartitionId: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Priority: UCHAR,
    #[doc = "offset: 0x7 (7)"]
    pub IrpPriority: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub ReservationWrite: UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub CurrentTime: _LARGE_INTEGER,
    #[doc = "offset: 0x18 (24)"]
    pub AvailablePages: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ModifiedPagesTotal: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub ModifiedPagefilePages: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ModifiedNoWritePages: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub ModifiedPagefileNoReservationPages: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub MdlHack: _MI_PAGEFILE_TRACES__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MI_PAGEFILE_TRACES__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Mdl: _MDL,
    #[doc = "offset: 0x1c (28)"]
    pub Page: [ULONG; 1usize],
}
impl Default for _MI_PAGEFILE_TRACES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_PAGEFILE_TRACES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc40 (3136) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_VISIBLE_PARTITION {
    #[doc = "offset: 0x0 (0)"]
    pub LowestPhysicalPage: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub HighestPhysicalPage: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub NumberOfPhysicalPages: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub NumberOfPagingFiles: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub SystemCacheInitialized: UCHAR,
    #[doc = "offset: 0x14 (20)"]
    pub PagingFile: [*mut _MMPAGING_FILE; 16usize],
    #[doc = "offset: 0x80 (128)"]
    pub AvailablePages: ULONG,
    #[doc = "offset: 0xc0 (192)"]
    pub ResidentAvailablePages: ULONG,
    #[doc = "offset: 0x100 (256)"]
    pub PartitionWs: [_MMSUPPORT_INSTANCE; 1usize],
    #[doc = "offset: 0x168 (360)"]
    pub PartitionWorkingSetLists: [_MMWSL_INSTANCE; 1usize],
    #[doc = "offset: 0x180 (384)"]
    pub TotalCommittedPages: ULONG,
    #[doc = "offset: 0x1c0 (448)"]
    pub ModifiedPageListHead: _MMPFNLIST,
    #[doc = "offset: 0x200 (512)"]
    pub ModifiedNoWritePageListHead: _MMPFNLIST,
    #[doc = "offset: 0x214 (532)"]
    pub TotalCommitLimit: ULONG,
    #[doc = "offset: 0x218 (536)"]
    pub TotalPagesForPagingFile: ULONG,
    #[doc = "offset: 0x21c (540)"]
    pub VadPhysicalPages: ULONG,
    #[doc = "offset: 0x220 (544)"]
    pub ProcessLockedFilePages: ULONG,
    #[doc = "offset: 0x224 (548)"]
    pub SharedCommit: ULONG,
    #[doc = "offset: 0x228 (552)"]
    pub ChargeCommitmentFailures: [ULONG; 4usize],
    #[doc = "offset: 0x238 (568)"]
    pub PageFileTraceIndex: LONG,
    #[doc = "offset: 0x240 (576)"]
    pub PageFileTraces: [_MI_PAGEFILE_TRACES; 32usize],
}
impl Default for _MI_VISIBLE_PARTITION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1a80 (6784) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION {
    #[doc = "offset: 0x0 (0)"]
    pub Core: _MI_PARTITION_CORE,
    #[doc = "offset: 0xe8 (232)"]
    pub Modwriter: _MI_PARTITION_MODWRITES,
    #[doc = "offset: 0x2b0 (688)"]
    pub Store: _MI_PARTITION_STORES,
    #[doc = "offset: 0x340 (832)"]
    pub Segments: _MI_PARTITION_SEGMENTS,
    #[doc = "offset: 0x4c0 (1216)"]
    pub PageLists: _MI_PARTITION_PAGE_LISTS,
    #[doc = "offset: 0xc80 (3200)"]
    pub Commit: _MI_PARTITION_COMMIT,
    #[doc = "offset: 0xd00 (3328)"]
    pub Zeroing: _MI_PARTITION_ZEROING,
    #[doc = "offset: 0xd40 (3392)"]
    pub PageCombine: _MI_PAGE_COMBINING_SUPPORT,
    #[doc = "offset: 0xe18 (3608)"]
    pub WorkingSetControl: *mut VOID,
    #[doc = "offset: 0xe1c (3612)"]
    pub WorkingSetExpansionHead: _MMWORKING_SET_EXPANSION_HEAD,
    #[doc = "offset: 0xe40 (3648)"]
    pub Vp: _MI_VISIBLE_PARTITION,
}
impl Default for _MI_PARTITION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PARTITION_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub PartitionLock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub PartitionIdLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x8 (8)"]
    pub InitialPartitionIdBits: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub PartitionList: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub PartitionIdBitmap: *mut _RTL_BITMAP,
    #[doc = "offset: 0x1c (28)"]
    pub InitialPartitionIdBitmap: _RTL_BITMAP,
    #[doc = "offset: 0x24 (36)"]
    pub TempPartitionPointers: [*mut _MI_PARTITION; 1usize],
    #[doc = "offset: 0x28 (40)"]
    pub Partition: *mut *mut _MI_PARTITION,
    #[doc = "offset: 0x2c (44)"]
    pub TotalPagesInChildPartitions: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub CrossPartitionDenials: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub MultiplePartitionsExist: UCHAR,
}
impl Default for _MI_PARTITION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3bc0 (15296) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SYSTEM_INFORMATION {
    #[doc = "offset: 0x0 (0)"]
    pub Pools: _MI_POOL_STATE,
    #[doc = "offset: 0x500 (1280)"]
    pub Sections: _MI_SECTION_STATE,
    #[doc = "offset: 0x640 (1600)"]
    pub SystemImages: _MI_SYSTEM_IMAGE_STATE,
    #[doc = "offset: 0x6ac (1708)"]
    pub Sessions: _MI_SESSION_STATE,
    #[doc = "offset: 0x16e8 (5864)"]
    pub Processes: _MI_PROCESS_STATE,
    #[doc = "offset: 0x1748 (5960)"]
    pub Hardware: _MI_HARDWARE_STATE,
    #[doc = "offset: 0x1840 (6208)"]
    pub SystemVa: _MI_SYSTEM_VA_STATE,
    #[doc = "offset: 0x2d40 (11584)"]
    pub PageCombines: _MI_COMBINE_STATE,
    #[doc = "offset: 0x2d58 (11608)"]
    pub PageLists: _MI_PAGELIST_STATE,
    #[doc = "offset: 0x2d60 (11616)"]
    pub Partitions: _MI_PARTITION_STATE,
    #[doc = "offset: 0x2d98 (11672)"]
    pub Shutdowns: _MI_SHUTDOWN_STATE,
    #[doc = "offset: 0x2de0 (11744)"]
    pub Errors: _MI_ERROR_STATE,
    #[doc = "offset: 0x2ec0 (11968)"]
    pub AccessLog: _MI_ACCESS_LOG_STATE,
    #[doc = "offset: 0x2f40 (12096)"]
    pub Debugger: _MI_DEBUGGER_STATE,
    #[doc = "offset: 0x2fd0 (12240)"]
    pub Standby: _MI_STANDBY_STATE,
    #[doc = "offset: 0x3040 (12352)"]
    pub SystemPtes: _MI_SYSTEM_PTE_STATE,
    #[doc = "offset: 0x31c0 (12736)"]
    pub IoPages: _MI_IO_PAGE_STATE,
    #[doc = "offset: 0x3200 (12800)"]
    pub PagingIo: _MI_PAGING_IO_STATE,
    #[doc = "offset: 0x3238 (12856)"]
    pub CommonPages: _MI_COMMON_PAGE_STATE,
    #[doc = "offset: 0x3280 (12928)"]
    pub Trims: _MI_SYSTEM_TRIM_STATE,
    #[doc = "offset: 0x32c0 (12992)"]
    pub Cookie: ULONG,
    #[doc = "offset: 0x32c4 (12996)"]
    pub BootRegistryRuns: *mut *mut VOID,
    #[doc = "offset: 0x32c8 (13000)"]
    pub ZeroingDisabled: LONG,
    #[doc = "offset: 0x32cc (13004)"]
    pub FullyInitialized: UCHAR,
    #[doc = "offset: 0x32cd (13005)"]
    pub SafeBooted: UCHAR,
    #[doc = "offset: 0x32d0 (13008)"]
    pub PfnBitMap: _RTL_BITMAP,
    #[doc = "offset: 0x32d8 (13016)"]
    pub TraceLogging: *mut _TlgProvider_t,
    #[doc = "offset: 0x3300 (13056)"]
    pub Vs: _MI_VISIBLE_STATE,
}
impl Default for _MI_SYSTEM_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa8 (168) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPAGING_FILE {
    #[doc = "offset: 0x0 (0)"]
    pub Size: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub MaximumSize: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub MinimumSize: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub FreeSpace: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub PeakUsage: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub HighestPage: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub FreeReservationSpace: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub File: *mut _FILE_OBJECT,
    #[doc = "offset: 0x20 (32)"]
    pub Entry: [*mut _MMMOD_WRITER_MDL_ENTRY; 2usize],
    #[doc = "offset: 0x28 (40)"]
    pub PfnsToFree: _SLIST_HEADER,
    #[doc = "offset: 0x30 (48)"]
    pub PageFileName: _UNICODE_STRING,
    #[doc = "offset: 0x38 (56)"]
    pub Bitmaps: *mut _MI_PAGING_FILE_SPACE_BITMAPS,
    #[doc = "offset: 0x3c (60)"]
    pub AllocationBitmapHint: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub LargestAllocationCluster: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub RefreshAllocationCluster: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub LastRefreshAllocationCluster: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub ReservedClusterSizeAggregate: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub MaximumRunLengthInBitmaps: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub BitmapsCacheLengthTree: _RTL_RB_TREE,
    #[doc = "offset: 0x5c (92)"]
    pub BitmapsCacheLocationTree: _RTL_RB_TREE,
    #[doc = "offset: 0x64 (100)"]
    pub BitmapsCacheFreeList: _LIST_ENTRY,
    #[doc = "offset: 0x6c (108)"]
    pub BitmapsCacheEntries: *mut _MI_PAGEFILE_BITMAPS_CACHE_ENTRY,
    pub __bindgen_anon_1: _MMPAGING_FILE__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "offset: 0x78 (120)"]
    pub PageHashPages: ULONG,
    #[doc = "offset: 0x7c (124)"]
    pub PageHashPagesPeak: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub PageHash: *mut ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub FileHandle: *mut VOID,
    #[doc = "offset: 0x88 (136)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub LockOwner: *mut _ETHREAD,
    #[doc = "offset: 0x90 (144)"]
    pub FlowThroughReadRoot: _RTL_AVL_TREE,
    #[doc = "offset: 0x94 (148)"]
    pub Partition: *mut _MI_PARTITION,
    #[doc = "offset: 0x98 (152)"]
    pub FileObjectNode: _RTL_BALANCED_NODE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPAGING_FILE__bindgen_ty_1 {
    #[doc = "offset: 0x70 (112)"]
    pub ToBeEvictedCount: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub HybridPriority: ULONG,
}
impl Default for _MMPAGING_FILE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMPAGING_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMPAGING_FILE {
    #[inline]
    pub fn PageFileNumber(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PageFileNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn WsSwapPagefile(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WsSwapPagefile(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoReservations(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NoReservations(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VirtualStorePagefile(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VirtualStorePagefile(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SwapSupported(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SwapSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NodeInserted(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NodeInserted(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackNotified(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_StackNotified(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BackedBySCM(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BackedBySCM(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare0(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn AdriftMdls(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AdriftMdls(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreReservations(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IgnoreReservations(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare2(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Spare2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageFileNumber: USHORT,
        WsSwapPagefile: USHORT,
        NoReservations: USHORT,
        VirtualStorePagefile: USHORT,
        SwapSupported: USHORT,
        NodeInserted: USHORT,
        StackNotified: USHORT,
        BackedBySCM: USHORT,
        Spare0: USHORT,
        AdriftMdls: UCHAR,
        Spare1: UCHAR,
        IgnoreReservations: UCHAR,
        Spare2: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PageFileNumber: u16 = unsafe { ::std::mem::transmute(PageFileNumber) };
            PageFileNumber as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WsSwapPagefile: u16 = unsafe { ::std::mem::transmute(WsSwapPagefile) };
            WsSwapPagefile as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let NoReservations: u16 = unsafe { ::std::mem::transmute(NoReservations) };
            NoReservations as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let VirtualStorePagefile: u16 = unsafe { ::std::mem::transmute(VirtualStorePagefile) };
            VirtualStorePagefile as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SwapSupported: u16 = unsafe { ::std::mem::transmute(SwapSupported) };
            SwapSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let NodeInserted: u16 = unsafe { ::std::mem::transmute(NodeInserted) };
            NodeInserted as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let StackNotified: u16 = unsafe { ::std::mem::transmute(StackNotified) };
            StackNotified as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BackedBySCM: u16 = unsafe { ::std::mem::transmute(BackedBySCM) };
            BackedBySCM as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let Spare0: u16 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let AdriftMdls: u8 = unsafe { ::std::mem::transmute(AdriftMdls) };
            AdriftMdls as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let Spare1: u8 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let IgnoreReservations: u8 = unsafe { ::std::mem::transmute(IgnoreReservations) };
            IgnoreReservations as u64
        });
        __bindgen_bitfield_unit.set(24usize, 7u8, {
            let Spare2: u8 = unsafe { ::std::mem::transmute(Spare2) };
            Spare2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMINPAGE_SUPPORT_FLOW_THROUGH {
    #[doc = "offset: 0x0 (0)"]
    pub Page: [ULONG; 1usize],
    #[doc = "offset: 0x4 (4)"]
    pub InitialInPageSupport: *mut _MMINPAGE_SUPPORT,
    #[doc = "offset: 0x8 (8)"]
    pub PagingFile: *mut _MMPAGING_FILE,
    #[doc = "offset: 0xc (12)"]
    pub PageFileOffset: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Node: _RTL_BALANCED_NODE,
}
impl Default for _MMINPAGE_SUPPORT_FLOW_THROUGH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xf8 (248) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMINPAGE_SUPPORT {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x20 (32)"]
    pub CollidedEvent: _KEVENT,
    #[doc = "offset: 0x30 (48)"]
    pub IoStatus: _IO_STATUS_BLOCK,
    #[doc = "offset: 0x38 (56)"]
    pub ReadOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x40 (64)"]
    pub ApcState: _KAPC_STATE,
    #[doc = "offset: 0x58 (88)"]
    pub Thread: *mut _ETHREAD,
    #[doc = "offset: 0x5c (92)"]
    pub LockedProtoPfn: *mut _MMPFN,
    #[doc = "offset: 0x60 (96)"]
    pub PteContents: _MMPTE,
    #[doc = "offset: 0x68 (104)"]
    pub WaitCount: LONG,
    #[doc = "offset: 0x6c (108)"]
    pub ByteCount: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub u3: _MMINPAGE_SUPPORT__bindgen_ty_1,
    #[doc = "offset: 0x74 (116)"]
    pub u1: _MMINPAGE_SUPPORT__bindgen_ty_2,
    #[doc = "offset: 0x78 (120)"]
    pub FilePointer: *mut _FILE_OBJECT,
    pub __bindgen_anon_1: _MMINPAGE_SUPPORT__bindgen_ty_3,
    #[doc = "offset: 0x80 (128)"]
    pub Autoboost: *mut VOID,
    #[doc = "offset: 0x84 (132)"]
    pub FaultingAddress: *mut VOID,
    #[doc = "offset: 0x88 (136)"]
    pub PointerPte: *mut _MMPTE,
    #[doc = "offset: 0x8c (140)"]
    pub BasePte: *mut _MMPTE,
    #[doc = "offset: 0x90 (144)"]
    pub Pfn: *mut _MMPFN,
    #[doc = "offset: 0x94 (148)"]
    pub PrefetchMdl: *mut _MDL,
    #[doc = "offset: 0x98 (152)"]
    pub Mdl: _MDL,
    pub __bindgen_anon_2: _MMINPAGE_SUPPORT__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMINPAGE_SUPPORT__bindgen_ty_1 {
    #[doc = "offset: 0x70 (112)"]
    pub ImagePteOffset: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub TossPage: ULONG,
}
impl Default for _MMINPAGE_SUPPORT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMINPAGE_SUPPORT__bindgen_ty_2 {
    #[doc = "offset: 0x74 (116)"]
    pub e1: _MMINPAGE_FLAGS,
    #[doc = "offset: 0x74 (116)"]
    pub LongFlags: ULONG,
}
impl Default for _MMINPAGE_SUPPORT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMINPAGE_SUPPORT__bindgen_ty_3 {
    #[doc = "offset: 0x7c (124)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = "offset: 0x7c (124)"]
    pub Subsection: *mut _SUBSECTION,
}
impl Default for _MMINPAGE_SUPPORT__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMINPAGE_SUPPORT__bindgen_ty_4 {
    #[doc = "offset: 0xb4 (180)"]
    pub Page: [ULONG; 16usize],
    #[doc = "offset: 0xb4 (180)"]
    pub FlowThrough: _MMINPAGE_SUPPORT_FLOW_THROUGH,
}
impl Default for _MMINPAGE_SUPPORT__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMINPAGE_SUPPORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMMOD_WRITER_MDL_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub u: _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x10 (16)"]
    pub Irp: *mut _IRP,
    #[doc = "offset: 0x14 (20)"]
    pub u1: _MODWRITER_FLAGS,
    #[doc = "offset: 0x18 (24)"]
    pub StoreWriteRefCount: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub StoreWriteCompletionApc: _KAPC,
    #[doc = "offset: 0x4c (76)"]
    pub ByteCount: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub ChargedPages: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub PagingFile: *mut _MMPAGING_FILE,
    #[doc = "offset: 0x58 (88)"]
    pub File: *mut _FILE_OBJECT,
    #[doc = "offset: 0x5c (92)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = "offset: 0x60 (96)"]
    pub FileResource: *mut _ERESOURCE,
    #[doc = "offset: 0x68 (104)"]
    pub WriteOffset: _LARGE_INTEGER,
    #[doc = "offset: 0x70 (112)"]
    pub IssueTime: _LARGE_INTEGER,
    #[doc = "offset: 0x78 (120)"]
    pub Partition: *mut _MI_PARTITION,
    #[doc = "offset: 0x7c (124)"]
    pub PointerMdl: *mut _MDL,
    #[doc = "offset: 0x80 (128)"]
    pub Mdl: _MDL,
    #[doc = "offset: 0x9c (156)"]
    pub Page: [ULONG; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x8 (8)"]
    pub IoStatus: _IO_STATUS_BLOCK,
}
impl Default for _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMMOD_WRITER_MDL_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMCLONE_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub NumberOfPtes: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub NumberOfProcessReferences: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub ClonePtes: *mut _MMCLONE_BLOCK,
    #[doc = "offset: 0xc (12)"]
    pub Partition: *mut _MI_PARTITION,
}
impl Default for _MMCLONE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMCLONE_DESCRIPTOR {
    pub __bindgen_anon_1: _MMCLONE_DESCRIPTOR__bindgen_ty_1,
    #[doc = "offset: 0xc (12)"]
    pub StartingCloneBlock: *mut _MMCLONE_BLOCK,
    #[doc = "offset: 0x10 (16)"]
    pub EndingCloneBlock: *mut _MMCLONE_BLOCK,
    #[doc = "offset: 0x14 (20)"]
    pub NumberOfPtes: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub NumberOfReferences: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub CloneHeader: *mut _MMCLONE_HEADER,
    #[doc = "offset: 0x20 (32)"]
    pub NonPagedPoolQuotaCharge: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub NestingLevel: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMCLONE_DESCRIPTOR__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub CloneNode: _RTL_BALANCED_NODE,
    #[doc = "offset: 0x0 (0)"]
    pub Next: *mut _MMCLONE_DESCRIPTOR,
}
impl Default for _MMCLONE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMCLONE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1000 (4096) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TEB {
    #[doc = "offset: 0x0 (0)"]
    pub NtTib: _NT_TIB,
    #[doc = "offset: 0x1c (28)"]
    pub EnvironmentPointer: *mut VOID,
    #[doc = "offset: 0x20 (32)"]
    pub ClientId: _CLIENT_ID,
    #[doc = "offset: 0x28 (40)"]
    pub ActiveRpcHandle: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub ThreadLocalStoragePointer: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub ProcessEnvironmentBlock: *mut _PEB,
    #[doc = "offset: 0x34 (52)"]
    pub LastErrorValue: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub CountOfOwnedCriticalSections: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub CsrClientThread: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub Win32ThreadInfo: *mut VOID,
    #[doc = "offset: 0x44 (68)"]
    pub User32Reserved: [ULONG; 26usize],
    #[doc = "offset: 0xac (172)"]
    pub UserReserved: [ULONG; 5usize],
    #[doc = "offset: 0xc0 (192)"]
    pub WOW32Reserved: *mut VOID,
    #[doc = "offset: 0xc4 (196)"]
    pub CurrentLocale: ULONG,
    #[doc = "offset: 0xc8 (200)"]
    pub FpSoftwareStatusRegister: ULONG,
    #[doc = "offset: 0xcc (204)"]
    pub ReservedForDebuggerInstrumentation: [*mut VOID; 16usize],
    #[doc = "offset: 0x10c (268)"]
    pub SystemReserved1: [*mut VOID; 26usize],
    #[doc = "offset: 0x174 (372)"]
    pub PlaceholderCompatibilityMode: CHAR,
    #[doc = "offset: 0x175 (373)"]
    pub PlaceholderReserved: [CHAR; 11usize],
    #[doc = "offset: 0x180 (384)"]
    pub ProxiedProcessId: ULONG,
    #[doc = "offset: 0x184 (388)"]
    pub _ActivationStack: _ACTIVATION_CONTEXT_STACK,
    #[doc = "offset: 0x19c (412)"]
    pub WorkingOnBehalfTicket: [UCHAR; 8usize],
    #[doc = "offset: 0x1a4 (420)"]
    pub ExceptionCode: LONG,
    #[doc = "offset: 0x1a8 (424)"]
    pub ActivationContextStackPointer: *mut _ACTIVATION_CONTEXT_STACK,
    #[doc = "offset: 0x1ac (428)"]
    pub InstrumentationCallbackSp: ULONG,
    #[doc = "offset: 0x1b0 (432)"]
    pub InstrumentationCallbackPreviousPc: ULONG,
    #[doc = "offset: 0x1b4 (436)"]
    pub InstrumentationCallbackPreviousSp: ULONG,
    #[doc = "offset: 0x1b8 (440)"]
    pub InstrumentationCallbackDisabled: UCHAR,
    #[doc = "offset: 0x1b9 (441)"]
    pub SpareBytes: [UCHAR; 23usize],
    #[doc = "offset: 0x1d0 (464)"]
    pub TxFsContext: ULONG,
    #[doc = "offset: 0x1d4 (468)"]
    pub GdiTebBatch: _GDI_TEB_BATCH,
    #[doc = "offset: 0x6b4 (1716)"]
    pub RealClientId: _CLIENT_ID,
    #[doc = "offset: 0x6bc (1724)"]
    pub GdiCachedProcessHandle: *mut VOID,
    #[doc = "offset: 0x6c0 (1728)"]
    pub GdiClientPID: ULONG,
    #[doc = "offset: 0x6c4 (1732)"]
    pub GdiClientTID: ULONG,
    #[doc = "offset: 0x6c8 (1736)"]
    pub GdiThreadLocalInfo: *mut VOID,
    #[doc = "offset: 0x6cc (1740)"]
    pub Win32ClientInfo: [ULONG; 62usize],
    #[doc = "offset: 0x7c4 (1988)"]
    pub glDispatchTable: [*mut VOID; 233usize],
    #[doc = "offset: 0xb68 (2920)"]
    pub glReserved1: [ULONG; 29usize],
    #[doc = "offset: 0xbdc (3036)"]
    pub glReserved2: *mut VOID,
    #[doc = "offset: 0xbe0 (3040)"]
    pub glSectionInfo: *mut VOID,
    #[doc = "offset: 0xbe4 (3044)"]
    pub glSection: *mut VOID,
    #[doc = "offset: 0xbe8 (3048)"]
    pub glTable: *mut VOID,
    #[doc = "offset: 0xbec (3052)"]
    pub glCurrentRC: *mut VOID,
    #[doc = "offset: 0xbf0 (3056)"]
    pub glContext: *mut VOID,
    #[doc = "offset: 0xbf4 (3060)"]
    pub LastStatusValue: ULONG,
    #[doc = "offset: 0xbf8 (3064)"]
    pub StaticUnicodeString: _UNICODE_STRING,
    #[doc = "offset: 0xc00 (3072)"]
    pub StaticUnicodeBuffer: [WCHAR; 261usize],
    #[doc = "offset: 0xe0c (3596)"]
    pub DeallocationStack: *mut VOID,
    #[doc = "offset: 0xe10 (3600)"]
    pub TlsSlots: [*mut VOID; 64usize],
    #[doc = "offset: 0xf10 (3856)"]
    pub TlsLinks: _LIST_ENTRY,
    #[doc = "offset: 0xf18 (3864)"]
    pub Vdm: *mut VOID,
    #[doc = "offset: 0xf1c (3868)"]
    pub ReservedForNtRpc: *mut VOID,
    #[doc = "offset: 0xf20 (3872)"]
    pub DbgSsReserved: [*mut VOID; 2usize],
    #[doc = "offset: 0xf28 (3880)"]
    pub HardErrorMode: ULONG,
    #[doc = "offset: 0xf2c (3884)"]
    pub Instrumentation: [*mut VOID; 9usize],
    #[doc = "offset: 0xf50 (3920)"]
    pub ActivityId: _GUID,
    #[doc = "offset: 0xf60 (3936)"]
    pub SubProcessTag: *mut VOID,
    #[doc = "offset: 0xf64 (3940)"]
    pub PerflibData: *mut VOID,
    #[doc = "offset: 0xf68 (3944)"]
    pub EtwTraceData: *mut VOID,
    #[doc = "offset: 0xf6c (3948)"]
    pub WinSockData: *mut VOID,
    #[doc = "offset: 0xf70 (3952)"]
    pub GdiBatchCount: ULONG,
    pub __bindgen_anon_1: _TEB__bindgen_ty_1,
    #[doc = "offset: 0xf78 (3960)"]
    pub GuaranteedStackBytes: ULONG,
    #[doc = "offset: 0xf7c (3964)"]
    pub ReservedForPerf: *mut VOID,
    #[doc = "offset: 0xf80 (3968)"]
    pub ReservedForOle: *mut VOID,
    #[doc = "offset: 0xf84 (3972)"]
    pub WaitingOnLoaderLock: ULONG,
    #[doc = "offset: 0xf88 (3976)"]
    pub SavedPriorityState: *mut VOID,
    #[doc = "offset: 0xf8c (3980)"]
    pub ReservedForCodeCoverage: ULONG,
    #[doc = "offset: 0xf90 (3984)"]
    pub ThreadPoolData: *mut VOID,
    #[doc = "offset: 0xf94 (3988)"]
    pub TlsExpansionSlots: *mut *mut VOID,
    #[doc = "offset: 0xf98 (3992)"]
    pub MuiGeneration: ULONG,
    #[doc = "offset: 0xf9c (3996)"]
    pub IsImpersonating: ULONG,
    #[doc = "offset: 0xfa0 (4000)"]
    pub NlsCache: *mut VOID,
    #[doc = "offset: 0xfa4 (4004)"]
    pub pShimData: *mut VOID,
    #[doc = "offset: 0xfa8 (4008)"]
    pub HeapVirtualAffinity: USHORT,
    #[doc = "offset: 0xfaa (4010)"]
    pub LowFragHeapDataSlot: USHORT,
    #[doc = "offset: 0xfac (4012)"]
    pub CurrentTransactionHandle: *mut VOID,
    #[doc = "offset: 0xfb0 (4016)"]
    pub ActiveFrame: *mut _TEB_ACTIVE_FRAME,
    #[doc = "offset: 0xfb4 (4020)"]
    pub FlsData: *mut VOID,
    #[doc = "offset: 0xfb8 (4024)"]
    pub PreferredLanguages: *mut VOID,
    #[doc = "offset: 0xfbc (4028)"]
    pub UserPrefLanguages: *mut VOID,
    #[doc = "offset: 0xfc0 (4032)"]
    pub MergedPrefLanguages: *mut VOID,
    #[doc = "offset: 0xfc4 (4036)"]
    pub MuiImpersonation: ULONG,
    pub __bindgen_anon_2: _TEB__bindgen_ty_2,
    pub __bindgen_anon_3: _TEB__bindgen_ty_3,
    #[doc = "offset: 0xfcc (4044)"]
    pub TxnScopeEnterCallback: *mut VOID,
    #[doc = "offset: 0xfd0 (4048)"]
    pub TxnScopeExitCallback: *mut VOID,
    #[doc = "offset: 0xfd4 (4052)"]
    pub TxnScopeContext: *mut VOID,
    #[doc = "offset: 0xfd8 (4056)"]
    pub LockCount: ULONG,
    #[doc = "offset: 0xfdc (4060)"]
    pub WowTebOffset: LONG,
    #[doc = "offset: 0xfe0 (4064)"]
    pub ResourceRetValue: *mut VOID,
    #[doc = "offset: 0xfe4 (4068)"]
    pub ReservedForWdf: *mut VOID,
    #[doc = "offset: 0xfe8 (4072)"]
    pub ReservedForCrt: ULONGLONG,
    #[doc = "offset: 0xff0 (4080)"]
    pub EffectiveContainerId: _GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_1 {
    #[doc = "offset: 0xf74 (3956)"]
    pub CurrentIdealProcessor: _PROCESSOR_NUMBER,
    #[doc = "offset: 0xf74 (3956)"]
    pub IdealProcessorValue: ULONG,
    pub __bindgen_anon_1: _TEB__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0xf74 (3956)"]
    pub ReservedPad0: UCHAR,
    #[doc = "offset: 0xf75 (3957)"]
    pub ReservedPad1: UCHAR,
    #[doc = "offset: 0xf76 (3958)"]
    pub ReservedPad2: UCHAR,
    #[doc = "offset: 0xf77 (3959)"]
    pub IdealProcessor: UCHAR,
}
impl Default for _TEB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_2 {
    #[doc = "offset: 0xfc8 (4040)"]
    pub CrossTebFlags: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _TEB__bindgen_ty_2 {
    #[inline]
    pub fn SpareCrossTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let SpareCrossTebBits: u16 = unsafe { ::std::mem::transmute(SpareCrossTebBits) };
            SpareCrossTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_3 {
    #[doc = "offset: 0xfca (4042)"]
    pub SameTebFlags: USHORT,
    pub __bindgen_anon_1: _TEB__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SafeThunkCall(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SafeThunkCall(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InDebugPrint(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InDebugPrint(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasFiberData(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HasFiberData(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipThreadAttach(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SkipThreadAttach(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WerInShipAssertCode(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WerInShipAssertCode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RanProcessInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RanProcessInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClonedThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ClonedThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SuppressDebugMsg(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SuppressDebugMsg(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableUserStackWalk(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DisableUserStackWalk(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlExceptionAttached(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InitialThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InitialThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SessionAware(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SessionAware(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoadOwner(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoadOwner(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoaderWorker(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoaderWorker(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipLoaderInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SkipLoaderInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareSameTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SafeThunkCall: USHORT,
        InDebugPrint: USHORT,
        HasFiberData: USHORT,
        SkipThreadAttach: USHORT,
        WerInShipAssertCode: USHORT,
        RanProcessInit: USHORT,
        ClonedThread: USHORT,
        SuppressDebugMsg: USHORT,
        DisableUserStackWalk: USHORT,
        RtlExceptionAttached: USHORT,
        InitialThread: USHORT,
        SessionAware: USHORT,
        LoadOwner: USHORT,
        LoaderWorker: USHORT,
        SkipLoaderInit: USHORT,
        SpareSameTebBits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SafeThunkCall: u16 = unsafe { ::std::mem::transmute(SafeThunkCall) };
            SafeThunkCall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InDebugPrint: u16 = unsafe { ::std::mem::transmute(InDebugPrint) };
            InDebugPrint as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HasFiberData: u16 = unsafe { ::std::mem::transmute(HasFiberData) };
            HasFiberData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SkipThreadAttach: u16 = unsafe { ::std::mem::transmute(SkipThreadAttach) };
            SkipThreadAttach as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WerInShipAssertCode: u16 = unsafe { ::std::mem::transmute(WerInShipAssertCode) };
            WerInShipAssertCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RanProcessInit: u16 = unsafe { ::std::mem::transmute(RanProcessInit) };
            RanProcessInit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ClonedThread: u16 = unsafe { ::std::mem::transmute(ClonedThread) };
            ClonedThread as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SuppressDebugMsg: u16 = unsafe { ::std::mem::transmute(SuppressDebugMsg) };
            SuppressDebugMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DisableUserStackWalk: u16 = unsafe { ::std::mem::transmute(DisableUserStackWalk) };
            DisableUserStackWalk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RtlExceptionAttached: u16 = unsafe { ::std::mem::transmute(RtlExceptionAttached) };
            RtlExceptionAttached as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let InitialThread: u16 = unsafe { ::std::mem::transmute(InitialThread) };
            InitialThread as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let SessionAware: u16 = unsafe { ::std::mem::transmute(SessionAware) };
            SessionAware as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LoadOwner: u16 = unsafe { ::std::mem::transmute(LoadOwner) };
            LoadOwner as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LoaderWorker: u16 = unsafe { ::std::mem::transmute(LoaderWorker) };
            LoaderWorker as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let SkipLoaderInit: u16 = unsafe { ::std::mem::transmute(SkipLoaderInit) };
            SkipLoaderInit as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SpareSameTebBits: u16 = unsafe { ::std::mem::transmute(SpareSameTebBits) };
            SpareSameTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TEB__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TEB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x330 (816) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
    #[doc = "offset: 0x0 (0)"]
    pub EnabledFeatures: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub EnabledVolatileFeatures: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Size: ULONG,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub Features: [_XSTATE_FEATURE; 64usize],
    #[doc = "offset: 0x218 (536)"]
    pub EnabledSupervisorFeatures: ULONGLONG,
    #[doc = "offset: 0x220 (544)"]
    pub AlignedFeatures: ULONGLONG,
    #[doc = "offset: 0x228 (552)"]
    pub AllFeatureSize: ULONG,
    #[doc = "offset: 0x22c (556)"]
    pub AllFeatures: [ULONG; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
    #[doc = "offset: 0x14 (20)"]
    pub ControlFlags: ULONG,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn OptimizedSave(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OptimizedSave(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompactionEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompactionEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OptimizedSave: ULONG,
        CompactionEnabled: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OptimizedSave: u32 = unsafe { ::std::mem::transmute(OptimizedSave) };
            OptimizedSave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CompactionEnabled: u32 = unsafe { ::std::mem::transmute(CompactionEnabled) };
            CompactionEnabled as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _XSTATE_CONFIGURATION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _XSTATE_CONFIGURATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_PER_PROCESSOR_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub UncompressedData: *mut UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub MappingVa: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub XpressEncodeWorkspace: *mut VOID,
    #[doc = "offset: 0xc (12)"]
    pub CompressedDataBuffer: *mut UCHAR,
    #[doc = "offset: 0x10 (16)"]
    pub CopyTicks: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub CompressTicks: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub BytesCopied: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub PagesProcessed: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub DecompressTicks: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub ResumeCopyTicks: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub SharedBufferTicks: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub DecompressTicksByMethod: [ULONGLONG; 2usize],
    #[doc = "offset: 0x58 (88)"]
    pub DecompressSizeByMethod: [ULONGLONG; 2usize],
    #[doc = "offset: 0x68 (104)"]
    pub CompressCount: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub HuffCompressCount: ULONG,
}
impl Default for _POP_PER_PROCESSOR_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x140 (320) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_HIBER_CONTEXT {
    #[doc = "offset: 0x0 (0)"]
    pub Reset: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub HiberFlags: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub WroteHiberFile: UCHAR,
    #[doc = "offset: 0x3 (3)"]
    pub KernelPhaseVerificationActive: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub InitializationFinished: UCHAR,
    #[doc = "offset: 0x8 (8)"]
    pub NextTableLockHeld: LONG,
    #[doc = "offset: 0xc (12)"]
    pub BootPhaseFinishedBarrier: LONG,
    #[doc = "offset: 0x10 (16)"]
    pub KernelResumeFinishedBarrier: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub HvCaptureReadyBarrier: LONG,
    #[doc = "offset: 0x18 (24)"]
    pub HvCaptureCompletedBarrier: LONG,
    #[doc = "offset: 0x1c (28)"]
    pub MapFrozen: UCHAR,
    pub __bindgen_anon_1: _POP_HIBER_CONTEXT__bindgen_ty_1,
    #[doc = "offset: 0x28 (40)"]
    pub BootPhaseMap: _RTL_BITMAP,
    #[doc = "offset: 0x30 (48)"]
    pub ClonedRanges: _LIST_ENTRY,
    #[doc = "offset: 0x38 (56)"]
    pub ClonedRangeCount: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub ClonedPageCount: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub CurrentMap: *mut _RTL_BITMAP,
    #[doc = "offset: 0x4c (76)"]
    pub NextCloneRange: *mut _LIST_ENTRY,
    #[doc = "offset: 0x50 (80)"]
    pub NextPreserve: ULONG,
    #[doc = "offset: 0x54 (84)"]
    pub LoaderMdl: *mut _MDL,
    #[doc = "offset: 0x58 (88)"]
    pub AllocatedMdl: *mut _MDL,
    #[doc = "offset: 0x60 (96)"]
    pub PagesOut: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub IoPages: *mut VOID,
    #[doc = "offset: 0x6c (108)"]
    pub IoPagesCount: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub CurrentMcb: *mut VOID,
    #[doc = "offset: 0x74 (116)"]
    pub DumpStack: *mut _DUMP_STACK_CONTEXT,
    #[doc = "offset: 0x78 (120)"]
    pub WakeState: *mut _KPROCESSOR_STATE,
    #[doc = "offset: 0x7c (124)"]
    pub IoProgress: ULONG,
    #[doc = "offset: 0x80 (128)"]
    pub Status: LONG,
    #[doc = "offset: 0x84 (132)"]
    pub GraphicsProc: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub MemoryImage: *mut PO_MEMORY_IMAGE,
    #[doc = "offset: 0x8c (140)"]
    pub PerformanceStats: *mut ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub BootLoaderLogMdl: *mut _MDL,
    #[doc = "offset: 0x94 (148)"]
    pub SiLogOffset: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub FirmwareRuntimeInformationMdl: *mut _MDL,
    #[doc = "offset: 0x9c (156)"]
    pub FirmwareRuntimeInformationVa: *mut VOID,
    #[doc = "offset: 0xa0 (160)"]
    pub ResumeContext: *mut VOID,
    #[doc = "offset: 0xa4 (164)"]
    pub ResumeContextPages: ULONG,
    #[doc = "offset: 0xa8 (168)"]
    pub ProcessorCount: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub ProcessorContext: *mut _POP_PER_PROCESSOR_CONTEXT,
    #[doc = "offset: 0xb0 (176)"]
    pub ProdConsBuffer: *mut CHAR,
    #[doc = "offset: 0xb4 (180)"]
    pub ProdConsSize: ULONG,
    #[doc = "offset: 0xb8 (184)"]
    pub MaxDataPages: ULONG,
    #[doc = "offset: 0xbc (188)"]
    pub ExtraBuffer: *mut VOID,
    #[doc = "offset: 0xc0 (192)"]
    pub ExtraBufferSize: ULONG,
    #[doc = "offset: 0xc4 (196)"]
    pub ExtraMapVa: *mut VOID,
    #[doc = "offset: 0xc8 (200)"]
    pub BitlockerKeyPFN: ULONG,
    #[doc = "offset: 0xd0 (208)"]
    pub IoInfo: _POP_IO_INFO,
    #[doc = "offset: 0x130 (304)"]
    pub IoChecksums: *mut USHORT,
    #[doc = "offset: 0x134 (308)"]
    pub IoChecksumsSize: ULONG,
    #[doc = "offset: 0x138 (312)"]
    pub HardwareConfigurationSignature: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_HIBER_CONTEXT__bindgen_ty_1 {
    #[doc = "offset: 0x20 (32)"]
    pub DiscardMap: _RTL_BITMAP,
    #[doc = "offset: 0x20 (32)"]
    pub KernelPhaseMap: _RTL_BITMAP,
}
impl Default for _POP_HIBER_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_HIBER_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x110 (272) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_POWER_ACTION {
    #[doc = "offset: 0x0 (0)"]
    pub Updates: UCHAR,
    #[doc = "offset: 0x1 (1)"]
    pub State: UCHAR,
    #[doc = "offset: 0x2 (2)"]
    pub Shutdown: UCHAR,
    #[doc = "offset: 0x4 (4)"]
    pub Action: POWER_ACTION,
    #[doc = "offset: 0x8 (8)"]
    pub LightestState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub Status: LONG,
    #[doc = "offset: 0x14 (20)"]
    pub DeviceType: POWER_POLICY_DEVICE_TYPE,
    #[doc = "offset: 0x18 (24)"]
    pub DeviceTypeFlags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub IrpMinor: UCHAR,
    #[doc = "offset: 0x1d (29)"]
    pub Waking: UCHAR,
    #[doc = "offset: 0x20 (32)"]
    pub SystemState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x24 (36)"]
    pub NextSystemState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x28 (40)"]
    pub EffectiveSystemState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x2c (44)"]
    pub CurrentSystemState: _SYSTEM_POWER_STATE,
    #[doc = "offset: 0x30 (48)"]
    pub ShutdownBugCode: *mut _POP_SHUTDOWN_BUG_CHECK,
    #[doc = "offset: 0x34 (52)"]
    pub DevState: *mut _POP_DEVICE_SYS_STATE,
    #[doc = "offset: 0x38 (56)"]
    pub HiberContext: *mut _POP_HIBER_CONTEXT,
    #[doc = "offset: 0x40 (64)"]
    pub WakeTime: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub SleepTime: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub WakeFirstUnattendedTime: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub WakeAlarmSignaled: SYSTEM_POWER_CONDITION,
    #[doc = "offset: 0x60 (96)"]
    pub WakeAlarm: [_POP_POWER_ACTION__bindgen_ty_1; 3usize],
    #[doc = "offset: 0xa8 (168)"]
    pub WakeAlarmPaused: UCHAR,
    #[doc = "offset: 0xb0 (176)"]
    pub WakeAlarmLastTime: ULONGLONG,
    #[doc = "offset: 0xb8 (184)"]
    pub DozeDeferralStartTime: ULONGLONG,
    #[doc = "offset: 0xc0 (192)"]
    pub FilteredCapabilities: SYSTEM_POWER_CAPABILITIES,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_POWER_ACTION__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub RequestedTime: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub ProgrammedTime: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub TimerInfo: *mut _DIAGNOSTIC_BUFFER,
}
impl Default for _POP_POWER_ACTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_POWER_ACTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER2 {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    pub __bindgen_anon_1: _KTIMER2__bindgen_ty_1,
    #[doc = "offset: 0x28 (40)"]
    pub DueTime: [ULONGLONG; 2usize],
    #[doc = "offset: 0x38 (56)"]
    pub Period: LONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub Callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _KTIMER2, arg2: *mut VOID)>,
    #[doc = "offset: 0x44 (68)"]
    pub CallbackContext: *mut VOID,
    #[doc = "offset: 0x48 (72)"]
    pub DisableCallback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = "offset: 0x4c (76)"]
    pub DisableContext: *mut VOID,
    #[doc = "offset: 0x50 (80)"]
    pub AbsoluteSystemTime: UCHAR,
    pub __bindgen_anon_2: _KTIMER2__bindgen_ty_2,
    #[doc = "offset: 0x52 (82)"]
    pub CollectionIndex: [UCHAR; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTIMER2__bindgen_ty_1 {
    #[doc = "offset: 0x10 (16)"]
    pub RbNodes: [_RTL_BALANCED_NODE; 2usize],
    #[doc = "offset: 0x10 (16)"]
    pub ListEntry: _LIST_ENTRY,
}
impl Default for _KTIMER2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTIMER2__bindgen_ty_2 {
    #[doc = "offset: 0x51 (81)"]
    pub TypeFlags: UCHAR,
    pub __bindgen_anon_1: _KTIMER2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTIMER2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KTIMER2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Unused(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleResilient(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IdleResilient(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HighResolution(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HighResolution(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoWake(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NoWake(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Unused1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Unused: UCHAR,
        IdleResilient: UCHAR,
        HighResolution: UCHAR,
        NoWake: UCHAR,
        Unused1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Unused: u8 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IdleResilient: u8 = unsafe { ::std::mem::transmute(IdleResilient) };
            IdleResilient as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HighResolution: u8 = unsafe { ::std::mem::transmute(HighResolution) };
            HighResolution as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoWake: u8 = unsafe { ::std::mem::transmute(NoWake) };
            NoWake as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Unused1: u8 = unsafe { ::std::mem::transmute(Unused1) };
            Unused1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTIMER2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTIMER2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb8 (184) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_WORK_QUEUE_MANAGER {
    #[doc = "offset: 0x0 (0)"]
    pub Partition: *mut _EX_PARTITION,
    #[doc = "offset: 0x4 (4)"]
    pub Node: *mut _ENODE,
    #[doc = "offset: 0x8 (8)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x18 (24)"]
    pub DeadlockTimer: _KTIMER,
    #[doc = "offset: 0x40 (64)"]
    pub ReaperEvent: _KEVENT,
    #[doc = "offset: 0x50 (80)"]
    pub ReaperTimer: _KTIMER2,
    #[doc = "offset: 0xa8 (168)"]
    pub ThreadHandle: *mut VOID,
    #[doc = "offset: 0xac (172)"]
    pub ExitThread: ULONG,
    #[doc = "offset: 0xb0 (176)"]
    pub ThreadSeed: ULONG,
}
impl Default for _EX_WORK_QUEUE_MANAGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EX_PARTITION {
    #[doc = "offset: 0x0 (0)"]
    pub PartitionObject: *mut _EPARTITION,
    #[doc = "offset: 0x4 (4)"]
    pub WorkQueues: *mut *mut *mut _EX_WORK_QUEUE,
    #[doc = "offset: 0x8 (8)"]
    pub WorkQueueManagers: *mut *mut _EX_WORK_QUEUE_MANAGER,
    #[doc = "offset: 0xc (12)"]
    pub QueueAllocationMask: LONG,
}
impl Default for _EX_PARTITION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x2e8 (744) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_THERMAL_ZONE {
    pub __bindgen_anon_1: _POP_THERMAL_ZONE__bindgen_ty_1,
    #[doc = "offset: 0x20 (32)"]
    pub State: UCHAR,
    #[doc = "offset: 0x21 (33)"]
    pub Flags: UCHAR,
    #[doc = "offset: 0x22 (34)"]
    pub Removing: UCHAR,
    #[doc = "offset: 0x23 (35)"]
    pub Mode: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub PendingMode: UCHAR,
    #[doc = "offset: 0x25 (37)"]
    pub ActivePoint: UCHAR,
    #[doc = "offset: 0x26 (38)"]
    pub PendingActivePoint: UCHAR,
    #[doc = "offset: 0x27 (39)"]
    pub Critical: UCHAR,
    #[doc = "offset: 0x28 (40)"]
    pub ThermalStandby: UCHAR,
    #[doc = "offset: 0x29 (41)"]
    pub OverThrottled: UCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub HighPrecisionThrottle: LONG,
    #[doc = "offset: 0x30 (48)"]
    pub Throttle: LONG,
    #[doc = "offset: 0x34 (52)"]
    pub PendingThrottle: LONG,
    #[doc = "offset: 0x38 (56)"]
    pub ThrottleReasons: ULONG,
    #[doc = "offset: 0x40 (64)"]
    pub LastPassiveTime: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub SampleRate: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub LastTemp: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub Info: _THERMAL_INFORMATION_EX,
    #[doc = "offset: 0xac (172)"]
    pub Policy: _THERMAL_POLICY,
    #[doc = "offset: 0xc4 (196)"]
    pub PolicyDriver: UCHAR,
    #[doc = "offset: 0xc8 (200)"]
    pub PollingRate: ULONG,
    #[doc = "offset: 0xd0 (208)"]
    pub LastTemperatureTime: ULONGLONG,
    #[doc = "offset: 0xd8 (216)"]
    pub LastActiveStartTime: ULONGLONG,
    #[doc = "offset: 0xe0 (224)"]
    pub LastPassiveStartTime: ULONGLONG,
    #[doc = "offset: 0xe8 (232)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0xf8 (248)"]
    pub ZoneUpdateTimer: _KTIMER2,
    #[doc = "offset: 0x150 (336)"]
    pub Lock: _POP_RW_LOCK,
    #[doc = "offset: 0x158 (344)"]
    pub ZoneStopped: _KEVENT,
    #[doc = "offset: 0x168 (360)"]
    pub TemperatureUpdated: _KEVENT,
    #[doc = "offset: 0x178 (376)"]
    pub InstanceId: ULONG,
    #[doc = "offset: 0x180 (384)"]
    pub TelemetryTracker: _POP_THERMAL_TELEMETRY_TRACKER,
    #[doc = "offset: 0x2e0 (736)"]
    pub Description: _UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_THERMAL_ZONE__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub PolicyDevice: _POP_POLICY_DEVICE,
    pub __bindgen_anon_1: _POP_THERMAL_ZONE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POP_THERMAL_ZONE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub DeviceType: POWER_POLICY_DEVICE_TYPE,
    #[doc = "offset: 0xc (12)"]
    pub Notification: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub Name: _UNICODE_STRING,
    #[doc = "offset: 0x18 (24)"]
    pub Device: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x1c (28)"]
    pub Irp: *mut _IRP,
}
impl Default for _POP_THERMAL_ZONE__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_THERMAL_ZONE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_THERMAL_ZONE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRUSTLET_COLLABORATION_ID {
    #[doc = "offset: 0x0 (0)"]
    pub Value: [ULONGLONG; 2usize],
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRUSTLET_MAILBOX_KEY {
    #[doc = "offset: 0x0 (0)"]
    pub SecretValue: [ULONGLONG; 2usize],
}
#[doc = "0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_PAYLOAD_PREDICATE {
    #[doc = "offset: 0x0 (0)"]
    pub FieldIndex: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub CompareOp: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub Value: [ULONGLONG; 2usize],
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _AGGREGATED_PAYLOAD_FILTER {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub PredicateCount: USHORT,
    #[doc = "offset: 0x6 (6)"]
    pub Reserved: USHORT,
    #[doc = "offset: 0x8 (8)"]
    pub HashedEventIdBitmap: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub ProviderGuid: _GUID,
    #[doc = "offset: 0x20 (32)"]
    pub EachEventTableOffset: USHORT,
    #[doc = "offset: 0x22 (34)"]
    pub EachEventTableLength: USHORT,
    #[doc = "offset: 0x24 (36)"]
    pub PayloadDecoderTableOffset: USHORT,
    #[doc = "offset: 0x26 (38)"]
    pub PayloadDecoderTableLength: USHORT,
    #[doc = "offset: 0x28 (40)"]
    pub EventFilterTableOffset: USHORT,
    #[doc = "offset: 0x2a (42)"]
    pub EventFilterTableLength: USHORT,
    #[doc = "offset: 0x2c (44)"]
    pub UNICODEStringTableOffset: USHORT,
    #[doc = "offset: 0x2e (46)"]
    pub UNICODEStringTableLength: USHORT,
    #[doc = "offset: 0x30 (48)"]
    pub ANSIStringTableOffset: USHORT,
    #[doc = "offset: 0x32 (50)"]
    pub ANSIStringTableLength: USHORT,
    #[doc = "offset: 0x38 (56)"]
    pub PredicateTable: [_EVENT_PAYLOAD_PREDICATE; 1usize],
}
impl _AGGREGATED_PAYLOAD_FILTER {
    #[inline]
    pub fn MagicValue(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_MagicValue(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn DescriptorVersion(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_DescriptorVersion(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MagicValue: USHORT,
        DescriptorVersion: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let MagicValue: u16 = unsafe { ::std::mem::transmute(MagicValue) };
            MagicValue as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let DescriptorVersion: u16 = unsafe { ::std::mem::transmute(DescriptorVersion) };
            DescriptorVersion as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_PAYLOAD_FILTER {
    #[doc = "offset: 0x0 (0)"]
    pub RefCount: LONG,
    #[doc = "offset: 0x8 (8)"]
    pub PayloadFilter: _AGGREGATED_PAYLOAD_FILTER,
}
#[doc = "0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_FILTER_HEADER {
    #[doc = "offset: 0x0 (0)"]
    pub FilterFlags: LONG,
    #[doc = "offset: 0x4 (4)"]
    pub PidFilter: *mut _ETW_FILTER_PID,
    #[doc = "offset: 0x8 (8)"]
    pub ExeFilter: *mut _ETW_FILTER_STRING_TOKEN,
    #[doc = "offset: 0xc (12)"]
    pub PkgIdFilter: *mut _ETW_FILTER_STRING_TOKEN,
    #[doc = "offset: 0x10 (16)"]
    pub PkgAppIdFilter: *mut _ETW_FILTER_STRING_TOKEN,
    #[doc = "offset: 0x14 (20)"]
    pub StackWalkIdFilter: *mut _ETW_PERFECT_HASH_FUNCTION,
    #[doc = "offset: 0x18 (24)"]
    pub StackWalkNameFilter: *mut _ETW_FILTER_EVENT_NAME_DATA,
    #[doc = "offset: 0x1c (28)"]
    pub StackWalkLevelKwFilter: *mut _EVENT_FILTER_LEVEL_KW,
    #[doc = "offset: 0x20 (32)"]
    pub EventIdFilter: *mut _ETW_PERFECT_HASH_FUNCTION,
    #[doc = "offset: 0x24 (36)"]
    pub PayloadFilter: *mut _ETW_PAYLOAD_FILTER,
    #[doc = "offset: 0x28 (40)"]
    pub ProviderSideFilter: *mut _EVENT_FILTER_HEADER,
    #[doc = "offset: 0x2c (44)"]
    pub EventNameFilter: *mut _ETW_FILTER_EVENT_NAME_DATA,
}
impl Default for _ETW_FILTER_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x168 (360) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_GUID_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub GuidList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub RefCount: LONG,
    #[doc = "offset: 0xc (12)"]
    pub Guid: _GUID,
    #[doc = "offset: 0x1c (28)"]
    pub RegListHead: _LIST_ENTRY,
    #[doc = "offset: 0x24 (36)"]
    pub SecurityDescriptor: *mut VOID,
    pub __bindgen_anon_1: _ETW_GUID_ENTRY__bindgen_ty_1,
    #[doc = "offset: 0x38 (56)"]
    pub ProviderEnableInfo: _TRACE_ENABLE_INFO,
    #[doc = "offset: 0x58 (88)"]
    pub EnableInfo: [_TRACE_ENABLE_INFO; 8usize],
    #[doc = "offset: 0x158 (344)"]
    pub FilterData: *mut _ETW_FILTER_HEADER,
    #[doc = "offset: 0x15c (348)"]
    pub SiloState: *mut _ETW_SILODRIVERSTATE,
    #[doc = "offset: 0x160 (352)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x164 (356)"]
    pub LockOwner: *mut _ETHREAD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_GUID_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x28 (40)"]
    pub LastEnable: _ETW_LAST_ENABLE_INFO,
    #[doc = "offset: 0x28 (40)"]
    pub MatchId: ULONGLONG,
}
impl Default for _ETW_GUID_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_GUID_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3c (60) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REG_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub RegList: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub GroupRegList: _LIST_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub GuidEntry: *mut _ETW_GUID_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub GroupEntry: *mut _ETW_GUID_ENTRY,
    pub __bindgen_anon_1: _ETW_REG_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _ETW_REG_ENTRY__bindgen_ty_2,
    #[doc = "offset: 0x2c (44)"]
    pub Callback: *mut VOID,
    #[doc = "offset: 0x30 (48)"]
    pub Index: USHORT,
    pub __bindgen_anon_3: _ETW_REG_ENTRY__bindgen_ty_3,
    #[doc = "offset: 0x34 (52)"]
    pub EnableMask: UCHAR,
    #[doc = "offset: 0x35 (53)"]
    pub GroupEnableMask: UCHAR,
    #[doc = "offset: 0x38 (56)"]
    pub Traits: *mut _ETW_PROVIDER_TRAITS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_REG_ENTRY__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub ReplyQueue: *mut _ETW_REPLY_QUEUE,
    #[doc = "offset: 0x18 (24)"]
    pub ReplySlot: [*mut _ETW_QUEUE_ENTRY; 4usize],
    pub __bindgen_anon_1: _ETW_REG_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_REG_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x18 (24)"]
    pub Caller: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub SessionId: ULONG,
}
impl Default for _ETW_REG_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_REG_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_REG_ENTRY__bindgen_ty_2 {
    #[doc = "offset: 0x28 (40)"]
    pub Process: *mut _EPROCESS,
    #[doc = "offset: 0x28 (40)"]
    pub CallbackContext: *mut VOID,
}
impl Default for _ETW_REG_ENTRY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_REG_ENTRY__bindgen_ty_3 {
    #[doc = "offset: 0x32 (50)"]
    pub Flags: USHORT,
    pub __bindgen_anon_1: _ETW_REG_ENTRY__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_REG_ENTRY__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _ETW_REG_ENTRY__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn DbgKernelRegistration(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgKernelRegistration(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgUserRegistration(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgUserRegistration(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgReplyRegistration(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgReplyRegistration(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgClassicRegistration(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgClassicRegistration(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSessionSpaceRegistration(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSessionSpaceRegistration(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgModernRegistration(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgModernRegistration(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgClosed(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgClosed(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgInserted(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgInserted(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgWow64(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgWow64(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgUseDescriptorType(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgUseDescriptorType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgDropProviderTraits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgDropProviderTraits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgKernelRegistration: USHORT,
        DbgUserRegistration: USHORT,
        DbgReplyRegistration: USHORT,
        DbgClassicRegistration: USHORT,
        DbgSessionSpaceRegistration: USHORT,
        DbgModernRegistration: USHORT,
        DbgClosed: USHORT,
        DbgInserted: USHORT,
        DbgWow64: USHORT,
        DbgUseDescriptorType: USHORT,
        DbgDropProviderTraits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgKernelRegistration: u16 =
                unsafe { ::std::mem::transmute(DbgKernelRegistration) };
            DbgKernelRegistration as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgUserRegistration: u16 = unsafe { ::std::mem::transmute(DbgUserRegistration) };
            DbgUserRegistration as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgReplyRegistration: u16 = unsafe { ::std::mem::transmute(DbgReplyRegistration) };
            DbgReplyRegistration as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgClassicRegistration: u16 =
                unsafe { ::std::mem::transmute(DbgClassicRegistration) };
            DbgClassicRegistration as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgSessionSpaceRegistration: u16 =
                unsafe { ::std::mem::transmute(DbgSessionSpaceRegistration) };
            DbgSessionSpaceRegistration as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgModernRegistration: u16 =
                unsafe { ::std::mem::transmute(DbgModernRegistration) };
            DbgModernRegistration as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgClosed: u16 = unsafe { ::std::mem::transmute(DbgClosed) };
            DbgClosed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DbgInserted: u16 = unsafe { ::std::mem::transmute(DbgInserted) };
            DbgInserted as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DbgWow64: u16 = unsafe { ::std::mem::transmute(DbgWow64) };
            DbgWow64 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DbgUseDescriptorType: u16 = unsafe { ::std::mem::transmute(DbgUseDescriptorType) };
            DbgUseDescriptorType as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DbgDropProviderTraits: u16 =
                unsafe { ::std::mem::transmute(DbgDropProviderTraits) };
            DbgDropProviderTraits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETW_REG_ENTRY__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_REG_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_QUEUE_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub DataBlock: *mut _ETWP_NOTIFICATION_HEADER,
    #[doc = "offset: 0xc (12)"]
    pub RegEntry: *mut _ETW_REG_ENTRY,
    #[doc = "offset: 0x10 (16)"]
    pub ReplyObject: *mut _ETW_REG_ENTRY,
    #[doc = "offset: 0x14 (20)"]
    pub WakeReference: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub RegIndex: USHORT,
    #[doc = "offset: 0x1a (26)"]
    pub ReplyIndex: USHORT,
    #[doc = "offset: 0x1c (28)"]
    pub Flags: ULONG,
}
impl Default for _ETW_QUEUE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xa48 (2632) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_SILODRIVERSTATE {
    #[doc = "offset: 0x0 (0)"]
    pub SiloGlobals: *mut _ESERVERSILO_GLOBALS,
    #[doc = "offset: 0x4 (4)"]
    pub MaxLoggers: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub EtwpSecurityProviderGuidEntry: _ETW_GUID_ENTRY,
    #[doc = "offset: 0x170 (368)"]
    pub EtwpLoggerRundown: *mut *mut _EX_RUNDOWN_REF_CACHE_AWARE,
    #[doc = "offset: 0x174 (372)"]
    pub EtwpLoggerContext: *mut *mut _WMI_LOGGER_CONTEXT,
    #[doc = "offset: 0x178 (376)"]
    pub EtwpGuidHashTable: [_ETW_HASH_BUCKET; 64usize],
    #[doc = "offset: 0x878 (2168)"]
    pub EtwpSecurityLoggers: [USHORT; 8usize],
    #[doc = "offset: 0x888 (2184)"]
    pub EtwpSecurityProviderEnableMask: UCHAR,
    #[doc = "offset: 0x88c (2188)"]
    pub EtwpShutdownInProgress: LONG,
    #[doc = "offset: 0x890 (2192)"]
    pub EtwpSecurityProviderPID: ULONG,
    #[doc = "offset: 0x894 (2196)"]
    pub PrivHandleDemuxTable: _ETW_PRIV_HANDLE_DEMUX_TABLE,
    #[doc = "offset: 0x8a4 (2212)"]
    pub EtwpCounters: _ETW_COUNTERS,
    #[doc = "offset: 0x8b8 (2232)"]
    pub LogfileBytesWritten: _LARGE_INTEGER,
    #[doc = "offset: 0x8c0 (2240)"]
    pub ProcessorBlocks: *mut _ETW_SILO_TRACING_BLOCK,
    #[doc = "offset: 0x8c4 (2244)"]
    pub PartitionId: _GUID,
    #[doc = "offset: 0x8d4 (2260)"]
    pub ParentId: _GUID,
    #[doc = "offset: 0x8e8 (2280)"]
    pub QpcOffsetFromRoot: _LARGE_INTEGER,
    #[doc = "offset: 0x8f0 (2288)"]
    pub PartitionType: ULONG,
    #[doc = "offset: 0x8f4 (2292)"]
    pub SystemLoggerSettings: _ETW_SYSTEM_LOGGER_SETTINGS,
}
impl Default for _ETW_SILODRIVERSTATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_PERF_CHECK_SNAP {
    #[doc = "offset: 0x0 (0)"]
    pub Time: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Active: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub Stall: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub FrequencyScaledActive: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub PerformanceScaledActive: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub PerformanceScaledKernelActive: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub CyclesActive: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub CyclesAffinitized: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub TaggedThreadCycles: [ULONGLONG; 2usize],
}
#[doc = "0x118 (280) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_PERF_CHECK {
    #[doc = "offset: 0x0 (0)"]
    pub LastActive: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub LastTime: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub LastStall: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub LastPerfCheckSnap: _PROC_PERF_CHECK_SNAP,
    #[doc = "offset: 0x68 (104)"]
    pub CurrentSnap: _PROC_PERF_CHECK_SNAP,
    #[doc = "offset: 0xb8 (184)"]
    pub LastDeliveredSnap: _PROC_PERF_CHECK_SNAP,
    #[doc = "offset: 0x108 (264)"]
    pub LastDeliveredPerformance: ULONG,
    #[doc = "offset: 0x10c (268)"]
    pub LastDeliveredFrequency: ULONG,
    #[doc = "offset: 0x110 (272)"]
    pub TaggedThreadPercent: [UCHAR; 2usize],
    #[doc = "offset: 0x112 (274)"]
    pub Class0FloorPerfSelection: UCHAR,
    #[doc = "offset: 0x113 (275)"]
    pub Class1MinimumPerfSelection: UCHAR,
}
#[doc = "0x88 (136) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_FEEDBACK {
    #[doc = "offset: 0x0 (0)"]
    pub Lock: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub CyclesLast: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub CyclesActive: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub Counters: [*mut _PROC_FEEDBACK_COUNTER; 2usize],
    #[doc = "offset: 0x20 (32)"]
    pub LastUpdateTime: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub UnscaledTime: ULONGLONG,
    #[doc = "offset: 0x30 (48)"]
    pub UnaccountedTime: LONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub ScaledTime: [ULONGLONG; 2usize],
    #[doc = "offset: 0x48 (72)"]
    pub UnaccountedKernelTime: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub PerformanceScaledKernelTime: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub UserTimeLast: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub KernelTimeLast: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub IdleGenerationNumberLast: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub HvActiveTimeLast: ULONGLONG,
    #[doc = "offset: 0x70 (112)"]
    pub StallCyclesLast: ULONGLONG,
    #[doc = "offset: 0x78 (120)"]
    pub StallTime: ULONGLONG,
    #[doc = "offset: 0x80 (128)"]
    pub KernelTimesIndex: UCHAR,
    #[doc = "offset: 0x81 (129)"]
    pub CounterDiscardsIdleTime: UCHAR,
}
impl Default for _PROC_FEEDBACK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1a8 (424) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_POWER_STATE {
    #[doc = "offset: 0x0 (0)"]
    pub IdleStates: *mut _PPM_IDLE_STATES,
    #[doc = "offset: 0x4 (4)"]
    pub IdleAccounting: *mut _PROC_IDLE_ACCOUNTING,
    #[doc = "offset: 0x8 (8)"]
    pub IdleTimeLast: ULONGLONG,
    #[doc = "offset: 0x10 (16)"]
    pub IdleTimeTotal: ULONGLONG,
    #[doc = "offset: 0x18 (24)"]
    pub IdleTimeEntry: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub IdleTimeExpiration: ULONGLONG,
    #[doc = "offset: 0x28 (40)"]
    pub NonInterruptibleTransition: UCHAR,
    #[doc = "offset: 0x29 (41)"]
    pub PepWokenTransition: UCHAR,
    #[doc = "offset: 0x2a (42)"]
    pub EfficiencyClass: UCHAR,
    #[doc = "offset: 0x2b (43)"]
    pub SchedulingClass: UCHAR,
    #[doc = "offset: 0x2c (44)"]
    pub TargetIdleState: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub IdlePolicy: _PROC_IDLE_POLICY,
    #[doc = "offset:\n 0x38 (56)"]
    pub Synchronization: _PPM_IDLE_SYNCHRONIZATION_STATE,
    #[doc = "offset: 0x40 (64)"]
    pub PerfFeedback: _PROC_FEEDBACK,
    #[doc = "offset: 0xc8 (200)"]
    pub Hypervisor: _PROC_HYPERVISOR_STATE,
    #[doc = "offset: 0xcc (204)"]
    pub LastSysTime: ULONG,
    #[doc = "offset: 0xd0 (208)"]
    pub WmiDispatchPtr: ULONG,
    #[doc = "offset: 0xd4 (212)"]
    pub WmiInterfaceEnabled: LONG,
    #[doc = "offset: 0xd8 (216)"]
    pub FFHThrottleStateInfo: _PPM_FFH_THROTTLE_STATE_INFO,
    #[doc = "offset: 0xf8 (248)"]
    pub PerfActionDpc: _KDPC,
    #[doc = "offset: 0x118 (280)"]
    pub PerfActionMask: LONG,
    #[doc = "offset: 0x120 (288)"]
    pub HvIdleCheck: _PROC_IDLE_SNAP,
    #[doc = "offset: 0x130 (304)"]
    pub PerfCheck: *mut _PROC_PERF_CHECK,
    #[doc = "offset: 0x134 (308)"]
    pub Domain: *mut _PROC_PERF_DOMAIN,
    #[doc = "offset: 0x138 (312)"]
    pub PerfConstraint: *mut _PROC_PERF_CONSTRAINT,
    #[doc = "offset: 0x13c (316)"]
    pub Concurrency: *mut _PPM_CONCURRENCY_ACCOUNTING,
    #[doc = "offset: 0x140 (320)"]
    pub ClassConcurrency: *mut _PPM_CONCURRENCY_ACCOUNTING,
    #[doc = "offset: 0x144 (324)"]
    pub Load: *mut _PROC_PERF_LOAD,
    #[doc = "offset: 0x148 (328)"]
    pub PerfHistory: *mut _PROC_PERF_HISTORY,
    #[doc = "offset: 0x14c (332)"]
    pub GuaranteedPerformancePercent: UCHAR,
    #[doc = "offset: 0x14d (333)"]
    pub HvTargetState: UCHAR,
    #[doc = "offset: 0x14e (334)"]
    pub Parked: UCHAR,
    #[doc = "offset: 0x14f (335)"]
    pub LongPriorQosPeriod: UCHAR,
    #[doc = "offset: 0x150 (336)"]
    pub LatestPerformancePercent: ULONG,
    #[doc = "offset: 0x154 (340)"]
    pub AveragePerformancePercent: ULONG,
    #[doc = "offset: 0x158 (344)"]
    pub LatestAffinitizedPercent: ULONG,
    #[doc = "offset: 0x15c (348)"]
    pub RelativePerformance: ULONG,
    #[doc = "offset: 0x160 (352)"]
    pub Utility: ULONG,
    #[doc = "offset: 0x164 (356)"]
    pub AffinitizedUtility: ULONG,
    pub __bindgen_anon_1: _PROCESSOR_POWER_STATE__bindgen_ty_1,
    #[doc = "offset: 0x170 (368)"]
    pub ActiveTime: ULONGLONG,
    #[doc = "offset: 0x178 (376)"]
    pub TotalTime: ULONGLONG,
    #[doc = "offset: 0x180 (384)"]
    pub FxDevice: *mut _POP_FX_DEVICE,
    #[doc = "offset: 0x188 (392)"]
    pub LastQosTranstionTsc: ULONGLONG,
    #[doc = "offset: 0x190 (400)"]
    pub QosTransitionHysteresis: ULONGLONG,
    #[doc = "offset: 0x198 (408)"]
    pub RequestedQosClass: _KHETERO_CPU_QOS,
    #[doc = "offset: 0x19c (412)"]
    pub ResolvedQosClass: _KHETERO_CPU_QOS,
    #[doc = "offset: 0x1a0 (416)"]
    pub QosEquivalencyMask: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESSOR_POWER_STATE__bindgen_ty_1 {
    #[doc = "offset: 0x168 (360)"]
    pub SnapTimeLast: ULONGLONG,
    #[doc = "offset: 0x168 (360)"]
    pub EnergyConsumed: ULONGLONG,
}
impl Default for _PROCESSOR_POWER_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PROCESSOR_POWER_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x110 (272) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES {
    #[doc = "offset: 0x0 (0)"]
    pub Cycles: [[ULONGLONG; 2usize]; 4usize],
    #[doc = "offset: 0x40 (64)"]
    pub DiskEnergy: ULONGLONG,
    #[doc = "offset: 0x48 (72)"]
    pub NetworkTailEnergy: ULONGLONG,
    #[doc = "offset: 0x50 (80)"]
    pub MBBTailEnergy: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub NetworkTxRxBytes: ULONGLONG,
    #[doc = "offset: 0x60 (96)"]
    pub MBBTxRxBytes: ULONGLONG,
    pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES__bindgen_ty_1,
    #[doc = "offset: 0x80 (128)"]
    pub CompositionRendered: ULONG,
    #[doc = "offset: 0x84 (132)"]
    pub CompositionDirtyGenerated: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub CompositionDirtyPropagated: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub Reserved1: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub AttributedCycles: [[ULONGLONG; 2usize]; 4usize],
    #[doc = "offset: 0xd0 (208)"]
    pub WorkOnBehalfCycles: [[ULONGLONG; 2usize]; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES__bindgen_ty_1 {
    #[doc = "offset: 0x68 (104)"]
    pub Durations: [_ENERGY_STATE_DURATION; 3usize],
    pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x68 (104)"]
    pub ForegroundDuration: _ENERGY_STATE_DURATION,
    #[doc = "offset: 0x70 (112)"]
    pub DesktopVisibleDuration: _ENERGY_STATE_DURATION,
    #[doc = "offset: 0x78 (120)"]
    pub PSMForegroundDuration: _ENERGY_STATE_DURATION,
}
impl Default for _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PROCESS_ENERGY_VALUES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PROCESS_ENERGY_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1b0 (432) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_EXTENDED_ENERGY_VALUES {
    #[doc = "offset: 0x0 (0)"]
    pub Base: _PROCESS_ENERGY_VALUES,
    #[doc = "offset: 0x110 (272)"]
    pub Extension: _PROCESS_ENERGY_VALUES_EXTENSION,
}
impl Default for _PROCESS_EXTENDED_ENERGY_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x3a0 (928) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EJOB {
    #[doc = "offset: 0x0 (0)"]
    pub Event: _KEVENT,
    #[doc = "offset: 0x10 (16)"]
    pub JobLinks: _LIST_ENTRY,
    #[doc = "offset: 0x18 (24)"]
    pub ProcessListHead: _LIST_ENTRY,
    #[doc = "offset: 0x20 (32)"]
    pub JobLock: _ERESOURCE,
    #[doc = "offset: 0x58 (88)"]
    pub TotalUserTime: _LARGE_INTEGER,
    #[doc = "offset: 0x60 (96)"]
    pub TotalKernelTime: _LARGE_INTEGER,
    #[doc = "offset: 0x68 (104)"]
    pub TotalCycleTime: _LARGE_INTEGER,
    #[doc = "offset: 0x70 (112)"]
    pub ThisPeriodTotalUserTime: _LARGE_INTEGER,
    #[doc = "offset: 0x78 (120)"]
    pub ThisPeriodTotalKernelTime: _LARGE_INTEGER,
    #[doc = "offset: 0x80 (128)"]
    pub TotalContextSwitches: ULONGLONG,
    #[doc = "offset: 0x88 (136)"]
    pub TotalPageFaultCount: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub TotalProcesses: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub ActiveProcesses: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub TotalTerminatedProcesses: ULONG,
    #[doc = "offset: 0x98 (152)"]
    pub PerProcessUserTimeLimit: _LARGE_INTEGER,
    #[doc = "offset: 0xa0 (160)"]
    pub PerJobUserTimeLimit: _LARGE_INTEGER,
    #[doc = "offset: 0xa8 (168)"]
    pub MinimumWorkingSetSize: ULONG,
    #[doc = "offset: 0xac (172)"]
    pub MaximumWorkingSetSize: ULONG,
    #[doc = "offset: 0xb0 (176)"]
    pub LimitFlags: ULONG,
    #[doc = "offset: 0xb4 (180)"]
    pub ActiveProcessLimit: ULONG,
    #[doc = "offset: 0xb8 (184)"]
    pub Affinity: _KAFFINITY_EX,
    #[doc = "offset: 0xc4 (196)"]
    pub AccessState: *mut _JOB_ACCESS_STATE,
    #[doc = "offset: 0xc8 (200)"]
    pub AccessStateQuotaReference: *mut VOID,
    #[doc = "offset: 0xcc (204)"]
    pub UIRestrictionsClass: ULONG,
    #[doc = "offset: 0xd0 (208)"]
    pub EndOfJobTimeAction: ULONG,
    #[doc = "offset: 0xd4 (212)"]
    pub CompletionPort: *mut VOID,
    #[doc = "offset: 0xd8 (216)"]
    pub CompletionKey: *mut VOID,
    #[doc = "offset: 0xe0 (224)"]
    pub CompletionCount: ULONGLONG,
    #[doc = "offset: 0xe8 (232)"]
    pub SessionId: ULONG,
    #[doc = "offset: 0xec (236)"]
    pub SchedulingClass: ULONG,
    #[doc = "offset: 0xf0 (240)"]
    pub ReadOperationCount: ULONGLONG,
    #[doc = "offset: 0xf8 (248)"]
    pub WriteOperationCount: ULONGLONG,
    #[doc = "offset: 0x100 (256)"]
    pub OtherOperationCount: ULONGLONG,
    #[doc = "offset: 0x108 (264)"]
    pub ReadTransferCount: ULONGLONG,
    #[doc = "offset: 0x110 (272)"]
    pub WriteTransferCount: ULONGLONG,
    #[doc = "offset: 0x118 (280)"]
    pub OtherTransferCount: ULONGLONG,
    #[doc = "offset: 0x120 (288)"]
    pub DiskIoInfo: _PROCESS_DISK_COUNTERS,
    #[doc = "offset: 0x148 (328)"]
    pub ProcessMemoryLimit: ULONG,
    #[doc = "offset: 0x14c (332)"]
    pub JobMemoryLimit: ULONG,
    #[doc = "offset: 0x150 (336)"]
    pub JobTotalMemoryLimit: ULONG,
    #[doc = "offset: 0x154 (340)"]
    pub PeakProcessMemoryUsed: ULONG,
    #[doc = "offset: 0x158 (344)"]
    pub PeakJobMemoryUsed: ULONG,
    #[doc = "offset: 0x15c (348)"]
    pub EffectiveAffinity: _KAFFINITY_EX,
    #[doc = "offset: 0x168 (360)"]
    pub EffectivePerProcessUserTimeLimit: _LARGE_INTEGER,
    #[doc = "offset: 0x170 (368)"]
    pub EffectiveMinimumWorkingSetSize: ULONG,
    #[doc = "offset: 0x174 (372)"]
    pub EffectiveMaximumWorkingSetSize: ULONG,
    #[doc = "offset: 0x178 (376)"]
    pub EffectiveProcessMemoryLimit: ULONG,
    #[doc = "offset: 0x17c (380)"]
    pub EffectiveProcessMemoryLimitJob: *mut _EJOB,
    #[doc = "offset: 0x180 (384)"]
    pub EffectivePerProcessUserTimeLimitJob: *mut _EJOB,
    #[doc = "offset: 0x184 (388)"]
    pub EffectiveNetIoRateLimitJob: *mut _EJOB,
    #[doc = "offset: 0x188 (392)"]
    pub EffectiveHeapAttributionJob: *mut _EJOB,
    #[doc = "offset: 0x18c (396)"]
    pub EffectiveLimitFlags: ULONG,
    #[doc = "offset: 0x190 (400)"]
    pub EffectiveSchedulingClass: ULONG,
    #[doc = "offset: 0x194 (404)"]
    pub EffectiveFreezeCount: ULONG,
    #[doc = "offset: 0x198 (408)"]
    pub EffectiveBackgroundCount: ULONG,
    #[doc = "offset: 0x19c (412)"]
    pub EffectiveSwapCount: ULONG,
    #[doc = "offset: 0x1a0 (416)"]
    pub EffectiveNotificationLimitCount: ULONG,
    #[doc = "offset: 0x1a4 (420)"]
    pub EffectivePriorityClass: UCHAR,
    #[doc = "offset: 0x1a5 (421)"]
    pub PriorityClass: UCHAR,
    #[doc = "offset: 0x1a6 (422)"]
    pub NestingDepth: UCHAR,
    #[doc = "offset: 0x1a7 (423)"]
    pub Reserved1: [UCHAR; 1usize],
    #[doc = "offset: 0x1a8 (424)"]
    pub CompletionFilter: ULONG,
    pub __bindgen_anon_1: _EJOB__bindgen_ty_1,
    #[doc = "offset: 0x1f8 (504)"]
    pub WakeFilter: _JOBOBJECT_WAKE_FILTER,
    #[doc = "offset: 0x200 (512)"]
    pub LowEdgeLatchFilter: ULONG,
    #[doc = "offset: 0x204 (516)"]
    pub NotificationLink: *mut _EJOB,
    #[doc = "offset: 0x208 (520)"]
    pub CurrentJobMemoryUsed: ULONGLONG,
    #[doc = "offset: 0x210 (528)"]
    pub NotificationInfo: *mut _JOB_NOTIFICATION_INFORMATION,
    #[doc = "offset: 0x214 (532)"]
    pub NotificationInfoQuotaReference: *mut VOID,
    #[doc = "offset: 0x218 (536)"]
    pub NotificationPacket: *mut _IO_MINI_COMPLETION_PACKET_USER,
    #[doc = "offset: 0x21c (540)"]
    pub CpuRateControl: *mut _JOB_CPU_RATE_CONTROL,
    #[doc = "offset: 0x220 (544)"]
    pub EffectiveSchedulingGroup: *mut VOID,
    #[doc = "offset: 0x228 (552)"]
    pub ReadyTime: ULONGLONG,
    #[doc = "offset: 0x230 (560)"]
    pub MemoryLimitsLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x234 (564)"]
    pub SiblingJobLinks: _LIST_ENTRY,
    #[doc = "offset: 0x23c (572)"]
    pub ChildJobListHead: _LIST_ENTRY,
    #[doc = "offset: 0x244 (580)"]
    pub ParentJob: *mut _EJOB,
    #[doc = "offset: 0x248 (584)"]
    pub RootJob: *mut _EJOB,
    #[doc = "offset: 0x24c (588)"]
    pub IteratorListHead: _LIST_ENTRY,
    #[doc = "offset: 0x254 (596)"]
    pub AncestorCount: ULONG,
    pub __bindgen_anon_2: _EJOB__bindgen_ty_2,
    #[doc = "offset: 0x260 (608)"]
    pub Accounting: _EPROCESS_VALUES,
    #[doc = "offset: 0x2b8 (696)"]
    pub ShadowActiveProcessCount: ULONG,
    #[doc = "offset: 0x2bc (700)"]
    pub ActiveAuxiliaryProcessCount: ULONG,
    #[doc = "offset: 0x2c0 (704)"]
    pub SequenceNumber: ULONG,
    #[doc = "offset: 0x2c4 (708)"]
    pub JobId: ULONG,
    #[doc = "offset: 0x2c8 (712)"]
    pub ContainerId: _GUID,
    #[doc = "offset: 0x2d8 (728)"]
    pub ContainerTelemetryId: _GUID,
    #[doc = "offset: 0x2e8 (744)"]
    pub ServerSiloGlobals: *mut _ESERVERSILO_GLOBALS,
    #[doc = "offset: 0x2ec (748)"]
    pub PropertySet: _PS_PROPERTY_SET,
    #[doc = "offset: 0x2f8 (760)"]
    pub Storage: *mut _PSP_STORAGE,
    #[doc = "offset: 0x2fc (764)"]
    pub NetRateControl: *mut _JOB_NET_RATE_CONTROL,
    pub __bindgen_anon_3: _EJOB__bindgen_ty_3,
    pub __bindgen_anon_4: _EJOB__bindgen_ty_4,
    #[doc = "offset: 0x308 (776)"]
    pub EnergyValues: *mut _PROCESS_EXTENDED_ENERGY_VALUES,
    #[doc = "offset: 0x30c (780)"]
    pub SharedCommitCharge: ULONG,
    #[doc = "offset: 0x310 (784)"]
    pub DiskIoAttributionUserRefCount: ULONG,
    #[doc = "offset: 0x314 (788)"]
    pub DiskIoAttributionRefCount: ULONG,
    pub __bindgen_anon_5: _EJOB__bindgen_ty_5,
    #[doc = "offset: 0x31c (796)"]
    pub IoRateControlHeader: _JOB_RATE_CONTROL_HEADER,
    #[doc = "offset: 0x330 (816)"]
    pub GlobalIoControl: _PS_IO_CONTROL_ENTRY,
    #[doc = "offset: 0x34c (844)"]
    pub IoControlStateLock: LONG,
    #[doc = "offset: 0x350 (848)"]
    pub VolumeIoControlTree: _RTL_RB_TREE,
    #[doc = "offset: 0x358 (856)"]
    pub IoRateOverQuotaHistory: ULONGLONG,
    #[doc = "offset: 0x360 (864)"]
    pub IoRateCurrentGeneration: ULONG,
    #[doc = "offset: 0x364 (868)"]
    pub IoRateLastQueryGeneration: ULONG,
    #[doc = "offset: 0x368 (872)"]
    pub IoRateGenerationLength: ULONG,
    #[doc = "offset: 0x36c (876)"]
    pub IoRateOverQuotaNotifySequenceId: ULONG,
    #[doc = "offset: 0x370 (880)"]
    pub LastThrottledIoTime: ULONGLONG,
    #[doc = "offset: 0x378 (888)"]
    pub IoControlLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x37c (892)"]
    pub SiloHardReferenceCount: ULONG,
    #[doc = "offset: 0x380 (896)"]
    pub RundownWorkItem: _WORK_QUEUE_ITEM,
    #[doc = "offset: 0x390 (912)"]
    pub PartitionObject: *mut VOID,
    #[doc = "offset: 0x394 (916)"]
    pub PartitionOwnerJob: *mut _EJOB,
    #[doc = "offset: 0x398 (920)"]
    pub EnergyTrackingState: _JOBOBJECT_ENERGY_TRACKING_STATE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EJOB__bindgen_ty_1 {
    #[doc = "offset: 0x1b0 (432)"]
    pub WakeChannel: _WNF_STATE_NAME,
    #[doc = "offset: 0x1b0 (432)"]
    pub WakeInfo: _PS_JOB_WAKE_INFORMATION,
}
impl Default for _EJOB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EJOB__bindgen_ty_2 {
    #[doc = "offset: 0x258 (600)"]
    pub Ancestors: *mut *mut _EJOB,
    #[doc = "offset: 0x258 (600)"]
    pub SessionObject: *mut VOID,
}
impl Default for _EJOB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EJOB__bindgen_ty_3 {
    #[doc = "offset: 0x300 (768)"]
    pub JobFlags: ULONG,
    pub __bindgen_anon_1: _EJOB__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EJOB__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _EJOB__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn CloseDone(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CloseDone(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MultiGroup(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultiGroup(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OutstandingNotification(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OutstandingNotification(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NotificationInProgress(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NotificationInProgress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UILimits(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UILimits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CpuRateControlActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CpuRateControlActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnCpuRateControl(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnCpuRateControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Terminating(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Terminating(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WorkingSetLock(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WorkingSetLock(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn JobFrozen(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JobFrozen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Background(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Background(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeNotificationAllocated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeNotificationAllocated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeNotificationEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeNotificationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeNotificationPending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeNotificationPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitNotificationRequired(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LimitNotificationRequired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ZeroCountNotificationRequired(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ZeroCountNotificationRequired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CycleTimeNotificationRequired(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CycleTimeNotificationRequired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CycleTimeNotificationPending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CycleTimeNotificationPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TimersVirtualized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TimersVirtualized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn JobSwapped(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JobSwapped(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ViolationDetected(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ViolationDetected(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EmptyJobNotified(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EmptyJobNotified(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoSystemCharge(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoSystemCharge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DropNoWakeCharges(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DropNoWakeCharges(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoWakeChargePolicyDecided(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoWakeChargePolicyDecided(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NetRateControlActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NetRateControlActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnNetRateControl(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnNetRateControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoRateControlActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoRateControlActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnIoRateControl(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnIoRateControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowNewProcesses(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowNewProcesses(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Silo(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Silo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ContainerTelemetryIdSet(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContainerTelemetryIdSet(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CloseDone: ULONG,
        MultiGroup: ULONG,
        OutstandingNotification: ULONG,
        NotificationInProgress: ULONG,
        UILimits: ULONG,
        CpuRateControlActive: ULONG,
        OwnCpuRateControl: ULONG,
        Terminating: ULONG,
        WorkingSetLock: ULONG,
        JobFrozen: ULONG,
        Background: ULONG,
        WakeNotificationAllocated: ULONG,
        WakeNotificationEnabled: ULONG,
        WakeNotificationPending: ULONG,
        LimitNotificationRequired: ULONG,
        ZeroCountNotificationRequired: ULONG,
        CycleTimeNotificationRequired: ULONG,
        CycleTimeNotificationPending: ULONG,
        TimersVirtualized: ULONG,
        JobSwapped: ULONG,
        ViolationDetected: ULONG,
        EmptyJobNotified: ULONG,
        NoSystemCharge: ULONG,
        DropNoWakeCharges: ULONG,
        NoWakeChargePolicyDecided: ULONG,
        NetRateControlActive: ULONG,
        OwnNetRateControl: ULONG,
        IoRateControlActive: ULONG,
        OwnIoRateControl: ULONG,
        DisallowNewProcesses: ULONG,
        Silo: ULONG,
        ContainerTelemetryIdSet: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CloseDone: u32 = unsafe { ::std::mem::transmute(CloseDone) };
            CloseDone as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MultiGroup: u32 = unsafe { ::std::mem::transmute(MultiGroup) };
            MultiGroup as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OutstandingNotification: u32 =
                unsafe { ::std::mem::transmute(OutstandingNotification) };
            OutstandingNotification as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NotificationInProgress: u32 =
                unsafe { ::std::mem::transmute(NotificationInProgress) };
            NotificationInProgress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UILimits: u32 = unsafe { ::std::mem::transmute(UILimits) };
            UILimits as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CpuRateControlActive: u32 = unsafe { ::std::mem::transmute(CpuRateControlActive) };
            CpuRateControlActive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OwnCpuRateControl: u32 = unsafe { ::std::mem::transmute(OwnCpuRateControl) };
            OwnCpuRateControl as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Terminating: u32 = unsafe { ::std::mem::transmute(Terminating) };
            Terminating as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let WorkingSetLock: u32 = unsafe { ::std::mem::transmute(WorkingSetLock) };
            WorkingSetLock as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let JobFrozen: u32 = unsafe { ::std::mem::transmute(JobFrozen) };
            JobFrozen as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Background: u32 = unsafe { ::std::mem::transmute(Background) };
            Background as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WakeNotificationAllocated: u32 =
                unsafe { ::std::mem::transmute(WakeNotificationAllocated) };
            WakeNotificationAllocated as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WakeNotificationEnabled: u32 =
                unsafe { ::std::mem::transmute(WakeNotificationEnabled) };
            WakeNotificationEnabled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WakeNotificationPending: u32 =
                unsafe { ::std::mem::transmute(WakeNotificationPending) };
            WakeNotificationPending as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let LimitNotificationRequired: u32 =
                unsafe { ::std::mem::transmute(LimitNotificationRequired) };
            LimitNotificationRequired as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ZeroCountNotificationRequired: u32 =
                unsafe { ::std::mem::transmute(ZeroCountNotificationRequired) };
            ZeroCountNotificationRequired as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CycleTimeNotificationRequired: u32 =
                unsafe { ::std::mem::transmute(CycleTimeNotificationRequired) };
            CycleTimeNotificationRequired as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let CycleTimeNotificationPending: u32 =
                unsafe { ::std::mem::transmute(CycleTimeNotificationPending) };
            CycleTimeNotificationPending as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let TimersVirtualized: u32 = unsafe { ::std::mem::transmute(TimersVirtualized) };
            TimersVirtualized as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let JobSwapped: u32 = unsafe { ::std::mem::transmute(JobSwapped) };
            JobSwapped as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ViolationDetected: u32 = unsafe { ::std::mem::transmute(ViolationDetected) };
            ViolationDetected as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EmptyJobNotified: u32 = unsafe { ::std::mem::transmute(EmptyJobNotified) };
            EmptyJobNotified as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let NoSystemCharge: u32 = unsafe { ::std::mem::transmute(NoSystemCharge) };
            NoSystemCharge as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let DropNoWakeCharges: u32 = unsafe { ::std::mem::transmute(DropNoWakeCharges) };
            DropNoWakeCharges as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let NoWakeChargePolicyDecided: u32 =
                unsafe { ::std::mem::transmute(NoWakeChargePolicyDecided) };
            NoWakeChargePolicyDecided as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let NetRateControlActive: u32 = unsafe { ::std::mem::transmute(NetRateControlActive) };
            NetRateControlActive as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let OwnNetRateControl: u32 = unsafe { ::std::mem::transmute(OwnNetRateControl) };
            OwnNetRateControl as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let IoRateControlActive: u32 = unsafe { ::std::mem::transmute(IoRateControlActive) };
            IoRateControlActive as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let OwnIoRateControl: u32 = unsafe { ::std::mem::transmute(OwnIoRateControl) };
            OwnIoRateControl as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let DisallowNewProcesses: u32 = unsafe { ::std::mem::transmute(DisallowNewProcesses) };
            DisallowNewProcesses as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Silo: u32 = unsafe { ::std::mem::transmute(Silo) };
            Silo as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ContainerTelemetryIdSet: u32 =
                unsafe { ::std::mem::transmute(ContainerTelemetryIdSet) };
            ContainerTelemetryIdSet as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EJOB__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EJOB__bindgen_ty_4 {
    #[doc = "offset: 0x304 (772)"]
    pub JobFlags2: ULONG,
    pub __bindgen_anon_1: _EJOB__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EJOB__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _EJOB__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn ParentLocked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ParentLocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableUsermodeSiloThreadImpersonation(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableUsermodeSiloThreadImpersonation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowUsermodeSiloThreadImpersonation(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowUsermodeSiloThreadImpersonation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ParentLocked: ULONG,
        EnableUsermodeSiloThreadImpersonation: ULONG,
        DisallowUsermodeSiloThreadImpersonation: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ParentLocked: u32 = unsafe { ::std::mem::transmute(ParentLocked) };
            ParentLocked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableUsermodeSiloThreadImpersonation: u32 =
                unsafe { ::std::mem::transmute(EnableUsermodeSiloThreadImpersonation) };
            EnableUsermodeSiloThreadImpersonation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisallowUsermodeSiloThreadImpersonation: u32 =
                unsafe { ::std::mem::transmute(DisallowUsermodeSiloThreadImpersonation) };
            DisallowUsermodeSiloThreadImpersonation as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EJOB__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EJOB__bindgen_ty_5 {
    #[doc = "offset: 0x318 (792)"]
    pub DiskIoAttributionContext: *mut VOID,
    #[doc = "offset: 0x318 (792)"]
    pub DiskIoAttributionOwnerJob: *mut _EJOB,
}
impl Default for _EJOB__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EJOB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xc8 (200) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _THREAD_ENERGY_VALUES {
    #[doc = "offset: 0x0 (0)"]
    pub Cycles: [[ULONGLONG; 2usize]; 4usize],
    #[doc = "offset: 0x40 (64)"]
    pub AttributedCycles: [[ULONGLONG; 2usize]; 4usize],
    #[doc = "offset: 0x80 (128)"]
    pub WorkOnBehalfCycles: [[ULONGLONG; 2usize]; 4usize],
    #[doc = "offset: 0xc0 (192)"]
    pub CpuTimeline: _TIMELINE_BITMAP,
}
impl Default for _THREAD_ENERGY_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4940 (18752) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPRCB {
    #[doc = "offset: 0x0 (0)"]
    pub MinorVersion: USHORT,
    #[doc = "offset: 0x2 (2)"]
    pub MajorVersion: USHORT,
    #[doc = "offset: 0x4 (4)"]
    pub CurrentThread: *mut _KTHREAD,
    #[doc = "offset: 0x8 (8)"]
    pub NextThread: *mut _KTHREAD,
    #[doc = "offset: 0xc (12)"]
    pub IdleThread: *mut _KTHREAD,
    #[doc = "offset: 0x10 (16)"]
    pub LegacyNumber: UCHAR,
    #[doc = "offset: 0x11 (17)"]
    pub NestingLevel: UCHAR,
    #[doc = "offset: 0x12 (18)"]
    pub BuildType: USHORT,
    #[doc = "offset: 0x14 (20)"]
    pub CpuType: CHAR,
    #[doc = "offset: 0x15 (21)"]
    pub CpuID: CHAR,
    pub __bindgen_anon_1: _KPRCB__bindgen_ty_1,
    #[doc = "offset: 0x18 (24)"]
    pub ProcessorState: _KPROCESSOR_STATE,
    #[doc = "offset: 0x338 (824)"]
    pub ParentNode: *mut _KNODE,
    #[doc = "offset: 0x33c (828)"]
    pub PriorityState: *mut CHAR,
    #[doc = "offset: 0x340 (832)"]
    pub KernelReserved: [ULONG; 14usize],
    #[doc = "offset: 0x378 (888)"]
    pub HalReserved: [ULONG; 16usize],
    #[doc = "offset: 0x3b8 (952)"]
    pub CFlushSize: ULONG,
    #[doc = "offset: 0x3bc (956)"]
    pub CoresPerPhysicalProcessor: UCHAR,
    #[doc = "offset: 0x3bd (957)"]
    pub LogicalProcessorsPerCore: UCHAR,
    #[doc = "offset: 0x3be (958)"]
    pub CpuVendor: UCHAR,
    #[doc = "offset: 0x3bf (959)"]
    pub PrcbPad0: [UCHAR; 1usize],
    #[doc = "offset: 0x3c0 (960)"]
    pub MHz: ULONG,
    #[doc = "offset: 0x3c4 (964)"]
    pub GroupIndex: UCHAR,
    #[doc = "offset: 0x3c5 (965)"]
    pub Group: UCHAR,
    #[doc = "offset: 0x3c6 (966)"]
    pub PrcbPad05: [UCHAR; 2usize],
    #[doc = "offset: 0x3c8 (968)"]
    pub GroupSetMember: ULONG,
    #[doc = "offset: 0x3cc (972)"]
    pub Number: ULONG,
    #[doc = "offset: 0x3d0 (976)"]
    pub ClockOwner: UCHAR,
    pub __bindgen_anon_2: _KPRCB__bindgen_ty_2,
    #[doc = "offset: 0x3d2 (978)"]
    pub PrcbPad10: [UCHAR; 70usize],
    #[doc = "offset: 0x418 (1048)"]
    pub LockQueue: [_KSPIN_LOCK_QUEUE; 17usize],
    #[doc = "offset: 0x4a0 (1184)"]
    pub InterruptCount: ULONG,
    #[doc = "offset: 0x4a4 (1188)"]
    pub KernelTime: ULONG,
    #[doc = "offset: 0x4a8 (1192)"]
    pub UserTime: ULONG,
    #[doc = "offset: 0x4ac (1196)"]
    pub DpcTime: ULONG,
    #[doc = "offset: 0x4b0 (1200)"]
    pub DpcTimeCount: ULONG,
    #[doc = "offset: 0x4b4 (1204)"]
    pub InterruptTime: ULONG,
    #[doc = "offset: 0x4b8 (1208)"]
    pub AdjustDpcThreshold: ULONG,
    #[doc = "offset: 0x4bc (1212)"]
    pub PageColor: ULONG,
    #[doc = "offset: 0x4c0 (1216)"]
    pub DebuggerSavedIRQL: UCHAR,
    #[doc = "offset: 0x4c1 (1217)"]
    pub NodeColor: UCHAR,
    #[doc = "offset: 0x4c2 (1218)"]
    pub DeepSleep: UCHAR,
    #[doc = "offset: 0x4c3 (1219)"]
    pub PrcbPad20: UCHAR,
    #[doc = "offset: 0x4c4 (1220)"]
    pub CachedStack: *mut VOID,
    #[doc = "offset: 0x4c8 (1224)"]
    pub NodeShiftedColor: ULONG,
    #[doc = "offset: 0x4cc (1228)"]
    pub SecondaryColorMask: ULONG,
    #[doc = "offset: 0x4d0 (1232)"]
    pub DpcTimeLimit: ULONG,
    #[doc = "offset: 0x4d4 (1236)"]
    pub PrcbPad21: [ULONG; 2usize],
    #[doc = "offset: 0x4dc (1244)"]
    pub SchedulerAssist: *mut VOID,
    #[doc = "offset: 0x4e0 (1248)"]
    pub CcFastReadNoWait: ULONG,
    #[doc = "offset: 0x4e4 (1252)"]
    pub CcFastReadWait: ULONG,
    #[doc = "offset: 0x4e8 (1256)"]
    pub CcFastReadNotPossible: ULONG,
    #[doc = "offset: 0x4ec (1260)"]
    pub CcCopyReadNoWait: ULONG,
    #[doc = "offset: 0x4f0 (1264)"]
    pub CcCopyReadWait: ULONG,
    #[doc = "offset: 0x4f4 (1268)"]
    pub CcCopyReadNoWaitMiss: ULONG,
    #[doc = "offset: 0x4f8 (1272)"]
    pub MmSpinLockOrdering: LONG,
    #[doc = "offset: 0x4fc (1276)"]
    pub IoReadOperationCount: LONG,
    #[doc = "offset: 0x500 (1280)"]
    pub IoWriteOperationCount: LONG,
    #[doc = "offset: 0x504 (1284)"]
    pub IoOtherOperationCount: LONG,
    #[doc = "offset: 0x508 (1288)"]
    pub IoReadTransferCount: _LARGE_INTEGER,
    #[doc = "offset: 0x510 (1296)"]
    pub IoWriteTransferCount: _LARGE_INTEGER,
    #[doc = "offset: 0x518 (1304)"]
    pub IoOtherTransferCount: _LARGE_INTEGER,
    #[doc = "offset: 0x520 (1312)"]
    pub CcFastMdlReadNoWait: ULONG,
    #[doc = "offset: 0x524 (1316)"]
    pub CcFastMdlReadWait: ULONG,
    #[doc = "offset: 0x528 (1320)"]
    pub CcFastMdlReadNotPossible: ULONG,
    #[doc = "offset: 0x52c (1324)"]
    pub CcMapDataNoWait: ULONG,
    #[doc = "offset: 0x530 (1328)"]
    pub CcMapDataWait: ULONG,
    #[doc = "offset: 0x534 (1332)"]
    pub CcPinMappedDataCount: ULONG,
    #[doc = "offset: 0x538 (1336)"]
    pub CcPinReadNoWait: ULONG,
    #[doc = "offset: 0x53c (1340)"]
    pub CcPinReadWait: ULONG,
    #[doc = "offset: 0x540 (1344)"]
    pub CcMdlReadNoWait: ULONG,
    #[doc = "offset: 0x544 (1348)"]
    pub CcMdlReadWait: ULONG,
    #[doc = "offset: 0x548 (1352)"]
    pub CcLazyWriteHotSpots: ULONG,
    #[doc = "offset: 0x54c (1356)"]
    pub CcLazyWriteIos: ULONG,
    #[doc = "offset: 0x550 (1360)"]
    pub CcLazyWritePages: ULONG,
    #[doc = "offset: 0x554 (1364)"]
    pub CcDataFlushes: ULONG,
    #[doc = "offset: 0x558 (1368)"]
    pub CcDataPages: ULONG,
    #[doc = "offset: 0x55c (1372)"]
    pub CcLostDelayedWrites: ULONG,
    #[doc = "offset: 0x560 (1376)"]
    pub CcFastReadResourceMiss: ULONG,
    #[doc = "offset: 0x564 (1380)"]
    pub CcCopyReadWaitMiss: ULONG,
    #[doc = "offset: 0x568 (1384)"]
    pub CcFastMdlReadResourceMiss: ULONG,
    #[doc = "offset: 0x56c (1388)"]
    pub CcMapDataNoWaitMiss: ULONG,
    #[doc = "offset: 0x570 (1392)"]
    pub CcMapDataWaitMiss: ULONG,
    #[doc = "offset: 0x574 (1396)"]
    pub CcPinReadNoWaitMiss: ULONG,
    #[doc = "offset: 0x578 (1400)"]
    pub CcPinReadWaitMiss: ULONG,
    #[doc = "offset: 0x57c (1404)"]
    pub CcMdlReadNoWaitMiss: ULONG,
    #[doc = "offset: 0x580 (1408)"]
    pub CcMdlReadWaitMiss: ULONG,
    #[doc = "offset: 0x584 (1412)"]
    pub CcReadAheadIos: ULONG,
    #[doc = "offset: 0x588 (1416)"]
    pub KeAlignmentFixupCount: ULONG,
    #[doc = "offset: 0x58c (1420)"]
    pub KeExceptionDispatchCount: ULONG,
    #[doc = "offset: 0x590 (1424)"]
    pub KeSystemCalls: ULONG,
    #[doc = "offset: 0x594 (1428)"]
    pub AvailableTime: ULONG,
    #[doc = "offset: 0x598 (1432)"]
    pub PrcbPad22: [ULONG; 2usize],
    #[doc = "offset: 0x5a0 (1440)"]
    pub PPLookasideList: [_PP_LOOKASIDE_LIST; 16usize],
    #[doc = "offset: 0x620 (1568)"]
    pub PPNxPagedLookasideList: [_GENERAL_LOOKASIDE_POOL; 32usize],
    #[doc = "offset: 0xf20 (3872)"]
    pub PPNPagedLookasideList: [_GENERAL_LOOKASIDE_POOL; 32usize],
    #[doc = "offset: 0x1820 (6176)"]
    pub PPPagedLookasideList: [_GENERAL_LOOKASIDE_POOL; 32usize],
    #[doc = "offset: 0x2120 (8480)"]
    pub PacketBarrier: LONG,
    #[doc = "offset: 0x2124 (8484)"]
    pub ReverseStall: LONG,
    #[doc = "offset: 0x2128 (8488)"]
    pub IpiFrame: *mut VOID,
    #[doc = "offset: 0x212c (8492)"]
    pub PrcbPad3: [UCHAR; 52usize],
    #[doc = "offset: 0x2160 (8544)"]
    pub CurrentPacket: [*mut VOID; 3usize],
    #[doc = "offset: 0x216c (8556)"]
    pub TargetSet: ULONG,
    pub volatileWorkerRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut VOID, arg4: *mut VOID),
    >,
    #[doc = "offset: 0x2174 (8564)"]
    pub IpiFrozen: ULONG,
    #[doc = "offset: 0x2178 (8568)"]
    pub PrcbPad4: [UCHAR; 40usize],
    #[doc = "offset: 0x21a0 (8608)"]
    pub RequestSummary: ULONG,
    #[doc = "offset: 0x21a4 (8612)"]
    pub TargetCount: LONG,
    #[doc = "offset: 0x21a8 (8616)"]
    pub LastNonHrTimerExpiration: ULONGLONG,
    #[doc = "offset: 0x21b0 (8624)"]
    pub PrcbPad50: [UCHAR; 32usize],
    #[doc = "offset: 0x21d0 (8656)"]
    pub InterruptLastCount: ULONG,
    #[doc = "offset: 0x21d4 (8660)"]
    pub InterruptRate: ULONG,
    #[doc = "offset: 0x21d8 (8664)"]
    pub DeviceInterrupts: ULONG,
    #[doc = "offset: 0x21dc (8668)"]
    pub IsrDpcStats: *mut VOID,
    #[doc = "offset: 0x21e0 (8672)"]
    pub DpcData: [_KDPC_DATA; 2usize],
    #[doc = "offset: 0x2210 (8720)"]
    pub DpcStack: *mut VOID,
    #[doc = "offset: 0x2214 (8724)"]
    pub MaximumDpcQueueDepth: LONG,
    #[doc = "offset: 0x2218 (8728)"]
    pub DpcRequestRate: ULONG,
    #[doc = "offset: 0x221c (8732)"]
    pub MinimumDpcRate: ULONG,
    #[doc = "offset: 0x2220 (8736)"]
    pub DpcLastCount: ULONG,
    #[doc = "offset: 0x2224 (8740)"]
    pub PrcbLock: ULONG,
    #[doc = "offset: 0x2228 (8744)"]
    pub DpcGate: _KGATE,
    #[doc = "offset: 0x2238 (8760)"]
    pub IdleState: UCHAR,
    #[doc = "offset: 0x2239 (8761)"]
    pub QuantumEnd: UCHAR,
    #[doc = "offset: 0x223a (8762)"]
    pub DpcRoutineActive: UCHAR,
    #[doc = "offset: 0x223b (8763)"]
    pub IdleSchedule: UCHAR,
    pub __bindgen_anon_3: _KPRCB__bindgen_ty_3,
    #[doc = "offset: 0x2240 (8768)"]
    pub LastTimerHand: ULONG,
    #[doc = "offset: 0x2244 (8772)"]
    pub LastTick: ULONG,
    #[doc = "offset: 0x2248 (8776)"]
    pub PeriodicCount: ULONG,
    #[doc = "offset: 0x224c (8780)"]
    pub PeriodicBias: ULONG,
    #[doc = "offset: 0x2250 (8784)"]
    pub ClockInterrupts: ULONG,
    #[doc = "offset: 0x2254 (8788)"]
    pub ReadyScanTick: ULONG,
    #[doc = "offset: 0x2258 (8792)"]
    pub GroupSchedulingOverQuota: UCHAR,
    #[doc = "offset: 0x2259 (8793)"]
    pub ThreadDpcEnable: UCHAR,
    #[doc = "offset: 0x225a (8794)"]
    pub PrcbPad41: [UCHAR; 2usize],
    #[doc = "offset: 0x2260 (8800)"]
    pub TimerTable: _KTIMER_TABLE,
    #[doc = "offset: 0x3aa0 (15008)"]
    pub CallDpc: _KDPC,
    #[doc = "offset: 0x3ac0 (15040)"]
    pub ClockKeepAlive: LONG,
    #[doc = "offset: 0x3ac4 (15044)"]
    pub PrcbPad6: [UCHAR; 4usize],
    #[doc = "offset: 0x3ac8 (15048)"]
    pub DpcWatchdogPeriod: LONG,
    #[doc = "offset: 0x3acc (15052)"]
    pub DpcWatchdogCount: LONG,
    #[doc = "offset: 0x3ad0 (15056)"]
    pub KeSpinLockOrdering: LONG,
    #[doc = "offset: 0x3ad4 (15060)"]
    pub DpcWatchdogProfileCumulativeDpcThreshold: ULONG,
    #[doc = "offset: 0x3ad8 (15064)"]
    pub QueueIndex: ULONG,
    #[doc = "offset: 0x3adc (15068)"]
    pub DeferredReadyListHead: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x3ae0 (15072)"]
    pub ReadySummary: ULONG,
    #[doc = "offset: 0x3ae4 (15076)"]
    pub AffinitizedSelectionMask: LONG,
    #[doc = "offset: 0x3ae8 (15080)"]
    pub WaitLock: ULONG,
    #[doc = "offset: 0x3aec (15084)"]
    pub WaitListHead: _LIST_ENTRY,
    #[doc = "offset: 0x3af4 (15092)"]
    pub ScbOffset: ULONG,
    #[doc = "offset: 0x3af8 (15096)"]
    pub ReadyThreadCount: ULONG,
    #[doc = "offset: 0x3b00 (15104)"]
    pub StartCycles: ULONGLONG,
    #[doc = "offset: 0x3b08 (15112)"]
    pub TaggedCyclesStart: ULONGLONG,
    #[doc = "offset: 0x3b10 (15120)"]
    pub TaggedCycles: [ULONGLONG; 2usize],
    #[doc = "offset: 0x3b20 (15136)"]
    pub GenerationTarget: ULONGLONG,
    #[doc = "offset: 0x3b28 (15144)"]
    pub CycleTime: ULONGLONG,
    #[doc = "offset: 0x3b30 (15152)"]
    pub AffinitizedCycles: ULONGLONG,
    #[doc = "offset: 0x3b38 (15160)"]
    pub ImportantCycles: ULONGLONG,
    #[doc = "offset: 0x3b40 (15168)"]
    pub UnimportantCycles: ULONGLONG,
    #[doc = "offset: 0x3b48 (15176)"]
    pub ReadyQueueExpectedRunTime: ULONGLONG,
    #[doc = "offset: 0x3b50 (15184)"]
    pub HighCycleTime: ULONG,
    #[doc = "offset: 0x3b58 (15192)"]
    pub Cycles: [[ULONGLONG; 2usize]; 4usize],
    #[doc = "offset: 0x3b98 (15256)"]
    pub PrcbPad71: [ULONG; 2usize],
    #[doc = "offset: 0x3ba0 (15264)"]
    pub DispatcherReadyListHead: [_LIST_ENTRY; 32usize],
    #[doc = "offset: 0x3ca0 (15520)"]
    pub ChainedInterruptList: *mut VOID,
    #[doc = "offset: 0x3ca4 (15524)"]
    pub LookasideIrpFloat: LONG,
    #[doc = "offset: 0x3ca8 (15528)"]
    pub ScbQueue: _RTL_RB_TREE,
    #[doc = "offset: 0x3cb0 (15536)"]
    pub ScbList: _LIST_ENTRY,
    #[doc = "offset: 0x3cb8 (15544)"]
    pub MmPageFaultCount: LONG,
    #[doc = "offset: 0x3cbc (15548)"]
    pub MmCopyOnWriteCount: LONG,
    #[doc = "offset: 0x3cc0 (15552)"]
    pub MmTransitionCount: LONG,
    #[doc = "offset: 0x3cc4 (15556)"]
    pub MmCacheTransitionCount: LONG,
    #[doc = "offset: 0x3cc8 (15560)"]
    pub MmDemandZeroCount: LONG,
    #[doc = "offset: 0x3ccc (15564)"]
    pub MmPageReadCount: LONG,
    #[doc = "offset: 0x3cd0 (15568)"]
    pub MmPageReadIoCount: LONG,
    #[doc = "offset: 0x3cd4 (15572)"]
    pub MmCacheReadCount: LONG,
    #[doc = "offset: 0x3cd8 (15576)"]
    pub MmCacheIoCount: LONG,
    #[doc = "offset: 0x3cdc (15580)"]
    pub MmDirtyPagesWriteCount: LONG,
    #[doc = "offset: 0x3ce0 (15584)"]
    pub MmDirtyWriteIoCount: LONG,
    #[doc = "offset: 0x3ce4 (15588)"]
    pub MmMappedPagesWriteCount: LONG,
    #[doc = "offset: 0x3ce8 (15592)"]
    pub MmMappedWriteIoCount: LONG,
    #[doc = "offset: 0x3cec (15596)"]
    pub CachedCommit: ULONG,
    #[doc = "offset: 0x3cf0 (15600)"]
    pub CachedResidentAvailable: ULONG,
    #[doc = "offset: 0x3cf4 (15604)"]
    pub HyperPte: *mut VOID,
    #[doc = "offset: 0x3cf8 (15608)"]
    pub PrcbPad8: [UCHAR; 4usize],
    #[doc = "offset: 0x3cfc (15612)"]
    pub VendorString: [UCHAR; 13usize],
    #[doc = "offset: 0x3d09 (15625)"]
    pub InitialApicId: UCHAR,
    #[doc = "offset: 0x3d0a (15626)"]
    pub LogicalProcessorsPerPhysicalProcessor: UCHAR,
    #[doc = "offset: 0x3d0b (15627)"]
    pub PrcbPad9: [UCHAR; 1usize],
    #[doc = "offset: 0x3d10 (15632)"]
    pub FeatureBits: ULONGLONG,
    #[doc = "offset: 0x3d18 (15640)"]
    pub UpdateSignature: _LARGE_INTEGER,
    #[doc = "offset: 0x3d20 (15648)"]
    pub IsrTime: ULONGLONG,
    #[doc = "offset: 0x3d28 (15656)"]
    pub PrcbPad90: [ULONG; 2usize],
    #[doc = "offset: 0x3d30 (15664)"]
    pub PowerState: _PROCESSOR_POWER_STATE,
    #[doc = "offset: 0x3ed8 (16088)"]
    pub ForceIdleDpc: _KDPC,
    #[doc = "offset: 0x3ef8 (16120)"]
    pub PrcbPad91: [ULONG; 14usize],
    #[doc = "offset: 0x3f30 (16176)"]
    pub DpcWatchdogProfileSingleDpcThreshold: ULONG,
    #[doc = "offset: 0x3f34 (16180)"]
    pub DpcWatchdogDpc: _KDPC,
    #[doc = "offset: 0x3f58 (16216)"]
    pub DpcWatchdogTimer: _KTIMER,
    #[doc = "offset: 0x3f80 (16256)"]
    pub HypercallPageList: _SLIST_HEADER,
    #[doc = "offset: 0x3f88 (16264)"]
    pub HypercallCachedPages: *mut VOID,
    #[doc = "offset: 0x3f8c (16268)"]
    pub VirtualApicAssist: *mut VOID,
    #[doc = "offset: 0x3f90 (16272)"]
    pub StatisticsPage: *mut ULONGLONG,
    #[doc = "offset: 0x3f94 (16276)"]
    pub Cache: [_CACHE_DESCRIPTOR; 5usize],
    #[doc = "offset: 0x3fd0 (16336)"]
    pub CacheCount: ULONG,
    #[doc = "offset: 0x3fd4 (16340)"]
    pub PackageProcessorSet: _KAFFINITY_EX,
    #[doc = "offset: 0x3fe0 (16352)"]
    pub SharedReadyQueueMask: ULONG,
    #[doc = "offset: 0x3fe4 (16356)"]
    pub SharedReadyQueue: *mut _KSHARED_READY_QUEUE,
    #[doc = "offset: 0x3fe8 (16360)"]
    pub SharedQueueScanOwner: ULONG,
    #[doc = "offset: 0x3fec (16364)"]
    pub CoreProcessorSet: ULONG,
    #[doc = "offset: 0x3ff0 (16368)"]
    pub ScanSiblingMask: ULONG,
    #[doc = "offset: 0x3ff4 (16372)"]
    pub LLCMask: ULONG,
    #[doc = "offset: 0x3ff8 (16376)"]
    pub CacheProcessorMask: [ULONG; 5usize],
    #[doc = "offset: 0x400c (16396)"]
    pub ScanSiblingIndex: ULONG,
    #[doc = "offset: 0x4010 (16400)"]
    pub WheaInfo: *mut VOID,
    #[doc = "offset: 0x4014 (16404)"]
    pub EtwSupport: *mut VOID,
    #[doc = "offset: 0x4018 (16408)"]
    pub InterruptObjectPool: _SLIST_HEADER,
    #[doc = "offset: 0x4020 (16416)"]
    pub DpcWatchdogProfile: *mut *mut VOID,
    #[doc = "offset: 0x4024 (16420)"]
    pub DpcWatchdogProfileCurrentEmptyCapture: *mut *mut VOID,
    #[doc = "offset: 0x4028 (16424)"]
    pub PrcbPad92: [ULONG; 1usize],
    #[doc = "offset: 0x402c (16428)"]
    pub PteBitCache: ULONG,
    #[doc = "offset: 0x4030 (16432)"]
    pub PteBitOffset: ULONG,
    #[doc = "offset: 0x4034 (16436)"]
    pub PrcbPad93: ULONG,
    #[doc = "offset: 0x4038 (16440)"]
    pub ProcessorProfileControlArea: *mut _PROCESSOR_PROFILE_CONTROL_AREA,
    #[doc = "offset: 0x403c (16444)"]
    pub ProfileEventIndexAddress: *mut VOID,
    #[doc = "offset: 0x4040 (16448)"]
    pub TimerExpirationDpc: _KDPC,
    #[doc = "offset: 0x4060 (16480)"]
    pub SynchCounters: _SYNCH_COUNTERS,
    #[doc = "offset: 0x4118 (16664)"]
    pub FsCounters: _FILESYSTEM_DISK_COUNTERS,
    #[doc = "offset: 0x4128 (16680)"]
    pub Context: *mut _CONTEXT,
    #[doc = "offset: 0x412c (16684)"]
    pub ContextFlagsInit: ULONG,
    #[doc = "offset: 0x4130 (16688)"]
    pub ExtendedState: *mut _XSAVE_AREA,
    #[doc = "offset: 0x4134 (16692)"]
    pub EntropyTimingState: _KENTROPY_TIMING_STATE,
    #[doc = "offset: 0x425c (16988)"]
    pub IsrStack: *mut VOID,
    #[doc = "offset: 0x4260 (16992)"]
    pub VectorToInterruptObject: [*mut _KINTERRUPT; 208usize],
    #[doc = "offset: 0x45a0 (17824)"]
    pub AbSelfIoBoostsList: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x45a4 (17828)"]
    pub AbPropagateBoostsList: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x45a8 (17832)"]
    pub AbDpc: _KDPC,
    #[doc = "offset: 0x45c8 (17864)"]
    pub IoIrpStackProfilerCurrent: _IOP_IRP_STACK_PROFILER,
    #[doc = "offset: 0x461c (17948)"]
    pub IoIrpStackProfilerPrevious: _IOP_IRP_STACK_PROFILER,
    #[doc = "offset: 0x4670 (18032)"]
    pub TimerExpirationTrace: [_KTIMER_EXPIRATION_TRACE; 16usize],
    #[doc = "offset: 0x4770 (18288)"]
    pub TimerExpirationTraceCount: ULONG,
    #[doc = "offset: 0x4774 (18292)"]
    pub ExSaPageArray: *mut VOID,
    #[doc = "offset: 0x4778 (18296)"]
    pub PrcbPad100: [ULONG; 10usize],
    #[doc = "offset: 0x47a0 (18336)"]
    pub LocalSharedReadyQueue: _KSHARED_READY_QUEUE,
    #[doc = "offset: 0x48e0 (18656)"]
    pub Mailbox: *mut _REQUEST_MAILBOX,
    #[doc = "offset: 0x48e4 (18660)"]
    pub PrcbPad: [UCHAR; 60usize],
    #[doc = "offset: 0x4920 (18720)"]
    pub RequestMailbox: [_REQUEST_MAILBOX; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPRCB__bindgen_ty_1 {
    #[doc = "offset: 0x16 (22)"]
    pub CpuStep: USHORT,
    pub __bindgen_anon_1: _KPRCB__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KPRCB__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x16 (22)"]
    pub CpuStepping: UCHAR,
    #[doc = "offset: 0x17 (23)"]
    pub CpuModel: UCHAR,
}
impl Default for _KPRCB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPRCB__bindgen_ty_2 {
    #[doc = "offset: 0x3d1 (977)"]
    pub PendingTickFlags: UCHAR,
    pub __bindgen_anon_1: _KPRCB__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KPRCB__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KPRCB__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn PendingTick(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PendingTick(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PendingBackupTick(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PendingBackupTick(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PendingTick: UCHAR,
        PendingBackupTick: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PendingTick: u8 = unsafe { ::std::mem::transmute(PendingTick) };
            PendingTick as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PendingBackupTick: u8 = unsafe { ::std::mem::transmute(PendingBackupTick) };
            PendingBackupTick as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KPRCB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPRCB__bindgen_ty_3 {
    #[doc = "offset: 0x223c (8764)"]
    pub DpcRequestSummary: LONG,
    #[doc = "offset: 0x223c (8764)"]
    pub DpcRequestSlot: [SHORT; 2usize],
    pub __bindgen_anon_1: _KPRCB__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2: _KPRCB__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KPRCB__bindgen_ty_3__bindgen_ty_1 {
    #[doc = "offset: 0x223c (8764)"]
    pub NormalDpcState: SHORT,
    #[doc = "offset: 0x223e (8766)"]
    pub ThreadDpcState: SHORT,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KPRCB__bindgen_ty_3__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KPRCB__bindgen_ty_3__bindgen_ty_2 {
    #[inline]
    pub fn DpcNormalProcessingActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcNormalProcessingActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcNormalProcessingRequested(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcNormalProcessingRequested(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcNormalThreadSignal(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcNormalThreadSignal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcNormalTimerExpiration(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcNormalTimerExpiration(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcNormalDpcPresent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcNormalDpcPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcNormalLocalInterrupt(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcNormalLocalInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcNormalSpare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_DpcNormalSpare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcThreadActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcThreadActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcThreadRequested(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DpcThreadRequested(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DpcThreadSpare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_DpcThreadSpare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DpcNormalProcessingActive: ULONG,
        DpcNormalProcessingRequested: ULONG,
        DpcNormalThreadSignal: ULONG,
        DpcNormalTimerExpiration: ULONG,
        DpcNormalDpcPresent: ULONG,
        DpcNormalLocalInterrupt: ULONG,
        DpcNormalSpare: ULONG,
        DpcThreadActive: ULONG,
        DpcThreadRequested: ULONG,
        DpcThreadSpare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DpcNormalProcessingActive: u32 =
                unsafe { ::std::mem::transmute(DpcNormalProcessingActive) };
            DpcNormalProcessingActive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DpcNormalProcessingRequested: u32 =
                unsafe { ::std::mem::transmute(DpcNormalProcessingRequested) };
            DpcNormalProcessingRequested as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DpcNormalThreadSignal: u32 =
                unsafe { ::std::mem::transmute(DpcNormalThreadSignal) };
            DpcNormalThreadSignal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DpcNormalTimerExpiration: u32 =
                unsafe { ::std::mem::transmute(DpcNormalTimerExpiration) };
            DpcNormalTimerExpiration as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DpcNormalDpcPresent: u32 = unsafe { ::std::mem::transmute(DpcNormalDpcPresent) };
            DpcNormalDpcPresent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DpcNormalLocalInterrupt: u32 =
                unsafe { ::std::mem::transmute(DpcNormalLocalInterrupt) };
            DpcNormalLocalInterrupt as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let DpcNormalSpare: u32 = unsafe { ::std::mem::transmute(DpcNormalSpare) };
            DpcNormalSpare as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DpcThreadActive: u32 = unsafe { ::std::mem::transmute(DpcThreadActive) };
            DpcThreadActive as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DpcThreadRequested: u32 = unsafe { ::std::mem::transmute(DpcThreadRequested) };
            DpcThreadRequested as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let DpcThreadSpare: u32 = unsafe { ::std::mem::transmute(DpcThreadSpare) };
            DpcThreadSpare as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KPRCB__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPRCB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x350 (848) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD {
    #[doc = "offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = "offset: 0x10 (16)"]
    pub SListFaultAddress: *mut VOID,
    #[doc = "offset: 0x18 (24)"]
    pub QuantumTarget: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub InitialStack: *mut VOID,
    #[doc = "offset: 0x24 (36)"]
    pub StackLimit: *mut VOID,
    #[doc = "offset: 0x28 (40)"]
    pub StackBase: *mut VOID,
    #[doc = "offset: 0x2c (44)"]
    pub ThreadLock: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub CycleTime: ULONGLONG,
    #[doc = "offset: 0x38 (56)"]
    pub HighCycleTime: ULONG,
    #[doc = "offset: 0x3c (60)"]
    pub ServiceTable: *mut VOID,
    #[doc = "offset: 0x40 (64)"]
    pub CurrentRunTime: ULONG,
    #[doc = "offset: 0x44 (68)"]
    pub ExpectedRunTime: ULONG,
    #[doc = "offset: 0x48 (72)"]
    pub KernelStack: *mut VOID,
    #[doc = "offset: 0x4c (76)"]
    pub StateSaveArea: *mut _XSAVE_FORMAT,
    #[doc = "offset: 0x50 (80)"]
    pub SchedulingGroup: *mut _KSCHEDULING_GROUP,
    #[doc = "offset: 0x54 (84)"]
    pub WaitRegister: _KWAIT_STATUS_REGISTER,
    #[doc = "offset: 0x55 (85)"]
    pub Running: UCHAR,
    #[doc = "offset: 0x56 (86)"]
    pub Alerted: [UCHAR; 2usize],
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_1,
    pub __bindgen_anon_2: _KTHREAD__bindgen_ty_2,
    #[doc = "offset: 0x60 (96)"]
    pub Tag: UCHAR,
    #[doc = "offset: 0x61 (97)"]
    pub SystemHeteroCpuPolicy: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "offset: 0x63 (99)"]
    pub Spare0: UCHAR,
    #[doc = "offset: 0x64 (100)"]
    pub SystemCallNumber: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub FirstArgument: *mut VOID,
    #[doc = "offset: 0x6c (108)"]
    pub TrapFrame: *mut _KTRAP_FRAME,
    pub __bindgen_anon_3: _KTHREAD__bindgen_ty_3,
    #[doc = "offset: 0x88 (136)"]
    pub UserIdealProcessor: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub ContextSwitches: ULONG,
    #[doc = "offset: 0x90 (144)"]
    pub State: UCHAR,
    #[doc = "offset: 0x91 (145)"]
    pub Spare12: CHAR,
    #[doc = "offset: 0x92 (146)"]
    pub WaitIrql: UCHAR,
    #[doc = "offset: 0x93 (147)"]
    pub WaitMode: CHAR,
    #[doc = "offset: 0x94 (148)"]
    pub WaitStatus: LONG,
    #[doc = "offset: 0x98 (152)"]
    pub WaitBlockList: *mut _KWAIT_BLOCK,
    pub __bindgen_anon_4: _KTHREAD__bindgen_ty_4,
    #[doc = "offset: 0xa4 (164)"]
    pub Queue: *mut _DISPATCHER_HEADER,
    #[doc = "offset: 0xa8 (168)"]
    pub Teb: *mut VOID,
    #[doc = "offset: 0xb0 (176)"]
    pub RelativeTimerBias: ULONGLONG,
    #[doc = "offset: 0xb8 (184)"]
    pub Timer: _KTIMER,
    pub __bindgen_anon_5: _KTHREAD__bindgen_ty_5,
    #[doc = "offset: 0x140 (320)"]
    pub QueueListEntry: _LIST_ENTRY,
    pub __bindgen_anon_6: _KTHREAD__bindgen_ty_6,
    #[doc = "offset: 0x14c (332)"]
    pub QueuePriority: LONG,
    #[doc = "offset: 0x150 (336)"]
    pub Process: *mut _KPROCESS,
    pub __bindgen_anon_7: _KTHREAD__bindgen_ty_7,
    #[doc = "offset: 0x160 (352)"]
    pub AffinityVersion: ULONG,
    pub __bindgen_anon_8: _KTHREAD__bindgen_ty_8,
    #[doc = "offset: 0x170 (368)"]
    pub ReadyTime: ULONG,
    pub __bindgen_anon_9: _KTHREAD__bindgen_ty_9,
    #[doc = "offset: 0x18c (396)"]
    pub SuspendCount: CHAR,
    #[doc = "offset: 0x18d (397)"]
    pub Saturation: CHAR,
    #[doc = "offset: 0x18e (398)"]
    pub SListFaultCount: USHORT,
    pub __bindgen_anon_10: _KTHREAD__bindgen_ty_10,
    #[doc = "offset: 0x1c0 (448)"]
    pub UserTime: ULONG,
    #[doc = "offset: 0x1c4 (452)"]
    pub SuspendEvent: _KEVENT,
    #[doc = "offset: 0x1d4 (468)"]
    pub ThreadListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x1dc (476)"]
    pub MutantListHead: _LIST_ENTRY,
    #[doc = "offset: 0x1e4 (484)"]
    pub AbEntrySummary: UCHAR,
    #[doc = "offset: 0x1e5 (485)"]
    pub AbWaitEntryCount: UCHAR,
    #[doc = "offset: 0x1e6 (486)"]
    pub AbAllocationRegionCount: UCHAR,
    #[doc = "offset: 0x1e7 (487)"]
    pub Spare20: UCHAR,
    #[doc = "offset: 0x1e8 (488)"]
    pub LockEntries: [_KLOCK_ENTRY; 6usize],
    #[doc = "offset: 0x308 (776)"]
    pub PropagateBoostsEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x30c (780)"]
    pub IoSelfBoostsEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x310 (784)"]
    pub PriorityFloorCounts: [UCHAR; 16usize],
    #[doc = "offset: 0x320 (800)"]
    pub PriorityFloorSummary: ULONG,
    #[doc = "offset: 0x324 (804)"]
    pub AbCompletedIoBoostCount: LONG,
    #[doc = "offset: 0x328 (808)"]
    pub AbCompletedIoQoSBoostCount: LONG,
    #[doc = "offset: 0x32c (812)"]
    pub KeReferenceCount: SHORT,
    #[doc = "offset: 0x32e (814)"]
    pub AbOrphanedEntrySummary: UCHAR,
    #[doc = "offset: 0x32f (815)"]
    pub AbOwnedEntryCount: UCHAR,
    #[doc = "offset: 0x330 (816)"]
    pub ForegroundLossTime: ULONG,
    pub __bindgen_anon_11: _KTHREAD__bindgen_ty_11,
    #[doc = "offset: 0x33c (828)"]
    pub QueuedScb: *mut _KSCB,
    #[doc = "offset: 0x340 (832)"]
    pub NpxState: ULONGLONG,
    #[doc = "offset: 0x348 (840)"]
    pub ThreadTimerDelay: ULONG,
    pub __bindgen_anon_12: _KTHREAD__bindgen_ty_12,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_1 {
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x58 (88)"]
    pub MiscFlags: LONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KTHREAD__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AutoBoostActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoBoostActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadyTransition(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadyTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WaitNext(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WaitNext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemAffinityActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemAffinityActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Alertable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Alertable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserStackWalkActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserStackWalkActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ApcInterruptRequest(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ApcInterruptRequest(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QuantumEndMigrate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QuantumEndMigrate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmsDirectedSwitchEnable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmsDirectedSwitchEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TimerActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TimerActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessDetachActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessDetachActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CalloutActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CalloutActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ScbReadyQueue(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ScbReadyQueue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ApcQueueable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ApcQueueable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedStackInUse(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedStackInUse(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmsPerformingSyscall(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmsPerformingSyscall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TimerSuspended(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TimerSuspended(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SuspendedWaitMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SuspendedWaitMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SuspendSchedulerApcWait(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SuspendSchedulerApcWait(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AutoBoostActive: ULONG,
        ReadyTransition: ULONG,
        WaitNext: ULONG,
        SystemAffinityActive: ULONG,
        Alertable: ULONG,
        UserStackWalkActive: ULONG,
        ApcInterruptRequest: ULONG,
        QuantumEndMigrate: ULONG,
        UmsDirectedSwitchEnable: ULONG,
        TimerActive: ULONG,
        SystemThread: ULONG,
        ProcessDetachActive: ULONG,
        CalloutActive: ULONG,
        ScbReadyQueue: ULONG,
        ApcQueueable: ULONG,
        ReservedStackInUse: ULONG,
        UmsPerformingSyscall: ULONG,
        TimerSuspended: ULONG,
        SuspendedWaitMode: ULONG,
        SuspendSchedulerApcWait: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AutoBoostActive: u32 = unsafe { ::std::mem::transmute(AutoBoostActive) };
            AutoBoostActive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadyTransition: u32 = unsafe { ::std::mem::transmute(ReadyTransition) };
            ReadyTransition as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WaitNext: u32 = unsafe { ::std::mem::transmute(WaitNext) };
            WaitNext as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SystemAffinityActive: u32 = unsafe { ::std::mem::transmute(SystemAffinityActive) };
            SystemAffinityActive as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Alertable: u32 = unsafe { ::std::mem::transmute(Alertable) };
            Alertable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UserStackWalkActive: u32 = unsafe { ::std::mem::transmute(UserStackWalkActive) };
            UserStackWalkActive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ApcInterruptRequest: u32 = unsafe { ::std::mem::transmute(ApcInterruptRequest) };
            ApcInterruptRequest as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let QuantumEndMigrate: u32 = unsafe { ::std::mem::transmute(QuantumEndMigrate) };
            QuantumEndMigrate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UmsDirectedSwitchEnable: u32 =
                unsafe { ::std::mem::transmute(UmsDirectedSwitchEnable) };
            UmsDirectedSwitchEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TimerActive: u32 = unsafe { ::std::mem::transmute(TimerActive) };
            TimerActive as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SystemThread: u32 = unsafe { ::std::mem::transmute(SystemThread) };
            SystemThread as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ProcessDetachActive: u32 = unsafe { ::std::mem::transmute(ProcessDetachActive) };
            ProcessDetachActive as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let CalloutActive: u32 = unsafe { ::std::mem::transmute(CalloutActive) };
            CalloutActive as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ScbReadyQueue: u32 = unsafe { ::std::mem::transmute(ScbReadyQueue) };
            ScbReadyQueue as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ApcQueueable: u32 = unsafe { ::std::mem::transmute(ApcQueueable) };
            ApcQueueable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ReservedStackInUse: u32 = unsafe { ::std::mem::transmute(ReservedStackInUse) };
            ReservedStackInUse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UmsPerformingSyscall: u32 = unsafe { ::std::mem::transmute(UmsPerformingSyscall) };
            UmsPerformingSyscall as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let TimerSuspended: u32 = unsafe { ::std::mem::transmute(TimerSuspended) };
            TimerSuspended as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let SuspendedWaitMode: u32 = unsafe { ::std::mem::transmute(SuspendedWaitMode) };
            SuspendedWaitMode as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let SuspendSchedulerApcWait: u32 =
                unsafe { ::std::mem::transmute(SuspendSchedulerApcWait) };
            SuspendSchedulerApcWait as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTHREAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_2 {
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_2__bindgen_ty_1,
    #[doc = "offset: 0x5c (92)"]
    pub ThreadFlags: LONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KTHREAD__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn BamQosLevel(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BamQosLevel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn AutoAlignment(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoAlignment(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableBoost(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableBoost(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AlertedByThreadId(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AlertedByThreadId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QuantumDonation(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QuantumDonation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableStackSwap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableStackSwap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuiThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuiThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableQuantum(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableQuantum(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ChargeOnlySchedulingGroup(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ChargeOnlySchedulingGroup(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeferPreemption(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeferPreemption(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QueueDeferPreemption(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QueueDeferPreemption(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceDeferSchedule(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForceDeferSchedule(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedReadyQueueAffinity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SharedReadyQueueAffinity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FreezeCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FreezeCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TerminationApcRequest(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TerminationApcRequest(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AutoBoostEntriesExhausted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoBoostEntriesExhausted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelStackResident(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelStackResident(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TerminateRequestReason(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TerminateRequestReason(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessStackCountDecremented(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessStackCountDecremented(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RestrictedGuiThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RestrictedGuiThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VpBackingThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VpBackingThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadFlagsSpare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadFlagsSpare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EtwStackTraceApcInserted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EtwStackTraceApcInserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BamQosLevel: ULONG,
        AutoAlignment: ULONG,
        DisableBoost: ULONG,
        AlertedByThreadId: ULONG,
        QuantumDonation: ULONG,
        EnableStackSwap: ULONG,
        GuiThread: ULONG,
        DisableQuantum: ULONG,
        ChargeOnlySchedulingGroup: ULONG,
        DeferPreemption: ULONG,
        QueueDeferPreemption: ULONG,
        ForceDeferSchedule: ULONG,
        SharedReadyQueueAffinity: ULONG,
        FreezeCount: ULONG,
        TerminationApcRequest: ULONG,
        AutoBoostEntriesExhausted: ULONG,
        KernelStackResident: ULONG,
        TerminateRequestReason: ULONG,
        ProcessStackCountDecremented: ULONG,
        RestrictedGuiThread: ULONG,
        VpBackingThread: ULONG,
        ThreadFlagsSpare: ULONG,
        EtwStackTraceApcInserted: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let BamQosLevel: u32 = unsafe { ::std::mem::transmute(BamQosLevel) };
            BamQosLevel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AutoAlignment: u32 = unsafe { ::std::mem::transmute(AutoAlignment) };
            AutoAlignment as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DisableBoost: u32 = unsafe { ::std::mem::transmute(DisableBoost) };
            DisableBoost as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AlertedByThreadId: u32 = unsafe { ::std::mem::transmute(AlertedByThreadId) };
            AlertedByThreadId as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let QuantumDonation: u32 = unsafe { ::std::mem::transmute(QuantumDonation) };
            QuantumDonation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EnableStackSwap: u32 = unsafe { ::std::mem::transmute(EnableStackSwap) };
            EnableStackSwap as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let GuiThread: u32 = unsafe { ::std::mem::transmute(GuiThread) };
            GuiThread as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DisableQuantum: u32 = unsafe { ::std::mem::transmute(DisableQuantum) };
            DisableQuantum as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ChargeOnlySchedulingGroup: u32 =
                unsafe { ::std::mem::transmute(ChargeOnlySchedulingGroup) };
            ChargeOnlySchedulingGroup as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DeferPreemption: u32 = unsafe { ::std::mem::transmute(DeferPreemption) };
            DeferPreemption as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let QueueDeferPreemption: u32 = unsafe { ::std::mem::transmute(QueueDeferPreemption) };
            QueueDeferPreemption as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ForceDeferSchedule: u32 = unsafe { ::std::mem::transmute(ForceDeferSchedule) };
            ForceDeferSchedule as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let SharedReadyQueueAffinity: u32 =
                unsafe { ::std::mem::transmute(SharedReadyQueueAffinity) };
            SharedReadyQueueAffinity as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FreezeCount: u32 = unsafe { ::std::mem::transmute(FreezeCount) };
            FreezeCount as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TerminationApcRequest: u32 =
                unsafe { ::std::mem::transmute(TerminationApcRequest) };
            TerminationApcRequest as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AutoBoostEntriesExhausted: u32 =
                unsafe { ::std::mem::transmute(AutoBoostEntriesExhausted) };
            AutoBoostEntriesExhausted as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let KernelStackResident: u32 = unsafe { ::std::mem::transmute(KernelStackResident) };
            KernelStackResident as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let TerminateRequestReason: u32 =
                unsafe { ::std::mem::transmute(TerminateRequestReason) };
            TerminateRequestReason as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ProcessStackCountDecremented: u32 =
                unsafe { ::std::mem::transmute(ProcessStackCountDecremented) };
            ProcessStackCountDecremented as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let RestrictedGuiThread: u32 = unsafe { ::std::mem::transmute(RestrictedGuiThread) };
            RestrictedGuiThread as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let VpBackingThread: u32 = unsafe { ::std::mem::transmute(VpBackingThread) };
            VpBackingThread as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ThreadFlagsSpare: u32 = unsafe { ::std::mem::transmute(ThreadFlagsSpare) };
            ThreadFlagsSpare as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let EtwStackTraceApcInserted: u32 =
                unsafe { ::std::mem::transmute(EtwStackTraceApcInserted) };
            EtwStackTraceApcInserted as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTHREAD__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_3 {
    #[doc = "offset: 0x70 (112)"]
    pub ApcState: _KAPC_STATE,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_3__bindgen_ty_1 {
    #[doc = "offset: 0x70 (112)"]
    pub ApcStateFill: [UCHAR; 23usize],
    #[doc = "offset: 0x87 (135)"]
    pub Priority: CHAR,
}
impl Default for _KTHREAD__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_4 {
    #[doc = "offset: 0x9c (156)"]
    pub WaitListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x9c (156)"]
    pub SwapListEntry: _SINGLE_LIST_ENTRY,
}
impl Default for _KTHREAD__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_5 {
    #[doc = "offset: 0xe0 (224)"]
    pub WaitBlock: [_KWAIT_BLOCK; 4usize],
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_5__bindgen_ty_1,
    pub __bindgen_anon_2: _KTHREAD__bindgen_ty_5__bindgen_ty_2,
    pub __bindgen_anon_3: _KTHREAD__bindgen_ty_5__bindgen_ty_3,
    pub __bindgen_anon_4: _KTHREAD__bindgen_ty_5__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_5__bindgen_ty_1 {
    #[doc = "offset: 0xe0 (224)"]
    pub WaitBlockFill8: [UCHAR; 20usize],
    #[doc = "offset: 0xf4 (244)"]
    pub ThreadCounters: *mut _KTHREAD_COUNTERS,
}
impl Default for _KTHREAD__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_5__bindgen_ty_2 {
    #[doc = "offset: 0xe0 (224)"]
    pub WaitBlockFill9: [UCHAR; 44usize],
    #[doc = "offset: 0x10c (268)"]
    pub XStateSave: *mut _XSTATE_SAVE,
}
impl Default for _KTHREAD__bindgen_ty_5__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_5__bindgen_ty_3 {
    #[doc = "offset: 0xe0 (224)"]
    pub WaitBlockFill10: [UCHAR; 68usize],
    #[doc = "offset: 0x124 (292)"]
    pub Win32Thread: *mut VOID,
}
impl Default for _KTHREAD__bindgen_ty_5__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_5__bindgen_ty_4 {
    #[doc = "offset: 0xe0 (224)"]
    pub WaitBlockFill11: [UCHAR; 88usize],
    #[doc = "offset: 0x138 (312)"]
    pub WaitTime: ULONG,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1 {
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x13c (316)"]
    pub CombinedApcDisable: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x13c (316)"]
    pub KernelApcDisable: SHORT,
    #[doc = "offset: 0x13e (318)"]
    pub SpecialApcDisable: SHORT,
}
impl Default for _KTHREAD__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_5__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_6 {
    #[doc = "offset: 0x148 (328)"]
    pub NextProcessor: ULONG,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KTHREAD__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn NextProcessorNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_NextProcessorNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedReadyQueue(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SharedReadyQueue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NextProcessorNumber: ULONG,
        SharedReadyQueue: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let NextProcessorNumber: u32 = unsafe { ::std::mem::transmute(NextProcessorNumber) };
            NextProcessorNumber as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let SharedReadyQueue: u32 = unsafe { ::std::mem::transmute(SharedReadyQueue) };
            SharedReadyQueue as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTHREAD__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_7 {
    #[doc = "offset: 0x154 (340)"]
    pub UserAffinity: _GROUP_AFFINITY,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_7__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_7__bindgen_ty_1 {
    #[doc = "offset: 0x154 (340)"]
    pub UserAffinityFill: [UCHAR; 6usize],
    #[doc = "offset: 0x15a (346)"]
    pub PreviousMode: CHAR,
    #[doc = "offset: 0x15b (347)"]
    pub BasePriority: CHAR,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1,
    #[doc = "offset: 0x15d (349)"]
    pub Preempted: UCHAR,
    #[doc = "offset: 0x15e (350)"]
    pub AdjustReason: UCHAR,
    #[doc = "offset: 0x15f (351)"]
    pub AdjustIncrement: CHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x15c (348)"]
    pub PriorityDecrement: CHAR,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KTHREAD__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ForegroundBoost(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ForegroundBoost(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn UnusualBoost(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_UnusualBoost(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ForegroundBoost: UCHAR,
        UnusualBoost: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ForegroundBoost: u8 = unsafe { ::std::mem::transmute(ForegroundBoost) };
            ForegroundBoost as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let UnusualBoost: u8 = unsafe { ::std::mem::transmute(UnusualBoost) };
            UnusualBoost as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTHREAD__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_7__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_8 {
    #[doc = "offset: 0x164 (356)"]
    pub Affinity: _GROUP_AFFINITY,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_8__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_8__bindgen_ty_1 {
    #[doc = "offset: 0x164 (356)"]
    pub AffinityFill: [UCHAR; 6usize],
    #[doc = "offset: 0x16a (362)"]
    pub ApcStateIndex: UCHAR,
    #[doc = "offset: 0x16b (363)"]
    pub WaitBlockCount: UCHAR,
    #[doc = "offset: 0x16c (364)"]
    pub IdealProcessor: ULONG,
}
impl Default for _KTHREAD__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_9 {
    #[doc = "offset: 0x174 (372)"]
    pub SavedApcState: _KAPC_STATE,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_9__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_9__bindgen_ty_1 {
    #[doc = "offset: 0x174 (372)"]
    pub SavedApcStateFill: [UCHAR; 23usize],
    #[doc = "offset: 0x18b (395)"]
    pub WaitReason: UCHAR,
}
impl Default for _KTHREAD__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_10 {
    #[doc = "offset: 0x190 (400)"]
    pub SchedulerApc: _KAPC,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_10__bindgen_ty_1,
    pub __bindgen_anon_2: _KTHREAD__bindgen_ty_10__bindgen_ty_2,
    pub __bindgen_anon_3: _KTHREAD__bindgen_ty_10__bindgen_ty_3,
    pub __bindgen_anon_4: _KTHREAD__bindgen_ty_10__bindgen_ty_4,
    pub __bindgen_anon_5: _KTHREAD__bindgen_ty_10__bindgen_ty_5,
    pub __bindgen_anon_6: _KTHREAD__bindgen_ty_10__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_10__bindgen_ty_1 {
    #[doc = "offset: 0x190 (400)"]
    pub SchedulerApcFill0: [UCHAR; 1usize],
    #[doc = "offset: 0x191 (401)"]
    pub ResourceIndex: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_10__bindgen_ty_2 {
    #[doc = "offset: 0x190 (400)"]
    pub SchedulerApcFill1: [UCHAR; 3usize],
    #[doc = "offset: 0x193 (403)"]
    pub QuantumReset: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_10__bindgen_ty_3 {
    #[doc = "offset: 0x190 (400)"]
    pub SchedulerApcFill2: [UCHAR; 4usize],
    #[doc = "offset: 0x194 (404)"]
    pub KernelTime: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_10__bindgen_ty_4 {
    #[doc = "offset: 0x190 (400)"]
    pub SchedulerApcFill3: [UCHAR; 36usize],
    #[doc = "offset: 0x1b4 (436)"]
    pub WaitPrcb: *mut _KPRCB,
}
impl Default for _KTHREAD__bindgen_ty_10__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_10__bindgen_ty_5 {
    #[doc = "offset: 0x190 (400)"]
    pub SchedulerApcFill4: [UCHAR; 40usize],
    #[doc = "offset: 0x1b8 (440)"]
    pub LegoData: *mut VOID,
}
impl Default for _KTHREAD__bindgen_ty_10__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_10__bindgen_ty_6 {
    #[doc = "offset: 0x190 (400)"]
    pub SchedulerApcFill5: [UCHAR; 47usize],
    #[doc = "offset: 0x1bf (447)"]
    pub CallbackNestingLevel: UCHAR,
}
impl Default for _KTHREAD__bindgen_ty_10__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_11 {
    #[doc = "offset: 0x334 (820)"]
    pub GlobalForegroundListEntry: _LIST_ENTRY,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_11__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_11__bindgen_ty_1 {
    #[doc = "offset: 0x334 (820)"]
    pub ForegroundDpcStackListEntry: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x338 (824)"]
    pub InGlobalForegroundList: ULONG,
}
impl Default for _KTHREAD__bindgen_ty_11__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_12 {
    #[doc = "offset: 0x34c (844)"]
    pub ThreadFlags2: LONG,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_12__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KTHREAD__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn PpmPolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PpmPolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadFlags2Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadFlags2Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PpmPolicy: ULONG,
        ThreadFlags2Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let PpmPolicy: u32 = unsafe { ::std::mem::transmute(PpmPolicy) };
            PpmPolicy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ThreadFlags2Reserved: u32 = unsafe { ::std::mem::transmute(ThreadFlags2Reserved) };
            ThreadFlags2Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTHREAD__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KTHREAD {
    #[inline]
    pub fn UserHeteroCpuPolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_UserHeteroCpuPolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn ExplicitSystemHeteroCpuPolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExplicitSystemHeteroCpuPolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UserHeteroCpuPolicy: UCHAR,
        ExplicitSystemHeteroCpuPolicy: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let UserHeteroCpuPolicy: u8 = unsafe { ::std::mem::transmute(UserHeteroCpuPolicy) };
            UserHeteroCpuPolicy as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ExplicitSystemHeteroCpuPolicy: u8 =
                unsafe { ::std::mem::transmute(ExplicitSystemHeteroCpuPolicy) };
            ExplicitSystemHeteroCpuPolicy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "0x480 (1152) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETHREAD {
    #[doc = "offset: 0x0 (0)"]
    pub Tcb: _KTHREAD,
    #[doc = "offset: 0x350 (848)"]
    pub CreateTime: _LARGE_INTEGER,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_1,
    #[doc = "offset: 0x360 (864)"]
    pub ChargeOnlySession: *mut VOID,
    pub __bindgen_anon_2: _ETHREAD__bindgen_ty_2,
    pub __bindgen_anon_3: _ETHREAD__bindgen_ty_3,
    #[doc = "offset: 0x370 (880)"]
    pub ActiveTimerListLock: ULONG,
    #[doc = "offset: 0x374 (884)"]
    pub ActiveTimerListHead: _LIST_ENTRY,
    #[doc = "offset: 0x37c (892)"]
    pub Cid: _CLIENT_ID,
    pub __bindgen_anon_4: _ETHREAD__bindgen_ty_4,
    #[doc = "offset: 0x398 (920)"]
    pub ClientSecurity: _PS_CLIENT_SECURITY_CONTEXT,
    #[doc = "offset: 0x39c (924)"]
    pub IrpList: _LIST_ENTRY,
    #[doc = "offset: 0x3a4 (932)"]
    pub TopLevelIrp: ULONG,
    #[doc = "offset: 0x3a8 (936)"]
    pub DeviceToVerify: *mut _DEVICE_OBJECT,
    #[doc = "offset: 0x3ac (940)"]
    pub Win32StartAddress: *mut VOID,
    #[doc = "offset: 0x3b0 (944)"]
    pub LegacyPowerObject: *mut VOID,
    #[doc = "offset: 0x3b4 (948)"]
    pub ThreadListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x3bc (956)"]
    pub RundownProtect: _EX_RUNDOWN_REF,
    #[doc = "offset: 0x3c0 (960)"]
    pub ThreadLock: _EX_PUSH_LOCK,
    #[doc = "offset: 0x3c4 (964)"]
    pub ReadClusterSize: ULONG,
    #[doc = "offset: 0x3c8 (968)"]
    pub MmLockOrdering: LONG,
    pub __bindgen_anon_5: _ETHREAD__bindgen_ty_5,
    pub __bindgen_anon_6: _ETHREAD__bindgen_ty_6,
    pub __bindgen_anon_7: _ETHREAD__bindgen_ty_7,
    #[doc = "offset: 0x3d8 (984)"]
    pub CacheManagerActive: UCHAR,
    #[doc = "offset: 0x3d9 (985)"]
    pub DisablePageFaultClustering: UCHAR,
    #[doc = "offset: 0x3da (986)"]
    pub ActiveFaultCount: UCHAR,
    #[doc = "offset: 0x3db (987)"]
    pub LockOrderState: UCHAR,
    #[doc = "offset: 0x3dc (988)"]
    pub AlpcMessageId: ULONG,
    pub __bindgen_anon_8: _ETHREAD__bindgen_ty_8,
    #[doc = "offset: 0x3e4 (996)"]
    pub AlpcWaitListEntry: _LIST_ENTRY,
    #[doc = "offset: 0x3ec (1004)"]
    pub ExitStatus: LONG,
    #[doc = "offset: 0x3f0 (1008)"]
    pub CacheManagerCount: ULONG,
    #[doc = "offset: 0x3f4 (1012)"]
    pub IoBoostCount: ULONG,
    #[doc = "offset: 0x3f8 (1016)"]
    pub IoQoSBoostCount: ULONG,
    #[doc = "offset: 0x3fc (1020)"]
    pub IoQoSThrottleCount: ULONG,
    #[doc = "offset: 0x400 (1024)"]
    pub BoostList: _LIST_ENTRY,
    #[doc = "offset: 0x408 (1032)"]
    pub DeboostList: _LIST_ENTRY,
    #[doc = "offset: 0x410 (1040)"]
    pub BoostListLock: ULONG,
    #[doc = "offset: 0x414 (1044)"]
    pub IrpListLock: ULONG,
    #[doc = "offset: 0x418 (1048)"]
    pub ReservedForSynchTracking: *mut VOID,
    #[doc = "offset: 0x41c (1052)"]
    pub CmCallbackListHead: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x420 (1056)"]
    pub ActivityId: *mut _GUID,
    #[doc = "offset: 0x424 (1060)"]
    pub SeLearningModeListHead: _SINGLE_LIST_ENTRY,
    #[doc = "offset: 0x428 (1064)"]
    pub VerifierContext: *mut VOID,
    #[doc = "offset: 0x42c (1068)"]
    pub KernelStackReference: ULONG,
    #[doc = "offset: 0x430 (1072)"]
    pub AdjustedClientToken: *mut VOID,
    #[doc = "offset: 0x434 (1076)"]
    pub WorkOnBehalfThread: *mut VOID,
    #[doc = "offset: 0x438 (1080)"]
    pub PropertySet: _PS_PROPERTY_SET,
    #[doc = "offset: 0x444 (1092)"]
    pub PicoContext: *mut VOID,
    #[doc = "offset: 0x448 (1096)"]
    pub UserFsBase: ULONG,
    #[doc = "offset: 0x44c (1100)"]
    pub UserGsBase: ULONG,
    #[doc = "offset: 0x450 (1104)"]
    pub EnergyValues: *mut _THREAD_ENERGY_VALUES,
    #[doc = "offset: 0x454 (1108)"]
    pub CmDbgInfo: *mut VOID,
    pub __bindgen_anon_9: _ETHREAD__bindgen_ty_9,
    #[doc = "offset: 0x45c (1116)"]
    pub Silo: *mut _EJOB,
    #[doc = "offset: 0x460 (1120)"]
    pub ThreadName: *mut _UNICODE_STRING,
    #[doc = "offset: 0x464 (1124)"]
    pub LastExpectedRunTime: ULONG,
    #[doc = "offset: 0x468 (1128)"]
    pub OwnerEntryListHead: _LIST_ENTRY,
    #[doc = "offset: 0x470 (1136)"]
    pub DisownedOwnerEntryListLock: ULONG,
    #[doc = "offset: 0x474 (1140)"]
    pub DisownedOwnerEntryListHead: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_1 {
    #[doc = "offset: 0x358 (856)"]
    pub ExitTime: _LARGE_INTEGER,
    #[doc = "offset: 0x358 (856)"]
    pub KeyedWaitChain: _LIST_ENTRY,
}
impl Default for _ETHREAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_2 {
    #[doc = "offset: 0x364 (868)"]
    pub PostBlockList: _LIST_ENTRY,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETHREAD__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "offset: 0x364 (868)"]
    pub ForwardLinkShadow: *mut VOID,
    #[doc = "offset: 0x368 (872)"]
    pub StartAddress: *mut VOID,
}
impl Default for _ETHREAD__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETHREAD__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_3 {
    #[doc = "offset: 0x36c (876)"]
    pub TerminationPort: *mut _TERMINATION_PORT,
    #[doc = "offset: 0x36c (876)"]
    pub ReaperLink: *mut _ETHREAD,
    #[doc = "offset: 0x36c (876)"]
    pub KeyedWaitValue: *mut VOID,
}
impl Default for _ETHREAD__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_4 {
    #[doc = "offset: 0x384 (900)"]
    pub KeyedWaitSemaphore: _KSEMAPHORE,
    #[doc = "offset: 0x384 (900)"]
    pub AlpcWaitSemaphore: _KSEMAPHORE,
}
impl Default for _ETHREAD__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_5 {
    #[doc = "offset: 0x3cc (972)"]
    pub CrossThreadFlags: ULONG,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETHREAD__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ETHREAD__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn Terminated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Terminated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadInserted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadInserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HideFromDebugger(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HideFromDebugger(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ActiveImpersonationInfo(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ActiveImpersonationInfo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardErrorsAreDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardErrorsAreDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BreakOnTermination(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BreakOnTermination(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipCreationMsg(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SkipCreationMsg(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipTerminationMsg(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SkipTerminationMsg(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyTokenOnOpen(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CopyTokenOnOpen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadIoPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadIoPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadPagePriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadPagePriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RundownFail(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RundownFail(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmsForceQueueTermination(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmsForceQueueTermination(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IndirectCpuSets(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IndirectCpuSets(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableDynamicCodeOptOut(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableDynamicCodeOptOut(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExplicitCaseSensitivity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExplicitCaseSensitivity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PicoNotifyExit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PicoNotifyExit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgWerUserReportActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgWerUserReportActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForcedSelfTrimActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForcedSelfTrimActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedCrossThreadFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedCrossThreadFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Terminated: ULONG,
        ThreadInserted: ULONG,
        HideFromDebugger: ULONG,
        ActiveImpersonationInfo: ULONG,
        HardErrorsAreDisabled: ULONG,
        BreakOnTermination: ULONG,
        SkipCreationMsg: ULONG,
        SkipTerminationMsg: ULONG,
        CopyTokenOnOpen: ULONG,
        ThreadIoPriority: ULONG,
        ThreadPagePriority: ULONG,
        RundownFail: ULONG,
        UmsForceQueueTermination: ULONG,
        IndirectCpuSets: ULONG,
        DisableDynamicCodeOptOut: ULONG,
        ExplicitCaseSensitivity: ULONG,
        PicoNotifyExit: ULONG,
        DbgWerUserReportActive: ULONG,
        ForcedSelfTrimActive: ULONG,
        ReservedCrossThreadFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Terminated: u32 = unsafe { ::std::mem::transmute(Terminated) };
            Terminated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ThreadInserted: u32 = unsafe { ::std::mem::transmute(ThreadInserted) };
            ThreadInserted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HideFromDebugger: u32 = unsafe { ::std::mem::transmute(HideFromDebugger) };
            HideFromDebugger as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ActiveImpersonationInfo: u32 =
                unsafe { ::std::mem::transmute(ActiveImpersonationInfo) };
            ActiveImpersonationInfo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HardErrorsAreDisabled: u32 =
                unsafe { ::std::mem::transmute(HardErrorsAreDisabled) };
            HardErrorsAreDisabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BreakOnTermination: u32 = unsafe { ::std::mem::transmute(BreakOnTermination) };
            BreakOnTermination as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SkipCreationMsg: u32 = unsafe { ::std::mem::transmute(SkipCreationMsg) };
            SkipCreationMsg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SkipTerminationMsg: u32 = unsafe { ::std::mem::transmute(SkipTerminationMsg) };
            SkipTerminationMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CopyTokenOnOpen: u32 = unsafe { ::std::mem::transmute(CopyTokenOnOpen) };
            CopyTokenOnOpen as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let ThreadIoPriority: u32 = unsafe { ::std::mem::transmute(ThreadIoPriority) };
            ThreadIoPriority as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let ThreadPagePriority: u32 = unsafe { ::std::mem::transmute(ThreadPagePriority) };
            ThreadPagePriority as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RundownFail: u32 = unsafe { ::std::mem::transmute(RundownFail) };
            RundownFail as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UmsForceQueueTermination: u32 =
                unsafe { ::std::mem::transmute(UmsForceQueueTermination) };
            UmsForceQueueTermination as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let IndirectCpuSets: u32 = unsafe { ::std::mem::transmute(IndirectCpuSets) };
            IndirectCpuSets as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DisableDynamicCodeOptOut: u32 =
                unsafe { ::std::mem::transmute(DisableDynamicCodeOptOut) };
            DisableDynamicCodeOptOut as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ExplicitCaseSensitivity: u32 =
                unsafe { ::std::mem::transmute(ExplicitCaseSensitivity) };
            ExplicitCaseSensitivity as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let PicoNotifyExit: u32 = unsafe { ::std::mem::transmute(PicoNotifyExit) };
            PicoNotifyExit as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let DbgWerUserReportActive: u32 =
                unsafe { ::std::mem::transmute(DbgWerUserReportActive) };
            DbgWerUserReportActive as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ForcedSelfTrimActive: u32 = unsafe { ::std::mem::transmute(ForcedSelfTrimActive) };
            ForcedSelfTrimActive as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let ReservedCrossThreadFlags: u32 =
                unsafe { ::std::mem::transmute(ReservedCrossThreadFlags) };
            ReservedCrossThreadFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETHREAD__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_6 {
    #[doc = "offset: 0x3d0 (976)"]
    pub SameThreadPassiveFlags: ULONG,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETHREAD__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ETHREAD__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn ActiveExWorker(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ActiveExWorker(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MemoryMaker(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemoryMaker(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StoreLockThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_StoreLockThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ClonedThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ClonedThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KeyedEventInUse(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KeyedEventInUse(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SelfTerminate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SelfTerminate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RespectIoPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RespectIoPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ActivePageLists(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ActivePageLists(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecureContext(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ZeroPageThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ZeroPageThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedSameThreadPassiveFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedSameThreadPassiveFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActiveExWorker: ULONG,
        MemoryMaker: ULONG,
        StoreLockThread: ULONG,
        ClonedThread: ULONG,
        KeyedEventInUse: ULONG,
        SelfTerminate: ULONG,
        RespectIoPriority: ULONG,
        ActivePageLists: ULONG,
        SecureContext: ULONG,
        ZeroPageThread: ULONG,
        ReservedSameThreadPassiveFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ActiveExWorker: u32 = unsafe { ::std::mem::transmute(ActiveExWorker) };
            ActiveExWorker as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MemoryMaker: u32 = unsafe { ::std::mem::transmute(MemoryMaker) };
            MemoryMaker as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let StoreLockThread: u32 = unsafe { ::std::mem::transmute(StoreLockThread) };
            StoreLockThread as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ClonedThread: u32 = unsafe { ::std::mem::transmute(ClonedThread) };
            ClonedThread as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let KeyedEventInUse: u32 = unsafe { ::std::mem::transmute(KeyedEventInUse) };
            KeyedEventInUse as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SelfTerminate: u32 = unsafe { ::std::mem::transmute(SelfTerminate) };
            SelfTerminate as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RespectIoPriority: u32 = unsafe { ::std::mem::transmute(RespectIoPriority) };
            RespectIoPriority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ActivePageLists: u32 = unsafe { ::std::mem::transmute(ActivePageLists) };
            ActivePageLists as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SecureContext: u32 = unsafe { ::std::mem::transmute(SecureContext) };
            SecureContext as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ZeroPageThread: u32 = unsafe { ::std::mem::transmute(ZeroPageThread) };
            ZeroPageThread as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let ReservedSameThreadPassiveFlags: u32 =
                unsafe { ::std::mem::transmute(ReservedSameThreadPassiveFlags) };
            ReservedSameThreadPassiveFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETHREAD__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_7 {
    #[doc = "offset: 0x3d4 (980)"]
    pub SameThreadApcFlags: ULONG,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_7__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETHREAD__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _ETHREAD__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn OwnsProcessAddressSpaceExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsProcessAddressSpaceExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsProcessAddressSpaceShared(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsProcessAddressSpaceShared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardFaultBehavior(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HardFaultBehavior(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StartAddressInvalid(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_StartAddressInvalid(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EtwCalloutActive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EtwCalloutActive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SuppressSymbolLoad(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SuppressSymbolLoad(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prefetching(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Prefetching(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsVadExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsVadExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemPagePriorityActive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SystemPagePriorityActive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemPagePriority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SystemPagePriority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowWritesToExecutableMemory(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AllowWritesToExecutableMemory(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OwnsProcessAddressSpaceExclusive: UCHAR,
        OwnsProcessAddressSpaceShared: UCHAR,
        HardFaultBehavior: UCHAR,
        StartAddressInvalid: UCHAR,
        EtwCalloutActive: UCHAR,
        SuppressSymbolLoad: UCHAR,
        Prefetching: UCHAR,
        OwnsVadExclusive: UCHAR,
        SystemPagePriorityActive: UCHAR,
        SystemPagePriority: UCHAR,
        AllowWritesToExecutableMemory: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OwnsProcessAddressSpaceExclusive: u8 =
                unsafe { ::std::mem::transmute(OwnsProcessAddressSpaceExclusive) };
            OwnsProcessAddressSpaceExclusive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OwnsProcessAddressSpaceShared: u8 =
                unsafe { ::std::mem::transmute(OwnsProcessAddressSpaceShared) };
            OwnsProcessAddressSpaceShared as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HardFaultBehavior: u8 = unsafe { ::std::mem::transmute(HardFaultBehavior) };
            HardFaultBehavior as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let StartAddressInvalid: u8 = unsafe { ::std::mem::transmute(StartAddressInvalid) };
            StartAddressInvalid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EtwCalloutActive: u8 = unsafe { ::std::mem::transmute(EtwCalloutActive) };
            EtwCalloutActive as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SuppressSymbolLoad: u8 = unsafe { ::std::mem::transmute(SuppressSymbolLoad) };
            SuppressSymbolLoad as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Prefetching: u8 = unsafe { ::std::mem::transmute(Prefetching) };
            Prefetching as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OwnsVadExclusive: u8 = unsafe { ::std::mem::transmute(OwnsVadExclusive) };
            OwnsVadExclusive as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SystemPagePriorityActive: u8 =
                unsafe { ::std::mem::transmute(SystemPagePriorityActive) };
            SystemPagePriorityActive as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let SystemPagePriority: u8 = unsafe { ::std::mem::transmute(SystemPagePriority) };
            SystemPagePriority as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let AllowWritesToExecutableMemory: u8 =
                unsafe { ::std::mem::transmute(AllowWritesToExecutableMemory) };
            AllowWritesToExecutableMemory as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETHREAD__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_8 {
    #[doc = "offset: 0x3e0 (992)"]
    pub AlpcMessage: *mut VOID,
    #[doc = "offset: 0x3e0 (992)"]
    pub AlpcReceiveAttributeSet: ULONG,
}
impl Default for _ETHREAD__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_9 {
    #[doc = "offset: 0x458 (1112)"]
    pub SelectedCpuSets: ULONG,
    #[doc = "offset: 0x458 (1112)"]
    pub SelectedCpuSetsIndirect: *mut ULONG,
}
impl Default for _ETHREAD__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETHREAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0xb0 (176) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KINTERRUPT {
    #[doc = "offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = "offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = "offset: 0x4 (4)"]
    pub InterruptListEntry: _LIST_ENTRY,
    pub ServiceRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _KINTERRUPT, arg2: *mut VOID) -> UCHAR,
    >,
    pub MessageServiceRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _KINTERRUPT, arg2: *mut VOID, arg3: ULONG) -> UCHAR,
    >,
    #[doc = "offset: 0x14 (20)"]
    pub MessageIndex: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub ServiceContext: *mut VOID,
    #[doc = "offset: 0x1c (28)"]
    pub SpinLock: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub TickCount: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ActualLock: *mut ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub DispatchAddress: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "offset: 0x2c (44)"]
    pub Vector: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub Irql: UCHAR,
    #[doc = "offset: 0x31 (49)"]
    pub SynchronizeIrql: UCHAR,
    #[doc = "offset: 0x32 (50)"]
    pub FloatingSave: UCHAR,
    #[doc = "offset: 0x33 (51)"]
    pub Connected: UCHAR,
    #[doc = "offset: 0x34 (52)"]
    pub Number: ULONG,
    #[doc = "offset: 0x38 (56)"]
    pub ShareVector: UCHAR,
    #[doc = "offset: 0x39 (57)"]
    pub EmulateActiveBoth: UCHAR,
    #[doc = "offset: 0x3a (58)"]
    pub ActiveCount: USHORT,
    #[doc = "offset: 0x3c (60)"]
    pub InternalState: LONG,
    #[doc = "offset: 0x40 (64)"]
    pub Mode: _KINTERRUPT_MODE,
    #[doc = "offset: 0x44 (68)"]
    pub Polarity: _KINTERRUPT_POLARITY,
    #[doc = "offset: 0x48 (72)"]
    pub ServiceCount: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub DispatchCount: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub PassiveEvent: *mut _KEVENT,
    #[doc = "offset: 0x54 (84)"]
    pub DisconnectData: *mut VOID,
    #[doc = "offset: 0x58 (88)"]
    pub ServiceThread: *mut _KTHREAD,
    #[doc = "offset: 0x5c (92)"]
    pub ConnectionData: *mut _INTERRUPT_CONNECTION_DATA,
    #[doc = "offset: 0x60 (96)"]
    pub IntTrackEntry: *mut VOID,
    #[doc = "offset: 0x68 (104)"]
    pub IsrDpcStats: _ISRDPCSTATS,
    #[doc = "offset: 0xa8 (168)"]
    pub RedirectObject: *mut VOID,
}
impl Default for _KINTERRUPT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSECONDARY_IDT_ENTRY {
    #[doc = "offset: 0x0 (0)"]
    pub SpinLock: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub ConnectLock: _KEVENT,
    #[doc = "offset: 0x14 (20)"]
    pub LineMasked: UCHAR,
    #[doc = "offset: 0x18 (24)"]
    pub InterruptList: *mut _KINTERRUPT,
}
impl Default for _KSECONDARY_IDT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_PERF_CONSTRAINT {
    #[doc = "offset: 0x0 (0)"]
    pub Prcb: *mut _KPRCB,
    #[doc = "offset: 0x4 (4)"]
    pub PerfContext: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub PlatformCap: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub ThermalCap: ULONG,
    #[doc = "offset: 0x10 (16)"]
    pub LimitReasons: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub PlatformCapStartTime: ULONGLONG,
    #[doc = "offset: 0x20 (32)"]
    pub ProcCap: ULONG,
    #[doc = "offset: 0x24 (36)"]
    pub ProcFloor: ULONG,
    #[doc = "offset: 0x28 (40)"]
    pub TargetPercent: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub Selection: _PERF_CONTROL_STATE_SELECTION,
    #[doc = "offset: 0x58 (88)"]
    pub DomainSelectionGeneration: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub PreviousFrequency: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub PreviousPercent: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub LatestFrequencyPercent: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub Force: UCHAR,
}
impl Default for _PROC_PERF_CONSTRAINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x180 (384) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_PERF_DOMAIN {
    #[doc = "offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = "offset: 0x8 (8)"]
    pub Master: *mut _KPRCB,
    #[doc = "offset: 0xc (12)"]
    pub Members: _KAFFINITY_EX,
    #[doc = "offset: 0x18 (24)"]
    pub DomainContext: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub ProcessorCount: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub EfficiencyClass: UCHAR,
    #[doc = "offset: 0x21 (33)"]
    pub NominalPerformanceClass: UCHAR,
    #[doc = "offset: 0x22 (34)"]
    pub HighestPerformanceClass: UCHAR,
    #[doc = "offset: 0x23 (35)"]
    pub Spare: UCHAR,
    #[doc = "offset: 0x24 (36)"]
    pub Processors: *mut _PROC_PERF_CONSTRAINT,
    #[doc = "offset: 0x28 (40)"]
    pub GetFFHThrottleState: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ULONGLONG)>,
    #[doc = "offset: 0x2c (44)"]
    pub TimeWindowHandler: ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: ULONG)>,
    #[doc = "offset: 0x30 (48)"]
    pub BoostPolicyHandler: ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: ULONG)>,
    #[doc = "offset: 0x34 (52)"]
    pub BoostModeHandler: ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: ULONG)>,
    pub EnergyPerfPreferenceHandler:
        ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: ULONG)>,
    pub AutonomousActivityWindowHandler:
        ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: ULONG)>,
    #[doc = "offset: 0x40 (64)"]
    pub AutonomousModeHandler:
        ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: ULONG)>,
    #[doc = "offset: 0x44 (68)"]
    pub ReinitializeHandler: ::std::option::Option<unsafe extern "C" fn(arg1: ULONG)>,
    pub PerfSelectionHandler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ULONG,
            arg2: ULONG,
            arg3: ULONG,
            arg4: ULONG,
            arg5: ULONG,
            arg6: ULONG,
            arg7: ULONG,
            arg8: *mut ULONG,
            arg9: *mut ULONGLONG,
        ) -> ULONG,
    >,
    pub PerfControlHandler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ULONG,
            arg2: *mut _PERF_CONTROL_STATE_SELECTION,
            arg3: UCHAR,
            arg4: UCHAR,
        ),
    >,
    pub DomainPerfControlHandler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ULONG,
            arg2: *mut _PERF_CONTROL_STATE_SELECTION,
            arg3: UCHAR,
            arg4: UCHAR,
        ),
    >,
    #[doc = "offset: 0x54 (84)"]
    pub MaxFrequency: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub NominalFrequency: ULONG,
    #[doc = "offset: 0x5c (92)"]
    pub MaxPercent: ULONG,
    #[doc = "offset: 0x60 (96)"]
    pub MinPerfPercent: ULONG,
    #[doc = "offset: 0x64 (100)"]
    pub MinThrottlePercent: ULONG,
    #[doc = "offset: 0x68 (104)"]
    pub MinimumRelativePerformance: ULONGLONG,
    #[doc = "offset: 0x70 (112)"]
    pub NominalRelativePerformance: ULONGLONG,
    #[doc = "offset: 0x78 (120)"]
    pub NominalRelativePerformancePercent: UCHAR,
    #[doc = "offset: 0x79 (121)"]
    pub Coordination: UCHAR,
    #[doc = "offset: 0x7a (122)"]
    pub HardPlatformCap: UCHAR,
    #[doc = "offset: 0x7b (123)"]
    pub AffinitizeControl: UCHAR,
    #[doc = "offset: 0x7c (124)"]
    pub EfficientThrottle: UCHAR,
    #[doc = "offset: 0x7d (125)"]
    pub AllowSchedulerDirectedPerfStates: UCHAR,
    #[doc = "offset: 0x7e (126)"]
    pub InitiateAllProcessors: UCHAR,
    #[doc = "offset: 0x7f (127)"]
    pub AutonomousMode: UCHAR,
    #[doc = "offset: 0x80 (128)"]
    pub ProvideGuidance: UCHAR,
    #[doc = "offset: 0x84 (132)"]
    pub DesiredPercent: ULONG,
    #[doc = "offset: 0x88 (136)"]
    pub GuaranteedPercent: ULONG,
    #[doc = "offset: 0x8c (140)"]
    pub QosPolicies: [_PROC_PERF_QOS_CLASS_POLICY; 3usize],
    #[doc = "offset: 0xd4 (212)"]
    pub QosDisableReasons: [ULONG; 3usize],
    #[doc = "offset: 0xe0 (224)"]
    pub QosEquivalencyMasks: [ULONG; 3usize],
    #[doc = "offset: 0xec (236)"]
    pub QosSupported: UCHAR,
    #[doc = "offset: 0xf0 (240)"]
    pub SelectionGeneration: ULONG,
    #[doc = "offset: 0xf8 (248)"]
    pub QosSelection: [_PERF_CONTROL_STATE_SELECTION; 3usize],
    #[doc = "offset: 0x170 (368)"]
    pub PerfChangeTime: ULONGLONG,
    #[doc = "offset: 0x178 (376)"]
    pub PerfChangeIntervalCount: ULONG,
    #[doc = "offset: 0x17c (380)"]
    pub Force: UCHAR,
}
impl Default for _PROC_PERF_DOMAIN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x4a60 (19040) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPCR {
    pub __bindgen_anon_1: _KPCR__bindgen_ty_1,
    #[doc = "offset: 0x1c (28)"]
    pub SelfPcr: *mut _KPCR,
    #[doc = "offset: 0x20 (32)"]
    pub Prcb: *mut _KPRCB,
    #[doc = "offset: 0x24 (36)"]
    pub Irql: UCHAR,
    #[doc = "offset: 0x28 (40)"]
    pub IRR: ULONG,
    #[doc = "offset: 0x2c (44)"]
    pub IrrActive: ULONG,
    #[doc = "offset: 0x30 (48)"]
    pub IDR: ULONG,
    #[doc = "offset: 0x34 (52)"]
    pub KdVersionBlock: *mut VOID,
    #[doc = "offset: 0x38 (56)"]
    pub IDT: *mut _KIDTENTRY,
    #[doc = "offset: 0x3c (60)"]
    pub GDT: *mut _KGDTENTRY,
    #[doc = "offset: 0x40 (64)"]
    pub TSS: *mut _KTSS,
    #[doc = "offset: 0x44 (68)"]
    pub MajorVersion: USHORT,
    #[doc = "offset: 0x46 (70)"]
    pub MinorVersion: USHORT,
    #[doc = "offset: 0x48 (72)"]
    pub SetMember: ULONG,
    #[doc = "offset: 0x4c (76)"]
    pub StallScaleFactor: ULONG,
    #[doc = "offset: 0x50 (80)"]
    pub SpareUnused: UCHAR,
    #[doc = "offset: 0x51 (81)"]
    pub Number: UCHAR,
    #[doc = "offset: 0x52 (82)"]
    pub Spare0: UCHAR,
    #[doc = "offset: 0x53 (83)"]
    pub SecondLevelCacheAssociativity: UCHAR,
    #[doc = "offset: 0x54 (84)"]
    pub VdmAlert: ULONG,
    #[doc = "offset: 0x58 (88)"]
    pub KernelReserved: [ULONG; 14usize],
    #[doc = "offset: 0x90 (144)"]
    pub SecondLevelCacheSize: ULONG,
    #[doc = "offset: 0x94 (148)"]
    pub HalReserved: [ULONG; 16usize],
    #[doc = "offset: 0xd4 (212)"]
    pub InterruptMode: ULONG,
    #[doc = "offset: 0xd8 (216)"]
    pub Spare1: UCHAR,
    #[doc = "offset: 0xdc (220)"]
    pub KernelReserved2: [ULONG; 17usize],
    #[doc = "offset: 0x120 (288)"]
    pub PrcbData: _KPRCB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPCR__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub NtTib: _NT_TIB,
    pub __bindgen_anon_1: _KPCR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPCR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x0 (0)"]
    pub Used_ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    #[doc = "offset: 0x4 (4)"]
    pub Used_StackBase: *mut VOID,
    #[doc = "offset: 0x8 (8)"]
    pub MxCsr: ULONG,
    #[doc = "offset: 0xc (12)"]
    pub TssCopy: *mut VOID,
    #[doc = "offset: 0x10 (16)"]
    pub ContextSwitches: ULONG,
    #[doc = "offset: 0x14 (20)"]
    pub SetMemberCopy: ULONG,
    #[doc = "offset: 0x18 (24)"]
    pub Used_Self: *mut VOID,
}
impl Default for _KPCR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPCR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPCR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x708 (1800) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KUSER_SHARED_DATA {
    #[doc = "offset: 0x0 (0)"]
    pub TickCountLowDeprecated: ULONG,
    #[doc = "offset: 0x4 (4)"]
    pub TickCountMultiplier: ULONG,
    #[doc = "offset: 0x8 (8)"]
    pub InterruptTime: _KSYSTEM_TIME,
    #[doc = "offset: 0x14 (20)"]
    pub SystemTime: _KSYSTEM_TIME,
    #[doc = "offset: 0x20 (32)"]
    pub TimeZoneBias: _KSYSTEM_TIME,
    #[doc = "offset: 0x2c (44)"]
    pub ImageNumberLow: USHORT,
    #[doc = "offset: 0x2e (46)"]
    pub ImageNumberHigh: USHORT,
    #[doc = "offset: 0x30 (48)"]
    pub NtSystemRoot: [WCHAR; 260usize],
    #[doc = "offset: 0x238 (568)"]
    pub MaxStackTraceDepth: ULONG,
    #[doc = "offset: 0x23c (572)"]
    pub CryptoExponent: ULONG,
    #[doc = "offset: 0x240 (576)"]
    pub TimeZoneId: ULONG,
    #[doc = "offset: 0x244 (580)"]
    pub LargePageMinimum: ULONG,
    #[doc = "offset: 0x248 (584)"]
    pub AitSamplingValue: ULONG,
    #[doc = "offset: 0x24c (588)"]
    pub AppCompatFlag: ULONG,
    #[doc = "offset: 0x250 (592)"]
    pub RNGSeedVersion: ULONGLONG,
    #[doc = "offset: 0x258 (600)"]
    pub GlobalValidationRunlevel: ULONG,
    #[doc = "offset: 0x25c (604)"]
    pub TimeZoneBiasStamp: LONG,
    #[doc = "offset: 0x260 (608)"]
    pub NtBuildNumber: ULONG,
    #[doc = "offset: 0x264 (612)"]
    pub NtProductType: _NT_PRODUCT_TYPE,
    #[doc = "offset: 0x268 (616)"]
    pub ProductTypeIsValid: UCHAR,
    #[doc = "offset: 0x269 (617)"]
    pub Reserved0: [UCHAR; 1usize],
    #[doc = "offset: 0x26a (618)"]
    pub NativeProcessorArchitecture: USHORT,
    #[doc = "offset: 0x26c (620)"]
    pub NtMajorVersion: ULONG,
    #[doc = "offset: 0x270 (624)"]
    pub NtMinorVersion: ULONG,
    #[doc = "offset: 0x274 (628)"]
    pub ProcessorFeatures: [UCHAR; 64usize],
    #[doc = "offset: 0x2b4 (692)"]
    pub Reserved1: ULONG,
    #[doc = "offset: 0x2b8 (696)"]
    pub Reserved3: ULONG,
    #[doc = "offset: 0x2bc (700)"]
    pub TimeSlip: ULONG,
    #[doc = "offset: 0x2c0 (704)"]
    pub AlternativeArchitecture: _ALTERNATIVE_ARCHITECTURE_TYPE,
    #[doc = "offset: 0x2c4 (708)"]
    pub BootId: ULONG,
    #[doc = "offset: 0x2c8 (712)"]
    pub SystemExpirationDate: _LARGE_INTEGER,
    #[doc = "offset: 0x2d0 (720)"]
    pub SuiteMask: ULONG,
    #[doc = "offset: 0x2d4 (724)"]
    pub KdDebuggerEnabled: UCHAR,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1,
    #[doc = "offset: 0x2d6 (726)"]
    pub Reserved6: [UCHAR; 2usize],
    #[doc = "offset: 0x2d8 (728)"]
    pub ActiveConsoleId: ULONG,
    #[doc = "offset: 0x2dc (732)"]
    pub DismountCount: ULONG,
    #[doc = "offset: 0x2e0 (736)"]
    pub ComPlusPackage: ULONG,
    #[doc = "offset: 0x2e4 (740)"]
    pub LastSystemRITEventTickCount: ULONG,
    #[doc = "offset: 0x2e8 (744)"]
    pub NumberOfPhysicalPages: ULONG,
    #[doc = "offset: 0x2ec (748)"]
    pub SafeBootMode: UCHAR,
    #[doc = "offset: 0x2ed (749)"]
    pub VirtualizationFlags: UCHAR,
    #[doc = "offset: 0x2ee (750)"]
    pub Reserved12: [UCHAR; 2usize],
    pub __bindgen_anon_2: _KUSER_SHARED_DATA__bindgen_ty_2,
    #[doc = "offset: 0x2f4 (756)"]
    pub DataFlagsPad: [ULONG; 1usize],
    #[doc = "offset: 0x2f8 (760)"]
    pub TestRetInstruction: ULONGLONG,
    #[doc = "offset: 0x300 (768)"]
    pub QpcFrequency: LONGLONG,
    #[doc = "offset: 0x308 (776)"]
    pub SystemCall: ULONG,
    #[doc = "offset: 0x30c (780)"]
    pub SystemCallPad0: ULONG,
    #[doc = "offset: 0x310 (784)"]
    pub SystemCallPad: [ULONGLONG; 2usize],
    pub __bindgen_anon_3: _KUSER_SHARED_DATA__bindgen_ty_3,
    #[doc = "offset: 0x32c (812)"]
    pub TickCountPad: [ULONG; 1usize],
    #[doc = "offset: 0x330 (816)"]
    pub Cookie: ULONG,
    #[doc = "offset: 0x334 (820)"]
    pub CookiePad: [ULONG; 1usize],
    #[doc = "offset: 0x338 (824)"]
    pub ConsoleSessionForegroundProcessId: LONGLONG,
    #[doc = "offset: 0x340 (832)"]
    pub TimeUpdateLock: ULONGLONG,
    #[doc = "offset: 0x348 (840)"]
    pub BaselineSystemTimeQpc: ULONGLONG,
    #[doc = "offset: 0x350 (848)"]
    pub BaselineInterruptTimeQpc: ULONGLONG,
    #[doc = "offset: 0x358 (856)"]
    pub QpcSystemTimeIncrement: ULONGLONG,
    #[doc = "offset: 0x360 (864)"]
    pub QpcInterruptTimeIncrement: ULONGLONG,
    #[doc = "offset: 0x368 (872)"]
    pub QpcSystemTimeIncrementShift: UCHAR,
    #[doc = "offset: 0x369 (873)"]
    pub QpcInterruptTimeIncrementShift: UCHAR,
    #[doc = "offset: 0x36a (874)"]
    pub UnparkedProcessorCount: USHORT,
    #[doc = "offset: 0x36c (876)"]
    pub EnclaveFeatureMask: [ULONG; 4usize],
    #[doc = "offset: 0x37c (892)"]
    pub TelemetryCoverageRound: ULONG,
    #[doc = "offset: 0x380 (896)"]
    pub UserModeGlobalLogger: [USHORT; 16usize],
    #[doc = "offset: 0x3a0 (928)"]
    pub ImageFileExecutionOptions: ULONG,
    #[doc = "offset: 0x3a4 (932)"]
    pub LangGenerationCount: ULONG,
    #[doc = "offset: 0x3a8 (936)"]
    pub Reserved4: ULONGLONG,
    #[doc = "offset: 0x3b0 (944)"]
    pub InterruptTimeBias: ULONGLONG,
    #[doc = "offset: 0x3b8 (952)"]
    pub QpcBias: ULONGLONG,
    #[doc = "offset: 0x3c0 (960)"]
    pub ActiveProcessorCount: ULONG,
    #[doc = "offset: 0x3c4 (964)"]
    pub ActiveGroupCount: UCHAR,
    #[doc = "offset: 0x3c5 (965)"]
    pub Reserved9: UCHAR,
    pub __bindgen_anon_4: _KUSER_SHARED_DATA__bindgen_ty_4,
    #[doc = "offset: 0x3c8 (968)"]
    pub TimeZoneBiasEffectiveStart: _LARGE_INTEGER,
    #[doc = "offset: 0x3d0 (976)"]
    pub TimeZoneBiasEffectiveEnd: _LARGE_INTEGER,
    #[doc = "offset: 0x3d8 (984)"]
    pub XState: _XSTATE_CONFIGURATION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_1 {
    #[doc = "offset: 0x2d5 (725)"]
    pub MitigationPolicies: UCHAR,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NXSupportPolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_NXSupportPolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SEHValidationPolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SEHValidationPolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CurDirDevicesSkippedForDlls(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CurDirDevicesSkippedForDlls(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NXSupportPolicy: UCHAR,
        SEHValidationPolicy: UCHAR,
        CurDirDevicesSkippedForDlls: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let NXSupportPolicy: u8 = unsafe { ::std::mem::transmute(NXSupportPolicy) };
            NXSupportPolicy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SEHValidationPolicy: u8 = unsafe { ::std::mem::transmute(SEHValidationPolicy) };
            SEHValidationPolicy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let CurDirDevicesSkippedForDlls: u8 =
                unsafe { ::std::mem::transmute(CurDirDevicesSkippedForDlls) };
            CurDirDevicesSkippedForDlls as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_2 {
    #[doc = "offset: 0x2f0 (752)"]
    pub SharedDataFlags: ULONG,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn DbgErrorPortPresent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgErrorPortPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgElevationEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgElevationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgVirtEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgVirtEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgInstallerDetectEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgInstallerDetectEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgLkgEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgLkgEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgDynProcessorEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgDynProcessorEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgConsoleBrokerEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgConsoleBrokerEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSecureBootEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgSecureBootEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgMultiSessionSku(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgMultiSessionSku(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgMultiUsersInSessionSku(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgMultiUsersInSessionSku(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgStateSeparationEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgStateSeparationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgErrorPortPresent: ULONG,
        DbgElevationEnabled: ULONG,
        DbgVirtEnabled: ULONG,
        DbgInstallerDetectEnabled: ULONG,
        DbgLkgEnabled: ULONG,
        DbgDynProcessorEnabled: ULONG,
        DbgConsoleBrokerEnabled: ULONG,
        DbgSecureBootEnabled: ULONG,
        DbgMultiSessionSku: ULONG,
        DbgMultiUsersInSessionSku: ULONG,
        DbgStateSeparationEnabled: ULONG,
        SpareBits: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgErrorPortPresent: u32 = unsafe { ::std::mem::transmute(DbgErrorPortPresent) };
            DbgErrorPortPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgElevationEnabled: u32 = unsafe { ::std::mem::transmute(DbgElevationEnabled) };
            DbgElevationEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgVirtEnabled: u32 = unsafe { ::std::mem::transmute(DbgVirtEnabled) };
            DbgVirtEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgInstallerDetectEnabled: u32 =
                unsafe { ::std::mem::transmute(DbgInstallerDetectEnabled) };
            DbgInstallerDetectEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgLkgEnabled: u32 = unsafe { ::std::mem::transmute(DbgLkgEnabled) };
            DbgLkgEnabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgDynProcessorEnabled: u32 =
                unsafe { ::std::mem::transmute(DbgDynProcessorEnabled) };
            DbgDynProcessorEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgConsoleBrokerEnabled: u32 =
                unsafe { ::std::mem::transmute(DbgConsoleBrokerEnabled) };
            DbgConsoleBrokerEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DbgSecureBootEnabled: u32 = unsafe { ::std::mem::transmute(DbgSecureBootEnabled) };
            DbgSecureBootEnabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DbgMultiSessionSku: u32 = unsafe { ::std::mem::transmute(DbgMultiSessionSku) };
            DbgMultiSessionSku as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DbgMultiUsersInSessionSku: u32 =
                unsafe { ::std::mem::transmute(DbgMultiUsersInSessionSku) };
            DbgMultiUsersInSessionSku as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DbgStateSeparationEnabled: u32 =
                unsafe { ::std::mem::transmute(DbgStateSeparationEnabled) };
            DbgStateSeparationEnabled as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let SpareBits: u32 = unsafe { ::std::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_3 {
    #[doc = "offset: 0x320 (800)"]
    pub TickCount: _KSYSTEM_TIME,
    #[doc = "offset: 0x320 (800)"]
    pub TickCountQuad: ULONGLONG,
    #[doc = "offset: 0x320 (800)"]
    pub ReservedTickCountOverlay: [ULONG; 3usize],
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_4 {
    #[doc = "offset: 0x3c6 (966)"]
    pub QpcData: USHORT,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 {
    #[doc = "offset: 0x3c6 (966)"]
    pub QpcBypassEnabled: UCHAR,
    #[doc = "offset: 0x3c7 (967)"]
    pub QpcShift: UCHAR,
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KUSER_SHARED_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_MITIGATION_AUDIT_OPTIONS_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub Map: [ULONGLONG; 2usize],
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_MITIGATION_OPTIONS_MAP {
    #[doc = "offset: 0x0 (0)"]
    pub Map: [ULONGLONG; 2usize],
}
#[doc = "0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LIST_ENTRY64 {
    #[doc = "offset: 0x0 (0)"]
    pub Flink: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub Blink: ULONGLONG,
}
#[doc = "0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STACK64 {
    #[doc = "offset: 0x0 (0)"]
    pub ActiveFrame: ULONGLONG,
    #[doc = "offset: 0x8 (8)"]
    pub FrameListCache: LIST_ENTRY64,
    #[doc = "offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = "offset: 0x1c (28)"]
    pub NextCookieSequenceNumber: ULONG,
    #[doc = "offset: 0x20 (32)"]
    pub StackId: ULONG,
}
#[doc = "0x1838 (6200) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TEB64 {
    #[doc = "offset: 0x0 (0)"]
    pub NtTib: _NT_TIB64,
    #[doc = "offset: 0x38 (56)"]
    pub EnvironmentPointer: ULONGLONG,
    #[doc = "offset: 0x40 (64)"]
    pub ClientId: _CLIENT_ID64,
    #[doc = "offset: 0x50 (80)"]
    pub ActiveRpcHandle: ULONGLONG,
    #[doc = "offset: 0x58 (88)"]
    pub ThreadLocalStoragePointer: ULONGLONG,
    #[doc = "offset: 0x60 (96)"]
    pub ProcessEnvironmentBlock: ULONGLONG,
    #[doc = "offset: 0x68 (104)"]
    pub LastErrorValue: ULONG,
    #[doc = "offset: 0x6c (108)"]
    pub CountOfOwnedCriticalSections: ULONG,
    #[doc = "offset: 0x70 (112)"]
    pub CsrClientThread: ULONGLONG,
    #[doc = "offset: 0x78 (120)"]
    pub Win32ThreadInfo: ULONGLONG,
    #[doc = "offset: 0x80 (128)"]
    pub User32Reserved: [ULONG; 26usize],
    #[doc = "offset: 0xe8 (232)"]
    pub UserReserved: [ULONG; 5usize],
    #[doc = "offset: 0x100 (256)"]
    pub WOW32Reserved: ULONGLONG,
    #[doc = "offset: 0x108 (264)"]
    pub CurrentLocale: ULONG,
    #[doc = "offset: 0x10c (268)"]
    pub FpSoftwareStatusRegister: ULONG,
    #[doc = "offset: 0x110 (272)"]
    pub ReservedForDebuggerInstrumentation: [ULONGLONG; 16usize],
    #[doc = "offset: 0x190 (400)"]
    pub SystemReserved1: [ULONGLONG; 30usize],
    #[doc = "offset: 0x280 (640)"]
    pub PlaceholderCompatibilityMode: CHAR,
    #[doc = "offset: 0x281 (641)"]
    pub PlaceholderReserved: [CHAR; 11usize],
    #[doc = "offset: 0x28c (652)"]
    pub ProxiedProcessId: ULONG,
    #[doc = "offset: 0x290 (656)"]
    pub _ActivationStack: _ACTIVATION_CONTEXT_STACK64,
    #[doc = "offset: 0x2b8 (696)"]
    pub WorkingOnBehalfTicket: [UCHAR; 8usize],
    #[doc = "offset: 0x2c0 (704)"]
    pub ExceptionCode: LONG,
    #[doc = "offset: 0x2c4 (708)"]
    pub Padding0: [UCHAR; 4usize],
    #[doc = "offset: 0x2c8 (712)"]
    pub ActivationContextStackPointer: ULONGLONG,
    #[doc = "offset: 0x2d0 (720)"]
    pub InstrumentationCallbackSp: ULONGLONG,
    #[doc = "offset: 0x2d8 (728)"]
    pub InstrumentationCallbackPreviousPc: ULONGLONG,
    #[doc = "offset: 0x2e0 (736)"]
    pub InstrumentationCallbackPreviousSp: ULONGLONG,
    #[doc = "offset: 0x2e8 (744)"]
    pub TxFsContext: ULONG,
    #[doc = "offset: 0x2ec (748)"]
    pub InstrumentationCallbackDisabled: UCHAR,
    #[doc = "offset: 0x2ed (749)"]
    pub Padding1: [UCHAR; 3usize],
    #[doc = "offset: 0x2f0 (752)"]
    pub GdiTebBatch: _GDI_TEB_BATCH64,
    #[doc = "offset: 0x7d8 (2008)"]
    pub RealClientId: _CLIENT_ID64,
    #[doc = "offset: 0x7e8 (2024)"]
    pub GdiCachedProcessHandle: ULONGLONG,
    #[doc = "offset: 0x7f0 (2032)"]
    pub GdiClientPID: ULONG,
    #[doc = "offset: 0x7f4 (2036)"]
    pub GdiClientTID: ULONG,
    #[doc = "offset: 0x7f8 (2040)"]
    pub GdiThreadLocalInfo: ULONGLONG,
    #[doc = "offset: 0x800 (2048)"]
    pub Win32ClientInfo: [ULONGLONG; 62usize],
    #[doc = "offset: 0x9f0 (2544)"]
    pub glDispatchTable: [ULONGLONG; 233usize],
    #[doc = "offset: 0x1138 (4408)"]
    pub glReserved1: [ULONGLONG; 29usize],
    #[doc = "offset: 0x1220 (4640)"]
    pub glReserved2: ULONGLONG,
    #[doc = "offset: 0x1228 (4648)"]
    pub glSectionInfo: ULONGLONG,
    #[doc = "offset: 0x1230 (4656)"]
    pub glSection: ULONGLONG,
    #[doc = "offset: 0x1238 (4664)"]
    pub glTable: ULONGLONG,
    #[doc = "offset: 0x1240 (4672)"]
    pub glCurrentRC: ULONGLONG,
    #[doc = "offset: 0x1248 (4680)"]
    pub glContext: ULONGLONG,
    #[doc = "offset: 0x1250 (4688)"]
    pub LastStatusValue: ULONG,
    #[doc = "offset: 0x1254 (4692)"]
    pub Padding2: [UCHAR; 4usize],
    #[doc = "offset: 0x1258 (4696)"]
    pub StaticUnicodeString: _STRING64,
    #[doc = "offset: 0x1268 (4712)"]
    pub StaticUnicodeBuffer: [WCHAR; 261usize],
    #[doc = "offset: 0x1472 (5234)"]
    pub Padding3: [UCHAR; 6usize],
    #[doc = "offset: 0x1478 (5240)"]
    pub DeallocationStack: ULONGLONG,
    #[doc = "offset: 0x1480 (5248)"]
    pub TlsSlots: [ULONGLONG; 64usize],
    #[doc = "offset: 0x1680 (5760)"]
    pub TlsLinks: LIST_ENTRY64,
    #[doc = "offset: 0x1690 (5776)"]
    pub Vdm: ULONGLONG,
    #[doc = "offset: 0x1698 (5784)"]
    pub ReservedForNtRpc: ULONGLONG,
    #[doc = "offset: 0x16a0 (5792)"]
    pub DbgSsReserved: [ULONGLONG; 2usize],
    #[doc = "offset: 0x16b0 (5808)"]
    pub HardErrorMode: ULONG,
    #[doc = "offset: 0x16b4 (5812)"]
    pub Padding4: [UCHAR; 4usize],
    #[doc = "offset: 0x16b8 (5816)"]
    pub Instrumentation: [ULONGLONG; 11usize],
    #[doc = "offset: 0x1710 (5904)"]
    pub ActivityId: _GUID,
    #[doc = "offset: 0x1720 (5920)"]
    pub SubProcessTag: ULONGLONG,
    #[doc = "offset: 0x1728 (5928)"]
    pub PerflibData: ULONGLONG,
    #[doc = "offset: 0x1730 (5936)"]
    pub EtwTraceData: ULONGLONG,
    #[doc = "offset: 0x1738 (5944)"]
    pub WinSockData: ULONGLONG,
    #[doc = "offset: 0x1740 (5952)"]
    pub GdiBatchCount: ULONG,
    pub __bindgen_anon_1: _TEB64__bindgen_ty_1,
    #[doc = "offset: 0x1748 (5960)"]
    pub GuaranteedStackBytes: ULONG,
    #[doc = "offset: 0x174c (5964)"]
    pub Padding5: [UCHAR; 4usize],
    #[doc = "offset: 0x1750 (5968)"]
    pub ReservedForPerf: ULONGLONG,
    #[doc = "offset: 0x1758 (5976)"]
    pub ReservedForOle: ULONGLONG,
    #[doc = "offset: 0x1760 (5984)"]
    pub WaitingOnLoaderLock: ULONG,
    #[doc = "offset: 0x1764 (5988)"]
    pub Padding6: [UCHAR; 4usize],
    #[doc = "offset: 0x1768 (5992)"]
    pub SavedPriorityState: ULONGLONG,
    #[doc = "offset: 0x1770 (6000)"]
    pub ReservedForCodeCoverage: ULONGLONG,
    #[doc = "offset: 0x1778 (6008)"]
    pub ThreadPoolData: ULONGLONG,
    #[doc = "offset: 0x1780 (6016)"]
    pub TlsExpansionSlots: ULONGLONG,
    #[doc = "offset: 0x1788 (6024)"]
    pub DeallocationBStore: ULONGLONG,
    #[doc = "offset: 0x1790 (6032)"]
    pub BStoreLimit: ULONGLONG,
    #[doc = "offset: 0x1798 (6040)"]
    pub MuiGeneration: ULONG,
    #[doc = "offset: 0x179c (6044)"]
    pub IsImpersonating: ULONG,
    #[doc = "offset: 0x17a0 (6048)"]
    pub NlsCache: ULONGLONG,
    #[doc = "offset: 0x17a8 (6056)"]
    pub pShimData: ULONGLONG,
    #[doc = "offset: 0x17b0 (6064)"]
    pub HeapVirtualAffinity: USHORT,
    #[doc = "offset: 0x17b2 (6066)"]
    pub LowFragHeapDataSlot: USHORT,
    #[doc = "offset: 0x17b4 (6068)"]
    pub Padding7: [UCHAR; 4usize],
    #[doc = "offset: 0x17b8 (6072)"]
    pub CurrentTransactionHandle: ULONGLONG,
    #[doc = "offset: 0x17c0 (6080)"]
    pub ActiveFrame: ULONGLONG,
    #[doc = "offset: 0x17c8 (6088)"]
    pub FlsData: ULONGLONG,
    #[doc = "offset: 0x17d0 (6096)"]
    pub PreferredLanguages: ULONGLONG,
    #[doc = "offset: 0x17d8 (6104)"]
    pub UserPrefLanguages: ULONGLONG,
    #[doc = "offset: 0x17e0 (6112)"]
    pub MergedPrefLanguages: ULONGLONG,
    #[doc = "offset: 0x17e8 (6120)"]
    pub MuiImpersonation: ULONG,
    pub __bindgen_anon_2: _TEB64__bindgen_ty_2,
    pub __bindgen_anon_3: _TEB64__bindgen_ty_3,
    #[doc = "offset: 0x17f0 (6128)"]
    pub TxnScopeEnterCallback: ULONGLONG,
    #[doc = "offset: 0x17f8 (6136)"]
    pub TxnScopeExitCallback: ULONGLONG,
    #[doc = "offset: 0x1800 (6144)"]
    pub TxnScopeContext: ULONGLONG,
    #[doc = "offset: 0x1808 (6152)"]
    pub LockCount: ULONG,
    #[doc = "offset: 0x180c (6156)"]
    pub WowTebOffset: LONG,
    #[doc = "offset: 0x1810 (6160)"]
    pub ResourceRetValue: ULONGLONG,
    #[doc = "offset: 0x1818 (6168)"]
    pub ReservedForWdf: ULONGLONG,
    #[doc = "offset: 0x1820 (6176)"]
    pub ReservedForCrt: ULONGLONG,
    #[doc = "offset: 0x1828 (6184)"]
    pub EffectiveContainerId: _GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB64__bindgen_ty_1 {
    #[doc = "offset: 0x1744 (5956)"]
    pub CurrentIdealProcessor: _PROCESSOR_NUMBER,
    #[doc = "offset: 0x1744 (5956)"]
    pub IdealProcessorValue: ULONG,
    pub __bindgen_anon_1: _TEB64__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB64__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "offset: 0x1744 (5956)"]
    pub ReservedPad0: UCHAR,
    #[doc = "offset: 0x1745 (5957)"]
    pub ReservedPad1: UCHAR,
    #[doc = "offset: 0x1746 (5958)"]
    pub ReservedPad2: UCHAR,
    #[doc = "offset: 0x1747 (5959)"]
    pub IdealProcessor: UCHAR,
}
impl Default for _TEB64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB64__bindgen_ty_2 {
    #[doc = "offset: 0x17ec (6124)"]
    pub CrossTebFlags: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB64__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _TEB64__bindgen_ty_2 {
    #[inline]
    pub fn SpareCrossTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let SpareCrossTebBits: u16 = unsafe { ::std::mem::transmute(SpareCrossTebBits) };
            SpareCrossTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB64__bindgen_ty_3 {
    #[doc = "offset: 0x17ee (6126)"]
    pub SameTebFlags: USHORT,
    pub __bindgen_anon_1: _TEB64__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB64__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB64__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SafeThunkCall(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SafeThunkCall(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InDebugPrint(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InDebugPrint(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasFiberData(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HasFiberData(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipThreadAttach(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SkipThreadAttach(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WerInShipAssertCode(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WerInShipAssertCode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RanProcessInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RanProcessInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClonedThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ClonedThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SuppressDebugMsg(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SuppressDebugMsg(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableUserStackWalk(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DisableUserStackWalk(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlExceptionAttached(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InitialThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InitialThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SessionAware(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SessionAware(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoadOwner(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoadOwner(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LoaderWorker(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoaderWorker(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipLoaderInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SkipLoaderInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareSameTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SafeThunkCall: USHORT,
        InDebugPrint: USHORT,
        HasFiberData: USHORT,
        SkipThreadAttach: USHORT,
        WerInShipAssertCode: USHORT,
        RanProcessInit: USHORT,
        ClonedThread: USHORT,
        SuppressDebugMsg: USHORT,
        DisableUserStackWalk: USHORT,
        RtlExceptionAttached: USHORT,
        InitialThread: USHORT,
        SessionAware: USHORT,
        LoadOwner: USHORT,
        LoaderWorker: USHORT,
        SkipLoaderInit: USHORT,
        SpareSameTebBits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SafeThunkCall: u16 = unsafe { ::std::mem::transmute(SafeThunkCall) };
            SafeThunkCall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InDebugPrint: u16 = unsafe { ::std::mem::transmute(InDebugPrint) };
            InDebugPrint as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HasFiberData: u16 = unsafe { ::std::mem::transmute(HasFiberData) };
            HasFiberData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SkipThreadAttach: u16 = unsafe { ::std::mem::transmute(SkipThreadAttach) };
            SkipThreadAttach as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WerInShipAssertCode: u16 = unsafe { ::std::mem::transmute(WerInShipAssertCode) };
            WerInShipAssertCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RanProcessInit: u16 = unsafe { ::std::mem::transmute(RanProcessInit) };
            RanProcessInit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ClonedThread: u16 = unsafe { ::std::mem::transmute(ClonedThread) };
            ClonedThread as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SuppressDebugMsg: u16 = unsafe { ::std::mem::transmute(SuppressDebugMsg) };
            SuppressDebugMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DisableUserStackWalk: u16 = unsafe { ::std::mem::transmute(DisableUserStackWalk) };
            DisableUserStackWalk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RtlExceptionAttached: u16 = unsafe { ::std::mem::transmute(RtlExceptionAttached) };
            RtlExceptionAttached as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let InitialThread: u16 = unsafe { ::std::mem::transmute(InitialThread) };
            InitialThread as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let SessionAware: u16 = unsafe { ::std::mem::transmute(SessionAware) };
            SessionAware as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LoadOwner: u16 = unsafe { ::std::mem::transmute(LoadOwner) };
            LoadOwner as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LoaderWorker: u16 = unsafe { ::std::mem::transmute(LoaderWorker) };
            LoaderWorker as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let SkipLoaderInit: u16 = unsafe { ::std::mem::transmute(SkipLoaderInit) };
            SkipLoaderInit as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SpareSameTebBits: u16 = unsafe { ::std::mem::transmute(SpareSameTebBits) };
            SpareSameTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TEB64__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TEB64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
