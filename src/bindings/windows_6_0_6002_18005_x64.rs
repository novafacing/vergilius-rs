/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
#[doc = " Convenience types."]
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
#[doc = " These few don't really vary by system, they always correspond\nto one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,\neven in the presence of asynchronous interrupts.\nIt is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ADAPTER_OBJECT {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ACTIVATION_CONTEXT_DATA {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_LOCAL_SEGMENT_INFO {}
pub type CHAR = i8;
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTMNOTIFICATION_PACKET {}
pub type LONGLONG = i64;
pub type ULONG = u32;
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMVAD_FLAGS2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMVAD_FLAGS2 {
    #[inline]
    pub fn FileOffset(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_FileOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn SecNoChange(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecNoChange(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OneSecured(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OneSecured(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MultipleSecured(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleSecured(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LongVad(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LongVad(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendableFile(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendableFile(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Inherit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Inherit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FileOffset: ULONG,
        SecNoChange: ULONG,
        OneSecured: ULONG,
        MultipleSecured: ULONG,
        Spare: ULONG,
        LongVad: ULONG,
        ExtendableFile: ULONG,
        Inherit: ULONG,
        CopyOnWrite: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let FileOffset: u32 = unsafe { ::std::mem::transmute(FileOffset) };
            FileOffset as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let SecNoChange: u32 = unsafe { ::std::mem::transmute(SecNoChange) };
            SecNoChange as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let OneSecured: u32 = unsafe { ::std::mem::transmute(OneSecured) };
            OneSecured as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let MultipleSecured: u32 = unsafe { ::std::mem::transmute(MultipleSecured) };
            MultipleSecured as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let LongVad: u32 = unsafe { ::std::mem::transmute(LongVad) };
            LongVad as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ExtendableFile: u32 = unsafe { ::std::mem::transmute(ExtendableFile) };
            ExtendableFile as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Inherit: u32 = unsafe { ::std::mem::transmute(Inherit) };
            Inherit as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let CopyOnWrite: u32 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMSECTION_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMSECTION_FLAGS {
    #[inline]
    pub fn BeingDeleted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BeingDeleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BeingCreated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BeingCreated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BeingPurged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BeingPurged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoModifiedWriting(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoModifiedWriting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FailAllIo(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FailAllIo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Image(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Image(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Based(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Based(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn File(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_File(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Networked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Networked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Rom(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rom(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalMemory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PhysicalMemory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserve(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserve(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Commit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Commit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WasPurged(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WasPurged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalMemory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GlobalMemory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeleteOnClose(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeleteOnClose(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FilePointerNull(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FilePointerNull(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalOnlyPerSession(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GlobalOnlyPerSession(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetMappedFileIoComplete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetMappedFileIoComplete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CollidedFlush(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CollidedFlush(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoChange(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoChange(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserWritable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserWritable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferredNode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_PreferredNode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BeingDeleted: ULONG,
        BeingCreated: ULONG,
        BeingPurged: ULONG,
        NoModifiedWriting: ULONG,
        FailAllIo: ULONG,
        Image: ULONG,
        Based: ULONG,
        File: ULONG,
        Networked: ULONG,
        Rom: ULONG,
        PhysicalMemory: ULONG,
        CopyOnWrite: ULONG,
        Reserve: ULONG,
        Commit: ULONG,
        Accessed: ULONG,
        WasPurged: ULONG,
        UserReference: ULONG,
        GlobalMemory: ULONG,
        DeleteOnClose: ULONG,
        FilePointerNull: ULONG,
        GlobalOnlyPerSession: ULONG,
        SetMappedFileIoComplete: ULONG,
        CollidedFlush: ULONG,
        NoChange: ULONG,
        Spare: ULONG,
        UserWritable: ULONG,
        PreferredNode: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BeingDeleted: u32 = unsafe { ::std::mem::transmute(BeingDeleted) };
            BeingDeleted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BeingCreated: u32 = unsafe { ::std::mem::transmute(BeingCreated) };
            BeingCreated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BeingPurged: u32 = unsafe { ::std::mem::transmute(BeingPurged) };
            BeingPurged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoModifiedWriting: u32 = unsafe { ::std::mem::transmute(NoModifiedWriting) };
            NoModifiedWriting as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FailAllIo: u32 = unsafe { ::std::mem::transmute(FailAllIo) };
            FailAllIo as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Image: u32 = unsafe { ::std::mem::transmute(Image) };
            Image as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Based: u32 = unsafe { ::std::mem::transmute(Based) };
            Based as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let File: u32 = unsafe { ::std::mem::transmute(File) };
            File as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Networked: u32 = unsafe { ::std::mem::transmute(Networked) };
            Networked as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Rom: u32 = unsafe { ::std::mem::transmute(Rom) };
            Rom as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PhysicalMemory: u32 = unsafe { ::std::mem::transmute(PhysicalMemory) };
            PhysicalMemory as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CopyOnWrite: u32 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Reserve: u32 = unsafe { ::std::mem::transmute(Reserve) };
            Reserve as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Commit: u32 = unsafe { ::std::mem::transmute(Commit) };
            Commit as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Accessed: u32 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WasPurged: u32 = unsafe { ::std::mem::transmute(WasPurged) };
            WasPurged as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UserReference: u32 = unsafe { ::std::mem::transmute(UserReference) };
            UserReference as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let GlobalMemory: u32 = unsafe { ::std::mem::transmute(GlobalMemory) };
            GlobalMemory as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DeleteOnClose: u32 = unsafe { ::std::mem::transmute(DeleteOnClose) };
            DeleteOnClose as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let FilePointerNull: u32 = unsafe { ::std::mem::transmute(FilePointerNull) };
            FilePointerNull as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let GlobalOnlyPerSession: u32 = unsafe { ::std::mem::transmute(GlobalOnlyPerSession) };
            GlobalOnlyPerSession as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let SetMappedFileIoComplete: u32 =
                unsafe { ::std::mem::transmute(SetMappedFileIoComplete) };
            SetMappedFileIoComplete as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let CollidedFlush: u32 = unsafe { ::std::mem::transmute(CollidedFlush) };
            CollidedFlush as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let NoChange: u32 = unsafe { ::std::mem::transmute(NoChange) };
            NoChange as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let UserWritable: u32 = unsafe { ::std::mem::transmute(UserWritable) };
            UserWritable as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let PreferredNode: u32 = unsafe { ::std::mem::transmute(PreferredNode) };
            PreferredNode as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SHORT = i16;
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SMBIOS_TABLE_HEADER {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SETUP_LOADER_BLOCK {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ECP_LIST {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SCSI_REQUEST_BLOCK {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FLS_CALLBACK_INFO {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ASSEMBLY_STORAGE_MAP {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _JOB_ACCESS_STATE {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PAGEFAULT_HISTORY {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EPROCESS_QUOTA_BLOCK {}
pub type WCHAR = u16;
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_ADD_RESERVED_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub ReserveDevice: *mut _DEVICE_OBJECT,
}
impl Default for _ARBITER_ADD_RESERVED_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PSP_RATE_APC {
    _unused: [u8; 0],
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SLIST_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _SLIST_ENTRY,
}
impl Default for _SLIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LONG = i32;
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MI_DYNAMIC_MEMORY_LOCKTYPE {
    AlreadyHeld = 0,
    AcquiredShared = 1,
    UseSpinLock = 2,
    UseSpinLockRaiseIrql = 3,
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreDeleteKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtDeleteKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreSetValueKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtSetValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreDeleteValueKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtDeleteValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreSetInformationKey: _REG_NOTIFY_CLASS =
        _REG_NOTIFY_CLASS::RegNtSetInformationKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreRenameKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtRenameKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreEnumerateKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtEnumerateKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreEnumerateValueKey: _REG_NOTIFY_CLASS =
        _REG_NOTIFY_CLASS::RegNtEnumerateValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreQueryKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtQueryKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreQueryValueKey: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtQueryValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreQueryMultipleValueKey: _REG_NOTIFY_CLASS =
        _REG_NOTIFY_CLASS::RegNtQueryMultipleValueKey;
}
impl _REG_NOTIFY_CLASS {
    pub const RegNtPreKeyHandleClose: _REG_NOTIFY_CLASS = _REG_NOTIFY_CLASS::RegNtKeyHandleClose;
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _REG_NOTIFY_CLASS {
    RegNtDeleteKey = 0,
    RegNtSetValueKey = 1,
    RegNtDeleteValueKey = 2,
    RegNtSetInformationKey = 3,
    RegNtRenameKey = 4,
    RegNtEnumerateKey = 5,
    RegNtEnumerateValueKey = 6,
    RegNtQueryKey = 7,
    RegNtQueryValueKey = 8,
    RegNtQueryMultipleValueKey = 9,
    RegNtPreCreateKey = 10,
    RegNtPostCreateKey = 11,
    RegNtPreOpenKey = 12,
    RegNtPostOpenKey = 13,
    RegNtKeyHandleClose = 14,
    RegNtPostDeleteKey = 15,
    RegNtPostSetValueKey = 16,
    RegNtPostDeleteValueKey = 17,
    RegNtPostSetInformationKey = 18,
    RegNtPostRenameKey = 19,
    RegNtPostEnumerateKey = 20,
    RegNtPostEnumerateValueKey = 21,
    RegNtPostQueryKey = 22,
    RegNtPostQueryValueKey = 23,
    RegNtPostQueryMultipleValueKey = 24,
    RegNtPostKeyHandleClose = 25,
    RegNtPreCreateKeyEx = 26,
    RegNtPostCreateKeyEx = 27,
    RegNtPreOpenKeyEx = 28,
    RegNtPostOpenKeyEx = 29,
    RegNtPreFlushKey = 30,
    RegNtPostFlushKey = 31,
    RegNtPreLoadKey = 32,
    RegNtPostLoadKey = 33,
    RegNtPreUnLoadKey = 34,
    RegNtPostUnLoadKey = 35,
    RegNtPreQueryKeySecurity = 36,
    RegNtPostQueryKeySecurity = 37,
    RegNtPreSetKeySecurity = 38,
    RegNtPostSetKeySecurity = 39,
    RegNtCallbackObjectContextCleanup = 40,
    RegNtPreRestoreKey = 41,
    RegNtPostRestoreKey = 42,
    RegNtPreSaveKey = 43,
    RegNtPostSaveKey = 44,
    RegNtPreReplaceKey = 45,
    RegNtPostReplaceKey = 46,
    MaxRegNtNotifyClass = 47,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _WOW64_SHARED_INFORMATION {
    SharedNtdll32LdrInitializeThunk = 0,
    SharedNtdll32KiUserExceptionDispatcher = 1,
    SharedNtdll32KiUserApcDispatcher = 2,
    SharedNtdll32KiUserCallbackDispatcher = 3,
    SharedNtdll32LdrHotPatchRoutine = 4,
    SharedNtdll32ExpInterlockedPopEntrySListFault = 5,
    SharedNtdll32ExpInterlockedPopEntrySListResume = 6,
    SharedNtdll32ExpInterlockedPopEntrySListEnd = 7,
    SharedNtdll32RtlUserThreadStart = 8,
    SharedNtdll32pQueryProcessDebugInformationRemote = 9,
    SharedNtdll32EtwpNotificationThread = 10,
    SharedNtdll32BaseAddress = 11,
    Wow64SharedPageEntriesCount = 12,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MM_POOL_FAILURE_REASONS {
    MmNonPagedNoPtes = 0,
    MmPriorityTooLow = 1,
    MmNonPagedNoPagesAvailable = 2,
    MmPagedNoPtes = 3,
    MmSessionPagedNoPtes = 4,
    MmPagedNoPagesAvailable = 5,
    MmSessionPagedNoPagesAvailable = 6,
    MmPagedNoCommit = 7,
    MmSessionPagedNoCommit = 8,
    MmNonPagedNoResidentAvailable = 9,
    MmNonPagedNoCommit = 10,
    MmMaximumFailureReason = 11,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation = 0,
    ObjectNameInformation = 1,
    ObjectTypeInformation = 2,
    ObjectTypesInformation = 3,
    ObjectHandleFlagInformation = 4,
    ObjectSessionInformation = 5,
    MaxObjectInfoClass = 6,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KTHREAD_STATE {
    Initialized = 0,
    Ready = 1,
    Running = 2,
    Standby = 3,
    Terminated = 4,
    Waiting = 5,
    Transition = 6,
    DeferredReady = 7,
    GateWait = 8,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MI_VAD_TYPE {
    VadNone = 0,
    VadDevicePhysicalMemory = 1,
    VadImageMap = 2,
    VadAwe = 3,
    VadWriteWatch = 4,
    VadLargePages = 5,
    VadRotatePhysical = 6,
    VadLargePageSection = 7,
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VERSION_MAJOR_V2: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VERSION_MAJOR: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_DELETED_NAME_LENGTH: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLEGAP_NAME_LENGTH: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const NATIVE_TYPE_MAX_CB: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_METHODRVA: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_EHRVA: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_BASICBLOCK: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_32BIT: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_64BIT: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_FROM_UNMANAGED: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_IL_LIBRARY;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_CALL_MOST_DERIVED: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_NATIVE_ENTRYPOINT;
}
impl ReplacesCorHdrNumericDefines {
    pub const MAX_PACKAGE_NAME: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::MAX_CLASS_NAME;
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ReplacesCorHdrNumericDefines {
    COMIMAGE_FLAGS_ILONLY = 1,
    COMIMAGE_FLAGS_32BITREQUIRED = 2,
    COMIMAGE_FLAGS_IL_LIBRARY = 4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
    COR_VERSION_MINOR = 0,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PS_STD_HANDLE_STATE {
    PsNeverDuplicate = 0,
    PsRequestDuplicate = 1,
    PsAlwaysDuplicate = 2,
    PsMaxStdHandleStates = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _POLICY_AUDIT_EVENT_TYPE {
    AuditCategorySystem = 0,
    AuditCategoryLogon = 1,
    AuditCategoryObjectAccess = 2,
    AuditCategoryPrivilegeUse = 3,
    AuditCategoryDetailedTracking = 4,
    AuditCategoryPolicyChange = 5,
    AuditCategoryAccountManagement = 6,
    AuditCategoryDirectoryServiceAccess = 7,
    AuditCategoryAccountLogon = 8,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    GateObject = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject = 18,
    DpcObject = 19,
    DeviceQueueObject = 20,
    EventPairObject = 21,
    InterruptObject = 22,
    ProfileObject = 23,
    ThreadedDpcObject = 24,
    MaximumKernelObject = 25,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _INTERLOCKED_RESULT {
    ResultNegative = 1,
    ResultZero = 0,
    ResultPositive = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MODE {
    KernelMode = 0,
    UserMode = 1,
    MaximumMode = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MM_POOL_PRIORITIES {
    MmHighPriority = 0,
    MmNormalPriority = 1,
    MmLowPriority = 2,
    MmMaximumPoolPriority = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PCI_HOTPLUG_SLOT_INTERRUPT {
    SlotInterruptPresenceDetect = 0,
    SlotInterruptLatchChange = 1,
    SlotInterruptAttentionButton = 2,
    SlotInterruptLinkStateChange = 3,
    SlotInterruptPowerFault = 4,
    SlotInterruptMaximum = 7,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MM_POOL_TYPES {
    MmNonPagedPool = 0,
    MmPagedPool = 1,
    MmSessionPagedPool = 2,
    MmMaximumPoolType = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum PS_CREATE_STATE {
    PsCreateInitialState = 0,
    PsCreateFailOnFileOpen = 1,
    PsCreateFailOnSectionCreate = 2,
    PsCreateFailExeFormat = 3,
    PsCreateFailMachineMismatch = 4,
    PsCreateFailExeName = 5,
    PsCreateSuccess = 6,
    PsCreateMaximumStates = 7,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MI_SYSTEM_VA_TYPE {
    MiVaUnused = 0,
    MiVaSessionSpace = 1,
    MiVaProcessSpace = 2,
    MiVaBootLoaded = 3,
    MiVaPfnDatabase = 4,
    MiVaNonPagedPool = 5,
    MiVaPagedPool = 6,
    MiVaSpecialPool = 7,
    MiVaSystemCache = 8,
    MiVaSystemPtes = 9,
    MiVaHal = 10,
    MiVaSessionGlobalSpace = 11,
    MiVaDriverImages = 12,
    MiVaMaximumType = 13,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _VI_CNT_INDEX_TYPE {
    VF_CNT_IRPS_TOTAL_COUNT = 0,
    VF_CNT_IRPS_NOT_A_TARGET = 1,
    VF_CNT_IRPS_KMODE = 2,
    VF_CNT_IRPS_SKIP_FLAGS = 3,
    VF_CNT_IRPS_ALREADY_HOOKED = 4,
    VF_CNT_IRPS_WILL_ATTEMPT_CANCEL = 5,
    VF_CNT_IRPS_WILL_NOT_CANCEL = 6,
    VF_CNT_REAL_RACE_FOR_COMPLETION = 7,
    VF_CNT_IRPS_COMPLETED_BY_DRIVER = 8,
    VF_CNT_IRPS_COMPLETED_BY_CANCEL = 9,
    VF_CNT_IRPS_NO_CANCEL_ROUTINE = 10,
    VF_CNT_IRPS_CANCEL_RETURNED_TRUE = 11,
    VF_CNT_IRPS_CANCEL_RETURNED_FALSE = 12,
    VF_CNT_IRP_CANCEL_ROUTINE_NO_CHECK = 13,
    VF_CNT_IRP_CANCEL_ROUTINE_NEVER = 14,
    VF_CNT_IRP_CANCEL_ROUTINE_SOMETIMES = 15,
    VF_CNT_EXTRA_ALLOCS = 16,
    VF_CNT_EXTRA_FREES = 17,
    VF_CNT_CALLS_TO_TIMER_DPC = 18,
    VF_CNT_CALLS_TO_CANCEL_WORKER = 19,
    VF_CNT_FREE_FROM_CANCEL_ROUTINE = 20,
    VF_CNT_FREE_FROM_COMPLETION_ROUTINE = 21,
    VF_CNT_ISSUES_LOGGED = 22,
    VF_CNT_CANCEL_AND_COMPLETE_DIFFERENT_THREADS = 23,
    VF_CNT_IRPS_TOO_MANY_UNDER_WATCH = 24,
    VF_CNT_MAX_INDEX = 25,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum SYSTEM_POWER_CONDITION {
    PoAc = 0,
    PoDc = 1,
    PoHot = 2,
    PoConditionMaximum = 3,
}
impl LSA_FOREST_TRUST_RECORD_TYPE {
    pub const ForestTrustRecordTypeLast: LSA_FOREST_TRUST_RECORD_TYPE =
        LSA_FOREST_TRUST_RECORD_TYPE::ForestTrustDomainInfo;
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum LSA_FOREST_TRUST_RECORD_TYPE {
    ForestTrustTopLevelName = 0,
    ForestTrustTopLevelNameEx = 1,
    ForestTrustDomainInfo = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MM_PREEMPTIVE_TRIMS {
    MmPreemptForNonPaged = 0,
    MmPreemptForPaged = 1,
    MmPreemptForNonPagedPriority = 2,
    MmPreemptForPagedPriority = 3,
    MmMaximumPreempt = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PS_IFEO_KEY_STATE {
    PsReadIFEOAllValues = 0,
    PsSkipIFEODebugger = 1,
    PsSkipAllIFEO = 2,
    PsMaxIFEOKeyStates = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _DPFLTR_TYPE {
    DPFLTR_SYSTEM_ID = 0,
    DPFLTR_SMSS_ID = 1,
    DPFLTR_SETUP_ID = 2,
    DPFLTR_NTFS_ID = 3,
    DPFLTR_FSTUB_ID = 4,
    DPFLTR_CRASHDUMP_ID = 5,
    DPFLTR_CDAUDIO_ID = 6,
    DPFLTR_CDROM_ID = 7,
    DPFLTR_CLASSPNP_ID = 8,
    DPFLTR_DISK_ID = 9,
    DPFLTR_REDBOOK_ID = 10,
    DPFLTR_STORPROP_ID = 11,
    DPFLTR_SCSIPORT_ID = 12,
    DPFLTR_SCSIMINIPORT_ID = 13,
    DPFLTR_CONFIG_ID = 14,
    DPFLTR_I8042PRT_ID = 15,
    DPFLTR_SERMOUSE_ID = 16,
    DPFLTR_LSERMOUS_ID = 17,
    DPFLTR_KBDHID_ID = 18,
    DPFLTR_MOUHID_ID = 19,
    DPFLTR_KBDCLASS_ID = 20,
    DPFLTR_MOUCLASS_ID = 21,
    DPFLTR_TWOTRACK_ID = 22,
    DPFLTR_WMILIB_ID = 23,
    DPFLTR_ACPI_ID = 24,
    DPFLTR_AMLI_ID = 25,
    DPFLTR_HALIA64_ID = 26,
    DPFLTR_VIDEO_ID = 27,
    DPFLTR_SVCHOST_ID = 28,
    DPFLTR_VIDEOPRT_ID = 29,
    DPFLTR_TCPIP_ID = 30,
    DPFLTR_DMSYNTH_ID = 31,
    DPFLTR_NTOSPNP_ID = 32,
    DPFLTR_FASTFAT_ID = 33,
    DPFLTR_SAMSS_ID = 34,
    DPFLTR_PNPMGR_ID = 35,
    DPFLTR_NETAPI_ID = 36,
    DPFLTR_SCSERVER_ID = 37,
    DPFLTR_SCCLIENT_ID = 38,
    DPFLTR_SERIAL_ID = 39,
    DPFLTR_SERENUM_ID = 40,
    DPFLTR_UHCD_ID = 41,
    DPFLTR_RPCPROXY_ID = 42,
    DPFLTR_AUTOCHK_ID = 43,
    DPFLTR_DCOMSS_ID = 44,
    DPFLTR_UNIMODEM_ID = 45,
    DPFLTR_SIS_ID = 46,
    DPFLTR_FLTMGR_ID = 47,
    DPFLTR_WMICORE_ID = 48,
    DPFLTR_BURNENG_ID = 49,
    DPFLTR_IMAPI_ID = 50,
    DPFLTR_SXS_ID = 51,
    DPFLTR_FUSION_ID = 52,
    DPFLTR_IDLETASK_ID = 53,
    DPFLTR_SOFTPCI_ID = 54,
    DPFLTR_TAPE_ID = 55,
    DPFLTR_MCHGR_ID = 56,
    DPFLTR_IDEP_ID = 57,
    DPFLTR_PCIIDE_ID = 58,
    DPFLTR_FLOPPY_ID = 59,
    DPFLTR_FDC_ID = 60,
    DPFLTR_TERMSRV_ID = 61,
    DPFLTR_W32TIME_ID = 62,
    DPFLTR_PREFETCHER_ID = 63,
    DPFLTR_RSFILTER_ID = 64,
    DPFLTR_FCPORT_ID = 65,
    DPFLTR_PCI_ID = 66,
    DPFLTR_DMIO_ID = 67,
    DPFLTR_DMCONFIG_ID = 68,
    DPFLTR_DMADMIN_ID = 69,
    DPFLTR_WSOCKTRANSPORT_ID = 70,
    DPFLTR_VSS_ID = 71,
    DPFLTR_PNPMEM_ID = 72,
    DPFLTR_PROCESSOR_ID = 73,
    DPFLTR_DMSERVER_ID = 74,
    DPFLTR_SR_ID = 75,
    DPFLTR_INFINIBAND_ID = 76,
    DPFLTR_IHVDRIVER_ID = 77,
    DPFLTR_IHVVIDEO_ID = 78,
    DPFLTR_IHVAUDIO_ID = 79,
    DPFLTR_IHVNETWORK_ID = 80,
    DPFLTR_IHVSTREAMING_ID = 81,
    DPFLTR_IHVBUS_ID = 82,
    DPFLTR_HPS_ID = 83,
    DPFLTR_RTLTHREADPOOL_ID = 84,
    DPFLTR_LDR_ID = 85,
    DPFLTR_TCPIP6_ID = 86,
    DPFLTR_ISAPNP_ID = 87,
    DPFLTR_SHPC_ID = 88,
    DPFLTR_STORPORT_ID = 89,
    DPFLTR_STORMINIPORT_ID = 90,
    DPFLTR_PRINTSPOOLER_ID = 91,
    DPFLTR_VSSDYNDISK_ID = 92,
    DPFLTR_VERIFIER_ID = 93,
    DPFLTR_VDS_ID = 94,
    DPFLTR_VDSBAS_ID = 95,
    DPFLTR_VDSDYN_ID = 96,
    DPFLTR_VDSDYNDR_ID = 97,
    DPFLTR_VDSLDR_ID = 98,
    DPFLTR_VDSUTIL_ID = 99,
    DPFLTR_DFRGIFC_ID = 100,
    DPFLTR_DEFAULT_ID = 101,
    DPFLTR_MM_ID = 102,
    DPFLTR_DFSC_ID = 103,
    DPFLTR_WOW64_ID = 104,
    DPFLTR_ALPC_ID = 105,
    DPFLTR_WDI_ID = 106,
    DPFLTR_PERFLIB_ID = 107,
    DPFLTR_KTM_ID = 108,
    DPFLTR_IOSTRESS_ID = 109,
    DPFLTR_HEAP_ID = 110,
    DPFLTR_WHEA_ID = 111,
    DPFLTR_USERGDI_ID = 112,
    DPFLTR_MMCSS_ID = 113,
    DPFLTR_TPM_ID = 114,
    DPFLTR_THREADORDER_ID = 115,
    DPFLTR_ENVIRON_ID = 116,
    DPFLTR_EMS_ID = 117,
    DPFLTR_WDT_ID = 118,
    DPFLTR_FVEVOL_ID = 119,
    DPFLTR_NDIS_ID = 120,
    DPFLTR_NVCTRACE_ID = 121,
    DPFLTR_LUAFV_ID = 122,
    DPFLTR_APPCOMPAT_ID = 123,
    DPFLTR_USBSTOR_ID = 124,
    DPFLTR_SBP2PORT_ID = 125,
    DPFLTR_COVERAGE_ID = 126,
    DPFLTR_CACHEMGR_ID = 127,
    DPFLTR_MOUNTMGR_ID = 128,
    DPFLTR_CFR_ID = 129,
    DPFLTR_TXF_ID = 130,
    DPFLTR_KSECDD_ID = 131,
    DPFLTR_FLTREGRESS_ID = 132,
    DPFLTR_MPIO_ID = 133,
    DPFLTR_MSDSM_ID = 134,
    DPFLTR_UDFS_ID = 135,
    DPFLTR_PSHED_ID = 136,
    DPFLTR_STORVSP_ID = 137,
    DPFLTR_EXFAT_ID = 138,
    DPFLTR_ENDOFTABLE_ID = 139,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PS_RESOURCE_TYPE {
    PsResourceNonPagedPool = 0,
    PsResourcePagedPool = 1,
    PsResourcePageFile = 2,
    PsResourceWorkingSet = 3,
    PsResourceCpuRate = 4,
    PsResourceMax = 5,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PS_ATTRIBUTE_NUM {
    PsAttributeParentProcess = 0,
    PsAttributeDebugObject = 1,
    PsAttributeToken = 2,
    PsAttributeClientId = 3,
    PsAttributeTebAddress = 4,
    PsAttributeImageName = 5,
    PsAttributeImageInfo = 6,
    PsAttributeMemoryReserve = 7,
    PsAttributePriorityClass = 8,
    PsAttributeErrorMode = 9,
    PsAttributeStdHandleInfo = 10,
    PsAttributeHandleList = 11,
    PsAttributeMax = 12,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _WAIT_TYPE {
    WaitAll = 0,
    WaitAny = 1,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrEventPair = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    Spare2 = 21,
    Spare3 = 22,
    Spare4 = 23,
    Spare5 = 24,
    WrCalloutStack = 25,
    WrKernel = 26,
    WrResource = 27,
    WrPushLock = 28,
    WrMutex = 29,
    WrQuantumEnd = 30,
    WrDispatchInt = 31,
    WrPreempted = 32,
    WrYieldExecution = 33,
    WrFastMutex = 34,
    WrGuardedMutex = 35,
    WrRundown = 36,
    MaximumWaitReason = 37,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ETW_GUID_TYPE {
    EtwTraceGuidType = 0,
    EtwNotificationGuidType = 1,
    EtwGuidTypeMax = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _HEAP_FAILURE_TYPE {
    heap_failure_internal = 0,
    heap_failure_unknown = 1,
    heap_failure_generic = 2,
    heap_failure_entry_corruption = 3,
    heap_failure_multiple_entries_corruption = 4,
    heap_failure_virtual_block_corruption = 5,
    heap_failure_buffer_overrun = 6,
    heap_failure_buffer_underrun = 7,
    heap_failure_block_not_busy = 8,
    heap_failure_invalid_argument = 9,
    heap_failure_usage_after_free = 10,
    heap_failure_cross_heap_operation = 11,
    heap_failure_freelists_corruption = 12,
    heap_failure_listentry_corruption = 13,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _IO_PAGING_PRIORITY {
    IoPagingPriorityInvalid = 0,
    IoPagingPriorityNormal = 1,
    IoPagingPriorityHigh = 2,
    IoPagingPriorityReserved1 = 3,
    IoPagingPriorityReserved2 = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MI_PFN_CACHE_ATTRIBUTE {
    MiNonCached = 0,
    MiCached = 1,
    MiWriteCombined = 2,
    MiNotMapped = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PF_FILE_ACCESS_TYPE {
    PfFileAccessTypeRead = 0,
    PfFileAccessTypeWrite = 1,
    PfFileAccessTypeMax = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PP_NPAGED_LOOKASIDE_NUMBER {
    LookasideSmallIrpList = 0,
    LookasideLargeIrpList = 1,
    LookasideMdlList = 2,
    LookasideCreateInfoList = 3,
    LookasideNameBufferList = 4,
    LookasideTwilightList = 5,
    LookasideCompletionList = 6,
    LookasideScratchBufferList = 7,
    LookasideMaximumList = 8,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _EVENT_TYPE {
    NotificationEvent = 0,
    SynchronizationEvent = 1,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PLUGPLAY_EVENT_CATEGORY {
    HardwareProfileChangeEvent = 0,
    TargetDeviceChangeEvent = 1,
    DeviceClassChangeEvent = 2,
    CustomDeviceEvent = 3,
    DeviceInstallEvent = 4,
    DeviceArrivalEvent = 5,
    PowerEvent = 6,
    VetoEvent = 7,
    BlockedDriverEvent = 8,
    InvalidIDEvent = 9,
    PowerSettingChange = 10,
    MaxPlugEventCategory = 11,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PNP_VETO_TYPE {
    PNP_VetoTypeUnknown = 0,
    PNP_VetoLegacyDevice = 1,
    PNP_VetoPendingClose = 2,
    PNP_VetoWindowsApp = 3,
    PNP_VetoWindowsService = 4,
    PNP_VetoOutstandingOpen = 5,
    PNP_VetoDevice = 6,
    PNP_VetoDriver = 7,
    PNP_VetoIllegalDeviceRequest = 8,
    PNP_VetoInsufficientPower = 9,
    PNP_VetoNonDisableable = 10,
    PNP_VetoLegacyDriver = 11,
    PNP_VetoInsufficientRights = 12,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MMLISTS {
    ZeroedPageList = 0,
    FreePageList = 1,
    StandbyPageList = 2,
    ModifiedPageList = 3,
    ModifiedNoWritePageList = 4,
    BadPageList = 5,
    ActiveAndValid = 6,
    TransitionPage = 7,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _VI_DEADLOCK_RESOURCE_TYPE {
    VfDeadlockUnknown = 0,
    VfDeadlockMutex = 1,
    VfDeadlockMutexAbandoned = 2,
    VfDeadlockFastMutex = 3,
    VfDeadlockFastMutexUnsafe = 4,
    VfDeadlockSpinLock = 5,
    VfDeadlockTypeMaximum = 6,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ETW_PROVIDER_STATE {
    EtwProviderStateFree = 0,
    EtwProviderStateTransition = 1,
    EtwProviderStateActive = 2,
    EtwProviderStateMax = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt = 2,
    NtProductServer = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum POP_POLICY_DEVICE_TYPE {
    PolicyDeviceSystemButton = 0,
    PolicyDeviceThermalZone = 1,
    PolicyDeviceBattery = 2,
    PolicyDeviceMemory = 3,
    PolicyInitiatePowerActionAPI = 4,
    PolicySetPowerStateAPI = 5,
    PolicyImmediateDozeS4 = 6,
    PolicySystemIdle = 7,
    PolicyDeviceMax = 8,
}
#[repr(i32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ARBITER_RESULT {
    ArbiterResultUndefined = -1,
    ArbiterResultSuccess = 0,
    ArbiterResultExternalConflict = 1,
    ArbiterResultNullRequest = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ARBITER_ACTION {
    ArbiterActionTestAllocation = 0,
    ArbiterActionRetestAllocation = 1,
    ArbiterActionCommitAllocation = 2,
    ArbiterActionRollbackAllocation = 3,
    ArbiterActionQueryAllocatedResources = 4,
    ArbiterActionWriteReservedResources = 5,
    ArbiterActionQueryConflict = 6,
    ArbiterActionQueryArbitrate = 7,
    ArbiterActionAddReserved = 8,
    ArbiterActionBootAllocation = 9,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _TYPE_OF_MEMORY {
    LoaderExceptionBlock = 0,
    LoaderSystemBlock = 1,
    LoaderFree = 2,
    LoaderBad = 3,
    LoaderLoadedProgram = 4,
    LoaderFirmwareTemporary = 5,
    LoaderFirmwarePermanent = 6,
    LoaderOsloaderHeap = 7,
    LoaderOsloaderStack = 8,
    LoaderSystemCode = 9,
    LoaderHalCode = 10,
    LoaderBootDriver = 11,
    LoaderConsoleInDriver = 12,
    LoaderConsoleOutDriver = 13,
    LoaderStartupDpcStack = 14,
    LoaderStartupKernelStack = 15,
    LoaderStartupPanicStack = 16,
    LoaderStartupPcrPage = 17,
    LoaderStartupPdrPage = 18,
    LoaderRegistryData = 19,
    LoaderMemoryData = 20,
    LoaderNlsData = 21,
    LoaderSpecialMemory = 22,
    LoaderBBTMemory = 23,
    LoaderReserve = 24,
    LoaderXIPRom = 25,
    LoaderHALCachedMemory = 26,
    LoaderLargePageFiller = 27,
    LoaderErrorLogMemory = 28,
    LoaderMaximum = 29,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KINTERRUPT_POLARITY {
    InterruptPolarityUnknown = 0,
    InterruptActiveHigh = 1,
    InterruptActiveLow = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KINTERRUPT_MODE {
    LevelSensitive = 0,
    Latched = 1,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PROXY_CLASS {
    ProxyFull = 0,
    ProxyService = 1,
    ProxyTree = 2,
    ProxyDirectory = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _BLOB_ID {
    BLOB_TYPE_UNKNOWN = 0,
    BLOB_TYPE_CONNECTION_INFO = 1,
    BLOB_TYPE_MESSAGE = 2,
    BLOB_TYPE_SECURITY_CONTEXT = 3,
    BLOB_TYPE_SECTION = 4,
    BLOB_TYPE_REGION = 5,
    BLOB_TYPE_VIEW = 6,
    BLOB_TYPE_RESERVE = 7,
    BLOB_TYPE_DIRECT_TRANSFER = 8,
    BLOB_TYPE_HANDLE_DATA = 9,
    BLOB_TYPE_MAX_ID = 10,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ETW_BUFFER_STATE {
    EtwBufferStateFree = 0,
    EtwBufferStateGeneralLogging = 1,
    EtwBufferStateCSwitch = 2,
    EtwBufferStateFlush = 3,
    EtwBufferStateMaximum = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ETW_RT_EVENT_LOSS {
    EtwRtEventNoLoss = 0,
    EtwRtEventLost = 1,
    EtwRtBufferLost = 2,
    EtwRtBackupLost = 3,
    EtwRtEventLossMax = 4,
}
#[repr(i32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _ARBITER_REQUEST_SOURCE {
    ArbiterRequestUndefined = -1,
    ArbiterRequestLegacyReported = 0,
    ArbiterRequestHalReported = 1,
    ArbiterRequestLegacyAssigned = 2,
    ArbiterRequestPnpDetected = 3,
    ArbiterRequestPnpEnumerated = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum PROFILE_STATUS {
    DOCK_NOTDOCKDEVICE = 0,
    DOCK_QUIESCENT = 1,
    DOCK_ARRIVING = 2,
    DOCK_DEPARTING = 3,
    DOCK_EJECTIRP_COMPLETED = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PNP_DEVNODE_STATE {
    DeviceNodeUnspecified = 768,
    DeviceNodeUninitialized = 769,
    DeviceNodeInitialized = 770,
    DeviceNodeDriversAdded = 771,
    DeviceNodeResourcesAssigned = 772,
    DeviceNodeStartPending = 773,
    DeviceNodeStartCompletion = 774,
    DeviceNodeStartPostWork = 775,
    DeviceNodeStarted = 776,
    DeviceNodeQueryStopped = 777,
    DeviceNodeStopped = 778,
    DeviceNodeRestartCompletion = 779,
    DeviceNodeEnumeratePending = 780,
    DeviceNodeEnumerateCompletion = 781,
    DeviceNodeAwaitingQueuedDeletion = 782,
    DeviceNodeAwaitingQueuedRemoval = 783,
    DeviceNodeQueryRemoved = 784,
    DeviceNodeRemovePendingCloses = 785,
    DeviceNodeRemoved = 786,
    DeviceNodeDeletePendingCloses = 787,
    DeviceNodeDeleted = 788,
    MaxDeviceNodeState = 789,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution = 0,
    ExceptionContinueSearch = 1,
    ExceptionNestedException = 2,
    ExceptionCollidedUnwind = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan = 0,
    GenericGreaterThan = 1,
    GenericEqual = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum KTM_STATE {
    KKtmUninitialized = 0,
    KKtmInitialized = 1,
    KKtmRecovering = 2,
    KKtmOnline = 3,
    KKtmRecoveryFailed = 4,
    KKtmOffline = 5,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KTRANSACTION_OUTCOME {
    KTxOutcomeUninitialized = 0,
    KTxOutcomeUndetermined = 1,
    KTxOutcomeCommitted = 2,
    KTxOutcomeAborted = 3,
    KTxOutcomeUnavailable = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KTRANSACTION_STATE {
    KTransactionUninitialized = 0,
    KTransactionActive = 1,
    KTransactionPreparing = 2,
    KTransactionPrepared = 3,
    KTransactionInDoubt = 4,
    KTransactionCommitted = 5,
    KTransactionAborted = 6,
    KTransactionDelegated = 7,
    KTransactionPrePreparing = 8,
    KTransactionForgotten = 9,
    KTransactionRecovering = 10,
    KTransactionPrePrepared = 11,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KRESOURCEMANAGER_STATE {
    KResourceManagerUninitialized = 0,
    KResourceManagerOffline = 1,
    KResourceManagerOnline = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum HSTORAGE_TYPE {
    Stable = 0,
    Volatile = 1,
    InvalidStorage = 2,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum UoWActionType {
    UoWAddThisKey = 0,
    UoWAddChildKey = 1,
    UoWDeleteThisKey = 2,
    UoWDeleteChildKey = 3,
    UoWSetValueNew = 4,
    UoWSetValueExisting = 5,
    UoWDeleteValue = 6,
    UoWSetKeyUserFlags = 7,
    UoWSetLastWriteTime = 8,
    UoWSetSecurityDescriptor = 9,
    UoWRenameSubKey = 10,
    UoWRenameOldSubKey = 11,
    UoWRenameNewSubKey = 12,
    UoWIsolation = 13,
    UoWInvalid = 14,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KENLISTMENT_STATE {
    KEnlistmentUninitialized = 0,
    KEnlistmentActive = 256,
    KEnlistmentPreparing = 257,
    KEnlistmentPrepared = 258,
    KEnlistmentInDoubt = 259,
    KEnlistmentCommitted = 260,
    KEnlistmentCommittedNotify = 261,
    KEnlistmentCommitRequested = 262,
    KEnlistmentAborted = 263,
    KEnlistmentDelegated = 264,
    KEnlistmentDelegatedDisconnected = 265,
    KEnlistmentPrePreparing = 266,
    KEnlistmentForgotten = 267,
    KEnlistmentRecovering = 268,
    KEnlistmentAborting = 269,
    KEnlistmentReadOnly = 270,
    KEnlistmentOutcomeUnavailable = 271,
    KEnlistmentOffline = 272,
    KEnlistmentPrePrepared = 273,
    KEnlistmentInitialized = 274,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _CONFIGURATION_TYPE {
    ArcSystem = 0,
    CentralProcessor = 1,
    FloatingPointProcessor = 2,
    PrimaryIcache = 3,
    PrimaryDcache = 4,
    SecondaryIcache = 5,
    SecondaryDcache = 6,
    SecondaryCache = 7,
    EisaAdapter = 8,
    TcAdapter = 9,
    ScsiAdapter = 10,
    DtiAdapter = 11,
    MultiFunctionAdapter = 12,
    DiskController = 13,
    TapeController = 14,
    CdromController = 15,
    WormController = 16,
    SerialController = 17,
    NetworkController = 18,
    DisplayController = 19,
    ParallelController = 20,
    PointerController = 21,
    KeyboardController = 22,
    AudioController = 23,
    OtherController = 24,
    DiskPeripheral = 25,
    FloppyDiskPeripheral = 26,
    TapePeripheral = 27,
    ModemPeripheral = 28,
    MonitorPeripheral = 29,
    PrinterPeripheral = 30,
    PointerPeripheral = 31,
    KeyboardPeripheral = 32,
    TerminalPeripheral = 33,
    OtherPeripheral = 34,
    LinePeripheral = 35,
    NetworkPeripheral = 36,
    SystemMemory = 37,
    DockingInformation = 38,
    RealModeIrqRoutingTable = 39,
    RealModePCIEnumeration = 40,
    MaximumType = 41,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _CONFIGURATION_CLASS {
    SystemClass = 0,
    ProcessorClass = 1,
    CacheClass = 2,
    AdapterClass = 3,
    ControllerClass = 4,
    PeripheralClass = 5,
    MemoryClass = 6,
    MaximumClass = 7,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _WHEA_RAW_DATA_FORMAT {
    WheaRawDataFormatIPFSalRecord = 0,
    WheaRawDataFormatIA32MCA = 1,
    WheaRawDataFormatIntel64MCA = 2,
    WheaRawDataFormatAMD64MCA = 3,
    WheaRawDataFormatMemory = 4,
    WheaRawDataFormatPCIExpress = 5,
    WheaRawDataFormatNMIPort = 6,
    WheaRawDataFormatPCIXBus = 7,
    WheaRawDataFormatPCIXDevice = 8,
    WheaRawDataFormatGeneric = 9,
    WheaRawDataFormatMax = 10,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _WHEA_ERROR_SOURCE_TYPE {
    WheaErrSrcTypeMCE = 0,
    WheaErrSrcTypeCMC = 1,
    WheaErrSrcTypeCPE = 2,
    WheaErrSrcTypeNMI = 3,
    WheaErrSrcTypePCIe = 4,
    WheaErrSrcTypeGeneric = 5,
    WheaErrSrcTypeINIT = 6,
    WheaErrSrcTypeBOOT = 7,
    WheaErrSrcTypeSCIGeneric = 8,
    WheaErrSrcTypeIPFMCA = 9,
    WheaErrSrcTypeIPFCMC = 10,
    WheaErrSrcTypeIPFCPE = 11,
    WheaErrSrcTypeMax = 12,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _WHEA_ERROR_TYPE {
    WheaErrTypeProcessor = 0,
    WheaErrTypeMemory = 1,
    WheaErrTypePCIExpress = 2,
    WheaErrTypeNMI = 3,
    WheaErrTypePCIXBus = 4,
    WheaErrTypePCIXDevice = 5,
    WheaErrTypeGeneric = 6,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum WHEA_PCIEXPRESS_DEVICE_TYPE {
    WheaPciExpressEndpoint = 0,
    WheaPciExpressLegacyEndpoint = 1,
    WheaPciExpressRootPort = 4,
    WheaPciExpressUpstreamSwitchPort = 5,
    WheaPciExpressDownstreamSwitchPort = 6,
    WheaPciExpressToPciXBridge = 7,
    WheaPciXToExpressBridge = 8,
    WheaPciExpressRootComplexIntegratedEndpoint = 9,
    WheaPciExpressRootComplexEventCollector = 10,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _WHEA_ERROR_SEVERITY {
    WheaErrSevRecoverable = 0,
    WheaErrSevFatal = 1,
    WheaErrSevCorrected = 2,
    WheaErrSevNone = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _MM_PAGE_ACCESS_TYPE {
    MmPteAccessType = 0,
    MmCcReadAheadType = 1,
    MmPfnRepurposeType = 2,
    MmMaximumPageAccessType = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor = 0,
    QuerySecurityDescriptor = 1,
    DeleteSecurityDescriptor = 2,
    AssignSecurityDescriptor = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _OB_OPEN_REASON {
    ObCreateHandle = 0,
    ObOpenHandle = 1,
    ObDuplicateHandle = 2,
    ObInheritHandle = 3,
    ObMaxOpenReason = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _IO_PRIORITY_HINT {
    IoPriorityVeryLow = 0,
    IoPriorityLow = 1,
    IoPriorityNormal = 2,
    IoPriorityHigh = 3,
    IoPriorityCritical = 4,
    MaxIoPriorityTypes = 5,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _IRQ_PRIORITY {
    IrqPriorityUndefined = 0,
    IrqPriorityLow = 1,
    IrqPriorityNormal = 2,
    IrqPriorityHigh = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _IRQ_DEVICE_POLICY {
    IrqPolicyMachineDefault = 0,
    IrqPolicyAllCloseProcessors = 1,
    IrqPolicyOneCloseProcessor = 2,
    IrqPolicyAllProcessorsInMachine = 3,
    IrqPolicySpecifiedProcessors = 4,
    IrqPolicySpreadMessagesAcrossAllProcessors = 5,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
    NotifyTypeCreate = 0,
    NotifyTypeRetired = 1,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _FS_FILTER_SECTION_SYNC_TYPE {
    SyncTypeOther = 0,
    SyncTypeCreateSection = 1,
}
#[repr(i32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    Vmcs = 16,
    MaximumInterfaceType = 17,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum POWER_ACTION {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum DEVICE_TEXT_TYPE {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum BUS_QUERY_ID_TYPE {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4,
    SingleBusRelations = 5,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsDriverPathInformation = 9,
    FileFsVolumeFlagsInformation = 10,
    FileFsMaximumInformation = 11,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileIdBothDirectoryInformation = 37,
    FileIdFullDirectoryInformation = 38,
    FileValidDataLengthInformation = 39,
    FileShortNameInformation = 40,
    FileIoCompletionNotificationInformation = 41,
    FileIoStatusBlockRangeInformation = 42,
    FileIoPriorityHintInformation = 43,
    FileSfioReserveInformation = 44,
    FileSfioVolumeInformation = 45,
    FileHardLinkInformation = 46,
    FileProcessIdsUsingFileInformation = 47,
    FileNormalizedNameInformation = 48,
    FileNetworkPhysicalNameInformation = 49,
    FileIdGlobalTxDirectoryInformation = 50,
    FileMaximumInformation = 51,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub SystemState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x0 (0)"]
    pub DeviceState: _DEVICE_POWER_STATE,
}
impl Default for _POWER_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _PROCESSOR_CACHE_TYPE {
    CacheUnified = 0,
    CacheInstruction = 1,
    CacheData = 2,
    CacheTrace = 3,
}
#[repr(u32)]
#[doc = " 0x4 (4) bytes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TIME_FIELDS {
    #[doc = " offset: 0x0 (0)"]
    pub Year: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Month: SHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Day: SHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Hour: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Minute: SHORT,
    #[doc = " offset: 0xa (10)"]
    pub Second: SHORT,
    #[doc = " offset: 0xc (12)"]
    pub Milliseconds: SHORT,
    #[doc = " offset: 0xe (14)"]
    pub Weekday: SHORT,
}
pub type USHORT = u16;
pub type UCHAR = u8;
pub type ULONGLONG = u64;
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub s1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Value: ULONGLONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Head(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Head(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn Tail(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Tail(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn ActiveThreadCount(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_ActiveThreadCount(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Head: ULONGLONG,
        Tail: ULONGLONG,
        ActiveThreadCount: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let Head: u64 = unsafe { ::std::mem::transmute(Head) };
            Head as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let Tail: u64 = unsafe { ::std::mem::transmute(Tail) };
            Tail as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let ActiveThreadCount: u64 = unsafe { ::std::mem::transmute(ActiveThreadCount) };
            ActiveThreadCount as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ALPC_COMPLETION_LIST_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1b (27) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TOKEN_AUDIT_POLICY {
    #[doc = " offset: 0x0 (0)"]
    pub PerUserPolicy: [UCHAR; 27usize],
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SEP_AUDIT_POLICY {
    #[doc = " offset: 0x0 (0)"]
    pub AdtTokenPolicy: _TOKEN_AUDIT_POLICY,
    #[doc = " offset: 0x1b (27)"]
    pub PolicySetStatus: UCHAR,
}
#[doc = " 0x2 (2) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPFNENTRY {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _MMPFNENTRY {
    #[inline]
    pub fn PageLocation(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_PageLocation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteInProgress(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WriteInProgress(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Modified(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Modified(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadInProgress(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadInProgress(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheAttribute(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CacheAttribute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Priority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Priority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Rom(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Rom(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InPageError(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InPageError(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelStack(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_KernelStack(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RemovalRequested(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RemovalRequested(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ParityError(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ParityError(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageLocation: UCHAR,
        WriteInProgress: UCHAR,
        Modified: UCHAR,
        ReadInProgress: UCHAR,
        CacheAttribute: UCHAR,
        Priority: UCHAR,
        Rom: UCHAR,
        InPageError: UCHAR,
        KernelStack: UCHAR,
        RemovalRequested: UCHAR,
        ParityError: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let PageLocation: u8 = unsafe { ::std::mem::transmute(PageLocation) };
            PageLocation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteInProgress: u8 = unsafe { ::std::mem::transmute(WriteInProgress) };
            WriteInProgress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Modified: u8 = unsafe { ::std::mem::transmute(Modified) };
            Modified as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ReadInProgress: u8 = unsafe { ::std::mem::transmute(ReadInProgress) };
            ReadInProgress as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let CacheAttribute: u8 = unsafe { ::std::mem::transmute(CacheAttribute) };
            CacheAttribute as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let Priority: u8 = unsafe { ::std::mem::transmute(Priority) };
            Priority as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Rom: u8 = unsafe { ::std::mem::transmute(Rom) };
            Rom as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let InPageError: u8 = unsafe { ::std::mem::transmute(InPageError) };
            InPageError as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let KernelStack: u8 = unsafe { ::std::mem::transmute(KernelStack) };
            KernelStack as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let RemovalRequested: u8 = unsafe { ::std::mem::transmute(RemovalRequested) };
            RemovalRequested as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ParityError: u8 = unsafe { ::std::mem::transmute(ParityError) };
            ParityError as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_DEADLOCK_ADDRESS_RANGE {
    #[doc = " offset: 0x0 (0)"]
    pub Start: *mut UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub End: *mut UCHAR,
}
impl Default for _VI_DEADLOCK_ADDRESS_RANGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1 (1) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsUCHAR: UCHAR,
}
impl Default for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    #[inline]
    pub fn FRUId(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FRUId(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FRUText(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FRUText(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FRUId: UCHAR,
        FRUText: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FRUId: u8 = unsafe { ::std::mem::transmute(FRUId) };
            FRUId as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FRUText: u8 = unsafe { ::std::mem::transmute(FRUText) };
            FRUText as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMSUPPORT_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMSUPPORT_FLAGS {
    #[inline]
    pub fn SessionSpace(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SessionSpace(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ModwriterAttached(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ModwriterAttached(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TrimHard(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TrimHard(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MaximumWorkingSetHard(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MaximumWorkingSetHard(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceTrim(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ForceTrim(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MinimumWorkingSetHard(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MinimumWorkingSetHard(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SessionMaster(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SessionMaster(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TrimmerAttached(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TrimmerAttached(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TrimmerDetaching(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TrimmerDetaching(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PageStealers(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PageStealers(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn MemoryPriority(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_MemoryPriority(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn WsleDeleted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WsleDeleted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VmExiting(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VmExiting(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExpansionFailed(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExpansionFailed(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Available(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Available(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SessionSpace: UCHAR,
        ModwriterAttached: UCHAR,
        TrimHard: UCHAR,
        MaximumWorkingSetHard: UCHAR,
        ForceTrim: UCHAR,
        MinimumWorkingSetHard: UCHAR,
        SessionMaster: UCHAR,
        TrimmerAttached: UCHAR,
        TrimmerDetaching: UCHAR,
        Reserved: UCHAR,
        PageStealers: UCHAR,
        MemoryPriority: UCHAR,
        WsleDeleted: UCHAR,
        VmExiting: UCHAR,
        ExpansionFailed: UCHAR,
        Available: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SessionSpace: u8 = unsafe { ::std::mem::transmute(SessionSpace) };
            SessionSpace as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ModwriterAttached: u8 = unsafe { ::std::mem::transmute(ModwriterAttached) };
            ModwriterAttached as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TrimHard: u8 = unsafe { ::std::mem::transmute(TrimHard) };
            TrimHard as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MaximumWorkingSetHard: u8 = unsafe { ::std::mem::transmute(MaximumWorkingSetHard) };
            MaximumWorkingSetHard as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ForceTrim: u8 = unsafe { ::std::mem::transmute(ForceTrim) };
            ForceTrim as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MinimumWorkingSetHard: u8 = unsafe { ::std::mem::transmute(MinimumWorkingSetHard) };
            MinimumWorkingSetHard as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SessionMaster: u8 = unsafe { ::std::mem::transmute(SessionMaster) };
            SessionMaster as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let TrimmerAttached: u8 = unsafe { ::std::mem::transmute(TrimmerAttached) };
            TrimmerAttached as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TrimmerDetaching: u8 = unsafe { ::std::mem::transmute(TrimmerDetaching) };
            TrimmerDetaching as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PageStealers: u8 = unsafe { ::std::mem::transmute(PageStealers) };
            PageStealers as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let MemoryPriority: u8 = unsafe { ::std::mem::transmute(MemoryPriority) };
            MemoryPriority as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let WsleDeleted: u8 = unsafe { ::std::mem::transmute(WsleDeleted) };
            WsleDeleted as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let VmExiting: u8 = unsafe { ::std::mem::transmute(VmExiting) };
            VmExiting as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ExpansionFailed: u8 = unsafe { ::std::mem::transmute(ExpansionFailed) };
            ExpansionFailed as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let Available: u8 = unsafe { ::std::mem::transmute(Available) };
            Available as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x1 (1) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KEXECUTE_OPTIONS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KEXECUTE_OPTIONS {
    #[inline]
    pub fn ExecuteDisable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteEnable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExecuteEnable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableThunkEmulation(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableThunkEmulation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Permanent(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Permanent(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDispatchEnable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ExecuteDispatchEnable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageDispatchEnable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageDispatchEnable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableExceptionChainValidation(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableExceptionChainValidation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExecuteDisable: UCHAR,
        ExecuteEnable: UCHAR,
        DisableThunkEmulation: UCHAR,
        Permanent: UCHAR,
        ExecuteDispatchEnable: UCHAR,
        ImageDispatchEnable: UCHAR,
        DisableExceptionChainValidation: UCHAR,
        Spare: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ExecuteDisable: u8 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ExecuteEnable: u8 = unsafe { ::std::mem::transmute(ExecuteEnable) };
            ExecuteEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisableThunkEmulation: u8 = unsafe { ::std::mem::transmute(DisableThunkEmulation) };
            DisableThunkEmulation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Permanent: u8 = unsafe { ::std::mem::transmute(Permanent) };
            Permanent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ExecuteDispatchEnable: u8 = unsafe { ::std::mem::transmute(ExecuteDispatchEnable) };
            ExecuteDispatchEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ImageDispatchEnable: u8 = unsafe { ::std::mem::transmute(ImageDispatchEnable) };
            ImageDispatchEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DisableExceptionChainValidation: u8 =
                unsafe { ::std::mem::transmute(DisableExceptionChainValidation) };
            DisableExceptionChainValidation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Spare: u8 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x1 (1) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _flags {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _flags {
    #[inline]
    pub fn Removable(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Fill(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Fill(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Removable: UCHAR, Fill: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Removable: u8 = unsafe { ::std::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Fill: u8 = unsafe { ::std::mem::transmute(Fill) };
            Fill as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x6 (6) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    #[doc = " offset: 0x0 (0)"]
    pub Value: [UCHAR; 6usize],
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_BALANCED_LINKS {
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _RTL_BALANCED_LINKS,
    #[doc = " offset: 0x8 (8)"]
    pub LeftChild: *mut _RTL_BALANCED_LINKS,
    #[doc = " offset: 0x10 (16)"]
    pub RightChild: *mut _RTL_BALANCED_LINKS,
    #[doc = " offset: 0x18 (24)"]
    pub Balance: CHAR,
    #[doc = " offset: 0x19 (25)"]
    pub Reserved: [UCHAR; 3usize],
}
impl Default for _RTL_BALANCED_LINKS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTMOBJECT_NAMESPACE_LINK {
    #[doc = " offset: 0x0 (0)"]
    pub Links: _RTL_BALANCED_LINKS,
    #[doc = " offset: 0x20 (32)"]
    pub Expired: UCHAR,
}
impl Default for _KTMOBJECT_NAMESPACE_LINK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _iobuf {
    #[doc = " offset: 0x0 (0)"]
    pub _ptr: *mut CHAR,
    #[doc = " offset: 0x8 (8)"]
    pub _cnt: LONG,
    #[doc = " offset: 0x10 (16)"]
    pub _base: *mut CHAR,
    #[doc = " offset: 0x18 (24)"]
    pub _flag: LONG,
    #[doc = " offset: 0x1c (28)"]
    pub _file: LONG,
    #[doc = " offset: 0x20 (32)"]
    pub _charbuf: LONG,
    #[doc = " offset: 0x24 (36)"]
    pub _bufsiz: LONG,
    #[doc = " offset: 0x28 (40)"]
    pub _tmpfname: *mut CHAR,
}
impl Default for _iobuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_FREE_ENTRY_EXTRA {
    #[doc = " offset: 0x0 (0)"]
    pub TagIndex: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub FreeBackTraceIndex: USHORT,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_ATOM_TABLE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub HashLink: *mut _RTL_ATOM_TABLE_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub HandleIndex: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub Atom: USHORT,
    #[doc = " offset: 0xc (12)"]
    pub ReferenceCount: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub Flags: UCHAR,
    #[doc = " offset: 0xf (15)"]
    pub NameLength: UCHAR,
    #[doc = " offset: 0x10 (16)"]
    pub Name: [WCHAR; 1usize],
}
impl Default for _RTL_ATOM_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ACL {
    #[doc = " offset: 0x0 (0)"]
    pub AclRevision: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Sbz1: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub AclSize: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub AceCount: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Sbz2: USHORT,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_TRACE_PACKET {
    #[doc = " offset: 0x0 (0)"]
    pub Size: USHORT,
    pub __bindgen_anon_1: _WMI_TRACE_PACKET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_TRACE_PACKET__bindgen_ty_1 {
    #[doc = " offset: 0x2 (2)"]
    pub HookId: USHORT,
    pub __bindgen_anon_1: _WMI_TRACE_PACKET__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WMI_TRACE_PACKET__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x2 (2)"]
    pub Type: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub Group: UCHAR,
}
impl Default for _WMI_TRACE_PACKET__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_TRACE_PACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ETW_BUFFER_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub ProcessorNumber: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Alignment: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub LoggerId: USHORT,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ETW_SYSTEMTIME {
    #[doc = " offset: 0x0 (0)"]
    pub Year: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Month: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub DayOfWeek: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Day: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Hour: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub Minute: USHORT,
    #[doc = " offset: 0xc (12)"]
    pub Second: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub Milliseconds: USHORT,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INTERLOCK_SEQ {
    pub __bindgen_anon_1: _INTERLOCK_SEQ__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _INTERLOCK_SEQ__bindgen_ty_1 {
    pub __bindgen_anon_1: _INTERLOCK_SEQ__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _INTERLOCK_SEQ__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x0 (0)"]
    pub Exchg: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _INTERLOCK_SEQ__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Depth: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub FreeEntryOffset: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _INTERLOCK_SEQ__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub OffsetAndDepth: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Sequence: ULONG,
}
impl Default for _INTERLOCK_SEQ__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _INTERLOCK_SEQ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMSUBSECTION_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MMSUBSECTION_FLAGS {
    #[inline]
    pub fn SubsectionAccessed(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SubsectionAccessed(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn StartingSector4132(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_StartingSector4132(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn SubsectionStatic(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SubsectionStatic(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalMemory(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GlobalMemory(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirtyPages(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DirtyPages(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SectorEndOffset(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_SectorEndOffset(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SubsectionAccessed: USHORT,
        Protection: USHORT,
        StartingSector4132: USHORT,
        SubsectionStatic: USHORT,
        GlobalMemory: USHORT,
        DirtyPages: USHORT,
        Spare: USHORT,
        SectorEndOffset: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SubsectionAccessed: u16 = unsafe { ::std::mem::transmute(SubsectionAccessed) };
            SubsectionAccessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Protection: u16 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let StartingSector4132: u16 = unsafe { ::std::mem::transmute(StartingSector4132) };
            StartingSector4132 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let SubsectionStatic: u16 = unsafe { ::std::mem::transmute(SubsectionStatic) };
            SubsectionStatic as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let GlobalMemory: u16 = unsafe { ::std::mem::transmute(GlobalMemory) };
            GlobalMemory as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DirtyPages: u16 = unsafe { ::std::mem::transmute(DirtyPages) };
            DirtyPages as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Spare: u16 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let SectorEndOffset: u16 = unsafe { ::std::mem::transmute(SectorEndOffset) };
            SectorEndOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x2 (2) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXBUS_ID {
    pub __bindgen_anon_1: _WHEA_PCIXBUS_ID__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_PCIXBUS_ID__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub BusNumber: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub BusSegment: UCHAR,
}
impl Default for _WHEA_PCIXBUS_ID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x2 (2) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_REVISION {
    pub __bindgen_anon_1: _WHEA_REVISION__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_REVISION__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub MinorRevision: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub MajorRevision: UCHAR,
}
impl Default for _WHEA_REVISION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _STRING {
    #[doc = " offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Buffer: *mut CHAR,
}
impl Default for _STRING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MI_COLOR_BASE {
    #[doc = " offset: 0x0 (0)"]
    pub ColorPointer: *mut USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub ColorMask: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub ColorNode: USHORT,
}
impl Default for _MI_COLOR_BASE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _UNICODE_STRING {
    #[doc = " offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Buffer: *mut USHORT,
}
impl Default for _UNICODE_STRING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_NAME_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub Name: _UNICODE_STRING,
}
impl Default for _OBJECT_NAME_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SE_AUDIT_PROCESS_CREATION_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub ImageFileName: *mut _OBJECT_NAME_INFORMATION,
}
impl Default for _SE_AUDIT_PROCESS_CREATION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SINGLE_LIST_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _SINGLE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
}
impl Default for _ARBITER_QUERY_ARBITRATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
}
impl Default for _ARBITER_BOOT_ALLOCATION_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LIST_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Flink: *mut _LIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub Blink: *mut _LIST_ENTRY,
}
impl Default for _LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARC_DISK_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub DiskSignatures: _LIST_ENTRY,
}
impl Default for _ARC_DISK_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VOID = ::std::os::raw::c_void;
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECURITY_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub Revision: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Sbz1: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Control: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Owner: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Group: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Sacl: *mut _ACL,
    #[doc = " offset: 0x20 (32)"]
    pub Dacl: *mut _ACL,
}
impl Default for _SECURITY_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_FAULT_TRACE {
    #[doc = " offset: 0x0 (0)"]
    pub Thread: *mut _ETHREAD,
    #[doc = " offset: 0x8 (8)"]
    pub StackTrace: [*mut VOID; 8usize],
}
impl Default for _VI_FAULT_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VF_TRACKER_STAMP {
    #[doc = " offset: 0x0 (0)"]
    pub Thread: *mut VOID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _VF_TRACKER_STAMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VF_TRACKER_STAMP {
    #[inline]
    pub fn Flags(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn OldIrql(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_OldIrql(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn NewIrql(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_NewIrql(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Processor(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_Processor(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flags: UCHAR,
        OldIrql: UCHAR,
        NewIrql: UCHAR,
        Processor: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Flags: u8 = unsafe { ::std::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let OldIrql: u8 = unsafe { ::std::mem::transmute(OldIrql) };
            OldIrql as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let NewIrql: u8 = unsafe { ::std::mem::transmute(NewIrql) };
            NewIrql as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Processor: u8 = unsafe { ::std::mem::transmute(Processor) };
            Processor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_HANDLE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Object: *mut VOID,
}
impl Default for _ALPC_HANDLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NLS_DATA_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub AnsiCodePageData: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub OemCodePageData: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub UnicodeCaseTableData: *mut VOID,
}
impl Default for _NLS_DATA_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_HEADER_CREATOR_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub TypeList: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub CreatorUniqueProcess: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub CreatorBackTraceIndex: USHORT,
    #[doc = " offset: 0x1a (26)"]
    pub Reserved: USHORT,
}
impl Default for _OBJECT_HEADER_CREATOR_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TXN_PARAMETER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub TxFsContext: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub TransactionObject: *mut VOID,
}
impl Default for _TXN_PARAMETER_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_DRIVER_CREATE_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Size: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub ExtraCreateParameter: *mut _ECP_LIST,
    #[doc = " offset: 0x10 (16)"]
    pub DeviceObjectHint: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub TxnParameters: *mut _TXN_PARAMETER_BLOCK,
}
impl Default for _IO_DRIVER_CREATE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub ClientToken: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub ImpersonationLevel: _SECURITY_IMPERSONATION_LEVEL,
    #[doc = " offset: 0x10 (16)"]
    pub PrimaryToken: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub ProcessAuditId: *mut VOID,
}
impl Default for _SECURITY_SUBJECT_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_REF_TRACE {
    #[doc = " offset: 0x0 (0)"]
    pub StackTrace: [*mut VOID; 16usize],
}
impl Default for _OBJECT_REF_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8088 (32904) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _STACK_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub NumStackTraces: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub TraceCapacity: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub StackTrace: [*mut _OBJECT_REF_TRACE; 16usize],
    #[doc = " offset: 0x88 (136)"]
    pub StackTableHash: [USHORT; 16381usize],
}
impl Default for _STACK_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CURDIR {
    #[doc = " offset: 0x0 (0)"]
    pub DosPath: _UNICODE_STRING,
    #[doc = " offset: 0x10 (16)"]
    pub Handle: *mut VOID,
}
impl Default for _CURDIR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_COMPLETION_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Port: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Key: *mut VOID,
}
impl Default for _IO_COMPLETION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECTION_OBJECT_POINTERS {
    #[doc = " offset: 0x0 (0)"]
    pub DataSectionObject: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub SharedCacheMap: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ImageSectionObject: *mut VOID,
}
impl Default for _SECTION_OBJECT_POINTERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_CLIENT_EXTENSION {
    #[doc = " offset: 0x0 (0)"]
    pub NextExtension: *mut _IO_CLIENT_EXTENSION,
    #[doc = " offset: 0x8 (8)"]
    pub ClientIdentificationAddress: *mut VOID,
}
impl Default for _IO_CLIENT_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_TIMER {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub TimerFlag: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub TimerList: _LIST_ENTRY,
    pub TimerRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut VOID)>,
    #[doc = " offset: 0x20 (32)"]
    pub Context: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
}
impl Default for _IO_TIMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TERMINATION_PORT {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _TERMINATION_PORT,
    #[doc = " offset: 0x8 (8)"]
    pub Port: *mut VOID,
}
impl Default for _TERMINATION_PORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CLIENT_ID {
    #[doc = " offset: 0x0 (0)"]
    pub UniqueProcess: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub UniqueThread: *mut VOID,
}
impl Default for _CLIENT_ID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KREQUEST_PACKET {
    #[doc = " offset: 0x0 (0)"]
    pub CurrentPacket: [*mut VOID; 3usize],
    pub WorkerRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut VOID, arg4: *mut VOID),
    >,
}
impl Default for _KREQUEST_PACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CACHE_MANAGER_CALLBACKS {
    #[doc = " offset: 0x0 (0)"]
    pub AcquireForLazyWrite:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: UCHAR) -> UCHAR>,
    #[doc = " offset: 0x8 (8)"]
    pub ReleaseFromLazyWrite: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = " offset: 0x10 (16)"]
    pub AcquireForReadAhead:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: UCHAR) -> UCHAR>,
    #[doc = " offset: 0x18 (24)"]
    pub ReleaseFromReadAhead: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WORK_QUEUE_ITEM {
    #[doc = " offset: 0x0 (0)"]
    pub List: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub WorkerRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = " offset: 0x18 (24)"]
    pub Parameter: *mut VOID,
}
impl Default for _WORK_QUEUE_ITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_WORKITEM {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub WorkerRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = " offset: 0x18 (24)"]
    pub Parameter: *mut VOID,
}
impl Default for _CM_WORKITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _INTERFACE {
    #[doc = " offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Version: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Context: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub InterfaceReference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = " offset: 0x18 (24)"]
    pub InterfaceDereference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
impl Default for _INTERFACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KDESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub Pad: [USHORT; 3usize],
    #[doc = " offset: 0x6 (6)"]
    pub Limit: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Base: *mut VOID,
}
impl Default for _KDESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KDPC {
    #[doc = " offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Importance: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Number: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub DpcListEntry: _LIST_ENTRY,
    pub DeferredRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _KDPC, arg2: *mut VOID, arg3: *mut VOID, arg4: *mut VOID),
    >,
    #[doc = " offset: 0x20 (32)"]
    pub DeferredContext: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub SystemArgument1: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub SystemArgument2: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub DpcData: *mut VOID,
}
impl Default for _KDPC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TP_CALLBACK_INSTANCE {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ACTIVATION_CONTEXT {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TP_CLEANUP_GROUP {}
#[doc = " 0x0 (0) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TP_POOL {}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TP_TASK_CALLBACKS {
    pub ExecuteCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _TP_CALLBACK_INSTANCE, arg2: *mut _TP_TASK),
    >,
    pub Unposted:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _TP_TASK, arg2: *mut _TP_POOL)>,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TP_TASK {
    #[doc = " offset: 0x0 (0)"]
    pub Callbacks: *mut _TP_TASK_CALLBACKS,
}
impl Default for _TP_TASK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUAD {
    pub __bindgen_anon_1: _QUAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUAD__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub UseThisFieldToCopy: LONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub DoNotUseThisField: f64,
}
impl Default for _QUAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _QUAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REQUEST_MAILBOX {
    #[doc = " offset: 0x0 (0)"]
    pub RequestSummary: LONGLONG,
    pub __bindgen_anon_1: _REQUEST_MAILBOX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REQUEST_MAILBOX__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub RequestPacket: _KREQUEST_PACKET,
    #[doc = " offset: 0x8 (8)"]
    pub Virtual: [*mut VOID; 7usize],
}
impl Default for _REQUEST_MAILBOX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _REQUEST_MAILBOX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_DOS_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub e_magic: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub e_cblp: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub e_cp: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub e_crlc: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub e_cparhdr: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub e_minalloc: USHORT,
    #[doc = " offset: 0xc (12)"]
    pub e_maxalloc: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub e_ss: USHORT,
    #[doc = " offset: 0x10 (16)"]
    pub e_sp: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub e_csum: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub e_ip: USHORT,
    #[doc = " offset: 0x16 (22)"]
    pub e_cs: USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub e_lfarlc: USHORT,
    #[doc = " offset: 0x1a (26)"]
    pub e_ovno: USHORT,
    #[doc = " offset: 0x1c (28)"]
    pub e_res: [USHORT; 4usize],
    #[doc = " offset: 0x24 (36)"]
    pub e_oemid: USHORT,
    #[doc = " offset: 0x26 (38)"]
    pub e_oeminfo: USHORT,
    #[doc = " offset: 0x28 (40)"]
    pub e_res2: [USHORT; 10usize],
    #[doc = " offset: 0x3c (60)"]
    pub e_lfanew: LONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VACB_LEVEL_REFERENCE {
    #[doc = " offset: 0x0 (0)"]
    pub Reference: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub SpecialReference: LONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_CONTINUE {
    #[doc = " offset: 0x0 (0)"]
    pub ContinueStatus: LONG,
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KWAIT_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub WaitListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Thread: *mut _KTHREAD,
    #[doc = " offset: 0x18 (24)"]
    pub Object: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub NextWaitBlock: *mut _KWAIT_BLOCK,
    #[doc = " offset: 0x28 (40)"]
    pub WaitKey: USHORT,
    #[doc = " offset: 0x2a (42)"]
    pub WaitType: UCHAR,
    #[doc = " offset: 0x2b (43)"]
    pub SpareByte: UCHAR,
    #[doc = " offset: 0x2c (44)"]
    pub SpareLong: LONG,
}
impl Default for _KWAIT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub SignalState: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub WaitListHead: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Lock: LONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x1 (1)"]
    pub Abandoned: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Absolute: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub NpxIrql: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Signalling: UCHAR,
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x2 (2)"]
    pub Size: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Hand: UCHAR,
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x3 (3)"]
    pub Inserted: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub DebugActive: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub DpcActive: UCHAR,
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DISPATCHER_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KMUTANT {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = " offset: 0x18 (24)"]
    pub MutantListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub OwnerThread: *mut _KTHREAD,
    #[doc = " offset: 0x30 (48)"]
    pub Abandoned: UCHAR,
    #[doc = " offset: 0x31 (49)"]
    pub ApcDisable: UCHAR,
}
impl Default for _KMUTANT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KGATE {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
}
impl Default for _KGATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SECTION_CREATION_GATE {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _MI_SECTION_CREATION_GATE,
    #[doc = " offset: 0x8 (8)"]
    pub Gate: _KGATE,
}
impl Default for _MI_SECTION_CREATION_GATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSEMAPHORE {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = " offset: 0x18 (24)"]
    pub Limit: LONG,
}
impl Default for _KSEMAPHORE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPCP_NONPAGED_PORT_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub Semaphore: _KSEMAPHORE,
    #[doc = " offset: 0x20 (32)"]
    pub BackPointer: *mut _LPCP_PORT_OBJECT,
}
impl Default for _LPCP_NONPAGED_PORT_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LPCP_PORT_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub NonPagedPortQueue: *mut _LPCP_NONPAGED_PORT_QUEUE,
    #[doc = " offset: 0x8 (8)"]
    pub Semaphore: *mut _KSEMAPHORE,
    #[doc = " offset: 0x10 (16)"]
    pub ReceiveHead: _LIST_ENTRY,
}
impl Default for _LPCP_PORT_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEVENT {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
}
impl Default for _KEVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHE_UNINITIALIZE_EVENT {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _CACHE_UNINITIALIZE_EVENT,
    #[doc = " offset: 0x8 (8)"]
    pub Event: _KEVENT,
}
impl Default for _CACHE_UNINITIALIZE_EVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_PUSH_LOCK_WAIT_BLOCK {
    pub __bindgen_anon_1: _EX_PUSH_LOCK_WAIT_BLOCK__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub Next: *mut _EX_PUSH_LOCK_WAIT_BLOCK,
    #[doc = " offset: 0x20 (32)"]
    pub Last: *mut _EX_PUSH_LOCK_WAIT_BLOCK,
    #[doc = " offset: 0x28 (40)"]
    pub Previous: *mut _EX_PUSH_LOCK_WAIT_BLOCK,
    #[doc = " offset: 0x30 (48)"]
    pub ShareCount: LONG,
    #[doc = " offset: 0x34 (52)"]
    pub Flags: LONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_PUSH_LOCK_WAIT_BLOCK__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub WakeGate: _KGATE,
    #[doc = " offset: 0x0 (0)"]
    pub WakeEvent: _KEVENT,
}
impl Default for _EX_PUSH_LOCK_WAIT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EX_PUSH_LOCK_WAIT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEFERRED_WRITE {
    #[doc = " offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub NodeByteSize: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub BytesToWrite: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DeferredWriteLinks: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub Event: *mut _KEVENT,
    #[doc = " offset: 0x30 (48)"]
    pub PostRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID)>,
    #[doc = " offset: 0x38 (56)"]
    pub Context1: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub Context2: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub LimitModifiedPages: UCHAR,
}
impl Default for _DEFERRED_WRITE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VF_TRACKER {
    #[doc = " offset: 0x0 (0)"]
    pub TrackerFlags: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub TrackerSize: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub TrackerIndex: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub TraceDepth: ULONG,
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionList: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub StackBase: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub StackLimit: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SubSystemTib: ULONG,
    pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
    #[doc = " offset: 0x14 (20)"]
    pub ArbitraryUserPointer: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Self_: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub FiberData: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Version: ULONG,
}
impl Default for _NT_TIB32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NT_TIB32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SHARED_CACHE_MAP_LIST_CURSOR {
    #[doc = " offset: 0x0 (0)"]
    pub SharedCacheMapLinks: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Flags: ULONG,
}
impl Default for _SHARED_CACHE_MAP_LIST_CURSOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union EX_QUEUE_WORKER_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub QueueWorkerInfo: LONG,
}
impl Default for EX_QUEUE_WORKER_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl EX_QUEUE_WORKER_INFO {
    #[inline]
    pub fn QueueDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QueueDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MakeThreadsAsNecessary(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MakeThreadsAsNecessary(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WaitMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WaitMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WorkerCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_WorkerCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        QueueDisabled: ULONG,
        MakeThreadsAsNecessary: ULONG,
        WaitMode: ULONG,
        WorkerCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let QueueDisabled: u32 = unsafe { ::std::mem::transmute(QueueDisabled) };
            QueueDisabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MakeThreadsAsNecessary: u32 =
                unsafe { ::std::mem::transmute(MakeThreadsAsNecessary) };
            MakeThreadsAsNecessary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WaitMode: u32 = unsafe { ::std::mem::transmute(WaitMode) };
            WaitMode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let WorkerCount: u32 = unsafe { ::std::mem::transmute(WorkerCount) };
            WorkerCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KSYSTEM_TIME {
    #[doc = " offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub High1Time: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub High2Time: LONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PROCESSOR_IDLESTATE_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub TimeCheck: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub DemotePercent: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub PromotePercent: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub Spare: [UCHAR; 2usize],
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY {
    #[doc = " offset: 0x0 (0)"]
    pub Revision: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Flags: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub PolicyCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Policy: [PROCESSOR_IDLESTATE_INFO; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    #[doc = " offset: 0x2 (2)"]
    pub AsUSHORT: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    #[inline]
    pub fn AllowScaling(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AllowScaling(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disabled(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Disabled(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowScaling: USHORT,
        Disabled: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowScaling: u16 = unsafe { ::std::mem::transmute(AllowScaling) };
            AllowScaling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Disabled: u16 = unsafe { ::std::mem::transmute(Disabled) };
            Disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for PROCESSOR_IDLESTATE_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_DEADLOCK_THREAD {
    #[doc = " offset: 0x0 (0)"]
    pub Thread: *mut _KTHREAD,
    #[doc = " offset: 0x8 (8)"]
    pub CurrentSpinNode: *mut _VI_DEADLOCK_NODE,
    #[doc = " offset: 0x10 (16)"]
    pub CurrentOtherNode: *mut _VI_DEADLOCK_NODE,
    pub __bindgen_anon_1: _VI_DEADLOCK_THREAD__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub NodeCount: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub PagingCount: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_THREAD__bindgen_ty_1 {
    #[doc = " offset: 0x18 (24)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _VI_DEADLOCK_THREAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VI_DEADLOCK_THREAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xf8 (248) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_DEADLOCK_RESOURCE {
    #[doc = " offset: 0x0 (0)"]
    pub Type: _VI_DEADLOCK_RESOURCE_TYPE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x8 (8)"]
    pub ResourceAddress: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ThreadOwner: *mut _VI_DEADLOCK_THREAD,
    #[doc = " offset: 0x18 (24)"]
    pub ResourceList: _LIST_ENTRY,
    pub __bindgen_anon_1: _VI_DEADLOCK_RESOURCE__bindgen_ty_1,
    #[doc = " offset: 0x38 (56)"]
    pub StackTrace: [*mut VOID; 8usize],
    #[doc = " offset: 0x78 (120)"]
    pub LastAcquireTrace: [*mut VOID; 8usize],
    #[doc = " offset: 0xb8 (184)"]
    pub LastReleaseTrace: [*mut VOID; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_RESOURCE__bindgen_ty_1 {
    #[doc = " offset: 0x28 (40)"]
    pub HashChainList: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _VI_DEADLOCK_RESOURCE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VI_DEADLOCK_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VI_DEADLOCK_RESOURCE {
    #[inline]
    pub fn NodeCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_NodeCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn RecursionCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_RecursionCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NodeCount: ULONG,
        RecursionCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let NodeCount: u32 = unsafe { ::std::mem::transmute(NodeCount) };
            NodeCount as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let RecursionCount: u32 = unsafe { ::std::mem::transmute(RecursionCount) };
            RecursionCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0xd0 (208) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_DEADLOCK_NODE {
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _VI_DEADLOCK_NODE,
    #[doc = " offset: 0x8 (8)"]
    pub ChildrenList: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub SiblingsList: _LIST_ENTRY,
    pub __bindgen_anon_1: _VI_DEADLOCK_NODE__bindgen_ty_1,
    #[doc = " offset: 0x38 (56)"]
    pub Root: *mut _VI_DEADLOCK_RESOURCE,
    #[doc = " offset: 0x40 (64)"]
    pub ThreadEntry: *mut _VI_DEADLOCK_THREAD,
    #[doc = " offset: 0x48 (72)"]
    pub u1: _VI_DEADLOCK_NODE__bindgen_ty_2,
    #[doc = " offset: 0x4c (76)"]
    pub ChildrenCount: LONG,
    #[doc = " offset: 0x50 (80)"]
    pub StackTrace: [*mut VOID; 8usize],
    #[doc = " offset: 0x90 (144)"]
    pub ParentStackTrace: [*mut VOID; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_NODE__bindgen_ty_1 {
    #[doc = " offset: 0x28 (40)"]
    pub ResourceList: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _VI_DEADLOCK_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_DEADLOCK_NODE__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x48 (72)"]
    pub Whole: ULONG,
}
impl Default for _VI_DEADLOCK_NODE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VI_DEADLOCK_NODE__bindgen_ty_2 {
    #[inline]
    pub fn Active(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Active(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OnlyTryAcquireUsed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OnlyTryAcquireUsed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReleasedOutOfOrder(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReleasedOutOfOrder(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SequenceNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_SequenceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Active: ULONG,
        OnlyTryAcquireUsed: ULONG,
        ReleasedOutOfOrder: ULONG,
        SequenceNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Active: u32 = unsafe { ::std::mem::transmute(Active) };
            Active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OnlyTryAcquireUsed: u32 = unsafe { ::std::mem::transmute(OnlyTryAcquireUsed) };
            OnlyTryAcquireUsed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReleasedOutOfOrder: u32 = unsafe { ::std::mem::transmute(ReleasedOutOfOrder) };
            ReleasedOutOfOrder as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let SequenceNumber: u32 = unsafe { ::std::mem::transmute(SequenceNumber) };
            SequenceNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VI_DEADLOCK_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MM_SESSION_SPACE_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MM_SESSION_SPACE_FLAGS {
    #[inline]
    pub fn Initialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Initialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeletePending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeletePending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoolInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DynamicVaInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DynamicVaInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WsInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WsInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolDestroyed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoolDestroyed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ObjectInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ObjectInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Filler(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Filler(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Initialized: ULONG,
        DeletePending: ULONG,
        PoolInitialized: ULONG,
        DynamicVaInitialized: ULONG,
        WsInitialized: ULONG,
        PoolDestroyed: ULONG,
        ObjectInitialized: ULONG,
        Filler: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Initialized: u32 = unsafe { ::std::mem::transmute(Initialized) };
            Initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeletePending: u32 = unsafe { ::std::mem::transmute(DeletePending) };
            DeletePending as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PoolInitialized: u32 = unsafe { ::std::mem::transmute(PoolInitialized) };
            PoolInitialized as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DynamicVaInitialized: u32 = unsafe { ::std::mem::transmute(DynamicVaInitialized) };
            DynamicVaInitialized as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WsInitialized: u32 = unsafe { ::std::mem::transmute(WsInitialized) };
            WsInitialized as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PoolDestroyed: u32 = unsafe { ::std::mem::transmute(PoolDestroyed) };
            PoolDestroyed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ObjectInitialized: u32 = unsafe { ::std::mem::transmute(ObjectInitialized) };
            ObjectInitialized as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Filler: u32 = unsafe { ::std::mem::transmute(Filler) };
            Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct POWER_ACTION_POLICY {
    #[doc = " offset: 0x0 (0)"]
    pub Action: POWER_ACTION,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub EventCode: ULONG,
}
impl Default for POWER_ACTION_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SYSTEM_POWER_LEVEL {
    #[doc = " offset: 0x0 (0)"]
    pub Enable: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Spare: [UCHAR; 3usize],
    #[doc = " offset: 0x4 (4)"]
    pub BatteryLevel: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PowerPolicy: POWER_ACTION_POLICY,
    #[doc = " offset: 0x14 (20)"]
    pub MinSystemState: _SYSTEM_POWER_STATE,
}
impl Default for SYSTEM_POWER_LEVEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_NOTIFY_ORDER_LEVEL {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceCount: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ActiveCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub WaitSleep: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub ReadySleep: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub ReadyS0: _LIST_ENTRY,
    #[doc = " offset: 0x38 (56)"]
    pub WaitS0: _LIST_ENTRY,
}
impl Default for _PO_NOTIFY_ORDER_LEVEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x250 (592) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_DEVICE_NOTIFY_ORDER {
    #[doc = " offset: 0x0 (0)"]
    pub Locked: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub WarmEjectPdoPointer: *mut *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub OrderLevel: [_PO_NOTIFY_ORDER_LEVEL; 8usize],
}
impl Default for _PO_DEVICE_NOTIFY_ORDER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct BATTERY_REPORTING_SCALE {
    #[doc = " offset: 0x0 (0)"]
    pub Granularity: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Capacity: ULONG,
}
#[doc = " 0x4c (76) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SYSTEM_POWER_CAPABILITIES {
    #[doc = " offset: 0x0 (0)"]
    pub PowerButtonPresent: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub SleepButtonPresent: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub LidPresent: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub SystemS1: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub SystemS2: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub SystemS3: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub SystemS4: UCHAR,
    #[doc = " offset: 0x7 (7)"]
    pub SystemS5: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub HiberFilePresent: UCHAR,
    #[doc = " offset: 0x9 (9)"]
    pub FullWake: UCHAR,
    #[doc = " offset: 0xa (10)"]
    pub VideoDimPresent: UCHAR,
    #[doc = " offset: 0xb (11)"]
    pub ApmPresent: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub UpsPresent: UCHAR,
    #[doc = " offset: 0xd (13)"]
    pub ThermalControl: UCHAR,
    #[doc = " offset: 0xe (14)"]
    pub ProcessorThrottle: UCHAR,
    #[doc = " offset: 0xf (15)"]
    pub ProcessorMinThrottle: UCHAR,
    #[doc = " offset: 0x10 (16)"]
    pub ProcessorMaxThrottle: UCHAR,
    #[doc = " offset: 0x11 (17)"]
    pub FastSystemS4: UCHAR,
    #[doc = " offset: 0x12 (18)"]
    pub spare2: [UCHAR; 3usize],
    #[doc = " offset: 0x15 (21)"]
    pub DiskSpinDown: UCHAR,
    #[doc = " offset: 0x16 (22)"]
    pub spare3: [UCHAR; 8usize],
    #[doc = " offset: 0x1e (30)"]
    pub SystemBatteriesPresent: UCHAR,
    #[doc = " offset: 0x1f (31)"]
    pub BatteriesAreShortTerm: UCHAR,
    #[doc = " offset: 0x20 (32)"]
    pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
    #[doc = " offset: 0x38 (56)"]
    pub AcOnLineWake: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x3c (60)"]
    pub SoftLidWake: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x40 (64)"]
    pub RtcWake: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x44 (68)"]
    pub MinDeviceWakeState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x48 (72)"]
    pub DefaultLowLatencyWake: _SYSTEM_POWER_STATE,
}
impl Default for SYSTEM_POWER_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_DISPLAY_RESUME_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub WorkItem: _WORK_QUEUE_ITEM,
    #[doc = " offset: 0x20 (32)"]
    pub WorkerThread: *mut _ETHREAD,
    #[doc = " offset: 0x28 (40)"]
    pub PrepareUIEvent: _KEVENT,
    #[doc = " offset: 0x40 (64)"]
    pub PowerOnEvent: _KEVENT,
    #[doc = " offset: 0x58 (88)"]
    pub DoneEvent: _KEVENT,
    #[doc = " offset: 0x70 (112)"]
    pub WorkerQueued: ULONG,
    #[doc = " offset: 0x74 (116)"]
    pub WorkerAbort: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub NoResumeUI: ULONG,
}
impl Default for _POP_DISPLAY_RESUME_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_HANDLE_TABLE_ENTRY {
    pub __bindgen_anon_1: _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x0 (0)"]
    pub NextFree: *mut _RTL_HANDLE_TABLE_ENTRY,
}
impl Default for _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTL_HANDLE_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_DEBUG_DIRECTORY {
    #[doc = " offset: 0x0 (0)"]
    pub Characteristics: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub TimeDateStamp: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MajorVersion: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub MinorVersion: USHORT,
    #[doc = " offset: 0xc (12)"]
    pub Type: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub SizeOfData: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub AddressOfRawData: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub PointerToRawData: ULONG,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub Name: [UCHAR; 8usize],
    #[doc = " offset: 0x8 (8)"]
    pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
    #[doc = " offset: 0xc (12)"]
    pub VirtualAddress: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub SizeOfRawData: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub PointerToRawData: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub PointerToRelocations: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub PointerToLinenumbers: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub NumberOfRelocations: USHORT,
    #[doc = " offset: 0x22 (34)"]
    pub NumberOfLinenumbers: USHORT,
    #[doc = " offset: 0x24 (36)"]
    pub Characteristics: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub PhysicalAddress: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub VirtualSize: ULONG,
}
impl Default for _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IMAGE_SECTION_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KBUGCHECK_ACTIVE_STATE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub Value: LONG,
}
impl Default for _KBUGCHECK_ACTIVE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KBUGCHECK_ACTIVE_STATE {
    #[inline]
    pub fn BugCheckState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BugCheckState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RecursionCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RecursionCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BugCheckOwner(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_BugCheckOwner(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BugCheckState: ULONG,
        RecursionCount: ULONG,
        BugCheckOwner: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let BugCheckState: u32 = unsafe { ::std::mem::transmute(BugCheckState) };
            BugCheckState as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let RecursionCount: u32 = unsafe { ::std::mem::transmute(RecursionCount) };
            RecursionCount as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let BugCheckOwner: u32 = unsafe { ::std::mem::transmute(BugCheckOwner) };
            BugCheckOwner as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _STRING32 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Buffer: ULONG,
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY {
    #[doc = " offset: 0x0 (0)"]
    pub Revision: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub MaxThrottle: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub MinThrottle: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub BusyAdjThreshold: UCHAR,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub TimeCheck: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub IncreaseTime: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub DecreaseTime: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub IncreasePercent: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DecreasePercent: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
    #[doc = " offset: 0x7 (7)"]
    pub Spare: UCHAR,
    #[doc = " offset: 0x7 (7)"]
    pub Flags: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x7 (7)"]
    pub AsUCHAR: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoDomainAccounting(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NoDomainAccounting(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IncreasePolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IncreasePolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DecreasePolicy(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DecreasePolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoDomainAccounting: UCHAR,
        IncreasePolicy: UCHAR,
        DecreasePolicy: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoDomainAccounting: u8 = unsafe { ::std::mem::transmute(NoDomainAccounting) };
            NoDomainAccounting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let IncreasePolicy: u8 = unsafe { ::std::mem::transmute(IncreasePolicy) };
            IncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let DecreasePolicy: u8 = unsafe { ::std::mem::transmute(DecreasePolicy) };
            DecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for PROCESSOR_PERFSTATE_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_ACTION_TRIGGER {
    #[doc = " offset: 0x0 (0)"]
    pub Type: POP_POLICY_DEVICE_TYPE,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Wait: *mut _POP_TRIGGER_WAIT,
    pub __bindgen_anon_1: _POP_ACTION_TRIGGER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POP_ACTION_TRIGGER__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub Battery: _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub Button: _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Level: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POP_ACTION_TRIGGER__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub Type: ULONG,
}
impl Default for _POP_ACTION_TRIGGER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POP_ACTION_TRIGGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_TRIGGER_WAIT {
    #[doc = " offset: 0x0 (0)"]
    pub Event: _KEVENT,
    #[doc = " offset: 0x18 (24)"]
    pub Status: LONG,
    #[doc = " offset: 0x20 (32)"]
    pub Link: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub Trigger: *mut _POP_ACTION_TRIGGER,
}
impl Default for _POP_TRIGGER_WAIT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KGUARDED_MUTEX {
    #[doc = " offset: 0x0 (0)"]
    pub Count: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub Owner: *mut _KTHREAD,
    #[doc = " offset: 0x10 (16)"]
    pub Contention: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Gate: _KGATE,
    pub __bindgen_anon_1: _KGUARDED_MUTEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KGUARDED_MUTEX__bindgen_ty_1 {
    pub __bindgen_anon_1: _KGUARDED_MUTEX__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x30 (48)"]
    pub CombinedApcDisable: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KGUARDED_MUTEX__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x30 (48)"]
    pub KernelApcDisable: SHORT,
    #[doc = " offset: 0x32 (50)"]
    pub SpecialApcDisable: SHORT,
}
impl Default for _KGUARDED_MUTEX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KGUARDED_MUTEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x88 (136) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_DEVICE_EVENT_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Status: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub EventQueueMutex: _KMUTANT,
    #[doc = " offset: 0x40 (64)"]
    pub Lock: _KGUARDED_MUTEX,
    #[doc = " offset: 0x78 (120)"]
    pub List: _LIST_ENTRY,
}
impl Default for _PNP_DEVICE_EVENT_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_RANGE_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Count: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Stamp: ULONG,
}
impl Default for _RTL_RANGE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TEB_ACTIVE_FRAME_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FrameName: *const CHAR,
}
impl Default for _TEB_ACTIVE_FRAME_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_TRACK_IRQL {
    #[doc = " offset: 0x0 (0)"]
    pub Thread: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub OldIrql: UCHAR,
    #[doc = " offset: 0x9 (9)"]
    pub NewIrql: UCHAR,
    #[doc = " offset: 0xa (10)"]
    pub Processor: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub TickCount: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub StackTrace: [*mut VOID; 5usize],
}
impl Default for _VI_TRACK_IRQL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CALL_HASH_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub CallersAddress: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub CallersCaller: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub CallCount: ULONG,
}
impl Default for _CALL_HASH_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_STOP_ON_TAG {
    pub __bindgen_anon_1: _HEAP_STOP_ON_TAG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_STOP_ON_TAG__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub HeapAndTagIndex: ULONG,
    pub __bindgen_anon_1: _HEAP_STOP_ON_TAG__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_STOP_ON_TAG__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub TagIndex: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub HeapIndex: USHORT,
}
impl Default for _HEAP_STOP_ON_TAG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_STOP_ON_TAG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _UNEXPECTED_INTERRUPT {
    #[doc = " offset: 0x0 (0)"]
    pub PushImmOp: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub PushImm: ULONG,
    #[doc = " offset: 0x5 (5)"]
    pub PushRbp: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub JmpOp: UCHAR,
    #[doc = " offset: 0x7 (7)"]
    pub JmpOffset: LONG,
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PI_BUS_EXTENSION {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub NumberCSNs: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub ReadDataPort: *mut UCHAR,
    #[doc = " offset: 0x10 (16)"]
    pub DataPortMapped: UCHAR,
    #[doc = " offset: 0x18 (24)"]
    pub AddressPort: *mut UCHAR,
    #[doc = " offset: 0x20 (32)"]
    pub AddrPortMapped: UCHAR,
    #[doc = " offset: 0x28 (40)"]
    pub CommandPort: *mut UCHAR,
    #[doc = " offset: 0x30 (48)"]
    pub CmdPortMapped: UCHAR,
    #[doc = " offset: 0x34 (52)"]
    pub NextSlotNumber: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub DeviceList: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x40 (64)"]
    pub CardList: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x48 (72)"]
    pub PhysicalBusDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x50 (80)"]
    pub FunctionalBusDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x58 (88)"]
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x60 (96)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0x64 (100)"]
    pub SystemPowerState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x68 (104)"]
    pub DevicePowerState: _DEVICE_POWER_STATE,
}
impl Default for _PI_BUS_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _BUS_EXTENSION_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub BusExtension: *mut _PI_BUS_EXTENSION,
}
impl Default for _BUS_EXTENSION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMSECURE_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _MMSECURE_FLAGS {
    #[inline]
    pub fn ReadOnly(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoWrite(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoWrite(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReadOnly: ULONG,
        NoWrite: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoWrite: u32 = unsafe { ::std::mem::transmute(NoWrite) };
            NoWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMADDRESS_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MMADDRESS_LIST__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub EndVa: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMADDRESS_LIST__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: _MMSECURE_FLAGS,
    #[doc = " offset: 0x0 (0)"]
    pub StartVa: *mut VOID,
}
impl Default for _MMADDRESS_LIST__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMADDRESS_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_REF_STACK_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub Sequence: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Index: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub NumTraces: USHORT,
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECURITY_TOKEN_AUDIT_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub GrantMask: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DenyMask: ULONG,
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECURITY_TOKEN_PROXY_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ProxyClass: _PROXY_CLASS,
    #[doc = " offset: 0x8 (8)"]
    pub PathInfo: _UNICODE_STRING,
    #[doc = " offset: 0x18 (24)"]
    pub ContainerMask: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub ObjectMask: ULONG,
}
impl Default for _SECURITY_TOKEN_PROXY_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SID_AND_ATTRIBUTES {
    #[doc = " offset: 0x0 (0)"]
    pub Sid: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Attributes: ULONG,
}
impl Default for _SID_AND_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_MESSAGE_ATTRIBUTES {
    #[doc = " offset: 0x0 (0)"]
    pub AllocatedAttributes: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ValidAttributes: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CLIENT_ID32 {
    #[doc = " offset: 0x0 (0)"]
    pub UniqueProcess: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub UniqueThread: ULONG,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PORT_MESSAGE32 {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _PORT_MESSAGE32__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub u2: _PORT_MESSAGE32__bindgen_ty_2,
    pub __bindgen_anon_1: _PORT_MESSAGE32__bindgen_ty_3,
    #[doc = " offset: 0x10 (16)"]
    pub MessageId: ULONG,
    pub __bindgen_anon_2: _PORT_MESSAGE32__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE32__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub s1: _PORT_MESSAGE32__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PORT_MESSAGE32__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub DataLength: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub TotalLength: SHORT,
}
impl Default for _PORT_MESSAGE32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE32__bindgen_ty_2 {
    #[doc = " offset: 0x4 (4)"]
    pub s2: _PORT_MESSAGE32__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub ZeroInit: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PORT_MESSAGE32__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub DataInfoOffset: SHORT,
}
impl Default for _PORT_MESSAGE32__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE32__bindgen_ty_3 {
    #[doc = " offset: 0x8 (8)"]
    pub ClientId: _CLIENT_ID32,
    #[doc = " offset: 0x8 (8)"]
    pub DoNotUseThisField: f64,
}
impl Default for _PORT_MESSAGE32__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE32__bindgen_ty_4 {
    #[doc = " offset: 0x14 (20)"]
    pub ClientViewSize: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub CallbackId: ULONG,
}
impl Default for _PORT_MESSAGE32__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PORT_MESSAGE32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TRACE_ENABLE_CONTEXT_EX {
    #[doc = " offset: 0x0 (0)"]
    pub LoggerId: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Level: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub InternalFlag: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub EnableFlags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub EnableFlagsHigh: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Reserved: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TRACE_ENABLE_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub LoggerId: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Level: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub InternalFlag: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub EnableFlags: ULONG,
}
#[doc = " 0xc8 (200) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub InLoadOrderLinks: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub InMemoryOrderLinks: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub InInitializationOrderLinks: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub DllBase: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub EntryPoint: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub SizeOfImage: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub FullDllName: _UNICODE_STRING,
    #[doc = " offset: 0x58 (88)"]
    pub BaseDllName: _UNICODE_STRING,
    #[doc = " offset: 0x68 (104)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x6c (108)"]
    pub LoadCount: USHORT,
    #[doc = " offset: 0x6e (110)"]
    pub TlsIndex: USHORT,
    pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _LDR_DATA_TABLE_ENTRY__bindgen_ty_2,
    #[doc = " offset: 0x88 (136)"]
    pub EntryPointActivationContext: *mut _ACTIVATION_CONTEXT,
    #[doc = " offset: 0x90 (144)"]
    pub PatchInformation: *mut VOID,
    #[doc = " offset: 0x98 (152)"]
    pub ForwarderLinks: _LIST_ENTRY,
    #[doc = " offset: 0xa8 (168)"]
    pub ServiceTagLinks: _LIST_ENTRY,
    #[doc = " offset: 0xb8 (184)"]
    pub StaticLinks: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x70 (112)"]
    pub HashLinks: _LIST_ENTRY,
    pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x70 (112)"]
    pub SectionPointer: *mut VOID,
    #[doc = " offset: 0x78 (120)"]
    pub CheckSum: ULONG,
}
impl Default for _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY__bindgen_ty_2 {
    #[doc = " offset: 0x80 (128)"]
    pub TimeDateStamp: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub LoadedImports: *mut VOID,
}
impl Default for _LDR_DATA_TABLE_ENTRY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LDR_DATA_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VACB_ARRAY_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub MappingCount: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Reserved: ULONG,
}
impl Default for _VACB_ARRAY_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PRIVATE_CACHE_MAP_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PRIVATE_CACHE_MAP_FLAGS {
    #[inline]
    pub fn DontUse(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DontUse(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadAheadActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadAheadActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadAheadEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadAheadEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PagePriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PagePriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Available(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_Available(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DontUse: ULONG,
        ReadAheadActive: ULONG,
        ReadAheadEnabled: ULONG,
        PagePriority: ULONG,
        Available: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let DontUse: u32 = unsafe { ::std::mem::transmute(DontUse) };
            DontUse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ReadAheadActive: u32 = unsafe { ::std::mem::transmute(ReadAheadActive) };
            ReadAheadActive as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReadAheadEnabled: u32 = unsafe { ::std::mem::transmute(ReadAheadEnabled) };
            ReadAheadEnabled as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let PagePriority: u32 = unsafe { ::std::mem::transmute(PagePriority) };
            PagePriority as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let Available: u32 = unsafe { ::std::mem::transmute(Available) };
            Available as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VOLUME_CACHE_MAP {
    #[doc = " offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub NodeByteCode: SHORT,
    #[doc = " offset: 0x4 (4)"]
    pub UseCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub VolumeCacheMapLinks: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub Flags: ULONG,
}
impl Default for _VOLUME_CACHE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CPU_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub Eax: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Ebx: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Ecx: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Edx: ULONG,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_GET_VERSION32 {
    #[doc = " offset: 0x0 (0)"]
    pub MajorVersion: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MinorVersion: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub ProtocolVersion: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub KernBase: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub PsLoadedModuleList: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub MachineType: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub ThCallbackStack: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub NextCallback: USHORT,
    #[doc = " offset: 0x16 (22)"]
    pub FramePointer: USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub KiCallUserMode: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub KeUserCallbackDispatcher: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub BreakpointWithStatus: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub DebuggerDataList: ULONG,
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARM_DBGKD_CONTROL_SET {
    #[doc = " offset: 0x0 (0)"]
    pub Continue: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub CurrentSymbolStart: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CurrentSymbolEnd: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _X86_DBGKD_CONTROL_SET {
    #[doc = " offset: 0x0 (0)"]
    pub TraceFlag: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Dr7: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CurrentSymbolStart: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub CurrentSymbolEnd: ULONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_SWITCH_PARTITION {
    #[doc = " offset: 0x0 (0)"]
    pub Partition: ULONG,
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_GET_SET_BUS_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub BusDataType: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub SlotNumber: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Offset: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Length: ULONG,
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_READ_WRITE_MSR {
    #[doc = " offset: 0x0 (0)"]
    pub Msr: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub DataValueLow: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DataValueHigh: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_BREAKPOINTEX {
    #[doc = " offset: 0x0 (0)"]
    pub BreakPointCount: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ContinueStatus: LONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_QUERY_SPECIAL_CALLS {
    #[doc = " offset: 0x0 (0)"]
    pub NumberOfSpecialCalls: ULONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_RESTORE_BREAKPOINT {
    #[doc = " offset: 0x0 (0)"]
    pub BreakPointHandle: ULONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_SET_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub ContextFlags: ULONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_GET_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Unused: ULONG,
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_GET_INTERNAL_BREAKPOINT32 {
    #[doc = " offset: 0x0 (0)"]
    pub BreakpointAddress: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Calls: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub MaxCallsPerPeriod: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub MinInstructions: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub MaxInstructions: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub TotalInstructions: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_SET_INTERNAL_BREAKPOINT32 {
    #[doc = " offset: 0x0 (0)"]
    pub BreakpointAddress: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: ULONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_SET_SPECIAL_CALL32 {
    #[doc = " offset: 0x0 (0)"]
    pub SpecialCall: ULONG,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_READ_WRITE_IO_EXTENDED32 {
    #[doc = " offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub InterfaceType: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub AddressSpace: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub IoAddress: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub DataValue: ULONG,
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_READ_WRITE_IO32 {
    #[doc = " offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub IoAddress: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DataValue: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_WRITE_BREAKPOINT32 {
    #[doc = " offset: 0x0 (0)"]
    pub BreakPointAddress: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub BreakPointHandle: ULONG,
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_WRITE_MEMORY32 {
    #[doc = " offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub TransferCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ActualBytesWritten: ULONG,
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_READ_MEMORY32 {
    #[doc = " offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub TransferCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ActualBytesRead: ULONG,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_LOAD_SYMBOLS32 {
    #[doc = " offset: 0x0 (0)"]
    pub PathNameLength: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub BaseOfDll: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ProcessId: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub CheckSum: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub SizeOfImage: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub UnloadSymbols: UCHAR,
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EXCEPTION_RECORD32 {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionCode: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub ExceptionFlags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ExceptionRecord: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ExceptionAddress: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub NumberParameters: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub ExceptionInformation: [ULONG; 15usize],
}
#[doc = " 0x54 (84) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKM_EXCEPTION32 {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionRecord: _EXCEPTION_RECORD32,
    #[doc = " offset: 0x50 (80)"]
    pub FirstChance: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PNP_ASSIGN_RESOURCES_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub IncludeFailedDevices: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub DeviceCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceList: [*mut _DEVICE_OBJECT; 1usize],
}
impl Default for _PNP_ASSIGN_RESOURCES_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_DEVICE_NOTIFY {
    #[doc = " offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub TargetDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x18 (24)"]
    pub OrderLevel: UCHAR,
    #[doc = " offset: 0x20 (32)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x28 (40)"]
    pub DeviceName: *mut USHORT,
    #[doc = " offset: 0x30 (48)"]
    pub DriverName: *mut USHORT,
    #[doc = " offset: 0x38 (56)"]
    pub ChildCount: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub ActiveChild: ULONG,
}
impl Default for _PO_DEVICE_NOTIFY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVICE_RELATIONS {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Objects: [*mut _DEVICE_OBJECT; 1usize],
}
impl Default for _DEVICE_RELATIONS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CONTEXT32_UPDATE {
    #[doc = " offset: 0x0 (0)"]
    pub NumberEntries: ULONG,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
    #[doc = " offset: 0x0 (0)"]
    pub Previous: *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME,
    #[doc = " offset: 0x8 (8)"]
    pub ActivationContext: *mut _ACTIVATION_CONTEXT,
    #[doc = " offset: 0x10 (16)"]
    pub Flags: ULONG,
}
impl Default for _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TEB_ACTIVE_FRAME {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Previous: *mut _TEB_ACTIVE_FRAME,
    #[doc = " offset: 0x10 (16)"]
    pub Context: *mut _TEB_ACTIVE_FRAME_CONTEXT,
}
impl Default for _TEB_ACTIVE_FRAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4e0 (1248) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _GDI_TEB_BATCH32 {
    #[doc = " offset: 0x0 (0)"]
    pub Offset: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub HDC: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ACTIVATION_CONTEXT_STACK {
    #[doc = " offset: 0x0 (0)"]
    pub ActiveFrame: *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME,
    #[doc = " offset: 0x8 (8)"]
    pub FrameListCache: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub NextCookieSequenceNumber: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub StackId: ULONG,
}
impl Default for _ACTIVATION_CONTEXT_STACK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    #[doc = " offset: 0x8 (8)"]
    pub StackBase: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub StackLimit: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub SubSystemTib: *mut VOID,
    pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub ArbitraryUserPointer: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub FiberData: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub Version: ULONG,
}
impl Default for _NT_TIB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NT_TIB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTRANSACTION_HISTORY {
    #[doc = " offset: 0x0 (0)"]
    pub RecordType: _KTRANSACTION_HISTORY__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub Payload: ULONG,
}
pub const _KTRANSACTION_HISTORY_KTMOH_CommitTransaction_Result:
    _KTRANSACTION_HISTORY__bindgen_ty_1 =
    _KTRANSACTION_HISTORY__bindgen_ty_1::KTMOH_CommitTransaction_Result;
pub const _KTRANSACTION_HISTORY_KTMOH_RollbackTransaction_Result:
    _KTRANSACTION_HISTORY__bindgen_ty_1 =
    _KTRANSACTION_HISTORY__bindgen_ty_1::KTMOH_RollbackTransaction_Result;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _KTRANSACTION_HISTORY__bindgen_ty_1 {
    KTMOH_CommitTransaction_Result = 1,
    KTMOH_RollbackTransaction_Result = 2,
}
impl Default for _KTRANSACTION_HISTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_AVL_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub BalancedRoot: _RTL_BALANCED_LINKS,
    #[doc = " offset: 0x20 (32)"]
    pub OrderedPointer: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub WhichOrderedElement: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub NumberGenericTableElements: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub DepthOfTree: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub RestartKey: *mut _RTL_BALANCED_LINKS,
    #[doc = " offset: 0x40 (64)"]
    pub DeleteCount: ULONG,
    pub CompareRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _RTL_AVL_TABLE,
            arg2: *mut VOID,
            arg3: *mut VOID,
        ) -> _RTL_GENERIC_COMPARE_RESULTS,
    >,
    pub AllocateRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _RTL_AVL_TABLE, arg2: ULONG) -> *mut VOID,
    >,
    pub FreeRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _RTL_AVL_TABLE, arg2: *mut VOID)>,
    #[doc = " offset: 0x60 (96)"]
    pub TableContext: *mut VOID,
}
impl Default for _RTL_AVL_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xa8 (168) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTMOBJECT_NAMESPACE {
    #[doc = " offset: 0x0 (0)"]
    pub Table: _RTL_AVL_TABLE,
    #[doc = " offset: 0x68 (104)"]
    pub Mutex: _KMUTANT,
    #[doc = " offset: 0xa0 (160)"]
    pub LinksOffset: USHORT,
    #[doc = " offset: 0xa2 (162)"]
    pub GuidOffset: USHORT,
    #[doc = " offset: 0xa4 (164)"]
    pub Expired: UCHAR,
}
impl Default for _KTMOBJECT_NAMESPACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KENLISTMENT_HISTORY {
    #[doc = " offset: 0x0 (0)"]
    pub Notification: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub NewState: _KENLISTMENT_STATE,
}
impl Default for _KENLISTMENT_HISTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_NAME_HASH {
    #[doc = " offset: 0x0 (0)"]
    pub ConvKey: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub NextHash: *mut _CM_NAME_HASH,
    #[doc = " offset: 0x10 (16)"]
    pub NameLength: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub Name: [WCHAR; 1usize],
}
impl Default for _CM_NAME_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_NAME_CONTROL_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub Compressed: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub RefCount: USHORT,
    pub __bindgen_anon_1: _CM_NAME_CONTROL_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_NAME_CONTROL_BLOCK__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub NameHash: _CM_NAME_HASH,
    pub __bindgen_anon_1: _CM_NAME_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_NAME_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub ConvKey: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub NextHash: *mut _CM_KEY_HASH,
    #[doc = " offset: 0x18 (24)"]
    pub NameLength: USHORT,
    #[doc = " offset: 0x1a (26)"]
    pub Name: [WCHAR; 1usize],
}
impl Default for _CM_NAME_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_NAME_CONTROL_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_NAME_CONTROL_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_CELL_REMAP_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub OldCell: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub NewCell: ULONG,
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
    #[doc = " offset: 0x0 (0)"]
    pub Revision: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Sbz1: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Control: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Owner: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Group: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Sacl: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Dacl: ULONG,
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_SECURITY_CACHE {
    #[doc = " offset: 0x0 (0)"]
    pub Cell: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ConvKey: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub List: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub DescriptorLength: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub RealRefCount: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub Descriptor: _SECURITY_DESCRIPTOR_RELATIVE,
}
impl Default for _CM_KEY_SECURITY_CACHE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_SECURITY_CACHE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Cell: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CachedSecurity: *mut _CM_KEY_SECURITY_CACHE,
}
impl Default for _CM_KEY_SECURITY_CACHE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CHILD_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub List: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_BIG_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Count: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub List: ULONG,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_SECURITY {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Flink: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Blink: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ReferenceCount: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub DescriptorLength: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Descriptor: _SECURITY_DESCRIPTOR_RELATIVE,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_VALUE {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub NameLength: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub DataLength: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Data: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Type: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub Spare: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub Name: [WCHAR; 1usize],
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CMP_OFFSET_ARRAY {
    #[doc = " offset: 0x0 (0)"]
    pub FileOffset: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DataBuffer: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub DataLength: ULONG,
}
impl Default for CMP_OFFSET_ARRAY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPAGING_FILE_FREE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub FreeBit: ULONG,
}
impl Default for _MMPAGING_FILE_FREE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MI_EXTRA_IMAGE_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub SizeOfHeaders: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ImageMerge: *mut VOID,
}
impl Default for _MI_EXTRA_IMAGE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SEGMENT_FLAGS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SEGMENT_FLAGS {
    #[inline]
    pub fn TotalNumberOfPtes4132(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_TotalNumberOfPtes4132(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtraSharedWowSubsections(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtraSharedWowSubsections(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePages(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LargePages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WatchProto(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WatchProto(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugSymbolsLoaded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DebugSymbolsLoaded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteCombined(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteCombined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoCache(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoCache(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FloppyMedia(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FloppyMedia(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultProtectionMask(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DefaultProtectionMask(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ContainsPxeSubsection(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContainsPxeSubsection(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Binary32(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Binary32(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TotalNumberOfPtes4132: ULONG,
        ExtraSharedWowSubsections: ULONG,
        LargePages: ULONG,
        WatchProto: ULONG,
        DebugSymbolsLoaded: ULONG,
        WriteCombined: ULONG,
        NoCache: ULONG,
        FloppyMedia: ULONG,
        DefaultProtectionMask: ULONG,
        ContainsPxeSubsection: ULONG,
        Binary32: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let TotalNumberOfPtes4132: u32 =
                unsafe { ::std::mem::transmute(TotalNumberOfPtes4132) };
            TotalNumberOfPtes4132 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ExtraSharedWowSubsections: u32 =
                unsafe { ::std::mem::transmute(ExtraSharedWowSubsections) };
            ExtraSharedWowSubsections as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let LargePages: u32 = unsafe { ::std::mem::transmute(LargePages) };
            LargePages as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WatchProto: u32 = unsafe { ::std::mem::transmute(WatchProto) };
            WatchProto as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let DebugSymbolsLoaded: u32 = unsafe { ::std::mem::transmute(DebugSymbolsLoaded) };
            DebugSymbolsLoaded as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let WriteCombined: u32 = unsafe { ::std::mem::transmute(WriteCombined) };
            WriteCombined as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NoCache: u32 = unsafe { ::std::mem::transmute(NoCache) };
            NoCache as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let FloppyMedia: u32 = unsafe { ::std::mem::transmute(FloppyMedia) };
            FloppyMedia as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let DefaultProtectionMask: u32 =
                unsafe { ::std::mem::transmute(DefaultProtectionMask) };
            DefaultProtectionMask as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ContainsPxeSubsection: u32 =
                unsafe { ::std::mem::transmute(ContainsPxeSubsection) };
            ContainsPxeSubsection as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Binary32: u32 = unsafe { ::std::mem::transmute(Binary32) };
            Binary32 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMSUBSECTION_NODE {
    #[doc = " offset: 0x0 (0)"]
    pub u: _MMSUBSECTION_NODE__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub StartingSector: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub NumberOfFullSectors: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub u1: _MMSUBSECTION_NODE__bindgen_ty_2,
    #[doc = " offset: 0x18 (24)"]
    pub LeftChild: *mut _MMSUBSECTION_NODE,
    #[doc = " offset: 0x20 (32)"]
    pub RightChild: *mut _MMSUBSECTION_NODE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMSUBSECTION_NODE__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub LongFlags: ULONG,
    #[doc = " offset: 0x0 (0)"]
    pub SubsectionFlags: _MMSUBSECTION_FLAGS,
}
impl Default for _MMSUBSECTION_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMSUBSECTION_NODE__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x10 (16)"]
    pub Parent: *mut _MMSUBSECTION_NODE,
}
impl Default for _MMSUBSECTION_NODE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMSUBSECTION_NODE__bindgen_ty_2 {
    #[inline]
    pub fn Balance(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Balance: LONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Balance: u64 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMSUBSECTION_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xa8 (168) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_FLUSH_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub MaximumCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FlushVa: [*mut VOID; 20usize],
}
impl Default for _MMPTE_FLUSH_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NETWORK_LOADER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub DHCPServerACK: *mut UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub DHCPServerACKLength: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub BootServerReplyPacket: *mut UCHAR,
    #[doc = " offset: 0x18 (24)"]
    pub BootServerReplyPacketLength: ULONG,
}
impl Default for _NETWORK_LOADER_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVICE_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _DEVICE_FLAGS {
    #[inline]
    pub fn Failed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Failed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ConsoleIn(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConsoleIn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ConsoleOut(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConsoleOut(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Input(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Input(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Output(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Output(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Failed: ULONG,
        ReadOnly: ULONG,
        Removable: ULONG,
        ConsoleIn: ULONG,
        ConsoleOut: ULONG,
        Input: ULONG,
        Output: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Failed: u32 = unsafe { ::std::mem::transmute(Failed) };
            Failed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Removable: u32 = unsafe { ::std::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ConsoleIn: u32 = unsafe { ::std::mem::transmute(ConsoleIn) };
            ConsoleIn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ConsoleOut: u32 = unsafe { ::std::mem::transmute(ConsoleOut) };
            ConsoleOut as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Input: u32 = unsafe { ::std::mem::transmute(Input) };
            Input as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Output: u32 = unsafe { ::std::mem::transmute(Output) };
            Output as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PCAT_FIRMWARE_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub PlaceHolder: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PROFILE_PARAMETER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub Status: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub DockingState: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Capabilities: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub DockID: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SerialNumber: ULONG,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CONFIGURATION_COMPONENT {
    #[doc = " offset: 0x0 (0)"]
    pub Class: _CONFIGURATION_CLASS,
    #[doc = " offset: 0x4 (4)"]
    pub Type: _CONFIGURATION_TYPE,
    #[doc = " offset: 0x8 (8)"]
    pub Flags: _DEVICE_FLAGS,
    #[doc = " offset: 0xc (12)"]
    pub Version: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub Revision: USHORT,
    #[doc = " offset: 0x10 (16)"]
    pub Key: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub AffinityMask: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub ConfigurationDataLength: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub IdentifierLength: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub Identifier: *mut CHAR,
}
impl Default for _CONFIGURATION_COMPONENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CONFIGURATION_COMPONENT_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _CONFIGURATION_COMPONENT_DATA,
    #[doc = " offset: 0x8 (8)"]
    pub Child: *mut _CONFIGURATION_COMPONENT_DATA,
    #[doc = " offset: 0x10 (16)"]
    pub Sibling: *mut _CONFIGURATION_COMPONENT_DATA,
    #[doc = " offset: 0x18 (24)"]
    pub ComponentEntry: _CONFIGURATION_COMPONENT,
    #[doc = " offset: 0x40 (64)"]
    pub ConfigurationData: *mut VOID,
}
impl Default for _CONFIGURATION_COMPONENT_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IA64_LOADER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub PlaceHolder: ULONG,
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPHA_LOADER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub PlaceHolder: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _I386_LOADER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub CommonDataArea: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub MachineType: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub VirtualBias: ULONG,
}
impl Default for _I386_LOADER_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_PACKET_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_PACKET_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_PACKET_FLAGS {
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CpuValid(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CpuValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HypervisorError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HypervisorError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PreviousError: ULONG,
        CpuValid: ULONG,
        HypervisorError: ULONG,
        Simulated: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PreviousError: u32 = unsafe { ::std::mem::transmute(PreviousError) };
            PreviousError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CpuValid: u32 = unsafe { ::std::mem::transmute(CpuValid) };
            CpuValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HypervisorError: u32 = unsafe { ::std::mem::transmute(HypervisorError) };
            HypervisorError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Simulated: u32 = unsafe { ::std::mem::transmute(Simulated) };
            Simulated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_PCIXDEVICE_ID {
    #[doc = " offset: 0x0 (0)"]
    pub VendorId: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub DeviceId: USHORT,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0xc (12)"]
    pub Reserved2: ULONG,
}
impl _WHEA_PCIXDEVICE_ID {
    #[inline]
    pub fn ClassCode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ClassCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn SegmentNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SegmentNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClassCode: ULONG,
        FunctionNumber: ULONG,
        DeviceNumber: ULONG,
        BusNumber: ULONG,
        SegmentNumber: ULONG,
        Reserved1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let ClassCode: u32 = unsafe { ::std::mem::transmute(ClassCode) };
            ClassCode as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let FunctionNumber: u32 = unsafe { ::std::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let DeviceNumber: u32 = unsafe { ::std::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let BusNumber: u32 = unsafe { ::std::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let SegmentNumber: u32 = unsafe { ::std::mem::transmute(SegmentNumber) };
            SegmentNumber as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS {
    pub __bindgen_anon_1: _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub BridgeSecondaryStatus: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub BridgeControl: USHORT,
}
impl Default for _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_PCIEXPRESS_DEVICE_ID {
    #[doc = " offset: 0x0 (0)"]
    pub VendorID: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub DeviceID: USHORT,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
impl _WHEA_PCIEXPRESS_DEVICE_ID {
    #[inline]
    pub fn ClassCode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ClassCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Segment(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Segment(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn PrimaryBusNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PrimaryBusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn SecondaryBusNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SecondaryBusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SlotNumber(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(74usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_SlotNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(74usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClassCode: ULONG,
        FunctionNumber: ULONG,
        DeviceNumber: ULONG,
        Segment: ULONG,
        PrimaryBusNumber: ULONG,
        SecondaryBusNumber: ULONG,
        Reserved1: ULONG,
        SlotNumber: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let ClassCode: u32 = unsafe { ::std::mem::transmute(ClassCode) };
            ClassCode as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let FunctionNumber: u32 = unsafe { ::std::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let DeviceNumber: u32 = unsafe { ::std::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(40usize, 16u8, {
            let Segment: u32 = unsafe { ::std::mem::transmute(Segment) };
            Segment as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let PrimaryBusNumber: u32 = unsafe { ::std::mem::transmute(PrimaryBusNumber) };
            PrimaryBusNumber as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let SecondaryBusNumber: u32 = unsafe { ::std::mem::transmute(SecondaryBusNumber) };
            SecondaryBusNumber as u64
        });
        __bindgen_bitfield_unit.set(72usize, 2u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(74usize, 14u8, {
            let SlotNumber: u32 = unsafe { ::std::mem::transmute(SlotNumber) };
            SlotNumber as u64
        });
        __bindgen_bitfield_unit.set(88usize, 8u8, {
            let Reserved2: u32 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_COMMAND_STATUS {
    pub __bindgen_anon_1: _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Command: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Status: USHORT,
}
impl Default for _WHEA_PCIEXPRESS_COMMAND_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_VERSION {
    pub __bindgen_anon_1: _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1,
    pub __bindgen_anon_2: _WHEA_PCIEXPRESS_VERSION__bindgen_ty_2,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub MinorVersion: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub MajorVersion: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WHEA_PCIEXPRESS_VERSION__bindgen_ty_2 {
    #[doc = " offset: 0x2 (2)"]
    pub Reserved: USHORT,
}
impl Default for _WHEA_PCIEXPRESS_VERSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_NMI_ERROR_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_NMI_ERROR_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_NMI_ERROR_FLAGS {
    #[inline]
    pub fn HypervisorError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HypervisorError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HypervisorError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HypervisorError: u32 = unsafe { ::std::mem::transmute(HypervisorError) };
            HypervisorError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_NMI_ERROR {
    #[doc = " offset: 0x0 (0)"]
    pub Data: [UCHAR; 8usize],
    #[doc = " offset: 0x8 (8)"]
    pub Flags: _WHEA_NMI_ERROR_FLAGS,
}
impl Default for _WHEA_NMI_ERROR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    #[inline]
    pub fn Primary(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Primary(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ContainmentWarning(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContainmentWarning(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reset(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThresholdExceeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThresholdExceeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ResourceNotAvailable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResourceNotAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LatentError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LatentError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Primary: ULONG,
        ContainmentWarning: ULONG,
        Reset: ULONG,
        ThresholdExceeded: ULONG,
        ResourceNotAvailable: ULONG,
        LatentError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Primary: u32 = unsafe { ::std::mem::transmute(Primary) };
            Primary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ContainmentWarning: u32 = unsafe { ::std::mem::transmute(ContainmentWarning) };
            ContainmentWarning as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Reset: u32 = unsafe { ::std::mem::transmute(Reset) };
            Reset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ThresholdExceeded: u32 = unsafe { ::std::mem::transmute(ThresholdExceeded) };
            ThresholdExceeded as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ResourceNotAvailable: u32 = unsafe { ::std::mem::transmute(ResourceNotAvailable) };
            ResourceNotAvailable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LatentError: u32 = unsafe { ::std::mem::transmute(LatentError) };
            LatentError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_HEADER_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_RECORD_HEADER_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_HEADER_FLAGS {
    #[inline]
    pub fn Recovered(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Recovered(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Recovered: ULONG,
        PreviousError: ULONG,
        Simulated: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Recovered: u32 = unsafe { ::std::mem::transmute(Recovered) };
            Recovered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PreviousError: u32 = unsafe { ::std::mem::transmute(PreviousError) };
            PreviousError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Simulated: u32 = unsafe { ::std::mem::transmute(Simulated) };
            Simulated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _GUID {
    #[doc = " offset: 0x0 (0)"]
    pub Data1: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Data2: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Data3: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Data4: [UCHAR; 8usize],
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVPROPKEY {
    #[doc = " offset: 0x0 (0)"]
    pub fmtid: _GUID,
    #[doc = " offset: 0x10 (16)"]
    pub pid: ULONG,
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_BODY {
    #[doc = " offset: 0x0 (0)"]
    pub Type: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub KeyControlBlock: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0x10 (16)"]
    pub NotifyBlock: *mut _CM_NOTIFY_BLOCK,
    #[doc = " offset: 0x18 (24)"]
    pub ProcessID: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub KeyBodyList: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub KtmTrans: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub KtmUow: *mut _GUID,
    #[doc = " offset: 0x48 (72)"]
    pub ContextListHead: _LIST_ENTRY,
}
impl Default for _CM_KEY_BODY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_NOTIFY_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub HiveList: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub PostList: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub KeyControlBlock: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0x28 (40)"]
    pub KeyBody: *mut _CM_KEY_BODY,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x38 (56)"]
    pub SubjectContext: _SECURITY_SUBJECT_CONTEXT,
}
impl Default for _CM_NOTIFY_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_NOTIFY_BLOCK {
    #[inline]
    pub fn Filter(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Filter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn WatchTree(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WatchTree(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NotifyPending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NotifyPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Filter: ULONG,
        WatchTree: ULONG,
        NotifyPending: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let Filter: u32 = unsafe { ::std::mem::transmute(Filter) };
            Filter as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let WatchTree: u32 = unsafe { ::std::mem::transmute(WatchTree) };
            WatchTree as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let NotifyPending: u32 = unsafe { ::std::mem::transmute(NotifyPending) };
            NotifyPending as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEADLESS_LOADER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub UsedBiosSettings: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub DataBits: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub StopBits: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub Parity: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub BaudRate: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PortNumber: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub PortAddress: *mut UCHAR,
    #[doc = " offset: 0x18 (24)"]
    pub PciDeviceId: USHORT,
    #[doc = " offset: 0x1a (26)"]
    pub PciVendorId: USHORT,
    #[doc = " offset: 0x1c (28)"]
    pub PciBusNumber: UCHAR,
    #[doc = " offset: 0x1e (30)"]
    pub PciBusSegment: USHORT,
    #[doc = " offset: 0x20 (32)"]
    pub PciSlotNumber: UCHAR,
    #[doc = " offset: 0x21 (33)"]
    pub PciFunctionNumber: UCHAR,
    #[doc = " offset: 0x24 (36)"]
    pub PciFlags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub SystemGUID: _GUID,
    #[doc = " offset: 0x38 (56)"]
    pub IsMMIODevice: UCHAR,
    #[doc = " offset: 0x39 (57)"]
    pub TerminalType: UCHAR,
}
impl Default for _HEADLESS_LOADER_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub SectionOffset: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub SectionLength: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Revision: _WHEA_REVISION,
    #[doc = " offset: 0xa (10)"]
    pub ValidBits: _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS,
    #[doc = " offset: 0xb (11)"]
    pub Reserved: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub Flags: _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS,
    #[doc = " offset: 0x10 (16)"]
    pub SectionType: _GUID,
    #[doc = " offset: 0x20 (32)"]
    pub FRUId: _GUID,
    #[doc = " offset: 0x30 (48)"]
    pub SectionSeverity: _WHEA_ERROR_SEVERITY,
    #[doc = " offset: 0x34 (52)"]
    pub FRUText: [CHAR; 20usize],
}
impl Default for _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONG: ULONG,
}
impl Default for _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    #[inline]
    pub fn Timestamp(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Timestamp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PlatformId(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PartitionId(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PartitionId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Timestamp: ULONG,
        PlatformId: ULONG,
        PartitionId: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Timestamp: u32 = unsafe { ::std::mem::transmute(Timestamp) };
            Timestamp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PlatformId: u32 = unsafe { ::std::mem::transmute(PlatformId) };
            PlatformId as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PartitionId: u32 = unsafe { ::std::mem::transmute(PartitionId) };
            PartitionId as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_FLAGS {
    #[doc = " offset: 0x0 (0)"]
    pub File: _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Private: _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn FilePointerIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_FilePointerIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn HardFault(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardFault(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Image(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Image(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilePointerIndex: ULONG,
        HardFault: ULONG,
        Image: ULONG,
        Spare0: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let FilePointerIndex: u32 = unsafe { ::std::mem::transmute(FilePointerIndex) };
            FilePointerIndex as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HardFault: u32 = unsafe { ::std::mem::transmute(HardFault) };
            HardFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Image: u32 = unsafe { ::std::mem::transmute(Image) };
            Image as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Spare0: u32 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _MM_PAGE_ACCESS_INFO_FLAGS__bindgen_ty_2 {
    #[inline]
    pub fn FilePointerIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_FilePointerIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn HardFault(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardFault(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilePointerIndex: ULONG,
        HardFault: ULONG,
        Spare1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let FilePointerIndex: u32 = unsafe { ::std::mem::transmute(FilePointerIndex) };
            FilePointerIndex as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HardFault: u32 = unsafe { ::std::mem::transmute(HardFault) };
            HardFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let Spare1: u32 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MM_PAGE_ACCESS_INFO_FLAGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PERFINFO_GROUPMASK {
    #[doc = " offset: 0x0 (0)"]
    pub Masks: [ULONG; 8usize],
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_DIRECTORY_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub ChainLink: *mut _OBJECT_DIRECTORY_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub Object: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub HashValue: ULONG,
}
impl Default for _OBJECT_DIRECTORY_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_DUMP_CONTROL {
    #[doc = " offset: 0x0 (0)"]
    pub Stream: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Detail: ULONG,
}
impl Default for _OBJECT_DUMP_CONTROL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _GENERIC_MAPPING {
    #[doc = " offset: 0x0 (0)"]
    pub GenericRead: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub GenericWrite: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub GenericExecute: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub GenericAll: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_HANDLE_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub HandleAttributes: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub GrantedAccess: ULONG,
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_ATTRIBUTES {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub RootDirectory: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ObjectName: *mut _UNICODE_STRING,
    #[doc = " offset: 0x18 (24)"]
    pub Attributes: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub SecurityQualityOfService: *mut VOID,
}
impl Default for _OBJECT_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_PRIORITY_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub Size: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ThreadPriority: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PagePriority: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub IoPriority: _IO_PRIORITY_HINT,
}
impl Default for _IO_PRIORITY_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ImpersonationLevel: _SECURITY_IMPERSONATION_LEVEL,
    #[doc = " offset: 0x8 (8)"]
    pub ContextTrackingMode: UCHAR,
    #[doc = " offset: 0x9 (9)"]
    pub EffectiveOnly: UCHAR,
}
impl Default for _SECURITY_QUALITY_OF_SERVICE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_CREATE_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub Attributes: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub RootDirectory: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ParseContext: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub ProbeMode: CHAR,
    #[doc = " offset: 0x1c (28)"]
    pub PagedPoolCharge: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub NonPagedPoolCharge: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub SecurityDescriptorCharge: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub SecurityQos: *mut _SECURITY_QUALITY_OF_SERVICE,
    #[doc = " offset: 0x38 (56)"]
    pub SecurityQualityOfService: _SECURITY_QUALITY_OF_SERVICE,
}
impl Default for _OBJECT_CREATE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_DRIVE_LETTER_CURDIR {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Length: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub TimeStamp: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DosPath: _STRING,
}
impl Default for _RTL_DRIVE_LETTER_CURDIR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HANDLE_TABLE_ENTRY_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub AuditMask: ULONG,
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HANDLE_TRACE_DB_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub ClientId: _CLIENT_ID,
    #[doc = " offset: 0x10 (16)"]
    pub Handle: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Type: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub StackTrace: [*mut VOID; 16usize],
}
impl Default for _HANDLE_TRACE_DB_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMWSLE_HASH {
    #[doc = " offset: 0x0 (0)"]
    pub Index: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMWSLE_NONDIRECT_HASH {
    #[doc = " offset: 0x0 (0)"]
    pub Key: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Index: ULONG,
}
impl Default for _MMWSLE_NONDIRECT_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POWER_SEQUENCE {
    #[doc = " offset: 0x0 (0)"]
    pub SequenceD1: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub SequenceD2: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub SequenceD3: ULONG,
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVICE_CAPABILITIES {
    #[doc = " offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Version: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x8 (8)"]
    pub Address: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub UINumber: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub DeviceState: [_DEVICE_POWER_STATE; 7usize],
    #[doc = " offset: 0x2c (44)"]
    pub SystemWake: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x30 (48)"]
    pub DeviceWake: _DEVICE_POWER_STATE,
    #[doc = " offset: 0x34 (52)"]
    pub D1Latency: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub D2Latency: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub D3Latency: ULONG,
}
impl Default for _DEVICE_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceD2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LockSupported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DockDevice(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UniqueID(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SilentInstall(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD3(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NonDynamic(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceD1: ULONG,
        DeviceD2: ULONG,
        LockSupported: ULONG,
        EjectSupported: ULONG,
        Removable: ULONG,
        DockDevice: ULONG,
        UniqueID: ULONG,
        SilentInstall: ULONG,
        RawDeviceOK: ULONG,
        SurpriseRemovalOK: ULONG,
        WakeFromD0: ULONG,
        WakeFromD1: ULONG,
        WakeFromD2: ULONG,
        WakeFromD3: ULONG,
        HardwareDisabled: ULONG,
        NonDynamic: ULONG,
        WarmEjectSupported: ULONG,
        NoDisplayInUI: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeviceD1: u32 = unsafe { ::std::mem::transmute(DeviceD1) };
            DeviceD1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeviceD2: u32 = unsafe { ::std::mem::transmute(DeviceD2) };
            DeviceD2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LockSupported: u32 = unsafe { ::std::mem::transmute(LockSupported) };
            LockSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EjectSupported: u32 = unsafe { ::std::mem::transmute(EjectSupported) };
            EjectSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Removable: u32 = unsafe { ::std::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DockDevice: u32 = unsafe { ::std::mem::transmute(DockDevice) };
            DockDevice as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UniqueID: u32 = unsafe { ::std::mem::transmute(UniqueID) };
            UniqueID as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SilentInstall: u32 = unsafe { ::std::mem::transmute(SilentInstall) };
            SilentInstall as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RawDeviceOK: u32 = unsafe { ::std::mem::transmute(RawDeviceOK) };
            RawDeviceOK as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SurpriseRemovalOK: u32 = unsafe { ::std::mem::transmute(SurpriseRemovalOK) };
            SurpriseRemovalOK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let WakeFromD0: u32 = unsafe { ::std::mem::transmute(WakeFromD0) };
            WakeFromD0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WakeFromD1: u32 = unsafe { ::std::mem::transmute(WakeFromD1) };
            WakeFromD1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WakeFromD2: u32 = unsafe { ::std::mem::transmute(WakeFromD2) };
            WakeFromD2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WakeFromD3: u32 = unsafe { ::std::mem::transmute(WakeFromD3) };
            WakeFromD3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HardwareDisabled: u32 = unsafe { ::std::mem::transmute(HardwareDisabled) };
            HardwareDisabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NonDynamic: u32 = unsafe { ::std::mem::transmute(NonDynamic) };
            NonDynamic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WarmEjectSupported: u32 = unsafe { ::std::mem::transmute(WarmEjectSupported) };
            WarmEjectSupported as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let NoDisplayInUI: u32 = unsafe { ::std::mem::transmute(NoDisplayInUI) };
            NoDisplayInUI as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x3f8 (1016) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_USER_PROCESS_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub MaximumLength: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub DebugFlags: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ConsoleHandle: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub ConsoleFlags: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub StandardInput: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub StandardOutput: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub StandardError: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub CurrentDirectory: _CURDIR,
    #[doc = " offset: 0x50 (80)"]
    pub DllPath: _UNICODE_STRING,
    #[doc = " offset: 0x60 (96)"]
    pub ImagePathName: _UNICODE_STRING,
    #[doc = " offset: 0x70 (112)"]
    pub CommandLine: _UNICODE_STRING,
    #[doc = " offset: 0x80 (128)"]
    pub Environment: *mut VOID,
    #[doc = " offset: 0x88 (136)"]
    pub StartingX: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub StartingY: ULONG,
    #[doc = " offset: 0x90 (144)"]
    pub CountX: ULONG,
    #[doc = " offset: 0x94 (148)"]
    pub CountY: ULONG,
    #[doc = " offset: 0x98 (152)"]
    pub CountCharsX: ULONG,
    #[doc = " offset: 0x9c (156)"]
    pub CountCharsY: ULONG,
    #[doc = " offset: 0xa0 (160)"]
    pub FillAttribute: ULONG,
    #[doc = " offset: 0xa4 (164)"]
    pub WindowFlags: ULONG,
    #[doc = " offset: 0xa8 (168)"]
    pub ShowWindowFlags: ULONG,
    #[doc = " offset: 0xb0 (176)"]
    pub WindowTitle: _UNICODE_STRING,
    #[doc = " offset: 0xc0 (192)"]
    pub DesktopInfo: _UNICODE_STRING,
    #[doc = " offset: 0xd0 (208)"]
    pub ShellInfo: _UNICODE_STRING,
    #[doc = " offset: 0xe0 (224)"]
    pub RuntimeData: _UNICODE_STRING,
    #[doc = " offset: 0xf0 (240)"]
    pub CurrentDirectores: [_RTL_DRIVE_LETTER_CURDIR; 32usize],
    #[doc = " offset: 0x3f0 (1008)"]
    pub EnvironmentSize: ULONGLONG,
}
impl Default for _RTL_USER_PROCESS_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PEB_LDR_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Initialized: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub SsHandle: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub InLoadOrderModuleList: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub InMemoryOrderModuleList: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub InInitializationOrderModuleList: _LIST_ENTRY,
    #[doc = " offset: 0x40 (64)"]
    pub EntryInProgress: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub ShutdownInProgress: UCHAR,
    #[doc = " offset: 0x50 (80)"]
    pub ShutdownThreadId: *mut VOID,
}
impl Default for _PEB_LDR_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4 (4) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub ContextAsUlong: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG,
        TargetSystemState: ULONG,
        EffectiveSystemState: ULONG,
        CurrentSystemState: ULONG,
        IgnoreHibernationPath: ULONG,
        PseudoTransition: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let TargetSystemState: u32 = unsafe { ::std::mem::transmute(TargetSystemState) };
            TargetSystemState as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let EffectiveSystemState: u32 = unsafe { ::std::mem::transmute(EffectiveSystemState) };
            EffectiveSystemState as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CurrentSystemState: u32 = unsafe { ::std::mem::transmute(CurrentSystemState) };
            CurrentSystemState as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let IgnoreHibernationPath: u32 =
                unsafe { ::std::mem::transmute(IgnoreHibernationPath) };
            IgnoreHibernationPath as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PseudoTransition: u32 = unsafe { ::std::mem::transmute(PseudoTransition) };
            PseudoTransition as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let Reserved2: u32 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_ROM_OPTIONAL_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub Magic: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MajorLinkerVersion: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub MinorLinkerVersion: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub SizeOfCode: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub SizeOfInitializedData: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SizeOfUninitializedData: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub AddressOfEntryPoint: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub BaseOfCode: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub BaseOfData: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub BaseOfBss: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub GprMask: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub CprMask: [ULONG; 4usize],
    #[doc = " offset: 0x34 (52)"]
    pub GpValue: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_INDEX_HINT_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub HashKey: [ULONG; 1usize],
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_INDEX {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Count: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub List: [ULONG; 1usize],
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SID {
    #[doc = " offset: 0x0 (0)"]
    pub Revision: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub SubAuthorityCount: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub IdentifierAuthority: _SID_IDENTIFIER_AUTHORITY,
    #[doc = " offset: 0x8 (8)"]
    pub SubAuthority: [ULONG; 1usize],
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub NextEntryOffset: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub SidLength: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Sid: _SID,
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _COMPRESSED_DATA_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub CompressionFormatAndEngine: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub CompressionUnitShift: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub ChunkShift: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub ClusterShift: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub Reserved: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub NumberOfChunks: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub CompressedChunkSizes: [ULONG; 1usize],
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POWER_CHANNEL_SUMMARY {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub TotalCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub D0Count: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub NotifyList: _LIST_ENTRY,
}
impl Default for _POWER_CHANNEL_SUMMARY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x98 (152) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    #[doc = " offset: 0x0 (0)"]
    pub IdleCount: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub BusyCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub TotalBusyCount: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ConservationIdleTime: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub PerformanceIdleTime: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x20 (32)"]
    pub IdleList: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub DeviceType: UCHAR,
    #[doc = " offset: 0x34 (52)"]
    pub IdleState: _DEVICE_POWER_STATE,
    #[doc = " offset: 0x38 (56)"]
    pub CurrentState: _DEVICE_POWER_STATE,
    #[doc = " offset: 0x40 (64)"]
    pub NotifySourceList: _LIST_ENTRY,
    #[doc = " offset: 0x50 (80)"]
    pub NotifyTargetList: _LIST_ENTRY,
    #[doc = " offset: 0x60 (96)"]
    pub PowerChannelSummary: _POWER_CHANNEL_SUMMARY,
    #[doc = " offset: 0x80 (128)"]
    pub Volume: _LIST_ENTRY,
    #[doc = " offset: 0x90 (144)"]
    pub Specific: _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1 {
    #[doc = " offset: 0x90 (144)"]
    pub Disk: _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub IdleTime: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub NonIdleTime: ULONG,
}
impl Default for _DEVICE_OBJECT_POWER_EXTENSION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DEVICE_OBJECT_POWER_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KDEVICE_QUEUE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub SortKey: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Inserted: UCHAR,
}
impl Default for _KDEVICE_QUEUE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VPB {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub VolumeLabelLength: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub RealDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x18 (24)"]
    pub SerialNumber: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub ReferenceCount: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub VolumeLabel: [WCHAR; 32usize],
}
impl Default for _VPB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVOBJ_EXTENSION {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub PowerFlags: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    #[doc = " offset: 0x20 (32)"]
    pub ExtensionFlags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub DeviceNode: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub AttachedTo: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x38 (56)"]
    pub StartIoCount: LONG,
    #[doc = " offset: 0x3c (60)"]
    pub StartIoKey: LONG,
    #[doc = " offset: 0x40 (64)"]
    pub StartIoFlags: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub Vpb: *mut _VPB,
    #[doc = " offset: 0x50 (80)"]
    pub DependentList: _LIST_ENTRY,
    #[doc = " offset: 0x60 (96)"]
    pub ProviderList: _LIST_ENTRY,
}
impl Default for _DEVOBJ_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FAST_MUTEX {
    #[doc = " offset: 0x0 (0)"]
    pub Count: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub Owner: *mut _KTHREAD,
    #[doc = " offset: 0x10 (16)"]
    pub Contention: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Gate: _KEVENT,
    #[doc = " offset: 0x30 (48)"]
    pub OldIrql: ULONG,
}
impl Default for _FAST_MUTEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xf0 (240) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HANDLE_TRACE_DEBUG_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub RefCount: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub TableSize: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub BitMaskFlags: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub CloseCompactionLock: _FAST_MUTEX,
    #[doc = " offset: 0x48 (72)"]
    pub CurrentStackIndex: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub TraceDb: [_HANDLE_TRACE_DB_ENTRY; 1usize],
}
impl Default for _HANDLE_TRACE_DEBUG_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PPM_DIA_STATS {
    #[doc = " offset: 0x0 (0)"]
    pub PerfLevel: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub IdleTime: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub TimeInterval: ULONG,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PPM_IDLE_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub IdleHandler:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG) -> LONG>,
    #[doc = " offset: 0x8 (8)"]
    pub Context: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Latency: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Power: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub TimeCheck: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub StateFlags: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub PromotePercent: UCHAR,
    #[doc = " offset: 0x21 (33)"]
    pub DemotePercent: UCHAR,
    #[doc = " offset: 0x22 (34)"]
    pub PromotePercentBase: UCHAR,
    #[doc = " offset: 0x23 (35)"]
    pub DemotePercentBase: UCHAR,
    #[doc = " offset: 0x24 (36)"]
    pub StateType: UCHAR,
}
impl Default for _PPM_IDLE_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KQUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = " offset: 0x18 (24)"]
    pub EntryListHead: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub CurrentCount: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub MaximumCount: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub ThreadListHead: _LIST_ENTRY,
}
impl Default for _KQUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_WORK_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub WorkerQueue: _KQUEUE,
    #[doc = " offset: 0x40 (64)"]
    pub DynamicThreadCount: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub WorkItemsProcessed: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub WorkItemsProcessedLastPass: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub QueueDepthLastPass: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub Info: EX_QUEUE_WORKER_INFO,
}
impl Default for _EX_WORK_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REPLY_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub Queue: _KQUEUE,
    #[doc = " offset: 0x40 (64)"]
    pub EventsLost: LONG,
}
impl Default for _ETW_REPLY_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_HANDLE_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub MaximumNumberOfHandles: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub SizeOfHandleTableEntry: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved: [ULONG; 2usize],
    #[doc = " offset: 0x10 (16)"]
    pub FreeHandles: *mut _RTL_HANDLE_TABLE_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub CommittedHandles: *mut _RTL_HANDLE_TABLE_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub UnCommittedHandles: *mut _RTL_HANDLE_TABLE_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub MaxReservedHandles: *mut _RTL_HANDLE_TABLE_ENTRY,
}
impl Default for _RTL_HANDLE_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KAPC {
    #[doc = " offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub SpareByte0: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Size: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub SpareByte1: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub SpareLong0: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Thread: *mut _KTHREAD,
    #[doc = " offset: 0x10 (16)"]
    pub ApcListEntry: _LIST_ENTRY,
    pub KernelRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _KAPC,
            arg2: *mut ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut VOID),
            >,
            arg3: *mut *mut VOID,
            arg4: *mut *mut VOID,
            arg5: *mut *mut VOID,
        ),
    >,
    #[doc = " offset: 0x28 (40)"]
    pub RundownRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _KAPC)>,
    pub NormalRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID, arg3: *mut VOID),
    >,
    #[doc = " offset: 0x38 (56)"]
    pub NormalContext: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub SystemArgument1: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub SystemArgument2: *mut VOID,
    #[doc = " offset: 0x50 (80)"]
    pub ApcStateIndex: CHAR,
    #[doc = " offset: 0x51 (81)"]
    pub ApcMode: CHAR,
    #[doc = " offset: 0x52 (82)"]
    pub Inserted: UCHAR,
}
impl Default for _KAPC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CACHE_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub Level: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Associativity: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub LineSize: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Size: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Type: _PROCESSOR_CACHE_TYPE,
}
impl Default for _CACHE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xe8 (232) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYSTEM_POWER_POLICY {
    #[doc = " offset: 0x0 (0)"]
    pub Revision: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub PowerButton: POWER_ACTION_POLICY,
    #[doc = " offset: 0x10 (16)"]
    pub SleepButton: POWER_ACTION_POLICY,
    #[doc = " offset: 0x1c (28)"]
    pub LidClose: POWER_ACTION_POLICY,
    #[doc = " offset: 0x28 (40)"]
    pub LidOpenWake: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x2c (44)"]
    pub Reserved: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub Idle: POWER_ACTION_POLICY,
    #[doc = " offset: 0x3c (60)"]
    pub IdleTimeout: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub IdleSensitivity: UCHAR,
    #[doc = " offset: 0x41 (65)"]
    pub DynamicThrottle: UCHAR,
    #[doc = " offset: 0x42 (66)"]
    pub Spare2: [UCHAR; 2usize],
    #[doc = " offset: 0x44 (68)"]
    pub MinSleep: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x48 (72)"]
    pub MaxSleep: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x4c (76)"]
    pub ReducedLatencySleep: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x50 (80)"]
    pub WinLogonFlags: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub Spare3: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub DozeS4Timeout: ULONG,
    #[doc = " offset: 0x5c (92)"]
    pub BroadcastCapacityResolution: ULONG,
    #[doc = " offset: 0x60 (96)"]
    pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
    #[doc = " offset: 0xc0 (192)"]
    pub VideoTimeout: ULONG,
    #[doc = " offset: 0xc4 (196)"]
    pub VideoDimDisplay: UCHAR,
    #[doc = " offset: 0xc8 (200)"]
    pub VideoReserved: [ULONG; 3usize],
    #[doc = " offset: 0xd4 (212)"]
    pub SpindownTimeout: ULONG,
    #[doc = " offset: 0xd8 (216)"]
    pub OptimizeForPower: UCHAR,
    #[doc = " offset: 0xd9 (217)"]
    pub FanThrottleTolerance: UCHAR,
    #[doc = " offset: 0xda (218)"]
    pub ForcedThrottle: UCHAR,
    #[doc = " offset: 0xdb (219)"]
    pub MinThrottle: UCHAR,
    #[doc = " offset: 0xdc (220)"]
    pub OverThrottled: POWER_ACTION_POLICY,
}
impl Default for _SYSTEM_POWER_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_DATA_DIRECTORY {
    #[doc = " offset: 0x0 (0)"]
    pub VirtualAddress: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Size: ULONG,
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_FILE_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub Machine: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub NumberOfSections: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub TimeDateStamp: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PointerToSymbolTable: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub NumberOfSymbols: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub SizeOfOptionalHeader: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub Characteristics: USHORT,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LUID {
    #[doc = " offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub HighPart: LONG,
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SEP_LOGON_SESSION_REFERENCES {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _SEP_LOGON_SESSION_REFERENCES,
    #[doc = " offset: 0x8 (8)"]
    pub LogonId: _LUID,
    #[doc = " offset: 0x10 (16)"]
    pub BuddyLogonId: _LUID,
    #[doc = " offset: 0x18 (24)"]
    pub ReferenceCount: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub pDeviceMap: *mut _DEVICE_MAP,
    #[doc = " offset: 0x28 (40)"]
    pub Token: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub AccountName: _UNICODE_STRING,
    #[doc = " offset: 0x40 (64)"]
    pub AuthorityName: _UNICODE_STRING,
}
impl Default for _SEP_LOGON_SESSION_REFERENCES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TOKEN_SOURCE {
    #[doc = " offset: 0x0 (0)"]
    pub SourceName: [CHAR; 8usize],
    #[doc = " offset: 0x8 (8)"]
    pub SourceIdentifier: _LUID,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TOKEN_CONTROL {
    #[doc = " offset: 0x0 (0)"]
    pub TokenId: _LUID,
    #[doc = " offset: 0x8 (8)"]
    pub AuthenticationId: _LUID,
    #[doc = " offset: 0x10 (16)"]
    pub ModifiedId: _LUID,
    #[doc = " offset: 0x18 (24)"]
    pub TokenSource: _TOKEN_SOURCE,
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECURITY_CLIENT_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityQos: _SECURITY_QUALITY_OF_SERVICE,
    #[doc = " offset: 0x10 (16)"]
    pub ClientToken: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub DirectlyAccessClientToken: UCHAR,
    #[doc = " offset: 0x19 (25)"]
    pub DirectAccessEffectiveOnly: UCHAR,
    #[doc = " offset: 0x1a (26)"]
    pub ServerIsRemote: UCHAR,
    #[doc = " offset: 0x1c (28)"]
    pub ClientTokenControl: _TOKEN_CONTROL,
}
impl Default for _SECURITY_CLIENT_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc (12) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LUID_AND_ATTRIBUTES {
    #[doc = " offset: 0x0 (0)"]
    pub Luid: _LUID,
    #[doc = " offset: 0x8 (8)"]
    pub Attributes: ULONG,
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PRIVILEGE_SET {
    #[doc = " offset: 0x0 (0)"]
    pub PrivilegeCount: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Control: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Privilege: [_LUID_AND_ATTRIBUTES; 1usize],
}
#[doc = " 0x2c (44) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _INITIAL_PRIVILEGE_SET {
    #[doc = " offset: 0x0 (0)"]
    pub PrivilegeCount: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Control: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Privilege: [_LUID_AND_ATTRIBUTES; 3usize],
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACCESS_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub OperationID: _LUID,
    #[doc = " offset: 0x8 (8)"]
    pub SecurityEvaluated: UCHAR,
    #[doc = " offset: 0x9 (9)"]
    pub GenerateAudit: UCHAR,
    #[doc = " offset: 0xa (10)"]
    pub GenerateOnClose: UCHAR,
    #[doc = " offset: 0xb (11)"]
    pub PrivilegesAllocated: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub RemainingDesiredAccess: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub PreviouslyGrantedAccess: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub OriginalDesiredAccess: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub SubjectSecurityContext: _SECURITY_SUBJECT_CONTEXT,
    #[doc = " offset: 0x40 (64)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub AuxData: *mut VOID,
    #[doc = " offset: 0x50 (80)"]
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    #[doc = " offset: 0x7c (124)"]
    pub AuditPrivileges: UCHAR,
    #[doc = " offset: 0x80 (128)"]
    pub ObjectName: _UNICODE_STRING,
    #[doc = " offset: 0x90 (144)"]
    pub ObjectTypeName: _UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ACCESS_STATE__bindgen_ty_1 {
    #[doc = " offset: 0x50 (80)"]
    pub InitialPrivilegeSet: _INITIAL_PRIVILEGE_SET,
    #[doc = " offset: 0x50 (80)"]
    pub PrivilegeSet: _PRIVILEGE_SET,
}
impl Default for _ACCESS_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ACCESS_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_SECURITY_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityQos: *mut _SECURITY_QUALITY_OF_SERVICE,
    #[doc = " offset: 0x8 (8)"]
    pub AccessState: *mut _ACCESS_STATE,
    #[doc = " offset: 0x10 (16)"]
    pub DesiredAccess: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub FullCreateOptions: ULONG,
}
impl Default for _IO_SECURITY_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub EventGuid: _GUID,
    #[doc = " offset: 0x10 (16)"]
    pub EventCategory: _PLUGPLAY_EVENT_CATEGORY,
    #[doc = " offset: 0x18 (24)"]
    pub Result: *mut ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub TotalSize: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub DeviceObject: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub u: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
    #[doc = " offset: 0x30 (48)"]
    pub DeviceClass: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x30 (48)"]
    pub TargetDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x30 (48)"]
    pub InstallDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3,
    #[doc = " offset: 0x30 (48)"]
    pub CustomNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4,
    #[doc = " offset: 0x30 (48)"]
    pub ProfileNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5,
    #[doc = " offset: 0x30 (48)"]
    pub PowerNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6,
    #[doc = " offset: 0x30 (48)"]
    pub VetoNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7,
    #[doc = " offset: 0x30 (48)"]
    pub BlockedDriverNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8,
    #[doc = " offset: 0x30 (48)"]
    pub InvalidIDNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9,
    #[doc = " offset: 0x30 (48)"]
    pub PowerSettingNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub ClassGuid: _GUID,
    #[doc = " offset: 0x10 (16)"]
    pub SymbolicLinkName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceIds: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " offset: 0x0 (0)"]
    pub NotificationStructure: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceIds: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " offset: 0x0 (0)"]
    pub Notification: *mut VOID,
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " offset: 0x0 (0)"]
    pub NotificationCode: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub NotificationData: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " offset: 0x0 (0)"]
    pub VetoType: _PNP_VETO_TYPE,
    #[doc = " offset: 0x4 (4)"]
    pub DeviceIdVetoNameBuffer: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8 {
    #[doc = " offset: 0x0 (0)"]
    pub BlockedDriverGuid: _GUID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9 {
    #[doc = " offset: 0x0 (0)"]
    pub ParentId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_10 {
    #[doc = " offset: 0x0 (0)"]
    pub PowerSettingGuid: _GUID,
    #[doc = " offset: 0x10 (16)"]
    pub PowerSettingChanged: UCHAR,
    #[doc = " offset: 0x14 (20)"]
    pub DataLength: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Data: [UCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PLUGPLAY_EVENT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x90 (144) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_DEVICE_EVENT_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Argument: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub CallerEvent: *mut _KEVENT,
    #[doc = " offset: 0x20 (32)"]
    pub Callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = " offset: 0x28 (40)"]
    pub Context: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub VetoType: *mut _PNP_VETO_TYPE,
    #[doc = " offset: 0x38 (56)"]
    pub VetoName: *mut _UNICODE_STRING,
    #[doc = " offset: 0x40 (64)"]
    pub Data: _PLUGPLAY_EVENT_BLOCK,
}
impl Default for _PNP_DEVICE_EVENT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_LIST_LOOKUP {
    #[doc = " offset: 0x0 (0)"]
    pub ExtendedLookup: *mut _HEAP_LIST_LOOKUP,
    #[doc = " offset: 0x8 (8)"]
    pub ArraySize: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ExtraItem: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ItemCount: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub OutOfRangeItems: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub BaseIndex: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub ListHead: *mut _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub ListsInUseUlong: *mut ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub ListHints: *mut *mut _LIST_ENTRY,
}
impl Default for _HEAP_LIST_LOOKUP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _BITMAP_RANGE {
    #[doc = " offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub BasePage: LONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub FirstDirtyPage: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub LastDirtyPage: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub DirtyPages: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub Bitmap: *mut ULONG,
}
impl Default for _BITMAP_RANGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xb8 (184) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MBCB {
    #[doc = " offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub NodeIsInZone: SHORT,
    #[doc = " offset: 0x4 (4)"]
    pub PagesToWrite: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DirtyPages: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Reserved: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub BitmapRanges: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub ResumeWritePage: LONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub BitmapRange1: _BITMAP_RANGE,
    #[doc = " offset: 0x58 (88)"]
    pub BitmapRange2: _BITMAP_RANGE,
    #[doc = " offset: 0x88 (136)"]
    pub BitmapRange3: _BITMAP_RANGE,
}
impl Default for _MBCB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_BITMAP {
    #[doc = " offset: 0x0 (0)"]
    pub SizeOfBitMap: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Buffer: *mut ULONG,
}
impl Default for _RTL_BITMAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FREE_DISPLAY {
    #[doc = " offset: 0x0 (0)"]
    pub RealVectorSize: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Display: _RTL_BITMAP,
}
impl Default for _FREE_DISPLAY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON {
    #[doc = " offset: 0x0 (0)"]
    pub Version: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Pool: *mut _TP_POOL,
    #[doc = " offset: 0x10 (16)"]
    pub CleanupGroup: *mut _TP_CLEANUP_GROUP,
    pub CleanupGroupCancelCallback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut VOID)>,
    #[doc = " offset: 0x20 (32)"]
    pub RaceDll: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub ActivationContext: *mut _ACTIVATION_CONTEXT,
    pub FinalizationCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _TP_CALLBACK_INSTANCE, arg2: *mut VOID),
    >,
    #[doc = " offset: 0x38 (56)"]
    pub u: _TP_CALLBACK_ENVIRON__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON__bindgen_ty_1 {
    #[doc = " offset: 0x38 (56)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub s: _TP_CALLBACK_ENVIRON__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TP_CALLBACK_ENVIRON__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _TP_CALLBACK_ENVIRON__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LongFunction(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LongFunction(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Private(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Private(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LongFunction: ULONG,
        Private: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LongFunction: u32 = unsafe { ::std::mem::transmute(LongFunction) };
            LongFunction as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Private: u32 = unsafe { ::std::mem::transmute(Private) };
            Private as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TP_CALLBACK_ENVIRON__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TP_CALLBACK_ENVIRON {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    #[doc = " offset: 0x0 (0)"]
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub HighPart: LONG,
}
impl Default for _LARGE_INTEGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_SYMBOLIC_LINK {
    #[doc = " offset: 0x0 (0)"]
    pub CreationTime: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub LinkTarget: _UNICODE_STRING,
    #[doc = " offset: 0x18 (24)"]
    pub LinkTargetRemaining: _UNICODE_STRING,
    #[doc = " offset: 0x28 (40)"]
    pub LinkTargetObject: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub DosDeviceDriveIndex: ULONG,
}
impl Default for _OBJECT_SYMBOLIC_LINK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEGMENT_OBJECT {
    #[doc = " offset: 0x0 (0)"]
    pub BaseAddress: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub TotalNumberOfPtes: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub SizeOfSegment: _LARGE_INTEGER,
    #[doc = " offset: 0x18 (24)"]
    pub NonExtendedPtes: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub ImageCommitment: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = " offset: 0x28 (40)"]
    pub Subsection: *mut _SUBSECTION,
    #[doc = " offset: 0x30 (48)"]
    pub MmSectionFlags: *mut _MMSECTION_FLAGS,
    #[doc = " offset: 0x38 (56)"]
    pub MmSubSectionFlags: *mut _MMSUBSECTION_FLAGS,
}
impl Default for _SEGMENT_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECTION_OBJECT {
    #[doc = " offset: 0x0 (0)"]
    pub StartingVa: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub EndingVa: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Parent: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub LeftChild: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub RightChild: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub Segment: *mut _SEGMENT_OBJECT,
}
impl Default for _SECTION_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_LAST_ENABLE_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub EnableFlags: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub LoggerId: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub Level: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _ETW_LAST_ENABLE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _ETW_LAST_ENABLE_INFO {
    #[inline]
    pub fn Enabled(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Enabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InternalFlag(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_InternalFlag(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enabled: UCHAR,
        InternalFlag: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enabled: u8 = unsafe { ::std::mem::transmute(Enabled) };
            Enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let InternalFlag: u8 = unsafe { ::std::mem::transmute(InternalFlag) };
            InternalFlag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_TRACE_HEADER {
    pub __bindgen_anon_1: _SYSTEM_TRACE_HEADER__bindgen_ty_1,
    pub __bindgen_anon_2: _SYSTEM_TRACE_HEADER__bindgen_ty_2,
    #[doc = " offset: 0x8 (8)"]
    pub ThreadId: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ProcessId: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub SystemTime: _LARGE_INTEGER,
    #[doc = " offset: 0x18 (24)"]
    pub KernelTime: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub UserTime: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_TRACE_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Marker: ULONG,
    pub __bindgen_anon_1: _SYSTEM_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYSTEM_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Version: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub HeaderType: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub Flags: UCHAR,
}
impl Default for _SYSTEM_TRACE_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_TRACE_HEADER__bindgen_ty_2 {
    #[doc = " offset: 0x4 (4)"]
    pub Header: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Packet: _WMI_TRACE_PACKET,
}
impl Default for _SYSTEM_TRACE_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYSTEM_TRACE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REF_CLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub StartTime: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub StartPerfClock: _LARGE_INTEGER,
}
impl Default for _ETW_REF_CLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1000 (4096) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HBASE_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Sequence1: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Sequence2: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub TimeStamp: _LARGE_INTEGER,
    #[doc = " offset: 0x14 (20)"]
    pub Major: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Minor: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub Type: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub Format: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub RootCell: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub Length: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub Cluster: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub FileName: [UCHAR; 64usize],
    #[doc = " offset: 0x70 (112)"]
    pub RmId: _GUID,
    #[doc = " offset: 0x80 (128)"]
    pub LogId: _GUID,
    #[doc = " offset: 0x90 (144)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x94 (148)"]
    pub TmId: _GUID,
    #[doc = " offset: 0xa4 (164)"]
    pub GuidSignature: ULONG,
    #[doc = " offset: 0xa8 (168)"]
    pub Reserved1: [ULONG; 85usize],
    #[doc = " offset: 0x1fc (508)"]
    pub CheckSum: ULONG,
    #[doc = " offset: 0x200 (512)"]
    pub Reserved2: [ULONG; 882usize],
    #[doc = " offset: 0xfc8 (4040)"]
    pub ThawTmId: _GUID,
    #[doc = " offset: 0xfd8 (4056)"]
    pub ThawRmId: _GUID,
    #[doc = " offset: 0xfe8 (4072)"]
    pub ThawLogId: _GUID,
    #[doc = " offset: 0xff8 (4088)"]
    pub BootType: ULONG,
    #[doc = " offset: 0xffc (4092)"]
    pub BootRecover: ULONG,
}
impl Default for _HBASE_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x278 (632) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DUAL {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Map: *mut _HMAP_DIRECTORY,
    #[doc = " offset: 0x10 (16)"]
    pub SmallDir: *mut _HMAP_TABLE,
    #[doc = " offset: 0x18 (24)"]
    pub Guard: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub FreeDisplay: [_FREE_DISPLAY; 24usize],
    #[doc = " offset: 0x260 (608)"]
    pub FreeSummary: ULONG,
    #[doc = " offset: 0x268 (616)"]
    pub FreeBins: _LIST_ENTRY,
}
impl Default for _DUAL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x590 (1424) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HHIVE {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    pub GetCellRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _HHIVE, arg2: ULONG) -> *mut _CELL_DATA,
    >,
    pub ReleaseCellRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _HHIVE, arg2: ULONG)>,
    #[doc = " offset: 0x18 (24)"]
    pub Allocate: ::std::option::Option<
        unsafe extern "C" fn(arg1: ULONG, arg2: UCHAR, arg3: ULONG) -> *mut VOID,
    >,
    #[doc = " offset: 0x20 (32)"]
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: ULONG)>,
    pub FileSetSize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _HHIVE, arg2: ULONG, arg3: ULONG, arg4: ULONG) -> UCHAR,
    >,
    pub FileWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _HHIVE,
            arg2: ULONG,
            arg3: *mut CMP_OFFSET_ARRAY,
            arg4: ULONG,
            arg5: *mut ULONG,
        ) -> UCHAR,
    >,
    pub FileRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _HHIVE,
            arg2: ULONG,
            arg3: *mut ULONG,
            arg4: *mut VOID,
            arg5: ULONG,
        ) -> UCHAR,
    >,
    pub FileFlush: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _HHIVE,
            arg2: ULONG,
            arg3: *mut _LARGE_INTEGER,
            arg4: ULONG,
        ) -> UCHAR,
    >,
    #[doc = " offset: 0x48 (72)"]
    pub BaseBlock: *mut _HBASE_BLOCK,
    #[doc = " offset: 0x50 (80)"]
    pub DirtyVector: _RTL_BITMAP,
    #[doc = " offset: 0x60 (96)"]
    pub DirtyCount: ULONG,
    #[doc = " offset: 0x64 (100)"]
    pub DirtyAlloc: ULONG,
    #[doc = " offset: 0x68 (104)"]
    pub BaseBlockAlloc: ULONG,
    #[doc = " offset: 0x6c (108)"]
    pub Cluster: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub Flat: UCHAR,
    #[doc = " offset: 0x71 (113)"]
    pub ReadOnly: UCHAR,
    #[doc = " offset: 0x72 (114)"]
    pub DirtyFlag: UCHAR,
    #[doc = " offset: 0x74 (116)"]
    pub HvBinHeadersUse: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub HvFreeCellsUse: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub HvUsedCellsUse: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub CmUsedCellsUse: ULONG,
    #[doc = " offset: 0x84 (132)"]
    pub HiveFlags: ULONG,
    #[doc = " offset: 0x88 (136)"]
    pub CurrentLog: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub LogSize: [ULONG; 2usize],
    #[doc = " offset: 0x94 (148)"]
    pub RefreshCount: ULONG,
    #[doc = " offset: 0x98 (152)"]
    pub StorageTypeCount: ULONG,
    #[doc = " offset: 0x9c (156)"]
    pub Version: ULONG,
    #[doc = " offset: 0xa0 (160)"]
    pub Storage: [_DUAL; 2usize],
}
impl Default for _HHIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_HASH {
    #[doc = " offset: 0x0 (0)"]
    pub ConvKey: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub NextHash: *mut _CM_KEY_HASH,
    #[doc = " offset: 0x10 (16)"]
    pub KeyHive: *mut _HHIVE,
    #[doc = " offset: 0x18 (24)"]
    pub KeyCell: ULONG,
}
impl Default for _CM_KEY_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_REFERENCE {
    #[doc = " offset: 0x0 (0)"]
    pub KeyCell: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub KeyHive: *mut _HHIVE,
}
impl Default for _CM_KEY_REFERENCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KEY_NODE {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = " offset: 0xc (12)"]
    pub Spare: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Parent: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub SubKeyCounts: [ULONG; 2usize],
    pub __bindgen_anon_1: _CM_KEY_NODE__bindgen_ty_1,
    #[doc = " offset: 0x2c (44)"]
    pub Security: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub Class: ULONG,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x38 (56)"]
    pub MaxClassLen: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub MaxValueNameLen: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub MaxValueDataLen: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub WorkVar: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub NameLength: USHORT,
    #[doc = " offset: 0x4a (74)"]
    pub ClassLength: USHORT,
    #[doc = " offset: 0x4c (76)"]
    pub Name: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_NODE__bindgen_ty_1 {
    pub __bindgen_anon_1: _CM_KEY_NODE__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x1c (28)"]
    pub ChildHiveReference: _CM_KEY_REFERENCE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_NODE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x1c (28)"]
    pub SubKeyLists: [ULONG; 2usize],
    #[doc = " offset: 0x24 (36)"]
    pub ValueList: _CHILD_LIST,
}
impl Default for _CM_KEY_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KEY_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_KEY_NODE {
    #[inline]
    pub fn MaxNameLen(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_MaxNameLen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn UserFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_UserFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn VirtControlFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_VirtControlFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Debug(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Debug(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MaxNameLen: ULONG,
        UserFlags: ULONG,
        VirtControlFlags: ULONG,
        Debug: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let MaxNameLen: u32 = unsafe { ::std::mem::transmute(MaxNameLen) };
            MaxNameLen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let UserFlags: u32 = unsafe { ::std::mem::transmute(UserFlags) };
            UserFlags as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let VirtControlFlags: u32 = unsafe { ::std::mem::transmute(VirtControlFlags) };
            VirtControlFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Debug: u32 = unsafe { ::std::mem::transmute(Debug) };
            Debug as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _u {
    #[doc = " offset: 0x0 (0)"]
    pub KeyNode: _CM_KEY_NODE,
    #[doc = " offset: 0x0 (0)"]
    pub KeyValue: _CM_KEY_VALUE,
    #[doc = " offset: 0x0 (0)"]
    pub KeySecurity: _CM_KEY_SECURITY,
    #[doc = " offset: 0x0 (0)"]
    pub KeyIndex: _CM_KEY_INDEX,
    #[doc = " offset: 0x0 (0)"]
    pub ValueData: _CM_BIG_DATA,
    #[doc = " offset: 0x0 (0)"]
    pub KeyList: [ULONG; 1usize],
    #[doc = " offset: 0x0 (0)"]
    pub KeyString: [WCHAR; 1usize],
}
impl Default for _u {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CELL_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub u: _u,
}
impl Default for _CELL_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_KERNEL_TRACE_TIMESTAMP {
    #[doc = " offset: 0x0 (0)"]
    pub KernelTraceTimeStamp: [_LARGE_INTEGER; 2usize],
}
impl Default for _ETW_KERNEL_TRACE_TIMESTAMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_HARDPAGEFAULT_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub ReadOffset: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub VirtualAddress: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub FileObject: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub ThreadId: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub ByteCount: ULONG,
}
impl Default for _PERFINFO_HARDPAGEFAULT_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_HARD_FAULT_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub KernelTimeStamp: _ETW_KERNEL_TRACE_TIMESTAMP,
    #[doc = " offset: 0x10 (16)"]
    pub HardFaultEvent: _PERFINFO_HARDPAGEFAULT_INFORMATION,
    #[doc = " offset: 0x30 (48)"]
    pub IoTimeInTicks: _LARGE_INTEGER,
}
impl Default for _PF_HARD_FAULT_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub MailslotQuota: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub MaximumMessageSize: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ReadTimeout: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub TimeoutSpecified: UCHAR,
}
impl Default for _MAILSLOT_CREATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub NamedPipeType: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ReadMode: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CompletionMode: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub MaximumInstances: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub InboundQuota: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub OutboundQuota: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DefaultTimeout: _LARGE_INTEGER,
    #[doc = " offset: 0x20 (32)"]
    pub TimeoutSpecified: UCHAR,
}
impl Default for _NAMED_PIPE_CREATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub CreationTime: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub LastAccessTime: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = " offset: 0x18 (24)"]
    pub ChangeTime: _LARGE_INTEGER,
    #[doc = " offset: 0x20 (32)"]
    pub AllocationSize: _LARGE_INTEGER,
    #[doc = " offset: 0x28 (40)"]
    pub EndOfFile: _LARGE_INTEGER,
    #[doc = " offset: 0x30 (48)"]
    pub FileAttributes: ULONG,
}
impl Default for _FILE_NETWORK_OPEN_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub AllocationSize: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub EndOfFile: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub NumberOfLinks: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub DeletePending: UCHAR,
    #[doc = " offset: 0x15 (21)"]
    pub Directory: UCHAR,
}
impl Default for _FILE_STANDARD_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub CreationTime: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub LastAccessTime: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = " offset: 0x18 (24)"]
    pub ChangeTime: _LARGE_INTEGER,
    #[doc = " offset: 0x20 (32)"]
    pub FileAttributes: ULONG,
}
impl Default for _FILE_BASIC_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUMP_INITIALIZATION_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Reserved: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MemoryBlock: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub CommonBuffer: [*mut VOID; 2usize],
    #[doc = " offset: 0x20 (32)"]
    pub PhysicalAddress: [_LARGE_INTEGER; 2usize],
    #[doc = " offset: 0x30 (48)"]
    pub StallRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: ULONG)>,
    #[doc = " offset: 0x38 (56)"]
    pub OpenRoutine: ::std::option::Option<unsafe extern "C" fn(arg1: _LARGE_INTEGER) -> UCHAR>,
    pub WriteRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _LARGE_INTEGER, arg2: *mut _MDL) -> LONG,
    >,
    #[doc = " offset: 0x48 (72)"]
    pub FinishRoutine: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " offset: 0x50 (80)"]
    pub AdapterObject: *mut _ADAPTER_OBJECT,
    #[doc = " offset: 0x58 (88)"]
    pub MappedRegisterBase: *mut VOID,
    #[doc = " offset: 0x60 (96)"]
    pub PortConfiguration: *mut VOID,
    #[doc = " offset: 0x68 (104)"]
    pub CrashDump: UCHAR,
    #[doc = " offset: 0x6c (108)"]
    pub MaximumTransferSize: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub CommonBufferSize: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub TargetAddress: *mut VOID,
    pub WritePendingRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LONG,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _MDL,
            arg4: *mut VOID,
        ) -> LONG,
    >,
    #[doc = " offset: 0x88 (136)"]
    pub PartitionStyle: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub DiskInfo: _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1 {
    #[doc = " offset: 0x8c (140)"]
    pub Mbr: _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8c (140)"]
    pub Gpt: _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub CheckSum: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub DiskId: _GUID,
}
impl Default for _DUMP_INITIALIZATION_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DUMP_INITIALIZATION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x110 (272) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUMP_STACK_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Init: _DUMP_INITIALIZATION_CONTEXT,
    #[doc = " offset: 0xa0 (160)"]
    pub PartitionOffset: _LARGE_INTEGER,
    #[doc = " offset: 0xa8 (168)"]
    pub DumpPointers: *mut VOID,
    #[doc = " offset: 0xb0 (176)"]
    pub PointersLength: ULONG,
    #[doc = " offset: 0xb8 (184)"]
    pub ModulePrefix: *mut USHORT,
    #[doc = " offset: 0xc0 (192)"]
    pub DriverList: _LIST_ENTRY,
    #[doc = " offset: 0xd0 (208)"]
    pub InitMsg: _STRING,
    #[doc = " offset: 0xe0 (224)"]
    pub ProgMsg: _STRING,
    #[doc = " offset: 0xf0 (240)"]
    pub DoneMsg: _STRING,
    #[doc = " offset: 0x100 (256)"]
    pub FileObject: *mut VOID,
    #[doc = " offset: 0x108 (264)"]
    pub UsageType: _DEVICE_USAGE_NOTIFICATION_TYPE,
}
impl Default for _DUMP_STACK_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct LIST_ENTRY32 {
    #[doc = " offset: 0x0 (0)"]
    pub Flink: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Blink: ULONG,
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_USERDATA_HEADER {
    pub __bindgen_anon_1: _HEAP_USERDATA_HEADER__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub SizeIndex: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Signature: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_USERDATA_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub SFreeListEntry: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x0 (0)"]
    pub SubSegment: *mut _HEAP_SUBSEGMENT,
}
impl Default for _HEAP_USERDATA_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_USERDATA_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x408 (1032) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CALL_PERFORMANCE_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub SpinLock: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub HashTable: [_LIST_ENTRY; 64usize],
}
impl Default for _CALL_PERFORMANCE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KIDTENTRY64 {
    pub __bindgen_anon_1: _KIDTENTRY64__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_2: _KIDTENTRY64__bindgen_ty_2,
    pub __bindgen_anon_3: _KIDTENTRY64__bindgen_ty_3,
    #[doc = " offset: 0x0 (0)"]
    pub Alignment: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KIDTENTRY64__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub OffsetLow: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Selector: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KIDTENTRY64__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x6 (6)"]
    pub OffsetMiddle: USHORT,
}
impl _KIDTENTRY64__bindgen_ty_2 {
    #[inline]
    pub fn Present(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Present: USHORT) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Present: u16 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KIDTENTRY64__bindgen_ty_3 {
    #[doc = " offset: 0x8 (8)"]
    pub OffsetHigh: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Reserved1: ULONG,
}
impl Default for _KIDTENTRY64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _KIDTENTRY64 {
    #[inline]
    pub fn IstIndex(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_IstIndex(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IstIndex: USHORT,
        Reserved0: USHORT,
        Type: USHORT,
        Dpl: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let IstIndex: u16 = unsafe { ::std::mem::transmute(IstIndex) };
            IstIndex as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Reserved0: u16 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u16 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u16 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KGDTENTRY64 {
    pub __bindgen_anon_1: _KGDTENTRY64__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub Bytes: _KGDTENTRY64__bindgen_ty_2,
    pub __bindgen_anon_2: _KGDTENTRY64__bindgen_ty_3,
    pub __bindgen_anon_3: _KGDTENTRY64__bindgen_ty_4,
    #[doc = " offset: 0x0 (0)"]
    pub Alignment: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KGDTENTRY64__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub LimitLow: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub BaseLow: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KGDTENTRY64__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub BaseMiddle: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Flags1: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Flags2: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub BaseHigh: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KGDTENTRY64__bindgen_ty_3 {
    #[doc = " offset: 0x4 (4)"]
    pub Bits: _KGDTENTRY64__bindgen_ty_3__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub BaseUpper: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KGDTENTRY64__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KGDTENTRY64__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn BaseMiddle(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMiddle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Present(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHigh(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHigh(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn System(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_System(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LongMode(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LongMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultBig(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DefaultBig(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHigh(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHigh(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMiddle: ULONG,
        Type: ULONG,
        Dpl: ULONG,
        Present: ULONG,
        LimitHigh: ULONG,
        System: ULONG,
        LongMode: ULONG,
        DefaultBig: ULONG,
        Granularity: ULONG,
        BaseHigh: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMiddle: u32 = unsafe { ::std::mem::transmute(BaseMiddle) };
            BaseMiddle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Present: u32 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHigh: u32 = unsafe { ::std::mem::transmute(LimitHigh) };
            LimitHigh as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let System: u32 = unsafe { ::std::mem::transmute(System) };
            System as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let LongMode: u32 = unsafe { ::std::mem::transmute(LongMode) };
            LongMode as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let DefaultBig: u32 = unsafe { ::std::mem::transmute(DefaultBig) };
            DefaultBig as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHigh: u32 = unsafe { ::std::mem::transmute(BaseHigh) };
            BaseHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KGDTENTRY64__bindgen_ty_4 {
    #[doc = " offset: 0xc (12)"]
    pub MustBeZero: ULONG,
}
impl Default for _KGDTENTRY64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8168 (33128) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_DEADLOCK_GLOBALS {
    #[doc = " offset: 0x0 (0)"]
    pub TimeAcquire: LONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub TimeRelease: LONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub ResourceDatabase: *mut _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub ResourceDatabaseCount: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub ResourceAddressRange: [_VI_DEADLOCK_ADDRESS_RANGE; 1023usize],
    #[doc = " offset: 0x4010 (16400)"]
    pub ThreadDatabase: *mut _LIST_ENTRY,
    #[doc = " offset: 0x4018 (16408)"]
    pub ThreadDatabaseCount: ULONGLONG,
    #[doc = " offset: 0x4020 (16416)"]
    pub ThreadAddressRange: [_VI_DEADLOCK_ADDRESS_RANGE; 1023usize],
    #[doc = " offset: 0x8010 (32784)"]
    pub AllocationFailures: ULONG,
    #[doc = " offset: 0x8014 (32788)"]
    pub NodesTrimmedBasedOnAge: ULONG,
    #[doc = " offset: 0x8018 (32792)"]
    pub NodesTrimmedBasedOnCount: ULONG,
    #[doc = " offset: 0x801c (32796)"]
    pub NodesSearched: ULONG,
    #[doc = " offset: 0x8020 (32800)"]
    pub MaxNodesSearched: ULONG,
    #[doc = " offset: 0x8024 (32804)"]
    pub SequenceNumber: ULONG,
    #[doc = " offset: 0x8028 (32808)"]
    pub RecursionDepthLimit: ULONG,
    #[doc = " offset: 0x802c (32812)"]
    pub SearchedNodesLimit: ULONG,
    #[doc = " offset: 0x8030 (32816)"]
    pub DepthLimitHits: ULONG,
    #[doc = " offset: 0x8034 (32820)"]
    pub SearchLimitHits: ULONG,
    #[doc = " offset: 0x8038 (32824)"]
    pub ABC_ACB_Skipped: ULONG,
    #[doc = " offset: 0x803c (32828)"]
    pub OutOfOrderReleases: ULONG,
    #[doc = " offset: 0x8040 (32832)"]
    pub NodesReleasedOutOfOrder: ULONG,
    #[doc = " offset: 0x8044 (32836)"]
    pub TotalReleases: ULONG,
    #[doc = " offset: 0x8048 (32840)"]
    pub RootNodesDeleted: ULONG,
    #[doc = " offset: 0x804c (32844)"]
    pub ForgetHistoryCounter: ULONG,
    #[doc = " offset: 0x8050 (32848)"]
    pub Instigator: *mut VOID,
    #[doc = " offset: 0x8058 (32856)"]
    pub NumberOfParticipants: ULONG,
    #[doc = " offset: 0x8060 (32864)"]
    pub Participant: [*mut _VI_DEADLOCK_NODE; 32usize],
    #[doc = " offset: 0x8160 (33120)"]
    pub ChildrenCountWatermark: LONG,
}
impl Default for _VI_DEADLOCK_GLOBALS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x90 (144) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MM_DRIVER_VERIFIER_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub Level: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub RaiseIrqls: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub AcquireSpinLocks: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SynchronizeExecutions: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub AllocationsAttempted: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub AllocationsSucceeded: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub AllocationsSucceededSpecialPool: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub AllocationsWithNoTag: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub TrimRequests: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub Trims: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub AllocationsFailed: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub AllocationsFailedDeliberately: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub Loads: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub Unloads: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub UnTrackedPool: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub UserTrims: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub CurrentPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub CurrentNonPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub PeakPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub PeakNonPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub PagedBytes: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub NonPagedBytes: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub PeakPagedBytes: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub PeakNonPagedBytes: ULONGLONG,
    #[doc = " offset: 0x70 (112)"]
    pub BurstAllocationsFailedDeliberately: ULONG,
    #[doc = " offset: 0x74 (116)"]
    pub SessionTrims: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub OptionChanges: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub VerifyMode: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub PreviousBucketName: _UNICODE_STRING,
}
impl Default for _MM_DRIVER_VERIFIER_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xff8 (4088) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TEB32 {
    #[doc = " offset: 0x0 (0)"]
    pub NtTib: _NT_TIB32,
    #[doc = " offset: 0x1c (28)"]
    pub EnvironmentPointer: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub ClientId: _CLIENT_ID32,
    #[doc = " offset: 0x28 (40)"]
    pub ActiveRpcHandle: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub ThreadLocalStoragePointer: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub ProcessEnvironmentBlock: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub LastErrorValue: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub CountOfOwnedCriticalSections: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub CsrClientThread: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub Win32ThreadInfo: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub User32Reserved: [ULONG; 26usize],
    #[doc = " offset: 0xac (172)"]
    pub UserReserved: [ULONG; 5usize],
    #[doc = " offset: 0xc0 (192)"]
    pub WOW32Reserved: ULONG,
    #[doc = " offset: 0xc4 (196)"]
    pub CurrentLocale: ULONG,
    #[doc = " offset: 0xc8 (200)"]
    pub FpSoftwareStatusRegister: ULONG,
    #[doc = " offset: 0xcc (204)"]
    pub SystemReserved1: [ULONG; 54usize],
    #[doc = " offset: 0x1a4 (420)"]
    pub ExceptionCode: LONG,
    #[doc = " offset: 0x1a8 (424)"]
    pub ActivationContextStackPointer: ULONG,
    #[doc = " offset: 0x1ac (428)"]
    pub SpareBytes1: [UCHAR; 36usize],
    #[doc = " offset: 0x1d0 (464)"]
    pub TxFsContext: ULONG,
    #[doc = " offset: 0x1d4 (468)"]
    pub GdiTebBatch: _GDI_TEB_BATCH32,
    #[doc = " offset: 0x6b4 (1716)"]
    pub RealClientId: _CLIENT_ID32,
    #[doc = " offset: 0x6bc (1724)"]
    pub GdiCachedProcessHandle: ULONG,
    #[doc = " offset: 0x6c0 (1728)"]
    pub GdiClientPID: ULONG,
    #[doc = " offset: 0x6c4 (1732)"]
    pub GdiClientTID: ULONG,
    #[doc = " offset: 0x6c8 (1736)"]
    pub GdiThreadLocalInfo: ULONG,
    #[doc = " offset: 0x6cc (1740)"]
    pub Win32ClientInfo: [ULONG; 62usize],
    #[doc = " offset: 0x7c4 (1988)"]
    pub glDispatchTable: [ULONG; 233usize],
    #[doc = " offset: 0xb68 (2920)"]
    pub glReserved1: [ULONG; 29usize],
    #[doc = " offset: 0xbdc (3036)"]
    pub glReserved2: ULONG,
    #[doc = " offset: 0xbe0 (3040)"]
    pub glSectionInfo: ULONG,
    #[doc = " offset: 0xbe4 (3044)"]
    pub glSection: ULONG,
    #[doc = " offset: 0xbe8 (3048)"]
    pub glTable: ULONG,
    #[doc = " offset: 0xbec (3052)"]
    pub glCurrentRC: ULONG,
    #[doc = " offset: 0xbf0 (3056)"]
    pub glContext: ULONG,
    #[doc = " offset: 0xbf4 (3060)"]
    pub LastStatusValue: ULONG,
    #[doc = " offset: 0xbf8 (3064)"]
    pub StaticUnicodeString: _STRING32,
    #[doc = " offset: 0xc00 (3072)"]
    pub StaticUnicodeBuffer: [WCHAR; 261usize],
    #[doc = " offset: 0xe0c (3596)"]
    pub DeallocationStack: ULONG,
    #[doc = " offset: 0xe10 (3600)"]
    pub TlsSlots: [ULONG; 64usize],
    #[doc = " offset: 0xf10 (3856)"]
    pub TlsLinks: LIST_ENTRY32,
    #[doc = " offset: 0xf18 (3864)"]
    pub Vdm: ULONG,
    #[doc = " offset: 0xf1c (3868)"]
    pub ReservedForNtRpc: ULONG,
    #[doc = " offset: 0xf20 (3872)"]
    pub DbgSsReserved: [ULONG; 2usize],
    #[doc = " offset: 0xf28 (3880)"]
    pub HardErrorMode: ULONG,
    #[doc = " offset: 0xf2c (3884)"]
    pub Instrumentation: [ULONG; 9usize],
    #[doc = " offset: 0xf50 (3920)"]
    pub ActivityId: _GUID,
    #[doc = " offset: 0xf60 (3936)"]
    pub SubProcessTag: ULONG,
    #[doc = " offset: 0xf64 (3940)"]
    pub EtwLocalData: ULONG,
    #[doc = " offset: 0xf68 (3944)"]
    pub EtwTraceData: ULONG,
    #[doc = " offset: 0xf6c (3948)"]
    pub WinSockData: ULONG,
    #[doc = " offset: 0xf70 (3952)"]
    pub GdiBatchCount: ULONG,
    #[doc = " offset: 0xf74 (3956)"]
    pub SpareBool0: UCHAR,
    #[doc = " offset: 0xf75 (3957)"]
    pub SpareBool1: UCHAR,
    #[doc = " offset: 0xf76 (3958)"]
    pub SpareBool2: UCHAR,
    #[doc = " offset: 0xf77 (3959)"]
    pub IdealProcessor: UCHAR,
    #[doc = " offset: 0xf78 (3960)"]
    pub GuaranteedStackBytes: ULONG,
    #[doc = " offset: 0xf7c (3964)"]
    pub ReservedForPerf: ULONG,
    #[doc = " offset: 0xf80 (3968)"]
    pub ReservedForOle: ULONG,
    #[doc = " offset: 0xf84 (3972)"]
    pub WaitingOnLoaderLock: ULONG,
    #[doc = " offset: 0xf88 (3976)"]
    pub SavedPriorityState: ULONG,
    #[doc = " offset: 0xf8c (3980)"]
    pub SoftPatchPtr1: ULONG,
    #[doc = " offset: 0xf90 (3984)"]
    pub ThreadPoolData: ULONG,
    #[doc = " offset: 0xf94 (3988)"]
    pub TlsExpansionSlots: ULONG,
    #[doc = " offset: 0xf98 (3992)"]
    pub ImpersonationLocale: ULONG,
    #[doc = " offset: 0xf9c (3996)"]
    pub IsImpersonating: ULONG,
    #[doc = " offset: 0xfa0 (4000)"]
    pub NlsCache: ULONG,
    #[doc = " offset: 0xfa4 (4004)"]
    pub pShimData: ULONG,
    #[doc = " offset: 0xfa8 (4008)"]
    pub HeapVirtualAffinity: ULONG,
    #[doc = " offset: 0xfac (4012)"]
    pub CurrentTransactionHandle: ULONG,
    #[doc = " offset: 0xfb0 (4016)"]
    pub ActiveFrame: ULONG,
    #[doc = " offset: 0xfb4 (4020)"]
    pub FlsData: ULONG,
    #[doc = " offset: 0xfb8 (4024)"]
    pub PreferredLanguages: ULONG,
    #[doc = " offset: 0xfbc (4028)"]
    pub UserPrefLanguages: ULONG,
    #[doc = " offset: 0xfc0 (4032)"]
    pub MergedPrefLanguages: ULONG,
    #[doc = " offset: 0xfc4 (4036)"]
    pub MuiImpersonation: ULONG,
    pub __bindgen_anon_1: _TEB32__bindgen_ty_1,
    pub __bindgen_anon_2: _TEB32__bindgen_ty_2,
    #[doc = " offset: 0xfcc (4044)"]
    pub TxnScopeEnterCallback: ULONG,
    #[doc = " offset: 0xfd0 (4048)"]
    pub TxnScopeExitCallback: ULONG,
    #[doc = " offset: 0xfd4 (4052)"]
    pub TxnScopeContext: ULONG,
    #[doc = " offset: 0xfd8 (4056)"]
    pub LockCount: ULONG,
    #[doc = " offset: 0xfdc (4060)"]
    pub ProcessRundown: ULONG,
    #[doc = " offset: 0xfe0 (4064)"]
    pub LastSwitchTime: ULONGLONG,
    #[doc = " offset: 0xfe8 (4072)"]
    pub TotalSwitchOutTime: ULONGLONG,
    #[doc = " offset: 0xff0 (4080)"]
    pub WaitReasonBitMap: _LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_1 {
    #[doc = " offset: 0xfc8 (4040)"]
    pub CrossTebFlags: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _TEB32__bindgen_ty_1 {
    #[inline]
    pub fn SpareCrossTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let SpareCrossTebBits: u16 = unsafe { ::std::mem::transmute(SpareCrossTebBits) };
            SpareCrossTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_2 {
    #[doc = " offset: 0xfca (4042)"]
    pub SameTebFlags: USHORT,
    pub __bindgen_anon_1: _TEB32__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TEB32__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB32__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn DbgSafeThunkCall(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSafeThunkCall(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgInDebugPrint(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgInDebugPrint(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgHasFiberData(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgHasFiberData(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSkipThreadAttach(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSkipThreadAttach(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgWerInShipAssertCode(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgWerInShipAssertCode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRanProcessInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgRanProcessInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgClonedThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgClonedThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSuppressDebugMsg(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSuppressDebugMsg(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlDisableUserStackWalk(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlDisableUserStackWalk(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlExceptionAttached(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareSameTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgSafeThunkCall: USHORT,
        DbgInDebugPrint: USHORT,
        DbgHasFiberData: USHORT,
        DbgSkipThreadAttach: USHORT,
        DbgWerInShipAssertCode: USHORT,
        DbgRanProcessInit: USHORT,
        DbgClonedThread: USHORT,
        DbgSuppressDebugMsg: USHORT,
        RtlDisableUserStackWalk: USHORT,
        RtlExceptionAttached: USHORT,
        SpareSameTebBits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgSafeThunkCall: u16 = unsafe { ::std::mem::transmute(DbgSafeThunkCall) };
            DbgSafeThunkCall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgInDebugPrint: u16 = unsafe { ::std::mem::transmute(DbgInDebugPrint) };
            DbgInDebugPrint as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgHasFiberData: u16 = unsafe { ::std::mem::transmute(DbgHasFiberData) };
            DbgHasFiberData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgSkipThreadAttach: u16 = unsafe { ::std::mem::transmute(DbgSkipThreadAttach) };
            DbgSkipThreadAttach as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgWerInShipAssertCode: u16 =
                unsafe { ::std::mem::transmute(DbgWerInShipAssertCode) };
            DbgWerInShipAssertCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgRanProcessInit: u16 = unsafe { ::std::mem::transmute(DbgRanProcessInit) };
            DbgRanProcessInit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgClonedThread: u16 = unsafe { ::std::mem::transmute(DbgClonedThread) };
            DbgClonedThread as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DbgSuppressDebugMsg: u16 = unsafe { ::std::mem::transmute(DbgSuppressDebugMsg) };
            DbgSuppressDebugMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RtlDisableUserStackWalk: u16 =
                unsafe { ::std::mem::transmute(RtlDisableUserStackWalk) };
            RtlDisableUserStackWalk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RtlExceptionAttached: u16 = unsafe { ::std::mem::transmute(RtlExceptionAttached) };
            RtlExceptionAttached as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let SpareSameTebBits: u16 = unsafe { ::std::mem::transmute(SpareSameTebBits) };
            SpareSameTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TEB32__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TEB32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPFNLIST {
    #[doc = " offset: 0x0 (0)"]
    pub Total: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub ListName: _MMLISTS,
    #[doc = " offset: 0x10 (16)"]
    pub Flink: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Blink: ULONGLONG,
}
impl Default for _MMPFNLIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PTE_TRACKER {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Mdl: *mut _MDL,
    #[doc = " offset: 0x18 (24)"]
    pub Count: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub SystemVa: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub StartVa: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub Offset: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub Length: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub Page: ULONGLONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x48 (72)"]
    pub CallingAddress: *mut VOID,
    #[doc = " offset: 0x50 (80)"]
    pub CallersCaller: *mut VOID,
}
impl Default for _PTE_TRACKER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PTE_TRACKER {
    #[inline]
    pub fn IoMapping(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoMapping(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Matched(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Matched(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheAttribute(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CacheAttribute(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoMapping: ULONG,
        Matched: ULONG,
        CacheAttribute: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoMapping: u32 = unsafe { ::std::mem::transmute(IoMapping) };
            IoMapping as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Matched: u32 = unsafe { ::std::mem::transmute(Matched) };
            Matched as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let CacheAttribute: u32 = unsafe { ::std::mem::transmute(CacheAttribute) };
            CacheAttribute as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Spare: u32 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTLP_RANGE_LIST_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub End: ULONGLONG,
    pub __bindgen_anon_1: _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1,
    #[doc = " offset: 0x20 (32)"]
    pub Attributes: UCHAR,
    #[doc = " offset: 0x21 (33)"]
    pub PublicFlags: UCHAR,
    #[doc = " offset: 0x22 (34)"]
    pub PrivateFlags: USHORT,
    #[doc = " offset: 0x28 (40)"]
    pub ListEntry: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub Allocated: _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub Merged: _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub UserData: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Owner: *mut VOID,
}
impl Default for _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
}
impl Default for _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTLP_RANGE_LIST_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTLP_RANGE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMVIEW {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: ULONGLONG,
    pub __bindgen_anon_1: _MMVIEW__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVIEW__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x8 (8)"]
    pub ControlArea: *mut _CONTROL_AREA,
}
impl Default for _MMVIEW__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMVIEW__bindgen_ty_1 {
    #[inline]
    pub fn Writable(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Writable(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Writable: ULONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Writable: u64 = unsafe { ::std::mem::transmute(Writable) };
            Writable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMVIEW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMSESSION {
    #[doc = " offset: 0x0 (0)"]
    pub SystemSpaceViewLock: _KGUARDED_MUTEX,
    #[doc = " offset: 0x38 (56)"]
    pub SystemSpaceViewLockPointer: *mut _KGUARDED_MUTEX,
    #[doc = " offset: 0x40 (64)"]
    pub SystemSpaceViewTable: *mut _MMVIEW,
    #[doc = " offset: 0x48 (72)"]
    pub SystemSpaceHashSize: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub SystemSpaceHashEntries: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub SystemSpaceHashKey: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub BitmapFailures: ULONG,
}
impl Default for _MMSESSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x80 (128) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VF_POOL_TRACE {
    #[doc = " offset: 0x0 (0)"]
    pub Address: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Size: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Thread: *mut _ETHREAD,
    #[doc = " offset: 0x18 (24)"]
    pub StackTrace: [*mut VOID; 13usize],
}
impl Default for _VF_POOL_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PHYSICAL_MEMORY_RUN {
    #[doc = " offset: 0x0 (0)"]
    pub BasePage: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub PageCount: ULONGLONG,
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PHYSICAL_MEMORY_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub NumberOfRuns: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub NumberOfPages: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Run: [_PHYSICAL_MEMORY_RUN; 1usize],
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_MEMORY_RANGE {
    #[doc = " offset: 0x0 (0)"]
    pub StartPage: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub EndPage: ULONGLONG,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_MEMORY_RANGE_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _PO_MEMORY_RANGE_TABLE,
    #[doc = " offset: 0x8 (8)"]
    pub NextTable: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub EntryCount: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Range: [_PO_MEMORY_RANGE; 1usize],
}
impl Default for _PO_MEMORY_RANGE_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_HIBER_PERF {
    #[doc = " offset: 0x0 (0)"]
    pub IoTicks: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub InitTicks: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub CopyTicks: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub StartCount: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub ElapsedTime: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub IoTime: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub CopyTime: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub InitTime: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub PagesWritten: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub PagesProcessed: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub BytesCopied: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub DumpCount: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub FileRuns: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub ResumeAppStartTime: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub ResumeAppEndTime: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub HiberFileResumeTime: ULONGLONG,
}
#[doc = " 0x2b8 (696) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POP_DEVICE_SYS_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub IrpMinor: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub SystemState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x8 (8)"]
    pub SpinLock: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Thread: *mut _KTHREAD,
    #[doc = " offset: 0x18 (24)"]
    pub AbortEvent: *mut _KEVENT,
    #[doc = " offset: 0x20 (32)"]
    pub ReadySemaphore: *mut _KSEMAPHORE,
    #[doc = " offset: 0x28 (40)"]
    pub FinishedSemaphore: *mut _KSEMAPHORE,
    #[doc = " offset: 0x30 (48)"]
    pub GetNewDeviceList: UCHAR,
    #[doc = " offset: 0x38 (56)"]
    pub Order: _PO_DEVICE_NOTIFY_ORDER,
    #[doc = " offset: 0x288 (648)"]
    pub NotifyGdiLevelForPowerOn: LONG,
    #[doc = " offset: 0x28c (652)"]
    pub NotifyGdiLevelForResumeUI: LONG,
    #[doc = " offset: 0x290 (656)"]
    pub Pending: _LIST_ENTRY,
    #[doc = " offset: 0x2a0 (672)"]
    pub Status: LONG,
    #[doc = " offset: 0x2a8 (680)"]
    pub FailedDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x2b0 (688)"]
    pub Waking: UCHAR,
    #[doc = " offset: 0x2b1 (689)"]
    pub Cancelled: UCHAR,
    #[doc = " offset: 0x2b2 (690)"]
    pub IgnoreErrors: UCHAR,
    #[doc = " offset: 0x2b3 (691)"]
    pub IgnoreNotImplemented: UCHAR,
    #[doc = " offset: 0x2b4 (692)"]
    pub TimeRefreshLockAcquired: UCHAR,
}
impl Default for _POP_DEVICE_SYS_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POP_SHUTDOWN_BUG_CHECK {
    #[doc = " offset: 0x0 (0)"]
    pub ThreadHandle: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub ThreadId: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ProcessId: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Code: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub Parameter1: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub Parameter2: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub Parameter3: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub Parameter4: ULONGLONG,
}
impl Default for _POP_SHUTDOWN_BUG_CHECK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY_EXTRA {
    pub __bindgen_anon_1: _HEAP_ENTRY_EXTRA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY_EXTRA__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_ENTRY_EXTRA__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _HEAP_ENTRY_EXTRA__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_ENTRY_EXTRA__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub AllocatorBackTraceIndex: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub TagIndex: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Settable: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_ENTRY_EXTRA__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub ZeroInit: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub ZeroInit1: ULONGLONG,
}
impl Default for _HEAP_ENTRY_EXTRA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY_EXTRA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_DEBUGGING_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub InterceptorFunction: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub InterceptorValue: USHORT,
    #[doc = " offset: 0xc (12)"]
    pub ExtendedOptions: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub StackTraceDepth: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub MinTotalBlockSize: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub MaxTotalBlockSize: ULONGLONG,
    pub HeapLeakEnumerationRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LONG,
            arg2: *mut VOID,
            arg3: *mut VOID,
            arg4: ULONGLONG,
            arg5: ULONG,
            arg6: *mut VOID,
        ) -> LONG,
    >,
}
impl Default for _HEAP_DEBUGGING_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_CONFLICT_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub OwningObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x8 (8)"]
    pub Start: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub End: ULONGLONG,
}
impl Default for _ARBITER_CONFLICT_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_RANGE {
    #[doc = " offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub End: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub UserData: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Owner: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub Attributes: UCHAR,
    #[doc = " offset: 0x21 (33)"]
    pub Flags: UCHAR,
}
impl Default for _RTL_RANGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_ORDERING {
    #[doc = " offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub End: ULONGLONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_ORDERING_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Count: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Maximum: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Orderings: *mut _ARBITER_ORDERING,
}
impl Default for _ARBITER_ORDERING_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _STRING64 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MaximumLength: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Buffer: ULONGLONG,
}
#[doc = " 0x4e8 (1256) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _GDI_TEB_BATCH64 {
    #[doc = " offset: 0x0 (0)"]
    pub Offset: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub HDC: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CLIENT_ID64 {
    #[doc = " offset: 0x0 (0)"]
    pub UniqueProcess: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub UniqueThread: ULONGLONG,
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB64 {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionList: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub StackBase: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub StackLimit: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub SubSystemTib: ULONGLONG,
    pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub ArbitraryUserPointer: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub Self_: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB64__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub FiberData: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub Version: ULONG,
}
impl Default for _NT_TIB64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NT_TIB64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _THERMAL_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub ThermalStamp: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ThermalConstant1: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ThermalConstant2: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Processors: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub SamplingPeriod: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub CurrentTemperature: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub PassiveTripPoint: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub CriticalTripPoint: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub ActiveTripPointCount: UCHAR,
    #[doc = " offset: 0x2c (44)"]
    pub ActiveTripPoint: [ULONG; 10usize],
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MEMORY_ALLOCATION_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub MemoryType: _TYPE_OF_MEMORY,
    #[doc = " offset: 0x18 (24)"]
    pub BasePage: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub PageCount: ULONGLONG,
}
impl Default for _MEMORY_ALLOCATION_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POOL_TRACKER_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub Key: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub NonPagedAllocs: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub NonPagedFrees: LONG,
    #[doc = " offset: 0x10 (16)"]
    pub NonPagedBytes: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub PagedAllocs: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub PagedFrees: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub PagedBytes: ULONGLONG,
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_STOP_ON_VALUES {
    #[doc = " offset: 0x0 (0)"]
    pub AllocAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub AllocTag: _HEAP_STOP_ON_TAG,
    #[doc = " offset: 0x10 (16)"]
    pub ReAllocAddress: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub ReAllocTag: _HEAP_STOP_ON_TAG,
    #[doc = " offset: 0x20 (32)"]
    pub FreeAddress: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub FreeTag: _HEAP_STOP_ON_TAG,
}
impl Default for _HEAP_STOP_ON_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1048 (4168) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POOL_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub PoolType: _POOL_TYPE,
    #[doc = " offset: 0x4 (4)"]
    pub PoolIndex: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub RunningAllocs: LONG,
    #[doc = " offset: 0xc (12)"]
    pub RunningDeAllocs: LONG,
    #[doc = " offset: 0x10 (16)"]
    pub TotalPages: LONG,
    #[doc = " offset: 0x14 (20)"]
    pub TotalBigPages: LONG,
    #[doc = " offset: 0x18 (24)"]
    pub Threshold: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub LockAddress: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub PendingFrees: *mut *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub ThreadsProcessingDeferrals: LONG,
    #[doc = " offset: 0x34 (52)"]
    pub PendingFreeDepth: LONG,
    #[doc = " offset: 0x38 (56)"]
    pub TotalBytes: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub Spare0: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub ListHeads: [_LIST_ENTRY; 256usize],
}
impl Default for _POOL_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_UCR_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub SegmentEntry: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub Address: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub Size: ULONGLONG,
}
impl Default for _HEAP_UCR_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _THERMAL_INFORMATION_EX {
    #[doc = " offset: 0x0 (0)"]
    pub ThermalStamp: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ThermalConstant1: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ThermalConstant2: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Processors: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub SamplingPeriod: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub CurrentTemperature: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub PassiveTripPoint: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub CriticalTripPoint: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub ActiveTripPointCount: UCHAR,
    #[doc = " offset: 0x2c (44)"]
    pub ActiveTripPoint: [ULONG; 10usize],
    #[doc = " offset: 0x54 (84)"]
    pub S4TransitionTripPoint: ULONG,
}
#[doc = " 0x78 (120) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_CANCEL_GLOBALS {
    #[doc = " offset: 0x0 (0)"]
    pub CancelLock: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub IssueLock: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Counters: [LONG; 25usize],
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POOL_TRACKER_BIG_PAGES {
    #[doc = " offset: 0x0 (0)"]
    pub Va: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Key: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub PoolType: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub NumberOfBytes: ULONGLONG,
}
impl Default for _POOL_TRACKER_BIG_PAGES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYSPTES_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub ListHead: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Count: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub NumberOfEntries: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub NumberOfEntriesPeak: ULONGLONG,
}
impl Default for _SYSPTES_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_POOL_ENTRY_INUSE {
    #[doc = " offset: 0x0 (0)"]
    pub VirtualAddress: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub CallingAddress: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub NumberOfBytes: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Tag: ULONGLONG,
}
impl Default for _VI_POOL_ENTRY_INUSE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_POOL_PAGE_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub NextPage: *mut _SLIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub VerifierEntry: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Signature: ULONGLONG,
}
impl Default for _VI_POOL_PAGE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VI_POOL_ENTRY {
    pub __bindgen_anon_1: _VI_POOL_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VI_POOL_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub PageHeader: _VI_POOL_PAGE_HEADER,
    #[doc = " offset: 0x0 (0)"]
    pub InUse: _VI_POOL_ENTRY_INUSE,
    #[doc = " offset: 0x0 (0)"]
    pub NextFree: *mut _SLIST_ENTRY,
}
impl Default for _VI_POOL_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VI_POOL_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MI_VERIFIER_POOL_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub VerifierPoolEntry: *mut _VI_POOL_ENTRY,
}
impl Default for _MI_VERIFIER_POOL_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x110 (272) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SID_AND_ATTRIBUTES_HASH {
    #[doc = " offset: 0x0 (0)"]
    pub SidCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub SidAttr: *mut _SID_AND_ATTRIBUTES,
    #[doc = " offset: 0x10 (16)"]
    pub Hash: [ULONGLONG; 32usize],
}
impl Default for _SID_AND_ATTRIBUTES_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SEP_TOKEN_PRIVILEGES {
    #[doc = " offset: 0x0 (0)"]
    pub Present: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Enabled: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub EnabledByDefault: ULONGLONG,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _REMOTE_PORT_VIEW {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ViewSize: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub ViewBase: *mut VOID,
}
impl Default for _REMOTE_PORT_VIEW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SRWLOCK {
    pub __bindgen_anon_1: _RTL_SRWLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_SRWLOCK__bindgen_ty_1 {
    pub __bindgen_anon_1: _RTL_SRWLOCK__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub Ptr: *mut VOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_SRWLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _RTL_SRWLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Locked(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Locked(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waiting(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Waiting(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waking(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Waking(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MultipleShared(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MultipleShared(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Shared(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Locked: ULONGLONG,
        Waiting: ULONGLONG,
        Waking: ULONGLONG,
        MultipleShared: ULONGLONG,
        Shared: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Locked: u64 = unsafe { ::std::mem::transmute(Locked) };
            Locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Waiting: u64 = unsafe { ::std::mem::transmute(Waiting) };
            Waiting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Waking: u64 = unsafe { ::std::mem::transmute(Waking) };
            Waking as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MultipleShared: u64 = unsafe { ::std::mem::transmute(MultipleShared) };
            MultipleShared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let Shared: u64 = unsafe { ::std::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _RTL_SRWLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _RTL_SRWLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x300 (768) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub StartMagic: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub TotalSize: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ListOffset: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ListSize: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub BitmapOffset: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub BitmapSize: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub DataOffset: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub DataSize: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub AttributeFlags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub AttributeSize: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub State: _ALPC_COMPLETION_LIST_STATE,
    #[doc = " offset: 0x88 (136)"]
    pub LastMessageId: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub LastCallbackId: ULONG,
    #[doc = " offset: 0x100 (256)"]
    pub PostCount: ULONG,
    #[doc = " offset: 0x180 (384)"]
    pub ReturnCount: ULONG,
    #[doc = " offset: 0x200 (512)"]
    pub LogSequenceNumber: ULONG,
    #[doc = " offset: 0x280 (640)"]
    pub UserLock: _RTL_SRWLOCK,
    #[doc = " offset: 0x288 (648)"]
    pub EndMagic: ULONGLONG,
}
impl Default for _ALPC_COMPLETION_LIST_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_MESSAGE_ZONE {
    #[doc = " offset: 0x0 (0)"]
    pub Mdl: *mut _MDL,
    #[doc = " offset: 0x8 (8)"]
    pub UserVa: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub UserLimit: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub SystemVa: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub SystemLimit: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub Size: ULONGLONG,
}
impl Default for _ALPC_MESSAGE_ZONE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub Packet: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Lookaside: *mut _ALPC_COMPLETION_PACKET_LOOKASIDE,
}
impl Default for _ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug)]
pub struct _ALPC_COMPLETION_PACKET_LOOKASIDE {
    #[doc = " offset: 0x0 (0)"]
    pub Lock: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Size: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ActiveCount: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub PendingNullCount: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub PendingCheckCompletionListCount: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub PendingDelete: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub FreeListHead: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub CompletionPort: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub CompletionKey: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub Entry: __IncompleteArrayField<_ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY>,
}
impl Default for _ALPC_COMPLETION_PACKET_LOOKASIDE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_PORT_ATTRIBUTES {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub SecurityQos: _SECURITY_QUALITY_OF_SERVICE,
    #[doc = " offset: 0x10 (16)"]
    pub MaxMessageLength: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub MemoryBandwidth: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub MaxPoolUsage: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub MaxSectionSize: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub MaxViewSize: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub MaxTotalSectionSize: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub DupObjectTypes: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub Reserved: ULONG,
}
impl Default for _ALPC_PORT_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _BLOB_TYPE {
    #[doc = " offset: 0x0 (0)"]
    pub ResourceId: _BLOB_ID,
    #[doc = " offset: 0x4 (4)"]
    pub PoolTag: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub CreatedObjects: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub DeletedObjects: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DeleteProcedure: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = " offset: 0x20 (32)"]
    pub DestroyProcedure: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID) -> LONG>,
    #[doc = " offset: 0x28 (40)"]
    pub UsualSize: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub LookasideIndex: ULONG,
}
impl Default for _BLOB_TYPE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PORT_MESSAGE {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _PORT_MESSAGE__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub u2: _PORT_MESSAGE__bindgen_ty_2,
    pub __bindgen_anon_1: _PORT_MESSAGE__bindgen_ty_3,
    #[doc = " offset: 0x18 (24)"]
    pub MessageId: ULONG,
    pub __bindgen_anon_2: _PORT_MESSAGE__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub s1: _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub DataLength: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub TotalLength: SHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_2 {
    #[doc = " offset: 0x4 (4)"]
    pub s2: _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub ZeroInit: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub DataInfoOffset: SHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_3 {
    #[doc = " offset: 0x8 (8)"]
    pub ClientId: _CLIENT_ID,
    #[doc = " offset: 0x8 (8)"]
    pub DoNotUseThisField: f64,
}
impl Default for _PORT_MESSAGE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_4 {
    #[doc = " offset: 0x20 (32)"]
    pub ClientViewSize: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub CallbackId: ULONG,
}
impl Default for _PORT_MESSAGE__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PORT_MESSAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPCP_MESSAGE {
    pub __bindgen_anon_1: _LPCP_MESSAGE__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub SenderPort: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub RepliedToThread: *mut _ETHREAD,
    #[doc = " offset: 0x20 (32)"]
    pub PortContext: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub Request: _PORT_MESSAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LPCP_MESSAGE__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    pub __bindgen_anon_1: _LPCP_MESSAGE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LPCP_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub FreeEntry: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved0: ULONG,
}
impl Default for _LPCP_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LPCP_MESSAGE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LPCP_MESSAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TRACE_ENABLE_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub IsEnabled: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Level: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub Reserved1: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub LoggerId: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub EnableProperty: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Reserved2: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub MatchAnyKeyword: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub MatchAllKeyword: ULONGLONG,
}
#[doc = " 0x170 (368) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_GUID_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub GuidList: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub RefCount: LONG,
    #[doc = " offset: 0x14 (20)"]
    pub Guid: _GUID,
    #[doc = " offset: 0x28 (40)"]
    pub RegListHead: _LIST_ENTRY,
    #[doc = " offset: 0x38 (56)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub LastEnable: _ETW_LAST_ENABLE_INFO,
    #[doc = " offset: 0x50 (80)"]
    pub ProviderEnableInfo: _TRACE_ENABLE_INFO,
    #[doc = " offset: 0x70 (112)"]
    pub EnableInfo: [_TRACE_ENABLE_INFO; 8usize],
}
impl Default for _ETW_GUID_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_TRACE_HEADER {
    pub __bindgen_anon_1: _PERFINFO_TRACE_HEADER__bindgen_ty_1,
    pub __bindgen_anon_2: _PERFINFO_TRACE_HEADER__bindgen_ty_2,
    pub __bindgen_anon_3: _PERFINFO_TRACE_HEADER__bindgen_ty_3,
    #[doc = " offset: 0x10 (16)"]
    pub Data: [UCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_TRACE_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Marker: ULONG,
    pub __bindgen_anon_1: _PERFINFO_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PERFINFO_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Version: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub HeaderType: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub Flags: UCHAR,
}
impl Default for _PERFINFO_TRACE_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_TRACE_HEADER__bindgen_ty_2 {
    #[doc = " offset: 0x4 (4)"]
    pub Header: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Packet: _WMI_TRACE_PACKET,
}
impl Default for _PERFINFO_TRACE_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_TRACE_HEADER__bindgen_ty_3 {
    #[doc = " offset: 0x8 (8)"]
    pub TS: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub SystemTime: _LARGE_INTEGER,
}
impl Default for _PERFINFO_TRACE_HEADER__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PERFINFO_TRACE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WNODE_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub BufferSize: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ProviderId: ULONG,
    pub __bindgen_anon_1: _WNODE_HEADER__bindgen_ty_1,
    pub __bindgen_anon_2: _WNODE_HEADER__bindgen_ty_2,
    #[doc = " offset: 0x18 (24)"]
    pub Guid: _GUID,
    #[doc = " offset: 0x28 (40)"]
    pub ClientContext: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WNODE_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub HistoricalContext: ULONGLONG,
    pub __bindgen_anon_1: _WNODE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WNODE_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub Version: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Linkage: ULONG,
}
impl Default for _WNODE_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WNODE_HEADER__bindgen_ty_2 {
    #[doc = " offset: 0x10 (16)"]
    pub CountLost: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub KernelHandle: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub TimeStamp: _LARGE_INTEGER,
}
impl Default for _WNODE_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WNODE_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_BUFFER_HEADER {
    pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_1,
    #[doc = " offset: 0x30 (48)"]
    pub Offset: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub BufferFlag: USHORT,
    #[doc = " offset: 0x36 (54)"]
    pub BufferType: USHORT,
    pub __bindgen_anon_2: _WMI_BUFFER_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Wnode: _WNODE_HEADER,
    pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub BufferSize: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub SavedOffset: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CurrentOffset: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ReferenceCount: LONG,
    pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub SequenceNumber: LONGLONG,
    pub __bindgen_anon_2: _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x28 (40)"]
    pub ClientContext: _ETW_BUFFER_CONTEXT,
    pub __bindgen_anon_3: _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub TimeStamp: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub StartPerfClock: _LARGE_INTEGER,
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x20 (32)"]
    pub Padding0: [ULONG; 2usize],
    #[doc = " offset: 0x20 (32)"]
    pub SlistEntry: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub NextBuffer: *mut _WMI_BUFFER_HEADER,
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x2c (44)"]
    pub State: _ETW_BUFFER_STATE,
    #[doc = " offset: 0x2c (44)"]
    pub Flags: ULONG,
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_2 {
    #[doc = " offset: 0x38 (56)"]
    pub Padding1: [ULONG; 4usize],
    #[doc = " offset: 0x38 (56)"]
    pub StartTime: _LARGE_INTEGER,
    #[doc = " offset: 0x38 (56)"]
    pub Entry: _LIST_ENTRY,
    pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " offset: 0x38 (56)"]
    pub Padding2: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub GlobalEntry: _SINGLE_LIST_ENTRY,
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_2 {
    #[doc = " offset: 0x38 (56)"]
    pub Pointer0: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub Pointer1: *mut VOID,
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_BUFFER_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_SUBSEGMENT {
    #[doc = " offset: 0x0 (0)"]
    pub LocalInfo: *mut _HEAP_LOCAL_SEGMENT_INFO,
    #[doc = " offset: 0x8 (8)"]
    pub UserBlocks: *mut _HEAP_USERDATA_HEADER,
    #[doc = " offset: 0x10 (16)"]
    pub AggregateExchg: _INTERLOCK_SEQ,
    pub __bindgen_anon_1: _HEAP_SUBSEGMENT__bindgen_ty_1,
    #[doc = " offset: 0x20 (32)"]
    pub SFreeListEntry: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub Lock: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_SUBSEGMENT__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_SUBSEGMENT__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub Alignment: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_SUBSEGMENT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x18 (24)"]
    pub BlockSize: USHORT,
    #[doc = " offset: 0x1a (26)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x1c (28)"]
    pub BlockCount: USHORT,
    #[doc = " offset: 0x1e (30)"]
    pub SizeIndex: UCHAR,
    #[doc = " offset: 0x1f (31)"]
    pub AffinityIndex: UCHAR,
}
impl Default for _HEAP_SUBSEGMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_SUBSEGMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY {
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub FreeList: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub PreviousBlockPrivateData: *mut VOID,
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub CompactHeader: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub Size: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub Flags: UCHAR,
    #[doc = " offset: 0xb (11)"]
    pub SmallTagIndex: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub PreviousSize: USHORT,
    pub __bindgen_anon_1:
        _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0xf (15)"]
    pub UnusedBytes: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0xe (14)"]
    pub SegmentOffset: UCHAR,
    #[doc = " offset: 0xe (14)"]
    pub LFHFlags: UCHAR,
}
impl Default
    for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub Reserved: *mut VOID,
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0xc (12)"]
    pub UnusedBytesLength: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub EntryOffset: UCHAR,
    #[doc = " offset: 0xf (15)"]
    pub ExtendedBlockSignature: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub InterceptorValue: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub FunctionIndex: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub ContextValue: USHORT,
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub ReservedForAlignment: *mut VOID,
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub AgregateCode: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub Code1: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Code2: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub Code3: UCHAR,
    #[doc = " offset: 0xf (15)"]
    pub Code4: UCHAR,
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_FREE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_PSEUDO_TAG_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Allocs: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Frees: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Size: ULONGLONG,
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_TAG_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Allocs: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Frees: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Size: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub TagIndex: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub CreatorBackTraceIndex: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub TagName: [WCHAR; 24usize],
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_TUNING_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub CommittThresholdShift: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MaxPreCommittThreshold: ULONGLONG,
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_COUNTERS {
    #[doc = " offset: 0x0 (0)"]
    pub TotalMemoryReserved: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub TotalMemoryCommitted: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub TotalMemoryLargeUCR: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub TotalSizeInVirtualBlocks: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub TotalSegments: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub TotalUCRs: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub CommittOps: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub DeCommitOps: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub LockAcquires: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub LockCollisions: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub CommitRate: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub DecommittRate: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub CommitFailures: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub InBlockCommitFailures: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub CompactHeapCalls: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub CompactedUCRs: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub InBlockDeccommits: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub InBlockDeccomitSize: ULONGLONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY {
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub PreviousBlockPrivateData: *mut VOID,
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub CompactHeader: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub Size: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub Flags: UCHAR,
    #[doc = " offset: 0xb (11)"]
    pub SmallTagIndex: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub PreviousSize: USHORT,
    pub __bindgen_anon_1:
        _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0xf (15)"]
    pub UnusedBytes: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0xe (14)"]
    pub SegmentOffset: UCHAR,
    #[doc = " offset: 0xe (14)"]
    pub LFHFlags: UCHAR,
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub Reserved: *mut VOID,
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0xc (12)"]
    pub UnusedBytesLength: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub EntryOffset: UCHAR,
    #[doc = " offset: 0xf (15)"]
    pub ExtendedBlockSignature: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub InterceptorValue: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub FunctionIndex: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub ContextValue: USHORT,
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub ReservedForAlignment: *mut VOID,
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub AgregateCode: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub Code1: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Code2: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub Code3: UCHAR,
    #[doc = " offset: 0xf (15)"]
    pub Code4: UCHAR,
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub ExtraStuff: _HEAP_ENTRY_EXTRA,
    #[doc = " offset: 0x20 (32)"]
    pub CommitSize: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub ReserveSize: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub BusyBlock: _HEAP_ENTRY,
}
impl Default for _HEAP_VIRTUAL_ALLOC_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_SEGMENT {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: _HEAP_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub SegmentSignature: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub SegmentFlags: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub SegmentListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub Heap: *mut _HEAP,
    #[doc = " offset: 0x30 (48)"]
    pub BaseAddress: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub NumberOfPages: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub FirstEntry: *mut _HEAP_ENTRY,
    #[doc = " offset: 0x48 (72)"]
    pub LastValidEntry: *mut _HEAP_ENTRY,
    #[doc = " offset: 0x50 (80)"]
    pub NumberOfUnCommittedPages: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub NumberOfUnCommittedRanges: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub SegmentAllocatorBackTraceIndex: USHORT,
    #[doc = " offset: 0x5a (90)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x60 (96)"]
    pub UCRSegmentList: _LIST_ENTRY,
}
impl Default for _HEAP_SEGMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PRIVATE_CACHE_MAP {
    pub __bindgen_anon_1: _PRIVATE_CACHE_MAP__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub ReadAheadMask: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub FileOffset1: _LARGE_INTEGER,
    #[doc = " offset: 0x18 (24)"]
    pub BeyondLastByte1: _LARGE_INTEGER,
    #[doc = " offset: 0x20 (32)"]
    pub FileOffset2: _LARGE_INTEGER,
    #[doc = " offset: 0x28 (40)"]
    pub BeyondLastByte2: _LARGE_INTEGER,
    #[doc = " offset: 0x30 (48)"]
    pub ReadAheadOffset: [_LARGE_INTEGER; 2usize],
    #[doc = " offset: 0x40 (64)"]
    pub ReadAheadLength: [ULONG; 2usize],
    #[doc = " offset: 0x48 (72)"]
    pub ReadAheadSpinLock: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub PrivateLinks: _LIST_ENTRY,
    #[doc = " offset: 0x60 (96)"]
    pub ReadAheadWorkItem: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PRIVATE_CACHE_MAP__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = " offset: 0x0 (0)"]
    pub Flags: _PRIVATE_CACHE_MAP_FLAGS,
    #[doc = " offset: 0x0 (0)"]
    pub UlongFlags: ULONG,
}
impl Default for _PRIVATE_CACHE_MAP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PRIVATE_CACHE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IA64_DBGKD_CONTROL_SET {
    #[doc = " offset: 0x0 (0)"]
    pub Continue: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub CurrentSymbolStart: ULONGLONG,
    #[doc = " offset: 0xc (12)"]
    pub CurrentSymbolEnd: ULONGLONG,
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _AMD64_DBGKD_CONTROL_SET {
    #[doc = " offset: 0x0 (0)"]
    pub TraceFlag: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Dr7: ULONGLONG,
    #[doc = " offset: 0xc (12)"]
    pub CurrentSymbolStart: ULONGLONG,
    #[doc = " offset: 0x14 (20)"]
    pub CurrentSymbolEnd: ULONGLONG,
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_ANY_CONTROL_SET {
    pub __bindgen_anon_1: _DBGKD_ANY_CONTROL_SET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_ANY_CONTROL_SET__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub X86ControlSet: _X86_DBGKD_CONTROL_SET,
    #[doc = " offset: 0x0 (0)"]
    pub AlphaControlSet: ULONG,
    #[doc = " offset: 0x0 (0)"]
    pub IA64ControlSet: _IA64_DBGKD_CONTROL_SET,
    #[doc = " offset: 0x0 (0)"]
    pub Amd64ControlSet: _AMD64_DBGKD_CONTROL_SET,
    #[doc = " offset: 0x0 (0)"]
    pub ArmControlSet: _ARM_DBGKD_CONTROL_SET,
}
impl Default for _DBGKD_ANY_CONTROL_SET__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_ANY_CONTROL_SET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_CONTINUE2 {
    #[doc = " offset: 0x0 (0)"]
    pub ContinueStatus: LONG,
    pub __bindgen_anon_1: _DBGKD_CONTINUE2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_CONTINUE2__bindgen_ty_1 {
    #[doc = " offset: 0x4 (4)"]
    pub ControlSet: _AMD64_DBGKD_CONTROL_SET,
    #[doc = " offset: 0x4 (4)"]
    pub AnyControlSet: _DBGKD_ANY_CONTROL_SET,
}
impl Default for _DBGKD_CONTINUE2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_CONTINUE2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_QUERY_MEMORY {
    #[doc = " offset: 0x0 (0)"]
    pub Address: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub AddressSpace: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Flags: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_FILL_MEMORY {
    #[doc = " offset: 0x0 (0)"]
    pub Address: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Length: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Flags: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub PatternLength: USHORT,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_SEARCH_MEMORY {
    pub __bindgen_anon_1: _DBGKD_SEARCH_MEMORY__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub SearchLength: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub PatternLength: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_SEARCH_MEMORY__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub SearchAddress: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub FoundAddress: ULONGLONG,
}
impl Default for _DBGKD_SEARCH_MEMORY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_SEARCH_MEMORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_GET_VERSION64 {
    #[doc = " offset: 0x0 (0)"]
    pub MajorVersion: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MinorVersion: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub ProtocolVersion: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub KdSecondaryVersion: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub MachineType: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub MaxPacketType: UCHAR,
    #[doc = " offset: 0xb (11)"]
    pub MaxStateChange: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub MaxManipulate: UCHAR,
    #[doc = " offset: 0xd (13)"]
    pub Simulation: UCHAR,
    #[doc = " offset: 0xe (14)"]
    pub Unused: [USHORT; 1usize],
    #[doc = " offset: 0x10 (16)"]
    pub KernBase: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub PsLoadedModuleList: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub DebuggerDataList: ULONGLONG,
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_GET_INTERNAL_BREAKPOINT64 {
    #[doc = " offset: 0x0 (0)"]
    pub BreakpointAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Calls: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub MaxCallsPerPeriod: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub MinInstructions: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub MaxInstructions: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub TotalInstructions: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_SET_INTERNAL_BREAKPOINT64 {
    #[doc = " offset: 0x0 (0)"]
    pub BreakpointAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Flags: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_SET_SPECIAL_CALL64 {
    #[doc = " offset: 0x0 (0)"]
    pub SpecialCall: ULONGLONG,
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_READ_WRITE_IO_EXTENDED64 {
    #[doc = " offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub InterfaceType: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub AddressSpace: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub IoAddress: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub DataValue: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_READ_WRITE_IO64 {
    #[doc = " offset: 0x0 (0)"]
    pub IoAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub DataSize: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub DataValue: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_WRITE_BREAKPOINT64 {
    #[doc = " offset: 0x0 (0)"]
    pub BreakPointAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub BreakPointHandle: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_WRITE_MEMORY64 {
    #[doc = " offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub TransferCount: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ActualBytesWritten: ULONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_READ_MEMORY64 {
    #[doc = " offset: 0x0 (0)"]
    pub TargetBaseAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub TransferCount: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ActualBytesRead: ULONG,
}
#[doc = " 0x34 (52) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_MANIPULATE_STATE32 {
    #[doc = " offset: 0x0 (0)"]
    pub ApiNumber: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ProcessorLevel: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Processor: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub ReturnStatus: LONG,
    #[doc = " offset: 0xc (12)"]
    pub u: _DBGKD_MANIPULATE_STATE32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_MANIPULATE_STATE32__bindgen_ty_1 {
    #[doc = " offset: 0xc (12)"]
    pub ReadMemory: _DBGKD_READ_MEMORY32,
    #[doc = " offset: 0xc (12)"]
    pub WriteMemory: _DBGKD_WRITE_MEMORY32,
    #[doc = " offset: 0xc (12)"]
    pub ReadMemory64: _DBGKD_READ_MEMORY64,
    #[doc = " offset: 0xc (12)"]
    pub WriteMemory64: _DBGKD_WRITE_MEMORY64,
    #[doc = " offset: 0xc (12)"]
    pub GetContext: _DBGKD_GET_CONTEXT,
    #[doc = " offset: 0xc (12)"]
    pub SetContext: _DBGKD_SET_CONTEXT,
    #[doc = " offset: 0xc (12)"]
    pub WriteBreakPoint: _DBGKD_WRITE_BREAKPOINT32,
    #[doc = " offset: 0xc (12)"]
    pub RestoreBreakPoint: _DBGKD_RESTORE_BREAKPOINT,
    #[doc = " offset: 0xc (12)"]
    pub Continue: _DBGKD_CONTINUE,
    #[doc = " offset: 0xc (12)"]
    pub Continue2: _DBGKD_CONTINUE2,
    #[doc = " offset: 0xc (12)"]
    pub ReadWriteIo: _DBGKD_READ_WRITE_IO32,
    #[doc = " offset: 0xc (12)"]
    pub ReadWriteIoExtended: _DBGKD_READ_WRITE_IO_EXTENDED32,
    #[doc = " offset: 0xc (12)"]
    pub QuerySpecialCalls: _DBGKD_QUERY_SPECIAL_CALLS,
    #[doc = " offset: 0xc (12)"]
    pub SetSpecialCall: _DBGKD_SET_SPECIAL_CALL32,
    #[doc = " offset: 0xc (12)"]
    pub SetInternalBreakpoint: _DBGKD_SET_INTERNAL_BREAKPOINT32,
    #[doc = " offset: 0xc (12)"]
    pub GetInternalBreakpoint: _DBGKD_GET_INTERNAL_BREAKPOINT32,
    #[doc = " offset: 0xc (12)"]
    pub GetVersion32: _DBGKD_GET_VERSION32,
    #[doc = " offset: 0xc (12)"]
    pub BreakPointEx: _DBGKD_BREAKPOINTEX,
    #[doc = " offset: 0xc (12)"]
    pub ReadWriteMsr: _DBGKD_READ_WRITE_MSR,
    #[doc = " offset: 0xc (12)"]
    pub SearchMemory: _DBGKD_SEARCH_MEMORY,
}
impl Default for _DBGKD_MANIPULATE_STATE32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_MANIPULATE_STATE32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DBGKD_MANIPULATE_STATE64 {
    #[doc = " offset: 0x0 (0)"]
    pub ApiNumber: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ProcessorLevel: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Processor: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub ReturnStatus: LONG,
    #[doc = " offset: 0x10 (16)"]
    pub u: _DBGKD_MANIPULATE_STATE64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DBGKD_MANIPULATE_STATE64__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub ReadMemory: _DBGKD_READ_MEMORY64,
    #[doc = " offset: 0x10 (16)"]
    pub WriteMemory: _DBGKD_WRITE_MEMORY64,
    #[doc = " offset: 0x10 (16)"]
    pub GetContext: _DBGKD_GET_CONTEXT,
    #[doc = " offset: 0x10 (16)"]
    pub SetContext: _DBGKD_SET_CONTEXT,
    #[doc = " offset: 0x10 (16)"]
    pub WriteBreakPoint: _DBGKD_WRITE_BREAKPOINT64,
    #[doc = " offset: 0x10 (16)"]
    pub RestoreBreakPoint: _DBGKD_RESTORE_BREAKPOINT,
    #[doc = " offset: 0x10 (16)"]
    pub Continue: _DBGKD_CONTINUE,
    #[doc = " offset: 0x10 (16)"]
    pub Continue2: _DBGKD_CONTINUE2,
    #[doc = " offset: 0x10 (16)"]
    pub ReadWriteIo: _DBGKD_READ_WRITE_IO64,
    #[doc = " offset: 0x10 (16)"]
    pub ReadWriteIoExtended: _DBGKD_READ_WRITE_IO_EXTENDED64,
    #[doc = " offset: 0x10 (16)"]
    pub QuerySpecialCalls: _DBGKD_QUERY_SPECIAL_CALLS,
    #[doc = " offset: 0x10 (16)"]
    pub SetSpecialCall: _DBGKD_SET_SPECIAL_CALL64,
    #[doc = " offset: 0x10 (16)"]
    pub SetInternalBreakpoint: _DBGKD_SET_INTERNAL_BREAKPOINT64,
    #[doc = " offset: 0x10 (16)"]
    pub GetInternalBreakpoint: _DBGKD_GET_INTERNAL_BREAKPOINT64,
    #[doc = " offset: 0x10 (16)"]
    pub GetVersion64: _DBGKD_GET_VERSION64,
    #[doc = " offset: 0x10 (16)"]
    pub BreakPointEx: _DBGKD_BREAKPOINTEX,
    #[doc = " offset: 0x10 (16)"]
    pub ReadWriteMsr: _DBGKD_READ_WRITE_MSR,
    #[doc = " offset: 0x10 (16)"]
    pub SearchMemory: _DBGKD_SEARCH_MEMORY,
    #[doc = " offset: 0x10 (16)"]
    pub GetSetBusData: _DBGKD_GET_SET_BUS_DATA,
    #[doc = " offset: 0x10 (16)"]
    pub FillMemory: _DBGKD_FILL_MEMORY,
    #[doc = " offset: 0x10 (16)"]
    pub QueryMemory: _DBGKD_QUERY_MEMORY,
    #[doc = " offset: 0x10 (16)"]
    pub SwitchPartition: _DBGKD_SWITCH_PARTITION,
}
impl Default for _DBGKD_MANIPULATE_STATE64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DBGKD_MANIPULATE_STATE64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKD_LOAD_SYMBOLS64 {
    #[doc = " offset: 0x0 (0)"]
    pub PathNameLength: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub BaseOfDll: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub ProcessId: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub CheckSum: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub SizeOfImage: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub UnloadSymbols: UCHAR,
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_DEVICE_COMPLETION_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub SpinLock: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub DispatchedCount: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub DispatchedList: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub CompletedSemaphore: _KSEMAPHORE,
    #[doc = " offset: 0x40 (64)"]
    pub CompletedList: _LIST_ENTRY,
}
impl Default for _PNP_DEVICE_COMPLETION_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4e8 (1256) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _GDI_TEB_BATCH {
    #[doc = " offset: 0x0 (0)"]
    pub Offset: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub HDC: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x98 (152) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EXCEPTION_RECORD64 {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionCode: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub ExceptionFlags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ExceptionRecord: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub ExceptionAddress: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub NumberParameters: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub __unusedAlignment: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub ExceptionInformation: [ULONGLONG; 15usize],
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DBGKM_EXCEPTION64 {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionRecord: _EXCEPTION_RECORD64,
    #[doc = " offset: 0x98 (152)"]
    pub FirstChance: ULONG,
}
#[doc = " 0x98 (152) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EXCEPTION_RECORD {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionCode: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub ExceptionFlags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    #[doc = " offset: 0x10 (16)"]
    pub ExceptionAddress: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub NumberParameters: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub ExceptionInformation: [ULONGLONG; 15usize],
}
impl Default for _EXCEPTION_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLS_LSN {
    #[doc = " offset: 0x0 (0)"]
    pub offset: _CLS_LSN__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub ullOffset: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CLS_LSN__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub idxRecord: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub cidContainer: ULONG,
}
impl Default for _CLS_LSN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHED_CHILD_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONG,
    pub __bindgen_anon_1: _CACHED_CHILD_LIST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CACHED_CHILD_LIST__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub ValueList: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub RealKcb: *mut _CM_KEY_CONTROL_BLOCK,
}
impl Default for _CACHED_CHILD_LIST__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CACHED_CHILD_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMVAD_FLAGS3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMVAD_FLAGS3 {
    #[inline]
    pub fn PreferredNode(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_PreferredNode(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Teb(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Teb(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SequentialAccess(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SequentialAccess(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LastSequentialTrim(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_LastSequentialTrim(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare2(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Spare2(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePageCreating(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LargePageCreating(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare3(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 31u8) as u64) }
    }
    #[inline]
    pub fn set_Spare3(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PreferredNode: ULONGLONG,
        Teb: ULONGLONG,
        Spare: ULONGLONG,
        SequentialAccess: ULONGLONG,
        LastSequentialTrim: ULONGLONG,
        Spare2: ULONGLONG,
        LargePageCreating: ULONGLONG,
        Spare3: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let PreferredNode: u64 = unsafe { ::std::mem::transmute(PreferredNode) };
            PreferredNode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Teb: u64 = unsafe { ::std::mem::transmute(Teb) };
            Teb as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Spare: u64 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SequentialAccess: u64 = unsafe { ::std::mem::transmute(SequentialAccess) };
            SequentialAccess as u64
        });
        __bindgen_bitfield_unit.set(9usize, 15u8, {
            let LastSequentialTrim: u64 = unsafe { ::std::mem::transmute(LastSequentialTrim) };
            LastSequentialTrim as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Spare2: u64 = unsafe { ::std::mem::transmute(Spare2) };
            Spare2 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let LargePageCreating: u64 = unsafe { ::std::mem::transmute(LargePageCreating) };
            LargePageCreating as u64
        });
        __bindgen_bitfield_unit.set(33usize, 31u8, {
            let Spare3: u64 = unsafe { ::std::mem::transmute(Spare3) };
            Spare3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMVAD_FLAGS {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMVAD_FLAGS {
    #[inline]
    pub fn CommitCharge(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 51u8) as u64) }
    }
    #[inline]
    pub fn set_CommitCharge(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 51u8, val as u64)
        }
    }
    #[inline]
    pub fn NoChange(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NoChange(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VadType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_VadType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn MemCommit(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MemCommit(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PrivateMemory(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PrivateMemory(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CommitCharge: ULONGLONG,
        NoChange: ULONGLONG,
        VadType: ULONGLONG,
        MemCommit: ULONGLONG,
        Protection: ULONGLONG,
        Spare: ULONGLONG,
        PrivateMemory: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 51u8, {
            let CommitCharge: u64 = unsafe { ::std::mem::transmute(CommitCharge) };
            CommitCharge as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let NoChange: u64 = unsafe { ::std::mem::transmute(NoChange) };
            NoChange as u64
        });
        __bindgen_bitfield_unit.set(52usize, 3u8, {
            let VadType: u64 = unsafe { ::std::mem::transmute(VadType) };
            VadType as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let MemCommit: u64 = unsafe { ::std::mem::transmute(MemCommit) };
            MemCommit as u64
        });
        __bindgen_bitfield_unit.set(56usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(61usize, 2u8, {
            let Spare: u64 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let PrivateMemory: u64 = unsafe { ::std::mem::transmute(PrivateMemory) };
            PrivateMemory as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub TransferAddress: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub ZeroBits: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub MaximumStackSize: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub CommittedStackSize: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub SubSystemType: ULONG,
    pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub GpValue: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub ImageCharacteristics: USHORT,
    #[doc = " offset: 0x2e (46)"]
    pub DllCharacteristics: USHORT,
    #[doc = " offset: 0x30 (48)"]
    pub Machine: USHORT,
    #[doc = " offset: 0x32 (50)"]
    pub ImageContainsCode: UCHAR,
    pub __bindgen_anon_2: _SECTION_IMAGE_INFORMATION__bindgen_ty_2,
    #[doc = " offset: 0x34 (52)"]
    pub LoaderFlags: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub ImageFileSize: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub CheckSum: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x24 (36)"]
    pub SubSystemVersion: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x24 (36)"]
    pub SubSystemMinorVersion: USHORT,
    #[doc = " offset: 0x26 (38)"]
    pub SubSystemMajorVersion: USHORT,
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
    #[doc = " offset: 0x33 (51)"]
    pub ImageFlags: UCHAR,
    pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ComPlusNativeReady(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ComPlusNativeReady(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ComPlusILOnly(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ComPlusILOnly(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageDynamicallyRelocated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageDynamicallyRelocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageMappedFlat(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageMappedFlat(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ComPlusNativeReady: UCHAR,
        ComPlusILOnly: UCHAR,
        ImageDynamicallyRelocated: UCHAR,
        ImageMappedFlat: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ComPlusNativeReady: u8 = unsafe { ::std::mem::transmute(ComPlusNativeReady) };
            ComPlusNativeReady as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ComPlusILOnly: u8 = unsafe { ::std::mem::transmute(ComPlusILOnly) };
            ComPlusILOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ImageDynamicallyRelocated: u8 =
                unsafe { ::std::mem::transmute(ImageDynamicallyRelocated) };
            ImageDynamicallyRelocated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ImageMappedFlat: u8 = unsafe { ::std::mem::transmute(ImageMappedFlat) };
            ImageMappedFlat as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SECTION_IMAGE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SECTION_IMAGE_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub ExportedImageInformation: _SECTION_IMAGE_INFORMATION,
    #[doc = " offset: 0x40 (64)"]
    pub InternalImageInformation: _MI_EXTRA_IMAGE_INFORMATION,
}
impl Default for _MI_SECTION_IMAGE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMEXTEND_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub CommittedSize: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub ReferenceCount: ULONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECURITY_CONTEXT {
    pub __bindgen_anon_1: _IMAGE_SECURITY_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECURITY_CONTEXT__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub PageHashes: *mut VOID,
    #[doc = " offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    pub __bindgen_anon_1: _IMAGE_SECURITY_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_SECURITY_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _IMAGE_SECURITY_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SecurityBeingCreated(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SecurityBeingCreated(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecurityMandatory(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SecurityMandatory(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageHashPointer(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_PageHashPointer(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SecurityBeingCreated: ULONGLONG,
        SecurityMandatory: ULONGLONG,
        Unused: ULONGLONG,
        PageHashPointer: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SecurityBeingCreated: u64 = unsafe { ::std::mem::transmute(SecurityBeingCreated) };
            SecurityBeingCreated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SecurityMandatory: u64 = unsafe { ::std::mem::transmute(SecurityMandatory) };
            SecurityMandatory as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let PageHashPointer: u64 = unsafe { ::std::mem::transmute(PageHashPointer) };
            PageHashPointer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _IMAGE_SECURITY_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IMAGE_SECURITY_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_IMAGE_SECURITY_REFERENCE {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityContext: _IMAGE_SECURITY_CONTEXT,
    #[doc = " offset: 0x8 (8)"]
    pub DynamicRelocations: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ReferenceCount: LONG,
}
impl Default for _MI_IMAGE_SECURITY_REFERENCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_SUBSECTION_AVL_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub BalancedRoot: _MMSUBSECTION_NODE,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x30 (48)"]
    pub NodeHint: *mut VOID,
}
impl Default for _MM_SUBSECTION_AVL_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MM_SUBSECTION_AVL_TABLE {
    #[inline]
    pub fn DepthOfTree(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_DepthOfTree(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NumberGenericTableElements(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_NumberGenericTableElements(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DepthOfTree: ULONGLONG,
        Unused: ULONGLONG,
        NumberGenericTableElements: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DepthOfTree: u64 = unsafe { ::std::mem::transmute(DepthOfTree) };
            DepthOfTree as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let NumberGenericTableElements: u64 =
                unsafe { ::std::mem::transmute(NumberGenericTableElements) };
            NumberGenericTableElements as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_LIST {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_LIST {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OneEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OneEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filler0(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_filler0(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filler1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u64) }
    }
    #[inline]
    pub fn set_filler1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        OneEntry: ULONGLONG,
        filler0: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Transition: ULONGLONG,
        filler1: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OneEntry: u64 = unsafe { ::std::mem::transmute(OneEntry) };
            OneEntry as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let filler0: u64 = unsafe { ::std::mem::transmute(filler0) };
            filler0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Transition: u64 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let filler1: u64 = unsafe { ::std::mem::transmute(filler1) };
            filler1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_SUBSECTION {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_SUBSECTION {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused0(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Unused0(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Unused1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn SubsectionAddress(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_SubsectionAddress(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Unused0: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Unused1: ULONGLONG,
        SubsectionAddress: LONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let Unused0: u64 = unsafe { ::std::mem::transmute(Unused0) };
            Unused0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Unused1: u64 = unsafe { ::std::mem::transmute(Unused1) };
            Unused1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let SubsectionAddress: u64 = unsafe { ::std::mem::transmute(SubsectionAddress) };
            SubsectionAddress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_TRANSITION {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_TRANSITION {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 36u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 36u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Write: ULONGLONG,
        Owner: ULONGLONG,
        WriteThrough: ULONGLONG,
        CacheDisable: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Transition: ULONGLONG,
        PageFrameNumber: ULONGLONG,
        Unused: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u64 = unsafe { ::std::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u64 = unsafe { ::std::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u64 = unsafe { ::std::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Transition: u64 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(12usize, 36u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_TIMESTAMP {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_TIMESTAMP {
    #[inline]
    pub fn MustBeZero(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MustBeZero(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileLow(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileLow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn GlobalTimeStamp(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_GlobalTimeStamp(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MustBeZero: ULONGLONG,
        PageFileLow: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Transition: ULONGLONG,
        Reserved: ULONGLONG,
        GlobalTimeStamp: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MustBeZero: u64 = unsafe { ::std::mem::transmute(MustBeZero) };
            MustBeZero as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let PageFileLow: u64 = unsafe { ::std::mem::transmute(PageFileLow) };
            PageFileLow as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Transition: u64 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let GlobalTimeStamp: u64 = unsafe { ::std::mem::transmute(GlobalTimeStamp) };
            GlobalTimeStamp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_SOFTWARE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_SOFTWARE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileLow(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileLow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Transition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Transition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UsedPageTableEntries(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_UsedPageTableEntries(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFileHigh(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_PageFileHigh(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        PageFileLow: ULONGLONG,
        Protection: ULONGLONG,
        Prototype: ULONGLONG,
        Transition: ULONGLONG,
        UsedPageTableEntries: ULONGLONG,
        Reserved: ULONGLONG,
        PageFileHigh: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let PageFileLow: u64 = unsafe { ::std::mem::transmute(PageFileLow) };
            PageFileLow as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Transition: u64 = unsafe { ::std::mem::transmute(Transition) };
            Transition as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let UsedPageTableEntries: u64 = unsafe { ::std::mem::transmute(UsedPageTableEntries) };
            UsedPageTableEntries as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let PageFileHigh: u64 = unsafe { ::std::mem::transmute(PageFileHigh) };
            PageFileHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_PROTOTYPE {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_PROTOTYPE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused0(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_Unused0(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Unused1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtoAddress(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_ProtoAddress(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Unused0: ULONGLONG,
        ReadOnly: ULONGLONG,
        Unused1: ULONGLONG,
        Prototype: ULONGLONG,
        Protection: ULONGLONG,
        ProtoAddress: LONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Unused0: u64 = unsafe { ::std::mem::transmute(Unused0) };
            Unused0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReadOnly: u64 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Unused1: u64 = unsafe { ::std::mem::transmute(Unused1) };
            Unused1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let ProtoAddress: u64 = unsafe { ::std::mem::transmute(ProtoAddress) };
            ProtoAddress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_HARDWARE_LARGEPAGE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_HARDWARE_LARGEPAGE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PAT(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PAT(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 27u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Dirty1: ULONGLONG,
        Owner: ULONGLONG,
        WriteThrough: ULONGLONG,
        CacheDisable: ULONGLONG,
        Accessed: ULONGLONG,
        Dirty: ULONGLONG,
        LargePage: ULONGLONG,
        Global: ULONGLONG,
        CopyOnWrite: ULONGLONG,
        Prototype: ULONGLONG,
        Write: ULONGLONG,
        PAT: ULONGLONG,
        reserved1: ULONGLONG,
        PageFrameNumber: ULONGLONG,
        reserved2: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Dirty1: u64 = unsafe { ::std::mem::transmute(Dirty1) };
            Dirty1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u64 = unsafe { ::std::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u64 = unsafe { ::std::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u64 = unsafe { ::std::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u64 = unsafe { ::std::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CopyOnWrite: u64 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PAT: u64 = unsafe { ::std::mem::transmute(PAT) };
            PAT as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 27u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let reserved2: u64 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_HARDWARE {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_HARDWARE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 36u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 36u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SoftwareWsIndex(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_SoftwareWsIndex(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn NoExecute(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NoExecute(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Dirty1: ULONGLONG,
        Owner: ULONGLONG,
        WriteThrough: ULONGLONG,
        CacheDisable: ULONGLONG,
        Accessed: ULONGLONG,
        Dirty: ULONGLONG,
        LargePage: ULONGLONG,
        Global: ULONGLONG,
        CopyOnWrite: ULONGLONG,
        Prototype: ULONGLONG,
        Write: ULONGLONG,
        PageFrameNumber: ULONGLONG,
        reserved1: ULONGLONG,
        SoftwareWsIndex: ULONGLONG,
        NoExecute: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Dirty1: u64 = unsafe { ::std::mem::transmute(Dirty1) };
            Dirty1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u64 = unsafe { ::std::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u64 = unsafe { ::std::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u64 = unsafe { ::std::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u64 = unsafe { ::std::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CopyOnWrite: u64 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(12usize, 36u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let SoftwareWsIndex: u64 = unsafe { ::std::mem::transmute(SoftwareWsIndex) };
            SoftwareWsIndex as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let NoExecute: u64 = unsafe { ::std::mem::transmute(NoExecute) };
            NoExecute as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VIRTUAL_EFI_RUNTIME_SERVICES {
    #[doc = " offset: 0x0 (0)"]
    pub GetTime: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub SetTime: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub GetWakeupTime: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub SetWakeupTime: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub SetVirtualAddressMap: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub ConvertPointer: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub GetVariable: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub GetNextVariableName: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub SetVariable: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub GetNextHighMonotonicCount: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub ResetSystem: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub UpdateCapsule: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub QueryCapsuleCapabilities: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub QueryVariableInfo: ULONGLONG,
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EFI_FIRMWARE_INFORMATION {
    #[doc = " offset: 0x0 (0)"]
    pub FirmwareVersion: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub VirtualEfiRuntimeServices: *mut _VIRTUAL_EFI_RUNTIME_SERVICES,
    #[doc = " offset: 0x10 (16)"]
    pub SetVirtualAddressMapStatus: LONG,
    #[doc = " offset: 0x14 (20)"]
    pub MissedMappingsCount: ULONG,
}
impl Default for _EFI_FIRMWARE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FIRMWARE_INFORMATION_LOADER_BLOCK {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x8 (8)"]
    pub u: _FIRMWARE_INFORMATION_LOADER_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FIRMWARE_INFORMATION_LOADER_BLOCK__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub EfiInformation: _EFI_FIRMWARE_INFORMATION,
    #[doc = " offset: 0x8 (8)"]
    pub PcatInformation: _PCAT_FIRMWARE_INFORMATION,
}
impl Default for _FIRMWARE_INFORMATION_LOADER_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _FIRMWARE_INFORMATION_LOADER_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _FIRMWARE_INFORMATION_LOADER_BLOCK {
    #[inline]
    pub fn FirmwareTypeEfi(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FirmwareTypeEfi(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FirmwareTypeEfi: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FirmwareTypeEfi: u32 = unsafe { ::std::mem::transmute(FirmwareTypeEfi) };
            FirmwareTypeEfi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LOADER_PERFORMANCE_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub StartTime: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub EndTime: ULONGLONG,
}
#[doc = " 0xc8 (200) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LOADER_PARAMETER_EXTENSION {
    #[doc = " offset: 0x0 (0)"]
    pub Size: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Profile: _PROFILE_PARAMETER_BLOCK,
    #[doc = " offset: 0x14 (20)"]
    pub MajorVersion: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub MinorVersion: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub EmInfFileImage: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub EmInfFileSize: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub TriageDumpBlock: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub LoaderPagesSpanned: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub HeadlessLoaderBlock: *mut _HEADLESS_LOADER_BLOCK,
    #[doc = " offset: 0x48 (72)"]
    pub SMBiosEPSHeader: *mut _SMBIOS_TABLE_HEADER,
    #[doc = " offset: 0x50 (80)"]
    pub DrvDBImage: *mut VOID,
    #[doc = " offset: 0x58 (88)"]
    pub DrvDBSize: ULONG,
    #[doc = " offset: 0x60 (96)"]
    pub NetworkLoaderBlock: *mut _NETWORK_LOADER_BLOCK,
    #[doc = " offset: 0x68 (104)"]
    pub FirmwareDescriptorListHead: _LIST_ENTRY,
    #[doc = " offset: 0x78 (120)"]
    pub AcpiTable: *mut VOID,
    #[doc = " offset: 0x80 (128)"]
    pub AcpiTableSize: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x88 (136)"]
    pub LoaderPerformanceData: *mut _LOADER_PERFORMANCE_DATA,
    #[doc = " offset: 0x90 (144)"]
    pub BootApplicationPersistentData: _LIST_ENTRY,
    #[doc = " offset: 0xa0 (160)"]
    pub WmdTestResult: *mut VOID,
    #[doc = " offset: 0xa8 (168)"]
    pub BootIdentifier: _GUID,
    #[doc = " offset: 0xb8 (184)"]
    pub ResumePages: ULONG,
    #[doc = " offset: 0xc0 (192)"]
    pub DumpHeader: *mut VOID,
}
impl Default for _LOADER_PARAMETER_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _LOADER_PARAMETER_EXTENSION {
    #[inline]
    pub fn BootViaWinload(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BootViaWinload(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BootViaWinload: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BootViaWinload: u32 = unsafe { ::std::mem::transmute(BootViaWinload) };
            BootViaWinload as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0xe8 (232) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOADER_PARAMETER_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub LoadOrderListHead: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub MemoryDescriptorListHead: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub BootDriverListHead: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub KernelStack: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub Prcb: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub Process: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub Thread: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub RegistryLength: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub RegistryBase: *mut VOID,
    #[doc = " offset: 0x60 (96)"]
    pub ConfigurationRoot: *mut _CONFIGURATION_COMPONENT_DATA,
    #[doc = " offset: 0x68 (104)"]
    pub ArcBootDeviceName: *mut CHAR,
    #[doc = " offset: 0x70 (112)"]
    pub ArcHalDeviceName: *mut CHAR,
    #[doc = " offset: 0x78 (120)"]
    pub NtBootPathName: *mut CHAR,
    #[doc = " offset: 0x80 (128)"]
    pub NtHalPathName: *mut CHAR,
    #[doc = " offset: 0x88 (136)"]
    pub LoadOptions: *mut CHAR,
    #[doc = " offset: 0x90 (144)"]
    pub NlsData: *mut _NLS_DATA_BLOCK,
    #[doc = " offset: 0x98 (152)"]
    pub ArcDiskInformation: *mut _ARC_DISK_INFORMATION,
    #[doc = " offset: 0xa0 (160)"]
    pub OemFontFile: *mut VOID,
    #[doc = " offset: 0xa8 (168)"]
    pub SetupLoaderBlock: *mut _SETUP_LOADER_BLOCK,
    #[doc = " offset: 0xb0 (176)"]
    pub Extension: *mut _LOADER_PARAMETER_EXTENSION,
    #[doc = " offset: 0xb8 (184)"]
    pub u: _LOADER_PARAMETER_BLOCK__bindgen_ty_1,
    #[doc = " offset: 0xc8 (200)"]
    pub FirmwareInformation: _FIRMWARE_INFORMATION_LOADER_BLOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LOADER_PARAMETER_BLOCK__bindgen_ty_1 {
    #[doc = " offset: 0xb8 (184)"]
    pub I386: _I386_LOADER_BLOCK,
    #[doc = " offset: 0xb8 (184)"]
    pub Alpha: _ALPHA_LOADER_BLOCK,
    #[doc = " offset: 0xb8 (184)"]
    pub Ia64: _IA64_LOADER_BLOCK,
}
impl Default for _LOADER_PARAMETER_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LOADER_PARAMETER_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct WHEA_PCIXDEVICE_REGISTER_PAIR {
    #[doc = " offset: 0x0 (0)"]
    pub Register: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Data: ULONGLONG,
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXDEVICE_ERROR_VALIDBITS {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: ULONGLONG,
}
impl Default for _WHEA_PCIXDEVICE_ERROR_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_PCIXDEVICE_ERROR_VALIDBITS {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdInfo(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IdInfo(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MemoryNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MemoryNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IoNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RegisterDataPairs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RegisterDataPairs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        IdInfo: ULONGLONG,
        MemoryNumber: ULONGLONG,
        IoNumber: ULONGLONG,
        RegisterDataPairs: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::std::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IdInfo: u64 = unsafe { ::std::mem::transmute(IdInfo) };
            IdInfo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MemoryNumber: u64 = unsafe { ::std::mem::transmute(MemoryNumber) };
            MemoryNumber as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IoNumber: u64 = unsafe { ::std::mem::transmute(IoNumber) };
            IoNumber as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RegisterDataPairs: u64 = unsafe { ::std::mem::transmute(RegisterDataPairs) };
            RegisterDataPairs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 59u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXBUS_COMMAND {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONGLONG: ULONGLONG,
}
impl Default for _WHEA_PCIXBUS_COMMAND {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_PCIXBUS_COMMAND {
    #[inline]
    pub fn Command(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Command(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn PCIXCommand(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PCIXCommand(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Command: ULONGLONG,
        PCIXCommand: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 56u8, {
            let Command: u64 = unsafe { ::std::mem::transmute(Command) };
            Command as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let PCIXCommand: u64 = unsafe { ::std::mem::transmute(PCIXCommand) };
            PCIXCommand as u64
        });
        __bindgen_bitfield_unit.set(57usize, 7u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXBUS_ERROR_VALIDBITS {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: ULONGLONG,
}
impl Default for _WHEA_PCIXBUS_ERROR_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_PCIXBUS_ERROR_VALIDBITS {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BusId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BusAddress(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BusData(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusData(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BusCommand(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusCommand(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompleterId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CompleterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 55u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 55u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        ErrorType: ULONGLONG,
        BusId: ULONGLONG,
        BusAddress: ULONGLONG,
        BusData: ULONGLONG,
        BusCommand: ULONGLONG,
        RequesterId: ULONGLONG,
        CompleterId: ULONGLONG,
        TargetId: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::std::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ErrorType: u64 = unsafe { ::std::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BusId: u64 = unsafe { ::std::mem::transmute(BusId) };
            BusId as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BusAddress: u64 = unsafe { ::std::mem::transmute(BusAddress) };
            BusAddress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BusData: u64 = unsafe { ::std::mem::transmute(BusData) };
            BusData as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BusCommand: u64 = unsafe { ::std::mem::transmute(BusCommand) };
            BusCommand as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RequesterId: u64 = unsafe { ::std::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CompleterId: u64 = unsafe { ::std::mem::transmute(CompleterId) };
            CompleterId as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TargetId: u64 = unsafe { ::std::mem::transmute(TargetId) };
            TargetId as u64
        });
        __bindgen_bitfield_unit.set(9usize, 55u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_ERROR_VALIDBITS {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: ULONGLONG,
}
impl Default for _WHEA_PCIEXPRESS_ERROR_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_PCIEXPRESS_ERROR_VALIDBITS {
    #[inline]
    pub fn PortType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PortType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Version(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CommandStatus(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CommandStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DeviceId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceSerialNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DeviceSerialNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BridgeControlStatus(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BridgeControlStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExpressCapability(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExpressCapability(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AerInfo(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AerInfo(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PortType: ULONGLONG,
        Version: ULONGLONG,
        CommandStatus: ULONGLONG,
        DeviceId: ULONGLONG,
        DeviceSerialNumber: ULONGLONG,
        BridgeControlStatus: ULONGLONG,
        ExpressCapability: ULONGLONG,
        AerInfo: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PortType: u64 = unsafe { ::std::mem::transmute(PortType) };
            PortType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Version: u64 = unsafe { ::std::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CommandStatus: u64 = unsafe { ::std::mem::transmute(CommandStatus) };
            CommandStatus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DeviceId: u64 = unsafe { ::std::mem::transmute(DeviceId) };
            DeviceId as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DeviceSerialNumber: u64 = unsafe { ::std::mem::transmute(DeviceSerialNumber) };
            DeviceSerialNumber as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BridgeControlStatus: u64 = unsafe { ::std::mem::transmute(BridgeControlStatus) };
            BridgeControlStatus as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ExpressCapability: u64 = unsafe { ::std::mem::transmute(ExpressCapability) };
            ExpressCapability as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AerInfo: u64 = unsafe { ::std::mem::transmute(AerInfo) };
            AerInfo as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_STATUS {
    #[doc = " offset: 0x0 (0)"]
    pub ErrorStatus: ULONGLONG,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for _WHEA_ERROR_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_ERROR_STATUS {
    #[inline]
    pub fn Reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Address(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Address(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Control(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Control(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Data(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Data(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Responder(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Responder(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Requester(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Requester(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FirstError(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FirstError(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 41u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 41u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONGLONG,
        ErrorType: ULONGLONG,
        Address: ULONGLONG,
        Control: ULONGLONG,
        Data: ULONGLONG,
        Responder: ULONGLONG,
        Requester: ULONGLONG,
        FirstError: ULONGLONG,
        Overflow: ULONGLONG,
        Reserved2: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ErrorType: u64 = unsafe { ::std::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Address: u64 = unsafe { ::std::mem::transmute(Address) };
            Address as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Control: u64 = unsafe { ::std::mem::transmute(Control) };
            Control as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Data: u64 = unsafe { ::std::mem::transmute(Data) };
            Data as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Responder: u64 = unsafe { ::std::mem::transmute(Responder) };
            Responder as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Requester: u64 = unsafe { ::std::mem::transmute(Requester) };
            Requester as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let FirstError: u64 = unsafe { ::std::mem::transmute(FirstError) };
            FirstError as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Overflow: u64 = unsafe { ::std::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(23usize, 41u8, {
            let Reserved2: u64 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIXDEVICE_ERROR {
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: _WHEA_PCIXDEVICE_ERROR_VALIDBITS,
    #[doc = " offset: 0x8 (8)"]
    pub ErrorStatus: _WHEA_ERROR_STATUS,
    #[doc = " offset: 0x10 (16)"]
    pub IdInfo: _WHEA_PCIXDEVICE_ID,
    #[doc = " offset: 0x20 (32)"]
    pub MemoryNumber: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub IoNumber: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub RegisterDataPairs: [WHEA_PCIXDEVICE_REGISTER_PAIR; 4usize],
}
impl Default for _WHEA_PCIXDEVICE_ERROR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_MEMORY_ERROR_VALIDBITS {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: ULONGLONG,
}
impl Default for _WHEA_MEMORY_ERROR_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_MEMORY_ERROR_VALIDBITS {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddressMask(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddressMask(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Node(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Node(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Card(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Card(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Module(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Module(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bank(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bank(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Device(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Device(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Row(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Row(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Column(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Column(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BitPosition(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BitPosition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 49u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 49u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        PhysicalAddress: ULONGLONG,
        PhysicalAddressMask: ULONGLONG,
        Node: ULONGLONG,
        Card: ULONGLONG,
        Module: ULONGLONG,
        Bank: ULONGLONG,
        Device: ULONGLONG,
        Row: ULONGLONG,
        Column: ULONGLONG,
        BitPosition: ULONGLONG,
        RequesterId: ULONGLONG,
        ResponderId: ULONGLONG,
        TargetId: ULONGLONG,
        ErrorType: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::std::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PhysicalAddressMask: u64 = unsafe { ::std::mem::transmute(PhysicalAddressMask) };
            PhysicalAddressMask as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Node: u64 = unsafe { ::std::mem::transmute(Node) };
            Node as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Card: u64 = unsafe { ::std::mem::transmute(Card) };
            Card as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Module: u64 = unsafe { ::std::mem::transmute(Module) };
            Module as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Bank: u64 = unsafe { ::std::mem::transmute(Bank) };
            Bank as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Device: u64 = unsafe { ::std::mem::transmute(Device) };
            Device as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Row: u64 = unsafe { ::std::mem::transmute(Row) };
            Row as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Column: u64 = unsafe { ::std::mem::transmute(Column) };
            Column as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BitPosition: u64 = unsafe { ::std::mem::transmute(BitPosition) };
            BitPosition as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let RequesterId: u64 = unsafe { ::std::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ResponderId: u64 = unsafe { ::std::mem::transmute(ResponderId) };
            ResponderId as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TargetId: u64 = unsafe { ::std::mem::transmute(TargetId) };
            TargetId as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ErrorType: u64 = unsafe { ::std::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(15usize, 49u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: ULONGLONG,
}
impl Default for _WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS {
    #[inline]
    pub fn ProcessorType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InstructionSet(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InstructionSet(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Flags(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPUVersion(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CPUVersion(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPUBrandString(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CPUBrandString(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessorId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetAddress(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InstructionPointer(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InstructionPointer(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 51u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 51u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProcessorType: ULONGLONG,
        InstructionSet: ULONGLONG,
        ErrorType: ULONGLONG,
        Operation: ULONGLONG,
        Flags: ULONGLONG,
        Level: ULONGLONG,
        CPUVersion: ULONGLONG,
        CPUBrandString: ULONGLONG,
        ProcessorId: ULONGLONG,
        TargetAddress: ULONGLONG,
        RequesterId: ULONGLONG,
        ResponderId: ULONGLONG,
        InstructionPointer: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProcessorType: u64 = unsafe { ::std::mem::transmute(ProcessorType) };
            ProcessorType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InstructionSet: u64 = unsafe { ::std::mem::transmute(InstructionSet) };
            InstructionSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ErrorType: u64 = unsafe { ::std::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Operation: u64 = unsafe { ::std::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Flags: u64 = unsafe { ::std::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Level: u64 = unsafe { ::std::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CPUVersion: u64 = unsafe { ::std::mem::transmute(CPUVersion) };
            CPUVersion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CPUBrandString: u64 = unsafe { ::std::mem::transmute(CPUBrandString) };
            CPUBrandString as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ProcessorId: u64 = unsafe { ::std::mem::transmute(ProcessorId) };
            ProcessorId as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TargetAddress: u64 = unsafe { ::std::mem::transmute(TargetAddress) };
            TargetAddress as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let RequesterId: u64 = unsafe { ::std::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ResponderId: u64 = unsafe { ::std::mem::transmute(ResponderId) };
            ResponderId as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let InstructionPointer: u64 = unsafe { ::std::mem::transmute(InstructionPointer) };
            InstructionPointer as u64
        });
        __bindgen_bitfield_unit.set(13usize, 51u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIXBUS_ERROR {
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: _WHEA_PCIXBUS_ERROR_VALIDBITS,
    #[doc = " offset: 0x8 (8)"]
    pub ErrorStatus: _WHEA_ERROR_STATUS,
    #[doc = " offset: 0x10 (16)"]
    pub ErrorType: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub BusId: _WHEA_PCIXBUS_ID,
    #[doc = " offset: 0x14 (20)"]
    pub Reserved: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub BusAddress: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub BusData: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub BusCommand: _WHEA_PCIXBUS_COMMAND,
    #[doc = " offset: 0x30 (48)"]
    pub RequesterId: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub CompleterId: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub TargetId: ULONGLONG,
}
impl Default for _WHEA_PCIXBUS_ERROR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xd0 (208) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIEXPRESS_ERROR {
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: _WHEA_PCIEXPRESS_ERROR_VALIDBITS,
    #[doc = " offset: 0x8 (8)"]
    pub PortType: WHEA_PCIEXPRESS_DEVICE_TYPE,
    #[doc = " offset: 0xc (12)"]
    pub Version: _WHEA_PCIEXPRESS_VERSION,
    #[doc = " offset: 0x10 (16)"]
    pub CommandStatus: _WHEA_PCIEXPRESS_COMMAND_STATUS,
    #[doc = " offset: 0x14 (20)"]
    pub Reserved: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DeviceId: _WHEA_PCIEXPRESS_DEVICE_ID,
    #[doc = " offset: 0x28 (40)"]
    pub DeviceSerialNumber: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub BridgeControlStatus: _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS,
    #[doc = " offset: 0x34 (52)"]
    pub ExpressCapability: [UCHAR; 60usize],
    #[doc = " offset: 0x70 (112)"]
    pub AerInfo: [UCHAR; 96usize],
}
impl Default for _WHEA_PCIEXPRESS_ERROR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x49 (73) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_MEMORY_ERROR {
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: _WHEA_MEMORY_ERROR_VALIDBITS,
    #[doc = " offset: 0x8 (8)"]
    pub ErrorStatus: _WHEA_ERROR_STATUS,
    #[doc = " offset: 0x10 (16)"]
    pub PhysicalAddress: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub PhysicalAddressMask: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub Node: USHORT,
    #[doc = " offset: 0x22 (34)"]
    pub Card: USHORT,
    #[doc = " offset: 0x24 (36)"]
    pub Module: USHORT,
    #[doc = " offset: 0x26 (38)"]
    pub Bank: USHORT,
    #[doc = " offset: 0x28 (40)"]
    pub Device: USHORT,
    #[doc = " offset: 0x2a (42)"]
    pub Row: USHORT,
    #[doc = " offset: 0x2c (44)"]
    pub Column: USHORT,
    #[doc = " offset: 0x2e (46)"]
    pub BitPosition: USHORT,
    #[doc = " offset: 0x30 (48)"]
    pub RequesterId: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub ResponderId: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub TargetId: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub ErrorType: UCHAR,
}
impl Default for _WHEA_MEMORY_ERROR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_PROCESSOR_ERROR {
    #[doc = " offset: 0x0 (0)"]
    pub ValidBits: _WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS,
    #[doc = " offset: 0x8 (8)"]
    pub ProcessorType: UCHAR,
    #[doc = " offset: 0x9 (9)"]
    pub InstructionSet: UCHAR,
    #[doc = " offset: 0xa (10)"]
    pub ErrorType: UCHAR,
    #[doc = " offset: 0xb (11)"]
    pub Operation: UCHAR,
    #[doc = " offset: 0xc (12)"]
    pub Flags: UCHAR,
    #[doc = " offset: 0xd (13)"]
    pub Level: UCHAR,
    #[doc = " offset: 0xe (14)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x10 (16)"]
    pub CPUVersion: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub CPUBrandString: [UCHAR; 128usize],
    #[doc = " offset: 0x98 (152)"]
    pub ProcessorId: ULONGLONG,
    #[doc = " offset: 0xa0 (160)"]
    pub TargetAddress: ULONGLONG,
    #[doc = " offset: 0xa8 (168)"]
    pub RequesterId: ULONGLONG,
    #[doc = " offset: 0xb0 (176)"]
    pub ResponderId: ULONGLONG,
    #[doc = " offset: 0xb8 (184)"]
    pub InstructionPointer: ULONGLONG,
}
impl Default for _WHEA_GENERIC_PROCESSOR_ERROR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x119 (281) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_PACKET {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: _WHEA_ERROR_PACKET_FLAGS,
    #[doc = " offset: 0x8 (8)"]
    pub Size: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub RawDataLength: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Reserved1: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Context: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub ErrorType: _WHEA_ERROR_TYPE,
    #[doc = " offset: 0x24 (36)"]
    pub ErrorSeverity: _WHEA_ERROR_SEVERITY,
    #[doc = " offset: 0x28 (40)"]
    pub ErrorSourceId: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub ErrorSourceType: _WHEA_ERROR_SOURCE_TYPE,
    #[doc = " offset: 0x30 (48)"]
    pub Reserved2: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub Version: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub Cpu: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub u: _WHEA_ERROR_PACKET__bindgen_ty_1,
    #[doc = " offset: 0x110 (272)"]
    pub RawDataFormat: _WHEA_RAW_DATA_FORMAT,
    #[doc = " offset: 0x114 (276)"]
    pub RawDataOffset: ULONG,
    #[doc = " offset: 0x118 (280)"]
    pub RawData: [UCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_PACKET__bindgen_ty_1 {
    #[doc = " offset: 0x40 (64)"]
    pub ProcessorError: _WHEA_GENERIC_PROCESSOR_ERROR,
    #[doc = " offset: 0x40 (64)"]
    pub MemoryError: _WHEA_MEMORY_ERROR,
    #[doc = " offset: 0x40 (64)"]
    pub NmiError: _WHEA_NMI_ERROR,
    #[doc = " offset: 0x40 (64)"]
    pub PciExpressError: _WHEA_PCIEXPRESS_ERROR,
    #[doc = " offset: 0x40 (64)"]
    pub PciXBusError: _WHEA_PCIXBUS_ERROR,
    #[doc = " offset: 0x40 (64)"]
    pub PciXDeviceError: _WHEA_PCIXDEVICE_ERROR,
}
impl Default for _WHEA_ERROR_PACKET__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WHEA_ERROR_PACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_PERSISTENCE_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsULONGLONG: ULONGLONG,
}
impl Default for _WHEA_PERSISTENCE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_PERSISTENCE_INFO {
    #[inline]
    pub fn Signature(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Signature(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Length(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Length(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn Identifier(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Identifier(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Attributes(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Attributes(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DoNotLog(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DoNotLog(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Signature: ULONGLONG,
        Length: ULONGLONG,
        Identifier: ULONGLONG,
        Attributes: ULONGLONG,
        DoNotLog: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Signature: u64 = unsafe { ::std::mem::transmute(Signature) };
            Signature as u64
        });
        __bindgen_bitfield_unit.set(16usize, 24u8, {
            let Length: u64 = unsafe { ::std::mem::transmute(Length) };
            Length as u64
        });
        __bindgen_bitfield_unit.set(40usize, 16u8, {
            let Identifier: u64 = unsafe { ::std::mem::transmute(Identifier) };
            Identifier as u64
        });
        __bindgen_bitfield_unit.set(56usize, 2u8, {
            let Attributes: u64 = unsafe { ::std::mem::transmute(Attributes) };
            Attributes as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let DoNotLog: u64 = unsafe { ::std::mem::transmute(DoNotLog) };
            DoNotLog as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_TIMESTAMP {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub AsLARGE_INTEGER: _LARGE_INTEGER,
}
impl Default for _WHEA_TIMESTAMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WHEA_TIMESTAMP {
    #[inline]
    pub fn Seconds(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Seconds(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Minutes(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Minutes(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Hours(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Hours(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Day(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Day(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Month(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Month(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Year(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Year(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Century(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Century(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Seconds: ULONGLONG,
        Minutes: ULONGLONG,
        Hours: ULONGLONG,
        Reserved: ULONGLONG,
        Day: ULONGLONG,
        Month: ULONGLONG,
        Year: ULONGLONG,
        Century: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Seconds: u64 = unsafe { ::std::mem::transmute(Seconds) };
            Seconds as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Minutes: u64 = unsafe { ::std::mem::transmute(Minutes) };
            Minutes as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Hours: u64 = unsafe { ::std::mem::transmute(Hours) };
            Hours as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let Day: u64 = unsafe { ::std::mem::transmute(Day) };
            Day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let Month: u64 = unsafe { ::std::mem::transmute(Month) };
            Month as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let Year: u64 = unsafe { ::std::mem::transmute(Year) };
            Year as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let Century: u64 = unsafe { ::std::mem::transmute(Century) };
            Century as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Revision: _WHEA_REVISION,
    #[doc = " offset: 0x6 (6)"]
    pub SignatureEnd: ULONG,
    #[doc = " offset: 0xa (10)"]
    pub SectionCount: USHORT,
    #[doc = " offset: 0xc (12)"]
    pub Severity: _WHEA_ERROR_SEVERITY,
    #[doc = " offset: 0x10 (16)"]
    pub ValidBits: _WHEA_ERROR_RECORD_HEADER_VALIDBITS,
    #[doc = " offset: 0x14 (20)"]
    pub Length: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Timestamp: _WHEA_TIMESTAMP,
    #[doc = " offset: 0x20 (32)"]
    pub PlatformId: _GUID,
    #[doc = " offset: 0x30 (48)"]
    pub PartitionId: _GUID,
    #[doc = " offset: 0x40 (64)"]
    pub CreatorId: _GUID,
    #[doc = " offset: 0x50 (80)"]
    pub NotifyType: _GUID,
    #[doc = " offset: 0x60 (96)"]
    pub RecordId: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub Flags: _WHEA_ERROR_RECORD_HEADER_FLAGS,
    #[doc = " offset: 0x6c (108)"]
    pub PersistenceInfo: _WHEA_PERSISTENCE_INFO,
    #[doc = " offset: 0x74 (116)"]
    pub Reserved: [UCHAR; 12usize],
}
impl Default for _WHEA_ERROR_RECORD_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc8 (200) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _WHEA_ERROR_RECORD_HEADER,
    #[doc = " offset: 0x80 (128)"]
    pub SectionDescriptor: [_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR; 1usize],
}
impl Default for _WHEA_ERROR_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO {
    pub __bindgen_anon_1: _MM_PAGE_ACCESS_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: _MM_PAGE_ACCESS_INFO_FLAGS,
    #[doc = " offset: 0x0 (0)"]
    pub FileOffset: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub VirtualAddress: *mut VOID,
    #[doc = " offset: 0x0 (0)"]
    pub PointerProtoPte: *mut VOID,
}
impl Default for _MM_PAGE_ACCESS_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_PAGE_ACCESS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EVENT_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub Id: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Version: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub Channel: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub Level: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub Opcode: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub Task: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Keyword: ULONGLONG,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EVENT_DATA_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub Ptr: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Size: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Reserved: ULONG,
}
#[doc = " 0x14 (20) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub Type: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub ShareDisposition: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    #[doc = " offset: 0x4 (4)"]
    pub Generic: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub Port: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x4 (4)"]
    pub Interrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    #[doc = " offset: 0x4 (4)"]
    pub MessageInterrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    #[doc = " offset: 0x4 (4)"]
    pub Memory: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    #[doc = " offset: 0x4 (4)"]
    pub Dma: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    #[doc = " offset: 0x4 (4)"]
    pub DevicePrivate: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    #[doc = " offset: 0x4 (4)"]
    pub BusNumber: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    #[doc = " offset: 0x4 (4)"]
    pub DeviceSpecificData: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    #[doc = " offset: 0x4 (4)"]
    pub Memory40: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    #[doc = " offset: 0x4 (4)"]
    pub Memory48: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    #[doc = " offset: 0x4 (4)"]
    pub Memory64: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub Length: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub Length: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub Level: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Affinity: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Raw:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Translated:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MessageCount: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Affinity: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub Level: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Vector: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Affinity: ULONGLONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub Length: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " offset: 0x0 (0)"]
    pub Channel: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Port: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved1: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " offset: 0x0 (0)"]
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    #[doc = " offset: 0x0 (0)"]
    pub Start: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    #[doc = " offset: 0x0 (0)"]
    pub DataSize: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Reserved1: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    #[doc = " offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub Length40: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    #[doc = " offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub Length48: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    #[doc = " offset: 0x0 (0)"]
    pub Start: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub Length64: ULONG,
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub AllocateFromCount: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub AllocateFrom: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
}
impl Default for _ARBITER_RETEST_ALLOCATION_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_TEST_ALLOCATION_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub ArbitrationList: *mut _LIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub AllocateFromCount: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub AllocateFrom: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
}
impl Default for _ARBITER_TEST_ALLOCATION_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1c (28) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Version: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Revision: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Count: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PartialDescriptors: [_CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
impl Default for _CM_PARTIAL_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub AllocatedResources: *mut *mut _CM_PARTIAL_RESOURCE_LIST,
}
impl Default for _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x24 (36) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = " offset: 0x4 (4)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PartialResourceList: _CM_PARTIAL_RESOURCE_LIST,
}
impl Default for _CM_FULL_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_RESOURCE_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub List: [_CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
impl Default for _CM_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    #[doc = " offset: 0x0 (0)"]
    pub Option: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Type: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub ShareDisposition: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub Spare1: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub Spare2: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub Port: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub Memory: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x8 (8)"]
    pub Interrupt: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    #[doc = " offset: 0x8 (8)"]
    pub Dma: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    #[doc = " offset: 0x8 (8)"]
    pub Generic: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    #[doc = " offset: 0x8 (8)"]
    pub DevicePrivate: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    #[doc = " offset: 0x8 (8)"]
    pub BusNumber: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    #[doc = " offset: 0x8 (8)"]
    pub ConfigData: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    #[doc = " offset: 0x8 (8)"]
    pub Memory40: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    #[doc = " offset: 0x8 (8)"]
    pub Memory48: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    #[doc = " offset: 0x8 (8)"]
    pub Memory64: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Alignment: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Alignment: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub MinimumVector: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub MaximumVector: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub AffinityPolicy: _IRQ_DEVICE_POLICY,
    #[doc = " offset: 0xc (12)"]
    pub PriorityPolicy: _IRQ_PRIORITY,
    #[doc = " offset: 0x10 (16)"]
    pub TargetedProcessors: ULONGLONG,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " offset: 0x0 (0)"]
    pub MinimumChannel: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub MaximumChannel: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Alignment: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " offset: 0x0 (0)"]
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub MinBusNumber: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MaxBusNumber: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    #[doc = " offset: 0x0 (0)"]
    pub Priority: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Reserved1: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    #[doc = " offset: 0x0 (0)"]
    pub Length40: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Alignment40: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    #[doc = " offset: 0x0 (0)"]
    pub Length48: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Alignment48: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    #[doc = " offset: 0x0 (0)"]
    pub Length64: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Alignment64: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MinimumAddress: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub MaximumAddress: _LARGE_INTEGER,
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_QUERY_CONFLICT_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x8 (8)"]
    pub ConflictingResource: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = " offset: 0x10 (16)"]
    pub ConflictCount: *mut ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Conflicts: *mut *mut _ARBITER_CONFLICT_INFO,
}
impl Default for _ARBITER_QUERY_CONFLICT_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARBITER_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub Parameters: _ARBITER_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARBITER_PARAMETERS__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub TestAllocation: _ARBITER_TEST_ALLOCATION_PARAMETERS,
    #[doc = " offset: 0x0 (0)"]
    pub RetestAllocation: _ARBITER_RETEST_ALLOCATION_PARAMETERS,
    #[doc = " offset: 0x0 (0)"]
    pub BootAllocation: _ARBITER_BOOT_ALLOCATION_PARAMETERS,
    #[doc = " offset: 0x0 (0)"]
    pub QueryAllocatedResources: _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS,
    #[doc = " offset: 0x0 (0)"]
    pub QueryConflict: _ARBITER_QUERY_CONFLICT_PARAMETERS,
    #[doc = " offset: 0x0 (0)"]
    pub QueryArbitrate: _ARBITER_QUERY_ARBITRATE_PARAMETERS,
    #[doc = " offset: 0x0 (0)"]
    pub AddReserved: _ARBITER_ADD_RESERVED_PARAMETERS,
}
impl Default for _ARBITER_PARAMETERS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ARBITER_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_INTERFACE {
    #[doc = " offset: 0x0 (0)"]
    pub Size: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Version: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub Context: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub InterfaceReference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    #[doc = " offset: 0x18 (24)"]
    pub InterfaceDereference: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    pub ArbiterHandler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: _ARBITER_ACTION,
            arg3: *mut _ARBITER_PARAMETERS,
        ) -> LONG,
    >,
    #[doc = " offset: 0x28 (40)"]
    pub Flags: ULONG,
}
impl Default for _ARBITER_INTERFACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PI_RESOURCE_ARBITER_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceArbiterList: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub ResourceType: UCHAR,
    #[doc = " offset: 0x18 (24)"]
    pub ArbiterInterface: *mut _ARBITER_INTERFACE,
    #[doc = " offset: 0x20 (32)"]
    pub DeviceNode: *mut _DEVICE_NODE,
    #[doc = " offset: 0x28 (40)"]
    pub ResourceList: _LIST_ENTRY,
    #[doc = " offset: 0x38 (56)"]
    pub BestResourceList: _LIST_ENTRY,
    #[doc = " offset: 0x48 (72)"]
    pub BestConfig: _LIST_ENTRY,
    #[doc = " offset: 0x58 (88)"]
    pub ActiveArbiterList: _LIST_ENTRY,
    #[doc = " offset: 0x68 (104)"]
    pub State: UCHAR,
    #[doc = " offset: 0x69 (105)"]
    pub ResourcesChanged: UCHAR,
}
impl Default for _PI_RESOURCE_ARBITER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_ALTERNATIVE {
    #[doc = " offset: 0x0 (0)"]
    pub Minimum: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Maximum: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Length: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Alignment: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub Priority: LONG,
    #[doc = " offset: 0x24 (36)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub Descriptor: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = " offset: 0x30 (48)"]
    pub Reserved: [ULONG; 3usize],
}
impl Default for _ARBITER_ALTERNATIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_LIST_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub AlternativeCount: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Alternatives: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = " offset: 0x20 (32)"]
    pub PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x28 (40)"]
    pub RequestSource: _ARBITER_REQUEST_SOURCE,
    #[doc = " offset: 0x2c (44)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub WorkSpace: LONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = " offset: 0x3c (60)"]
    pub SlotNumber: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub Assignment: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
    #[doc = " offset: 0x50 (80)"]
    pub SelectedAlternative: *mut _IO_RESOURCE_DESCRIPTOR,
    #[doc = " offset: 0x58 (88)"]
    pub Result: _ARBITER_RESULT,
}
impl Default for _ARBITER_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_ALLOCATION_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub Start: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub End: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub CurrentMinimum: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub CurrentMaximum: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub Entry: *mut _ARBITER_LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub CurrentAlternative: *mut _ARBITER_ALTERNATIVE,
    #[doc = " offset: 0x30 (48)"]
    pub AlternativeCount: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub Alternatives: *mut _ARBITER_ALTERNATIVE,
    #[doc = " offset: 0x40 (64)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x42 (66)"]
    pub RangeAttributes: UCHAR,
    #[doc = " offset: 0x43 (67)"]
    pub RangeAvailableAttributes: UCHAR,
    #[doc = " offset: 0x48 (72)"]
    pub WorkSpace: ULONGLONG,
}
impl Default for _ARBITER_ALLOCATION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Version: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Revision: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub Count: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Descriptors: [_IO_RESOURCE_DESCRIPTOR; 1usize],
}
impl Default for _IO_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub ListSize: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = " offset: 0x8 (8)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SlotNumber: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Reserved: [ULONG; 3usize],
    #[doc = " offset: 0x1c (28)"]
    pub AlternativeLists: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub List: [_IO_RESOURCE_LIST; 1usize],
}
impl Default for _IO_RESOURCE_REQUIREMENTS_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PNP_RESOURCE_REQUEST {
    #[doc = " offset: 0x0 (0)"]
    pub PhysicalDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x8 (8)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub AllocationType: _ARBITER_REQUEST_SOURCE,
    #[doc = " offset: 0x10 (16)"]
    pub Priority: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Position: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub ResourceRequirements: *mut _IO_RESOURCE_REQUIREMENTS_LIST,
    #[doc = " offset: 0x20 (32)"]
    pub ReqList: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub ResourceAssignment: *mut _CM_RESOURCE_LIST,
    #[doc = " offset: 0x30 (48)"]
    pub TranslatedResourceAssignment: *mut _CM_RESOURCE_LIST,
    #[doc = " offset: 0x38 (56)"]
    pub Status: LONG,
}
impl Default for _PNP_RESOURCE_REQUEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMWSLE_FREE_ENTRY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMWSLE_FREE_ENTRY {
    #[inline]
    pub fn MustBeZero(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MustBeZero(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreviousFree(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u64) }
    }
    #[inline]
    pub fn set_PreviousFree(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn NextFree(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_NextFree(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MustBeZero: ULONGLONG,
        PreviousFree: ULONGLONG,
        NextFree: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MustBeZero: u64 = unsafe { ::std::mem::transmute(MustBeZero) };
            MustBeZero as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let PreviousFree: u64 = unsafe { ::std::mem::transmute(PreviousFree) };
            PreviousFree as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let NextFree: u64 = unsafe { ::std::mem::transmute(NextFree) };
            NextFree as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMWSLENTRY {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMWSLENTRY {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LockedInWs(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LockedInWs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LockedInMemory(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LockedInMemory(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Protection(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Protection(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Hashed(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Hashed(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Direct(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Direct(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Age(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Age(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn VirtualPageNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_VirtualPageNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        LockedInWs: ULONGLONG,
        LockedInMemory: ULONGLONG,
        Protection: ULONGLONG,
        Hashed: ULONGLONG,
        Direct: ULONGLONG,
        Age: ULONGLONG,
        VirtualPageNumber: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LockedInWs: u64 = unsafe { ::std::mem::transmute(LockedInWs) };
            LockedInWs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LockedInMemory: u64 = unsafe { ::std::mem::transmute(LockedInMemory) };
            LockedInMemory as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Protection: u64 = unsafe { ::std::mem::transmute(Protection) };
            Protection as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Hashed: u64 = unsafe { ::std::mem::transmute(Hashed) };
            Hashed as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Direct: u64 = unsafe { ::std::mem::transmute(Direct) };
            Direct as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let Age: u64 = unsafe { ::std::mem::transmute(Age) };
            Age as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let VirtualPageNumber: u64 = unsafe { ::std::mem::transmute(VirtualPageNumber) };
            VirtualPageNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMWSLE {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MMWSLE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMWSLE__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub VirtualAddress: *mut VOID,
    #[doc = " offset: 0x0 (0)"]
    pub Long: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub e1: _MMWSLENTRY,
    #[doc = " offset: 0x0 (0)"]
    pub e2: _MMWSLE_FREE_ENTRY,
}
impl Default for _MMWSLE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMWSLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_CACHED_VALUE_INDEX {
    #[doc = " offset: 0x0 (0)"]
    pub CellIndex: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Data: _CM_CACHED_VALUE_INDEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_CACHED_VALUE_INDEX__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub CellData: _CELL_DATA,
    #[doc = " offset: 0x8 (8)"]
    pub List: [ULONGLONG; 1usize],
}
impl Default for _CM_CACHED_VALUE_INDEX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_CACHED_VALUE_INDEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x498 (1176) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMWSL {
    #[doc = " offset: 0x0 (0)"]
    pub FirstFree: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub FirstDynamic: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub LastEntry: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub NextSlot: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Wsle: *mut _MMWSLE,
    #[doc = " offset: 0x18 (24)"]
    pub LowestPagableAddress: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub LastInitializedWsle: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub NextEstimationSlot: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub NextAgingSlot: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub EstimatedAvailable: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub GrowthSinceLastEstimate: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub NumberOfCommittedPageTables: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub VadBitMapHint: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub NonDirectCount: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub LastVadBit: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub MaximumLastVadBit: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub LastAllocationSizeHint: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub LastAllocationSize: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub NonDirectHash: *mut _MMWSLE_NONDIRECT_HASH,
    #[doc = " offset: 0x58 (88)"]
    pub HashTableStart: *mut _MMWSLE_HASH,
    #[doc = " offset: 0x60 (96)"]
    pub HighestPermittedHashAddress: *mut _MMWSLE_HASH,
    #[doc = " offset: 0x68 (104)"]
    pub HighestUserAddress: *mut VOID,
    #[doc = " offset: 0x70 (112)"]
    pub MaximumUserPageTablePages: ULONG,
    #[doc = " offset: 0x74 (116)"]
    pub MaximumUserPageDirectoryPages: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub CommittedPageTables: *mut ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub NumberOfCommittedPageDirectories: ULONG,
    #[doc = " offset: 0x88 (136)"]
    pub CommittedPageDirectories: [ULONGLONG; 128usize],
    #[doc = " offset: 0x488 (1160)"]
    pub NumberOfCommittedPageDirectoryParents: ULONG,
    #[doc = " offset: 0x490 (1168)"]
    pub CommittedPageDirectoryParents: [ULONGLONG; 1usize],
}
impl Default for _MMWSL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_CRITICAL_SECTION {
    #[doc = " offset: 0x0 (0)"]
    pub DebugInfo: *mut _RTL_CRITICAL_SECTION_DEBUG,
    #[doc = " offset: 0x8 (8)"]
    pub LockCount: LONG,
    #[doc = " offset: 0xc (12)"]
    pub RecursionCount: LONG,
    #[doc = " offset: 0x10 (16)"]
    pub OwningThread: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub LockSemaphore: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub SpinCount: ULONGLONG,
}
impl Default for _RTL_CRITICAL_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_ATOM_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CriticalSection: _RTL_CRITICAL_SECTION,
    #[doc = " offset: 0x30 (48)"]
    pub RtlHandleTable: _RTL_HANDLE_TABLE,
    #[doc = " offset: 0x60 (96)"]
    pub NumberOfBuckets: ULONG,
    #[doc = " offset: 0x68 (104)"]
    pub Buckets: [*mut _RTL_ATOM_TABLE_ENTRY; 1usize],
}
impl Default for _RTL_ATOM_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_LOCK {
    #[doc = " offset: 0x0 (0)"]
    pub Lock: _HEAP_LOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_LOCK__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub CriticalSection: _RTL_CRITICAL_SECTION,
}
impl Default for _HEAP_LOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HEAP_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    #[doc = " offset: 0x0 (0)"]
    pub Type: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub CreatorBackTraceIndex: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    #[doc = " offset: 0x10 (16)"]
    pub ProcessLocksList: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub EntryCount: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub ContentionCount: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub CreatorBackTraceIndexHigh: USHORT,
    #[doc = " offset: 0x2e (46)"]
    pub SpareUSHORT: USHORT,
}
impl Default for _RTL_CRITICAL_SECTION_DEBUG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HANDLE_TABLE_ENTRY {
    pub __bindgen_anon_1: _HANDLE_TABLE_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _HANDLE_TABLE_ENTRY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HANDLE_TABLE_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Object: *mut VOID,
    #[doc = " offset: 0x0 (0)"]
    pub ObAttributes: ULONG,
    #[doc = " offset: 0x0 (0)"]
    pub InfoTable: *mut _HANDLE_TABLE_ENTRY_INFO,
    #[doc = " offset: 0x0 (0)"]
    pub Value: ULONGLONG,
}
impl Default for _HANDLE_TABLE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HANDLE_TABLE_ENTRY__bindgen_ty_2 {
    #[doc = " offset: 0x8 (8)"]
    pub GrantedAccess: ULONG,
    pub __bindgen_anon_1: _HANDLE_TABLE_ENTRY__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub NextFreeTableEntry: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HANDLE_TABLE_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub GrantedAccessIndex: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub CreatorBackTraceIndex: USHORT,
}
impl Default for _HANDLE_TABLE_ENTRY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _HANDLE_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OWNER_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub OwnerThread: ULONGLONG,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OWNER_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub OwnerCount: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub TableSize: ULONG,
}
impl Default for _OWNER_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OWNER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMADDRESS_NODE {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MMADDRESS_NODE__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub LeftChild: *mut _MMADDRESS_NODE,
    #[doc = " offset: 0x10 (16)"]
    pub RightChild: *mut _MMADDRESS_NODE,
    #[doc = " offset: 0x18 (24)"]
    pub StartingVpn: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub EndingVpn: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMADDRESS_NODE__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _MMADDRESS_NODE,
}
impl Default for _MMADDRESS_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMADDRESS_NODE__bindgen_ty_1 {
    #[inline]
    pub fn Balance(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Balance: LONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Balance: u64 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMADDRESS_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ERESOURCE {
    #[doc = " offset: 0x0 (0)"]
    pub SystemResourcesList: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub OwnerTable: *mut _OWNER_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub ActiveCount: SHORT,
    #[doc = " offset: 0x1a (26)"]
    pub Flag: USHORT,
    #[doc = " offset: 0x20 (32)"]
    pub SharedWaiters: *mut _KSEMAPHORE,
    #[doc = " offset: 0x28 (40)"]
    pub ExclusiveWaiters: *mut _KEVENT,
    #[doc = " offset: 0x30 (48)"]
    pub OwnerEntry: _OWNER_ENTRY,
    #[doc = " offset: 0x40 (64)"]
    pub ActiveEntries: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub ContentionCount: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub NumberOfSharedWaiters: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub NumberOfExclusiveWaiters: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub Reserved2: *mut VOID,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    #[doc = " offset: 0x60 (96)"]
    pub SpinLock: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_1 {
    #[doc = " offset: 0x58 (88)"]
    pub Address: *mut VOID,
    #[doc = " offset: 0x58 (88)"]
    pub CreatorBackTraceIndex: ULONGLONG,
}
impl Default for _ERESOURCE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ERESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x318 (792) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN {
    #[doc = " offset: 0x0 (0)"]
    pub TokenSource: _TOKEN_SOURCE,
    #[doc = " offset: 0x10 (16)"]
    pub TokenId: _LUID,
    #[doc = " offset: 0x18 (24)"]
    pub AuthenticationId: _LUID,
    #[doc = " offset: 0x20 (32)"]
    pub ParentTokenId: _LUID,
    #[doc = " offset: 0x28 (40)"]
    pub ExpirationTime: _LARGE_INTEGER,
    #[doc = " offset: 0x30 (48)"]
    pub TokenLock: *mut _ERESOURCE,
    #[doc = " offset: 0x38 (56)"]
    pub ModifiedId: _LUID,
    #[doc = " offset: 0x40 (64)"]
    pub Privileges: _SEP_TOKEN_PRIVILEGES,
    #[doc = " offset: 0x58 (88)"]
    pub AuditPolicy: _SEP_AUDIT_POLICY,
    #[doc = " offset: 0x74 (116)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub UserAndGroupCount: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub RestrictedSidCount: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub VariableLength: ULONG,
    #[doc = " offset: 0x84 (132)"]
    pub DynamicCharged: ULONG,
    #[doc = " offset: 0x88 (136)"]
    pub DynamicAvailable: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub DefaultOwnerIndex: ULONG,
    #[doc = " offset: 0x90 (144)"]
    pub UserAndGroups: *mut _SID_AND_ATTRIBUTES,
    #[doc = " offset: 0x98 (152)"]
    pub RestrictedSids: *mut _SID_AND_ATTRIBUTES,
    #[doc = " offset: 0xa0 (160)"]
    pub PrimaryGroup: *mut VOID,
    #[doc = " offset: 0xa8 (168)"]
    pub DynamicPart: *mut ULONG,
    #[doc = " offset: 0xb0 (176)"]
    pub DefaultDacl: *mut _ACL,
    #[doc = " offset: 0xb8 (184)"]
    pub TokenType: _TOKEN_TYPE,
    #[doc = " offset: 0xbc (188)"]
    pub ImpersonationLevel: _SECURITY_IMPERSONATION_LEVEL,
    #[doc = " offset: 0xc0 (192)"]
    pub TokenFlags: ULONG,
    #[doc = " offset: 0xc4 (196)"]
    pub TokenInUse: UCHAR,
    #[doc = " offset: 0xc8 (200)"]
    pub IntegrityLevelIndex: ULONG,
    #[doc = " offset: 0xcc (204)"]
    pub MandatoryPolicy: ULONG,
    #[doc = " offset: 0xd0 (208)"]
    pub ProxyData: *mut _SECURITY_TOKEN_PROXY_DATA,
    #[doc = " offset: 0xd8 (216)"]
    pub AuditData: *mut _SECURITY_TOKEN_AUDIT_DATA,
    #[doc = " offset: 0xe0 (224)"]
    pub LogonSession: *mut _SEP_LOGON_SESSION_REFERENCES,
    #[doc = " offset: 0xe8 (232)"]
    pub OriginatingLogonSession: _LUID,
    #[doc = " offset: 0xf0 (240)"]
    pub SidHash: _SID_AND_ATTRIBUTES_HASH,
    #[doc = " offset: 0x200 (512)"]
    pub RestrictedSidHash: _SID_AND_ATTRIBUTES_HASH,
    #[doc = " offset: 0x310 (784)"]
    pub VariablePart: ULONGLONG,
}
impl Default for _TOKEN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FS_FILTER_PARAMETERS {
    #[doc = " offset: 0x0 (0)"]
    pub AcquireForModifiedPageWriter: _FS_FILTER_PARAMETERS__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub ReleaseForModifiedPageWriter: _FS_FILTER_PARAMETERS__bindgen_ty_2,
    #[doc = " offset: 0x0 (0)"]
    pub AcquireForSectionSynchronization: _FS_FILTER_PARAMETERS__bindgen_ty_3,
    #[doc = " offset: 0x0 (0)"]
    pub NotifyStreamFileObject: _FS_FILTER_PARAMETERS__bindgen_ty_4,
    #[doc = " offset: 0x0 (0)"]
    pub Others: _FS_FILTER_PARAMETERS__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub EndingOffset: *mut _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub ResourceToRelease: *mut *mut _ERESOURCE,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub ResourceToRelease: *mut _ERESOURCE,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub SyncType: _FS_FILTER_SECTION_SYNC_TYPE,
    #[doc = " offset: 0x4 (4)"]
    pub PageProtection: ULONG,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_4 {
    #[doc = " offset: 0x0 (0)"]
    pub NotificationType: _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE,
    #[doc = " offset: 0x8 (8)"]
    pub SafeToRecurse: UCHAR,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_5 {
    #[doc = " offset: 0x0 (0)"]
    pub Argument1: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Argument2: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Argument3: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Argument4: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub Argument5: *mut VOID,
}
impl Default for _FS_FILTER_PARAMETERS__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _FS_FILTER_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FS_FILTER_CALLBACK_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub SizeOfFsFilterCallbackData: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Operation: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub Reserved: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = " offset: 0x18 (24)"]
    pub Parameters: _FS_FILTER_PARAMETERS,
}
impl Default for _FS_FILTER_CALLBACK_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FS_FILTER_CALLBACKS {
    #[doc = " offset: 0x0 (0)"]
    pub SizeOfFsFilterCallbacks: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Reserved: ULONG,
    pub PreAcquireForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostAcquireForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreReleaseForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostReleaseForSectionSynchronization: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreAcquireForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostAcquireForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreReleaseForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostReleaseForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreAcquireForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostAcquireForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
    pub PreReleaseForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: *mut *mut VOID) -> LONG,
    >,
    pub PostReleaseForModifiedPageWriter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FS_FILTER_CALLBACK_DATA, arg2: LONG, arg3: *mut VOID),
    >,
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_AVL_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub BalancedRoot: _MMADDRESS_NODE,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " offset: 0x30 (48)"]
    pub NodeHint: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub NodeFreeHint: *mut VOID,
}
impl Default for _MM_AVL_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MM_AVL_TABLE {
    #[inline]
    pub fn DepthOfTree(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_DepthOfTree(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NumberGenericTableElements(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_NumberGenericTableElements(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DepthOfTree: ULONGLONG,
        Unused: ULONGLONG,
        NumberGenericTableElements: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DepthOfTree: u64 = unsafe { ::std::mem::transmute(DepthOfTree) };
            DepthOfTree as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let NumberGenericTableElements: u64 =
                unsafe { ::std::mem::transmute(NumberGenericTableElements) };
            NumberGenericTableElements as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HARDWARE_PTE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _HARDWARE_PTE {
    #[inline]
    pub fn Valid(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prototype(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Prototype(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 28u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn SoftwareWsIndex(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_SoftwareWsIndex(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn NoExecute(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NoExecute(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONGLONG,
        Write: ULONGLONG,
        Owner: ULONGLONG,
        WriteThrough: ULONGLONG,
        CacheDisable: ULONGLONG,
        Accessed: ULONGLONG,
        Dirty: ULONGLONG,
        LargePage: ULONGLONG,
        Global: ULONGLONG,
        CopyOnWrite: ULONGLONG,
        Prototype: ULONGLONG,
        reserved0: ULONGLONG,
        PageFrameNumber: ULONGLONG,
        reserved1: ULONGLONG,
        SoftwareWsIndex: ULONGLONG,
        NoExecute: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u64 = unsafe { ::std::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u64 = unsafe { ::std::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u64 = unsafe { ::std::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u64 = unsafe { ::std::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CopyOnWrite: u64 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Prototype: u64 = unsafe { ::std::mem::transmute(Prototype) };
            Prototype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved0: u64 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 28u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(40usize, 12u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let SoftwareWsIndex: u64 = unsafe { ::std::mem::transmute(SoftwareWsIndex) };
            SoftwareWsIndex as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let NoExecute: u64 = unsafe { ::std::mem::transmute(NoExecute) };
            NoExecute as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTE {
    #[doc = " offset: 0x0 (0)"]
    pub u: _MMPTE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPTE__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Long: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub VolatileLong: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub Hard: _MMPTE_HARDWARE,
    #[doc = " offset: 0x0 (0)"]
    pub HardLarge: _MMPTE_HARDWARE_LARGEPAGE,
    #[doc = " offset: 0x0 (0)"]
    pub Flush: _HARDWARE_PTE,
    #[doc = " offset: 0x0 (0)"]
    pub Proto: _MMPTE_PROTOTYPE,
    #[doc = " offset: 0x0 (0)"]
    pub Soft: _MMPTE_SOFTWARE,
    #[doc = " offset: 0x0 (0)"]
    pub TimeStamp: _MMPTE_TIMESTAMP,
    #[doc = " offset: 0x0 (0)"]
    pub Trans: _MMPTE_TRANSITION,
    #[doc = " offset: 0x0 (0)"]
    pub Subsect: _MMPTE_SUBSECTION,
    #[doc = " offset: 0x0 (0)"]
    pub List: _MMPTE_LIST,
}
impl Default for _MMPTE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMPTE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_SPECIAL_POOL {
    #[doc = " offset: 0x0 (0)"]
    pub PteBase: *mut _MMPTE,
    #[doc = " offset: 0x8 (8)"]
    pub FreePteHead: _MMPTE,
    #[doc = " offset: 0x10 (16)"]
    pub FreePteTail: _MMPTE,
    #[doc = " offset: 0x18 (24)"]
    pub PagesInUse: LONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub SpecialPoolPdes: _RTL_BITMAP,
}
impl Default for _MI_SPECIAL_POOL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PAGED_POOL_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub Mutex: _KGUARDED_MUTEX,
    #[doc = " offset: 0x38 (56)"]
    pub PagedPoolAllocationMap: _RTL_BITMAP,
    #[doc = " offset: 0x48 (72)"]
    pub FirstPteForPagedPool: *mut _MMPTE,
    #[doc = " offset: 0x50 (80)"]
    pub PagedPoolHint: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub PagedPoolCommit: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub AllocatedPagedPool: ULONGLONG,
}
impl Default for _MM_PAGED_POOL_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMBANKED_SECTION {
    #[doc = " offset: 0x0 (0)"]
    pub BasePhysicalPage: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub BasedPte: *mut _MMPTE,
    #[doc = " offset: 0x10 (16)"]
    pub BankSize: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub BankShift: ULONG,
    pub BankedRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: ULONG, arg2: ULONG, arg3: *mut VOID)>,
    #[doc = " offset: 0x20 (32)"]
    pub Context: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub CurrentMappedPte: *mut _MMPTE,
    #[doc = " offset: 0x30 (48)"]
    pub BankTemplate: [_MMPTE; 1usize],
}
impl Default for _MMBANKED_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PER_SESSION_PROTOS {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MI_PER_SESSION_PROTOS__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub LeftChild: *mut _MMADDRESS_NODE,
    #[doc = " offset: 0x10 (16)"]
    pub RightChild: *mut _MMADDRESS_NODE,
    pub __bindgen_anon_1: _MI_PER_SESSION_PROTOS__bindgen_ty_2,
    #[doc = " offset: 0x20 (32)"]
    pub EndingVpn: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub SubsectionBase: *mut _MMPTE,
    #[doc = " offset: 0x30 (48)"]
    pub u2: _MI_PER_SESSION_PROTOS__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PER_SESSION_PROTOS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _MMADDRESS_NODE,
    #[doc = " offset: 0x0 (0)"]
    pub NextToFree: *mut _MI_PER_SESSION_PROTOS,
}
impl Default for _MI_PER_SESSION_PROTOS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MI_PER_SESSION_PROTOS__bindgen_ty_1 {
    #[inline]
    pub fn Balance(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Balance: LONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Balance: u64 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PER_SESSION_PROTOS__bindgen_ty_2 {
    #[doc = " offset: 0x18 (24)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub StartingVpn: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Subsection: *mut _SUBSECTION,
}
impl Default for _MI_PER_SESSION_PROTOS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MI_PER_SESSION_PROTOS__bindgen_ty_3 {
    #[doc = " offset: 0x30 (48)"]
    pub ReferenceCount: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub NumberOfPtesToFree: ULONG,
}
impl Default for _MI_PER_SESSION_PROTOS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_PER_SESSION_PROTOS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MSUBSECTION {
    #[doc = " offset: 0x0 (0)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = " offset: 0x8 (8)"]
    pub SubsectionBase: *mut _MMPTE,
    pub __bindgen_anon_1: _MSUBSECTION__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub PtesInSubsection: ULONG,
    pub __bindgen_anon_2: _MSUBSECTION__bindgen_ty_2,
    #[doc = " offset: 0x28 (40)"]
    pub u: _MSUBSECTION__bindgen_ty_3,
    #[doc = " offset: 0x2c (44)"]
    pub StartingSector: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub NumberOfFullSectors: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub u1: _MSUBSECTION__bindgen_ty_4,
    #[doc = " offset: 0x40 (64)"]
    pub LeftChild: *mut _MMSUBSECTION_NODE,
    #[doc = " offset: 0x48 (72)"]
    pub RightChild: *mut _MMSUBSECTION_NODE,
    #[doc = " offset: 0x50 (80)"]
    pub DereferenceList: _LIST_ENTRY,
    #[doc = " offset: 0x60 (96)"]
    pub NumberOfMappedViews: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MSUBSECTION__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub NextSubsection: *mut _SUBSECTION,
    #[doc = " offset: 0x10 (16)"]
    pub NextMappedSubsection: *mut _MSUBSECTION,
}
impl Default for _MSUBSECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MSUBSECTION__bindgen_ty_2 {
    #[doc = " offset: 0x20 (32)"]
    pub UnusedPtes: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub GlobalPerSessionHead: *mut _MM_AVL_TABLE,
}
impl Default for _MSUBSECTION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MSUBSECTION__bindgen_ty_3 {
    #[doc = " offset: 0x28 (40)"]
    pub LongFlags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub SubsectionFlags: _MMSUBSECTION_FLAGS,
}
impl Default for _MSUBSECTION__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MSUBSECTION__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x38 (56)"]
    pub Parent: *mut _MMSUBSECTION_NODE,
}
impl Default for _MSUBSECTION__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MSUBSECTION__bindgen_ty_4 {
    #[inline]
    pub fn Balance(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Balance: LONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Balance: u64 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MSUBSECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SUBSECTION {
    #[doc = " offset: 0x0 (0)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = " offset: 0x8 (8)"]
    pub SubsectionBase: *mut _MMPTE,
    #[doc = " offset: 0x10 (16)"]
    pub NextSubsection: *mut _SUBSECTION,
    #[doc = " offset: 0x18 (24)"]
    pub PtesInSubsection: ULONG,
    pub __bindgen_anon_1: _SUBSECTION__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub u: _SUBSECTION__bindgen_ty_2,
    #[doc = " offset: 0x2c (44)"]
    pub StartingSector: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub NumberOfFullSectors: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SUBSECTION__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub UnusedPtes: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub GlobalPerSessionHead: *mut _MM_AVL_TABLE,
}
impl Default for _SUBSECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SUBSECTION__bindgen_ty_2 {
    #[doc = " offset: 0x28 (40)"]
    pub LongFlags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub SubsectionFlags: _MMSUBSECTION_FLAGS,
}
impl Default for _SUBSECTION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SUBSECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPFN {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MMPFN__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub u2: _MMPFN__bindgen_ty_2,
    pub __bindgen_anon_1: _MMPFN__bindgen_ty_3,
    #[doc = " offset: 0x18 (24)"]
    pub u3: _MMPFN__bindgen_ty_4,
    #[doc = " offset: 0x1c (28)"]
    pub UsedPageTableEntries: USHORT,
    #[doc = " offset: 0x1e (30)"]
    pub VaType: UCHAR,
    #[doc = " offset: 0x1f (31)"]
    pub ViewCount: UCHAR,
    pub __bindgen_anon_2: _MMPFN__bindgen_ty_5,
    #[doc = " offset: 0x28 (40)"]
    pub u4: _MMPFN__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Flink: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub WsIndex: ULONG,
    #[doc = " offset: 0x0 (0)"]
    pub Event: *mut _KEVENT,
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut VOID,
    #[doc = " offset: 0x0 (0)"]
    pub VolatileNext: *mut VOID,
    #[doc = " offset: 0x0 (0)"]
    pub KernelStackOwner: *mut _KTHREAD,
    #[doc = " offset: 0x0 (0)"]
    pub NextStackPfn: _SINGLE_LIST_ENTRY,
}
impl Default for _MMPFN__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_2 {
    #[doc = " offset: 0x8 (8)"]
    pub Blink: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub ImageProtoPte: *mut _MMPTE,
    #[doc = " offset: 0x8 (8)"]
    pub ShareCount: ULONGLONG,
}
impl Default for _MMPFN__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_3 {
    #[doc = " offset: 0x10 (16)"]
    pub PteAddress: *mut _MMPTE,
    #[doc = " offset: 0x10 (16)"]
    pub VolatilePteAddress: *mut VOID,
}
impl Default for _MMPFN__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_4 {
    pub __bindgen_anon_1: _MMPFN__bindgen_ty_4__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub e2: _MMPFN__bindgen_ty_4__bindgen_ty_2,
    #[doc = " offset: 0x18 (24)"]
    pub e3: _MMPFN__bindgen_ty_4__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPFN__bindgen_ty_4__bindgen_ty_1 {
    #[doc = " offset: 0x18 (24)"]
    pub ReferenceCount: USHORT,
    #[doc = " offset: 0x1a (26)"]
    pub e1: _MMPFNENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPFN__bindgen_ty_4__bindgen_ty_2 {
    pub __bindgen_anon_1: _MMPFN__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x2 (2)"]
    pub ShortFlags: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub ReferenceCount: USHORT,
    #[doc = " offset: 0x0 (0)"]
    pub VolatileReferenceCount: SHORT,
}
impl Default for _MMPFN__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMPFN__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPFN__bindgen_ty_4__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub ReferenceCount: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub ByteFlags: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub InterlockedByteFlags: UCHAR,
}
impl Default for _MMPFN__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_5 {
    #[doc = " offset: 0x20 (32)"]
    pub OriginalPte: _MMPTE,
    #[doc = " offset: 0x20 (32)"]
    pub AweReferenceCount: LONG,
}
impl Default for _MMPFN__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN__bindgen_ty_6 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for _MMPFN__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMPFN__bindgen_ty_6 {
    #[inline]
    pub fn PteFrame(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_PteFrame(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PfnImageVerified(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PfnImageVerified(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AweAllocation(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AweAllocation(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PrototypePte(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PrototypePte(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageColor(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_PageColor(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PteFrame: ULONGLONG,
        Unused: ULONGLONG,
        PfnImageVerified: ULONGLONG,
        AweAllocation: ULONGLONG,
        PrototypePte: ULONGLONG,
        PageColor: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 52u8, {
            let PteFrame: u64 = unsafe { ::std::mem::transmute(PteFrame) };
            PteFrame as u64
        });
        __bindgen_bitfield_unit.set(52usize, 3u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let PfnImageVerified: u64 = unsafe { ::std::mem::transmute(PfnImageVerified) };
            PfnImageVerified as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let AweAllocation: u64 = unsafe { ::std::mem::transmute(AweAllocation) };
            AweAllocation as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let PrototypePte: u64 = unsafe { ::std::mem::transmute(PrototypePte) };
            PrototypePte as u64
        });
        __bindgen_bitfield_unit.set(58usize, 6u8, {
            let PageColor: u64 = unsafe { ::std::mem::transmute(PageColor) };
            PageColor as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMPFN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xd8 (216) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub Vpb: *mut _VPB,
    #[doc = " offset: 0x18 (24)"]
    pub FsContext: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub FsContext2: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub SectionObjectPointer: *mut _SECTION_OBJECT_POINTERS,
    #[doc = " offset: 0x30 (48)"]
    pub PrivateCacheMap: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub FinalStatus: LONG,
    #[doc = " offset: 0x40 (64)"]
    pub RelatedFileObject: *mut _FILE_OBJECT,
    #[doc = " offset: 0x48 (72)"]
    pub LockOperation: UCHAR,
    #[doc = " offset: 0x49 (73)"]
    pub DeletePending: UCHAR,
    #[doc = " offset: 0x4a (74)"]
    pub ReadAccess: UCHAR,
    #[doc = " offset: 0x4b (75)"]
    pub WriteAccess: UCHAR,
    #[doc = " offset: 0x4c (76)"]
    pub DeleteAccess: UCHAR,
    #[doc = " offset: 0x4d (77)"]
    pub SharedRead: UCHAR,
    #[doc = " offset: 0x4e (78)"]
    pub SharedWrite: UCHAR,
    #[doc = " offset: 0x4f (79)"]
    pub SharedDelete: UCHAR,
    #[doc = " offset: 0x50 (80)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub FileName: _UNICODE_STRING,
    #[doc = " offset: 0x68 (104)"]
    pub CurrentByteOffset: _LARGE_INTEGER,
    #[doc = " offset: 0x70 (112)"]
    pub Waiters: ULONG,
    #[doc = " offset: 0x74 (116)"]
    pub Busy: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub LastLock: *mut VOID,
    #[doc = " offset: 0x80 (128)"]
    pub Lock: _KEVENT,
    #[doc = " offset: 0x98 (152)"]
    pub Event: _KEVENT,
    #[doc = " offset: 0xb0 (176)"]
    pub CompletionContext: *mut _IO_COMPLETION_CONTEXT,
    #[doc = " offset: 0xb8 (184)"]
    pub IrpListLock: ULONGLONG,
    #[doc = " offset: 0xc0 (192)"]
    pub IrpList: _LIST_ENTRY,
    #[doc = " offset: 0xd0 (208)"]
    pub FileObjectExtension: *mut VOID,
}
impl Default for _FILE_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceListHead: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub Lock: ULONGLONG,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDEVICE_QUEUE__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub Busy: UCHAR,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Hint(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Hint(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved: LONGLONG,
        Hint: LONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Hint: u64 = unsafe { ::std::mem::transmute(Hint) };
            Hint as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KDEVICE_QUEUE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KDEVICE_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_RUNDOWN_REF {
    pub __bindgen_anon_1: _EX_RUNDOWN_REF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_RUNDOWN_REF__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub Ptr: *mut VOID,
}
impl Default for _EX_RUNDOWN_REF__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EX_RUNDOWN_REF {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CLIENT_SECURITY_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub ImpersonationData: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub ImpersonationToken: *mut VOID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _PS_CLIENT_SECURITY_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PS_CLIENT_SECURITY_CONTEXT {
    #[inline]
    pub fn ImpersonationLevel(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_ImpersonationLevel(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn EffectiveOnly(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EffectiveOnly(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImpersonationLevel: ULONGLONG,
        EffectiveOnly: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let ImpersonationLevel: u64 = unsafe { ::std::mem::transmute(ImpersonationLevel) };
            ImpersonationLevel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EffectiveOnly: u64 = unsafe { ::std::mem::transmute(EffectiveOnly) };
            EffectiveOnly as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_FAST_REF {
    pub __bindgen_anon_1: _EX_FAST_REF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_FAST_REF__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Object: *mut VOID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub Value: ULONGLONG,
}
impl Default for _EX_FAST_REF__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _EX_FAST_REF__bindgen_ty_1 {
    #[inline]
    pub fn RefCnt(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_RefCnt(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RefCnt: ULONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let RefCnt: u64 = unsafe { ::std::mem::transmute(RefCnt) };
            RefCnt as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EX_FAST_REF {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1d0 (464) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHARED_CACHE_MAP {
    #[doc = " offset: 0x0 (0)"]
    pub NodeTypeCode: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub NodeByteSize: SHORT,
    #[doc = " offset: 0x4 (4)"]
    pub OpenCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FileSize: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub BcbList: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub SectionSize: _LARGE_INTEGER,
    #[doc = " offset: 0x28 (40)"]
    pub ValidDataLength: _LARGE_INTEGER,
    #[doc = " offset: 0x30 (48)"]
    pub ValidDataGoal: _LARGE_INTEGER,
    #[doc = " offset: 0x38 (56)"]
    pub InitialVacbs: [*mut _VACB; 4usize],
    #[doc = " offset: 0x58 (88)"]
    pub Vacbs: *mut *mut _VACB,
    #[doc = " offset: 0x60 (96)"]
    pub FileObjectFastRef: _EX_FAST_REF,
    #[doc = " offset: 0x68 (104)"]
    pub ActiveVacb: *mut _VACB,
    #[doc = " offset: 0x70 (112)"]
    pub NeedToZero: *mut VOID,
    #[doc = " offset: 0x78 (120)"]
    pub ActivePage: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub NeedToZeroPage: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub ActiveVacbSpinLock: ULONGLONG,
    #[doc = " offset: 0x88 (136)"]
    pub VacbActiveCount: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub DirtyPages: ULONG,
    #[doc = " offset: 0x90 (144)"]
    pub SharedCacheMapLinks: _LIST_ENTRY,
    #[doc = " offset: 0xa0 (160)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xa4 (164)"]
    pub Status: LONG,
    #[doc = " offset: 0xa8 (168)"]
    pub Mbcb: *mut _MBCB,
    #[doc = " offset: 0xb0 (176)"]
    pub Section: *mut VOID,
    #[doc = " offset: 0xb8 (184)"]
    pub CreateEvent: *mut _KEVENT,
    #[doc = " offset: 0xc0 (192)"]
    pub WaitOnActiveCount: *mut _KEVENT,
    #[doc = " offset: 0xc8 (200)"]
    pub PagesToWrite: ULONG,
    #[doc = " offset: 0xd0 (208)"]
    pub BeyondLastFlush: LONGLONG,
    #[doc = " offset: 0xd8 (216)"]
    pub Callbacks: *mut _CACHE_MANAGER_CALLBACKS,
    #[doc = " offset: 0xe0 (224)"]
    pub LazyWriteContext: *mut VOID,
    #[doc = " offset: 0xe8 (232)"]
    pub PrivateList: _LIST_ENTRY,
    #[doc = " offset: 0xf8 (248)"]
    pub LogHandle: *mut VOID,
    pub FlushToLsnRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: _LARGE_INTEGER)>,
    #[doc = " offset: 0x108 (264)"]
    pub DirtyPageThreshold: ULONG,
    #[doc = " offset: 0x10c (268)"]
    pub LazyWritePassCount: ULONG,
    #[doc = " offset: 0x110 (272)"]
    pub UninitializeEvent: *mut _CACHE_UNINITIALIZE_EVENT,
    #[doc = " offset: 0x118 (280)"]
    pub NeedToZeroVacb: *mut _VACB,
    #[doc = " offset: 0x120 (288)"]
    pub BcbSpinLock: ULONGLONG,
    #[doc = " offset: 0x128 (296)"]
    pub Reserved: *mut VOID,
    #[doc = " offset: 0x130 (304)"]
    pub Event: _KEVENT,
    #[doc = " offset: 0x148 (328)"]
    pub HighWaterMappingOffset: _LARGE_INTEGER,
    #[doc = " offset: 0x150 (336)"]
    pub PrivateCacheMap: _PRIVATE_CACHE_MAP,
    #[doc = " offset: 0x1b8 (440)"]
    pub WriteBehindWorkQueueEntry: *mut VOID,
    #[doc = " offset: 0x1c0 (448)"]
    pub VolumeCacheMap: *mut _VOLUME_CACHE_MAP,
    #[doc = " offset: 0x1c8 (456)"]
    pub ProcImagePathHash: ULONG,
    #[doc = " offset: 0x1cc (460)"]
    pub MappedWritesInProgress: ULONG,
}
impl Default for _SHARED_CACHE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WORK_QUEUE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub WorkQueueLinks: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub CoalescedWorkQueueLinks: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub Parameters: _WORK_QUEUE_ENTRY__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub Function: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WORK_QUEUE_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub Read: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x20 (32)"]
    pub Write: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x20 (32)"]
    pub Event: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_3,
    #[doc = " offset: 0x20 (32)"]
    pub Notification: _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub FileObject: *mut _FILE_OBJECT,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub SharedCacheMap: *mut _SHARED_CACHE_MAP,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub Event: *mut _KEVENT,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WORK_QUEUE_ENTRY__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " offset: 0x0 (0)"]
    pub Reason: ULONG,
}
impl Default for _WORK_QUEUE_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WORK_QUEUE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VACB {
    #[doc = " offset: 0x0 (0)"]
    pub BaseAddress: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub SharedCacheMap: *mut _SHARED_CACHE_MAP,
    #[doc = " offset: 0x10 (16)"]
    pub Overlay: _VACB__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub LruList: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub ArrayHead: *mut _VACB_ARRAY_HEADER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VACB__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub FileOffset: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub ActiveCount: USHORT,
}
impl Default for _VACB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VACB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_PUSH_LOCK {
    pub __bindgen_anon_1: _EX_PUSH_LOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_PUSH_LOCK__bindgen_ty_1 {
    pub __bindgen_anon_1: _EX_PUSH_LOCK__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Value: ULONGLONG,
    #[doc = " offset: 0x0 (0)"]
    pub Ptr: *mut VOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EX_PUSH_LOCK__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _EX_PUSH_LOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Locked(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Locked(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waiting(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Waiting(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waking(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Waking(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MultipleShared(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MultipleShared(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Shared(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Locked: ULONGLONG,
        Waiting: ULONGLONG,
        Waking: ULONGLONG,
        MultipleShared: ULONGLONG,
        Shared: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Locked: u64 = unsafe { ::std::mem::transmute(Locked) };
            Locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Waiting: u64 = unsafe { ::std::mem::transmute(Waiting) };
            Waiting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Waking: u64 = unsafe { ::std::mem::transmute(Waking) };
            Waking as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MultipleShared: u64 = unsafe { ::std::mem::transmute(MultipleShared) };
            MultipleShared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let Shared: u64 = unsafe { ::std::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EX_PUSH_LOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EX_PUSH_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAPPED_FILE_SEGMENT {
    #[doc = " offset: 0x0 (0)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = " offset: 0x8 (8)"]
    pub TotalNumberOfPtes: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SegmentFlags: _SEGMENT_FLAGS,
    #[doc = " offset: 0x10 (16)"]
    pub NumberOfCommittedPages: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub SizeOfSegment: ULONGLONG,
    pub __bindgen_anon_1: _MAPPED_FILE_SEGMENT__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub SegmentLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x30 (48)"]
    pub LastSubsectionHint: *mut _MSUBSECTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MAPPED_FILE_SEGMENT__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub ExtendInfo: *mut _MMEXTEND_INFO,
    #[doc = " offset: 0x20 (32)"]
    pub BasedAddress: *mut VOID,
}
impl Default for _MAPPED_FILE_SEGMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MAPPED_FILE_SEGMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x78 (120) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMVAD_LONG {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MMVAD_LONG__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub LeftChild: *mut _MMVAD,
    #[doc = " offset: 0x10 (16)"]
    pub RightChild: *mut _MMVAD,
    #[doc = " offset: 0x18 (24)"]
    pub StartingVpn: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub EndingVpn: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub u: _MMVAD_LONG__bindgen_ty_2,
    #[doc = " offset: 0x30 (48)"]
    pub PushLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x38 (56)"]
    pub u5: _MMVAD_LONG__bindgen_ty_3,
    #[doc = " offset: 0x40 (64)"]
    pub u2: _MMVAD_LONG__bindgen_ty_4,
    #[doc = " offset: 0x48 (72)"]
    pub Subsection: *mut _SUBSECTION,
    #[doc = " offset: 0x50 (80)"]
    pub FirstPrototypePte: *mut _MMPTE,
    #[doc = " offset: 0x58 (88)"]
    pub LastContiguousPte: *mut _MMPTE,
    #[doc = " offset: 0x60 (96)"]
    pub u3: _MMVAD_LONG__bindgen_ty_5,
    #[doc = " offset: 0x70 (112)"]
    pub u4: _MMVAD_LONG__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_LONG__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _MMVAD,
}
impl Default for _MMVAD_LONG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMVAD_LONG__bindgen_ty_1 {
    #[inline]
    pub fn Balance(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Balance: LONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Balance: u64 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_LONG__bindgen_ty_2 {
    #[doc = " offset: 0x28 (40)"]
    pub LongFlags: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub VadFlags: _MMVAD_FLAGS,
}
impl Default for _MMVAD_LONG__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_LONG__bindgen_ty_3 {
    #[doc = " offset: 0x38 (56)"]
    pub LongFlags3: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub VadFlags3: _MMVAD_FLAGS3,
}
impl Default for _MMVAD_LONG__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_LONG__bindgen_ty_4 {
    #[doc = " offset: 0x40 (64)"]
    pub LongFlags2: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub VadFlags2: _MMVAD_FLAGS2,
}
impl Default for _MMVAD_LONG__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_LONG__bindgen_ty_5 {
    #[doc = " offset: 0x60 (96)"]
    pub List: _LIST_ENTRY,
    #[doc = " offset: 0x60 (96)"]
    pub Secured: _MMADDRESS_LIST,
}
impl Default for _MMVAD_LONG__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_LONG__bindgen_ty_6 {
    #[doc = " offset: 0x70 (112)"]
    pub Banked: *mut _MMBANKED_SECTION,
    #[doc = " offset: 0x70 (112)"]
    pub ExtendedInfo: *mut _MMEXTEND_INFO,
}
impl Default for _MMVAD_LONG__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMVAD_LONG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_HANDLE_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Handles: *mut _ALPC_HANDLE_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub TotalHandles: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Lock: _EX_PUSH_LOCK,
}
impl Default for _ALPC_HANDLE_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMMUNICATION_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub ConnectionPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x8 (8)"]
    pub ServerCommunicationPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x10 (16)"]
    pub ClientCommunicationPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x18 (24)"]
    pub CommunicationList: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub HandleTable: _ALPC_HANDLE_TABLE,
}
impl Default for _ALPC_COMMUNICATION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BLOB {
    pub __bindgen_anon_1: _BLOB__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub u1: _BLOB__bindgen_ty_2,
    #[doc = " offset: 0x11 (17)"]
    pub ResourceId: UCHAR,
    #[doc = " offset: 0x12 (18)"]
    pub CachedReferences: SHORT,
    #[doc = " offset: 0x14 (20)"]
    pub ReferenceCount: LONG,
    #[doc = " offset: 0x18 (24)"]
    pub Lock: _EX_PUSH_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BLOB__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub ResourceList: _LIST_ENTRY,
    #[doc = " offset: 0x0 (0)"]
    pub FreeListEntry: _SLIST_ENTRY,
}
impl Default for _BLOB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BLOB__bindgen_ty_2 {
    #[doc = " offset: 0x10 (16)"]
    pub s1: _BLOB__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _BLOB__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _BLOB__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ReferenceCache(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReferenceCache(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Lookaside(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Lookaside(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Initializing(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Initializing(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Deleted(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Deleted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReferenceCache: UCHAR,
        Lookaside: UCHAR,
        Initializing: UCHAR,
        Deleted: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReferenceCache: u8 = unsafe { ::std::mem::transmute(ReferenceCache) };
            ReferenceCache as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Lookaside: u8 = unsafe { ::std::mem::transmute(Lookaside) };
            Lookaside as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Initializing: u8 = unsafe { ::std::mem::transmute(Initializing) };
            Initializing as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Deleted: u8 = unsafe { ::std::mem::transmute(Deleted) };
            Deleted as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _BLOB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _BLOB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xb48 (2888) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMHIVE {
    #[doc = " offset: 0x0 (0)"]
    pub Hive: _HHIVE,
    #[doc = " offset: 0x590 (1424)"]
    pub FileHandles: [*mut VOID; 6usize],
    #[doc = " offset: 0x5c0 (1472)"]
    pub NotifyList: _LIST_ENTRY,
    #[doc = " offset: 0x5d0 (1488)"]
    pub HiveList: _LIST_ENTRY,
    #[doc = " offset: 0x5e0 (1504)"]
    pub HiveLock: *mut _FAST_MUTEX,
    #[doc = " offset: 0x5e8 (1512)"]
    pub ViewLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x5f0 (1520)"]
    pub ViewLockOwner: *mut _KTHREAD,
    #[doc = " offset: 0x5f8 (1528)"]
    pub ViewLockLast: ULONG,
    #[doc = " offset: 0x5fc (1532)"]
    pub ViewUnLockLast: ULONG,
    #[doc = " offset: 0x600 (1536)"]
    pub WriterLock: *mut _FAST_MUTEX,
    #[doc = " offset: 0x608 (1544)"]
    pub FlusherLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x610 (1552)"]
    pub SecurityLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x618 (1560)"]
    pub MappedViewList: _LIST_ENTRY,
    #[doc = " offset: 0x628 (1576)"]
    pub PinnedViewList: _LIST_ENTRY,
    #[doc = " offset: 0x638 (1592)"]
    pub FlushedViewList: _LIST_ENTRY,
    #[doc = " offset: 0x648 (1608)"]
    pub MappedViewCount: USHORT,
    #[doc = " offset: 0x64a (1610)"]
    pub PinnedViewCount: USHORT,
    #[doc = " offset: 0x64c (1612)"]
    pub UseCount: ULONG,
    #[doc = " offset: 0x650 (1616)"]
    pub ViewsPerHive: ULONG,
    #[doc = " offset: 0x658 (1624)"]
    pub FileObject: *mut _FILE_OBJECT,
    #[doc = " offset: 0x660 (1632)"]
    pub LastShrinkHiveSize: ULONG,
    #[doc = " offset: 0x668 (1640)"]
    pub ActualFileSize: _LARGE_INTEGER,
    #[doc = " offset: 0x670 (1648)"]
    pub FileFullPath: _UNICODE_STRING,
    #[doc = " offset: 0x680 (1664)"]
    pub FileUserName: _UNICODE_STRING,
    #[doc = " offset: 0x690 (1680)"]
    pub HiveRootPath: _UNICODE_STRING,
    #[doc = " offset: 0x6a0 (1696)"]
    pub SecurityCount: ULONG,
    #[doc = " offset: 0x6a4 (1700)"]
    pub SecurityCacheSize: ULONG,
    #[doc = " offset: 0x6a8 (1704)"]
    pub SecurityHitHint: LONG,
    #[doc = " offset: 0x6b0 (1712)"]
    pub SecurityCache: *mut _CM_KEY_SECURITY_CACHE_ENTRY,
    #[doc = " offset: 0x6b8 (1720)"]
    pub SecurityHash: [_LIST_ENTRY; 64usize],
    #[doc = " offset: 0xab8 (2744)"]
    pub UnloadEventCount: ULONG,
    #[doc = " offset: 0xac0 (2752)"]
    pub UnloadEventArray: *mut *mut _KEVENT,
    #[doc = " offset: 0xac8 (2760)"]
    pub RootKcb: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0xad0 (2768)"]
    pub Frozen: UCHAR,
    #[doc = " offset: 0xad8 (2776)"]
    pub UnloadWorkItem: *mut _CM_WORKITEM,
    #[doc = " offset: 0xae0 (2784)"]
    pub GrowOnlyMode: UCHAR,
    #[doc = " offset: 0xae4 (2788)"]
    pub GrowOffset: ULONG,
    #[doc = " offset: 0xae8 (2792)"]
    pub KcbConvertListHead: _LIST_ENTRY,
    #[doc = " offset: 0xaf8 (2808)"]
    pub KnodeConvertListHead: _LIST_ENTRY,
    #[doc = " offset: 0xb08 (2824)"]
    pub CellRemapArray: *mut _CM_CELL_REMAP_BLOCK,
    #[doc = " offset: 0xb10 (2832)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xb18 (2840)"]
    pub TrustClassEntry: _LIST_ENTRY,
    #[doc = " offset: 0xb28 (2856)"]
    pub FlushCount: ULONG,
    #[doc = " offset: 0xb30 (2864)"]
    pub CmRm: *mut _CM_RM,
    #[doc = " offset: 0xb38 (2872)"]
    pub CmRmInitFailPoint: ULONG,
    #[doc = " offset: 0xb3c (2876)"]
    pub CmRmInitFailStatus: LONG,
    #[doc = " offset: 0xb40 (2880)"]
    pub CreatorOwner: *mut _KTHREAD,
}
impl Default for _CMHIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HIVE_LIST_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub FileName: *mut USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub BaseName: *mut USHORT,
    #[doc = " offset: 0x10 (16)"]
    pub RegRootName: *mut USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub CmHive: *mut _CMHIVE,
    #[doc = " offset: 0x20 (32)"]
    pub HHiveFlags: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub CmHiveFlags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub CmHive2: *mut _CMHIVE,
    #[doc = " offset: 0x30 (48)"]
    pub ThreadFinished: UCHAR,
    #[doc = " offset: 0x31 (49)"]
    pub ThreadStarted: UCHAR,
    #[doc = " offset: 0x32 (50)"]
    pub Allocate: UCHAR,
    #[doc = " offset: 0x33 (51)"]
    pub WinPERequired: UCHAR,
}
impl Default for _HIVE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xb0 (176) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_TRANS {
    #[doc = " offset: 0x0 (0)"]
    pub TransactionListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub KCBUoWListHead: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub LazyCommitListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub KtmTrans: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub CmRm: *mut _CM_RM,
    #[doc = " offset: 0x40 (64)"]
    pub KtmEnlistmentObject: *mut _KENLISTMENT,
    #[doc = " offset: 0x48 (72)"]
    pub KtmEnlistmentHandle: *mut VOID,
    #[doc = " offset: 0x50 (80)"]
    pub KtmUow: _GUID,
    #[doc = " offset: 0x60 (96)"]
    pub StartLsn: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub TransState: ULONG,
    #[doc = " offset: 0x6c (108)"]
    pub HiveCount: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub HiveArray: [*mut _CMHIVE; 8usize],
}
impl Default for _CM_TRANS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KCB_UOW {
    #[doc = " offset: 0x0 (0)"]
    pub TransactionListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub KCBLock: *mut _CM_INTENT_LOCK,
    #[doc = " offset: 0x18 (24)"]
    pub KeyLock: *mut _CM_INTENT_LOCK,
    #[doc = " offset: 0x20 (32)"]
    pub KCBListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub KeyControlBlock: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0x38 (56)"]
    pub Transaction: *mut _CM_TRANS,
    #[doc = " offset: 0x40 (64)"]
    pub UoWState: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub ActionType: UoWActionType,
    #[doc = " offset: 0x48 (72)"]
    pub StorageType: HSTORAGE_TYPE,
    pub __bindgen_anon_1: _CM_KCB_UOW__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KCB_UOW__bindgen_ty_1 {
    #[doc = " offset: 0x50 (80)"]
    pub ChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0x50 (80)"]
    pub VolatileKeyCell: ULONG,
    pub __bindgen_anon_1: _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x50 (80)"]
    pub UserFlags: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub LastWriteTime: _LARGE_INTEGER,
    #[doc = " offset: 0x50 (80)"]
    pub TxSecurityCell: ULONG,
    pub __bindgen_anon_2: _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x50 (80)"]
    pub OldValueCell: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub NewValueCell: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x50 (80)"]
    pub OldChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0x58 (88)"]
    pub NewChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
}
impl Default for _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x50 (80)"]
    pub OtherChildKCB: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0x58 (88)"]
    pub ThisVolatileKeyCell: ULONG,
}
impl Default for _CM_KCB_UOW__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KCB_UOW__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KCB_UOW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_INTENT_LOCK {
    #[doc = " offset: 0x0 (0)"]
    pub OwnerCount: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub OwnerTable: *mut *mut _CM_KCB_UOW,
}
impl Default for _CM_INTENT_LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x100 (256) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_KEY_CONTROL_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub RefCount: ULONG,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: _CM_KEY_CONTROL_BLOCK__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub ParentKcb: *mut _CM_KEY_CONTROL_BLOCK,
    #[doc = " offset: 0x30 (48)"]
    pub NameBlock: *mut _CM_NAME_CONTROL_BLOCK,
    #[doc = " offset: 0x38 (56)"]
    pub CachedSecurity: *mut _CM_KEY_SECURITY_CACHE,
    #[doc = " offset: 0x40 (64)"]
    pub ValueCache: _CACHED_CHILD_LIST,
    pub __bindgen_anon_2: _CM_KEY_CONTROL_BLOCK__bindgen_ty_2,
    pub __bindgen_anon_3: _CM_KEY_CONTROL_BLOCK__bindgen_ty_3,
    #[doc = " offset: 0x68 (104)"]
    pub KeyBodyArray: [*mut _CM_KEY_BODY; 4usize],
    #[doc = " offset: 0x88 (136)"]
    pub DelayCloseEntry: *mut VOID,
    #[doc = " offset: 0x90 (144)"]
    pub KcbLastWriteTime: _LARGE_INTEGER,
    #[doc = " offset: 0x98 (152)"]
    pub KcbMaxNameLen: USHORT,
    #[doc = " offset: 0x9a (154)"]
    pub KcbMaxValueNameLen: USHORT,
    #[doc = " offset: 0x9c (156)"]
    pub KcbMaxValueDataLen: ULONG,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0xa8 (168)"]
    pub RealKeyName: *mut CHAR,
    #[doc = " offset: 0xb0 (176)"]
    pub KCBUoWListHead: _LIST_ENTRY,
    #[doc = " offset: 0xc0 (192)"]
    pub TransKCBOwner: *mut _CM_TRANS,
    #[doc = " offset: 0xc8 (200)"]
    pub KCBLock: _CM_INTENT_LOCK,
    #[doc = " offset: 0xd8 (216)"]
    pub KeyLock: _CM_INTENT_LOCK,
    #[doc = " offset: 0xe8 (232)"]
    pub TransValueCache: _CHILD_LIST,
    #[doc = " offset: 0xf0 (240)"]
    pub TransValueListOwner: *mut _CM_TRANS,
    #[doc = " offset: 0xf8 (248)"]
    pub FullKCBName: *mut _UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub KeyHash: _CM_KEY_HASH,
    pub __bindgen_anon_1: _CM_KEY_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_KEY_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub ConvKey: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub NextHash: *mut _CM_KEY_HASH,
    #[doc = " offset: 0x18 (24)"]
    pub KeyHive: *mut _HHIVE,
    #[doc = " offset: 0x20 (32)"]
    pub KeyCell: ULONG,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_2 {
    #[doc = " offset: 0x50 (80)"]
    pub IndexHint: *mut _CM_INDEX_HINT_BLOCK,
    #[doc = " offset: 0x50 (80)"]
    pub HashKey: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub SubKeyCount: ULONG,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_KEY_CONTROL_BLOCK__bindgen_ty_3 {
    #[doc = " offset: 0x58 (88)"]
    pub KeyBodyListHead: _LIST_ENTRY,
    #[doc = " offset: 0x58 (88)"]
    pub FreeListEntry: _LIST_ENTRY,
}
impl Default for _CM_KEY_CONTROL_BLOCK__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CM_KEY_CONTROL_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CM_KEY_CONTROL_BLOCK {
    #[inline]
    pub fn ExtFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ExtFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn PrivateAlloc(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrivateAlloc(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Delete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Delete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DelayedCloseIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_DelayedCloseIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn TotalLevels(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_TotalLevels(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExtFlags: ULONG,
        PrivateAlloc: ULONG,
        Delete: ULONG,
        DelayedCloseIndex: ULONG,
        TotalLevels: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ExtFlags: u32 = unsafe { ::std::mem::transmute(ExtFlags) };
            ExtFlags as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PrivateAlloc: u32 = unsafe { ::std::mem::transmute(PrivateAlloc) };
            PrivateAlloc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Delete: u32 = unsafe { ::std::mem::transmute(Delete) };
            Delete as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let DelayedCloseIndex: u32 = unsafe { ::std::mem::transmute(DelayedCloseIndex) };
            DelayedCloseIndex as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let TotalLevels: u32 = unsafe { ::std::mem::transmute(TotalLevels) };
            TotalLevels as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn KcbUserFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_KcbUserFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn KcbVirtControlFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_KcbVirtControlFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn KcbDebug(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_KcbDebug(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Flags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        KcbUserFlags: ULONG,
        KcbVirtControlFlags: ULONG,
        KcbDebug: ULONG,
        Flags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let KcbUserFlags: u32 = unsafe { ::std::mem::transmute(KcbUserFlags) };
            KcbUserFlags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let KcbVirtControlFlags: u32 = unsafe { ::std::mem::transmute(KcbVirtControlFlags) };
            KcbVirtControlFlags as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let KcbDebug: u32 = unsafe { ::std::mem::transmute(KcbDebug) };
            KcbDebug as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Flags: u32 = unsafe { ::std::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x88 (136) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_RM {
    #[doc = " offset: 0x0 (0)"]
    pub RmListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub TransactionListHead: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub TmHandle: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub Tm: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub RmHandle: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub KtmRm: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub RefCount: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub ContainerNum: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub ContainerSize: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub CmHive: *mut _CMHIVE,
    #[doc = " offset: 0x58 (88)"]
    pub LogFileObject: *mut VOID,
    #[doc = " offset: 0x60 (96)"]
    pub MarshallingContext: *mut VOID,
    #[doc = " offset: 0x68 (104)"]
    pub RmFlags: ULONG,
    #[doc = " offset: 0x6c (108)"]
    pub LogStartStatus1: LONG,
    #[doc = " offset: 0x70 (112)"]
    pub LogStartStatus2: LONG,
    #[doc = " offset: 0x78 (120)"]
    pub BaseLsn: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub RmLock: *mut _ERESOURCE,
}
impl Default for _CM_RM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x58 (88) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CM_VIEW_OF_FILE {
    #[doc = " offset: 0x0 (0)"]
    pub MappedViewLinks: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub PinnedViewLinks: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub FlushedViewLinks: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub CmHive: *mut _CMHIVE,
    #[doc = " offset: 0x38 (56)"]
    pub Bcb: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub ViewAddress: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub FileOffset: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub Size: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub UseCount: ULONG,
}
impl Default for _CM_VIEW_OF_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HMAP_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub BlockAddress: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub BinAddress: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub CmView: *mut _CM_VIEW_OF_FILE,
    #[doc = " offset: 0x18 (24)"]
    pub MemAlloc: ULONG,
}
impl Default for _HMAP_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4000 (16384) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HMAP_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub Table: [_HMAP_ENTRY; 512usize],
}
impl Default for _HMAP_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x2000 (8192) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HMAP_DIRECTORY {
    #[doc = " offset: 0x0 (0)"]
    pub Directory: [*mut _HMAP_TABLE; 1024usize],
}
impl Default for _HMAP_DIRECTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMVAD_SHORT {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MMVAD_SHORT__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub LeftChild: *mut _MMVAD,
    #[doc = " offset: 0x10 (16)"]
    pub RightChild: *mut _MMVAD,
    #[doc = " offset: 0x18 (24)"]
    pub StartingVpn: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub EndingVpn: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub u: _MMVAD_SHORT__bindgen_ty_2,
    #[doc = " offset: 0x30 (48)"]
    pub PushLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x38 (56)"]
    pub u5: _MMVAD_SHORT__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_SHORT__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _MMVAD,
}
impl Default for _MMVAD_SHORT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMVAD_SHORT__bindgen_ty_1 {
    #[inline]
    pub fn Balance(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Balance: LONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Balance: u64 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_SHORT__bindgen_ty_2 {
    #[doc = " offset: 0x28 (40)"]
    pub LongFlags: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub VadFlags: _MMVAD_FLAGS,
}
impl Default for _MMVAD_SHORT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD_SHORT__bindgen_ty_3 {
    #[doc = " offset: 0x38 (56)"]
    pub LongFlags3: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub VadFlags3: _MMVAD_FLAGS3,
}
impl Default for _MMVAD_SHORT__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMVAD_SHORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMVAD {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _MMVAD__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub LeftChild: *mut _MMVAD,
    #[doc = " offset: 0x10 (16)"]
    pub RightChild: *mut _MMVAD,
    #[doc = " offset: 0x18 (24)"]
    pub StartingVpn: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub EndingVpn: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub u: _MMVAD__bindgen_ty_2,
    #[doc = " offset: 0x30 (48)"]
    pub PushLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x38 (56)"]
    pub u5: _MMVAD__bindgen_ty_3,
    #[doc = " offset: 0x40 (64)"]
    pub u2: _MMVAD__bindgen_ty_4,
    pub __bindgen_anon_1: _MMVAD__bindgen_ty_5,
    #[doc = " offset: 0x50 (80)"]
    pub FirstPrototypePte: *mut _MMPTE,
    #[doc = " offset: 0x58 (88)"]
    pub LastContiguousPte: *mut _MMPTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " offset: 0x0 (0)"]
    pub Parent: *mut _MMVAD,
}
impl Default for _MMVAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMVAD__bindgen_ty_1 {
    #[inline]
    pub fn Balance(&self) -> LONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: LONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Balance: LONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Balance: u64 = unsafe { ::std::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD__bindgen_ty_2 {
    #[doc = " offset: 0x28 (40)"]
    pub LongFlags: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub VadFlags: _MMVAD_FLAGS,
}
impl Default for _MMVAD__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD__bindgen_ty_3 {
    #[doc = " offset: 0x38 (56)"]
    pub LongFlags3: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub VadFlags3: _MMVAD_FLAGS3,
}
impl Default for _MMVAD__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD__bindgen_ty_4 {
    #[doc = " offset: 0x40 (64)"]
    pub LongFlags2: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub VadFlags2: _MMVAD_FLAGS2,
}
impl Default for _MMVAD__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMVAD__bindgen_ty_5 {
    #[doc = " offset: 0x48 (72)"]
    pub Subsection: *mut _SUBSECTION,
    #[doc = " offset: 0x48 (72)"]
    pub MappedSubsection: *mut _MSUBSECTION,
}
impl Default for _MMVAD__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMVAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x150 (336) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_DIRECTORY {
    #[doc = " offset: 0x0 (0)"]
    pub HashBuckets: [*mut _OBJECT_DIRECTORY_ENTRY; 37usize],
    #[doc = " offset: 0x128 (296)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x130 (304)"]
    pub DeviceMap: *mut _DEVICE_MAP,
    #[doc = " offset: 0x138 (312)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0x140 (320)"]
    pub NamespaceEntry: *mut VOID,
    #[doc = " offset: 0x148 (328)"]
    pub Flags: ULONG,
}
impl Default for _OBJECT_DIRECTORY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBP_LOOKUP_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Directory: *mut _OBJECT_DIRECTORY,
    #[doc = " offset: 0x8 (8)"]
    pub Object: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub HashValue: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub HashIndex: USHORT,
    #[doc = " offset: 0x16 (22)"]
    pub DirectoryLocked: UCHAR,
    #[doc = " offset: 0x18 (24)"]
    pub LockStateSignature: ULONG,
}
impl Default for _OBP_LOOKUP_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVICE_MAP {
    #[doc = " offset: 0x0 (0)"]
    pub DosDevicesDirectory: *mut _OBJECT_DIRECTORY,
    #[doc = " offset: 0x8 (8)"]
    pub GlobalDosDevicesDirectory: *mut _OBJECT_DIRECTORY,
    #[doc = " offset: 0x10 (16)"]
    pub DosDevicesDirectoryHandle: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub ReferenceCount: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub DriveMap: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub DriveType: [UCHAR; 32usize],
}
impl Default for _DEVICE_MAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_HEADER_NAME_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub Directory: *mut _OBJECT_DIRECTORY,
    #[doc = " offset: 0x8 (8)"]
    pub Name: _UNICODE_STRING,
    #[doc = " offset: 0x18 (24)"]
    pub QueryReferences: ULONG,
}
impl Default for _OBJECT_HEADER_NAME_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1b0 (432) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EJOB {
    #[doc = " offset: 0x0 (0)"]
    pub Event: _KEVENT,
    #[doc = " offset: 0x18 (24)"]
    pub JobLinks: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub ProcessListHead: _LIST_ENTRY,
    #[doc = " offset: 0x38 (56)"]
    pub JobLock: _ERESOURCE,
    #[doc = " offset: 0xa0 (160)"]
    pub TotalUserTime: _LARGE_INTEGER,
    #[doc = " offset: 0xa8 (168)"]
    pub TotalKernelTime: _LARGE_INTEGER,
    #[doc = " offset: 0xb0 (176)"]
    pub ThisPeriodTotalUserTime: _LARGE_INTEGER,
    #[doc = " offset: 0xb8 (184)"]
    pub ThisPeriodTotalKernelTime: _LARGE_INTEGER,
    #[doc = " offset: 0xc0 (192)"]
    pub TotalPageFaultCount: ULONG,
    #[doc = " offset: 0xc4 (196)"]
    pub TotalProcesses: ULONG,
    #[doc = " offset: 0xc8 (200)"]
    pub ActiveProcesses: ULONG,
    #[doc = " offset: 0xcc (204)"]
    pub TotalTerminatedProcesses: ULONG,
    #[doc = " offset: 0xd0 (208)"]
    pub PerProcessUserTimeLimit: _LARGE_INTEGER,
    #[doc = " offset: 0xd8 (216)"]
    pub PerJobUserTimeLimit: _LARGE_INTEGER,
    #[doc = " offset: 0xe0 (224)"]
    pub LimitFlags: ULONG,
    #[doc = " offset: 0xe8 (232)"]
    pub MinimumWorkingSetSize: ULONGLONG,
    #[doc = " offset: 0xf0 (240)"]
    pub MaximumWorkingSetSize: ULONGLONG,
    #[doc = " offset: 0xf8 (248)"]
    pub ActiveProcessLimit: ULONG,
    #[doc = " offset: 0x100 (256)"]
    pub Affinity: ULONGLONG,
    #[doc = " offset: 0x108 (264)"]
    pub PriorityClass: UCHAR,
    #[doc = " offset: 0x110 (272)"]
    pub AccessState: *mut _JOB_ACCESS_STATE,
    #[doc = " offset: 0x118 (280)"]
    pub UIRestrictionsClass: ULONG,
    #[doc = " offset: 0x11c (284)"]
    pub EndOfJobTimeAction: ULONG,
    #[doc = " offset: 0x120 (288)"]
    pub CompletionPort: *mut VOID,
    #[doc = " offset: 0x128 (296)"]
    pub CompletionKey: *mut VOID,
    #[doc = " offset: 0x130 (304)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0x134 (308)"]
    pub SchedulingClass: ULONG,
    #[doc = " offset: 0x138 (312)"]
    pub ReadOperationCount: ULONGLONG,
    #[doc = " offset: 0x140 (320)"]
    pub WriteOperationCount: ULONGLONG,
    #[doc = " offset: 0x148 (328)"]
    pub OtherOperationCount: ULONGLONG,
    #[doc = " offset: 0x150 (336)"]
    pub ReadTransferCount: ULONGLONG,
    #[doc = " offset: 0x158 (344)"]
    pub WriteTransferCount: ULONGLONG,
    #[doc = " offset: 0x160 (352)"]
    pub OtherTransferCount: ULONGLONG,
    #[doc = " offset: 0x168 (360)"]
    pub ProcessMemoryLimit: ULONGLONG,
    #[doc = " offset: 0x170 (368)"]
    pub JobMemoryLimit: ULONGLONG,
    #[doc = " offset: 0x178 (376)"]
    pub PeakProcessMemoryUsed: ULONGLONG,
    #[doc = " offset: 0x180 (384)"]
    pub PeakJobMemoryUsed: ULONGLONG,
    #[doc = " offset: 0x188 (392)"]
    pub CurrentJobMemoryUsed: ULONGLONG,
    #[doc = " offset: 0x190 (400)"]
    pub MemoryLimitsLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x198 (408)"]
    pub JobSetLinks: _LIST_ENTRY,
    #[doc = " offset: 0x1a8 (424)"]
    pub MemberLevel: ULONG,
    #[doc = " offset: 0x1ac (428)"]
    pub JobFlags: ULONG,
}
impl Default for _EJOB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_PROCESS_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x8 (8)"]
    pub ViewListHead: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub PagedPoolQuotaCache: ULONGLONG,
}
impl Default for _ALPC_PROCESS_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMSUPPORT {
    #[doc = " offset: 0x0 (0)"]
    pub WorkingSetExpansionLinks: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub LastTrimStamp: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub NextPageColor: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub Flags: _MMSUPPORT_FLAGS,
    #[doc = " offset: 0x18 (24)"]
    pub PageFaultCount: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub PeakWorkingSetSize: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub ChargedWslePages: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub MinimumWorkingSetSize: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub MaximumWorkingSetSize: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub VmWorkingSetList: *mut _MMWSL,
    #[doc = " offset: 0x38 (56)"]
    pub Claim: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub ActualWslePages: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub WorkingSetPrivateSize: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub WorkingSetSizeOverhead: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub WorkingSetSize: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub ExitGate: *mut _KGATE,
    #[doc = " offset: 0x58 (88)"]
    pub WorkingSetMutex: _EX_PUSH_LOCK,
    #[doc = " offset: 0x60 (96)"]
    pub AccessLog: *mut VOID,
}
impl Default for _MMSUPPORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MI_SYSTEM_PTE_TYPE {
    #[doc = " offset: 0x0 (0)"]
    pub Bitmap: _RTL_BITMAP,
    #[doc = " offset: 0x10 (16)"]
    pub Hint: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub BasePte: *mut _MMPTE,
    #[doc = " offset: 0x20 (32)"]
    pub FailureCount: *mut ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub Vm: *mut _MMSUPPORT,
    #[doc = " offset: 0x30 (48)"]
    pub TotalSystemPtes: LONG,
    #[doc = " offset: 0x34 (52)"]
    pub TotalFreeSystemPtes: LONG,
    #[doc = " offset: 0x38 (56)"]
    pub CachedPteCount: LONG,
    #[doc = " offset: 0x3c (60)"]
    pub PteFailures: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub GlobalMutex: *mut _KGUARDED_MUTEX,
}
impl Default for _MI_SYSTEM_PTE_TYPE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x100 (256) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EX_PUSH_LOCK_CACHE_AWARE {
    #[doc = " offset: 0x0 (0)"]
    pub Locks: [*mut _EX_PUSH_LOCK; 32usize],
}
impl Default for _EX_PUSH_LOCK_CACHE_AWARE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    #[doc = " offset: 0x0 (0)"]
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub HighPart: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub LowPart: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub HighPart: ULONG,
}
impl Default for _ULARGE_INTEGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KERNEL_STACK_SEGMENT {
    #[doc = " offset: 0x0 (0)"]
    pub StackBase: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub StackLimit: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub KernelStack: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub InitialStack: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub ActualLimit: ULONGLONG,
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PPM_PERF_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub Frequency: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Power: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PercentFrequency: UCHAR,
    #[doc = " offset: 0x9 (9)"]
    pub IncreaseLevel: UCHAR,
    #[doc = " offset: 0xa (10)"]
    pub DecreaseLevel: UCHAR,
    #[doc = " offset: 0xb (11)"]
    pub Type: UCHAR,
    #[doc = " offset: 0x10 (16)"]
    pub Control: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Status: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub TotalHitCount: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub DesiredCount: ULONG,
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PPM_IDLE_STATE_ACCOUNTING {
    #[doc = " offset: 0x0 (0)"]
    pub IdleTransitions: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub FailedTransitions: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub InvalidBucketIndex: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub TotalTime: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub IdleTimeBuckets: [ULONG; 6usize],
}
#[doc = " 0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPROCESS {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = " offset: 0x18 (24)"]
    pub ProfileListHead: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub DirectoryTableBase: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub Unused0: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub IopmOffset: USHORT,
    #[doc = " offset: 0x40 (64)"]
    pub ActiveProcessors: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub KernelTime: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub UserTime: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub ReadyListHead: _LIST_ENTRY,
    #[doc = " offset: 0x60 (96)"]
    pub SwapListEntry: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x68 (104)"]
    pub InstrumentationCallback: *mut VOID,
    #[doc = " offset: 0x70 (112)"]
    pub ThreadListHead: _LIST_ENTRY,
    #[doc = " offset: 0x80 (128)"]
    pub ProcessLock: ULONGLONG,
    #[doc = " offset: 0x88 (136)"]
    pub Affinity: ULONGLONG,
    pub __bindgen_anon_1: _KPROCESS__bindgen_ty_1,
    #[doc = " offset: 0x94 (148)"]
    pub BasePriority: CHAR,
    #[doc = " offset: 0x95 (149)"]
    pub QuantumReset: CHAR,
    #[doc = " offset: 0x96 (150)"]
    pub State: UCHAR,
    #[doc = " offset: 0x97 (151)"]
    pub ThreadSeed: UCHAR,
    #[doc = " offset: 0x98 (152)"]
    pub PowerState: UCHAR,
    #[doc = " offset: 0x99 (153)"]
    pub IdealNode: UCHAR,
    #[doc = " offset: 0x9a (154)"]
    pub Visited: UCHAR,
    pub __bindgen_anon_2: _KPROCESS__bindgen_ty_2,
    #[doc = " offset: 0xa0 (160)"]
    pub StackCount: ULONGLONG,
    #[doc = " offset: 0xa8 (168)"]
    pub ProcessListEntry: _LIST_ENTRY,
    #[doc = " offset: 0xb8 (184)"]
    pub CycleTime: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPROCESS__bindgen_ty_1 {
    pub __bindgen_anon_1: _KPROCESS__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x90 (144)"]
    pub ProcessFlags: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KPROCESS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KPROCESS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AutoAlignment(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoAlignment(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableBoost(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableBoost(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableQuantum(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableQuantum(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> LONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: LONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AutoAlignment: LONG,
        DisableBoost: LONG,
        DisableQuantum: LONG,
        ReservedFlags: LONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AutoAlignment: u32 = unsafe { ::std::mem::transmute(AutoAlignment) };
            AutoAlignment as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableBoost: u32 = unsafe { ::std::mem::transmute(DisableBoost) };
            DisableBoost as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisableQuantum: u32 = unsafe { ::std::mem::transmute(DisableQuantum) };
            DisableQuantum as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KPROCESS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPROCESS__bindgen_ty_2 {
    #[doc = " offset: 0x9b (155)"]
    pub Flags: _KEXECUTE_OPTIONS,
    #[doc = " offset: 0x9b (155)"]
    pub ExecuteOptions: UCHAR,
}
impl Default for _KPROCESS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPROCESS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KAPC_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub ApcListHead: [_LIST_ENTRY; 2usize],
    #[doc = " offset: 0x20 (32)"]
    pub Process: *mut _KPROCESS,
    #[doc = " offset: 0x28 (40)"]
    pub KernelApcInProgress: UCHAR,
    #[doc = " offset: 0x29 (41)"]
    pub KernelApcPending: UCHAR,
    #[doc = " offset: 0x2a (42)"]
    pub UserApcPending: UCHAR,
}
impl Default for _KAPC_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x98 (152) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PPM_PERF_STATES {
    #[doc = " offset: 0x0 (0)"]
    pub Count: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub MaxFrequency: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub PStateCap: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub TStateCap: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub MaxPerfState: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub MinPerfState: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub LowestPState: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub IncreaseTime: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub DecreaseTime: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub BusyAdjThreshold: UCHAR,
    #[doc = " offset: 0x25 (37)"]
    pub Reserved: UCHAR,
    #[doc = " offset: 0x26 (38)"]
    pub ThrottleStatesOnly: UCHAR,
    #[doc = " offset: 0x27 (39)"]
    pub PolicyType: UCHAR,
    #[doc = " offset: 0x28 (40)"]
    pub TimerInterval: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub Flags: _PPM_PERF_STATES__bindgen_ty_1,
    #[doc = " offset: 0x30 (48)"]
    pub TargetProcessors: ULONGLONG,
    pub PStateHandler: ::std::option::Option<
        unsafe extern "C" fn(arg1: ULONGLONG, arg2: ULONGLONG, arg3: ULONGLONG) -> LONG,
    >,
    #[doc = " offset: 0x40 (64)"]
    pub PStateContext: ULONGLONG,
    pub TStateHandler: ::std::option::Option<
        unsafe extern "C" fn(arg1: ULONGLONG, arg2: ULONGLONG, arg3: ULONGLONG) -> LONG,
    >,
    #[doc = " offset: 0x50 (80)"]
    pub TStateContext: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub FeedbackHandler: ::std::option::Option<unsafe extern "C" fn(arg1: UCHAR) -> ULONG>,
    #[doc = " offset: 0x60 (96)"]
    pub DiaStats: *mut _PPM_DIA_STATS,
    #[doc = " offset: 0x68 (104)"]
    pub DiaStatsCount: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub State: [_PPM_PERF_STATE; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PPM_PERF_STATES__bindgen_ty_1 {
    #[doc = " offset: 0x2c (44)"]
    pub AsULONG: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PPM_PERF_STATES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PPM_PERF_STATES__bindgen_ty_1 {
    #[inline]
    pub fn UsingHypervisor(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UsingHypervisor(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDomainAccounting(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDomainAccounting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IncreasePolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IncreasePolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DecreasePolicy(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DecreasePolicy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UsingHypervisor: ULONG,
        NoDomainAccounting: ULONG,
        IncreasePolicy: ULONG,
        DecreasePolicy: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UsingHypervisor: u32 = unsafe { ::std::mem::transmute(UsingHypervisor) };
            UsingHypervisor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoDomainAccounting: u32 = unsafe { ::std::mem::transmute(NoDomainAccounting) };
            NoDomainAccounting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let IncreasePolicy: u32 = unsafe { ::std::mem::transmute(IncreasePolicy) };
            IncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let DecreasePolicy: u32 = unsafe { ::std::mem::transmute(DecreasePolicy) };
            DecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PPM_PERF_STATES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PPM_IDLE_ACCOUNTING {
    #[doc = " offset: 0x0 (0)"]
    pub StateCount: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub TotalTransitions: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ResetCount: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub StartTime: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub State: [PPM_IDLE_STATE_ACCOUNTING; 1usize],
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PPM_IDLE_STATES {
    #[doc = " offset: 0x0 (0)"]
    pub Type: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Count: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Flags: _PPM_IDLE_STATES__bindgen_ty_1,
    #[doc = " offset: 0xc (12)"]
    pub TargetState: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ActualState: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub OldState: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub TargetProcessors: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub State: [_PPM_IDLE_STATE; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PPM_IDLE_STATES__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub AsULONG: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PPM_IDLE_STATES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PPM_IDLE_STATES__bindgen_ty_1 {
    #[inline]
    pub fn AllowScaling(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowScaling(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Disabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Hypervisor(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Hypervisor(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn HvMaxCState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_HvMaxCState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowScaling: ULONG,
        Disabled: ULONG,
        Hypervisor: ULONG,
        HvMaxCState: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowScaling: u32 = unsafe { ::std::mem::transmute(AllowScaling) };
            AllowScaling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Disabled: u32 = unsafe { ::std::mem::transmute(Disabled) };
            Disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let Hypervisor: u32 = unsafe { ::std::mem::transmute(Hypervisor) };
            Hypervisor as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let HvMaxCState: u32 = unsafe { ::std::mem::transmute(HvMaxCState) };
            HvMaxCState as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PPM_IDLE_STATES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KSPIN_LOCK_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _KSPIN_LOCK_QUEUE,
    #[doc = " offset: 0x8 (8)"]
    pub Lock: *mut ULONGLONG,
}
impl Default for _KSPIN_LOCK_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KLOCK_QUEUE_HANDLE {
    #[doc = " offset: 0x0 (0)"]
    pub LockQueue: _KSPIN_LOCK_QUEUE,
    #[doc = " offset: 0x10 (16)"]
    pub OldIrql: UCHAR,
}
impl Default for _KLOCK_QUEUE_HANDLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _M128A {
    #[doc = " offset: 0x0 (0)"]
    pub Low: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub High: LONGLONG,
}
#[doc = " 0x140 (320) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KEXCEPTION_FRAME {
    #[doc = " offset: 0x0 (0)"]
    pub P1Home: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub P2Home: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub P3Home: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub P4Home: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub P5: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub InitialStack: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub Xmm6: _M128A,
    #[doc = " offset: 0x40 (64)"]
    pub Xmm7: _M128A,
    #[doc = " offset: 0x50 (80)"]
    pub Xmm8: _M128A,
    #[doc = " offset: 0x60 (96)"]
    pub Xmm9: _M128A,
    #[doc = " offset: 0x70 (112)"]
    pub Xmm10: _M128A,
    #[doc = " offset: 0x80 (128)"]
    pub Xmm11: _M128A,
    #[doc = " offset: 0x90 (144)"]
    pub Xmm12: _M128A,
    #[doc = " offset: 0xa0 (160)"]
    pub Xmm13: _M128A,
    #[doc = " offset: 0xb0 (176)"]
    pub Xmm14: _M128A,
    #[doc = " offset: 0xc0 (192)"]
    pub Xmm15: _M128A,
    #[doc = " offset: 0xd0 (208)"]
    pub TrapFrame: ULONGLONG,
    #[doc = " offset: 0xd8 (216)"]
    pub CallbackStack: ULONGLONG,
    #[doc = " offset: 0xe0 (224)"]
    pub OutputBuffer: ULONGLONG,
    #[doc = " offset: 0xe8 (232)"]
    pub OutputLength: ULONGLONG,
    #[doc = " offset: 0xf0 (240)"]
    pub MxCsr: ULONGLONG,
    #[doc = " offset: 0xf8 (248)"]
    pub Rbp: ULONGLONG,
    #[doc = " offset: 0x100 (256)"]
    pub Rbx: ULONGLONG,
    #[doc = " offset: 0x108 (264)"]
    pub Rdi: ULONGLONG,
    #[doc = " offset: 0x110 (272)"]
    pub Rsi: ULONGLONG,
    #[doc = " offset: 0x118 (280)"]
    pub R12: ULONGLONG,
    #[doc = " offset: 0x120 (288)"]
    pub R13: ULONGLONG,
    #[doc = " offset: 0x128 (296)"]
    pub R14: ULONGLONG,
    #[doc = " offset: 0x130 (304)"]
    pub R15: ULONGLONG,
    #[doc = " offset: 0x138 (312)"]
    pub Return: ULONGLONG,
}
#[doc = " 0x190 (400) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTRAP_FRAME {
    #[doc = " offset: 0x0 (0)"]
    pub P1Home: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub P2Home: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub P3Home: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub P4Home: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub P5: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub PreviousMode: CHAR,
    #[doc = " offset: 0x29 (41)"]
    pub PreviousIrql: UCHAR,
    #[doc = " offset: 0x2a (42)"]
    pub FaultIndicator: UCHAR,
    #[doc = " offset: 0x2b (43)"]
    pub ExceptionActive: UCHAR,
    #[doc = " offset: 0x2c (44)"]
    pub MxCsr: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub Rax: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub Rcx: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub Rdx: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub R8: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub R9: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub R10: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub R11: ULONGLONG,
    pub __bindgen_anon_1: _KTRAP_FRAME__bindgen_ty_1,
    #[doc = " offset: 0x70 (112)"]
    pub Xmm0: _M128A,
    #[doc = " offset: 0x80 (128)"]
    pub Xmm1: _M128A,
    #[doc = " offset: 0x90 (144)"]
    pub Xmm2: _M128A,
    #[doc = " offset: 0xa0 (160)"]
    pub Xmm3: _M128A,
    #[doc = " offset: 0xb0 (176)"]
    pub Xmm4: _M128A,
    #[doc = " offset: 0xc0 (192)"]
    pub Xmm5: _M128A,
    pub __bindgen_anon_2: _KTRAP_FRAME__bindgen_ty_2,
    #[doc = " offset: 0xd8 (216)"]
    pub Dr0: ULONGLONG,
    #[doc = " offset: 0xe0 (224)"]
    pub Dr1: ULONGLONG,
    #[doc = " offset: 0xe8 (232)"]
    pub Dr2: ULONGLONG,
    #[doc = " offset: 0xf0 (240)"]
    pub Dr3: ULONGLONG,
    #[doc = " offset: 0xf8 (248)"]
    pub Dr6: ULONGLONG,
    #[doc = " offset: 0x100 (256)"]
    pub Dr7: ULONGLONG,
    pub __bindgen_anon_3: _KTRAP_FRAME__bindgen_ty_3,
    #[doc = " offset: 0x130 (304)"]
    pub SegDs: USHORT,
    #[doc = " offset: 0x132 (306)"]
    pub SegEs: USHORT,
    #[doc = " offset: 0x134 (308)"]
    pub SegFs: USHORT,
    #[doc = " offset: 0x136 (310)"]
    pub SegGs: USHORT,
    #[doc = " offset: 0x138 (312)"]
    pub TrapFrame: ULONGLONG,
    #[doc = " offset: 0x140 (320)"]
    pub Rbx: ULONGLONG,
    #[doc = " offset: 0x148 (328)"]
    pub Rdi: ULONGLONG,
    #[doc = " offset: 0x150 (336)"]
    pub Rsi: ULONGLONG,
    #[doc = " offset: 0x158 (344)"]
    pub Rbp: ULONGLONG,
    pub __bindgen_anon_4: _KTRAP_FRAME__bindgen_ty_4,
    #[doc = " offset: 0x168 (360)"]
    pub Rip: ULONGLONG,
    #[doc = " offset: 0x170 (368)"]
    pub SegCs: USHORT,
    #[doc = " offset: 0x172 (370)"]
    pub Fill0: UCHAR,
    #[doc = " offset: 0x173 (371)"]
    pub Logging: UCHAR,
    #[doc = " offset: 0x174 (372)"]
    pub Fill1: [USHORT; 2usize],
    #[doc = " offset: 0x178 (376)"]
    pub EFlags: ULONG,
    #[doc = " offset: 0x17c (380)"]
    pub Fill2: ULONG,
    #[doc = " offset: 0x180 (384)"]
    pub Rsp: ULONGLONG,
    #[doc = " offset: 0x188 (392)"]
    pub SegSs: USHORT,
    #[doc = " offset: 0x18a (394)"]
    pub Fill3: USHORT,
    #[doc = " offset: 0x18c (396)"]
    pub CodePatchCycle: LONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_1 {
    #[doc = " offset: 0x68 (104)"]
    pub GsBase: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub GsSwap: ULONGLONG,
}
impl Default for _KTRAP_FRAME__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_2 {
    #[doc = " offset: 0xd0 (208)"]
    pub FaultAddress: ULONGLONG,
    #[doc = " offset: 0xd0 (208)"]
    pub ContextRecord: ULONGLONG,
    #[doc = " offset: 0xd0 (208)"]
    pub TimeStampCKCL: ULONGLONG,
}
impl Default for _KTRAP_FRAME__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_3 {
    pub __bindgen_anon_1: _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2: _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_1 {
    #[doc = " offset: 0x108 (264)"]
    pub DebugControl: ULONGLONG,
    #[doc = " offset: 0x110 (272)"]
    pub LastBranchToRip: ULONGLONG,
    #[doc = " offset: 0x118 (280)"]
    pub LastBranchFromRip: ULONGLONG,
    #[doc = " offset: 0x120 (288)"]
    pub LastExceptionToRip: ULONGLONG,
    #[doc = " offset: 0x128 (296)"]
    pub LastExceptionFromRip: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_2 {
    #[doc = " offset: 0x108 (264)"]
    pub LastBranchControl: ULONGLONG,
    #[doc = " offset: 0x110 (272)"]
    pub LastBranchMSR: ULONG,
}
impl Default for _KTRAP_FRAME__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_4 {
    #[doc = " offset: 0x160 (352)"]
    pub ErrorCode: ULONGLONG,
    #[doc = " offset: 0x160 (352)"]
    pub ExceptionFrame: ULONGLONG,
    #[doc = " offset: 0x160 (352)"]
    pub TimeStampKlog: ULONGLONG,
}
impl Default for _KTRAP_FRAME__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTRAP_FRAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x200 (512) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _XMM_SAVE_AREA32 {
    #[doc = " offset: 0x0 (0)"]
    pub ControlWord: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub StatusWord: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub TagWord: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub Reserved1: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub ErrorOpcode: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub ErrorOffset: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ErrorSelector: USHORT,
    #[doc = " offset: 0xe (14)"]
    pub Reserved2: USHORT,
    #[doc = " offset: 0x10 (16)"]
    pub DataOffset: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub DataSelector: USHORT,
    #[doc = " offset: 0x16 (22)"]
    pub Reserved3: USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub MxCsr: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub MxCsr_Mask: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub FloatRegisters: [_M128A; 8usize],
    #[doc = " offset: 0xa0 (160)"]
    pub XmmRegisters: [_M128A; 16usize],
    #[doc = " offset: 0x1a0 (416)"]
    pub Reserved4: [UCHAR; 96usize],
}
impl Default for _XMM_SAVE_AREA32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x250 (592) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KERNEL_STACK_CONTROL {
    #[doc = " offset: 0x0 (0)"]
    pub XmmSaveArea: _XMM_SAVE_AREA32,
    #[doc = " offset: 0x200 (512)"]
    pub Current: _KERNEL_STACK_SEGMENT,
    #[doc = " offset: 0x228 (552)"]
    pub Previous: _KERNEL_STACK_SEGMENT,
}
impl Default for _KERNEL_STACK_CONTROL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Header8: _SLIST_HEADER__bindgen_ty_2,
    #[doc = " offset: 0x0 (0)"]
    pub Header16: _SLIST_HEADER__bindgen_ty_3,
    #[doc = " offset: 0x0 (0)"]
    pub HeaderX64: _SLIST_HEADER__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Alignment: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Region: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_2 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 39u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 39u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HeaderType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Init(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Init(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub fn Region(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(125usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Region(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(125usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        NextEntry: ULONGLONG,
        HeaderType: ULONGLONG,
        Init: ULONGLONG,
        Reserved: ULONGLONG,
        Region: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(25usize, 39u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let HeaderType: u64 = unsafe { ::std::mem::transmute(HeaderType) };
            HeaderType as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let Init: u64 = unsafe { ::std::mem::transmute(Init) };
            Init as u64
        });
        __bindgen_bitfield_unit.set(66usize, 59u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(125usize, 3u8, {
            let Region: u64 = unsafe { ::std::mem::transmute(Region) };
            Region as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SLIST_HEADER__bindgen_ty_3 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_3 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HeaderType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Init(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Init(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        HeaderType: ULONGLONG,
        Init: ULONGLONG,
        Reserved: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let HeaderType: u64 = unsafe { ::std::mem::transmute(HeaderType) };
            HeaderType as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let Init: u64 = unsafe { ::std::mem::transmute(Init) };
            Init as u64
        });
        __bindgen_bitfield_unit.set(66usize, 2u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(68usize, 60u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SLIST_HEADER__bindgen_ty_4 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_4 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HeaderType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        HeaderType: ULONGLONG,
        Reserved: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let HeaderType: u64 = unsafe { ::std::mem::transmute(HeaderType) };
            HeaderType as u64
        });
        __bindgen_bitfield_unit.set(65usize, 3u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(68usize, 60u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _SLIST_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KDPC_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub DpcListHead: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub DpcLock: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub DpcQueueDepth: LONG,
    #[doc = " offset: 0x1c (28)"]
    pub DpcCount: ULONG,
}
impl Default for _KDPC_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x4d0 (1232) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub P1Home: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub P2Home: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub P3Home: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub P4Home: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub P5Home: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub P6Home: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub ContextFlags: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub MxCsr: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub SegCs: USHORT,
    #[doc = " offset: 0x3a (58)"]
    pub SegDs: USHORT,
    #[doc = " offset: 0x3c (60)"]
    pub SegEs: USHORT,
    #[doc = " offset: 0x3e (62)"]
    pub SegFs: USHORT,
    #[doc = " offset: 0x40 (64)"]
    pub SegGs: USHORT,
    #[doc = " offset: 0x42 (66)"]
    pub SegSs: USHORT,
    #[doc = " offset: 0x44 (68)"]
    pub EFlags: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub Dr0: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub Dr1: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub Dr2: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub Dr3: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub Dr6: ULONGLONG,
    #[doc = " offset: 0x70 (112)"]
    pub Dr7: ULONGLONG,
    #[doc = " offset: 0x78 (120)"]
    pub Rax: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub Rcx: ULONGLONG,
    #[doc = " offset: 0x88 (136)"]
    pub Rdx: ULONGLONG,
    #[doc = " offset: 0x90 (144)"]
    pub Rbx: ULONGLONG,
    #[doc = " offset: 0x98 (152)"]
    pub Rsp: ULONGLONG,
    #[doc = " offset: 0xa0 (160)"]
    pub Rbp: ULONGLONG,
    #[doc = " offset: 0xa8 (168)"]
    pub Rsi: ULONGLONG,
    #[doc = " offset: 0xb0 (176)"]
    pub Rdi: ULONGLONG,
    #[doc = " offset: 0xb8 (184)"]
    pub R8: ULONGLONG,
    #[doc = " offset: 0xc0 (192)"]
    pub R9: ULONGLONG,
    #[doc = " offset: 0xc8 (200)"]
    pub R10: ULONGLONG,
    #[doc = " offset: 0xd0 (208)"]
    pub R11: ULONGLONG,
    #[doc = " offset: 0xd8 (216)"]
    pub R12: ULONGLONG,
    #[doc = " offset: 0xe0 (224)"]
    pub R13: ULONGLONG,
    #[doc = " offset: 0xe8 (232)"]
    pub R14: ULONGLONG,
    #[doc = " offset: 0xf0 (240)"]
    pub R15: ULONGLONG,
    #[doc = " offset: 0xf8 (248)"]
    pub Rip: ULONGLONG,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
    #[doc = " offset: 0x300 (768)"]
    pub VectorRegister: [_M128A; 26usize],
    #[doc = " offset: 0x4a0 (1184)"]
    pub VectorControl: ULONGLONG,
    #[doc = " offset: 0x4a8 (1192)"]
    pub DebugControl: ULONGLONG,
    #[doc = " offset: 0x4b0 (1200)"]
    pub LastBranchToRip: ULONGLONG,
    #[doc = " offset: 0x4b8 (1208)"]
    pub LastBranchFromRip: ULONGLONG,
    #[doc = " offset: 0x4c0 (1216)"]
    pub LastExceptionToRip: ULONGLONG,
    #[doc = " offset: 0x4c8 (1224)"]
    pub LastExceptionFromRip: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
    #[doc = " offset: 0x100 (256)"]
    pub FltSave: _XMM_SAVE_AREA32,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x100 (256)"]
    pub Header: [_M128A; 2usize],
    #[doc = " offset: 0x120 (288)"]
    pub Legacy: [_M128A; 8usize],
    #[doc = " offset: 0x1a0 (416)"]
    pub Xmm0: _M128A,
    #[doc = " offset: 0x1b0 (432)"]
    pub Xmm1: _M128A,
    #[doc = " offset: 0x1c0 (448)"]
    pub Xmm2: _M128A,
    #[doc = " offset: 0x1d0 (464)"]
    pub Xmm3: _M128A,
    #[doc = " offset: 0x1e0 (480)"]
    pub Xmm4: _M128A,
    #[doc = " offset: 0x1f0 (496)"]
    pub Xmm5: _M128A,
    #[doc = " offset: 0x200 (512)"]
    pub Xmm6: _M128A,
    #[doc = " offset: 0x210 (528)"]
    pub Xmm7: _M128A,
    #[doc = " offset: 0x220 (544)"]
    pub Xmm8: _M128A,
    #[doc = " offset: 0x230 (560)"]
    pub Xmm9: _M128A,
    #[doc = " offset: 0x240 (576)"]
    pub Xmm10: _M128A,
    #[doc = " offset: 0x250 (592)"]
    pub Xmm11: _M128A,
    #[doc = " offset: 0x260 (608)"]
    pub Xmm12: _M128A,
    #[doc = " offset: 0x270 (624)"]
    pub Xmm13: _M128A,
    #[doc = " offset: 0x280 (640)"]
    pub Xmm14: _M128A,
    #[doc = " offset: 0x290 (656)"]
    pub Xmm15: _M128A,
}
impl Default for _CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EXCEPTION_POINTERS {
    #[doc = " offset: 0x0 (0)"]
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    #[doc = " offset: 0x8 (8)"]
    pub ContextRecord: *mut _CONTEXT,
}
impl Default for _EXCEPTION_POINTERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub Handler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _EXCEPTION_RECORD,
            arg2: *mut VOID,
            arg3: *mut _CONTEXT,
            arg4: *mut VOID,
        ) -> _EXCEPTION_DISPOSITION,
    >,
}
impl Default for _EXCEPTION_REGISTRATION_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xd8 (216) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KSPECIAL_REGISTERS {
    #[doc = " offset: 0x0 (0)"]
    pub Cr0: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Cr2: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub Cr3: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Cr4: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub KernelDr0: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub KernelDr1: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub KernelDr2: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub KernelDr3: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub KernelDr6: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub KernelDr7: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub Gdtr: _KDESCRIPTOR,
    #[doc = " offset: 0x60 (96)"]
    pub Idtr: _KDESCRIPTOR,
    #[doc = " offset: 0x70 (112)"]
    pub Tr: USHORT,
    #[doc = " offset: 0x72 (114)"]
    pub Ldtr: USHORT,
    #[doc = " offset: 0x74 (116)"]
    pub MxCsr: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub DebugControl: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub LastBranchToRip: ULONGLONG,
    #[doc = " offset: 0x88 (136)"]
    pub LastBranchFromRip: ULONGLONG,
    #[doc = " offset: 0x90 (144)"]
    pub LastExceptionToRip: ULONGLONG,
    #[doc = " offset: 0x98 (152)"]
    pub LastExceptionFromRip: ULONGLONG,
    #[doc = " offset: 0xa0 (160)"]
    pub Cr8: ULONGLONG,
    #[doc = " offset: 0xa8 (168)"]
    pub MsrGsBase: ULONGLONG,
    #[doc = " offset: 0xb0 (176)"]
    pub MsrGsSwap: ULONGLONG,
    #[doc = " offset: 0xb8 (184)"]
    pub MsrStar: ULONGLONG,
    #[doc = " offset: 0xc0 (192)"]
    pub MsrLStar: ULONGLONG,
    #[doc = " offset: 0xc8 (200)"]
    pub MsrCStar: ULONGLONG,
    #[doc = " offset: 0xd0 (208)"]
    pub MsrSyscallMask: ULONGLONG,
}
impl Default for _KSPECIAL_REGISTERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x5b0 (1456) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPROCESSOR_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub SpecialRegisters: _KSPECIAL_REGISTERS,
    #[doc = " offset: 0xe0 (224)"]
    pub ContextFrame: _CONTEXT,
}
impl Default for _KPROCESSOR_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x698 (1688) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ARBITER_INSTANCE {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub MutexEvent: *mut _KEVENT,
    #[doc = " offset: 0x10 (16)"]
    pub Name: *mut USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub OrderingName: *mut USHORT,
    #[doc = " offset: 0x20 (32)"]
    pub ResourceType: LONG,
    #[doc = " offset: 0x28 (40)"]
    pub Allocation: *mut _RTL_RANGE_LIST,
    #[doc = " offset: 0x30 (48)"]
    pub PossibleAllocation: *mut _RTL_RANGE_LIST,
    #[doc = " offset: 0x38 (56)"]
    pub OrderingList: _ARBITER_ORDERING_LIST,
    #[doc = " offset: 0x48 (72)"]
    pub ReservedList: _ARBITER_ORDERING_LIST,
    #[doc = " offset: 0x58 (88)"]
    pub ReferenceCount: LONG,
    #[doc = " offset: 0x60 (96)"]
    pub Interface: *mut _ARBITER_INTERFACE,
    #[doc = " offset: 0x68 (104)"]
    pub AllocationStackMaxSize: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub AllocationStack: *mut _ARBITER_ALLOCATION_STATE,
    pub UnpackRequirement: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _IO_RESOURCE_DESCRIPTOR,
            arg2: *mut ULONGLONG,
            arg3: *mut ULONGLONG,
            arg4: *mut ULONGLONG,
            arg5: *mut ULONGLONG,
        ) -> LONG,
    >,
    pub PackResource: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _IO_RESOURCE_DESCRIPTOR,
            arg2: ULONGLONG,
            arg3: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
        ) -> LONG,
    >,
    pub UnpackResource: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
            arg2: *mut ULONGLONG,
            arg3: *mut ULONGLONG,
        ) -> LONG,
    >,
    pub ScoreRequirement:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _IO_RESOURCE_DESCRIPTOR) -> LONG>,
    pub TestAllocation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_TEST_ALLOCATION_PARAMETERS,
        ) -> LONG,
    >,
    pub RetestAllocation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_RETEST_ALLOCATION_PARAMETERS,
        ) -> LONG,
    >,
    pub CommitAllocation:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE) -> LONG>,
    pub RollbackAllocation:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE) -> LONG>,
    pub BootAllocation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_BOOT_ALLOCATION_PARAMETERS,
        ) -> LONG,
    >,
    pub QueryArbitrate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_QUERY_ARBITRATE_PARAMETERS,
        ) -> LONG,
    >,
    pub QueryConflict: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_QUERY_CONFLICT_PARAMETERS,
        ) -> LONG,
    >,
    pub AddReserved: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ADD_RESERVED_PARAMETERS,
        ) -> LONG,
    >,
    pub StartArbiter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE, arg2: *mut _CM_RESOURCE_LIST) -> LONG,
    >,
    pub PreprocessEntry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> LONG,
    >,
    pub AllocateEntry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> LONG,
    >,
    pub GetNextAllocationRange: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> UCHAR,
    >,
    pub FindSuitableRange: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> UCHAR,
    >,
    pub AddAllocation: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE, arg2: *mut _ARBITER_ALLOCATION_STATE),
    >,
    pub BacktrackAllocation: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _ARBITER_INSTANCE, arg2: *mut _ARBITER_ALLOCATION_STATE),
    >,
    pub OverrideConflict: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: *mut _ARBITER_ALLOCATION_STATE,
        ) -> UCHAR,
    >,
    pub InitializeRangeList: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _ARBITER_INSTANCE,
            arg2: ULONG,
            arg3: *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR,
            arg4: *mut _RTL_RANGE_LIST,
        ) -> LONG,
    >,
    #[doc = " offset: 0x120 (288)"]
    pub TransactionInProgress: UCHAR,
    #[doc = " offset: 0x128 (296)"]
    pub TransactionEvent: *mut _KEVENT,
    #[doc = " offset: 0x130 (304)"]
    pub Extension: *mut VOID,
    #[doc = " offset: 0x138 (312)"]
    pub BusDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x140 (320)"]
    pub ConflictCallbackContext: *mut VOID,
    pub ConflictCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _RTL_RANGE) -> UCHAR,
    >,
    #[doc = " offset: 0x150 (336)"]
    pub PdoDescriptionString: [WCHAR; 336usize],
    #[doc = " offset: 0x3f0 (1008)"]
    pub PdoSymbolicNameString: [CHAR; 672usize],
    #[doc = " offset: 0x690 (1680)"]
    pub PdoAddressString: [WCHAR; 1usize],
}
impl Default for _ARBITER_INSTANCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KINTERRUPT {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub InterruptListEntry: _LIST_ENTRY,
    pub ServiceRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _KINTERRUPT, arg2: *mut VOID) -> UCHAR,
    >,
    pub MessageServiceRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _KINTERRUPT, arg2: *mut VOID, arg3: ULONG) -> UCHAR,
    >,
    #[doc = " offset: 0x28 (40)"]
    pub MessageIndex: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub ServiceContext: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub SpinLock: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub TickCount: ULONG,
    #[doc = " offset: 0x48 (72)"]
    pub ActualLock: *mut ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub DispatchAddress: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " offset: 0x58 (88)"]
    pub Vector: ULONG,
    #[doc = " offset: 0x5c (92)"]
    pub Irql: UCHAR,
    #[doc = " offset: 0x5d (93)"]
    pub SynchronizeIrql: UCHAR,
    #[doc = " offset: 0x5e (94)"]
    pub FloatingSave: UCHAR,
    #[doc = " offset: 0x5f (95)"]
    pub Connected: UCHAR,
    #[doc = " offset: 0x60 (96)"]
    pub Number: CHAR,
    #[doc = " offset: 0x61 (97)"]
    pub ShareVector: UCHAR,
    #[doc = " offset: 0x64 (100)"]
    pub Mode: _KINTERRUPT_MODE,
    #[doc = " offset: 0x68 (104)"]
    pub Polarity: _KINTERRUPT_POLARITY,
    #[doc = " offset: 0x6c (108)"]
    pub ServiceCount: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub DispatchCount: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub Rsvd1: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub TrapFrame: *mut _KTRAP_FRAME,
    #[doc = " offset: 0x88 (136)"]
    pub Reserved: *mut VOID,
    #[doc = " offset: 0x90 (144)"]
    pub DispatchCode: [ULONG; 4usize],
}
impl Default for _KINTERRUPT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1f8 (504) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: _HEAP_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub SegmentSignature: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub SegmentFlags: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub SegmentListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x28 (40)"]
    pub Heap: *mut _HEAP,
    #[doc = " offset: 0x30 (48)"]
    pub BaseAddress: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub NumberOfPages: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub FirstEntry: *mut _HEAP_ENTRY,
    #[doc = " offset: 0x48 (72)"]
    pub LastValidEntry: *mut _HEAP_ENTRY,
    #[doc = " offset: 0x50 (80)"]
    pub NumberOfUnCommittedPages: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub NumberOfUnCommittedRanges: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub SegmentAllocatorBackTraceIndex: USHORT,
    #[doc = " offset: 0x5a (90)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x60 (96)"]
    pub UCRSegmentList: _LIST_ENTRY,
    #[doc = " offset: 0x70 (112)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x74 (116)"]
    pub ForceFlags: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub CompatibilityFlags: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub EncodeFlagMask: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub Encoding: _HEAP_ENTRY,
    #[doc = " offset: 0x90 (144)"]
    pub PointerKey: ULONGLONG,
    #[doc = " offset: 0x98 (152)"]
    pub Interceptor: ULONG,
    #[doc = " offset: 0x9c (156)"]
    pub VirtualMemoryThreshold: ULONG,
    #[doc = " offset: 0xa0 (160)"]
    pub Signature: ULONG,
    #[doc = " offset: 0xa8 (168)"]
    pub SegmentReserve: ULONGLONG,
    #[doc = " offset: 0xb0 (176)"]
    pub SegmentCommit: ULONGLONG,
    #[doc = " offset: 0xb8 (184)"]
    pub DeCommitFreeBlockThreshold: ULONGLONG,
    #[doc = " offset: 0xc0 (192)"]
    pub DeCommitTotalFreeThreshold: ULONGLONG,
    #[doc = " offset: 0xc8 (200)"]
    pub TotalFreeSize: ULONGLONG,
    #[doc = " offset: 0xd0 (208)"]
    pub MaximumAllocationSize: ULONGLONG,
    #[doc = " offset: 0xd8 (216)"]
    pub ProcessHeapsListIndex: USHORT,
    #[doc = " offset: 0xda (218)"]
    pub HeaderValidateLength: USHORT,
    #[doc = " offset: 0xe0 (224)"]
    pub HeaderValidateCopy: *mut VOID,
    #[doc = " offset: 0xe8 (232)"]
    pub NextAvailableTagIndex: USHORT,
    #[doc = " offset: 0xea (234)"]
    pub MaximumTagIndex: USHORT,
    #[doc = " offset: 0xf0 (240)"]
    pub TagEntries: *mut _HEAP_TAG_ENTRY,
    #[doc = " offset: 0xf8 (248)"]
    pub UCRList: _LIST_ENTRY,
    #[doc = " offset: 0x108 (264)"]
    pub AlignRound: ULONGLONG,
    #[doc = " offset: 0x110 (272)"]
    pub AlignMask: ULONGLONG,
    #[doc = " offset: 0x118 (280)"]
    pub VirtualAllocdBlocks: _LIST_ENTRY,
    #[doc = " offset: 0x128 (296)"]
    pub SegmentList: _LIST_ENTRY,
    #[doc = " offset: 0x138 (312)"]
    pub AllocatorBackTraceIndex: USHORT,
    #[doc = " offset: 0x13c (316)"]
    pub NonDedicatedListLength: ULONG,
    #[doc = " offset: 0x140 (320)"]
    pub BlocksIndex: *mut VOID,
    #[doc = " offset: 0x148 (328)"]
    pub UCRIndex: *mut VOID,
    #[doc = " offset: 0x150 (336)"]
    pub PseudoTagEntries: *mut _HEAP_PSEUDO_TAG_ENTRY,
    #[doc = " offset: 0x158 (344)"]
    pub FreeLists: _LIST_ENTRY,
    #[doc = " offset: 0x168 (360)"]
    pub LockVariable: *mut _HEAP_LOCK,
    pub CommitRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut *mut VOID, arg3: *mut ULONGLONG) -> LONG,
    >,
    #[doc = " offset: 0x178 (376)"]
    pub FrontEndHeap: *mut VOID,
    #[doc = " offset: 0x180 (384)"]
    pub FrontHeapLockCount: USHORT,
    #[doc = " offset: 0x182 (386)"]
    pub FrontEndHeapType: UCHAR,
    #[doc = " offset: 0x188 (392)"]
    pub Counters: _HEAP_COUNTERS,
    #[doc = " offset: 0x1e8 (488)"]
    pub TuningParameters: _HEAP_TUNING_PARAMETERS,
}
impl Default for _HEAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_VERIFIER_DRIVER_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Loads: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub Unloads: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub BaseName: _UNICODE_STRING,
    #[doc = " offset: 0x28 (40)"]
    pub StartAddress: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub EndAddress: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub Signature: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub PoolPageHeaders: _SLIST_HEADER,
    #[doc = " offset: 0x60 (96)"]
    pub PoolTrackers: _SLIST_HEADER,
    #[doc = " offset: 0x70 (112)"]
    pub CurrentPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x74 (116)"]
    pub CurrentNonPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub PeakPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub PeakNonPagedPoolAllocations: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub PagedBytes: ULONGLONG,
    #[doc = " offset: 0x88 (136)"]
    pub NonPagedBytes: ULONGLONG,
    #[doc = " offset: 0x90 (144)"]
    pub PeakPagedBytes: ULONGLONG,
    #[doc = " offset: 0x98 (152)"]
    pub PeakNonPagedBytes: ULONGLONG,
}
impl Default for _MI_VERIFIER_DRIVER_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_LOOKASIDE {
    #[doc = " offset: 0x0 (0)"]
    pub ListHead: _SLIST_HEADER,
    #[doc = " offset: 0x10 (16)"]
    pub Depth: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub MaximumDepth: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub TotalAllocates: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub AllocateMisses: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub TotalFrees: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub FreeMisses: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub LastTotalAllocates: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub LastAllocateMisses: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub Counters: [ULONG; 2usize],
}
impl Default for _HEAP_LOOKASIDE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_KERNEL_GLOBALS {
    #[doc = " offset: 0x0 (0)"]
    pub AccessBufferAgeThreshold: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub AccessBufferRef: _EX_RUNDOWN_REF,
    #[doc = " offset: 0x10 (16)"]
    pub AccessBufferExistsEvent: _KEVENT,
    #[doc = " offset: 0x28 (40)"]
    pub AccessBufferMax: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub AccessBufferList: _SLIST_HEADER,
    #[doc = " offset: 0x50 (80)"]
    pub StreamSequenceNumber: LONG,
    #[doc = " offset: 0x54 (84)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub ScenarioPrefetchCount: LONG,
}
impl Default for _PF_KERNEL_GLOBALS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x370 (880) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_LOGGER_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub StartTime: _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub LogFileHandle: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub LoggerThread: *mut _ETHREAD,
    #[doc = " offset: 0x18 (24)"]
    pub LoggerStatus: LONG,
    #[doc = " offset: 0x1c (28)"]
    pub LoggerId: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub NBQHead: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub OverflowNBQHead: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub QueueBlockFreeList: _SLIST_HEADER,
    #[doc = " offset: 0x40 (64)"]
    pub GlobalList: _SLIST_HEADER,
    #[doc = " offset: 0x50 (80)"]
    pub BatchedBufferList: *mut _WMI_BUFFER_HEADER,
    #[doc = " offset: 0x58 (88)"]
    pub LoggerName: _UNICODE_STRING,
    #[doc = " offset: 0x68 (104)"]
    pub LogFileName: _UNICODE_STRING,
    #[doc = " offset: 0x78 (120)"]
    pub LogFilePattern: _UNICODE_STRING,
    #[doc = " offset: 0x88 (136)"]
    pub NewLogFileName: _UNICODE_STRING,
    #[doc = " offset: 0x98 (152)"]
    pub ClockType: ULONG,
    #[doc = " offset: 0x9c (156)"]
    pub CollectionOn: LONG,
    #[doc = " offset: 0xa0 (160)"]
    pub MaximumFileSize: ULONG,
    #[doc = " offset: 0xa4 (164)"]
    pub LoggerMode: ULONG,
    #[doc = " offset: 0xa8 (168)"]
    pub LastFlushedBuffer: ULONG,
    #[doc = " offset: 0xac (172)"]
    pub FlushTimer: ULONG,
    #[doc = " offset: 0xb0 (176)"]
    pub FlushThreshold: ULONG,
    #[doc = " offset: 0xb8 (184)"]
    pub ByteOffset: _LARGE_INTEGER,
    #[doc = " offset: 0xc0 (192)"]
    pub FlushTimeStamp: _LARGE_INTEGER,
    #[doc = " offset: 0xc8 (200)"]
    pub MinimumBuffers: ULONG,
    #[doc = " offset: 0xcc (204)"]
    pub BuffersAvailable: LONG,
    #[doc = " offset: 0xd0 (208)"]
    pub NumberOfBuffers: LONG,
    #[doc = " offset: 0xd4 (212)"]
    pub MaximumBuffers: ULONG,
    #[doc = " offset: 0xd8 (216)"]
    pub EventsLost: ULONG,
    #[doc = " offset: 0xdc (220)"]
    pub BuffersWritten: ULONG,
    #[doc = " offset: 0xe0 (224)"]
    pub LogBuffersLost: ULONG,
    #[doc = " offset: 0xe4 (228)"]
    pub RealTimeBuffersDelivered: ULONG,
    #[doc = " offset: 0xe8 (232)"]
    pub RealTimeBuffersLost: ULONG,
    #[doc = " offset: 0xec (236)"]
    pub BufferSize: ULONG,
    #[doc = " offset: 0xf0 (240)"]
    pub MaximumEventSize: ULONG,
    #[doc = " offset: 0xf8 (248)"]
    pub SequencePtr: *mut LONG,
    #[doc = " offset: 0x100 (256)"]
    pub LocalSequence: ULONG,
    #[doc = " offset: 0x104 (260)"]
    pub InstanceGuid: _GUID,
    #[doc = " offset: 0x118 (280)"]
    pub GetCpuClock: ::std::option::Option<unsafe extern "C" fn() -> LONGLONG>,
    #[doc = " offset: 0x120 (288)"]
    pub FileCounter: LONG,
    pub volatileBufferCallback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _WMI_BUFFER_HEADER, arg2: *mut VOID)>,
    #[doc = " offset: 0x130 (304)"]
    pub PoolType: _POOL_TYPE,
    #[doc = " offset: 0x138 (312)"]
    pub ReferenceTime: _ETW_REF_CLOCK,
    #[doc = " offset: 0x148 (328)"]
    pub RealtimeLoggerContextFreed: UCHAR,
    #[doc = " offset: 0x150 (336)"]
    pub Consumers: _LIST_ENTRY,
    #[doc = " offset: 0x160 (352)"]
    pub NumConsumers: ULONG,
    #[doc = " offset: 0x168 (360)"]
    pub Connecting: _LIST_ENTRY,
    #[doc = " offset: 0x178 (376)"]
    pub NewConsumer: UCHAR,
    #[doc = " offset: 0x180 (384)"]
    pub RealtimeLogfileHandle: *mut VOID,
    #[doc = " offset: 0x188 (392)"]
    pub RealtimeLogfileName: _UNICODE_STRING,
    #[doc = " offset: 0x198 (408)"]
    pub RealtimeWriteOffset: _LARGE_INTEGER,
    #[doc = " offset: 0x1a0 (416)"]
    pub RealtimeReadOffset: _LARGE_INTEGER,
    #[doc = " offset: 0x1a8 (424)"]
    pub RealtimeLogfileSize: _LARGE_INTEGER,
    #[doc = " offset: 0x1b0 (432)"]
    pub RealtimeLogfileUsage: ULONGLONG,
    #[doc = " offset: 0x1b8 (440)"]
    pub RealtimeMaximumFileSize: ULONGLONG,
    #[doc = " offset: 0x1c0 (448)"]
    pub RealtimeBuffersSaved: ULONG,
    #[doc = " offset: 0x1c8 (456)"]
    pub RealtimeReferenceTime: _ETW_REF_CLOCK,
    #[doc = " offset: 0x1d8 (472)"]
    pub RealtimeDisconnectProcessId: ULONG,
    #[doc = " offset: 0x1dc (476)"]
    pub RealtimeDisconnectConsumerId: ULONG,
    #[doc = " offset: 0x1e0 (480)"]
    pub NewRTEventsLost: _ETW_RT_EVENT_LOSS,
    #[doc = " offset: 0x1e8 (488)"]
    pub LoggerEvent: _KEVENT,
    #[doc = " offset: 0x200 (512)"]
    pub FlushEvent: _KEVENT,
    #[doc = " offset: 0x218 (536)"]
    pub FlushDpc: _KDPC,
    #[doc = " offset: 0x258 (600)"]
    pub LoggerMutex: _KMUTANT,
    #[doc = " offset: 0x290 (656)"]
    pub LoggerLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x298 (664)"]
    pub ClientSecurityContext: _SECURITY_CLIENT_CONTEXT,
    #[doc = " offset: 0x2e0 (736)"]
    pub SecurityDescriptor: _EX_FAST_REF,
    #[doc = " offset: 0x2e8 (744)"]
    pub DummyBufferForMarker: _WMI_BUFFER_HEADER,
    #[doc = " offset: 0x330 (816)"]
    pub BufferSequenceNumber: LONGLONG,
    #[doc = " offset: 0x338 (824)"]
    pub AcceptNewEvents: LONG,
    pub __bindgen_anon_1: _WMI_LOGGER_CONTEXT__bindgen_ty_1,
    pub __bindgen_anon_2: _WMI_LOGGER_CONTEXT__bindgen_ty_2,
    #[doc = " offset: 0x344 (836)"]
    pub StackTraceFilterHookCount: USHORT,
    #[doc = " offset: 0x346 (838)"]
    pub StackTraceFilter: [USHORT; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_CONTEXT__bindgen_ty_1 {
    #[doc = " offset: 0x33c (828)"]
    pub Flags: ULONG,
    pub __bindgen_anon_1: _WMI_LOGGER_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WMI_LOGGER_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _WMI_LOGGER_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Persistent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Persistent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AutoLogger(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoLogger(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FsReady(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FsReady(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RealTime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wow(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelTrace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelTrace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoMoreEnable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoMoreEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Persistent: ULONG,
        AutoLogger: ULONG,
        FsReady: ULONG,
        RealTime: ULONG,
        Wow: ULONG,
        KernelTrace: ULONG,
        NoMoreEnable: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Persistent: u32 = unsafe { ::std::mem::transmute(Persistent) };
            Persistent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AutoLogger: u32 = unsafe { ::std::mem::transmute(AutoLogger) };
            AutoLogger as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FsReady: u32 = unsafe { ::std::mem::transmute(FsReady) };
            FsReady as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RealTime: u32 = unsafe { ::std::mem::transmute(RealTime) };
            RealTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Wow: u32 = unsafe { ::std::mem::transmute(Wow) };
            Wow as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let KernelTrace: u32 = unsafe { ::std::mem::transmute(KernelTrace) };
            KernelTrace as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NoMoreEnable: u32 = unsafe { ::std::mem::transmute(NoMoreEnable) };
            NoMoreEnable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _WMI_LOGGER_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_CONTEXT__bindgen_ty_2 {
    #[doc = " offset: 0x340 (832)"]
    pub RequestFlag: ULONG,
    pub __bindgen_anon_1: _WMI_LOGGER_CONTEXT__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WMI_LOGGER_CONTEXT__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _WMI_LOGGER_CONTEXT__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn RequestNewFie(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestNewFie(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequestUpdateFile(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestUpdateFile(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequestFlush(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestFlush(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequestDisableRealtime(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestDisableRealtime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RequestDisconnectConsumer(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequestDisconnectConsumer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RequestNewFie: ULONG,
        RequestUpdateFile: ULONG,
        RequestFlush: ULONG,
        RequestDisableRealtime: ULONG,
        RequestDisconnectConsumer: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RequestNewFie: u32 = unsafe { ::std::mem::transmute(RequestNewFie) };
            RequestNewFie as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RequestUpdateFile: u32 = unsafe { ::std::mem::transmute(RequestUpdateFile) };
            RequestUpdateFile as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RequestFlush: u32 = unsafe { ::std::mem::transmute(RequestFlush) };
            RequestFlush as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RequestDisableRealtime: u32 =
                unsafe { ::std::mem::transmute(RequestDisableRealtime) };
            RequestDisableRealtime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RequestDisconnectConsumer: u32 =
                unsafe { ::std::mem::transmute(RequestDisconnectConsumer) };
            RequestDisconnectConsumer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _WMI_LOGGER_CONTEXT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _WMI_LOGGER_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub Depth: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub MaximumDepth: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE__bindgen_ty_2,
    #[doc = " offset: 0x1c (28)"]
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE__bindgen_ty_3,
    #[doc = " offset: 0x24 (36)"]
    pub Type: _POOL_TYPE,
    #[doc = " offset: 0x28 (40)"]
    pub Tag: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE__bindgen_ty_5,
    #[doc = " offset: 0x40 (64)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x50 (80)"]
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE__bindgen_ty_6,
    #[doc = " offset: 0x58 (88)"]
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub ListHead: _SLIST_HEADER,
    #[doc = " offset: 0x0 (0)"]
    pub SingleListHead: _SINGLE_LIST_ENTRY,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_2 {
    #[doc = " offset: 0x18 (24)"]
    pub AllocateMisses: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub AllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_3 {
    #[doc = " offset: 0x20 (32)"]
    pub FreeMisses: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub FreeHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_4 {
    pub AllocateEx: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: _POOL_TYPE,
            arg2: ULONGLONG,
            arg3: ULONG,
            arg4: *mut _LOOKASIDE_LIST_EX,
        ) -> *mut VOID,
    >,
    pub Allocate: ::std::option::Option<
        unsafe extern "C" fn(arg1: _POOL_TYPE, arg2: ULONGLONG, arg3: ULONG) -> *mut VOID,
    >,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_5 {
    pub FreeEx:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _LOOKASIDE_LIST_EX)>,
    #[doc = " offset: 0x38 (56)"]
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_6 {
    #[doc = " offset: 0x54 (84)"]
    pub LastAllocateMisses: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub LastAllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _GENERAL_LOOKASIDE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PAGED_LOOKASIDE_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub L: _GENERAL_LOOKASIDE,
}
impl Default for _PAGED_LOOKASIDE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x80 (128) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NPAGED_LOOKASIDE_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub L: _GENERAL_LOOKASIDE,
}
impl Default for _NPAGED_LOOKASIDE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PP_LOOKASIDE_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub P: *mut _GENERAL_LOOKASIDE,
    #[doc = " offset: 0x8 (8)"]
    pub L: *mut _GENERAL_LOOKASIDE,
}
impl Default for _PP_LOOKASIDE_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHED_KSTACK_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub SListHead: _SLIST_HEADER,
    #[doc = " offset: 0x10 (16)"]
    pub MinimumFree: LONG,
    #[doc = " offset: 0x14 (20)"]
    pub Misses: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub MissesLast: ULONG,
}
impl Default for _CACHED_KSTACK_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE_POOL {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE_POOL__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub Depth: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub MaximumDepth: USHORT,
    #[doc = " offset: 0x14 (20)"]
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE_POOL__bindgen_ty_2,
    #[doc = " offset: 0x1c (28)"]
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE_POOL__bindgen_ty_3,
    #[doc = " offset: 0x24 (36)"]
    pub Type: _POOL_TYPE,
    #[doc = " offset: 0x28 (40)"]
    pub Tag: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE_POOL__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE_POOL__bindgen_ty_5,
    #[doc = " offset: 0x40 (64)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x50 (80)"]
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE_POOL__bindgen_ty_6,
    #[doc = " offset: 0x58 (88)"]
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub ListHead: _SLIST_HEADER,
    #[doc = " offset: 0x0 (0)"]
    pub SingleListHead: _SINGLE_LIST_ENTRY,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    #[doc = " offset: 0x18 (24)"]
    pub AllocateMisses: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub AllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    #[doc = " offset: 0x20 (32)"]
    pub FreeMisses: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub FreeHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    pub AllocateEx: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: _POOL_TYPE,
            arg2: ULONGLONG,
            arg3: ULONG,
            arg4: *mut _LOOKASIDE_LIST_EX,
        ) -> *mut VOID,
    >,
    pub Allocate: ::std::option::Option<
        unsafe extern "C" fn(arg1: _POOL_TYPE, arg2: ULONGLONG, arg3: ULONG) -> *mut VOID,
    >,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    pub FreeEx:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _LOOKASIDE_LIST_EX)>,
    #[doc = " offset: 0x38 (56)"]
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    #[doc = " offset: 0x54 (84)"]
    pub LastAllocateMisses: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub LastAllocateHits: ULONG,
}
impl Default for _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _GENERAL_LOOKASIDE_POOL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOOKASIDE_LIST_EX {
    #[doc = " offset: 0x0 (0)"]
    pub L: _GENERAL_LOOKASIDE_POOL,
}
impl Default for _LOOKASIDE_LIST_EX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VI_VERIFIER_ISSUE {
    #[doc = " offset: 0x0 (0)"]
    pub IssueType: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Address: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Parameters: [ULONGLONG; 2usize],
}
impl Default for _VI_VERIFIER_ISSUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xc0 (192) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KNODE {
    #[doc = " offset: 0x0 (0)"]
    pub PagedPoolSListHead: _SLIST_HEADER,
    #[doc = " offset: 0x10 (16)"]
    pub NonPagedPoolSListHead: [_SLIST_HEADER; 3usize],
    #[doc = " offset: 0x40 (64)"]
    pub PfnDereferenceSListHead: _SLIST_HEADER,
    #[doc = " offset: 0x50 (80)"]
    pub ProcessorMask: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub Color: UCHAR,
    #[doc = " offset: 0x59 (89)"]
    pub Seed: UCHAR,
    #[doc = " offset: 0x5a (90)"]
    pub NodeNumber: UCHAR,
    #[doc = " offset: 0x5b (91)"]
    pub Flags: _flags,
    #[doc = " offset: 0x5c (92)"]
    pub MmShiftedColor: ULONG,
    #[doc = " offset: 0x60 (96)"]
    pub FreeCount: [ULONGLONG; 2usize],
    #[doc = " offset: 0x70 (112)"]
    pub PfnDeferredList: *mut _SLIST_ENTRY,
    #[doc = " offset: 0x78 (120)"]
    pub Right: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub Left: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub CachedKernelStacks: _CACHED_KSTACK_LIST,
}
impl Default for _KNODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x3b8 (952) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KUSER_SHARED_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub TickCountLowDeprecated: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub TickCountMultiplier: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub InterruptTime: _KSYSTEM_TIME,
    #[doc = " offset: 0x14 (20)"]
    pub SystemTime: _KSYSTEM_TIME,
    #[doc = " offset: 0x20 (32)"]
    pub TimeZoneBias: _KSYSTEM_TIME,
    #[doc = " offset: 0x2c (44)"]
    pub ImageNumberLow: USHORT,
    #[doc = " offset: 0x2e (46)"]
    pub ImageNumberHigh: USHORT,
    #[doc = " offset: 0x30 (48)"]
    pub NtSystemRoot: [WCHAR; 260usize],
    #[doc = " offset: 0x238 (568)"]
    pub MaxStackTraceDepth: ULONG,
    #[doc = " offset: 0x23c (572)"]
    pub CryptoExponent: ULONG,
    #[doc = " offset: 0x240 (576)"]
    pub TimeZoneId: ULONG,
    #[doc = " offset: 0x244 (580)"]
    pub LargePageMinimum: ULONG,
    #[doc = " offset: 0x248 (584)"]
    pub Reserved2: [ULONG; 7usize],
    #[doc = " offset: 0x264 (612)"]
    pub NtProductType: _NT_PRODUCT_TYPE,
    #[doc = " offset: 0x268 (616)"]
    pub ProductTypeIsValid: UCHAR,
    #[doc = " offset: 0x26c (620)"]
    pub NtMajorVersion: ULONG,
    #[doc = " offset: 0x270 (624)"]
    pub NtMinorVersion: ULONG,
    #[doc = " offset: 0x274 (628)"]
    pub ProcessorFeatures: [UCHAR; 64usize],
    #[doc = " offset: 0x2b4 (692)"]
    pub Reserved1: ULONG,
    #[doc = " offset: 0x2b8 (696)"]
    pub Reserved3: ULONG,
    #[doc = " offset: 0x2bc (700)"]
    pub TimeSlip: ULONG,
    #[doc = " offset: 0x2c0 (704)"]
    pub AlternativeArchitecture: _ALTERNATIVE_ARCHITECTURE_TYPE,
    #[doc = " offset: 0x2c8 (712)"]
    pub SystemExpirationDate: _LARGE_INTEGER,
    #[doc = " offset: 0x2d0 (720)"]
    pub SuiteMask: ULONG,
    #[doc = " offset: 0x2d4 (724)"]
    pub KdDebuggerEnabled: UCHAR,
    #[doc = " offset: 0x2d5 (725)"]
    pub NXSupportPolicy: UCHAR,
    #[doc = " offset: 0x2d8 (728)"]
    pub ActiveConsoleId: ULONG,
    #[doc = " offset: 0x2dc (732)"]
    pub DismountCount: ULONG,
    #[doc = " offset: 0x2e0 (736)"]
    pub ComPlusPackage: ULONG,
    #[doc = " offset: 0x2e4 (740)"]
    pub LastSystemRITEventTickCount: ULONG,
    #[doc = " offset: 0x2e8 (744)"]
    pub NumberOfPhysicalPages: ULONG,
    #[doc = " offset: 0x2ec (748)"]
    pub SafeBootMode: UCHAR,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1,
    #[doc = " offset: 0x2f8 (760)"]
    pub TestRetInstruction: ULONGLONG,
    #[doc = " offset: 0x300 (768)"]
    pub SystemCall: ULONG,
    #[doc = " offset: 0x304 (772)"]
    pub SystemCallReturn: ULONG,
    #[doc = " offset: 0x308 (776)"]
    pub SystemCallPad: [ULONGLONG; 3usize],
    pub __bindgen_anon_2: _KUSER_SHARED_DATA__bindgen_ty_2,
    #[doc = " offset: 0x330 (816)"]
    pub Cookie: ULONG,
    #[doc = " offset: 0x338 (824)"]
    pub ConsoleSessionForegroundProcessId: LONGLONG,
    #[doc = " offset: 0x340 (832)"]
    pub Wow64SharedInformation: [ULONG; 16usize],
    #[doc = " offset: 0x380 (896)"]
    pub UserModeGlobalLogger: [USHORT; 8usize],
    #[doc = " offset: 0x390 (912)"]
    pub HeapTracingPid: [ULONG; 2usize],
    #[doc = " offset: 0x398 (920)"]
    pub CritSecTracingPid: [ULONG; 2usize],
    #[doc = " offset: 0x3a0 (928)"]
    pub ImageFileExecutionOptions: ULONG,
    #[doc = " offset: 0x3a4 (932)"]
    pub LangGenerationCount: ULONG,
    pub __bindgen_anon_3: _KUSER_SHARED_DATA__bindgen_ty_3,
    #[doc = " offset: 0x3b0 (944)"]
    pub InterruptTimeBias: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_1 {
    #[doc = " offset: 0x2f0 (752)"]
    pub SharedDataFlags: ULONG,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DbgErrorPortPresent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgErrorPortPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgElevationEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgElevationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgVirtEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgVirtEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgInstallerDetectEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgInstallerDetectEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSystemDllRelocated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgSystemDllRelocated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgDynProcessorEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgDynProcessorEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSEHValidationEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgSEHValidationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgErrorPortPresent: ULONG,
        DbgElevationEnabled: ULONG,
        DbgVirtEnabled: ULONG,
        DbgInstallerDetectEnabled: ULONG,
        DbgSystemDllRelocated: ULONG,
        DbgDynProcessorEnabled: ULONG,
        DbgSEHValidationEnabled: ULONG,
        SpareBits: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgErrorPortPresent: u32 = unsafe { ::std::mem::transmute(DbgErrorPortPresent) };
            DbgErrorPortPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgElevationEnabled: u32 = unsafe { ::std::mem::transmute(DbgElevationEnabled) };
            DbgElevationEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgVirtEnabled: u32 = unsafe { ::std::mem::transmute(DbgVirtEnabled) };
            DbgVirtEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgInstallerDetectEnabled: u32 =
                unsafe { ::std::mem::transmute(DbgInstallerDetectEnabled) };
            DbgInstallerDetectEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgSystemDllRelocated: u32 =
                unsafe { ::std::mem::transmute(DbgSystemDllRelocated) };
            DbgSystemDllRelocated as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgDynProcessorEnabled: u32 =
                unsafe { ::std::mem::transmute(DbgDynProcessorEnabled) };
            DbgDynProcessorEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgSEHValidationEnabled: u32 =
                unsafe { ::std::mem::transmute(DbgSEHValidationEnabled) };
            DbgSEHValidationEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let SpareBits: u32 = unsafe { ::std::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_2 {
    #[doc = " offset: 0x320 (800)"]
    pub TickCount: _KSYSTEM_TIME,
    #[doc = " offset: 0x320 (800)"]
    pub TickCountQuad: ULONGLONG,
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_3 {
    #[doc = " offset: 0x3a8 (936)"]
    pub AffinityPad: ULONGLONG,
    #[doc = " offset: 0x3a8 (936)"]
    pub ActiveProcessorAffinity: ULONGLONG,
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KUSER_SHARED_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTSS64 {
    #[doc = " offset: 0x0 (0)"]
    pub Reserved0: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Rsp0: ULONGLONG,
    #[doc = " offset: 0xc (12)"]
    pub Rsp1: ULONGLONG,
    #[doc = " offset: 0x14 (20)"]
    pub Rsp2: ULONGLONG,
    #[doc = " offset: 0x1c (28)"]
    pub Ist: [ULONGLONG; 8usize],
    #[doc = " offset: 0x5c (92)"]
    pub Reserved1: ULONGLONG,
    #[doc = " offset: 0x64 (100)"]
    pub Reserved2: USHORT,
    #[doc = " offset: 0x66 (102)"]
    pub IoMapBase: USHORT,
}
#[doc = " 0x138 (312) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PO_MEMORY_IMAGE {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ImageType: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CheckSum: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub LengthSelf: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub PageSelf: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub PageSize: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub SystemTime: _LARGE_INTEGER,
    #[doc = " offset: 0x28 (40)"]
    pub InterruptTime: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub FeatureFlags: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub HiberFlags: UCHAR,
    #[doc = " offset: 0x35 (53)"]
    pub spare: [UCHAR; 3usize],
    #[doc = " offset: 0x38 (56)"]
    pub NoHiberPtes: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub HiberVa: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub HiberPte: _LARGE_INTEGER,
    #[doc = " offset: 0x50 (80)"]
    pub NoFreePages: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub FreeMapCheck: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub WakeCheck: ULONG,
    #[doc = " offset: 0x60 (96)"]
    pub TotalPages: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub FirstTablePage: ULONGLONG,
    #[doc = " offset: 0x70 (112)"]
    pub PerfInfo: _PO_HIBER_PERF,
    #[doc = " offset: 0xd0 (208)"]
    pub FirmwareRuntimeInformationPages: ULONG,
    #[doc = " offset: 0xd8 (216)"]
    pub FirmwareRuntimeInformation: [ULONGLONG; 1usize],
    #[doc = " offset: 0xe0 (224)"]
    pub NoBootLoaderLogPages: ULONG,
    #[doc = " offset: 0xe8 (232)"]
    pub BootLoaderLogPages: [ULONGLONG; 8usize],
    #[doc = " offset: 0x128 (296)"]
    pub NotUsed: ULONG,
    #[doc = " offset: 0x12c (300)"]
    pub ResumeContextCheck: ULONG,
    #[doc = " offset: 0x130 (304)"]
    pub ResumeContextPages: ULONG,
}
impl Default for PO_MEMORY_IMAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x178 (376) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_HIBER_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub WriteToFile: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub ReserveLoaderMemory: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub ReserveFreeMemory: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub VerifyOnWake: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub Reset: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub HiberFlags: UCHAR,
    #[doc = " offset: 0x6 (6)"]
    pub WroteHiberFile: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub Lock: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub MapFrozen: UCHAR,
    #[doc = " offset: 0x18 (24)"]
    pub MemoryMap: _RTL_BITMAP,
    #[doc = " offset: 0x28 (40)"]
    pub DiscardedMemoryPages: _RTL_BITMAP,
    #[doc = " offset: 0x38 (56)"]
    pub ClonedRanges: _LIST_ENTRY,
    #[doc = " offset: 0x48 (72)"]
    pub ClonedRangeCount: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub NextCloneRange: *mut _LIST_ENTRY,
    #[doc = " offset: 0x58 (88)"]
    pub NextPreserve: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub LoaderMdl: *mut _MDL,
    #[doc = " offset: 0x68 (104)"]
    pub AllocatedMdl: *mut _MDL,
    #[doc = " offset: 0x70 (112)"]
    pub PagesOut: ULONGLONG,
    #[doc = " offset: 0x78 (120)"]
    pub IoPages: *mut VOID,
    #[doc = " offset: 0x80 (128)"]
    pub IoPagesCount: ULONG,
    #[doc = " offset: 0x88 (136)"]
    pub CurrentMcb: *mut VOID,
    #[doc = " offset: 0x90 (144)"]
    pub DumpStack: *mut _DUMP_STACK_CONTEXT,
    #[doc = " offset: 0x98 (152)"]
    pub WakeState: *mut _KPROCESSOR_STATE,
    #[doc = " offset: 0xa0 (160)"]
    pub HiberVa: ULONGLONG,
    #[doc = " offset: 0xa8 (168)"]
    pub HiberPte: _LARGE_INTEGER,
    #[doc = " offset: 0xb0 (176)"]
    pub Status: LONG,
    #[doc = " offset: 0xb8 (184)"]
    pub MemoryImage: *mut PO_MEMORY_IMAGE,
    #[doc = " offset: 0xc0 (192)"]
    pub TableHead: *mut _PO_MEMORY_RANGE_TABLE,
    #[doc = " offset: 0xc8 (200)"]
    pub CompressionWorkspace: *mut UCHAR,
    #[doc = " offset: 0xd0 (208)"]
    pub CompressedWriteBuffer: *mut UCHAR,
    #[doc = " offset: 0xd8 (216)"]
    pub PerformanceStats: *mut ULONG,
    #[doc = " offset: 0xe0 (224)"]
    pub CompressionBlock: *mut VOID,
    #[doc = " offset: 0xe8 (232)"]
    pub DmaIO: *mut VOID,
    #[doc = " offset: 0xf0 (240)"]
    pub TemporaryHeap: *mut VOID,
    #[doc = " offset: 0xf8 (248)"]
    pub PerfInfo: _PO_HIBER_PERF,
    #[doc = " offset: 0x158 (344)"]
    pub BootLoaderLogMdl: *mut _MDL,
    #[doc = " offset: 0x160 (352)"]
    pub FirmwareRuntimeInformationMdl: *mut _MDL,
    #[doc = " offset: 0x168 (360)"]
    pub ResumeContext: *mut VOID,
    #[doc = " offset: 0x170 (368)"]
    pub ResumeContextPages: ULONG,
}
impl Default for _POP_HIBER_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xb0 (176) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POP_POWER_ACTION {
    #[doc = " offset: 0x0 (0)"]
    pub Updates: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub State: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Shutdown: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub Action: POWER_ACTION,
    #[doc = " offset: 0x8 (8)"]
    pub LightestState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0xc (12)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Status: LONG,
    #[doc = " offset: 0x14 (20)"]
    pub DeviceType: POP_POLICY_DEVICE_TYPE,
    #[doc = " offset: 0x18 (24)"]
    pub DeviceTypeFlags: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub IrpMinor: UCHAR,
    #[doc = " offset: 0x1d (29)"]
    pub Waking: UCHAR,
    #[doc = " offset: 0x20 (32)"]
    pub SystemState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x24 (36)"]
    pub NextSystemState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x28 (40)"]
    pub EffectiveSystemState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x2c (44)"]
    pub CurrentSystemState: _SYSTEM_POWER_STATE,
    #[doc = " offset: 0x30 (48)"]
    pub ShutdownBugCode: *mut _POP_SHUTDOWN_BUG_CHECK,
    #[doc = " offset: 0x38 (56)"]
    pub DevState: *mut _POP_DEVICE_SYS_STATE,
    #[doc = " offset: 0x40 (64)"]
    pub DisplayResumeContext: *mut _POP_DISPLAY_RESUME_CONTEXT,
    #[doc = " offset: 0x48 (72)"]
    pub HiberContext: *mut _POP_HIBER_CONTEXT,
    #[doc = " offset: 0x50 (80)"]
    pub WakeTime: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub SleepTime: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub FilteredCapabilities: SYSTEM_POWER_CAPABILITIES,
}
impl Default for _POP_POWER_ACTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xf0 (240) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_OPTIONAL_HEADER64 {
    #[doc = " offset: 0x0 (0)"]
    pub Magic: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub MajorLinkerVersion: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub MinorLinkerVersion: UCHAR,
    #[doc = " offset: 0x4 (4)"]
    pub SizeOfCode: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub SizeOfInitializedData: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SizeOfUninitializedData: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub AddressOfEntryPoint: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub BaseOfCode: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub ImageBase: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub SectionAlignment: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub FileAlignment: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub MajorOperatingSystemVersion: USHORT,
    #[doc = " offset: 0x2a (42)"]
    pub MinorOperatingSystemVersion: USHORT,
    #[doc = " offset: 0x2c (44)"]
    pub MajorImageVersion: USHORT,
    #[doc = " offset: 0x2e (46)"]
    pub MinorImageVersion: USHORT,
    #[doc = " offset: 0x30 (48)"]
    pub MajorSubsystemVersion: USHORT,
    #[doc = " offset: 0x32 (50)"]
    pub MinorSubsystemVersion: USHORT,
    #[doc = " offset: 0x34 (52)"]
    pub Win32VersionValue: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub SizeOfImage: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub SizeOfHeaders: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub CheckSum: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub Subsystem: USHORT,
    #[doc = " offset: 0x46 (70)"]
    pub DllCharacteristics: USHORT,
    #[doc = " offset: 0x48 (72)"]
    pub SizeOfStackReserve: ULONGLONG,
    #[doc = " offset: 0x50 (80)"]
    pub SizeOfStackCommit: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub SizeOfHeapReserve: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub SizeOfHeapCommit: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub LoaderFlags: ULONG,
    #[doc = " offset: 0x6c (108)"]
    pub NumberOfRvaAndSizes: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub DataDirectory: [_IMAGE_DATA_DIRECTORY; 16usize],
}
#[doc = " 0x108 (264) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IMAGE_NT_HEADERS64 {
    #[doc = " offset: 0x0 (0)"]
    pub Signature: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub FileHeader: _IMAGE_FILE_HEADER,
    #[doc = " offset: 0x18 (24)"]
    pub OptionalHeader: _IMAGE_OPTIONAL_HEADER64,
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub Information: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Status: LONG,
    #[doc = " offset: 0x0 (0)"]
    pub Pointer: *mut VOID,
}
impl Default for _IO_STATUS_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STATUS_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xd0 (208) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = " offset: 0x8 (8)"]
    pub MdlAddress: *mut _MDL,
    #[doc = " offset: 0x10 (16)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    #[doc = " offset: 0x20 (32)"]
    pub ThreadListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub IoStatus: _IO_STATUS_BLOCK,
    #[doc = " offset: 0x40 (64)"]
    pub RequestorMode: CHAR,
    #[doc = " offset: 0x41 (65)"]
    pub PendingReturned: UCHAR,
    #[doc = " offset: 0x42 (66)"]
    pub StackCount: CHAR,
    #[doc = " offset: 0x43 (67)"]
    pub CurrentLocation: CHAR,
    #[doc = " offset: 0x44 (68)"]
    pub Cancel: UCHAR,
    #[doc = " offset: 0x45 (69)"]
    pub CancelIrql: UCHAR,
    #[doc = " offset: 0x46 (70)"]
    pub ApcEnvironment: CHAR,
    #[doc = " offset: 0x47 (71)"]
    pub AllocationFlags: UCHAR,
    #[doc = " offset: 0x48 (72)"]
    pub UserIosb: *mut _IO_STATUS_BLOCK,
    #[doc = " offset: 0x50 (80)"]
    pub UserEvent: *mut _KEVENT,
    #[doc = " offset: 0x58 (88)"]
    pub Overlay: _IRP__bindgen_ty_2,
    pub CancelRoutine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP)>,
    #[doc = " offset: 0x70 (112)"]
    pub UserBuffer: *mut VOID,
    #[doc = " offset: 0x78 (120)"]
    pub Tail: _IRP__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    #[doc = " offset: 0x18 (24)"]
    pub MasterIrp: *mut _IRP,
    #[doc = " offset: 0x18 (24)"]
    pub IrpCount: LONG,
    #[doc = " offset: 0x18 (24)"]
    pub SystemBuffer: *mut VOID,
}
impl Default for _IRP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    #[doc = " offset: 0x58 (88)"]
    pub AsynchronousParameters: _IRP__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x58 (88)"]
    pub AllocationSize: _LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub UserApcContext: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _IO_STATUS_BLOCK, arg3: ULONG),
    >,
    #[doc = " offset: 0x0 (0)"]
    pub IssuingProcess: *mut VOID,
}
impl Default for _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3 {
    #[doc = " offset: 0x78 (120)"]
    pub Overlay: _IRP__bindgen_ty_3__bindgen_ty_1,
    #[doc = " offset: 0x78 (120)"]
    pub Apc: _KAPC,
    #[doc = " offset: 0x78 (120)"]
    pub CompletionKey: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x20 (32)"]
    pub Thread: *mut _ETHREAD,
    #[doc = " offset: 0x28 (40)"]
    pub AuxiliaryBuffer: *mut CHAR,
    #[doc = " offset: 0x30 (48)"]
    pub ListEntry: _LIST_ENTRY,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x48 (72)"]
    pub OriginalFileObject: *mut _FILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceQueueEntry: _KDEVICE_QUEUE_ENTRY,
    #[doc = " offset: 0x0 (0)"]
    pub DriverContext: [*mut VOID; 4usize],
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x40 (64)"]
    pub CurrentStackLocation: *mut _IO_STACK_LOCATION,
    #[doc = " offset: 0x40 (64)"]
    pub PacketType: ULONG,
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IRP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x200 (512) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IOV_FORCED_PENDING_TRACE {
    #[doc = " offset: 0x0 (0)"]
    pub Irp: *mut _IRP,
    #[doc = " offset: 0x8 (8)"]
    pub StackTrace: [*mut VOID; 63usize],
}
impl Default for _IOV_FORCED_PENDING_TRACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_IRP_QUEUE {
    #[doc = " offset: 0x0 (0)"]
    pub CurrentIrp: *mut _IRP,
    #[doc = " offset: 0x8 (8)"]
    pub PendingIrpList: *mut _IRP,
}
impl Default for _PO_IRP_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PO_IRP_MANAGER {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceIrpQueue: _PO_IRP_QUEUE,
    #[doc = " offset: 0x10 (16)"]
    pub SystemIrpQueue: _PO_IRP_QUEUE,
}
impl Default for _PO_IRP_MANAGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x220 (544) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_NODE {
    #[doc = " offset: 0x0 (0)"]
    pub Sibling: *mut _DEVICE_NODE,
    #[doc = " offset: 0x8 (8)"]
    pub Child: *mut _DEVICE_NODE,
    #[doc = " offset: 0x10 (16)"]
    pub Parent: *mut _DEVICE_NODE,
    #[doc = " offset: 0x18 (24)"]
    pub LastChild: *mut _DEVICE_NODE,
    #[doc = " offset: 0x20 (32)"]
    pub Level: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub Notify: _PO_DEVICE_NOTIFY,
    #[doc = " offset: 0x68 (104)"]
    pub PoIrpManager: _PO_IRP_MANAGER,
    #[doc = " offset: 0x88 (136)"]
    pub State: _PNP_DEVNODE_STATE,
    #[doc = " offset: 0x8c (140)"]
    pub PreviousState: _PNP_DEVNODE_STATE,
    #[doc = " offset: 0x90 (144)"]
    pub StateHistory: [_PNP_DEVNODE_STATE; 20usize],
    #[doc = " offset: 0xe0 (224)"]
    pub StateHistoryEntry: ULONG,
    #[doc = " offset: 0xe4 (228)"]
    pub CompletionStatus: LONG,
    #[doc = " offset: 0xe8 (232)"]
    pub PendingIrp: *mut _IRP,
    #[doc = " offset: 0xf0 (240)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xf4 (244)"]
    pub UserFlags: ULONG,
    #[doc = " offset: 0xf8 (248)"]
    pub Problem: ULONG,
    #[doc = " offset: 0x100 (256)"]
    pub PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x108 (264)"]
    pub ResourceList: *mut _CM_RESOURCE_LIST,
    #[doc = " offset: 0x110 (272)"]
    pub ResourceListTranslated: *mut _CM_RESOURCE_LIST,
    #[doc = " offset: 0x118 (280)"]
    pub InstancePath: _UNICODE_STRING,
    #[doc = " offset: 0x128 (296)"]
    pub ServiceName: _UNICODE_STRING,
    #[doc = " offset: 0x138 (312)"]
    pub DuplicatePDO: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x140 (320)"]
    pub ResourceRequirements: *mut _IO_RESOURCE_REQUIREMENTS_LIST,
    #[doc = " offset: 0x148 (328)"]
    pub InterfaceType: _INTERFACE_TYPE,
    #[doc = " offset: 0x14c (332)"]
    pub BusNumber: ULONG,
    #[doc = " offset: 0x150 (336)"]
    pub ChildInterfaceType: _INTERFACE_TYPE,
    #[doc = " offset: 0x154 (340)"]
    pub ChildBusNumber: ULONG,
    #[doc = " offset: 0x158 (344)"]
    pub ChildBusTypeIndex: USHORT,
    #[doc = " offset: 0x15a (346)"]
    pub RemovalPolicy: UCHAR,
    #[doc = " offset: 0x15b (347)"]
    pub HardwareRemovalPolicy: UCHAR,
    #[doc = " offset: 0x160 (352)"]
    pub TargetDeviceNotify: _LIST_ENTRY,
    #[doc = " offset: 0x170 (368)"]
    pub DeviceArbiterList: _LIST_ENTRY,
    #[doc = " offset: 0x180 (384)"]
    pub DeviceTranslatorList: _LIST_ENTRY,
    #[doc = " offset: 0x190 (400)"]
    pub NoTranslatorMask: USHORT,
    #[doc = " offset: 0x192 (402)"]
    pub QueryTranslatorMask: USHORT,
    #[doc = " offset: 0x194 (404)"]
    pub NoArbiterMask: USHORT,
    #[doc = " offset: 0x196 (406)"]
    pub QueryArbiterMask: USHORT,
    #[doc = " offset: 0x198 (408)"]
    pub OverUsed1: _DEVICE_NODE__bindgen_ty_1,
    #[doc = " offset: 0x1a0 (416)"]
    pub OverUsed2: _DEVICE_NODE__bindgen_ty_2,
    #[doc = " offset: 0x1a8 (424)"]
    pub BootResources: *mut _CM_RESOURCE_LIST,
    #[doc = " offset: 0x1b0 (432)"]
    pub BootResourcesTranslated: *mut _CM_RESOURCE_LIST,
    #[doc = " offset: 0x1b8 (440)"]
    pub CapabilityFlags: ULONG,
    #[doc = " offset: 0x1c0 (448)"]
    pub DockInfo: _DEVICE_NODE__bindgen_ty_3,
    #[doc = " offset: 0x1e0 (480)"]
    pub DisableableDepends: ULONG,
    #[doc = " offset: 0x1e8 (488)"]
    pub PendedSetInterfaceState: _LIST_ENTRY,
    #[doc = " offset: 0x1f8 (504)"]
    pub LegacyBusListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x208 (520)"]
    pub DriverUnloadRetryCount: ULONG,
    #[doc = " offset: 0x210 (528)"]
    pub PreviousParent: *mut _DEVICE_NODE,
    #[doc = " offset: 0x218 (536)"]
    pub DeletedChildren: ULONG,
    #[doc = " offset: 0x21c (540)"]
    pub NumaNodeIndex: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_NODE__bindgen_ty_1 {
    #[doc = " offset: 0x198 (408)"]
    pub LegacyDeviceNode: *mut _DEVICE_NODE,
    #[doc = " offset: 0x198 (408)"]
    pub PendingDeviceRelations: *mut _DEVICE_RELATIONS,
    #[doc = " offset: 0x198 (408)"]
    pub Information: *mut VOID,
}
impl Default for _DEVICE_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_NODE__bindgen_ty_2 {
    #[doc = " offset: 0x1a0 (416)"]
    pub NextResourceDeviceNode: *mut _DEVICE_NODE,
}
impl Default for _DEVICE_NODE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DEVICE_NODE__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub DockStatus: PROFILE_STATUS,
    #[doc = " offset: 0x8 (8)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub SerialNumber: *mut USHORT,
}
impl Default for _DEVICE_NODE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DEVICE_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION {
    #[doc = " offset: 0x0 (0)"]
    pub MajorFunction: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub MinorFunction: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub Flags: UCHAR,
    #[doc = " offset: 0x3 (3)"]
    pub Control: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x30 (48)"]
    pub FileObject: *mut _FILE_OBJECT,
    pub CompletionRoutine: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP, arg3: *mut VOID) -> LONG,
    >,
    #[doc = " offset: 0x40 (64)"]
    pub Context: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub Create: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub CreatePipe: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    #[doc = " offset: 0x8 (8)"]
    pub CreateMailslot: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    #[doc = " offset: 0x8 (8)"]
    pub Read: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    #[doc = " offset: 0x8 (8)"]
    pub Write: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    #[doc = " offset: 0x8 (8)"]
    pub QueryDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    #[doc = " offset: 0x8 (8)"]
    pub NotifyDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    #[doc = " offset: 0x8 (8)"]
    pub QueryFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    #[doc = " offset: 0x8 (8)"]
    pub SetFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    #[doc = " offset: 0x8 (8)"]
    pub QueryEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    #[doc = " offset: 0x8 (8)"]
    pub SetEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    #[doc = " offset: 0x8 (8)"]
    pub QueryVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    #[doc = " offset: 0x8 (8)"]
    pub SetVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    #[doc = " offset: 0x8 (8)"]
    pub FileSystemControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    #[doc = " offset: 0x8 (8)"]
    pub LockControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceIoControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    #[doc = " offset: 0x8 (8)"]
    pub QuerySecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    #[doc = " offset: 0x8 (8)"]
    pub SetSecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    #[doc = " offset: 0x8 (8)"]
    pub MountVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    #[doc = " offset: 0x8 (8)"]
    pub VerifyVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    #[doc = " offset: 0x8 (8)"]
    pub Scsi: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    #[doc = " offset: 0x8 (8)"]
    pub QueryQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    #[doc = " offset: 0x8 (8)"]
    pub SetQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    #[doc = " offset: 0x8 (8)"]
    pub QueryDeviceRelations: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    #[doc = " offset: 0x8 (8)"]
    pub QueryInterface: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceCapabilities: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    #[doc = " offset: 0x8 (8)"]
    pub FilterResourceRequirements: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    #[doc = " offset: 0x8 (8)"]
    pub ReadWriteConfig: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    #[doc = " offset: 0x8 (8)"]
    pub SetLock: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    #[doc = " offset: 0x8 (8)"]
    pub QueryId: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    #[doc = " offset: 0x8 (8)"]
    pub QueryDeviceText: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    #[doc = " offset: 0x8 (8)"]
    pub UsageNotification: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    #[doc = " offset: 0x8 (8)"]
    pub WaitWake: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    #[doc = " offset: 0x8 (8)"]
    pub PowerSequence: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    #[doc = " offset: 0x8 (8)"]
    pub Power: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    #[doc = " offset: 0x8 (8)"]
    pub StartDevice: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    #[doc = " offset: 0x8 (8)"]
    pub WMI: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    #[doc = " offset: 0x8 (8)"]
    pub Others: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityContext: *mut _IO_SECURITY_CONTEXT,
    #[doc = " offset: 0x8 (8)"]
    pub Options: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub FileAttributes: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub ShareAccess: USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub EaLength: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityContext: *mut _IO_SECURITY_CONTEXT,
    #[doc = " offset: 0x8 (8)"]
    pub Options: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub ShareAccess: USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub Parameters: *mut _NAMED_PIPE_CREATE_PARAMETERS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityContext: *mut _IO_SECURITY_CONTEXT,
    #[doc = " offset: 0x8 (8)"]
    pub Options: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub Reserved: USHORT,
    #[doc = " offset: 0x12 (18)"]
    pub ShareAccess: USHORT,
    #[doc = " offset: 0x18 (24)"]
    pub Parameters: *mut _MAILSLOT_CREATE_PARAMETERS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Key: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ByteOffset: _LARGE_INTEGER,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Key: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ByteOffset: _LARGE_INTEGER,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FileName: *mut _UNICODE_STRING,
    #[doc = " offset: 0x10 (16)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
    #[doc = " offset: 0x18 (24)"]
    pub FileIndex: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub CompletionFilter: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FileInformationClass: _FILE_INFORMATION_CLASS,
    #[doc = " offset: 0x10 (16)"]
    pub FileObject: *mut _FILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1 {
    pub __bindgen_anon_1:
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub ClusterCount: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DeleteHandle: *mut VOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x18 (24)"]
    pub ReplaceIfExists: UCHAR,
    #[doc = " offset: 0x19 (25)"]
    pub AdvanceOnly: UCHAR,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub EaList: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub EaListLength: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub EaIndex: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FsInformationClass: _FSINFOCLASS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub FsInformationClass: _FSINFOCLASS,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    #[doc = " offset: 0x0 (0)"]
    pub OutputBufferLength: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub InputBufferLength: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub FsControlCode: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Type3InputBuffer: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: *mut _LARGE_INTEGER,
    #[doc = " offset: 0x8 (8)"]
    pub Key: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ByteOffset: _LARGE_INTEGER,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    #[doc = " offset: 0x0 (0)"]
    pub OutputBufferLength: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub InputBufferLength: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub IoControlCode: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Type3InputBuffer: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityInformation: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    #[doc = " offset: 0x0 (0)"]
    pub SecurityInformation: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub SecurityDescriptor: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    #[doc = " offset: 0x0 (0)"]
    pub Vpb: *mut _VPB,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    #[doc = " offset: 0x0 (0)"]
    pub Vpb: *mut _VPB,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    #[doc = " offset: 0x0 (0)"]
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub StartSid: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub SidList: *mut _FILE_GET_QUOTA_INFORMATION,
    #[doc = " offset: 0x18 (24)"]
    pub SidListLength: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    #[doc = " offset: 0x0 (0)"]
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    #[doc = " offset: 0x0 (0)"]
    pub Type: _DEVICE_RELATION_TYPE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    #[doc = " offset: 0x0 (0)"]
    pub InterfaceType: *mut _GUID,
    #[doc = " offset: 0x8 (8)"]
    pub Size: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub Version: USHORT,
    #[doc = " offset: 0x10 (16)"]
    pub Interface: *mut _INTERFACE,
    #[doc = " offset: 0x18 (24)"]
    pub InterfaceSpecificData: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    #[doc = " offset: 0x0 (0)"]
    pub Capabilities: *mut _DEVICE_CAPABILITIES,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    #[doc = " offset: 0x0 (0)"]
    pub IoResourceRequirementList: *mut _IO_RESOURCE_REQUIREMENTS_LIST,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    #[doc = " offset: 0x0 (0)"]
    pub WhichSpace: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Buffer: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Offset: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Length: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    #[doc = " offset: 0x0 (0)"]
    pub Lock: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    #[doc = " offset: 0x0 (0)"]
    pub IdType: BUS_QUERY_ID_TYPE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    #[doc = " offset: 0x0 (0)"]
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    #[doc = " offset: 0x8 (8)"]
    pub LocaleId: ULONG,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    #[doc = " offset: 0x0 (0)"]
    pub InPath: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub Reserved: [UCHAR; 3usize],
    #[doc = " offset: 0x8 (8)"]
    pub Type: _DEVICE_USAGE_NOTIFICATION_TYPE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    #[doc = " offset: 0x0 (0)"]
    pub PowerState: _SYSTEM_POWER_STATE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    #[doc = " offset: 0x0 (0)"]
    pub PowerSequence: *mut _POWER_SEQUENCE,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub Type: _POWER_STATE_TYPE,
    #[doc = " offset: 0x10 (16)"]
    pub State: _POWER_STATE,
    #[doc = " offset: 0x18 (24)"]
    pub ShutdownType: POWER_ACTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub SystemContext: ULONG,
    #[doc = " offset: 0x0 (0)"]
    pub SystemPowerStateContext: _SYSTEM_POWER_STATE_CONTEXT,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    #[doc = " offset: 0x0 (0)"]
    pub AllocatedResources: *mut _CM_RESOURCE_LIST,
    #[doc = " offset: 0x8 (8)"]
    pub AllocatedResourcesTranslated: *mut _CM_RESOURCE_LIST,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    #[doc = " offset: 0x0 (0)"]
    pub ProviderId: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub DataPath: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub BufferSize: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub Buffer: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    #[doc = " offset: 0x0 (0)"]
    pub Argument1: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub Argument2: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Argument3: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Argument4: *mut VOID,
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _IO_STACK_LOCATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _WAIT_CONTEXT_BLOCK {
    #[doc = " offset: 0x0 (0)"]
    pub WaitQueueEntry: _KDEVICE_QUEUE_ENTRY,
    pub DeviceRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _DEVICE_OBJECT,
            arg2: *mut _IRP,
            arg3: *mut VOID,
            arg4: *mut VOID,
        ) -> _IO_ALLOCATION_ACTION,
    >,
    #[doc = " offset: 0x20 (32)"]
    pub DeviceContext: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub NumberOfMapRegisters: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub DeviceObject: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub CurrentIrp: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub BufferChainingDpc: *mut _KDPC,
}
impl Default for _WAIT_CONTEXT_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x8 (8) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TP_DIRECT {
    pub Callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _TP_CALLBACK_INSTANCE,
            arg2: *mut _TP_DIRECT,
            arg3: *mut VOID,
            arg4: *mut _IO_STATUS_BLOCK,
        ),
    >,
}
#[doc = " 0x238 (568) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEB32 {
    #[doc = " offset: 0x0 (0)"]
    pub InheritedAddressSpace: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub ReadImageFileExecOptions: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub BeingDebugged: UCHAR,
    pub __bindgen_anon_1: _PEB32__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub Mutant: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub ImageBaseAddress: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub Ldr: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ProcessParameters: ULONG,
    #[doc = " offset: 0x14 (20)"]
    pub SubSystemData: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub ProcessHeap: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub FastPebLock: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub AtlThunkSListPtr: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub IFEOKey: ULONG,
    pub __bindgen_anon_2: _PEB32__bindgen_ty_2,
    pub __bindgen_anon_3: _PEB32__bindgen_ty_3,
    #[doc = " offset: 0x30 (48)"]
    pub SystemReserved: [ULONG; 1usize],
    #[doc = " offset: 0x34 (52)"]
    pub SpareUlong: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub SparePebPtr0: ULONG,
    #[doc = " offset: 0x3c (60)"]
    pub TlsExpansionCounter: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub TlsBitmap: ULONG,
    #[doc = " offset: 0x44 (68)"]
    pub TlsBitmapBits: [ULONG; 2usize],
    #[doc = " offset: 0x4c (76)"]
    pub ReadOnlySharedMemoryBase: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub HotpatchInformation: ULONG,
    #[doc = " offset: 0x54 (84)"]
    pub ReadOnlyStaticServerData: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub AnsiCodePageData: ULONG,
    #[doc = " offset: 0x5c (92)"]
    pub OemCodePageData: ULONG,
    #[doc = " offset: 0x60 (96)"]
    pub UnicodeCaseTableData: ULONG,
    #[doc = " offset: 0x64 (100)"]
    pub NumberOfProcessors: ULONG,
    #[doc = " offset: 0x68 (104)"]
    pub NtGlobalFlag: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub CriticalSectionTimeout: _LARGE_INTEGER,
    #[doc = " offset: 0x78 (120)"]
    pub HeapSegmentReserve: ULONG,
    #[doc = " offset: 0x7c (124)"]
    pub HeapSegmentCommit: ULONG,
    #[doc = " offset: 0x80 (128)"]
    pub HeapDeCommitTotalFreeThreshold: ULONG,
    #[doc = " offset: 0x84 (132)"]
    pub HeapDeCommitFreeBlockThreshold: ULONG,
    #[doc = " offset: 0x88 (136)"]
    pub NumberOfHeaps: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub MaximumNumberOfHeaps: ULONG,
    #[doc = " offset: 0x90 (144)"]
    pub ProcessHeaps: ULONG,
    #[doc = " offset: 0x94 (148)"]
    pub GdiSharedHandleTable: ULONG,
    #[doc = " offset: 0x98 (152)"]
    pub ProcessStarterHelper: ULONG,
    #[doc = " offset: 0x9c (156)"]
    pub GdiDCAttributeList: ULONG,
    #[doc = " offset: 0xa0 (160)"]
    pub LoaderLock: ULONG,
    #[doc = " offset: 0xa4 (164)"]
    pub OSMajorVersion: ULONG,
    #[doc = " offset: 0xa8 (168)"]
    pub OSMinorVersion: ULONG,
    #[doc = " offset: 0xac (172)"]
    pub OSBuildNumber: USHORT,
    #[doc = " offset: 0xae (174)"]
    pub OSCSDVersion: USHORT,
    #[doc = " offset: 0xb0 (176)"]
    pub OSPlatformId: ULONG,
    #[doc = " offset: 0xb4 (180)"]
    pub ImageSubsystem: ULONG,
    #[doc = " offset: 0xb8 (184)"]
    pub ImageSubsystemMajorVersion: ULONG,
    #[doc = " offset: 0xbc (188)"]
    pub ImageSubsystemMinorVersion: ULONG,
    #[doc = " offset: 0xc0 (192)"]
    pub ActiveProcessAffinityMask: ULONG,
    #[doc = " offset: 0xc4 (196)"]
    pub GdiHandleBuffer: [ULONG; 34usize],
    #[doc = " offset: 0x14c (332)"]
    pub PostProcessInitRoutine: ULONG,
    #[doc = " offset: 0x150 (336)"]
    pub TlsExpansionBitmap: ULONG,
    #[doc = " offset: 0x154 (340)"]
    pub TlsExpansionBitmapBits: [ULONG; 32usize],
    #[doc = " offset: 0x1d4 (468)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0x1d8 (472)"]
    pub AppCompatFlags: _ULARGE_INTEGER,
    #[doc = " offset: 0x1e0 (480)"]
    pub AppCompatFlagsUser: _ULARGE_INTEGER,
    #[doc = " offset: 0x1e8 (488)"]
    pub pShimData: ULONG,
    #[doc = " offset: 0x1ec (492)"]
    pub AppCompatInfo: ULONG,
    #[doc = " offset: 0x1f0 (496)"]
    pub CSDVersion: _STRING32,
    #[doc = " offset: 0x1f8 (504)"]
    pub ActivationContextData: ULONG,
    #[doc = " offset: 0x1fc (508)"]
    pub ProcessAssemblyStorageMap: ULONG,
    #[doc = " offset: 0x200 (512)"]
    pub SystemDefaultActivationContextData: ULONG,
    #[doc = " offset: 0x204 (516)"]
    pub SystemAssemblyStorageMap: ULONG,
    #[doc = " offset: 0x208 (520)"]
    pub MinimumStackCommit: ULONG,
    #[doc = " offset: 0x20c (524)"]
    pub FlsCallback: ULONG,
    #[doc = " offset: 0x210 (528)"]
    pub FlsListHead: LIST_ENTRY32,
    #[doc = " offset: 0x218 (536)"]
    pub FlsBitmap: ULONG,
    #[doc = " offset: 0x21c (540)"]
    pub FlsBitmapBits: [ULONG; 4usize],
    #[doc = " offset: 0x22c (556)"]
    pub FlsHighIndex: ULONG,
    #[doc = " offset: 0x230 (560)"]
    pub WerRegistrationData: ULONG,
    #[doc = " offset: 0x234 (564)"]
    pub WerShipAssertPtr: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_1 {
    #[doc = " offset: 0x3 (3)"]
    pub BitField: UCHAR,
    pub __bindgen_anon_1: _PEB32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PEB32__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PEB32__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ImageUsesLargePages(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageUsesLargePages(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsProtectedProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsProtectedProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsLegacyProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsLegacyProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsImageDynamicallyRelocated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsImageDynamicallyRelocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipPatchingUser32Forwarders(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SkipPatchingUser32Forwarders(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImageUsesLargePages: UCHAR,
        IsProtectedProcess: UCHAR,
        IsLegacyProcess: UCHAR,
        IsImageDynamicallyRelocated: UCHAR,
        SkipPatchingUser32Forwarders: UCHAR,
        SpareBits: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ImageUsesLargePages: u8 = unsafe { ::std::mem::transmute(ImageUsesLargePages) };
            ImageUsesLargePages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsProtectedProcess: u8 = unsafe { ::std::mem::transmute(IsProtectedProcess) };
            IsProtectedProcess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IsLegacyProcess: u8 = unsafe { ::std::mem::transmute(IsLegacyProcess) };
            IsLegacyProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IsImageDynamicallyRelocated: u8 =
                unsafe { ::std::mem::transmute(IsImageDynamicallyRelocated) };
            IsImageDynamicallyRelocated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SkipPatchingUser32Forwarders: u8 =
                unsafe { ::std::mem::transmute(SkipPatchingUser32Forwarders) };
            SkipPatchingUser32Forwarders as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let SpareBits: u8 = unsafe { ::std::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_2 {
    #[doc = " offset: 0x28 (40)"]
    pub CrossProcessFlags: ULONG,
    pub __bindgen_anon_1: _PEB32__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PEB32__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB32__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ProcessInJob(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInJob(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInitializing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInitializing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVEH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVCH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedBits0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedBits0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProcessInJob: ULONG,
        ProcessInitializing: ULONG,
        ProcessUsingVEH: ULONG,
        ProcessUsingVCH: ULONG,
        ReservedBits0: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProcessInJob: u32 = unsafe { ::std::mem::transmute(ProcessInJob) };
            ProcessInJob as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ProcessInitializing: u32 = unsafe { ::std::mem::transmute(ProcessInitializing) };
            ProcessInitializing as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessUsingVEH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVEH) };
            ProcessUsingVEH as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessUsingVCH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVCH) };
            ProcessUsingVCH as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedBits0: u32 = unsafe { ::std::mem::transmute(ReservedBits0) };
            ReservedBits0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB32__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_3 {
    #[doc = " offset: 0x2c (44)"]
    pub KernelCallbackTable: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub UserSharedInfoPtr: ULONG,
}
impl Default for _PEB32__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PEB32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER_TABLE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Time: _ULARGE_INTEGER,
}
impl Default for _KTIMER_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x368 (872) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEB {
    #[doc = " offset: 0x0 (0)"]
    pub InheritedAddressSpace: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub ReadImageFileExecOptions: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub BeingDebugged: UCHAR,
    pub __bindgen_anon_1: _PEB__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub Mutant: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ImageBaseAddress: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Ldr: *mut _PEB_LDR_DATA,
    #[doc = " offset: 0x20 (32)"]
    pub ProcessParameters: *mut _RTL_USER_PROCESS_PARAMETERS,
    #[doc = " offset: 0x28 (40)"]
    pub SubSystemData: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub ProcessHeap: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub FastPebLock: *mut _RTL_CRITICAL_SECTION,
    #[doc = " offset: 0x40 (64)"]
    pub AtlThunkSListPtr: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub IFEOKey: *mut VOID,
    pub __bindgen_anon_2: _PEB__bindgen_ty_2,
    pub __bindgen_anon_3: _PEB__bindgen_ty_3,
    #[doc = " offset: 0x60 (96)"]
    pub SystemReserved: [ULONG; 1usize],
    #[doc = " offset: 0x64 (100)"]
    pub SpareUlong: ULONG,
    #[doc = " offset: 0x68 (104)"]
    pub SparePebPtr0: ULONGLONG,
    #[doc = " offset: 0x70 (112)"]
    pub TlsExpansionCounter: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub TlsBitmap: *mut VOID,
    #[doc = " offset: 0x80 (128)"]
    pub TlsBitmapBits: [ULONG; 2usize],
    #[doc = " offset: 0x88 (136)"]
    pub ReadOnlySharedMemoryBase: *mut VOID,
    #[doc = " offset: 0x90 (144)"]
    pub HotpatchInformation: *mut VOID,
    #[doc = " offset: 0x98 (152)"]
    pub ReadOnlyStaticServerData: *mut *mut VOID,
    #[doc = " offset: 0xa0 (160)"]
    pub AnsiCodePageData: *mut VOID,
    #[doc = " offset: 0xa8 (168)"]
    pub OemCodePageData: *mut VOID,
    #[doc = " offset: 0xb0 (176)"]
    pub UnicodeCaseTableData: *mut VOID,
    #[doc = " offset: 0xb8 (184)"]
    pub NumberOfProcessors: ULONG,
    #[doc = " offset: 0xbc (188)"]
    pub NtGlobalFlag: ULONG,
    #[doc = " offset: 0xc0 (192)"]
    pub CriticalSectionTimeout: _LARGE_INTEGER,
    #[doc = " offset: 0xc8 (200)"]
    pub HeapSegmentReserve: ULONGLONG,
    #[doc = " offset: 0xd0 (208)"]
    pub HeapSegmentCommit: ULONGLONG,
    #[doc = " offset: 0xd8 (216)"]
    pub HeapDeCommitTotalFreeThreshold: ULONGLONG,
    #[doc = " offset: 0xe0 (224)"]
    pub HeapDeCommitFreeBlockThreshold: ULONGLONG,
    #[doc = " offset: 0xe8 (232)"]
    pub NumberOfHeaps: ULONG,
    #[doc = " offset: 0xec (236)"]
    pub MaximumNumberOfHeaps: ULONG,
    #[doc = " offset: 0xf0 (240)"]
    pub ProcessHeaps: *mut *mut VOID,
    #[doc = " offset: 0xf8 (248)"]
    pub GdiSharedHandleTable: *mut VOID,
    #[doc = " offset: 0x100 (256)"]
    pub ProcessStarterHelper: *mut VOID,
    #[doc = " offset: 0x108 (264)"]
    pub GdiDCAttributeList: ULONG,
    #[doc = " offset: 0x110 (272)"]
    pub LoaderLock: *mut _RTL_CRITICAL_SECTION,
    #[doc = " offset: 0x118 (280)"]
    pub OSMajorVersion: ULONG,
    #[doc = " offset: 0x11c (284)"]
    pub OSMinorVersion: ULONG,
    #[doc = " offset: 0x120 (288)"]
    pub OSBuildNumber: USHORT,
    #[doc = " offset: 0x122 (290)"]
    pub OSCSDVersion: USHORT,
    #[doc = " offset: 0x124 (292)"]
    pub OSPlatformId: ULONG,
    #[doc = " offset: 0x128 (296)"]
    pub ImageSubsystem: ULONG,
    #[doc = " offset: 0x12c (300)"]
    pub ImageSubsystemMajorVersion: ULONG,
    #[doc = " offset: 0x130 (304)"]
    pub ImageSubsystemMinorVersion: ULONG,
    #[doc = " offset: 0x138 (312)"]
    pub ActiveProcessAffinityMask: ULONGLONG,
    #[doc = " offset: 0x140 (320)"]
    pub GdiHandleBuffer: [ULONG; 60usize],
    #[doc = " offset: 0x230 (560)"]
    pub PostProcessInitRoutine: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " offset: 0x238 (568)"]
    pub TlsExpansionBitmap: *mut VOID,
    #[doc = " offset: 0x240 (576)"]
    pub TlsExpansionBitmapBits: [ULONG; 32usize],
    #[doc = " offset: 0x2c0 (704)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0x2c8 (712)"]
    pub AppCompatFlags: _ULARGE_INTEGER,
    #[doc = " offset: 0x2d0 (720)"]
    pub AppCompatFlagsUser: _ULARGE_INTEGER,
    #[doc = " offset: 0x2d8 (728)"]
    pub pShimData: *mut VOID,
    #[doc = " offset: 0x2e0 (736)"]
    pub AppCompatInfo: *mut VOID,
    #[doc = " offset: 0x2e8 (744)"]
    pub CSDVersion: _UNICODE_STRING,
    #[doc = " offset: 0x2f8 (760)"]
    pub ActivationContextData: *mut _ACTIVATION_CONTEXT_DATA,
    #[doc = " offset: 0x300 (768)"]
    pub ProcessAssemblyStorageMap: *mut _ASSEMBLY_STORAGE_MAP,
    #[doc = " offset: 0x308 (776)"]
    pub SystemDefaultActivationContextData: *mut _ACTIVATION_CONTEXT_DATA,
    #[doc = " offset: 0x310 (784)"]
    pub SystemAssemblyStorageMap: *mut _ASSEMBLY_STORAGE_MAP,
    #[doc = " offset: 0x318 (792)"]
    pub MinimumStackCommit: ULONGLONG,
    #[doc = " offset: 0x320 (800)"]
    pub FlsCallback: *mut _FLS_CALLBACK_INFO,
    #[doc = " offset: 0x328 (808)"]
    pub FlsListHead: _LIST_ENTRY,
    #[doc = " offset: 0x338 (824)"]
    pub FlsBitmap: *mut VOID,
    #[doc = " offset: 0x340 (832)"]
    pub FlsBitmapBits: [ULONG; 4usize],
    #[doc = " offset: 0x350 (848)"]
    pub FlsHighIndex: ULONG,
    #[doc = " offset: 0x358 (856)"]
    pub WerRegistrationData: *mut VOID,
    #[doc = " offset: 0x360 (864)"]
    pub WerShipAssertPtr: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_1 {
    #[doc = " offset: 0x3 (3)"]
    pub BitField: UCHAR,
    pub __bindgen_anon_1: _PEB__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PEB__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PEB__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ImageUsesLargePages(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageUsesLargePages(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsProtectedProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsProtectedProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsLegacyProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsLegacyProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsImageDynamicallyRelocated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsImageDynamicallyRelocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipPatchingUser32Forwarders(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SkipPatchingUser32Forwarders(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImageUsesLargePages: UCHAR,
        IsProtectedProcess: UCHAR,
        IsLegacyProcess: UCHAR,
        IsImageDynamicallyRelocated: UCHAR,
        SkipPatchingUser32Forwarders: UCHAR,
        SpareBits: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ImageUsesLargePages: u8 = unsafe { ::std::mem::transmute(ImageUsesLargePages) };
            ImageUsesLargePages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsProtectedProcess: u8 = unsafe { ::std::mem::transmute(IsProtectedProcess) };
            IsProtectedProcess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IsLegacyProcess: u8 = unsafe { ::std::mem::transmute(IsLegacyProcess) };
            IsLegacyProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IsImageDynamicallyRelocated: u8 =
                unsafe { ::std::mem::transmute(IsImageDynamicallyRelocated) };
            IsImageDynamicallyRelocated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SkipPatchingUser32Forwarders: u8 =
                unsafe { ::std::mem::transmute(SkipPatchingUser32Forwarders) };
            SkipPatchingUser32Forwarders as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let SpareBits: u8 = unsafe { ::std::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_2 {
    #[doc = " offset: 0x50 (80)"]
    pub CrossProcessFlags: ULONG,
    pub __bindgen_anon_1: _PEB__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PEB__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ProcessInJob(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInJob(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInitializing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInitializing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVEH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVCH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedBits0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedBits0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProcessInJob: ULONG,
        ProcessInitializing: ULONG,
        ProcessUsingVEH: ULONG,
        ProcessUsingVCH: ULONG,
        ReservedBits0: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProcessInJob: u32 = unsafe { ::std::mem::transmute(ProcessInJob) };
            ProcessInJob as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ProcessInitializing: u32 = unsafe { ::std::mem::transmute(ProcessInitializing) };
            ProcessInitializing as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessUsingVEH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVEH) };
            ProcessUsingVEH as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessUsingVCH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVCH) };
            ProcessUsingVCH as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedBits0: u32 = unsafe { ::std::mem::transmute(ReservedBits0) };
            ReservedBits0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_3 {
    #[doc = " offset: 0x58 (88)"]
    pub KernelCallbackTable: *mut VOID,
    #[doc = " offset: 0x58 (88)"]
    pub UserSharedInfoPtr: *mut VOID,
}
impl Default for _PEB__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PEB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1828 (6184) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TEB {
    #[doc = " offset: 0x0 (0)"]
    pub NtTib: _NT_TIB,
    #[doc = " offset: 0x38 (56)"]
    pub EnvironmentPointer: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub ClientId: _CLIENT_ID,
    #[doc = " offset: 0x50 (80)"]
    pub ActiveRpcHandle: *mut VOID,
    #[doc = " offset: 0x58 (88)"]
    pub ThreadLocalStoragePointer: *mut VOID,
    #[doc = " offset: 0x60 (96)"]
    pub ProcessEnvironmentBlock: *mut _PEB,
    #[doc = " offset: 0x68 (104)"]
    pub LastErrorValue: ULONG,
    #[doc = " offset: 0x6c (108)"]
    pub CountOfOwnedCriticalSections: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub CsrClientThread: *mut VOID,
    #[doc = " offset: 0x78 (120)"]
    pub Win32ThreadInfo: *mut VOID,
    #[doc = " offset: 0x80 (128)"]
    pub User32Reserved: [ULONG; 26usize],
    #[doc = " offset: 0xe8 (232)"]
    pub UserReserved: [ULONG; 5usize],
    #[doc = " offset: 0x100 (256)"]
    pub WOW32Reserved: *mut VOID,
    #[doc = " offset: 0x108 (264)"]
    pub CurrentLocale: ULONG,
    #[doc = " offset: 0x10c (268)"]
    pub FpSoftwareStatusRegister: ULONG,
    #[doc = " offset: 0x110 (272)"]
    pub SystemReserved1: [*mut VOID; 54usize],
    #[doc = " offset: 0x2c0 (704)"]
    pub ExceptionCode: LONG,
    #[doc = " offset: 0x2c8 (712)"]
    pub ActivationContextStackPointer: *mut _ACTIVATION_CONTEXT_STACK,
    #[doc = " offset: 0x2d0 (720)"]
    pub SpareBytes1: [UCHAR; 24usize],
    #[doc = " offset: 0x2e8 (744)"]
    pub TxFsContext: ULONG,
    #[doc = " offset: 0x2f0 (752)"]
    pub GdiTebBatch: _GDI_TEB_BATCH,
    #[doc = " offset: 0x7d8 (2008)"]
    pub RealClientId: _CLIENT_ID,
    #[doc = " offset: 0x7e8 (2024)"]
    pub GdiCachedProcessHandle: *mut VOID,
    #[doc = " offset: 0x7f0 (2032)"]
    pub GdiClientPID: ULONG,
    #[doc = " offset: 0x7f4 (2036)"]
    pub GdiClientTID: ULONG,
    #[doc = " offset: 0x7f8 (2040)"]
    pub GdiThreadLocalInfo: *mut VOID,
    #[doc = " offset: 0x800 (2048)"]
    pub Win32ClientInfo: [ULONGLONG; 62usize],
    #[doc = " offset: 0x9f0 (2544)"]
    pub glDispatchTable: [*mut VOID; 233usize],
    #[doc = " offset: 0x1138 (4408)"]
    pub glReserved1: [ULONGLONG; 29usize],
    #[doc = " offset: 0x1220 (4640)"]
    pub glReserved2: *mut VOID,
    #[doc = " offset: 0x1228 (4648)"]
    pub glSectionInfo: *mut VOID,
    #[doc = " offset: 0x1230 (4656)"]
    pub glSection: *mut VOID,
    #[doc = " offset: 0x1238 (4664)"]
    pub glTable: *mut VOID,
    #[doc = " offset: 0x1240 (4672)"]
    pub glCurrentRC: *mut VOID,
    #[doc = " offset: 0x1248 (4680)"]
    pub glContext: *mut VOID,
    #[doc = " offset: 0x1250 (4688)"]
    pub LastStatusValue: ULONG,
    #[doc = " offset: 0x1258 (4696)"]
    pub StaticUnicodeString: _UNICODE_STRING,
    #[doc = " offset: 0x1268 (4712)"]
    pub StaticUnicodeBuffer: [WCHAR; 261usize],
    #[doc = " offset: 0x1478 (5240)"]
    pub DeallocationStack: *mut VOID,
    #[doc = " offset: 0x1480 (5248)"]
    pub TlsSlots: [*mut VOID; 64usize],
    #[doc = " offset: 0x1680 (5760)"]
    pub TlsLinks: _LIST_ENTRY,
    #[doc = " offset: 0x1690 (5776)"]
    pub Vdm: *mut VOID,
    #[doc = " offset: 0x1698 (5784)"]
    pub ReservedForNtRpc: *mut VOID,
    #[doc = " offset: 0x16a0 (5792)"]
    pub DbgSsReserved: [*mut VOID; 2usize],
    #[doc = " offset: 0x16b0 (5808)"]
    pub HardErrorMode: ULONG,
    #[doc = " offset: 0x16b8 (5816)"]
    pub Instrumentation: [*mut VOID; 11usize],
    #[doc = " offset: 0x1710 (5904)"]
    pub ActivityId: _GUID,
    #[doc = " offset: 0x1720 (5920)"]
    pub SubProcessTag: *mut VOID,
    #[doc = " offset: 0x1728 (5928)"]
    pub EtwLocalData: *mut VOID,
    #[doc = " offset: 0x1730 (5936)"]
    pub EtwTraceData: *mut VOID,
    #[doc = " offset: 0x1738 (5944)"]
    pub WinSockData: *mut VOID,
    #[doc = " offset: 0x1740 (5952)"]
    pub GdiBatchCount: ULONG,
    #[doc = " offset: 0x1744 (5956)"]
    pub SpareBool0: UCHAR,
    #[doc = " offset: 0x1745 (5957)"]
    pub SpareBool1: UCHAR,
    #[doc = " offset: 0x1746 (5958)"]
    pub SpareBool2: UCHAR,
    #[doc = " offset: 0x1747 (5959)"]
    pub IdealProcessor: UCHAR,
    #[doc = " offset: 0x1748 (5960)"]
    pub GuaranteedStackBytes: ULONG,
    #[doc = " offset: 0x1750 (5968)"]
    pub ReservedForPerf: *mut VOID,
    #[doc = " offset: 0x1758 (5976)"]
    pub ReservedForOle: *mut VOID,
    #[doc = " offset: 0x1760 (5984)"]
    pub WaitingOnLoaderLock: ULONG,
    #[doc = " offset: 0x1768 (5992)"]
    pub SavedPriorityState: *mut VOID,
    #[doc = " offset: 0x1770 (6000)"]
    pub SoftPatchPtr1: ULONGLONG,
    #[doc = " offset: 0x1778 (6008)"]
    pub ThreadPoolData: *mut VOID,
    #[doc = " offset: 0x1780 (6016)"]
    pub TlsExpansionSlots: *mut *mut VOID,
    #[doc = " offset: 0x1788 (6024)"]
    pub DeallocationBStore: *mut VOID,
    #[doc = " offset: 0x1790 (6032)"]
    pub BStoreLimit: *mut VOID,
    #[doc = " offset: 0x1798 (6040)"]
    pub ImpersonationLocale: ULONG,
    #[doc = " offset: 0x179c (6044)"]
    pub IsImpersonating: ULONG,
    #[doc = " offset: 0x17a0 (6048)"]
    pub NlsCache: *mut VOID,
    #[doc = " offset: 0x17a8 (6056)"]
    pub pShimData: *mut VOID,
    #[doc = " offset: 0x17b0 (6064)"]
    pub HeapVirtualAffinity: ULONG,
    #[doc = " offset: 0x17b8 (6072)"]
    pub CurrentTransactionHandle: *mut VOID,
    #[doc = " offset: 0x17c0 (6080)"]
    pub ActiveFrame: *mut _TEB_ACTIVE_FRAME,
    #[doc = " offset: 0x17c8 (6088)"]
    pub FlsData: *mut VOID,
    #[doc = " offset: 0x17d0 (6096)"]
    pub PreferredLanguages: *mut VOID,
    #[doc = " offset: 0x17d8 (6104)"]
    pub UserPrefLanguages: *mut VOID,
    #[doc = " offset: 0x17e0 (6112)"]
    pub MergedPrefLanguages: *mut VOID,
    #[doc = " offset: 0x17e8 (6120)"]
    pub MuiImpersonation: ULONG,
    pub __bindgen_anon_1: _TEB__bindgen_ty_1,
    pub __bindgen_anon_2: _TEB__bindgen_ty_2,
    #[doc = " offset: 0x17f0 (6128)"]
    pub TxnScopeEnterCallback: *mut VOID,
    #[doc = " offset: 0x17f8 (6136)"]
    pub TxnScopeExitCallback: *mut VOID,
    #[doc = " offset: 0x1800 (6144)"]
    pub TxnScopeContext: *mut VOID,
    #[doc = " offset: 0x1808 (6152)"]
    pub LockCount: ULONG,
    #[doc = " offset: 0x180c (6156)"]
    pub ProcessRundown: ULONG,
    #[doc = " offset: 0x1810 (6160)"]
    pub LastSwitchTime: ULONGLONG,
    #[doc = " offset: 0x1818 (6168)"]
    pub TotalSwitchOutTime: ULONGLONG,
    #[doc = " offset: 0x1820 (6176)"]
    pub WaitReasonBitMap: _LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_1 {
    #[doc = " offset: 0x17ec (6124)"]
    pub CrossTebFlags: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _TEB__bindgen_ty_1 {
    #[inline]
    pub fn SpareCrossTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let SpareCrossTebBits: u16 = unsafe { ::std::mem::transmute(SpareCrossTebBits) };
            SpareCrossTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_2 {
    #[doc = " offset: 0x17ee (6126)"]
    pub SameTebFlags: USHORT,
    pub __bindgen_anon_1: _TEB__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TEB__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn DbgSafeThunkCall(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSafeThunkCall(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgInDebugPrint(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgInDebugPrint(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgHasFiberData(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgHasFiberData(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSkipThreadAttach(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSkipThreadAttach(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgWerInShipAssertCode(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgWerInShipAssertCode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRanProcessInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgRanProcessInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgClonedThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgClonedThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSuppressDebugMsg(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSuppressDebugMsg(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlDisableUserStackWalk(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlDisableUserStackWalk(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlExceptionAttached(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareSameTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgSafeThunkCall: USHORT,
        DbgInDebugPrint: USHORT,
        DbgHasFiberData: USHORT,
        DbgSkipThreadAttach: USHORT,
        DbgWerInShipAssertCode: USHORT,
        DbgRanProcessInit: USHORT,
        DbgClonedThread: USHORT,
        DbgSuppressDebugMsg: USHORT,
        RtlDisableUserStackWalk: USHORT,
        RtlExceptionAttached: USHORT,
        SpareSameTebBits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgSafeThunkCall: u16 = unsafe { ::std::mem::transmute(DbgSafeThunkCall) };
            DbgSafeThunkCall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgInDebugPrint: u16 = unsafe { ::std::mem::transmute(DbgInDebugPrint) };
            DbgInDebugPrint as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgHasFiberData: u16 = unsafe { ::std::mem::transmute(DbgHasFiberData) };
            DbgHasFiberData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgSkipThreadAttach: u16 = unsafe { ::std::mem::transmute(DbgSkipThreadAttach) };
            DbgSkipThreadAttach as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgWerInShipAssertCode: u16 =
                unsafe { ::std::mem::transmute(DbgWerInShipAssertCode) };
            DbgWerInShipAssertCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgRanProcessInit: u16 = unsafe { ::std::mem::transmute(DbgRanProcessInit) };
            DbgRanProcessInit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgClonedThread: u16 = unsafe { ::std::mem::transmute(DbgClonedThread) };
            DbgClonedThread as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DbgSuppressDebugMsg: u16 = unsafe { ::std::mem::transmute(DbgSuppressDebugMsg) };
            DbgSuppressDebugMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RtlDisableUserStackWalk: u16 =
                unsafe { ::std::mem::transmute(RtlDisableUserStackWalk) };
            RtlDisableUserStackWalk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RtlExceptionAttached: u16 = unsafe { ::std::mem::transmute(RtlExceptionAttached) };
            RtlExceptionAttached as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let SpareSameTebBits: u16 = unsafe { ::std::mem::transmute(SpareSameTebBits) };
            SpareSameTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TEB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TEB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x3e8 (1000) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EPROCESS {
    #[doc = " offset: 0x0 (0)"]
    pub Pcb: _KPROCESS,
    #[doc = " offset: 0xc0 (192)"]
    pub ProcessLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0xc8 (200)"]
    pub CreateTime: _LARGE_INTEGER,
    #[doc = " offset: 0xd0 (208)"]
    pub ExitTime: _LARGE_INTEGER,
    #[doc = " offset: 0xd8 (216)"]
    pub RundownProtect: _EX_RUNDOWN_REF,
    #[doc = " offset: 0xe0 (224)"]
    pub UniqueProcessId: *mut VOID,
    #[doc = " offset: 0xe8 (232)"]
    pub ActiveProcessLinks: _LIST_ENTRY,
    #[doc = " offset: 0xf8 (248)"]
    pub QuotaUsage: [ULONGLONG; 3usize],
    #[doc = " offset: 0x110 (272)"]
    pub QuotaPeak: [ULONGLONG; 3usize],
    #[doc = " offset: 0x128 (296)"]
    pub CommitCharge: ULONGLONG,
    #[doc = " offset: 0x130 (304)"]
    pub PeakVirtualSize: ULONGLONG,
    #[doc = " offset: 0x138 (312)"]
    pub VirtualSize: ULONGLONG,
    #[doc = " offset: 0x140 (320)"]
    pub SessionProcessLinks: _LIST_ENTRY,
    #[doc = " offset: 0x150 (336)"]
    pub DebugPort: *mut VOID,
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_1,
    #[doc = " offset: 0x160 (352)"]
    pub ObjectTable: *mut _HANDLE_TABLE,
    #[doc = " offset: 0x168 (360)"]
    pub Token: _EX_FAST_REF,
    #[doc = " offset: 0x170 (368)"]
    pub WorkingSetPage: ULONGLONG,
    #[doc = " offset: 0x178 (376)"]
    pub AddressCreationLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x180 (384)"]
    pub RotateInProgress: *mut _ETHREAD,
    #[doc = " offset: 0x188 (392)"]
    pub ForkInProgress: *mut _ETHREAD,
    #[doc = " offset: 0x190 (400)"]
    pub HardwareTrigger: ULONGLONG,
    #[doc = " offset: 0x198 (408)"]
    pub PhysicalVadRoot: *mut _MM_AVL_TABLE,
    #[doc = " offset: 0x1a0 (416)"]
    pub CloneRoot: *mut VOID,
    #[doc = " offset: 0x1a8 (424)"]
    pub NumberOfPrivatePages: ULONGLONG,
    #[doc = " offset: 0x1b0 (432)"]
    pub NumberOfLockedPages: ULONGLONG,
    #[doc = " offset: 0x1b8 (440)"]
    pub Win32Process: *mut VOID,
    #[doc = " offset: 0x1c0 (448)"]
    pub Job: *mut _EJOB,
    #[doc = " offset: 0x1c8 (456)"]
    pub SectionObject: *mut VOID,
    #[doc = " offset: 0x1d0 (464)"]
    pub SectionBaseAddress: *mut VOID,
    #[doc = " offset: 0x1d8 (472)"]
    pub QuotaBlock: *mut _EPROCESS_QUOTA_BLOCK,
    #[doc = " offset: 0x1e0 (480)"]
    pub WorkingSetWatch: *mut _PAGEFAULT_HISTORY,
    #[doc = " offset: 0x1e8 (488)"]
    pub Win32WindowStation: *mut VOID,
    #[doc = " offset: 0x1f0 (496)"]
    pub InheritedFromUniqueProcessId: *mut VOID,
    #[doc = " offset: 0x1f8 (504)"]
    pub LdtInformation: *mut VOID,
    #[doc = " offset: 0x200 (512)"]
    pub Spare: *mut VOID,
    #[doc = " offset: 0x208 (520)"]
    pub VdmObjects: *mut VOID,
    #[doc = " offset: 0x210 (528)"]
    pub DeviceMap: *mut VOID,
    #[doc = " offset: 0x218 (536)"]
    pub EtwDataSource: *mut VOID,
    #[doc = " offset: 0x220 (544)"]
    pub FreeTebHint: *mut VOID,
    pub __bindgen_anon_2: _EPROCESS__bindgen_ty_2,
    #[doc = " offset: 0x230 (560)"]
    pub Session: *mut VOID,
    #[doc = " offset: 0x238 (568)"]
    pub ImageFileName: [UCHAR; 16usize],
    #[doc = " offset: 0x248 (584)"]
    pub JobLinks: _LIST_ENTRY,
    #[doc = " offset: 0x258 (600)"]
    pub LockedPagesList: *mut VOID,
    #[doc = " offset: 0x260 (608)"]
    pub ThreadListHead: _LIST_ENTRY,
    #[doc = " offset: 0x270 (624)"]
    pub SecurityPort: *mut VOID,
    #[doc = " offset: 0x278 (632)"]
    pub Wow64Process: *mut VOID,
    #[doc = " offset: 0x280 (640)"]
    pub ActiveThreads: ULONG,
    #[doc = " offset: 0x284 (644)"]
    pub ImagePathHash: ULONG,
    #[doc = " offset: 0x288 (648)"]
    pub DefaultHardErrorProcessing: ULONG,
    #[doc = " offset: 0x28c (652)"]
    pub LastThreadExitStatus: LONG,
    #[doc = " offset: 0x290 (656)"]
    pub Peb: *mut _PEB,
    #[doc = " offset: 0x298 (664)"]
    pub PrefetchTrace: _EX_FAST_REF,
    #[doc = " offset: 0x2a0 (672)"]
    pub ReadOperationCount: _LARGE_INTEGER,
    #[doc = " offset: 0x2a8 (680)"]
    pub WriteOperationCount: _LARGE_INTEGER,
    #[doc = " offset: 0x2b0 (688)"]
    pub OtherOperationCount: _LARGE_INTEGER,
    #[doc = " offset: 0x2b8 (696)"]
    pub ReadTransferCount: _LARGE_INTEGER,
    #[doc = " offset: 0x2c0 (704)"]
    pub WriteTransferCount: _LARGE_INTEGER,
    #[doc = " offset: 0x2c8 (712)"]
    pub OtherTransferCount: _LARGE_INTEGER,
    #[doc = " offset: 0x2d0 (720)"]
    pub CommitChargeLimit: ULONGLONG,
    #[doc = " offset: 0x2d8 (728)"]
    pub CommitChargePeak: ULONGLONG,
    #[doc = " offset: 0x2e0 (736)"]
    pub AweInfo: *mut VOID,
    #[doc = " offset: 0x2e8 (744)"]
    pub SeAuditProcessCreationInfo: _SE_AUDIT_PROCESS_CREATION_INFO,
    #[doc = " offset: 0x2f0 (752)"]
    pub Vm: _MMSUPPORT,
    #[doc = " offset: 0x358 (856)"]
    pub MmProcessLinks: _LIST_ENTRY,
    #[doc = " offset: 0x368 (872)"]
    pub ModifiedPageCount: ULONG,
    pub __bindgen_anon_3: _EPROCESS__bindgen_ty_3,
    pub __bindgen_anon_4: _EPROCESS__bindgen_ty_4,
    #[doc = " offset: 0x374 (884)"]
    pub ExitStatus: LONG,
    #[doc = " offset: 0x378 (888)"]
    pub Spare7: USHORT,
    pub __bindgen_anon_5: _EPROCESS__bindgen_ty_5,
    #[doc = " offset: 0x37c (892)"]
    pub PriorityClass: UCHAR,
    #[doc = " offset: 0x380 (896)"]
    pub VadRoot: _MM_AVL_TABLE,
    #[doc = " offset: 0x3c0 (960)"]
    pub Cookie: ULONG,
    #[doc = " offset: 0x3c8 (968)"]
    pub AlpcContext: _ALPC_PROCESS_CONTEXT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_1 {
    #[doc = " offset: 0x158 (344)"]
    pub ExceptionPortData: *mut VOID,
    #[doc = " offset: 0x158 (344)"]
    pub ExceptionPortValue: ULONGLONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _EPROCESS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _EPROCESS__bindgen_ty_1 {
    #[inline]
    pub fn ExceptionPortState(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_ExceptionPortState(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ExceptionPortState: ULONGLONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ExceptionPortState: u64 = unsafe { ::std::mem::transmute(ExceptionPortState) };
            ExceptionPortState as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_2 {
    #[doc = " offset: 0x228 (552)"]
    pub PageDirectoryPte: _HARDWARE_PTE,
    #[doc = " offset: 0x228 (552)"]
    pub Filler: ULONGLONG,
}
impl Default for _EPROCESS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_3 {
    #[doc = " offset: 0x36c (876)"]
    pub Flags2: ULONG,
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EPROCESS__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _EPROCESS__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn JobNotReallyActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JobNotReallyActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccountingFolded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AccountingFolded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NewProcessReported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NewProcessReported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExitProcessReported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExitProcessReported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReportCommitChanges(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReportCommitChanges(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LastReportMemory(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LastReportMemory(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReportPhysicalPageChanges(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReportPhysicalPageChanges(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HandleTableRundown(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HandleTableRundown(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NeedsHandleRundown(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NeedsHandleRundown(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RefTraceEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RefTraceEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NumaAware(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NumaAware(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtectedProcess(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProtectedProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultPagePriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DefaultPagePriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PrimaryTokenFrozen(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrimaryTokenFrozen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessVerifierTarget(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessVerifierTarget(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackRandomizationDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackRandomizationDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AffinityPermanent(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AffinityPermanent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AffinityUpdateEnable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AffinityUpdateEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrossSessionCreate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CrossSessionCreate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        JobNotReallyActive: ULONG,
        AccountingFolded: ULONG,
        NewProcessReported: ULONG,
        ExitProcessReported: ULONG,
        ReportCommitChanges: ULONG,
        LastReportMemory: ULONG,
        ReportPhysicalPageChanges: ULONG,
        HandleTableRundown: ULONG,
        NeedsHandleRundown: ULONG,
        RefTraceEnabled: ULONG,
        NumaAware: ULONG,
        ProtectedProcess: ULONG,
        DefaultPagePriority: ULONG,
        PrimaryTokenFrozen: ULONG,
        ProcessVerifierTarget: ULONG,
        StackRandomizationDisabled: ULONG,
        AffinityPermanent: ULONG,
        AffinityUpdateEnable: ULONG,
        CrossSessionCreate: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let JobNotReallyActive: u32 = unsafe { ::std::mem::transmute(JobNotReallyActive) };
            JobNotReallyActive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AccountingFolded: u32 = unsafe { ::std::mem::transmute(AccountingFolded) };
            AccountingFolded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NewProcessReported: u32 = unsafe { ::std::mem::transmute(NewProcessReported) };
            NewProcessReported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ExitProcessReported: u32 = unsafe { ::std::mem::transmute(ExitProcessReported) };
            ExitProcessReported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ReportCommitChanges: u32 = unsafe { ::std::mem::transmute(ReportCommitChanges) };
            ReportCommitChanges as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LastReportMemory: u32 = unsafe { ::std::mem::transmute(LastReportMemory) };
            LastReportMemory as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ReportPhysicalPageChanges: u32 =
                unsafe { ::std::mem::transmute(ReportPhysicalPageChanges) };
            ReportPhysicalPageChanges as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HandleTableRundown: u32 = unsafe { ::std::mem::transmute(HandleTableRundown) };
            HandleTableRundown as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let NeedsHandleRundown: u32 = unsafe { ::std::mem::transmute(NeedsHandleRundown) };
            NeedsHandleRundown as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RefTraceEnabled: u32 = unsafe { ::std::mem::transmute(RefTraceEnabled) };
            RefTraceEnabled as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let NumaAware: u32 = unsafe { ::std::mem::transmute(NumaAware) };
            NumaAware as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ProtectedProcess: u32 = unsafe { ::std::mem::transmute(ProtectedProcess) };
            ProtectedProcess as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let DefaultPagePriority: u32 = unsafe { ::std::mem::transmute(DefaultPagePriority) };
            DefaultPagePriority as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PrimaryTokenFrozen: u32 = unsafe { ::std::mem::transmute(PrimaryTokenFrozen) };
            PrimaryTokenFrozen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ProcessVerifierTarget: u32 =
                unsafe { ::std::mem::transmute(ProcessVerifierTarget) };
            ProcessVerifierTarget as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let StackRandomizationDisabled: u32 =
                unsafe { ::std::mem::transmute(StackRandomizationDisabled) };
            StackRandomizationDisabled as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let AffinityPermanent: u32 = unsafe { ::std::mem::transmute(AffinityPermanent) };
            AffinityPermanent as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let AffinityUpdateEnable: u32 = unsafe { ::std::mem::transmute(AffinityUpdateEnable) };
            AffinityUpdateEnable as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let CrossSessionCreate: u32 = unsafe { ::std::mem::transmute(CrossSessionCreate) };
            CrossSessionCreate as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPROCESS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_4 {
    #[doc = " offset: 0x370 (880)"]
    pub Flags: ULONG,
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EPROCESS__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _EPROCESS__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn CreateReported(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CreateReported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDebugInherit(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDebugInherit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessExiting(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessExiting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessDelete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessDelete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wow64SplitPages(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wow64SplitPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VmDeleted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VmDeleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OutswapEnabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OutswapEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Outswapped(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Outswapped(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForkFailed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForkFailed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wow64VaSpace4Gb(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wow64VaSpace4Gb(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AddressSpaceInitialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AddressSpaceInitialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SetTimerResolution(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetTimerResolution(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BreakOnTermination(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BreakOnTermination(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeprioritizeViews(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeprioritizeViews(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteWatch(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteWatch(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInSession(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInSession(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OverrideAddressSpace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OverrideAddressSpace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasAddressSpace(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasAddressSpace(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LaunchPrefetched(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LaunchPrefetched(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InjectInpageErrors(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InjectInpageErrors(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VmTopDown(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VmTopDown(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageNotifyDone(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImageNotifyDone(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PdeUpdateNeeded(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PdeUpdateNeeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VdmAllowed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VdmAllowed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmapAllowed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SmapAllowed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInserted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DefaultIoPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DefaultIoPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessSelfDelete(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessSelfDelete(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareProcessFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SpareProcessFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CreateReported: ULONG,
        NoDebugInherit: ULONG,
        ProcessExiting: ULONG,
        ProcessDelete: ULONG,
        Wow64SplitPages: ULONG,
        VmDeleted: ULONG,
        OutswapEnabled: ULONG,
        Outswapped: ULONG,
        ForkFailed: ULONG,
        Wow64VaSpace4Gb: ULONG,
        AddressSpaceInitialized: ULONG,
        SetTimerResolution: ULONG,
        BreakOnTermination: ULONG,
        DeprioritizeViews: ULONG,
        WriteWatch: ULONG,
        ProcessInSession: ULONG,
        OverrideAddressSpace: ULONG,
        HasAddressSpace: ULONG,
        LaunchPrefetched: ULONG,
        InjectInpageErrors: ULONG,
        VmTopDown: ULONG,
        ImageNotifyDone: ULONG,
        PdeUpdateNeeded: ULONG,
        VdmAllowed: ULONG,
        SmapAllowed: ULONG,
        ProcessInserted: ULONG,
        DefaultIoPriority: ULONG,
        ProcessSelfDelete: ULONG,
        SpareProcessFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CreateReported: u32 = unsafe { ::std::mem::transmute(CreateReported) };
            CreateReported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoDebugInherit: u32 = unsafe { ::std::mem::transmute(NoDebugInherit) };
            NoDebugInherit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessExiting: u32 = unsafe { ::std::mem::transmute(ProcessExiting) };
            ProcessExiting as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessDelete: u32 = unsafe { ::std::mem::transmute(ProcessDelete) };
            ProcessDelete as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Wow64SplitPages: u32 = unsafe { ::std::mem::transmute(Wow64SplitPages) };
            Wow64SplitPages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let VmDeleted: u32 = unsafe { ::std::mem::transmute(VmDeleted) };
            VmDeleted as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OutswapEnabled: u32 = unsafe { ::std::mem::transmute(OutswapEnabled) };
            OutswapEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Outswapped: u32 = unsafe { ::std::mem::transmute(Outswapped) };
            Outswapped as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ForkFailed: u32 = unsafe { ::std::mem::transmute(ForkFailed) };
            ForkFailed as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Wow64VaSpace4Gb: u32 = unsafe { ::std::mem::transmute(Wow64VaSpace4Gb) };
            Wow64VaSpace4Gb as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let AddressSpaceInitialized: u32 =
                unsafe { ::std::mem::transmute(AddressSpaceInitialized) };
            AddressSpaceInitialized as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SetTimerResolution: u32 = unsafe { ::std::mem::transmute(SetTimerResolution) };
            SetTimerResolution as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let BreakOnTermination: u32 = unsafe { ::std::mem::transmute(BreakOnTermination) };
            BreakOnTermination as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let DeprioritizeViews: u32 = unsafe { ::std::mem::transmute(DeprioritizeViews) };
            DeprioritizeViews as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WriteWatch: u32 = unsafe { ::std::mem::transmute(WriteWatch) };
            WriteWatch as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ProcessInSession: u32 = unsafe { ::std::mem::transmute(ProcessInSession) };
            ProcessInSession as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let OverrideAddressSpace: u32 = unsafe { ::std::mem::transmute(OverrideAddressSpace) };
            OverrideAddressSpace as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let HasAddressSpace: u32 = unsafe { ::std::mem::transmute(HasAddressSpace) };
            HasAddressSpace as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let LaunchPrefetched: u32 = unsafe { ::std::mem::transmute(LaunchPrefetched) };
            LaunchPrefetched as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let InjectInpageErrors: u32 = unsafe { ::std::mem::transmute(InjectInpageErrors) };
            InjectInpageErrors as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let VmTopDown: u32 = unsafe { ::std::mem::transmute(VmTopDown) };
            VmTopDown as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ImageNotifyDone: u32 = unsafe { ::std::mem::transmute(ImageNotifyDone) };
            ImageNotifyDone as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let PdeUpdateNeeded: u32 = unsafe { ::std::mem::transmute(PdeUpdateNeeded) };
            PdeUpdateNeeded as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let VdmAllowed: u32 = unsafe { ::std::mem::transmute(VdmAllowed) };
            VdmAllowed as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let SmapAllowed: u32 = unsafe { ::std::mem::transmute(SmapAllowed) };
            SmapAllowed as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ProcessInserted: u32 = unsafe { ::std::mem::transmute(ProcessInserted) };
            ProcessInserted as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let DefaultIoPriority: u32 = unsafe { ::std::mem::transmute(DefaultIoPriority) };
            DefaultIoPriority as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ProcessSelfDelete: u32 = unsafe { ::std::mem::transmute(ProcessSelfDelete) };
            ProcessSelfDelete as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let SpareProcessFlags: u32 = unsafe { ::std::mem::transmute(SpareProcessFlags) };
            SpareProcessFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _EPROCESS__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EPROCESS__bindgen_ty_5 {
    pub __bindgen_anon_1: _EPROCESS__bindgen_ty_5__bindgen_ty_1,
    #[doc = " offset: 0x37a (890)"]
    pub SubSystemVersion: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _EPROCESS__bindgen_ty_5__bindgen_ty_1 {
    #[doc = " offset: 0x37a (890)"]
    pub SubSystemMinorVersion: UCHAR,
    #[doc = " offset: 0x37b (891)"]
    pub SubSystemMajorVersion: UCHAR,
}
impl Default for _EPROCESS__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _EPROCESS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x100 (256) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPCP_PORT_OBJECT {
    #[doc = " offset: 0x0 (0)"]
    pub ConnectionPort: *mut _LPCP_PORT_OBJECT,
    #[doc = " offset: 0x8 (8)"]
    pub ConnectedPort: *mut _LPCP_PORT_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub MsgQueue: _LPCP_PORT_QUEUE,
    #[doc = " offset: 0x30 (48)"]
    pub Creator: _CLIENT_ID,
    #[doc = " offset: 0x40 (64)"]
    pub ClientSectionBase: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub ServerSectionBase: *mut VOID,
    #[doc = " offset: 0x50 (80)"]
    pub PortContext: *mut VOID,
    #[doc = " offset: 0x58 (88)"]
    pub ClientThread: *mut _ETHREAD,
    #[doc = " offset: 0x60 (96)"]
    pub SecurityQos: _SECURITY_QUALITY_OF_SERVICE,
    #[doc = " offset: 0x70 (112)"]
    pub StaticSecurity: _SECURITY_CLIENT_CONTEXT,
    #[doc = " offset: 0xb8 (184)"]
    pub LpcReplyChainHead: _LIST_ENTRY,
    #[doc = " offset: 0xc8 (200)"]
    pub LpcDataInfoChainHead: _LIST_ENTRY,
    pub __bindgen_anon_1: _LPCP_PORT_OBJECT__bindgen_ty_1,
    #[doc = " offset: 0xe0 (224)"]
    pub MaxMessageLength: USHORT,
    #[doc = " offset: 0xe2 (226)"]
    pub MaxConnectionInfoLength: USHORT,
    #[doc = " offset: 0xe4 (228)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xe8 (232)"]
    pub WaitEvent: _KEVENT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LPCP_PORT_OBJECT__bindgen_ty_1 {
    #[doc = " offset: 0xd8 (216)"]
    pub ServerProcess: *mut _EPROCESS,
    #[doc = " offset: 0xd8 (216)"]
    pub MappingProcess: *mut _EPROCESS,
}
impl Default for _LPCP_PORT_OBJECT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _LPCP_PORT_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REG_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub RegList: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub GuidEntry: *mut _ETW_GUID_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub Index: USHORT,
    #[doc = " offset: 0x1a (26)"]
    pub Flags: USHORT,
    #[doc = " offset: 0x1c (28)"]
    pub EnableMask: UCHAR,
    pub __bindgen_anon_1: _ETW_REG_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _ETW_REG_ENTRY__bindgen_ty_2,
    #[doc = " offset: 0x48 (72)"]
    pub CallbackContext: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_REG_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub ReplyQueue: *mut _ETW_REPLY_QUEUE,
    #[doc = " offset: 0x20 (32)"]
    pub ReplySlot: [*mut _ETW_REG_ENTRY; 4usize],
}
impl Default for _ETW_REG_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_REG_ENTRY__bindgen_ty_2 {
    #[doc = " offset: 0x40 (64)"]
    pub Process: *mut _EPROCESS,
    #[doc = " offset: 0x40 (64)"]
    pub Callback: *mut VOID,
}
impl Default for _ETW_REG_ENTRY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETW_REG_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ETW_PROVIDER_TABLE_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub RefCount: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub State: _ETW_PROVIDER_STATE,
    #[doc = " offset: 0x8 (8)"]
    pub RegEntry: *mut _ETW_REG_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Caller: *mut VOID,
}
impl Default for _ETW_PROVIDER_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POOL_HEADER {
    pub __bindgen_anon_1: _POOL_HEADER__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub PoolTag: ULONG,
    pub __bindgen_anon_2: _POOL_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POOL_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _POOL_HEADER__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x0 (0)"]
    pub Ulong1: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POOL_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _POOL_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn PreviousSize(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolIndex(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PoolIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn BlockSize(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BlockSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PoolType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PoolType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PreviousSize: ULONG,
        PoolIndex: ULONG,
        BlockSize: ULONG,
        PoolType: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PreviousSize: u32 = unsafe { ::std::mem::transmute(PreviousSize) };
            PreviousSize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let PoolIndex: u32 = unsafe { ::std::mem::transmute(PoolIndex) };
            PoolIndex as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let BlockSize: u32 = unsafe { ::std::mem::transmute(BlockSize) };
            BlockSize as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let PoolType: u32 = unsafe { ::std::mem::transmute(PoolType) };
            PoolType as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _POOL_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POOL_HEADER__bindgen_ty_2 {
    #[doc = " offset: 0x8 (8)"]
    pub ProcessBilled: *mut _EPROCESS,
    pub __bindgen_anon_1: _POOL_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _POOL_HEADER__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub AllocatorBackTraceIndex: USHORT,
    #[doc = " offset: 0xa (10)"]
    pub PoolTagHash: USHORT,
}
impl Default for _POOL_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _POOL_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POOL_HACKER {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _POOL_HEADER,
    #[doc = " offset: 0x10 (16)"]
    pub Contents: [ULONG; 8usize],
}
impl Default for _POOL_HACKER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POOL_BLOCK_HEAD {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _POOL_HEADER,
    #[doc = " offset: 0x10 (16)"]
    pub List: _LIST_ENTRY,
}
impl Default for _POOL_BLOCK_HEAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_SECURITY_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub HandleTable: *mut _ALPC_HANDLE_TABLE,
    #[doc = " offset: 0x8 (8)"]
    pub ContextHandle: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub OwningProcess: *mut _EPROCESS,
    #[doc = " offset: 0x18 (24)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x20 (32)"]
    pub DynamicSecurity: _SECURITY_CLIENT_CONTEXT,
    #[doc = " offset: 0x68 (104)"]
    pub u1: _KALPC_SECURITY_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_SECURITY_DATA__bindgen_ty_1 {
    #[doc = " offset: 0x68 (104)"]
    pub s1: _KALPC_SECURITY_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_SECURITY_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_SECURITY_DATA__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Revoked(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Revoked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Impersonated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Impersonated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Revoked: ULONG,
        Impersonated: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Revoked: u32 = unsafe { ::std::mem::transmute(Revoked) };
            Revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Impersonated: u32 = unsafe { ::std::mem::transmute(Impersonated) };
            Impersonated as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_SECURITY_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_SECURITY_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x98 (152) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_COMPLETION_LIST {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = " offset: 0x18 (24)"]
    pub Mdl: *mut _MDL,
    #[doc = " offset: 0x20 (32)"]
    pub UserVa: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub UserLimit: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub DataUserVa: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub SystemVa: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub TotalSize: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub Header: *mut _ALPC_COMPLETION_LIST_HEADER,
    #[doc = " offset: 0x50 (80)"]
    pub List: *mut VOID,
    #[doc = " offset: 0x58 (88)"]
    pub ListSize: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub Bitmap: *mut VOID,
    #[doc = " offset: 0x68 (104)"]
    pub BitmapSize: ULONGLONG,
    #[doc = " offset: 0x70 (112)"]
    pub Data: *mut VOID,
    #[doc = " offset: 0x78 (120)"]
    pub DataSize: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub BitmapLimit: ULONG,
    #[doc = " offset: 0x84 (132)"]
    pub BitmapNextHint: ULONG,
    #[doc = " offset: 0x88 (136)"]
    pub ConcurrencyCount: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub AttributeFlags: ULONG,
    #[doc = " offset: 0x90 (144)"]
    pub AttributeSize: ULONG,
}
impl Default for _ALPC_COMPLETION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_SECTION {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _KALPC_SECTION__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub SectionObject: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Size: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub HandleTable: *mut _ALPC_HANDLE_TABLE,
    #[doc = " offset: 0x20 (32)"]
    pub SectionHandle: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = " offset: 0x30 (48)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x38 (56)"]
    pub NumberOfRegions: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub RegionListHead: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_SECTION__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub s1: _KALPC_SECTION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_SECTION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_SECTION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Internal(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Internal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Secure(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Secure(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Internal: ULONG, Secure: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Internal: u32 = unsafe { ::std::mem::transmute(Internal) };
            Internal as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Secure: u32 = unsafe { ::std::mem::transmute(Secure) };
            Secure as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_SECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_REGION {
    #[doc = " offset: 0x0 (0)"]
    pub u1: _KALPC_REGION__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub RegionListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub Section: *mut _KALPC_SECTION,
    #[doc = " offset: 0x20 (32)"]
    pub Offset: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub Size: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub ViewSize: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub ReadOnlyView: *mut _KALPC_VIEW,
    #[doc = " offset: 0x40 (64)"]
    pub ReadWriteView: *mut _KALPC_VIEW,
    #[doc = " offset: 0x48 (72)"]
    pub NumberOfViews: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub ViewListHead: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_REGION__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub s1: _KALPC_REGION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_REGION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_REGION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Secure(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Secure(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Secure: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Secure: u32 = unsafe { ::std::mem::transmute(Secure) };
            Secure as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_REGION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_REGION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_VIEW {
    #[doc = " offset: 0x0 (0)"]
    pub ViewListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub u1: _KALPC_VIEW__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub Region: *mut _KALPC_REGION,
    #[doc = " offset: 0x20 (32)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x28 (40)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = " offset: 0x30 (48)"]
    pub Address: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub Size: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub SecureViewHandle: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub WriteAccessHandle: *mut VOID,
    #[doc = " offset: 0x50 (80)"]
    pub NumberOfOwnerMessages: ULONG,
    #[doc = " offset: 0x58 (88)"]
    pub ProcessViewListEntry: _LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_VIEW__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub s1: _KALPC_VIEW__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_VIEW__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _KALPC_VIEW__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn WriteAccess(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteAccess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AutoRelease(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoRelease(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceUnlink(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForceUnlink(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WriteAccess: ULONG,
        AutoRelease: ULONG,
        ForceUnlink: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WriteAccess: u32 = unsafe { ::std::mem::transmute(WriteAccess) };
            WriteAccess as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AutoRelease: u32 = unsafe { ::std::mem::transmute(AutoRelease) };
            AutoRelease as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ForceUnlink: u32 = unsafe { ::std::mem::transmute(ForceUnlink) };
            ForceUnlink as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_VIEW__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_VIEW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KRESOURCEMANAGER_COMPLETION_BINDING {
    #[doc = " offset: 0x0 (0)"]
    pub NotificationListHead: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Port: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Key: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub BindingProcess: *mut _EPROCESS,
}
impl Default for _KRESOURCEMANAGER_COMPLETION_BINDING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x250 (592) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KRESOURCEMANAGER {
    #[doc = " offset: 0x0 (0)"]
    pub NotificationAvailable: _KEVENT,
    #[doc = " offset: 0x18 (24)"]
    pub cookie: ULONG,
    #[doc = " offset: 0x1c (28)"]
    pub State: _KRESOURCEMANAGER_STATE,
    #[doc = " offset: 0x20 (32)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub Mutex: _KMUTANT,
    #[doc = " offset: 0x60 (96)"]
    pub NamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = " offset: 0x88 (136)"]
    pub RmId: _GUID,
    #[doc = " offset: 0x98 (152)"]
    pub NotificationQueue: _KQUEUE,
    #[doc = " offset: 0xd8 (216)"]
    pub NotificationMutex: _KMUTANT,
    #[doc = " offset: 0x110 (272)"]
    pub EnlistmentHead: _LIST_ENTRY,
    #[doc = " offset: 0x120 (288)"]
    pub EnlistmentCount: ULONG,
    pub NotificationRoutine: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _KENLISTMENT,
            arg2: *mut VOID,
            arg3: *mut VOID,
            arg4: ULONG,
            arg5: *mut _LARGE_INTEGER,
            arg6: ULONG,
            arg7: *mut VOID,
        ) -> LONG,
    >,
    #[doc = " offset: 0x130 (304)"]
    pub Key: *mut VOID,
    #[doc = " offset: 0x138 (312)"]
    pub ProtocolListHead: _LIST_ENTRY,
    #[doc = " offset: 0x148 (328)"]
    pub PendingPropReqListHead: _LIST_ENTRY,
    #[doc = " offset: 0x158 (344)"]
    pub CRMListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x168 (360)"]
    pub Tm: *mut _KTM,
    #[doc = " offset: 0x170 (368)"]
    pub Description: _UNICODE_STRING,
    #[doc = " offset: 0x180 (384)"]
    pub Enlistments: _KTMOBJECT_NAMESPACE,
    #[doc = " offset: 0x228 (552)"]
    pub CompletionBinding: _KRESOURCEMANAGER_COMPLETION_BINDING,
}
impl Default for _KRESOURCEMANAGER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x3a0 (928) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTM {
    #[doc = " offset: 0x0 (0)"]
    pub cookie: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub Mutex: _KMUTANT,
    #[doc = " offset: 0x40 (64)"]
    pub State: KTM_STATE,
    #[doc = " offset: 0x48 (72)"]
    pub NamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = " offset: 0x70 (112)"]
    pub TmIdentity: _GUID,
    #[doc = " offset: 0x80 (128)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x84 (132)"]
    pub VolatileFlags: ULONG,
    #[doc = " offset: 0x88 (136)"]
    pub LogFileName: _UNICODE_STRING,
    #[doc = " offset: 0x98 (152)"]
    pub LogFileObject: *mut _FILE_OBJECT,
    #[doc = " offset: 0xa0 (160)"]
    pub MarshallingContext: *mut VOID,
    #[doc = " offset: 0xa8 (168)"]
    pub LogManagementContext: *mut VOID,
    #[doc = " offset: 0xb0 (176)"]
    pub Transactions: _KTMOBJECT_NAMESPACE,
    #[doc = " offset: 0x158 (344)"]
    pub ResourceManagers: _KTMOBJECT_NAMESPACE,
    #[doc = " offset: 0x200 (512)"]
    pub LsnOrderedMutex: _KMUTANT,
    #[doc = " offset: 0x238 (568)"]
    pub LsnOrderedList: _LIST_ENTRY,
    #[doc = " offset: 0x248 (584)"]
    pub CommitVirtualClock: _LARGE_INTEGER,
    #[doc = " offset: 0x250 (592)"]
    pub CommitVirtualClockMutex: _FAST_MUTEX,
    #[doc = " offset: 0x288 (648)"]
    pub BaseLsn: _CLS_LSN,
    #[doc = " offset: 0x290 (656)"]
    pub CurrentReadLsn: _CLS_LSN,
    #[doc = " offset: 0x298 (664)"]
    pub LastRecoveredLsn: _CLS_LSN,
    #[doc = " offset: 0x2a0 (672)"]
    pub TmRmHandle: *mut VOID,
    #[doc = " offset: 0x2a8 (680)"]
    pub TmRm: *mut _KRESOURCEMANAGER,
    #[doc = " offset: 0x2b0 (688)"]
    pub LogFullNotifyEvent: _KEVENT,
    #[doc = " offset: 0x2c8 (712)"]
    pub CheckpointWorkItem: _WORK_QUEUE_ITEM,
    #[doc = " offset: 0x2e8 (744)"]
    pub CheckpointTargetLsn: _CLS_LSN,
    #[doc = " offset: 0x2f0 (752)"]
    pub LogFullCompletedWorkItem: _WORK_QUEUE_ITEM,
    #[doc = " offset: 0x310 (784)"]
    pub LogWriteResource: _ERESOURCE,
    #[doc = " offset: 0x378 (888)"]
    pub LogFlags: ULONG,
    #[doc = " offset: 0x37c (892)"]
    pub LogFullStatus: LONG,
    #[doc = " offset: 0x380 (896)"]
    pub RecoveryStatus: LONG,
    #[doc = " offset: 0x388 (904)"]
    pub LastCheckBaseLsn: _CLS_LSN,
    #[doc = " offset: 0x390 (912)"]
    pub RestartOrderedList: _LIST_ENTRY,
}
impl Default for _KTM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1e0 (480) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KENLISTMENT {
    #[doc = " offset: 0x0 (0)"]
    pub cookie: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub NamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = " offset: 0x30 (48)"]
    pub EnlistmentId: _GUID,
    #[doc = " offset: 0x40 (64)"]
    pub Mutex: _KMUTANT,
    #[doc = " offset: 0x78 (120)"]
    pub NextSameTx: _LIST_ENTRY,
    #[doc = " offset: 0x88 (136)"]
    pub NextSameRm: _LIST_ENTRY,
    #[doc = " offset: 0x98 (152)"]
    pub ResourceManager: *mut _KRESOURCEMANAGER,
    #[doc = " offset: 0xa0 (160)"]
    pub Transaction: *mut _KTRANSACTION,
    #[doc = " offset: 0xa8 (168)"]
    pub State: _KENLISTMENT_STATE,
    #[doc = " offset: 0xac (172)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xb0 (176)"]
    pub NotificationMask: ULONG,
    #[doc = " offset: 0xb8 (184)"]
    pub Key: *mut VOID,
    #[doc = " offset: 0xc0 (192)"]
    pub KeyRefCount: ULONG,
    #[doc = " offset: 0xc8 (200)"]
    pub RecoveryInformation: *mut VOID,
    #[doc = " offset: 0xd0 (208)"]
    pub RecoveryInformationLength: ULONG,
    #[doc = " offset: 0xd8 (216)"]
    pub DynamicNameInformation: *mut VOID,
    #[doc = " offset: 0xe0 (224)"]
    pub DynamicNameInformationLength: ULONG,
    #[doc = " offset: 0xe8 (232)"]
    pub FinalNotification: *mut _KTMNOTIFICATION_PACKET,
    #[doc = " offset: 0xf0 (240)"]
    pub SupSubEnlistment: *mut _KENLISTMENT,
    #[doc = " offset: 0xf8 (248)"]
    pub SupSubEnlHandle: *mut VOID,
    #[doc = " offset: 0x100 (256)"]
    pub SubordinateTxHandle: *mut VOID,
    #[doc = " offset: 0x108 (264)"]
    pub CrmEnlistmentEnId: _GUID,
    #[doc = " offset: 0x118 (280)"]
    pub CrmEnlistmentTmId: _GUID,
    #[doc = " offset: 0x128 (296)"]
    pub CrmEnlistmentRmId: _GUID,
    #[doc = " offset: 0x138 (312)"]
    pub NextHistory: ULONG,
    #[doc = " offset: 0x13c (316)"]
    pub History: [_KENLISTMENT_HISTORY; 20usize],
}
impl Default for _KENLISTMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x50 (80) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SEGMENT {
    #[doc = " offset: 0x0 (0)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = " offset: 0x8 (8)"]
    pub TotalNumberOfPtes: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub SegmentFlags: _SEGMENT_FLAGS,
    #[doc = " offset: 0x10 (16)"]
    pub NumberOfCommittedPages: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub SizeOfSegment: ULONGLONG,
    pub __bindgen_anon_1: _SEGMENT__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub SegmentLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x30 (48)"]
    pub u1: _SEGMENT__bindgen_ty_2,
    #[doc = " offset: 0x38 (56)"]
    pub u2: _SEGMENT__bindgen_ty_3,
    #[doc = " offset: 0x40 (64)"]
    pub PrototypePte: *mut _MMPTE,
    #[doc = " offset: 0x48 (72)"]
    pub ThePtes: [_MMPTE; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub ExtendInfo: *mut _MMEXTEND_INFO,
    #[doc = " offset: 0x20 (32)"]
    pub BasedAddress: *mut VOID,
}
impl Default for _SEGMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT__bindgen_ty_2 {
    #[doc = " offset: 0x30 (48)"]
    pub ImageCommitment: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub CreatingProcess: *mut _EPROCESS,
}
impl Default for _SEGMENT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SEGMENT__bindgen_ty_3 {
    #[doc = " offset: 0x38 (56)"]
    pub ImageInformation: *mut _MI_SECTION_IMAGE_INFORMATION,
    #[doc = " offset: 0x38 (56)"]
    pub FirstMappedVa: *mut VOID,
}
impl Default for _SEGMENT__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SEGMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CONTROL_AREA {
    #[doc = " offset: 0x0 (0)"]
    pub Segment: *mut _SEGMENT,
    #[doc = " offset: 0x8 (8)"]
    pub DereferenceList: _LIST_ENTRY,
    #[doc = " offset: 0x18 (24)"]
    pub NumberOfSectionReferences: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub NumberOfPfnReferences: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub NumberOfMappedViews: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub NumberOfUserReferences: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub u: _CONTROL_AREA__bindgen_ty_1,
    #[doc = " offset: 0x3c (60)"]
    pub u1: _CONTROL_AREA__bindgen_ty_2,
    #[doc = " offset: 0x40 (64)"]
    pub FilePointer: _EX_FAST_REF,
    #[doc = " offset: 0x48 (72)"]
    pub ControlAreaLock: LONG,
    #[doc = " offset: 0x4c (76)"]
    pub StartingFrame: ULONG,
    #[doc = " offset: 0x50 (80)"]
    pub WaitingForDeletion: *mut _MI_SECTION_CREATION_GATE,
    #[doc = " offset: 0x58 (88)"]
    pub u2: _CONTROL_AREA__bindgen_ty_3,
    #[doc = " offset: 0x68 (104)"]
    pub LockedPages: LONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_1 {
    #[doc = " offset: 0x38 (56)"]
    pub LongFlags: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub Flags: _MMSECTION_FLAGS,
}
impl Default for _CONTROL_AREA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_2 {
    #[doc = " offset: 0x3c (60)"]
    pub e2: _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CONTROL_AREA__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub ModifiedWriteCount: USHORT,
    #[doc = " offset: 0x2 (2)"]
    pub FlushInProgressCount: USHORT,
}
impl Default for _CONTROL_AREA__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_3 {
    #[doc = " offset: 0x58 (88)"]
    pub e2: _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub NumberOfSystemCacheViews: ULONG,
    #[doc = " offset: 0x0 (0)"]
    pub ImageRelocationStartBit: ULONG,
}
impl Default for _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x4 (4)"]
    pub WritableUserReferences: LONG,
    pub __bindgen_anon_1: _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ImageRelocationSizeIn64k(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ImageRelocationSizeIn64k(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn BitMap64(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BitMap64(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ImageActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImageActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImageRelocationSizeIn64k: ULONG,
        Unused: ULONG,
        BitMap64: ULONG,
        ImageActive: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ImageRelocationSizeIn64k: u32 =
                unsafe { ::std::mem::transmute(ImageRelocationSizeIn64k) };
            ImageRelocationSizeIn64k as u64
        });
        __bindgen_bitfield_unit.set(16usize, 14u8, {
            let Unused: u32 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let BitMap64: u32 = unsafe { ::std::mem::transmute(BitMap64) };
            BitMap64 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ImageActive: u32 = unsafe { ::std::mem::transmute(ImageActive) };
            ImageActive as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " offset: 0x8 (8)"]
    pub SubsectionRoot: *mut _MM_SUBSECTION_AVL_TABLE,
    #[doc = " offset: 0x8 (8)"]
    pub SeImageStub: *mut _MI_IMAGE_SECURITY_REFERENCE,
}
impl Default for _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CONTROL_AREA__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CONTROL_AREA__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CONTROL_AREA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x48 (72) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PAGE_ACCESS_INFO_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub Link: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x8 (8)"]
    pub Type: _MM_PAGE_ACCESS_TYPE,
    pub __bindgen_anon_1: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub CreateTime: ULONGLONG,
    pub __bindgen_anon_2: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_2,
    pub __bindgen_anon_3: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0xc (12)"]
    pub EmptySequenceNumber: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub CurrentFileIndex: ULONG,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_2 {
    #[doc = " offset: 0x18 (24)"]
    pub EmptyTime: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub TempEntry: *mut _MM_PAGE_ACCESS_INFO,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3 {
    pub __bindgen_anon_1: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2: _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub PageEntry: *mut _MM_PAGE_ACCESS_INFO,
    #[doc = " offset: 0x28 (40)"]
    pub FileEntry: *mut ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub FirstFileEntry: *mut ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub Process: *mut _EPROCESS,
    #[doc = " offset: 0x40 (64)"]
    pub SessionId: ULONG,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_2 {
    #[doc = " offset: 0x20 (32)"]
    pub PageFrameEntry: *mut ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub LastPageFrameEntry: *mut ULONGLONG,
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_PAGE_ACCESS_INFO_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_HANDLE_COUNT_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Process: *mut _EPROCESS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _OBJECT_HANDLE_COUNT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _OBJECT_HANDLE_COUNT_ENTRY {
    #[inline]
    pub fn HandleCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_HandleCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn LockCount(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_LockCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HandleCount: ULONG,
        LockCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let HandleCount: u32 = unsafe { ::std::mem::transmute(HandleCount) };
            HandleCount as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let LockCount: u32 = unsafe { ::std::mem::transmute(LockCount) };
            LockCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x18 (24) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_HANDLE_COUNT_DATABASE {
    #[doc = " offset: 0x0 (0)"]
    pub CountEntries: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub HandleCountEntries: [_OBJECT_HANDLE_COUNT_ENTRY; 1usize],
}
impl Default for _OBJECT_HANDLE_COUNT_DATABASE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_HEADER_HANDLE_INFO {
    pub __bindgen_anon_1: _OBJECT_HEADER_HANDLE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER_HANDLE_INFO__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub HandleCountDataBase: *mut _OBJECT_HANDLE_COUNT_DATABASE,
    #[doc = " offset: 0x0 (0)"]
    pub SingleEntry: _OBJECT_HANDLE_COUNT_ENTRY,
}
impl Default for _OBJECT_HEADER_HANDLE_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_HEADER_HANDLE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x20 (32) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_HEADER_QUOTA_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub PagedPoolCharge: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub NonPagedPoolCharge: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub SecurityDescriptorCharge: ULONG,
    #[doc = " offset: 0x10 (16)"]
    pub ExclusiveProcess: *mut _EPROCESS,
    #[doc = " offset: 0x18 (24)"]
    pub Reserved: ULONGLONG,
}
impl Default for _OBJECT_HEADER_QUOTA_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x70 (112) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_TYPE_INITIALIZER {
    #[doc = " offset: 0x0 (0)"]
    pub Length: USHORT,
    pub __bindgen_anon_1: _OBJECT_TYPE_INITIALIZER__bindgen_ty_1,
    #[doc = " offset: 0x4 (4)"]
    pub ObjectTypeCode: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub InvalidAttributes: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub GenericMapping: _GENERIC_MAPPING,
    #[doc = " offset: 0x1c (28)"]
    pub ValidAccessMask: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub RetainAccess: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub PoolType: _POOL_TYPE,
    #[doc = " offset: 0x28 (40)"]
    pub DefaultPagedPoolCharge: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub DefaultNonPagedPoolCharge: ULONG,
    pub DumpProcedure: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VOID, arg2: *mut _OBJECT_DUMP_CONTROL),
    >,
    pub OpenProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: _OB_OPEN_REASON,
            arg2: CHAR,
            arg3: *mut _EPROCESS,
            arg4: *mut VOID,
            arg5: *mut ULONG,
            arg6: ULONG,
        ) -> LONG,
    >,
    pub CloseProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _EPROCESS,
            arg2: *mut VOID,
            arg3: ULONG,
            arg4: ULONGLONG,
            arg5: ULONGLONG,
        ),
    >,
    #[doc = " offset: 0x48 (72)"]
    pub DeleteProcedure: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VOID)>,
    pub ParseProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: *mut VOID,
            arg3: *mut _ACCESS_STATE,
            arg4: CHAR,
            arg5: ULONG,
            arg6: *mut _UNICODE_STRING,
            arg7: *mut _UNICODE_STRING,
            arg8: *mut VOID,
            arg9: *mut _SECURITY_QUALITY_OF_SERVICE,
            arg10: *mut *mut VOID,
        ) -> LONG,
    >,
    pub SecurityProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: _SECURITY_OPERATION_CODE,
            arg3: *mut ULONG,
            arg4: *mut VOID,
            arg5: *mut ULONG,
            arg6: *mut *mut VOID,
            arg7: _POOL_TYPE,
            arg8: *mut _GENERIC_MAPPING,
            arg9: CHAR,
        ) -> LONG,
    >,
    pub QueryNameProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VOID,
            arg2: UCHAR,
            arg3: *mut _OBJECT_NAME_INFORMATION,
            arg4: ULONG,
            arg5: *mut ULONG,
            arg6: CHAR,
        ) -> LONG,
    >,
    pub OkayToCloseProcedure: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _EPROCESS,
            arg2: *mut VOID,
            arg3: *mut VOID,
            arg4: CHAR,
        ) -> UCHAR,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_TYPE_INITIALIZER__bindgen_ty_1 {
    #[doc = " offset: 0x2 (2)"]
    pub ObjectTypeFlags: UCHAR,
    pub __bindgen_anon_1: _OBJECT_TYPE_INITIALIZER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OBJECT_TYPE_INITIALIZER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _OBJECT_TYPE_INITIALIZER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CaseInsensitive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CaseInsensitive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnnamedObjectsOnly(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UnnamedObjectsOnly(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UseDefaultObject(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UseDefaultObject(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecurityRequired(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SecurityRequired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MaintainHandleCount(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MaintainHandleCount(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MaintainTypeList(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MaintainTypeList(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsObjectCallbacks(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SupportsObjectCallbacks(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseInsensitive: UCHAR,
        UnnamedObjectsOnly: UCHAR,
        UseDefaultObject: UCHAR,
        SecurityRequired: UCHAR,
        MaintainHandleCount: UCHAR,
        MaintainTypeList: UCHAR,
        SupportsObjectCallbacks: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseInsensitive: u8 = unsafe { ::std::mem::transmute(CaseInsensitive) };
            CaseInsensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UnnamedObjectsOnly: u8 = unsafe { ::std::mem::transmute(UnnamedObjectsOnly) };
            UnnamedObjectsOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UseDefaultObject: u8 = unsafe { ::std::mem::transmute(UseDefaultObject) };
            UseDefaultObject as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SecurityRequired: u8 = unsafe { ::std::mem::transmute(SecurityRequired) };
            SecurityRequired as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MaintainHandleCount: u8 = unsafe { ::std::mem::transmute(MaintainHandleCount) };
            MaintainHandleCount as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MaintainTypeList: u8 = unsafe { ::std::mem::transmute(MaintainTypeList) };
            MaintainTypeList as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SupportsObjectCallbacks: u8 =
                unsafe { ::std::mem::transmute(SupportsObjectCallbacks) };
            SupportsObjectCallbacks as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _OBJECT_TYPE_INITIALIZER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_TYPE_INITIALIZER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x238 (568) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_TYPE {
    #[doc = " offset: 0x0 (0)"]
    pub TypeList: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub Name: _UNICODE_STRING,
    #[doc = " offset: 0x20 (32)"]
    pub DefaultObject: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub Index: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub TotalNumberOfObjects: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub TotalNumberOfHandles: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub HighWaterNumberOfObjects: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub HighWaterNumberOfHandles: ULONG,
    #[doc = " offset: 0x40 (64)"]
    pub TypeInfo: _OBJECT_TYPE_INITIALIZER,
    #[doc = " offset: 0xb0 (176)"]
    pub Mutex: _ERESOURCE,
    #[doc = " offset: 0x118 (280)"]
    pub TypeLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x120 (288)"]
    pub Key: ULONG,
    #[doc = " offset: 0x128 (296)"]
    pub ObjectLocks: [_EX_PUSH_LOCK; 32usize],
    #[doc = " offset: 0x228 (552)"]
    pub CallbackList: _LIST_ENTRY,
}
impl Default for _OBJECT_TYPE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OB_DUPLICATE_OBJECT_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub SourceProcess: *mut _EPROCESS,
    #[doc = " offset: 0x8 (8)"]
    pub SourceHandle: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub Object: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub ObjectType: *mut _OBJECT_TYPE,
    #[doc = " offset: 0x20 (32)"]
    pub TargetAccess: ULONG,
    #[doc = " offset: 0x24 (36)"]
    pub ObjectInfo: _HANDLE_TABLE_ENTRY_INFO,
    #[doc = " offset: 0x28 (40)"]
    pub HandleAttributes: ULONG,
}
impl Default for _OB_DUPLICATE_OBJECT_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_HANDLE_DATA {
    #[doc = " offset: 0x0 (0)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub ObjectType: ULONG,
    #[doc = " offset: 0x8 (8)"]
    pub DuplicateContext: *mut _OB_DUPLICATE_OBJECT_STATE,
}
impl Default for _KALPC_HANDLE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_MESSAGE_ATTRIBUTES {
    #[doc = " offset: 0x0 (0)"]
    pub ClientContext: *mut VOID,
    #[doc = " offset: 0x8 (8)"]
    pub ServerContext: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub PortContext: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub CancelPortContext: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub SecurityData: *mut _KALPC_SECURITY_DATA,
    #[doc = " offset: 0x28 (40)"]
    pub View: *mut _KALPC_VIEW,
    #[doc = " offset: 0x30 (48)"]
    pub HandleData: *mut _KALPC_HANDLE_DATA,
}
impl Default for _KALPC_MESSAGE_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x108 (264) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KALPC_MESSAGE {
    #[doc = " offset: 0x0 (0)"]
    pub Entry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub ExtensionBuffer: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub ExtensionBufferSize: ULONGLONG,
    pub __bindgen_anon_1: _KALPC_MESSAGE__bindgen_ty_1,
    #[doc = " offset: 0x28 (40)"]
    pub SequenceNo: LONG,
    #[doc = " offset: 0x2c (44)"]
    pub u1: _KALPC_MESSAGE__bindgen_ty_2,
    #[doc = " offset: 0x30 (48)"]
    pub CancelSequencePort: *mut _ALPC_PORT,
    #[doc = " offset: 0x38 (56)"]
    pub CancelQueuePort: *mut _ALPC_PORT,
    #[doc = " offset: 0x40 (64)"]
    pub CancelSequenceNo: LONG,
    #[doc = " offset: 0x48 (72)"]
    pub CancelListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x58 (88)"]
    pub WaitingThread: *mut _ETHREAD,
    #[doc = " offset: 0x60 (96)"]
    pub Reserve: *mut _KALPC_RESERVE,
    #[doc = " offset: 0x68 (104)"]
    pub PortQueue: *mut _ALPC_PORT,
    #[doc = " offset: 0x70 (112)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x78 (120)"]
    pub UniqueTableEntry: *mut _HANDLE_TABLE_ENTRY,
    #[doc = " offset: 0x80 (128)"]
    pub MessageAttributes: _KALPC_MESSAGE_ATTRIBUTES,
    #[doc = " offset: 0xb8 (184)"]
    pub DataUserVa: *mut VOID,
    #[doc = " offset: 0xc0 (192)"]
    pub DataSystemVa: *mut VOID,
    #[doc = " offset: 0xc8 (200)"]
    pub CommunicationInfo: *mut _ALPC_COMMUNICATION_INFO,
    #[doc = " offset: 0xd0 (208)"]
    pub ConnectionPort: *mut _ALPC_PORT,
    #[doc = " offset: 0xd8 (216)"]
    pub ServerThread: *mut _ETHREAD,
    #[doc = " offset: 0xe0 (224)"]
    pub PortMessage: _PORT_MESSAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_MESSAGE__bindgen_ty_1 {
    #[doc = " offset: 0x20 (32)"]
    pub QuotaProcess: *mut _EPROCESS,
    #[doc = " offset: 0x20 (32)"]
    pub QuotaBlock: *mut VOID,
}
impl Default for _KALPC_MESSAGE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KALPC_MESSAGE__bindgen_ty_2 {
    #[doc = " offset: 0x2c (44)"]
    pub s1: _KALPC_MESSAGE__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x2c (44)"]
    pub State: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_MESSAGE__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _KALPC_MESSAGE__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn QueueType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_QueueType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn QueuePortType(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_QueuePortType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Canceled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Canceled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Ready(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Ready(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReleaseMessage(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReleaseMessage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedQuota(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SharedQuota(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReplyWaitReply(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplyWaitReply(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerPortReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerPortReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReserveReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReserveReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReceiverReference(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        QueueType: ULONG,
        QueuePortType: ULONG,
        Canceled: ULONG,
        Ready: ULONG,
        ReleaseMessage: ULONG,
        SharedQuota: ULONG,
        ReplyWaitReply: ULONG,
        OwnerPortReference: ULONG,
        ReserveReference: ULONG,
        ReceiverReference: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let QueueType: u32 = unsafe { ::std::mem::transmute(QueueType) };
            QueueType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let QueuePortType: u32 = unsafe { ::std::mem::transmute(QueuePortType) };
            QueuePortType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Canceled: u32 = unsafe { ::std::mem::transmute(Canceled) };
            Canceled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Ready: u32 = unsafe { ::std::mem::transmute(Ready) };
            Ready as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReleaseMessage: u32 = unsafe { ::std::mem::transmute(ReleaseMessage) };
            ReleaseMessage as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SharedQuota: u32 = unsafe { ::std::mem::transmute(SharedQuota) };
            SharedQuota as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ReplyWaitReply: u32 = unsafe { ::std::mem::transmute(ReplyWaitReply) };
            ReplyWaitReply as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let OwnerPortReference: u32 = unsafe { ::std::mem::transmute(OwnerPortReference) };
            OwnerPortReference as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ReserveReference: u32 = unsafe { ::std::mem::transmute(ReserveReference) };
            ReserveReference as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ReceiverReference: u32 = unsafe { ::std::mem::transmute(ReceiverReference) };
            ReceiverReference as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KALPC_MESSAGE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KALPC_MESSAGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_DISPATCH_CONTEXT {
    #[doc = " offset: 0x0 (0)"]
    pub PortObject: *mut _ALPC_PORT,
    #[doc = " offset: 0x8 (8)"]
    pub Message: *mut _KALPC_MESSAGE,
    #[doc = " offset: 0x10 (16)"]
    pub CommunicationInfo: *mut _ALPC_COMMUNICATION_INFO,
    #[doc = " offset: 0x18 (24)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub TargetThread: *mut _ETHREAD,
    #[doc = " offset: 0x28 (40)"]
    pub TargetPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x30 (48)"]
    pub TotalLength: USHORT,
    #[doc = " offset: 0x32 (50)"]
    pub Type: USHORT,
    #[doc = " offset: 0x34 (52)"]
    pub DataInfoOffset: USHORT,
}
impl Default for _ALPC_DISPATCH_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KALPC_RESERVE {
    #[doc = " offset: 0x0 (0)"]
    pub OwnerPort: *mut _ALPC_PORT,
    #[doc = " offset: 0x8 (8)"]
    pub HandleTable: *mut _ALPC_HANDLE_TABLE,
    #[doc = " offset: 0x10 (16)"]
    pub Handle: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub Message: *mut _KALPC_MESSAGE,
    #[doc = " offset: 0x20 (32)"]
    pub Active: LONG,
}
impl Default for _KALPC_RESERVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x198 (408) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_PORT {
    #[doc = " offset: 0x0 (0)"]
    pub PortListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub CommunicationInfo: *mut _ALPC_COMMUNICATION_INFO,
    #[doc = " offset: 0x18 (24)"]
    pub OwnerProcess: *mut _EPROCESS,
    #[doc = " offset: 0x20 (32)"]
    pub SequenceNo: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub CompletionPort: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub CompletionKey: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub CompletionPacketLookaside: *mut _ALPC_COMPLETION_PACKET_LOOKASIDE,
    #[doc = " offset: 0x40 (64)"]
    pub PortContext: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub StaticSecurity: _SECURITY_CLIENT_CONTEXT,
    #[doc = " offset: 0x90 (144)"]
    pub MainQueue: _LIST_ENTRY,
    #[doc = " offset: 0xa0 (160)"]
    pub PendingQueue: _LIST_ENTRY,
    #[doc = " offset: 0xb0 (176)"]
    pub LargeMessageQueue: _LIST_ENTRY,
    #[doc = " offset: 0xc0 (192)"]
    pub WaitQueue: _LIST_ENTRY,
    pub __bindgen_anon_1: _ALPC_PORT__bindgen_ty_1,
    #[doc = " offset: 0xd8 (216)"]
    pub Lock: _EX_PUSH_LOCK,
    #[doc = " offset: 0xe0 (224)"]
    pub PortAttributes: _ALPC_PORT_ATTRIBUTES,
    #[doc = " offset: 0x128 (296)"]
    pub ResourceListLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x130 (304)"]
    pub ResourceListHead: _LIST_ENTRY,
    #[doc = " offset: 0x140 (320)"]
    pub CompletionList: *mut _ALPC_COMPLETION_LIST,
    #[doc = " offset: 0x148 (328)"]
    pub MessageZone: *mut _ALPC_MESSAGE_ZONE,
    #[doc = " offset: 0x150 (336)"]
    pub CanceledQueue: _LIST_ENTRY,
    #[doc = " offset: 0x160 (352)"]
    pub u1: _ALPC_PORT__bindgen_ty_2,
    #[doc = " offset: 0x168 (360)"]
    pub TargetQueuePort: *mut _ALPC_PORT,
    #[doc = " offset: 0x170 (368)"]
    pub TargetSequencePort: *mut _ALPC_PORT,
    #[doc = " offset: 0x178 (376)"]
    pub Message: *mut _KALPC_MESSAGE,
    #[doc = " offset: 0x180 (384)"]
    pub MainQueueLength: ULONG,
    #[doc = " offset: 0x184 (388)"]
    pub PendingQueueLength: ULONG,
    #[doc = " offset: 0x188 (392)"]
    pub LargeMessageQueueLength: ULONG,
    #[doc = " offset: 0x18c (396)"]
    pub CanceledQueueLength: ULONG,
    #[doc = " offset: 0x190 (400)"]
    pub WaitQueueLength: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_PORT__bindgen_ty_1 {
    #[doc = " offset: 0xd0 (208)"]
    pub Semaphore: *mut _KSEMAPHORE,
    #[doc = " offset: 0xd0 (208)"]
    pub DummyEvent: *mut _KEVENT,
}
impl Default for _ALPC_PORT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_PORT__bindgen_ty_2 {
    #[doc = " offset: 0x160 (352)"]
    pub s1: _ALPC_PORT__bindgen_ty_2__bindgen_ty_1,
    #[doc = " offset: 0x160 (352)"]
    pub State: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ALPC_PORT__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _ALPC_PORT__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Initialized(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Initialized(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ConnectionPending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConnectionPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ConnectionRefused(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConnectionRefused(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disconnected(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Disconnected(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Closed(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Closed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoFlushOnClose(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoFlushOnClose(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReturnExtendedInfo(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReturnExtendedInfo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Waitable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Waitable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DynamicSecurity(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DynamicSecurity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wow64CompletionList(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Wow64CompletionList(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Lpc(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Lpc(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LpcToLpc(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LpcToLpc(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasCompletionList(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasCompletionList(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HadCompletionList(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HadCompletionList(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Initialized: ULONG,
        Type: ULONG,
        ConnectionPending: ULONG,
        ConnectionRefused: ULONG,
        Disconnected: ULONG,
        Closed: ULONG,
        NoFlushOnClose: ULONG,
        ReturnExtendedInfo: ULONG,
        Waitable: ULONG,
        DynamicSecurity: ULONG,
        Wow64CompletionList: ULONG,
        Lpc: ULONG,
        LpcToLpc: ULONG,
        HasCompletionList: ULONG,
        HadCompletionList: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Initialized: u32 = unsafe { ::std::mem::transmute(Initialized) };
            Initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ConnectionPending: u32 = unsafe { ::std::mem::transmute(ConnectionPending) };
            ConnectionPending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ConnectionRefused: u32 = unsafe { ::std::mem::transmute(ConnectionRefused) };
            ConnectionRefused as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Disconnected: u32 = unsafe { ::std::mem::transmute(Disconnected) };
            Disconnected as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Closed: u32 = unsafe { ::std::mem::transmute(Closed) };
            Closed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NoFlushOnClose: u32 = unsafe { ::std::mem::transmute(NoFlushOnClose) };
            NoFlushOnClose as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReturnExtendedInfo: u32 = unsafe { ::std::mem::transmute(ReturnExtendedInfo) };
            ReturnExtendedInfo as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Waitable: u32 = unsafe { ::std::mem::transmute(Waitable) };
            Waitable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DynamicSecurity: u32 = unsafe { ::std::mem::transmute(DynamicSecurity) };
            DynamicSecurity as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Wow64CompletionList: u32 = unsafe { ::std::mem::transmute(Wow64CompletionList) };
            Wow64CompletionList as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Lpc: u32 = unsafe { ::std::mem::transmute(Lpc) };
            Lpc as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LpcToLpc: u32 = unsafe { ::std::mem::transmute(LpcToLpc) };
            LpcToLpc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HasCompletionList: u32 = unsafe { ::std::mem::transmute(HasCompletionList) };
            HasCompletionList as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let HadCompletionList: u32 = unsafe { ::std::mem::transmute(HadCompletionList) };
            HadCompletionList as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ALPC_PORT__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ALPC_PORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_HEADER {
    #[doc = " offset: 0x0 (0)"]
    pub PointerCount: LONGLONG,
    pub __bindgen_anon_1: _OBJECT_HEADER__bindgen_ty_1,
    #[doc = " offset: 0x10 (16)"]
    pub Type: *mut _OBJECT_TYPE,
    #[doc = " offset: 0x18 (24)"]
    pub NameInfoOffset: UCHAR,
    #[doc = " offset: 0x19 (25)"]
    pub HandleInfoOffset: UCHAR,
    #[doc = " offset: 0x1a (26)"]
    pub QuotaInfoOffset: UCHAR,
    #[doc = " offset: 0x1b (27)"]
    pub Flags: UCHAR,
    pub __bindgen_anon_2: _OBJECT_HEADER__bindgen_ty_2,
    #[doc = " offset: 0x28 (40)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub Body: _QUAD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER__bindgen_ty_1 {
    #[doc = " offset: 0x8 (8)"]
    pub HandleCount: LONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub NextToFree: *mut VOID,
}
impl Default for _OBJECT_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_HEADER__bindgen_ty_2 {
    #[doc = " offset: 0x20 (32)"]
    pub ObjectCreateInfo: *mut _OBJECT_CREATE_INFORMATION,
    #[doc = " offset: 0x20 (32)"]
    pub QuotaBlockCharged: *mut VOID,
}
impl Default for _OBJECT_HEADER__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OBJECT_HEADER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x28 (40) bytes"]
#[repr(C)]
#[derive(Debug)]
pub struct _OBJECT_REF_INFO {
    #[doc = " offset: 0x0 (0)"]
    pub ObjectHeader: *mut _OBJECT_HEADER,
    #[doc = " offset: 0x8 (8)"]
    pub NextRef: *mut VOID,
    #[doc = " offset: 0x10 (16)"]
    pub ImageFileName: [UCHAR; 16usize],
    #[doc = " offset: 0x20 (32)"]
    pub NextPos: USHORT,
    #[doc = " offset: 0x22 (34)"]
    pub MaxStacks: USHORT,
    #[doc = " offset: 0x24 (36)"]
    pub StackInfo: __IncompleteArrayField<_OBJECT_REF_STACK_INFO>,
}
impl Default for _OBJECT_REF_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x60 (96) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HANDLE_TABLE {
    #[doc = " offset: 0x0 (0)"]
    pub TableCode: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub QuotaProcess: *mut _EPROCESS,
    #[doc = " offset: 0x10 (16)"]
    pub UniqueProcessId: *mut VOID,
    #[doc = " offset: 0x18 (24)"]
    pub HandleLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x20 (32)"]
    pub HandleTableList: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub HandleContentionEvent: _EX_PUSH_LOCK,
    #[doc = " offset: 0x38 (56)"]
    pub DebugInfo: *mut _HANDLE_TRACE_DEBUG_INFO,
    #[doc = " offset: 0x40 (64)"]
    pub ExtraInfoPages: LONG,
    pub __bindgen_anon_1: _HANDLE_TABLE__bindgen_ty_1,
    #[doc = " offset: 0x48 (72)"]
    pub FirstFreeHandle: LONG,
    #[doc = " offset: 0x50 (80)"]
    pub LastFreeHandleEntry: *mut _HANDLE_TABLE_ENTRY,
    #[doc = " offset: 0x58 (88)"]
    pub HandleCount: LONG,
    #[doc = " offset: 0x5c (92)"]
    pub NextHandleNeedingPool: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HANDLE_TABLE__bindgen_ty_1 {
    #[doc = " offset: 0x44 (68)"]
    pub Flags: ULONG,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _HANDLE_TABLE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _HANDLE_TABLE__bindgen_ty_1 {
    #[inline]
    pub fn StrictFIFO(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_StrictFIFO(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(StrictFIFO: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let StrictFIFO: u8 = unsafe { ::std::mem::transmute(StrictFIFO) };
            StrictFIFO as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _HANDLE_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xe0 (224) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _FAST_IO_DISPATCH {
    #[doc = " offset: 0x0 (0)"]
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: UCHAR,
            arg5: ULONG,
            arg6: UCHAR,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: UCHAR,
            arg5: ULONG,
            arg6: *mut VOID,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: UCHAR,
            arg5: ULONG,
            arg6: *mut VOID,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoQueryBasicInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut _FILE_BASIC_INFORMATION,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoQueryStandardInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut _FILE_STANDARD_INFORMATION,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _LARGE_INTEGER,
            arg4: *mut _EPROCESS,
            arg5: ULONG,
            arg6: UCHAR,
            arg7: UCHAR,
            arg8: *mut _IO_STATUS_BLOCK,
            arg9: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoUnlockSingle: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _LARGE_INTEGER,
            arg4: *mut _EPROCESS,
            arg5: ULONG,
            arg6: *mut _IO_STATUS_BLOCK,
            arg7: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoUnlockAll: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _EPROCESS,
            arg3: *mut _IO_STATUS_BLOCK,
            arg4: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoUnlockAllByKey: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut VOID,
            arg3: ULONG,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoDeviceControl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut VOID,
            arg4: ULONG,
            arg5: *mut VOID,
            arg6: ULONG,
            arg7: ULONG,
            arg8: *mut _IO_STATUS_BLOCK,
            arg9: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub AcquireFileForNtCreateSection:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _FILE_OBJECT)>,
    pub ReleaseFileForNtCreateSection:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _FILE_OBJECT)>,
    pub FastIoDetachDevice: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _DEVICE_OBJECT),
    >,
    pub FastIoQueryNetworkOpenInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: UCHAR,
            arg3: *mut _FILE_NETWORK_OPEN_INFORMATION,
            arg4: *mut _IO_STATUS_BLOCK,
            arg5: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub AcquireForModWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut *mut _ERESOURCE,
            arg4: *mut _DEVICE_OBJECT,
        ) -> LONG,
    >,
    pub MdlRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut *mut _MDL,
            arg6: *mut _IO_STATUS_BLOCK,
            arg7: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlReadComplete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _MDL,
            arg3: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub PrepareMdlWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut *mut _MDL,
            arg6: *mut _IO_STATUS_BLOCK,
            arg7: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlWriteComplete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _MDL,
            arg4: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoReadCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut VOID,
            arg6: *mut *mut _MDL,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _COMPRESSED_DATA_INFO,
            arg9: ULONG,
            arg10: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoWriteCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: ULONG,
            arg4: ULONG,
            arg5: *mut VOID,
            arg6: *mut *mut _MDL,
            arg7: *mut _IO_STATUS_BLOCK,
            arg8: *mut _COMPRESSED_DATA_INFO,
            arg9: ULONG,
            arg10: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlReadCompleteCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _MDL,
            arg3: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub MdlWriteCompleteCompressed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _LARGE_INTEGER,
            arg3: *mut _MDL,
            arg4: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub FastIoQueryOpen: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _IRP,
            arg2: *mut _FILE_NETWORK_OPEN_INFORMATION,
            arg3: *mut _DEVICE_OBJECT,
        ) -> UCHAR,
    >,
    pub ReleaseForModWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _FILE_OBJECT,
            arg2: *mut _ERESOURCE,
            arg3: *mut _DEVICE_OBJECT,
        ) -> LONG,
    >,
    pub AcquireForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FILE_OBJECT, arg2: *mut _DEVICE_OBJECT) -> LONG,
    >,
    pub ReleaseForCcFlush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _FILE_OBJECT, arg2: *mut _DEVICE_OBJECT) -> LONG,
    >,
}
#[doc = " 0x150 (336) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DRIVER_OBJECT {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: SHORT,
    #[doc = " offset: 0x8 (8)"]
    pub DeviceObject: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub DriverStart: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub DriverSize: ULONG,
    #[doc = " offset: 0x28 (40)"]
    pub DriverSection: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub DriverExtension: *mut _DRIVER_EXTENSION,
    #[doc = " offset: 0x38 (56)"]
    pub DriverName: _UNICODE_STRING,
    #[doc = " offset: 0x48 (72)"]
    pub HardwareDatabase: *mut _UNICODE_STRING,
    #[doc = " offset: 0x50 (80)"]
    pub FastIoDispatch: *mut _FAST_IO_DISPATCH,
    pub DriverInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT, arg2: *mut _UNICODE_STRING) -> LONG,
    >,
    pub DriverStartIo:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP)>,
    #[doc = " offset: 0x68 (104)"]
    pub DriverUnload: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT)>,
    pub MajorFunction: [::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DEVICE_OBJECT, arg2: *mut _IRP) -> LONG,
    >; 28usize],
}
impl Default for _DRIVER_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1e00 (7680) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_SESSION_SPACE {
    #[doc = " offset: 0x0 (0)"]
    pub ReferenceCount: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub u: _MM_SESSION_SPACE__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0xc (12)"]
    pub ProcessReferenceToSession: LONG,
    #[doc = " offset: 0x10 (16)"]
    pub ProcessList: _LIST_ENTRY,
    #[doc = " offset: 0x20 (32)"]
    pub LastProcessSwappedOutTime: _LARGE_INTEGER,
    #[doc = " offset: 0x28 (40)"]
    pub SessionPageDirectoryIndex: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub NonPagablePages: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub CommittedPages: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub PagedPoolStart: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub PagedPoolEnd: *mut VOID,
    #[doc = " offset: 0x50 (80)"]
    pub SessionObject: *mut VOID,
    #[doc = " offset: 0x58 (88)"]
    pub SessionObjectHandle: *mut VOID,
    #[doc = " offset: 0x60 (96)"]
    pub ResidentProcessCount: LONG,
    #[doc = " offset: 0x64 (100)"]
    pub ImageLoadingCount: LONG,
    #[doc = " offset: 0x68 (104)"]
    pub SessionPoolAllocationFailures: [ULONG; 4usize],
    #[doc = " offset: 0x78 (120)"]
    pub ImageList: _LIST_ENTRY,
    #[doc = " offset: 0x88 (136)"]
    pub LocaleId: ULONG,
    #[doc = " offset: 0x8c (140)"]
    pub AttachCount: ULONG,
    #[doc = " offset: 0x90 (144)"]
    pub AttachGate: _KGATE,
    #[doc = " offset: 0xa8 (168)"]
    pub WsListEntry: _LIST_ENTRY,
    #[doc = " offset: 0xc0 (192)"]
    pub Lookaside: [_GENERAL_LOOKASIDE; 21usize],
    #[doc = " offset: 0xb40 (2880)"]
    pub Session: _MMSESSION,
    #[doc = " offset: 0xb98 (2968)"]
    pub PagedPoolInfo: _MM_PAGED_POOL_INFO,
    #[doc = " offset: 0xc00 (3072)"]
    pub Vm: _MMSUPPORT,
    #[doc = " offset: 0xc68 (3176)"]
    pub Wsle: *mut _MMWSLE,
    pub volatileDriverUnload:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT)>,
    #[doc = " offset: 0xc78 (3192)"]
    pub PagedPool: _POOL_DESCRIPTOR,
    #[doc = " offset: 0x1cc0 (7360)"]
    pub PageDirectory: _MMPTE,
    #[doc = " offset: 0x1cc8 (7368)"]
    pub SessionVaLock: _KGUARDED_MUTEX,
    #[doc = " offset: 0x1d00 (7424)"]
    pub DynamicVaBitMap: _RTL_BITMAP,
    #[doc = " offset: 0x1d10 (7440)"]
    pub DynamicVaHint: ULONG,
    #[doc = " offset: 0x1d18 (7448)"]
    pub SpecialPool: _MI_SPECIAL_POOL,
    #[doc = " offset: 0x1d48 (7496)"]
    pub SessionPteLock: _KGUARDED_MUTEX,
    #[doc = " offset: 0x1d80 (7552)"]
    pub PoolBigEntriesInUse: LONG,
    #[doc = " offset: 0x1d84 (7556)"]
    pub PagedPoolPdeCount: ULONG,
    #[doc = " offset: 0x1d88 (7560)"]
    pub SpecialPoolPdeCount: ULONG,
    #[doc = " offset: 0x1d8c (7564)"]
    pub DynamicSessionPdeCount: ULONG,
    #[doc = " offset: 0x1d90 (7568)"]
    pub SystemPteInfo: _MI_SYSTEM_PTE_TYPE,
    #[doc = " offset: 0x1dd8 (7640)"]
    pub PoolTrackTableExpansion: *mut VOID,
    #[doc = " offset: 0x1de0 (7648)"]
    pub PoolTrackTableExpansionSize: ULONGLONG,
    #[doc = " offset: 0x1de8 (7656)"]
    pub PoolTrackBigPages: *mut VOID,
    #[doc = " offset: 0x1df0 (7664)"]
    pub PoolTrackBigPagesSize: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_SESSION_SPACE__bindgen_ty_1 {
    #[doc = " offset: 0x4 (4)"]
    pub LongFlags: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Flags: _MM_SESSION_SPACE_FLAGS,
}
impl Default for _MM_SESSION_SPACE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MM_SESSION_SPACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x38 (56) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DRIVER_EXTENSION {
    #[doc = " offset: 0x0 (0)"]
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut _DRIVER_OBJECT, arg2: *mut _DEVICE_OBJECT) -> LONG,
    >,
    #[doc = " offset: 0x10 (16)"]
    pub Count: ULONG,
    #[doc = " offset: 0x18 (24)"]
    pub ServiceKeyName: _UNICODE_STRING,
    #[doc = " offset: 0x28 (40)"]
    pub ClientDriverExtension: *mut _IO_CLIENT_EXTENSION,
    #[doc = " offset: 0x30 (48)"]
    pub FsFilterCallbacks: *mut _FS_FILTER_CALLBACKS,
}
impl Default for _DRIVER_EXTENSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x150 (336) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT {
    #[doc = " offset: 0x0 (0)"]
    pub Type: SHORT,
    #[doc = " offset: 0x2 (2)"]
    pub Size: USHORT,
    #[doc = " offset: 0x4 (4)"]
    pub ReferenceCount: LONG,
    #[doc = " offset: 0x8 (8)"]
    pub DriverObject: *mut _DRIVER_OBJECT,
    #[doc = " offset: 0x10 (16)"]
    pub NextDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x18 (24)"]
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x20 (32)"]
    pub CurrentIrp: *mut _IRP,
    #[doc = " offset: 0x28 (40)"]
    pub Timer: *mut _IO_TIMER,
    #[doc = " offset: 0x30 (48)"]
    pub Flags: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub Characteristics: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub Vpb: *mut _VPB,
    #[doc = " offset: 0x40 (64)"]
    pub DeviceExtension: *mut VOID,
    #[doc = " offset: 0x48 (72)"]
    pub DeviceType: ULONG,
    #[doc = " offset: 0x4c (76)"]
    pub StackSize: CHAR,
    #[doc = " offset: 0x50 (80)"]
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    #[doc = " offset: 0x98 (152)"]
    pub AlignmentRequirement: ULONG,
    #[doc = " offset: 0xa0 (160)"]
    pub DeviceQueue: _KDEVICE_QUEUE,
    #[doc = " offset: 0xc8 (200)"]
    pub Dpc: _KDPC,
    #[doc = " offset: 0x108 (264)"]
    pub ActiveThreadCount: ULONG,
    #[doc = " offset: 0x110 (272)"]
    pub SecurityDescriptor: *mut VOID,
    #[doc = " offset: 0x118 (280)"]
    pub DeviceLock: _KEVENT,
    #[doc = " offset: 0x130 (304)"]
    pub SectorSize: USHORT,
    #[doc = " offset: 0x132 (306)"]
    pub Spare1: USHORT,
    #[doc = " offset: 0x138 (312)"]
    pub DeviceObjectExtension: *mut _DEVOBJ_EXTENSION,
    #[doc = " offset: 0x140 (320)"]
    pub Reserved: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT__bindgen_ty_1 {
    #[doc = " offset: 0x50 (80)"]
    pub ListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x50 (80)"]
    pub Wcb: _WAIT_CONTEXT_BLOCK,
}
impl Default for _DEVICE_OBJECT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _DEVICE_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x30 (48) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MDL {
    #[doc = " offset: 0x0 (0)"]
    pub Next: *mut _MDL,
    #[doc = " offset: 0x8 (8)"]
    pub Size: SHORT,
    #[doc = " offset: 0xa (10)"]
    pub MdlFlags: SHORT,
    #[doc = " offset: 0x10 (16)"]
    pub Process: *mut _EPROCESS,
    #[doc = " offset: 0x18 (24)"]
    pub MappedSystemVa: *mut VOID,
    #[doc = " offset: 0x20 (32)"]
    pub StartVa: *mut VOID,
    #[doc = " offset: 0x28 (40)"]
    pub ByteCount: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub ByteOffset: ULONG,
}
impl Default for _MDL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x68 (104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MI_PAGEFILE_TRACES {
    #[doc = " offset: 0x0 (0)"]
    pub Status: LONG,
    #[doc = " offset: 0x4 (4)"]
    pub Priority: UCHAR,
    #[doc = " offset: 0x5 (5)"]
    pub IrpPriority: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub CurrentTime: _LARGE_INTEGER,
    #[doc = " offset: 0x10 (16)"]
    pub AvailablePages: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub ModifiedPagesTotal: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub ModifiedPagefilePages: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub ModifiedNoWritePages: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub MdlHack: _MI_PAGEFILE_TRACES__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MI_PAGEFILE_TRACES__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub Mdl: _MDL,
    #[doc = " offset: 0x30 (48)"]
    pub Page: [ULONGLONG; 1usize],
}
impl Default for _MI_PAGEFILE_TRACES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MI_PAGEFILE_TRACES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMMOD_WRITER_MDL_ENTRY {
    #[doc = " offset: 0x0 (0)"]
    pub Links: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub u: _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_1,
    #[doc = " offset: 0x20 (32)"]
    pub Irp: *mut _IRP,
    #[doc = " offset: 0x28 (40)"]
    pub u1: _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_2,
    #[doc = " offset: 0x30 (48)"]
    pub PagingFile: *mut _MMPAGING_FILE,
    #[doc = " offset: 0x38 (56)"]
    pub File: *mut _FILE_OBJECT,
    #[doc = " offset: 0x40 (64)"]
    pub ControlArea: *mut _CONTROL_AREA,
    #[doc = " offset: 0x48 (72)"]
    pub FileResource: *mut _ERESOURCE,
    #[doc = " offset: 0x50 (80)"]
    pub WriteOffset: _LARGE_INTEGER,
    #[doc = " offset: 0x58 (88)"]
    pub IssueTime: _LARGE_INTEGER,
    #[doc = " offset: 0x60 (96)"]
    pub PointerMdl: *mut _MDL,
    #[doc = " offset: 0x68 (104)"]
    pub Mdl: _MDL,
    #[doc = " offset: 0x98 (152)"]
    pub Page: [ULONGLONG; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_1 {
    #[doc = " offset: 0x10 (16)"]
    pub IoStatus: _IO_STATUS_BLOCK,
}
impl Default for _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_2 {
    #[doc = " offset: 0x28 (40)"]
    pub KeepForever: ULONGLONG,
}
impl Default for _MMMOD_WRITER_MDL_ENTRY__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _MMMOD_WRITER_MDL_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0xa0 (160) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPAGING_FILE {
    #[doc = " offset: 0x0 (0)"]
    pub Size: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub MaximumSize: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub MinimumSize: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub FreeSpace: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub PeakUsage: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub HighestPage: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub File: *mut _FILE_OBJECT,
    #[doc = " offset: 0x38 (56)"]
    pub Entry: [*mut _MMMOD_WRITER_MDL_ENTRY; 2usize],
    #[doc = " offset: 0x48 (72)"]
    pub PageFileName: _UNICODE_STRING,
    #[doc = " offset: 0x58 (88)"]
    pub Bitmap: *mut _RTL_BITMAP,
    #[doc = " offset: 0x60 (96)"]
    pub BitmapHint: ULONG,
    #[doc = " offset: 0x64 (100)"]
    pub LastAllocationSize: ULONG,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " offset: 0x70 (112)"]
    pub FileHandle: *mut VOID,
    #[doc = " offset: 0x80 (128)"]
    pub AvailableList: _SLIST_HEADER,
    #[doc = " offset: 0x90 (144)"]
    pub NeedProcessingList: _SLIST_HEADER,
}
impl Default for _MMPAGING_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _MMPAGING_FILE {
    #[inline]
    pub fn PageFileNumber(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PageFileNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn BootPartition(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BootPartition(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare0(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn AdriftMdls(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AdriftMdls(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageFileNumber: USHORT,
        BootPartition: USHORT,
        Spare0: USHORT,
        AdriftMdls: USHORT,
        Spare1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PageFileNumber: u16 = unsafe { ::std::mem::transmute(PageFileNumber) };
            PageFileNumber as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BootPartition: u16 = unsafe { ::std::mem::transmute(BootPartition) };
            BootPartition as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Spare0: u16 = unsafe { ::std::mem::transmute(Spare0) };
            Spare0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AdriftMdls: u16 = unsafe { ::std::mem::transmute(AdriftMdls) };
            AdriftMdls as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let Spare1: u16 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 0x40 (64) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = " offset: 0x18 (24)"]
    pub DueTime: _ULARGE_INTEGER,
    #[doc = " offset: 0x20 (32)"]
    pub TimerListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x30 (48)"]
    pub Dpc: *mut _KDPC,
    #[doc = " offset: 0x38 (56)"]
    pub Period: LONG,
}
impl Default for _KTIMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x128 (296) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POP_THERMAL_ZONE {
    #[doc = " offset: 0x0 (0)"]
    pub Link: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub State: UCHAR,
    #[doc = " offset: 0x11 (17)"]
    pub Flags: UCHAR,
    #[doc = " offset: 0x12 (18)"]
    pub Mode: UCHAR,
    #[doc = " offset: 0x13 (19)"]
    pub PendingMode: UCHAR,
    #[doc = " offset: 0x14 (20)"]
    pub ActivePoint: UCHAR,
    #[doc = " offset: 0x15 (21)"]
    pub PendingActivePoint: UCHAR,
    #[doc = " offset: 0x18 (24)"]
    pub Throttle: LONG,
    #[doc = " offset: 0x20 (32)"]
    pub LastTime: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub SampleRate: ULONG,
    #[doc = " offset: 0x2c (44)"]
    pub LastTemp: ULONG,
    #[doc = " offset: 0x30 (48)"]
    pub PassiveTimer: _KTIMER,
    #[doc = " offset: 0x70 (112)"]
    pub PassiveDpc: _KDPC,
    #[doc = " offset: 0xb0 (176)"]
    pub OverThrottled: _POP_ACTION_TRIGGER,
    #[doc = " offset: 0xc8 (200)"]
    pub Irp: *mut _IRP,
    #[doc = " offset: 0xd0 (208)"]
    pub Info: _THERMAL_INFORMATION_EX,
}
impl Default for _POP_THERMAL_ZONE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x108 (264) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETIMER {
    #[doc = " offset: 0x0 (0)"]
    pub KeTimer: _KTIMER,
    #[doc = " offset: 0x40 (64)"]
    pub TimerApc: _KAPC,
    #[doc = " offset: 0x98 (152)"]
    pub TimerDpc: _KDPC,
    #[doc = " offset: 0xd8 (216)"]
    pub ActiveTimerListEntry: _LIST_ENTRY,
    #[doc = " offset: 0xe8 (232)"]
    pub Lock: ULONGLONG,
    #[doc = " offset: 0xf0 (240)"]
    pub Period: LONG,
    #[doc = " offset: 0xf4 (244)"]
    pub ApcAssociated: UCHAR,
    #[doc = " offset: 0xf5 (245)"]
    pub WakeTimer: UCHAR,
    #[doc = " offset: 0xf8 (248)"]
    pub WakeTimerListEntry: _LIST_ENTRY,
}
impl Default for _ETIMER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x98 (152) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LAZY_WRITER {
    #[doc = " offset: 0x0 (0)"]
    pub WorkQueue: _LIST_ENTRY,
    #[doc = " offset: 0x10 (16)"]
    pub ScanDpc: _KDPC,
    #[doc = " offset: 0x50 (80)"]
    pub ScanTimer: _KTIMER,
    #[doc = " offset: 0x90 (144)"]
    pub ScanActive: UCHAR,
    #[doc = " offset: 0x91 (145)"]
    pub OtherWork: UCHAR,
    #[doc = " offset: 0x92 (146)"]
    pub PendingTeardown: UCHAR,
}
impl Default for _LAZY_WRITER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x2d8 (728) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTRANSACTION {
    #[doc = " offset: 0x0 (0)"]
    pub OutcomeEvent: _KEVENT,
    #[doc = " offset: 0x18 (24)"]
    pub cookie: ULONG,
    #[doc = " offset: 0x20 (32)"]
    pub Mutex: _KMUTANT,
    #[doc = " offset: 0x58 (88)"]
    pub TreeTx: *mut _KTRANSACTION,
    #[doc = " offset: 0x60 (96)"]
    pub GlobalNamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = " offset: 0x88 (136)"]
    pub TmNamespaceLink: _KTMOBJECT_NAMESPACE_LINK,
    #[doc = " offset: 0xb0 (176)"]
    pub UOW: _GUID,
    #[doc = " offset: 0xc0 (192)"]
    pub State: _KTRANSACTION_STATE,
    #[doc = " offset: 0xc4 (196)"]
    pub Flags: ULONG,
    #[doc = " offset: 0xc8 (200)"]
    pub EnlistmentHead: _LIST_ENTRY,
    #[doc = " offset: 0xd8 (216)"]
    pub EnlistmentCount: ULONG,
    #[doc = " offset: 0xdc (220)"]
    pub RecoverableEnlistmentCount: ULONG,
    #[doc = " offset: 0xe0 (224)"]
    pub PrePrepareRequiredEnlistmentCount: ULONG,
    #[doc = " offset: 0xe4 (228)"]
    pub PrepareRequiredEnlistmentCount: ULONG,
    #[doc = " offset: 0xe8 (232)"]
    pub OutcomeRequiredEnlistmentCount: ULONG,
    #[doc = " offset: 0xec (236)"]
    pub PendingResponses: ULONG,
    #[doc = " offset: 0xf0 (240)"]
    pub SuperiorEnlistment: *mut _KENLISTMENT,
    #[doc = " offset: 0xf8 (248)"]
    pub LastLsn: _CLS_LSN,
    #[doc = " offset: 0x100 (256)"]
    pub PromotedEntry: _LIST_ENTRY,
    #[doc = " offset: 0x110 (272)"]
    pub PromoterTransaction: *mut _KTRANSACTION,
    #[doc = " offset: 0x118 (280)"]
    pub PromotePropagation: *mut VOID,
    #[doc = " offset: 0x120 (288)"]
    pub IsolationLevel: ULONG,
    #[doc = " offset: 0x124 (292)"]
    pub IsolationFlags: ULONG,
    #[doc = " offset: 0x128 (296)"]
    pub Timeout: _LARGE_INTEGER,
    #[doc = " offset: 0x130 (304)"]
    pub Description: _UNICODE_STRING,
    #[doc = " offset: 0x140 (320)"]
    pub RollbackThread: *mut _KTHREAD,
    #[doc = " offset: 0x148 (328)"]
    pub RollbackWorkItem: _WORK_QUEUE_ITEM,
    #[doc = " offset: 0x168 (360)"]
    pub RollbackDpc: _KDPC,
    #[doc = " offset: 0x1a8 (424)"]
    pub RollbackTimer: _KTIMER,
    #[doc = " offset: 0x1e8 (488)"]
    pub LsnOrderedEntry: _LIST_ENTRY,
    #[doc = " offset: 0x1f8 (504)"]
    pub Outcome: _KTRANSACTION_OUTCOME,
    #[doc = " offset: 0x200 (512)"]
    pub Tm: *mut _KTM,
    #[doc = " offset: 0x208 (520)"]
    pub CommitReservation: LONGLONG,
    #[doc = " offset: 0x210 (528)"]
    pub TransactionHistory: [_KTRANSACTION_HISTORY; 10usize],
    #[doc = " offset: 0x260 (608)"]
    pub TransactionHistoryCount: ULONG,
    #[doc = " offset: 0x268 (616)"]
    pub DTCPrivateInformation: *mut VOID,
    #[doc = " offset: 0x270 (624)"]
    pub DTCPrivateInformationLength: ULONG,
    #[doc = " offset: 0x278 (632)"]
    pub DTCPrivateInformationMutex: _KMUTANT,
    #[doc = " offset: 0x2b0 (688)"]
    pub PromotedTxSelfHandle: *mut VOID,
    #[doc = " offset: 0x2b8 (696)"]
    pub PendingPromotionCount: ULONG,
    #[doc = " offset: 0x2c0 (704)"]
    pub PromotionCompletedEvent: _KEVENT,
}
impl Default for _KTRANSACTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x330 (816) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD {
    #[doc = " offset: 0x0 (0)"]
    pub Header: _DISPATCHER_HEADER,
    #[doc = " offset: 0x18 (24)"]
    pub CycleTime: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub QuantumTarget: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub InitialStack: *mut VOID,
    #[doc = " offset: 0x30 (48)"]
    pub StackLimit: *mut VOID,
    #[doc = " offset: 0x38 (56)"]
    pub KernelStack: *mut VOID,
    #[doc = " offset: 0x40 (64)"]
    pub ThreadLock: ULONGLONG,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_1,
    #[doc = " offset: 0x78 (120)"]
    pub ApcQueueLock: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub WaitStatus: LONGLONG,
    pub __bindgen_anon_2: _KTHREAD__bindgen_ty_2,
    pub __bindgen_anon_3: _KTHREAD__bindgen_ty_3,
    #[doc = " offset: 0x94 (148)"]
    pub WaitReason: UCHAR,
    #[doc = " offset: 0x95 (149)"]
    pub SwapBusy: UCHAR,
    #[doc = " offset: 0x96 (150)"]
    pub Alerted: [UCHAR; 2usize],
    pub __bindgen_anon_4: _KTHREAD__bindgen_ty_4,
    #[doc = " offset: 0xa8 (168)"]
    pub Queue: *mut _KQUEUE,
    #[doc = " offset: 0xb0 (176)"]
    pub Teb: *mut VOID,
    pub __bindgen_anon_5: _KTHREAD__bindgen_ty_5,
    pub __bindgen_anon_6: _KTHREAD__bindgen_ty_6,
    #[doc = " offset: 0x1b8 (440)"]
    pub QueueListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x1c8 (456)"]
    pub TrapFrame: *mut _KTRAP_FRAME,
    #[doc = " offset: 0x1d0 (464)"]
    pub FirstArgument: *mut VOID,
    pub __bindgen_anon_7: _KTHREAD__bindgen_ty_7,
    #[doc = " offset: 0x1e0 (480)"]
    pub ApcStateIndex: UCHAR,
    #[doc = " offset: 0x1e1 (481)"]
    pub BasePriority: CHAR,
    #[doc = " offset: 0x1e2 (482)"]
    pub PriorityDecrement: CHAR,
    #[doc = " offset: 0x1e3 (483)"]
    pub Preempted: UCHAR,
    #[doc = " offset: 0x1e4 (484)"]
    pub AdjustReason: UCHAR,
    #[doc = " offset: 0x1e5 (485)"]
    pub AdjustIncrement: CHAR,
    #[doc = " offset: 0x1e6 (486)"]
    pub Spare01: UCHAR,
    #[doc = " offset: 0x1e7 (487)"]
    pub Saturation: CHAR,
    #[doc = " offset: 0x1e8 (488)"]
    pub SystemCallNumber: ULONG,
    #[doc = " offset: 0x1ec (492)"]
    pub FreezeCount: ULONG,
    #[doc = " offset: 0x1f0 (496)"]
    pub UserAffinity: ULONGLONG,
    #[doc = " offset: 0x1f8 (504)"]
    pub Process: *mut _KPROCESS,
    #[doc = " offset: 0x200 (512)"]
    pub Affinity: ULONGLONG,
    #[doc = " offset: 0x208 (520)"]
    pub ApcStatePointer: [*mut _KAPC_STATE; 2usize],
    pub __bindgen_anon_8: _KTHREAD__bindgen_ty_8,
    #[doc = " offset: 0x248 (584)"]
    pub Win32Thread: *mut VOID,
    #[doc = " offset: 0x250 (592)"]
    pub StackBase: *mut VOID,
    pub __bindgen_anon_9: _KTHREAD__bindgen_ty_9,
    pub __bindgen_anon_10: _KTHREAD__bindgen_ty_10,
    #[doc = " offset: 0x2d0 (720)"]
    pub ThreadListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x2e0 (736)"]
    pub MutantListHead: _LIST_ENTRY,
    #[doc = " offset: 0x2f0 (752)"]
    pub SListFaultAddress: *mut VOID,
    #[doc = " offset: 0x2f8 (760)"]
    pub ReadOperationCount: LONGLONG,
    #[doc = " offset: 0x300 (768)"]
    pub WriteOperationCount: LONGLONG,
    #[doc = " offset: 0x308 (776)"]
    pub OtherOperationCount: LONGLONG,
    #[doc = " offset: 0x310 (784)"]
    pub ReadTransferCount: LONGLONG,
    #[doc = " offset: 0x318 (792)"]
    pub WriteTransferCount: LONGLONG,
    #[doc = " offset: 0x320 (800)"]
    pub OtherTransferCount: LONGLONG,
    #[doc = " offset: 0x328 (808)"]
    pub MdlForLockedTeb: *mut VOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_1 {
    #[doc = " offset: 0x48 (72)"]
    pub ApcState: _KAPC_STATE,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x48 (72)"]
    pub ApcStateFill: [UCHAR; 43usize],
    #[doc = " offset: 0x73 (115)"]
    pub Priority: CHAR,
    #[doc = " offset: 0x74 (116)"]
    pub NextProcessor: USHORT,
    #[doc = " offset: 0x76 (118)"]
    pub DeferredProcessor: USHORT,
}
impl Default for _KTHREAD__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_2 {
    #[doc = " offset: 0x88 (136)"]
    pub WaitBlockList: *mut _KWAIT_BLOCK,
    #[doc = " offset: 0x88 (136)"]
    pub GateObject: *mut _KGATE,
}
impl Default for _KTHREAD__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_3 {
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_3__bindgen_ty_1,
    #[doc = " offset: 0x90 (144)"]
    pub MiscFlags: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KTHREAD__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn KernelStackResident(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelStackResident(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadyTransition(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadyTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessReadyQueue(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessReadyQueue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WaitNext(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WaitNext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemAffinityActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemAffinityActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Alertable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Alertable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GdiFlushActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GdiFlushActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserStackWalkActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserStackWalkActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelStackResident: ULONG,
        ReadyTransition: ULONG,
        ProcessReadyQueue: ULONG,
        WaitNext: ULONG,
        SystemAffinityActive: ULONG,
        Alertable: ULONG,
        GdiFlushActive: ULONG,
        UserStackWalkActive: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelStackResident: u32 = unsafe { ::std::mem::transmute(KernelStackResident) };
            KernelStackResident as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadyTransition: u32 = unsafe { ::std::mem::transmute(ReadyTransition) };
            ReadyTransition as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessReadyQueue: u32 = unsafe { ::std::mem::transmute(ProcessReadyQueue) };
            ProcessReadyQueue as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WaitNext: u32 = unsafe { ::std::mem::transmute(WaitNext) };
            WaitNext as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SystemAffinityActive: u32 = unsafe { ::std::mem::transmute(SystemAffinityActive) };
            SystemAffinityActive as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Alertable: u32 = unsafe { ::std::mem::transmute(Alertable) };
            Alertable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let GdiFlushActive: u32 = unsafe { ::std::mem::transmute(GdiFlushActive) };
            GdiFlushActive as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UserStackWalkActive: u32 = unsafe { ::std::mem::transmute(UserStackWalkActive) };
            UserStackWalkActive as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTHREAD__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_4 {
    #[doc = " offset: 0x98 (152)"]
    pub WaitListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x98 (152)"]
    pub SwapListEntry: _SINGLE_LIST_ENTRY,
}
impl Default for _KTHREAD__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_5 {
    #[doc = " offset: 0xb8 (184)"]
    pub Timer: _KTIMER,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_5__bindgen_ty_1 {
    #[doc = " offset: 0xb8 (184)"]
    pub TimerFill: [UCHAR; 60usize],
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0xf4 (244)"]
    pub ThreadFlags: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KTHREAD__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AutoAlignment(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AutoAlignment(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableBoost(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableBoost(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EtwStackTraceApc1Inserted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EtwStackTraceApc1Inserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EtwStackTraceApc2Inserted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EtwStackTraceApc2Inserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CycleChargePending(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CycleChargePending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CalloutActive(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CalloutActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ApcQueueable(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ApcQueueable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableStackSwap(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableStackSwap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuiThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuiThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AutoAlignment: ULONG,
        DisableBoost: ULONG,
        EtwStackTraceApc1Inserted: ULONG,
        EtwStackTraceApc2Inserted: ULONG,
        CycleChargePending: ULONG,
        CalloutActive: ULONG,
        ApcQueueable: ULONG,
        EnableStackSwap: ULONG,
        GuiThread: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AutoAlignment: u32 = unsafe { ::std::mem::transmute(AutoAlignment) };
            AutoAlignment as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableBoost: u32 = unsafe { ::std::mem::transmute(DisableBoost) };
            DisableBoost as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EtwStackTraceApc1Inserted: u32 =
                unsafe { ::std::mem::transmute(EtwStackTraceApc1Inserted) };
            EtwStackTraceApc1Inserted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EtwStackTraceApc2Inserted: u32 =
                unsafe { ::std::mem::transmute(EtwStackTraceApc2Inserted) };
            EtwStackTraceApc2Inserted as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CycleChargePending: u32 = unsafe { ::std::mem::transmute(CycleChargePending) };
            CycleChargePending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CalloutActive: u32 = unsafe { ::std::mem::transmute(CalloutActive) };
            CalloutActive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ApcQueueable: u32 = unsafe { ::std::mem::transmute(ApcQueueable) };
            ApcQueueable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EnableStackSwap: u32 = unsafe { ::std::mem::transmute(EnableStackSwap) };
            EnableStackSwap as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let GuiThread: u32 = unsafe { ::std::mem::transmute(GuiThread) };
            GuiThread as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _KTHREAD__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_6 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlock: [_KWAIT_BLOCK; 4usize],
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: _KTHREAD__bindgen_ty_6__bindgen_ty_2,
    pub __bindgen_anon_3: _KTHREAD__bindgen_ty_6__bindgen_ty_3,
    pub __bindgen_anon_4: _KTHREAD__bindgen_ty_6__bindgen_ty_4,
    pub __bindgen_anon_5: _KTHREAD__bindgen_ty_6__bindgen_ty_5,
    pub __bindgen_anon_6: _KTHREAD__bindgen_ty_6__bindgen_ty_6,
    pub __bindgen_anon_7: _KTHREAD__bindgen_ty_6__bindgen_ty_7,
    pub __bindgen_anon_8: _KTHREAD__bindgen_ty_6__bindgen_ty_8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_1 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill0: [UCHAR; 43usize],
    #[doc = " offset: 0x123 (291)"]
    pub IdealProcessor: UCHAR,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_2 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill1: [UCHAR; 91usize],
    #[doc = " offset: 0x153 (339)"]
    pub PreviousMode: CHAR,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_3 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill2: [UCHAR; 139usize],
    #[doc = " offset: 0x183 (387)"]
    pub ResourceIndex: UCHAR,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_4 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill3: [UCHAR; 187usize],
    #[doc = " offset: 0x1b3 (435)"]
    pub LargeStack: UCHAR,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_5 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill4: [UCHAR; 44usize],
    #[doc = " offset: 0x124 (292)"]
    pub ContextSwitches: ULONG,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_6 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill5: [UCHAR; 92usize],
    #[doc = " offset: 0x154 (340)"]
    pub State: UCHAR,
    #[doc = " offset: 0x155 (341)"]
    pub NpxState: UCHAR,
    #[doc = " offset: 0x156 (342)"]
    pub WaitIrql: UCHAR,
    #[doc = " offset: 0x157 (343)"]
    pub WaitMode: CHAR,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_7 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill6: [UCHAR; 140usize],
    #[doc = " offset: 0x184 (388)"]
    pub WaitTime: ULONG,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_8 {
    #[doc = " offset: 0xf8 (248)"]
    pub WaitBlockFill7: [UCHAR; 188usize],
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_6__bindgen_ty_8__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_6__bindgen_ty_8__bindgen_ty_1 {
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_6__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x1b4 (436)"]
    pub CombinedApcDisable: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_6__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x1b4 (436)"]
    pub KernelApcDisable: SHORT,
    #[doc = " offset: 0x1b6 (438)"]
    pub SpecialApcDisable: SHORT,
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_6__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_7 {
    #[doc = " offset: 0x1d8 (472)"]
    pub CallbackStack: *mut VOID,
    #[doc = " offset: 0x1d8 (472)"]
    pub CallbackDepth: ULONGLONG,
}
impl Default for _KTHREAD__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_8 {
    #[doc = " offset: 0x218 (536)"]
    pub SavedApcState: _KAPC_STATE,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_8__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_8__bindgen_ty_1 {
    #[doc = " offset: 0x218 (536)"]
    pub SavedApcStateFill: [UCHAR; 43usize],
    #[doc = " offset: 0x243 (579)"]
    pub Spare02: UCHAR,
    #[doc = " offset: 0x244 (580)"]
    pub SuspendCount: CHAR,
    #[doc = " offset: 0x245 (581)"]
    pub UserIdealProcessor: UCHAR,
    #[doc = " offset: 0x246 (582)"]
    pub Spare03: UCHAR,
    #[doc = " offset: 0x247 (583)"]
    pub CodePatchInProgress: UCHAR,
}
impl Default for _KTHREAD__bindgen_ty_8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_9 {
    #[doc = " offset: 0x258 (600)"]
    pub SuspendApc: _KAPC,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_9__bindgen_ty_1,
    pub __bindgen_anon_2: _KTHREAD__bindgen_ty_9__bindgen_ty_2,
    pub __bindgen_anon_3: _KTHREAD__bindgen_ty_9__bindgen_ty_3,
    pub __bindgen_anon_4: _KTHREAD__bindgen_ty_9__bindgen_ty_4,
    pub __bindgen_anon_5: _KTHREAD__bindgen_ty_9__bindgen_ty_5,
    pub __bindgen_anon_6: _KTHREAD__bindgen_ty_9__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_9__bindgen_ty_1 {
    #[doc = " offset: 0x258 (600)"]
    pub SuspendApcFill0: [UCHAR; 1usize],
    #[doc = " offset: 0x259 (601)"]
    pub Spare04: CHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_9__bindgen_ty_2 {
    #[doc = " offset: 0x258 (600)"]
    pub SuspendApcFill1: [UCHAR; 3usize],
    #[doc = " offset: 0x25b (603)"]
    pub QuantumReset: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_9__bindgen_ty_3 {
    #[doc = " offset: 0x258 (600)"]
    pub SuspendApcFill2: [UCHAR; 4usize],
    #[doc = " offset: 0x25c (604)"]
    pub KernelTime: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_9__bindgen_ty_4 {
    #[doc = " offset: 0x258 (600)"]
    pub SuspendApcFill3: [UCHAR; 64usize],
    #[doc = " offset: 0x298 (664)"]
    pub WaitPrcb: *mut _KPRCB,
}
impl Default for _KTHREAD__bindgen_ty_9__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_9__bindgen_ty_5 {
    #[doc = " offset: 0x258 (600)"]
    pub SuspendApcFill4: [UCHAR; 72usize],
    #[doc = " offset: 0x2a0 (672)"]
    pub LegoData: *mut VOID,
}
impl Default for _KTHREAD__bindgen_ty_9__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_9__bindgen_ty_6 {
    #[doc = " offset: 0x258 (600)"]
    pub SuspendApcFill5: [UCHAR; 83usize],
    #[doc = " offset: 0x2ab (683)"]
    pub PowerState: UCHAR,
    #[doc = " offset: 0x2ac (684)"]
    pub UserTime: ULONG,
}
impl Default for _KTHREAD__bindgen_ty_9__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTHREAD__bindgen_ty_10 {
    #[doc = " offset: 0x2b0 (688)"]
    pub SuspendSemaphore: _KSEMAPHORE,
    pub __bindgen_anon_1: _KTHREAD__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KTHREAD__bindgen_ty_10__bindgen_ty_1 {
    #[doc = " offset: 0x2b0 (688)"]
    pub SuspendSemaphorefill: [UCHAR; 28usize],
    #[doc = " offset: 0x2cc (716)"]
    pub SListFaultCount: ULONG,
}
impl Default for _KTHREAD__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KTHREAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x450 (1104) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETHREAD {
    #[doc = " offset: 0x0 (0)"]
    pub Tcb: _KTHREAD,
    #[doc = " offset: 0x330 (816)"]
    pub CreateTime: _LARGE_INTEGER,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_1,
    pub __bindgen_anon_2: _ETHREAD__bindgen_ty_2,
    pub __bindgen_anon_3: _ETHREAD__bindgen_ty_3,
    pub __bindgen_anon_4: _ETHREAD__bindgen_ty_4,
    #[doc = " offset: 0x368 (872)"]
    pub ActiveTimerListLock: ULONGLONG,
    #[doc = " offset: 0x370 (880)"]
    pub ActiveTimerListHead: _LIST_ENTRY,
    #[doc = " offset: 0x380 (896)"]
    pub Cid: _CLIENT_ID,
    pub __bindgen_anon_5: _ETHREAD__bindgen_ty_5,
    #[doc = " offset: 0x3b0 (944)"]
    pub ClientSecurity: _PS_CLIENT_SECURITY_CONTEXT,
    #[doc = " offset: 0x3b8 (952)"]
    pub IrpList: _LIST_ENTRY,
    #[doc = " offset: 0x3c8 (968)"]
    pub TopLevelIrp: ULONGLONG,
    #[doc = " offset: 0x3d0 (976)"]
    pub DeviceToVerify: *mut _DEVICE_OBJECT,
    #[doc = " offset: 0x3d8 (984)"]
    pub RateControlApc: *mut _PSP_RATE_APC,
    #[doc = " offset: 0x3e0 (992)"]
    pub Win32StartAddress: *mut VOID,
    #[doc = " offset: 0x3e8 (1000)"]
    pub SparePtr0: *mut VOID,
    #[doc = " offset: 0x3f0 (1008)"]
    pub ThreadListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x400 (1024)"]
    pub RundownProtect: _EX_RUNDOWN_REF,
    #[doc = " offset: 0x408 (1032)"]
    pub ThreadLock: _EX_PUSH_LOCK,
    #[doc = " offset: 0x410 (1040)"]
    pub ReadClusterSize: ULONG,
    #[doc = " offset: 0x414 (1044)"]
    pub MmLockOrdering: LONG,
    pub __bindgen_anon_6: _ETHREAD__bindgen_ty_6,
    pub __bindgen_anon_7: _ETHREAD__bindgen_ty_7,
    pub __bindgen_anon_8: _ETHREAD__bindgen_ty_8,
    #[doc = " offset: 0x424 (1060)"]
    pub CacheManagerActive: UCHAR,
    #[doc = " offset: 0x425 (1061)"]
    pub DisablePageFaultClustering: UCHAR,
    #[doc = " offset: 0x426 (1062)"]
    pub ActiveFaultCount: UCHAR,
    #[doc = " offset: 0x428 (1064)"]
    pub AlpcMessageId: ULONGLONG,
    pub __bindgen_anon_9: _ETHREAD__bindgen_ty_9,
    #[doc = " offset: 0x438 (1080)"]
    pub AlpcWaitListEntry: _LIST_ENTRY,
    #[doc = " offset: 0x448 (1096)"]
    pub CacheManagerCount: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_1 {
    #[doc = " offset: 0x338 (824)"]
    pub ExitTime: _LARGE_INTEGER,
    #[doc = " offset: 0x338 (824)"]
    pub KeyedWaitChain: _LIST_ENTRY,
}
impl Default for _ETHREAD__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_2 {
    #[doc = " offset: 0x348 (840)"]
    pub ExitStatus: LONG,
    #[doc = " offset: 0x348 (840)"]
    pub OfsChain: *mut VOID,
}
impl Default for _ETHREAD__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_3 {
    #[doc = " offset: 0x350 (848)"]
    pub PostBlockList: _LIST_ENTRY,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ETHREAD__bindgen_ty_3__bindgen_ty_1 {
    #[doc = " offset: 0x350 (848)"]
    pub ForwardLinkShadow: *mut VOID,
    #[doc = " offset: 0x358 (856)"]
    pub StartAddress: *mut VOID,
}
impl Default for _ETHREAD__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETHREAD__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_4 {
    #[doc = " offset: 0x360 (864)"]
    pub TerminationPort: *mut _TERMINATION_PORT,
    #[doc = " offset: 0x360 (864)"]
    pub ReaperLink: *mut _ETHREAD,
    #[doc = " offset: 0x360 (864)"]
    pub KeyedWaitValue: *mut VOID,
    #[doc = " offset: 0x360 (864)"]
    pub Win32StartParameter: *mut VOID,
}
impl Default for _ETHREAD__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_5 {
    #[doc = " offset: 0x390 (912)"]
    pub KeyedWaitSemaphore: _KSEMAPHORE,
    #[doc = " offset: 0x390 (912)"]
    pub AlpcWaitSemaphore: _KSEMAPHORE,
}
impl Default for _ETHREAD__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_6 {
    #[doc = " offset: 0x418 (1048)"]
    pub CrossThreadFlags: ULONG,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ETHREAD__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _ETHREAD__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn Terminated(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Terminated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadInserted(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadInserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HideFromDebugger(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HideFromDebugger(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ActiveImpersonationInfo(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ActiveImpersonationInfo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SystemThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardErrorsAreDisabled(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardErrorsAreDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BreakOnTermination(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BreakOnTermination(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipCreationMsg(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SkipCreationMsg(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipTerminationMsg(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SkipTerminationMsg(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyTokenOnOpen(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CopyTokenOnOpen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadIoPriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadIoPriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadPagePriority(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadPagePriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RundownFail(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RundownFail(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Terminated: ULONG,
        ThreadInserted: ULONG,
        HideFromDebugger: ULONG,
        ActiveImpersonationInfo: ULONG,
        SystemThread: ULONG,
        HardErrorsAreDisabled: ULONG,
        BreakOnTermination: ULONG,
        SkipCreationMsg: ULONG,
        SkipTerminationMsg: ULONG,
        CopyTokenOnOpen: ULONG,
        ThreadIoPriority: ULONG,
        ThreadPagePriority: ULONG,
        RundownFail: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Terminated: u32 = unsafe { ::std::mem::transmute(Terminated) };
            Terminated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ThreadInserted: u32 = unsafe { ::std::mem::transmute(ThreadInserted) };
            ThreadInserted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HideFromDebugger: u32 = unsafe { ::std::mem::transmute(HideFromDebugger) };
            HideFromDebugger as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ActiveImpersonationInfo: u32 =
                unsafe { ::std::mem::transmute(ActiveImpersonationInfo) };
            ActiveImpersonationInfo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SystemThread: u32 = unsafe { ::std::mem::transmute(SystemThread) };
            SystemThread as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let HardErrorsAreDisabled: u32 =
                unsafe { ::std::mem::transmute(HardErrorsAreDisabled) };
            HardErrorsAreDisabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BreakOnTermination: u32 = unsafe { ::std::mem::transmute(BreakOnTermination) };
            BreakOnTermination as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SkipCreationMsg: u32 = unsafe { ::std::mem::transmute(SkipCreationMsg) };
            SkipCreationMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SkipTerminationMsg: u32 = unsafe { ::std::mem::transmute(SkipTerminationMsg) };
            SkipTerminationMsg as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CopyTokenOnOpen: u32 = unsafe { ::std::mem::transmute(CopyTokenOnOpen) };
            CopyTokenOnOpen as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let ThreadIoPriority: u32 = unsafe { ::std::mem::transmute(ThreadIoPriority) };
            ThreadIoPriority as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let ThreadPagePriority: u32 = unsafe { ::std::mem::transmute(ThreadPagePriority) };
            ThreadPagePriority as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let RundownFail: u32 = unsafe { ::std::mem::transmute(RundownFail) };
            RundownFail as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETHREAD__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_7 {
    #[doc = " offset: 0x41c (1052)"]
    pub SameThreadPassiveFlags: ULONG,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_7__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ETHREAD__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _ETHREAD__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn ActiveExWorker(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ActiveExWorker(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExWorkerCanWaitUser(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExWorkerCanWaitUser(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MemoryMaker(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemoryMaker(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClonedThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ClonedThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KeyedEventInUse(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KeyedEventInUse(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RateApcState(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RateApcState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SelfTerminate(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SelfTerminate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActiveExWorker: ULONG,
        ExWorkerCanWaitUser: ULONG,
        MemoryMaker: ULONG,
        ClonedThread: ULONG,
        KeyedEventInUse: ULONG,
        RateApcState: ULONG,
        SelfTerminate: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ActiveExWorker: u32 = unsafe { ::std::mem::transmute(ActiveExWorker) };
            ActiveExWorker as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ExWorkerCanWaitUser: u32 = unsafe { ::std::mem::transmute(ExWorkerCanWaitUser) };
            ExWorkerCanWaitUser as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MemoryMaker: u32 = unsafe { ::std::mem::transmute(MemoryMaker) };
            MemoryMaker as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ClonedThread: u32 = unsafe { ::std::mem::transmute(ClonedThread) };
            ClonedThread as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let KeyedEventInUse: u32 = unsafe { ::std::mem::transmute(KeyedEventInUse) };
            KeyedEventInUse as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let RateApcState: u32 = unsafe { ::std::mem::transmute(RateApcState) };
            RateApcState as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SelfTerminate: u32 = unsafe { ::std::mem::transmute(SelfTerminate) };
            SelfTerminate as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETHREAD__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_8 {
    #[doc = " offset: 0x420 (1056)"]
    pub SameThreadApcFlags: ULONG,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_8__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ETHREAD__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = " offset: 0x423 (1059)"]
    pub PriorityRegionActive: UCHAR,
}
impl _ETHREAD__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn Spare(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StartAddressInvalid(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_StartAddressInvalid(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EtwPageFaultCalloutActive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EtwPageFaultCalloutActive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsProcessWorkingSetExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsProcessWorkingSetExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsProcessWorkingSetShared(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsProcessWorkingSetShared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsSystemWorkingSetExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsSystemWorkingSetExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsSystemWorkingSetShared(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsSystemWorkingSetShared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsSessionWorkingSetExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsSessionWorkingSetExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsSessionWorkingSetShared(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsSessionWorkingSetShared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsProcessAddressSpaceExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsProcessAddressSpaceExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsProcessAddressSpaceShared(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsProcessAddressSpaceShared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SuppressSymbolLoad(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SuppressSymbolLoad(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Prefetching(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Prefetching(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsDynamicMemoryShared(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsDynamicMemoryShared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsChangeControlAreaExclusive(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsChangeControlAreaExclusive(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnsChangeControlAreaShared(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OwnsChangeControlAreaShared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Spare: UCHAR,
        StartAddressInvalid: UCHAR,
        EtwPageFaultCalloutActive: UCHAR,
        OwnsProcessWorkingSetExclusive: UCHAR,
        OwnsProcessWorkingSetShared: UCHAR,
        OwnsSystemWorkingSetExclusive: UCHAR,
        OwnsSystemWorkingSetShared: UCHAR,
        OwnsSessionWorkingSetExclusive: UCHAR,
        OwnsSessionWorkingSetShared: UCHAR,
        OwnsProcessAddressSpaceExclusive: UCHAR,
        OwnsProcessAddressSpaceShared: UCHAR,
        SuppressSymbolLoad: UCHAR,
        Prefetching: UCHAR,
        OwnsDynamicMemoryShared: UCHAR,
        OwnsChangeControlAreaExclusive: UCHAR,
        OwnsChangeControlAreaShared: UCHAR,
        Spare1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Spare: u8 = unsafe { ::std::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let StartAddressInvalid: u8 = unsafe { ::std::mem::transmute(StartAddressInvalid) };
            StartAddressInvalid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EtwPageFaultCalloutActive: u8 =
                unsafe { ::std::mem::transmute(EtwPageFaultCalloutActive) };
            EtwPageFaultCalloutActive as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OwnsProcessWorkingSetExclusive: u8 =
                unsafe { ::std::mem::transmute(OwnsProcessWorkingSetExclusive) };
            OwnsProcessWorkingSetExclusive as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OwnsProcessWorkingSetShared: u8 =
                unsafe { ::std::mem::transmute(OwnsProcessWorkingSetShared) };
            OwnsProcessWorkingSetShared as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OwnsSystemWorkingSetExclusive: u8 =
                unsafe { ::std::mem::transmute(OwnsSystemWorkingSetExclusive) };
            OwnsSystemWorkingSetExclusive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OwnsSystemWorkingSetShared: u8 =
                unsafe { ::std::mem::transmute(OwnsSystemWorkingSetShared) };
            OwnsSystemWorkingSetShared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OwnsSessionWorkingSetExclusive: u8 =
                unsafe { ::std::mem::transmute(OwnsSessionWorkingSetExclusive) };
            OwnsSessionWorkingSetExclusive as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let OwnsSessionWorkingSetShared: u8 =
                unsafe { ::std::mem::transmute(OwnsSessionWorkingSetShared) };
            OwnsSessionWorkingSetShared as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let OwnsProcessAddressSpaceExclusive: u8 =
                unsafe { ::std::mem::transmute(OwnsProcessAddressSpaceExclusive) };
            OwnsProcessAddressSpaceExclusive as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let OwnsProcessAddressSpaceShared: u8 =
                unsafe { ::std::mem::transmute(OwnsProcessAddressSpaceShared) };
            OwnsProcessAddressSpaceShared as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let SuppressSymbolLoad: u8 = unsafe { ::std::mem::transmute(SuppressSymbolLoad) };
            SuppressSymbolLoad as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Prefetching: u8 = unsafe { ::std::mem::transmute(Prefetching) };
            Prefetching as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let OwnsDynamicMemoryShared: u8 =
                unsafe { ::std::mem::transmute(OwnsDynamicMemoryShared) };
            OwnsDynamicMemoryShared as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let OwnsChangeControlAreaExclusive: u8 =
                unsafe { ::std::mem::transmute(OwnsChangeControlAreaExclusive) };
            OwnsChangeControlAreaExclusive as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OwnsChangeControlAreaShared: u8 =
                unsafe { ::std::mem::transmute(OwnsChangeControlAreaShared) };
            OwnsChangeControlAreaShared as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Spare1: u8 = unsafe { ::std::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _ETHREAD__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_9 {
    #[doc = " offset: 0x430 (1072)"]
    pub AlpcMessage: *mut VOID,
    #[doc = " offset: 0x430 (1072)"]
    pub AlpcReceiveAttributeSet: ULONG,
}
impl Default for _ETHREAD__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ETHREAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x118 (280) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_POWER_STATE {
    #[doc = " offset: 0x0 (0)"]
    pub IdleStates: *mut _PPM_IDLE_STATES,
    #[doc = " offset: 0x8 (8)"]
    pub LastTimeCheck: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub IdleTimeAccumulated: ULONGLONG,
    pub __bindgen_anon_1: _PROCESSOR_POWER_STATE__bindgen_ty_1,
    #[doc = " offset: 0x20 (32)"]
    pub IdleAccounting: *mut PPM_IDLE_ACCOUNTING,
    #[doc = " offset: 0x28 (40)"]
    pub PerfStates: *mut _PPM_PERF_STATES,
    #[doc = " offset: 0x30 (48)"]
    pub LastKernelUserTime: ULONG,
    #[doc = " offset: 0x34 (52)"]
    pub LastIdleThreadKTime: ULONG,
    #[doc = " offset: 0x38 (56)"]
    pub LastGlobalTimeHv: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub LastProcessorTimeHv: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub ThermalConstraint: UCHAR,
    #[doc = " offset: 0x49 (73)"]
    pub LastBusyPercentage: UCHAR,
    #[doc = " offset: 0x4a (74)"]
    pub Flags: _PROCESSOR_POWER_STATE__bindgen_ty_2,
    #[doc = " offset: 0x50 (80)"]
    pub PerfTimer: _KTIMER,
    #[doc = " offset: 0x90 (144)"]
    pub PerfDpc: _KDPC,
    #[doc = " offset: 0xd0 (208)"]
    pub LastSysTime: ULONG,
    #[doc = " offset: 0xd8 (216)"]
    pub PStateMaster: *mut _KPRCB,
    #[doc = " offset: 0xe0 (224)"]
    pub PStateSet: ULONGLONG,
    #[doc = " offset: 0xe8 (232)"]
    pub CurrentPState: ULONG,
    #[doc = " offset: 0xec (236)"]
    pub DesiredPState: ULONG,
    #[doc = " offset: 0xf0 (240)"]
    pub PStateIdleStartTime: ULONG,
    #[doc = " offset: 0xf4 (244)"]
    pub PStateIdleTime: ULONG,
    #[doc = " offset: 0xf8 (248)"]
    pub LastPStateIdleTime: ULONG,
    #[doc = " offset: 0xfc (252)"]
    pub PStateStartTime: ULONG,
    #[doc = " offset: 0x100 (256)"]
    pub DiaIndex: ULONG,
    #[doc = " offset: 0x104 (260)"]
    pub Reserved0: ULONG,
    #[doc = " offset: 0x108 (264)"]
    pub WmiDispatchPtr: ULONGLONG,
    #[doc = " offset: 0x110 (272)"]
    pub WmiInterfaceEnabled: LONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESSOR_POWER_STATE__bindgen_ty_1 {
    #[doc = " offset: 0x18 (24)"]
    pub Native: _PROCESSOR_POWER_STATE__bindgen_ty_1__bindgen_ty_1,
    #[doc = " offset: 0x18 (24)"]
    pub Hv: _PROCESSOR_POWER_STATE__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PROCESSOR_POWER_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub IdleTransitionTime: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PROCESSOR_POWER_STATE__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " offset: 0x0 (0)"]
    pub LastIdleCheck: ULONGLONG,
}
impl Default for _PROCESSOR_POWER_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESSOR_POWER_STATE__bindgen_ty_2 {
    #[doc = " offset: 0x4a (74)"]
    pub AsUSHORT: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _PROCESSOR_POWER_STATE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _PROCESSOR_POWER_STATE__bindgen_ty_2 {
    #[inline]
    pub fn PStateDomain(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PStateDomain(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PStateDomainIdleAccounting(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PStateDomainIdleAccounting(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PStateDomain: USHORT,
        PStateDomainIdleAccounting: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PStateDomain: u16 = unsafe { ::std::mem::transmute(PStateDomain) };
            PStateDomain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PStateDomainIdleAccounting: u16 =
                unsafe { ::std::mem::transmute(PStateDomainIdleAccounting) };
            PStateDomainIdleAccounting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PROCESSOR_POWER_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x3b20 (15136) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPRCB {
    #[doc = " offset: 0x0 (0)"]
    pub MxCsr: ULONG,
    #[doc = " offset: 0x4 (4)"]
    pub Number: USHORT,
    #[doc = " offset: 0x6 (6)"]
    pub InterruptRequest: UCHAR,
    #[doc = " offset: 0x7 (7)"]
    pub IdleHalt: UCHAR,
    #[doc = " offset: 0x8 (8)"]
    pub CurrentThread: *mut _KTHREAD,
    #[doc = " offset: 0x10 (16)"]
    pub NextThread: *mut _KTHREAD,
    #[doc = " offset: 0x18 (24)"]
    pub IdleThread: *mut _KTHREAD,
    #[doc = " offset: 0x20 (32)"]
    pub NestingLevel: UCHAR,
    #[doc = " offset: 0x21 (33)"]
    pub Group: UCHAR,
    #[doc = " offset: 0x22 (34)"]
    pub PrcbPad00: [UCHAR; 6usize],
    #[doc = " offset: 0x28 (40)"]
    pub RspBase: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub PrcbLock: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub SetMember: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub ProcessorState: _KPROCESSOR_STATE,
    #[doc = " offset: 0x5f0 (1520)"]
    pub CpuType: CHAR,
    #[doc = " offset: 0x5f1 (1521)"]
    pub CpuID: CHAR,
    pub __bindgen_anon_1: _KPRCB__bindgen_ty_1,
    #[doc = " offset: 0x5f4 (1524)"]
    pub MHz: ULONG,
    #[doc = " offset: 0x5f8 (1528)"]
    pub HalReserved: [ULONGLONG; 8usize],
    #[doc = " offset: 0x638 (1592)"]
    pub MinorVersion: USHORT,
    #[doc = " offset: 0x63a (1594)"]
    pub MajorVersion: USHORT,
    #[doc = " offset: 0x63c (1596)"]
    pub BuildType: UCHAR,
    #[doc = " offset: 0x63d (1597)"]
    pub CpuVendor: UCHAR,
    #[doc = " offset: 0x63e (1598)"]
    pub CoresPerPhysicalProcessor: UCHAR,
    #[doc = " offset: 0x63f (1599)"]
    pub LogicalProcessorsPerCore: UCHAR,
    #[doc = " offset: 0x640 (1600)"]
    pub ApicMask: ULONG,
    #[doc = " offset: 0x644 (1604)"]
    pub CFlushSize: ULONG,
    #[doc = " offset: 0x648 (1608)"]
    pub AcpiReserved: *mut VOID,
    #[doc = " offset: 0x650 (1616)"]
    pub InitialApicId: ULONG,
    #[doc = " offset: 0x654 (1620)"]
    pub Stride: ULONG,
    #[doc = " offset: 0x658 (1624)"]
    pub PrcbPad01: [ULONGLONG; 3usize],
    #[doc = " offset: 0x670 (1648)"]
    pub LockQueue: [_KSPIN_LOCK_QUEUE; 49usize],
    #[doc = " offset: 0x980 (2432)"]
    pub PPLookasideList: [_PP_LOOKASIDE_LIST; 16usize],
    #[doc = " offset: 0xa80 (2688)"]
    pub PPNPagedLookasideList: [_GENERAL_LOOKASIDE_POOL; 32usize],
    #[doc = " offset: 0x1680 (5760)"]
    pub PPPagedLookasideList: [_GENERAL_LOOKASIDE_POOL; 32usize],
    #[doc = " offset: 0x2280 (8832)"]
    pub PacketBarrier: ULONGLONG,
    #[doc = " offset: 0x2288 (8840)"]
    pub DeferredReadyListHead: _SINGLE_LIST_ENTRY,
    #[doc = " offset: 0x2290 (8848)"]
    pub MmPageFaultCount: LONG,
    #[doc = " offset: 0x2294 (8852)"]
    pub MmCopyOnWriteCount: LONG,
    #[doc = " offset: 0x2298 (8856)"]
    pub MmTransitionCount: LONG,
    #[doc = " offset: 0x229c (8860)"]
    pub MmDemandZeroCount: LONG,
    #[doc = " offset: 0x22a0 (8864)"]
    pub MmPageReadCount: LONG,
    #[doc = " offset: 0x22a4 (8868)"]
    pub MmPageReadIoCount: LONG,
    #[doc = " offset: 0x22a8 (8872)"]
    pub MmDirtyPagesWriteCount: LONG,
    #[doc = " offset: 0x22ac (8876)"]
    pub MmDirtyWriteIoCount: LONG,
    #[doc = " offset: 0x22b0 (8880)"]
    pub MmMappedPagesWriteCount: LONG,
    #[doc = " offset: 0x22b4 (8884)"]
    pub MmMappedWriteIoCount: LONG,
    #[doc = " offset: 0x22b8 (8888)"]
    pub KeSystemCalls: ULONG,
    #[doc = " offset: 0x22bc (8892)"]
    pub KeContextSwitches: ULONG,
    #[doc = " offset: 0x22c0 (8896)"]
    pub CcFastReadNoWait: ULONG,
    #[doc = " offset: 0x22c4 (8900)"]
    pub CcFastReadWait: ULONG,
    #[doc = " offset: 0x22c8 (8904)"]
    pub CcFastReadNotPossible: ULONG,
    #[doc = " offset: 0x22cc (8908)"]
    pub CcCopyReadNoWait: ULONG,
    #[doc = " offset: 0x22d0 (8912)"]
    pub CcCopyReadWait: ULONG,
    #[doc = " offset: 0x22d4 (8916)"]
    pub CcCopyReadNoWaitMiss: ULONG,
    #[doc = " offset: 0x22d8 (8920)"]
    pub LookasideIrpFloat: LONG,
    #[doc = " offset: 0x22dc (8924)"]
    pub IoReadOperationCount: LONG,
    #[doc = " offset: 0x22e0 (8928)"]
    pub IoWriteOperationCount: LONG,
    #[doc = " offset: 0x22e4 (8932)"]
    pub IoOtherOperationCount: LONG,
    #[doc = " offset: 0x22e8 (8936)"]
    pub IoReadTransferCount: _LARGE_INTEGER,
    #[doc = " offset: 0x22f0 (8944)"]
    pub IoWriteTransferCount: _LARGE_INTEGER,
    #[doc = " offset: 0x22f8 (8952)"]
    pub IoOtherTransferCount: _LARGE_INTEGER,
    #[doc = " offset: 0x2300 (8960)"]
    pub TargetSet: ULONGLONG,
    #[doc = " offset: 0x2308 (8968)"]
    pub IpiFrozen: ULONG,
    #[doc = " offset: 0x230c (8972)"]
    pub PrcbPad3: [UCHAR; 116usize],
    #[doc = " offset: 0x2380 (9088)"]
    pub RequestMailbox: [_REQUEST_MAILBOX; 64usize],
    #[doc = " offset: 0x3380 (13184)"]
    pub SenderSummary: ULONGLONG,
    #[doc = " offset: 0x3388 (13192)"]
    pub PrcbPad4: [UCHAR; 120usize],
    #[doc = " offset: 0x3400 (13312)"]
    pub DpcData: [_KDPC_DATA; 2usize],
    #[doc = " offset: 0x3440 (13376)"]
    pub DpcStack: *mut VOID,
    #[doc = " offset: 0x3448 (13384)"]
    pub SparePtr0: *mut VOID,
    #[doc = " offset: 0x3450 (13392)"]
    pub MaximumDpcQueueDepth: LONG,
    #[doc = " offset: 0x3454 (13396)"]
    pub DpcRequestRate: ULONG,
    #[doc = " offset: 0x3458 (13400)"]
    pub MinimumDpcRate: ULONG,
    #[doc = " offset: 0x345c (13404)"]
    pub DpcInterruptRequested: UCHAR,
    #[doc = " offset: 0x345d (13405)"]
    pub DpcThreadRequested: UCHAR,
    #[doc = " offset: 0x345e (13406)"]
    pub DpcRoutineActive: UCHAR,
    #[doc = " offset: 0x345f (13407)"]
    pub DpcThreadActive: UCHAR,
    pub __bindgen_anon_2: _KPRCB__bindgen_ty_2,
    #[doc = " offset: 0x3468 (13416)"]
    pub TickOffset: LONG,
    #[doc = " offset: 0x346c (13420)"]
    pub MasterOffset: LONG,
    #[doc = " offset: 0x3470 (13424)"]
    pub DpcLastCount: ULONG,
    #[doc = " offset: 0x3474 (13428)"]
    pub ThreadDpcEnable: UCHAR,
    #[doc = " offset: 0x3475 (13429)"]
    pub QuantumEnd: UCHAR,
    #[doc = " offset: 0x3476 (13430)"]
    pub PrcbPad50: UCHAR,
    #[doc = " offset: 0x3477 (13431)"]
    pub IdleSchedule: UCHAR,
    #[doc = " offset: 0x3478 (13432)"]
    pub DpcSetEventRequest: LONG,
    #[doc = " offset: 0x347c (13436)"]
    pub KeExceptionDispatchCount: ULONG,
    #[doc = " offset: 0x3480 (13440)"]
    pub DpcEvent: _KEVENT,
    #[doc = " offset: 0x3498 (13464)"]
    pub PrcbPad51: *mut VOID,
    #[doc = " offset: 0x34a0 (13472)"]
    pub CallDpc: _KDPC,
    #[doc = " offset: 0x34e0 (13536)"]
    pub ClockKeepAlive: LONG,
    #[doc = " offset: 0x34e4 (13540)"]
    pub ClockCheckSlot: UCHAR,
    #[doc = " offset: 0x34e5 (13541)"]
    pub ClockPollCycle: UCHAR,
    #[doc = " offset: 0x34e6 (13542)"]
    pub PrcbPad6: [UCHAR; 2usize],
    #[doc = " offset: 0x34e8 (13544)"]
    pub DpcWatchdogPeriod: LONG,
    #[doc = " offset: 0x34ec (13548)"]
    pub DpcWatchdogCount: LONG,
    #[doc = " offset: 0x34f0 (13552)"]
    pub PrcbPad70: [ULONGLONG; 2usize],
    #[doc = " offset: 0x3500 (13568)"]
    pub WaitListHead: _LIST_ENTRY,
    #[doc = " offset: 0x3510 (13584)"]
    pub WaitLock: ULONGLONG,
    #[doc = " offset: 0x3518 (13592)"]
    pub ReadySummary: ULONG,
    #[doc = " offset: 0x351c (13596)"]
    pub QueueIndex: ULONG,
    #[doc = " offset: 0x3520 (13600)"]
    pub PrcbPad71: [ULONGLONG; 12usize],
    #[doc = " offset: 0x3580 (13696)"]
    pub DispatcherReadyListHead: [_LIST_ENTRY; 32usize],
    #[doc = " offset: 0x3780 (14208)"]
    pub InterruptCount: ULONG,
    #[doc = " offset: 0x3784 (14212)"]
    pub KernelTime: ULONG,
    #[doc = " offset: 0x3788 (14216)"]
    pub UserTime: ULONG,
    #[doc = " offset: 0x378c (14220)"]
    pub DpcTime: ULONG,
    #[doc = " offset: 0x3790 (14224)"]
    pub InterruptTime: ULONG,
    #[doc = " offset: 0x3794 (14228)"]
    pub AdjustDpcThreshold: ULONG,
    #[doc = " offset: 0x3798 (14232)"]
    pub SkipTick: UCHAR,
    #[doc = " offset: 0x3799 (14233)"]
    pub DebuggerSavedIRQL: UCHAR,
    #[doc = " offset: 0x379a (14234)"]
    pub PollSlot: UCHAR,
    #[doc = " offset: 0x379b (14235)"]
    pub PrcbPad80: [UCHAR; 5usize],
    #[doc = " offset: 0x37a0 (14240)"]
    pub DpcTimeCount: ULONG,
    #[doc = " offset: 0x37a4 (14244)"]
    pub DpcTimeLimit: ULONG,
    #[doc = " offset: 0x37a8 (14248)"]
    pub PeriodicCount: ULONG,
    #[doc = " offset: 0x37ac (14252)"]
    pub PeriodicBias: ULONG,
    #[doc = " offset: 0x37b0 (14256)"]
    pub PrcbPad81: [ULONGLONG; 2usize],
    #[doc = " offset: 0x37c0 (14272)"]
    pub ParentNode: *mut _KNODE,
    #[doc = " offset: 0x37c8 (14280)"]
    pub MultiThreadProcessorSet: ULONGLONG,
    #[doc = " offset: 0x37d0 (14288)"]
    pub MultiThreadSetMaster: *mut _KPRCB,
    #[doc = " offset: 0x37d8 (14296)"]
    pub StartCycles: ULONGLONG,
    #[doc = " offset: 0x37e0 (14304)"]
    pub MmSpinLockOrdering: LONG,
    #[doc = " offset: 0x37e4 (14308)"]
    pub PageColor: ULONG,
    #[doc = " offset: 0x37e8 (14312)"]
    pub NodeColor: ULONG,
    #[doc = " offset: 0x37ec (14316)"]
    pub NodeShiftedColor: ULONG,
    #[doc = " offset: 0x37f0 (14320)"]
    pub SecondaryColorMask: ULONG,
    #[doc = " offset: 0x37f4 (14324)"]
    pub Sleeping: LONG,
    #[doc = " offset: 0x37f8 (14328)"]
    pub CycleTime: ULONGLONG,
    #[doc = " offset: 0x3800 (14336)"]
    pub CcFastMdlReadNoWait: ULONG,
    #[doc = " offset: 0x3804 (14340)"]
    pub CcFastMdlReadWait: ULONG,
    #[doc = " offset: 0x3808 (14344)"]
    pub CcFastMdlReadNotPossible: ULONG,
    #[doc = " offset: 0x380c (14348)"]
    pub CcMapDataNoWait: ULONG,
    #[doc = " offset: 0x3810 (14352)"]
    pub CcMapDataWait: ULONG,
    #[doc = " offset: 0x3814 (14356)"]
    pub CcPinMappedDataCount: ULONG,
    #[doc = " offset: 0x3818 (14360)"]
    pub CcPinReadNoWait: ULONG,
    #[doc = " offset: 0x381c (14364)"]
    pub CcPinReadWait: ULONG,
    #[doc = " offset: 0x3820 (14368)"]
    pub CcMdlReadNoWait: ULONG,
    #[doc = " offset: 0x3824 (14372)"]
    pub CcMdlReadWait: ULONG,
    #[doc = " offset: 0x3828 (14376)"]
    pub CcLazyWriteHotSpots: ULONG,
    #[doc = " offset: 0x382c (14380)"]
    pub CcLazyWriteIos: ULONG,
    #[doc = " offset: 0x3830 (14384)"]
    pub CcLazyWritePages: ULONG,
    #[doc = " offset: 0x3834 (14388)"]
    pub CcDataFlushes: ULONG,
    #[doc = " offset: 0x3838 (14392)"]
    pub CcDataPages: ULONG,
    #[doc = " offset: 0x383c (14396)"]
    pub CcLostDelayedWrites: ULONG,
    #[doc = " offset: 0x3840 (14400)"]
    pub CcFastReadResourceMiss: ULONG,
    #[doc = " offset: 0x3844 (14404)"]
    pub CcCopyReadWaitMiss: ULONG,
    #[doc = " offset: 0x3848 (14408)"]
    pub CcFastMdlReadResourceMiss: ULONG,
    #[doc = " offset: 0x384c (14412)"]
    pub CcMapDataNoWaitMiss: ULONG,
    #[doc = " offset: 0x3850 (14416)"]
    pub CcMapDataWaitMiss: ULONG,
    #[doc = " offset: 0x3854 (14420)"]
    pub CcPinReadNoWaitMiss: ULONG,
    #[doc = " offset: 0x3858 (14424)"]
    pub CcPinReadWaitMiss: ULONG,
    #[doc = " offset: 0x385c (14428)"]
    pub CcMdlReadNoWaitMiss: ULONG,
    #[doc = " offset: 0x3860 (14432)"]
    pub CcMdlReadWaitMiss: ULONG,
    #[doc = " offset: 0x3864 (14436)"]
    pub CcReadAheadIos: ULONG,
    #[doc = " offset: 0x3868 (14440)"]
    pub MmCacheTransitionCount: LONG,
    #[doc = " offset: 0x386c (14444)"]
    pub MmCacheReadCount: LONG,
    #[doc = " offset: 0x3870 (14448)"]
    pub MmCacheIoCount: LONG,
    #[doc = " offset: 0x3874 (14452)"]
    pub PrcbPad91: [ULONG; 3usize],
    #[doc = " offset: 0x3880 (14464)"]
    pub PowerState: _PROCESSOR_POWER_STATE,
    #[doc = " offset: 0x3998 (14744)"]
    pub KeAlignmentFixupCount: ULONG,
    #[doc = " offset: 0x399c (14748)"]
    pub VendorString: [UCHAR; 13usize],
    #[doc = " offset: 0x39a9 (14761)"]
    pub PrcbPad10: [UCHAR; 3usize],
    #[doc = " offset: 0x39ac (14764)"]
    pub FeatureBits: ULONG,
    #[doc = " offset: 0x39b0 (14768)"]
    pub UpdateSignature: _LARGE_INTEGER,
    #[doc = " offset: 0x39b8 (14776)"]
    pub DpcWatchdogDpc: _KDPC,
    #[doc = " offset: 0x39f8 (14840)"]
    pub DpcWatchdogTimer: _KTIMER,
    #[doc = " offset: 0x3a38 (14904)"]
    pub Cache: [_CACHE_DESCRIPTOR; 5usize],
    #[doc = " offset: 0x3a74 (14964)"]
    pub CacheCount: ULONG,
    #[doc = " offset: 0x3a78 (14968)"]
    pub CachedCommit: ULONG,
    #[doc = " offset: 0x3a7c (14972)"]
    pub CachedResidentAvailable: ULONG,
    #[doc = " offset: 0x3a80 (14976)"]
    pub HyperPte: *mut VOID,
    #[doc = " offset: 0x3a88 (14984)"]
    pub WheaInfo: *mut VOID,
    #[doc = " offset: 0x3a90 (14992)"]
    pub EtwSupport: *mut VOID,
    #[doc = " offset: 0x3aa0 (15008)"]
    pub InterruptObjectPool: _SLIST_HEADER,
    #[doc = " offset: 0x3ab0 (15024)"]
    pub HypercallPageList: _SLIST_HEADER,
    #[doc = " offset: 0x3ac0 (15040)"]
    pub HypercallPageVirtual: *mut VOID,
    #[doc = " offset: 0x3ac8 (15048)"]
    pub VirtualApicAssist: *mut VOID,
    #[doc = " offset: 0x3ad0 (15056)"]
    pub StatisticsPage: *mut ULONGLONG,
    #[doc = " offset: 0x3ad8 (15064)"]
    pub RateControl: *mut VOID,
    #[doc = " offset: 0x3ae0 (15072)"]
    pub CacheProcessorMask: [ULONGLONG; 5usize],
    #[doc = " offset: 0x3b08 (15112)"]
    pub PackageProcessorSet: ULONGLONG,
    #[doc = " offset: 0x3b10 (15120)"]
    pub CoreProcessorSet: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPRCB__bindgen_ty_1 {
    #[doc = " offset: 0x5f2 (1522)"]
    pub CpuStep: USHORT,
    pub __bindgen_anon_1: _KPRCB__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KPRCB__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x5f2 (1522)"]
    pub CpuStepping: UCHAR,
    #[doc = " offset: 0x5f3 (1523)"]
    pub CpuModel: UCHAR,
}
impl Default for _KPRCB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPRCB__bindgen_ty_2 {
    #[doc = " offset: 0x3460 (13408)"]
    pub TimerHand: ULONGLONG,
    #[doc = " offset: 0x3460 (13408)"]
    pub TimerRequest: ULONGLONG,
}
impl Default for _KPRCB__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPRCB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x3ca0 (15520) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPCR {
    pub __bindgen_anon_1: _KPCR__bindgen_ty_1,
    #[doc = " offset: 0x38 (56)"]
    pub IdtBase: *mut _KIDTENTRY64,
    #[doc = " offset: 0x40 (64)"]
    pub Unused: [ULONGLONG; 2usize],
    #[doc = " offset: 0x50 (80)"]
    pub Irql: UCHAR,
    #[doc = " offset: 0x51 (81)"]
    pub SecondLevelCacheAssociativity: UCHAR,
    #[doc = " offset: 0x52 (82)"]
    pub ObsoleteNumber: UCHAR,
    #[doc = " offset: 0x53 (83)"]
    pub Fill0: UCHAR,
    #[doc = " offset: 0x54 (84)"]
    pub Unused0: [ULONG; 3usize],
    #[doc = " offset: 0x60 (96)"]
    pub MajorVersion: USHORT,
    #[doc = " offset: 0x62 (98)"]
    pub MinorVersion: USHORT,
    #[doc = " offset: 0x64 (100)"]
    pub StallScaleFactor: ULONG,
    #[doc = " offset: 0x68 (104)"]
    pub Unused1: [*mut VOID; 3usize],
    #[doc = " offset: 0x80 (128)"]
    pub KernelReserved: [ULONG; 15usize],
    #[doc = " offset: 0xbc (188)"]
    pub SecondLevelCacheSize: ULONG,
    #[doc = " offset: 0xc0 (192)"]
    pub HalReserved: [ULONG; 16usize],
    #[doc = " offset: 0x100 (256)"]
    pub Unused2: ULONG,
    #[doc = " offset: 0x108 (264)"]
    pub KdVersionBlock: *mut VOID,
    #[doc = " offset: 0x110 (272)"]
    pub Unused3: *mut VOID,
    #[doc = " offset: 0x118 (280)"]
    pub PcrAlign1: [ULONG; 24usize],
    #[doc = " offset: 0x180 (384)"]
    pub Prcb: _KPRCB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPCR__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub NtTib: _NT_TIB,
    pub __bindgen_anon_1: _KPCR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _KPCR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " offset: 0x0 (0)"]
    pub GdtBase: *mut _KGDTENTRY64,
    #[doc = " offset: 0x8 (8)"]
    pub TssBase: *mut _KTSS64,
    #[doc = " offset: 0x10 (16)"]
    pub UserRsp: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Self_: *mut _KPCR,
    #[doc = " offset: 0x20 (32)"]
    pub CurrentPrcb: *mut _KPRCB,
    #[doc = " offset: 0x28 (40)"]
    pub LockArray: *mut _KSPIN_LOCK_QUEUE,
    #[doc = " offset: 0x30 (48)"]
    pub Used_Self: *mut VOID,
}
impl Default for _KPCR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPCR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _KPCR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x10 (16) bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct LIST_ENTRY64 {
    #[doc = " offset: 0x0 (0)"]
    pub Flink: ULONGLONG,
    #[doc = " offset: 0x8 (8)"]
    pub Blink: ULONGLONG,
}
#[doc = " 0x368 (872) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEB64 {
    #[doc = " offset: 0x0 (0)"]
    pub InheritedAddressSpace: UCHAR,
    #[doc = " offset: 0x1 (1)"]
    pub ReadImageFileExecOptions: UCHAR,
    #[doc = " offset: 0x2 (2)"]
    pub BeingDebugged: UCHAR,
    pub __bindgen_anon_1: _PEB64__bindgen_ty_1,
    #[doc = " offset: 0x8 (8)"]
    pub Mutant: ULONGLONG,
    #[doc = " offset: 0x10 (16)"]
    pub ImageBaseAddress: ULONGLONG,
    #[doc = " offset: 0x18 (24)"]
    pub Ldr: ULONGLONG,
    #[doc = " offset: 0x20 (32)"]
    pub ProcessParameters: ULONGLONG,
    #[doc = " offset: 0x28 (40)"]
    pub SubSystemData: ULONGLONG,
    #[doc = " offset: 0x30 (48)"]
    pub ProcessHeap: ULONGLONG,
    #[doc = " offset: 0x38 (56)"]
    pub FastPebLock: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub AtlThunkSListPtr: ULONGLONG,
    #[doc = " offset: 0x48 (72)"]
    pub IFEOKey: ULONGLONG,
    pub __bindgen_anon_2: _PEB64__bindgen_ty_2,
    pub __bindgen_anon_3: _PEB64__bindgen_ty_3,
    #[doc = " offset: 0x60 (96)"]
    pub SystemReserved: [ULONG; 1usize],
    #[doc = " offset: 0x64 (100)"]
    pub SpareUlong: ULONG,
    #[doc = " offset: 0x68 (104)"]
    pub SparePebPtr0: ULONGLONG,
    #[doc = " offset: 0x70 (112)"]
    pub TlsExpansionCounter: ULONG,
    #[doc = " offset: 0x78 (120)"]
    pub TlsBitmap: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub TlsBitmapBits: [ULONG; 2usize],
    #[doc = " offset: 0x88 (136)"]
    pub ReadOnlySharedMemoryBase: ULONGLONG,
    #[doc = " offset: 0x90 (144)"]
    pub HotpatchInformation: ULONGLONG,
    #[doc = " offset: 0x98 (152)"]
    pub ReadOnlyStaticServerData: ULONGLONG,
    #[doc = " offset: 0xa0 (160)"]
    pub AnsiCodePageData: ULONGLONG,
    #[doc = " offset: 0xa8 (168)"]
    pub OemCodePageData: ULONGLONG,
    #[doc = " offset: 0xb0 (176)"]
    pub UnicodeCaseTableData: ULONGLONG,
    #[doc = " offset: 0xb8 (184)"]
    pub NumberOfProcessors: ULONG,
    #[doc = " offset: 0xbc (188)"]
    pub NtGlobalFlag: ULONG,
    #[doc = " offset: 0xc0 (192)"]
    pub CriticalSectionTimeout: _LARGE_INTEGER,
    #[doc = " offset: 0xc8 (200)"]
    pub HeapSegmentReserve: ULONGLONG,
    #[doc = " offset: 0xd0 (208)"]
    pub HeapSegmentCommit: ULONGLONG,
    #[doc = " offset: 0xd8 (216)"]
    pub HeapDeCommitTotalFreeThreshold: ULONGLONG,
    #[doc = " offset: 0xe0 (224)"]
    pub HeapDeCommitFreeBlockThreshold: ULONGLONG,
    #[doc = " offset: 0xe8 (232)"]
    pub NumberOfHeaps: ULONG,
    #[doc = " offset: 0xec (236)"]
    pub MaximumNumberOfHeaps: ULONG,
    #[doc = " offset: 0xf0 (240)"]
    pub ProcessHeaps: ULONGLONG,
    #[doc = " offset: 0xf8 (248)"]
    pub GdiSharedHandleTable: ULONGLONG,
    #[doc = " offset: 0x100 (256)"]
    pub ProcessStarterHelper: ULONGLONG,
    #[doc = " offset: 0x108 (264)"]
    pub GdiDCAttributeList: ULONG,
    #[doc = " offset: 0x110 (272)"]
    pub LoaderLock: ULONGLONG,
    #[doc = " offset: 0x118 (280)"]
    pub OSMajorVersion: ULONG,
    #[doc = " offset: 0x11c (284)"]
    pub OSMinorVersion: ULONG,
    #[doc = " offset: 0x120 (288)"]
    pub OSBuildNumber: USHORT,
    #[doc = " offset: 0x122 (290)"]
    pub OSCSDVersion: USHORT,
    #[doc = " offset: 0x124 (292)"]
    pub OSPlatformId: ULONG,
    #[doc = " offset: 0x128 (296)"]
    pub ImageSubsystem: ULONG,
    #[doc = " offset: 0x12c (300)"]
    pub ImageSubsystemMajorVersion: ULONG,
    #[doc = " offset: 0x130 (304)"]
    pub ImageSubsystemMinorVersion: ULONG,
    #[doc = " offset: 0x138 (312)"]
    pub ActiveProcessAffinityMask: ULONGLONG,
    #[doc = " offset: 0x140 (320)"]
    pub GdiHandleBuffer: [ULONG; 60usize],
    #[doc = " offset: 0x230 (560)"]
    pub PostProcessInitRoutine: ULONGLONG,
    #[doc = " offset: 0x238 (568)"]
    pub TlsExpansionBitmap: ULONGLONG,
    #[doc = " offset: 0x240 (576)"]
    pub TlsExpansionBitmapBits: [ULONG; 32usize],
    #[doc = " offset: 0x2c0 (704)"]
    pub SessionId: ULONG,
    #[doc = " offset: 0x2c8 (712)"]
    pub AppCompatFlags: _ULARGE_INTEGER,
    #[doc = " offset: 0x2d0 (720)"]
    pub AppCompatFlagsUser: _ULARGE_INTEGER,
    #[doc = " offset: 0x2d8 (728)"]
    pub pShimData: ULONGLONG,
    #[doc = " offset: 0x2e0 (736)"]
    pub AppCompatInfo: ULONGLONG,
    #[doc = " offset: 0x2e8 (744)"]
    pub CSDVersion: _STRING64,
    #[doc = " offset: 0x2f8 (760)"]
    pub ActivationContextData: ULONGLONG,
    #[doc = " offset: 0x300 (768)"]
    pub ProcessAssemblyStorageMap: ULONGLONG,
    #[doc = " offset: 0x308 (776)"]
    pub SystemDefaultActivationContextData: ULONGLONG,
    #[doc = " offset: 0x310 (784)"]
    pub SystemAssemblyStorageMap: ULONGLONG,
    #[doc = " offset: 0x318 (792)"]
    pub MinimumStackCommit: ULONGLONG,
    #[doc = " offset: 0x320 (800)"]
    pub FlsCallback: ULONGLONG,
    #[doc = " offset: 0x328 (808)"]
    pub FlsListHead: LIST_ENTRY64,
    #[doc = " offset: 0x338 (824)"]
    pub FlsBitmap: ULONGLONG,
    #[doc = " offset: 0x340 (832)"]
    pub FlsBitmapBits: [ULONG; 4usize],
    #[doc = " offset: 0x350 (848)"]
    pub FlsHighIndex: ULONG,
    #[doc = " offset: 0x358 (856)"]
    pub WerRegistrationData: ULONGLONG,
    #[doc = " offset: 0x360 (864)"]
    pub WerShipAssertPtr: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB64__bindgen_ty_1 {
    #[doc = " offset: 0x3 (3)"]
    pub BitField: UCHAR,
    pub __bindgen_anon_1: _PEB64__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PEB64__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PEB64__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ImageUsesLargePages(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ImageUsesLargePages(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsProtectedProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsProtectedProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsLegacyProcess(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsLegacyProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsImageDynamicallyRelocated(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsImageDynamicallyRelocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipPatchingUser32Forwarders(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SkipPatchingUser32Forwarders(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImageUsesLargePages: UCHAR,
        IsProtectedProcess: UCHAR,
        IsLegacyProcess: UCHAR,
        IsImageDynamicallyRelocated: UCHAR,
        SkipPatchingUser32Forwarders: UCHAR,
        SpareBits: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ImageUsesLargePages: u8 = unsafe { ::std::mem::transmute(ImageUsesLargePages) };
            ImageUsesLargePages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsProtectedProcess: u8 = unsafe { ::std::mem::transmute(IsProtectedProcess) };
            IsProtectedProcess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IsLegacyProcess: u8 = unsafe { ::std::mem::transmute(IsLegacyProcess) };
            IsLegacyProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IsImageDynamicallyRelocated: u8 =
                unsafe { ::std::mem::transmute(IsImageDynamicallyRelocated) };
            IsImageDynamicallyRelocated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SkipPatchingUser32Forwarders: u8 =
                unsafe { ::std::mem::transmute(SkipPatchingUser32Forwarders) };
            SkipPatchingUser32Forwarders as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let SpareBits: u8 = unsafe { ::std::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB64__bindgen_ty_2 {
    #[doc = " offset: 0x50 (80)"]
    pub CrossProcessFlags: ULONG,
    pub __bindgen_anon_1: _PEB64__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PEB64__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB64__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ProcessInJob(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInJob(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessInitializing(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessInitializing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVEH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ProcessUsingVCH(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedBits0(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedBits0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProcessInJob: ULONG,
        ProcessInitializing: ULONG,
        ProcessUsingVEH: ULONG,
        ProcessUsingVCH: ULONG,
        ReservedBits0: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProcessInJob: u32 = unsafe { ::std::mem::transmute(ProcessInJob) };
            ProcessInJob as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ProcessInitializing: u32 = unsafe { ::std::mem::transmute(ProcessInitializing) };
            ProcessInitializing as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessUsingVEH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVEH) };
            ProcessUsingVEH as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessUsingVCH: u32 = unsafe { ::std::mem::transmute(ProcessUsingVCH) };
            ProcessUsingVCH as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedBits0: u32 = unsafe { ::std::mem::transmute(ReservedBits0) };
            ReservedBits0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PEB64__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB64__bindgen_ty_3 {
    #[doc = " offset: 0x58 (88)"]
    pub KernelCallbackTable: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub UserSharedInfoPtr: ULONGLONG,
}
impl Default for _PEB64__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _PEB64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 0x1828 (6184) bytes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TEB64 {
    #[doc = " offset: 0x0 (0)"]
    pub NtTib: _NT_TIB64,
    #[doc = " offset: 0x38 (56)"]
    pub EnvironmentPointer: ULONGLONG,
    #[doc = " offset: 0x40 (64)"]
    pub ClientId: _CLIENT_ID64,
    #[doc = " offset: 0x50 (80)"]
    pub ActiveRpcHandle: ULONGLONG,
    #[doc = " offset: 0x58 (88)"]
    pub ThreadLocalStoragePointer: ULONGLONG,
    #[doc = " offset: 0x60 (96)"]
    pub ProcessEnvironmentBlock: ULONGLONG,
    #[doc = " offset: 0x68 (104)"]
    pub LastErrorValue: ULONG,
    #[doc = " offset: 0x6c (108)"]
    pub CountOfOwnedCriticalSections: ULONG,
    #[doc = " offset: 0x70 (112)"]
    pub CsrClientThread: ULONGLONG,
    #[doc = " offset: 0x78 (120)"]
    pub Win32ThreadInfo: ULONGLONG,
    #[doc = " offset: 0x80 (128)"]
    pub User32Reserved: [ULONG; 26usize],
    #[doc = " offset: 0xe8 (232)"]
    pub UserReserved: [ULONG; 5usize],
    #[doc = " offset: 0x100 (256)"]
    pub WOW32Reserved: ULONGLONG,
    #[doc = " offset: 0x108 (264)"]
    pub CurrentLocale: ULONG,
    #[doc = " offset: 0x10c (268)"]
    pub FpSoftwareStatusRegister: ULONG,
    #[doc = " offset: 0x110 (272)"]
    pub SystemReserved1: [ULONGLONG; 54usize],
    #[doc = " offset: 0x2c0 (704)"]
    pub ExceptionCode: LONG,
    #[doc = " offset: 0x2c8 (712)"]
    pub ActivationContextStackPointer: ULONGLONG,
    #[doc = " offset: 0x2d0 (720)"]
    pub SpareBytes1: [UCHAR; 24usize],
    #[doc = " offset: 0x2e8 (744)"]
    pub TxFsContext: ULONG,
    #[doc = " offset: 0x2f0 (752)"]
    pub GdiTebBatch: _GDI_TEB_BATCH64,
    #[doc = " offset: 0x7d8 (2008)"]
    pub RealClientId: _CLIENT_ID64,
    #[doc = " offset: 0x7e8 (2024)"]
    pub GdiCachedProcessHandle: ULONGLONG,
    #[doc = " offset: 0x7f0 (2032)"]
    pub GdiClientPID: ULONG,
    #[doc = " offset: 0x7f4 (2036)"]
    pub GdiClientTID: ULONG,
    #[doc = " offset: 0x7f8 (2040)"]
    pub GdiThreadLocalInfo: ULONGLONG,
    #[doc = " offset: 0x800 (2048)"]
    pub Win32ClientInfo: [ULONGLONG; 62usize],
    #[doc = " offset: 0x9f0 (2544)"]
    pub glDispatchTable: [ULONGLONG; 233usize],
    #[doc = " offset: 0x1138 (4408)"]
    pub glReserved1: [ULONGLONG; 29usize],
    #[doc = " offset: 0x1220 (4640)"]
    pub glReserved2: ULONGLONG,
    #[doc = " offset: 0x1228 (4648)"]
    pub glSectionInfo: ULONGLONG,
    #[doc = " offset: 0x1230 (4656)"]
    pub glSection: ULONGLONG,
    #[doc = " offset: 0x1238 (4664)"]
    pub glTable: ULONGLONG,
    #[doc = " offset: 0x1240 (4672)"]
    pub glCurrentRC: ULONGLONG,
    #[doc = " offset: 0x1248 (4680)"]
    pub glContext: ULONGLONG,
    #[doc = " offset: 0x1250 (4688)"]
    pub LastStatusValue: ULONG,
    #[doc = " offset: 0x1258 (4696)"]
    pub StaticUnicodeString: _STRING64,
    #[doc = " offset: 0x1268 (4712)"]
    pub StaticUnicodeBuffer: [WCHAR; 261usize],
    #[doc = " offset: 0x1478 (5240)"]
    pub DeallocationStack: ULONGLONG,
    #[doc = " offset: 0x1480 (5248)"]
    pub TlsSlots: [ULONGLONG; 64usize],
    #[doc = " offset: 0x1680 (5760)"]
    pub TlsLinks: LIST_ENTRY64,
    #[doc = " offset: 0x1690 (5776)"]
    pub Vdm: ULONGLONG,
    #[doc = " offset: 0x1698 (5784)"]
    pub ReservedForNtRpc: ULONGLONG,
    #[doc = " offset: 0x16a0 (5792)"]
    pub DbgSsReserved: [ULONGLONG; 2usize],
    #[doc = " offset: 0x16b0 (5808)"]
    pub HardErrorMode: ULONG,
    #[doc = " offset: 0x16b8 (5816)"]
    pub Instrumentation: [ULONGLONG; 11usize],
    #[doc = " offset: 0x1710 (5904)"]
    pub ActivityId: _GUID,
    #[doc = " offset: 0x1720 (5920)"]
    pub SubProcessTag: ULONGLONG,
    #[doc = " offset: 0x1728 (5928)"]
    pub EtwLocalData: ULONGLONG,
    #[doc = " offset: 0x1730 (5936)"]
    pub EtwTraceData: ULONGLONG,
    #[doc = " offset: 0x1738 (5944)"]
    pub WinSockData: ULONGLONG,
    #[doc = " offset: 0x1740 (5952)"]
    pub GdiBatchCount: ULONG,
    #[doc = " offset: 0x1744 (5956)"]
    pub SpareBool0: UCHAR,
    #[doc = " offset: 0x1745 (5957)"]
    pub SpareBool1: UCHAR,
    #[doc = " offset: 0x1746 (5958)"]
    pub SpareBool2: UCHAR,
    #[doc = " offset: 0x1747 (5959)"]
    pub IdealProcessor: UCHAR,
    #[doc = " offset: 0x1748 (5960)"]
    pub GuaranteedStackBytes: ULONG,
    #[doc = " offset: 0x1750 (5968)"]
    pub ReservedForPerf: ULONGLONG,
    #[doc = " offset: 0x1758 (5976)"]
    pub ReservedForOle: ULONGLONG,
    #[doc = " offset: 0x1760 (5984)"]
    pub WaitingOnLoaderLock: ULONG,
    #[doc = " offset: 0x1768 (5992)"]
    pub SavedPriorityState: ULONGLONG,
    #[doc = " offset: 0x1770 (6000)"]
    pub SoftPatchPtr1: ULONGLONG,
    #[doc = " offset: 0x1778 (6008)"]
    pub ThreadPoolData: ULONGLONG,
    #[doc = " offset: 0x1780 (6016)"]
    pub TlsExpansionSlots: ULONGLONG,
    #[doc = " offset: 0x1788 (6024)"]
    pub DeallocationBStore: ULONGLONG,
    #[doc = " offset: 0x1790 (6032)"]
    pub BStoreLimit: ULONGLONG,
    #[doc = " offset: 0x1798 (6040)"]
    pub ImpersonationLocale: ULONG,
    #[doc = " offset: 0x179c (6044)"]
    pub IsImpersonating: ULONG,
    #[doc = " offset: 0x17a0 (6048)"]
    pub NlsCache: ULONGLONG,
    #[doc = " offset: 0x17a8 (6056)"]
    pub pShimData: ULONGLONG,
    #[doc = " offset: 0x17b0 (6064)"]
    pub HeapVirtualAffinity: ULONG,
    #[doc = " offset: 0x17b8 (6072)"]
    pub CurrentTransactionHandle: ULONGLONG,
    #[doc = " offset: 0x17c0 (6080)"]
    pub ActiveFrame: ULONGLONG,
    #[doc = " offset: 0x17c8 (6088)"]
    pub FlsData: ULONGLONG,
    #[doc = " offset: 0x17d0 (6096)"]
    pub PreferredLanguages: ULONGLONG,
    #[doc = " offset: 0x17d8 (6104)"]
    pub UserPrefLanguages: ULONGLONG,
    #[doc = " offset: 0x17e0 (6112)"]
    pub MergedPrefLanguages: ULONGLONG,
    #[doc = " offset: 0x17e8 (6120)"]
    pub MuiImpersonation: ULONG,
    pub __bindgen_anon_1: _TEB64__bindgen_ty_1,
    pub __bindgen_anon_2: _TEB64__bindgen_ty_2,
    #[doc = " offset: 0x17f0 (6128)"]
    pub TxnScopeEnterCallback: ULONGLONG,
    #[doc = " offset: 0x17f8 (6136)"]
    pub TxnScopeExitCallback: ULONGLONG,
    #[doc = " offset: 0x1800 (6144)"]
    pub TxnScopeContext: ULONGLONG,
    #[doc = " offset: 0x1808 (6152)"]
    pub LockCount: ULONG,
    #[doc = " offset: 0x180c (6156)"]
    pub ProcessRundown: ULONG,
    #[doc = " offset: 0x1810 (6160)"]
    pub LastSwitchTime: ULONGLONG,
    #[doc = " offset: 0x1818 (6168)"]
    pub TotalSwitchOutTime: ULONGLONG,
    #[doc = " offset: 0x1820 (6176)"]
    pub WaitReasonBitMap: _LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB64__bindgen_ty_1 {
    #[doc = " offset: 0x17ec (6124)"]
    pub CrossTebFlags: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _TEB64__bindgen_ty_1 {
    #[inline]
    pub fn SpareCrossTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let SpareCrossTebBits: u16 = unsafe { ::std::mem::transmute(SpareCrossTebBits) };
            SpareCrossTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB64__bindgen_ty_2 {
    #[doc = " offset: 0x17ee (6126)"]
    pub SameTebFlags: USHORT,
    pub __bindgen_anon_1: _TEB64__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _TEB64__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB64__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn DbgSafeThunkCall(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSafeThunkCall(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgInDebugPrint(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgInDebugPrint(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgHasFiberData(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgHasFiberData(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSkipThreadAttach(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSkipThreadAttach(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgWerInShipAssertCode(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgWerInShipAssertCode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgRanProcessInit(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgRanProcessInit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgClonedThread(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgClonedThread(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DbgSuppressDebugMsg(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DbgSuppressDebugMsg(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlDisableUserStackWalk(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlDisableUserStackWalk(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtlExceptionAttached(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareSameTebBits(&self) -> USHORT {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgSafeThunkCall: USHORT,
        DbgInDebugPrint: USHORT,
        DbgHasFiberData: USHORT,
        DbgSkipThreadAttach: USHORT,
        DbgWerInShipAssertCode: USHORT,
        DbgRanProcessInit: USHORT,
        DbgClonedThread: USHORT,
        DbgSuppressDebugMsg: USHORT,
        RtlDisableUserStackWalk: USHORT,
        RtlExceptionAttached: USHORT,
        SpareSameTebBits: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgSafeThunkCall: u16 = unsafe { ::std::mem::transmute(DbgSafeThunkCall) };
            DbgSafeThunkCall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgInDebugPrint: u16 = unsafe { ::std::mem::transmute(DbgInDebugPrint) };
            DbgInDebugPrint as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgHasFiberData: u16 = unsafe { ::std::mem::transmute(DbgHasFiberData) };
            DbgHasFiberData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgSkipThreadAttach: u16 = unsafe { ::std::mem::transmute(DbgSkipThreadAttach) };
            DbgSkipThreadAttach as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgWerInShipAssertCode: u16 =
                unsafe { ::std::mem::transmute(DbgWerInShipAssertCode) };
            DbgWerInShipAssertCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgRanProcessInit: u16 = unsafe { ::std::mem::transmute(DbgRanProcessInit) };
            DbgRanProcessInit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgClonedThread: u16 = unsafe { ::std::mem::transmute(DbgClonedThread) };
            DbgClonedThread as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DbgSuppressDebugMsg: u16 = unsafe { ::std::mem::transmute(DbgSuppressDebugMsg) };
            DbgSuppressDebugMsg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RtlDisableUserStackWalk: u16 =
                unsafe { ::std::mem::transmute(RtlDisableUserStackWalk) };
            RtlDisableUserStackWalk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RtlExceptionAttached: u16 = unsafe { ::std::mem::transmute(RtlExceptionAttached) };
            RtlExceptionAttached as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let SpareSameTebBits: u16 = unsafe { ::std::mem::transmute(SpareSameTebBits) };
            SpareSameTebBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _TEB64__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _TEB64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
